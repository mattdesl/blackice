(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({"./index.js":[function(require,module,exports){
(function (global){
var app = require('canvas-app')(render, {
    context: 'webgl',
    contextAttributes: { antialias: false, alpha: false },
    retina: true,
    onResize: handleResize
})

var THREE = (typeof window !== "undefined" ? window.THREE : typeof global !== "undefined" ? global.THREE : null)
var Renderer = require('./lib/renderer')
var createFont = require('./lib/create-font')


var renderer

function render(gl, width, height, dt) {
    if (renderer)
        renderer.draw(dt)
}

function handleResize(width, height) {
    if (renderer)
        renderer.resize(width, height)
}

require('raf.js')
require('domready')(function() {
    document.body.style.margin = '0'
    document.body.style.overflow = 'hidden'
    app.canvas.style.display = 'block'

    document.body.appendChild(app.canvas)

    var gl = app.context
    createFont(gl, function(err, font) {
        if (err)
            console.error(err)

        renderer = Renderer({
            gl: gl, 
            width: app.width, 
            height: app.height,
            font: font
        }) 
        app.start()
    })
})





function setupSmoothTex(gl, t) {
    t.minFilter = gl.LINEAR_MIPMAP_LINEAR
    t.magFilter = gl.LINEAR

    var ext = (gl.getExtension('EXT_texture_filter_anisotropic') 
                    || gl.getExtension("MOZ_EXT_texture_filter_anisotropic"));
    if (ext) {
        var maxAnistrophy = gl.getParameter(ext.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
        gl.texParameterf(gl.TEXTURE_2D, ext.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(16, maxAnistrophy));
    }

    t.generateMipmap()
}

function setupNearestTex(gl, t) {
    t.minFilter = t.magFilter = gl.NEAREST
}
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./lib/create-font":"/projects/blackice/lib/create-font.js","./lib/renderer":"/projects/blackice/lib/renderer.js","canvas-app":"/projects/blackice/node_modules/canvas-app/index.js","domready":"/projects/blackice/node_modules/domready/ready.js","raf.js":"/projects/blackice/node_modules/raf.js/raf.js"}],"/projects/blackice/fonts/Exo2SemiBold.json":[function(require,module,exports){
module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports={"pages":["Exo2SemiBold.png"],"chars":[{"id":32,"x":0,"y":0,"width":0,"height":0,"xoffset":0,"yoffset":33,"xadvance":7,"page":0,"chnl":0},{"id":41,"x":0,"y":0,"width":20,"height":41,"xoffset":-4,"yoffset":3,"xadvance":12,"page":0,"chnl":0},{"id":40,"x":20,"y":0,"width":19,"height":41,"xoffset":-3,"yoffset":3,"xadvance":12,"page":0,"chnl":0},{"id":124,"x":39,"y":0,"width":13,"height":40,"xoffset":-2,"yoffset":3,"xadvance":8,"page":0,"chnl":0},{"id":125,"x":52,"y":0,"width":18,"height":40,"xoffset":-3,"yoffset":4,"xadvance":11,"page":0,"chnl":0},{"id":123,"x":70,"y":0,"width":18,"height":40,"xoffset":-3,"yoffset":4,"xadvance":11,"page":0,"chnl":0},{"id":36,"x":88,"y":0,"width":25,"height":39,"xoffset":-3,"yoffset":3,"xadvance":18,"page":0,"chnl":0},{"id":93,"x":113,"y":0,"width":17,"height":39,"xoffset":-3,"yoffset":4,"xadvance":11,"page":0,"chnl":0},{"id":91,"x":130,"y":0,"width":17,"height":39,"xoffset":-2,"yoffset":4,"xadvance":11,"page":0,"chnl":0},{"id":81,"x":147,"y":0,"width":28,"height":39,"xoffset":-3,"yoffset":6,"xadvance":22,"page":0,"chnl":0},{"id":106,"x":175,"y":0,"width":16,"height":38,"xoffset":-4,"yoffset":6,"xadvance":9,"page":0,"chnl":0},{"id":92,"x":191,"y":0,"width":26,"height":34,"xoffset":-4,"yoffset":6,"xadvance":17,"page":0,"chnl":0},{"id":47,"x":217,"y":0,"width":26,"height":34,"xoffset":-4,"yoffset":6,"xadvance":17,"page":0,"chnl":0},{"id":102,"x":243,"y":0,"width":23,"height":33,"xoffset":-4,"yoffset":5,"xadvance":13,"page":0,"chnl":0},{"id":38,"x":266,"y":0,"width":32,"height":32,"xoffset":-3,"yoffset":6,"xadvance":25,"page":0,"chnl":0},{"id":35,"x":298,"y":0,"width":30,"height":32,"xoffset":-3,"yoffset":6,"xadvance":22,"page":0,"chnl":0},{"id":37,"x":328,"y":0,"width":36,"height":32,"xoffset":-3,"yoffset":6,"xadvance":29,"page":0,"chnl":0},{"id":63,"x":364,"y":0,"width":24,"height":32,"xoffset":-3,"yoffset":6,"xadvance":16,"page":0,"chnl":0},{"id":33,"x":388,"y":0,"width":14,"height":32,"xoffset":-2,"yoffset":6,"xadvance":9,"page":0,"chnl":0},{"id":48,"x":402,"y":0,"width":26,"height":32,"xoffset":-3,"yoffset":6,"xadvance":20,"page":0,"chnl":0},{"id":57,"x":428,"y":0,"width":25,"height":32,"xoffset":-3,"yoffset":6,"xadvance":19,"page":0,"chnl":0},{"id":56,"x":453,"y":0,"width":26,"height":32,"xoffset":-3,"yoffset":6,"xadvance":20,"page":0,"chnl":0},{"id":55,"x":479,"y":0,"width":24,"height":32,"xoffset":-3,"yoffset":6,"xadvance":17,"page":0,"chnl":0},{"id":54,"x":0,"y":41,"width":26,"height":32,"xoffset":-3,"yoffset":6,"xadvance":19,"page":0,"chnl":0},{"id":53,"x":26,"y":41,"width":24,"height":32,"xoffset":-3,"yoffset":6,"xadvance":17,"page":0,"chnl":0},{"id":52,"x":50,"y":41,"width":27,"height":32,"xoffset":-3,"yoffset":6,"xadvance":20,"page":0,"chnl":0},{"id":51,"x":77,"y":41,"width":25,"height":32,"xoffset":-3,"yoffset":6,"xadvance":18,"page":0,"chnl":0},{"id":50,"x":102,"y":41,"width":25,"height":32,"xoffset":-3,"yoffset":6,"xadvance":18,"page":0,"chnl":0},{"id":49,"x":127,"y":41,"width":19,"height":32,"xoffset":-4,"yoffset":6,"xadvance":13,"page":0,"chnl":0},{"id":121,"x":146,"y":41,"width":27,"height":32,"xoffset":-4,"yoffset":12,"xadvance":17,"page":0,"chnl":0},{"id":113,"x":173,"y":41,"width":25,"height":32,"xoffset":-3,"yoffset":12,"xadvance":19,"page":0,"chnl":0},{"id":112,"x":198,"y":41,"width":25,"height":32,"xoffset":-2,"yoffset":12,"xadvance":19,"page":0,"chnl":0},{"id":108,"x":223,"y":41,"width":17,"height":32,"xoffset":-2,"yoffset":6,"xadvance":10,"page":0,"chnl":0},{"id":107,"x":240,"y":41,"width":24,"height":32,"xoffset":-2,"yoffset":6,"xadvance":17,"page":0,"chnl":0},{"id":105,"x":264,"y":41,"width":14,"height":32,"xoffset":-2,"yoffset":6,"xadvance":8,"page":0,"chnl":0},{"id":104,"x":278,"y":41,"width":24,"height":32,"xoffset":-2,"yoffset":6,"xadvance":19,"page":0,"chnl":0},{"id":103,"x":302,"y":41,"width":27,"height":32,"xoffset":-4,"yoffset":12,"xadvance":18,"page":0,"chnl":0},{"id":100,"x":329,"y":41,"width":25,"height":32,"xoffset":-3,"yoffset":6,"xadvance":19,"page":0,"chnl":0},{"id":98,"x":354,"y":41,"width":25,"height":32,"xoffset":-2,"yoffset":6,"xadvance":19,"page":0,"chnl":0},{"id":90,"x":379,"y":41,"width":25,"height":32,"xoffset":-3,"yoffset":6,"xadvance":18,"page":0,"chnl":0},{"id":89,"x":404,"y":41,"width":28,"height":32,"xoffset":-4,"yoffset":6,"xadvance":19,"page":0,"chnl":0},{"id":88,"x":432,"y":41,"width":29,"height":32,"xoffset":-4,"yoffset":6,"xadvance":20,"page":0,"chnl":0},{"id":87,"x":461,"y":41,"width":39,"height":32,"xoffset":-4,"yoffset":6,"xadvance":31,"page":0,"chnl":0},{"id":86,"x":0,"y":73,"width":29,"height":32,"xoffset":-4,"yoffset":6,"xadvance":20,"page":0,"chnl":0},{"id":85,"x":29,"y":73,"width":27,"height":32,"xoffset":-2,"yoffset":6,"xadvance":21,"page":0,"chnl":0},{"id":84,"x":56,"y":73,"width":28,"height":32,"xoffset":-4,"yoffset":6,"xadvance":19,"page":0,"chnl":0},{"id":83,"x":84,"y":73,"width":25,"height":32,"xoffset":-3,"yoffset":6,"xadvance":18,"page":0,"chnl":0},{"id":82,"x":109,"y":73,"width":26,"height":32,"xoffset":-2,"yoffset":6,"xadvance":20,"page":0,"chnl":0},{"id":80,"x":135,"y":73,"width":26,"height":32,"xoffset":-2,"yoffset":6,"xadvance":19,"page":0,"chnl":0},{"id":79,"x":161,"y":73,"width":28,"height":32,"xoffset":-3,"yoffset":6,"xadvance":22,"page":0,"chnl":0},{"id":78,"x":189,"y":73,"width":28,"height":32,"xoffset":-2,"yoffset":6,"xadvance":23,"page":0,"chnl":0},{"id":77,"x":217,"y":73,"width":34,"height":32,"xoffset":-2,"yoffset":6,"xadvance":29,"page":0,"chnl":0},{"id":76,"x":251,"y":73,"width":24,"height":32,"xoffset":-2,"yoffset":6,"xadvance":17,"page":0,"chnl":0},{"id":75,"x":275,"y":73,"width":27,"height":32,"xoffset":-2,"yoffset":6,"xadvance":20,"page":0,"chnl":0},{"id":74,"x":302,"y":73,"width":18,"height":32,"xoffset":-4,"yoffset":6,"xadvance":11,"page":0,"chnl":0},{"id":73,"x":320,"y":73,"width":14,"height":32,"xoffset":-2,"yoffset":6,"xadvance":9,"page":0,"chnl":0},{"id":72,"x":334,"y":73,"width":27,"height":32,"xoffset":-2,"yoffset":6,"xadvance":22,"page":0,"chnl":0},{"id":71,"x":361,"y":73,"width":27,"height":32,"xoffset":-3,"yoffset":6,"xadvance":20,"page":0,"chnl":0},{"id":70,"x":388,"y":73,"width":24,"height":32,"xoffset":-2,"yoffset":6,"xadvance":17,"page":0,"chnl":0},{"id":69,"x":412,"y":73,"width":24,"height":32,"xoffset":-2,"yoffset":6,"xadvance":18,"page":0,"chnl":0},{"id":68,"x":436,"y":73,"width":27,"height":32,"xoffset":-2,"yoffset":6,"xadvance":21,"page":0,"chnl":0},{"id":67,"x":463,"y":73,"width":26,"height":32,"xoffset":-3,"yoffset":6,"xadvance":19,"page":0,"chnl":0},{"id":66,"x":0,"y":105,"width":26,"height":32,"xoffset":-2,"yoffset":6,"xadvance":20,"page":0,"chnl":0},{"id":65,"x":26,"y":105,"width":30,"height":32,"xoffset":-4,"yoffset":6,"xadvance":20,"page":0,"chnl":0},{"id":64,"x":56,"y":105,"width":29,"height":31,"xoffset":-2,"yoffset":9,"xadvance":24,"page":0,"chnl":0},{"id":116,"x":85,"y":105,"width":22,"height":30,"xoffset":-4,"yoffset":8,"xadvance":13,"page":0,"chnl":0},{"id":59,"x":107,"y":105,"width":14,"height":29,"xoffset":-2,"yoffset":14,"xadvance":8,"page":0,"chnl":0},{"id":122,"x":121,"y":105,"width":24,"height":26,"xoffset":-3,"yoffset":12,"xadvance":17,"page":0,"chnl":0},{"id":120,"x":145,"y":105,"width":26,"height":26,"xoffset":-4,"yoffset":12,"xadvance":17,"page":0,"chnl":0},{"id":119,"x":171,"y":105,"width":36,"height":26,"xoffset":-4,"yoffset":12,"xadvance":27,"page":0,"chnl":0},{"id":118,"x":207,"y":105,"width":27,"height":26,"xoffset":-4,"yoffset":12,"xadvance":17,"page":0,"chnl":0},{"id":117,"x":234,"y":105,"width":24,"height":26,"xoffset":-2,"yoffset":12,"xadvance":19,"page":0,"chnl":0},{"id":115,"x":258,"y":105,"width":24,"height":26,"xoffset":-3,"yoffset":12,"xadvance":17,"page":0,"chnl":0},{"id":114,"x":282,"y":105,"width":20,"height":26,"xoffset":-2,"yoffset":12,"xadvance":13,"page":0,"chnl":0},{"id":111,"x":302,"y":105,"width":25,"height":26,"xoffset":-3,"yoffset":12,"xadvance":18,"page":0,"chnl":0},{"id":110,"x":327,"y":105,"width":24,"height":26,"xoffset":-2,"yoffset":12,"xadvance":19,"page":0,"chnl":0},{"id":109,"x":351,"y":105,"width":33,"height":26,"xoffset":-2,"yoffset":12,"xadvance":28,"page":0,"chnl":0},{"id":101,"x":384,"y":105,"width":25,"height":26,"xoffset":-3,"yoffset":12,"xadvance":18,"page":0,"chnl":0},{"id":99,"x":409,"y":105,"width":23,"height":26,"xoffset":-3,"yoffset":12,"xadvance":16,"page":0,"chnl":0},{"id":97,"x":432,"y":105,"width":24,"height":26,"xoffset":-3,"yoffset":12,"xadvance":18,"page":0,"chnl":0},{"id":43,"x":456,"y":105,"width":24,"height":24,"xoffset":-3,"yoffset":11,"xadvance":17,"page":0,"chnl":0},{"id":62,"x":480,"y":105,"width":23,"height":24,"xoffset":-2,"yoffset":12,"xadvance":17,"page":0,"chnl":0},{"id":60,"x":0,"y":137,"width":23,"height":24,"xoffset":-3,"yoffset":12,"xadvance":17,"page":0,"chnl":0},{"id":58,"x":23,"y":137,"width":14,"height":24,"xoffset":-3,"yoffset":14,"xadvance":8,"page":0,"chnl":0},{"id":42,"x":37,"y":137,"width":21,"height":21,"xoffset":-3,"yoffset":6,"xadvance":14,"page":0,"chnl":0},{"id":61,"x":58,"y":137,"width":24,"height":20,"xoffset":-2,"yoffset":13,"xadvance":19,"page":0,"chnl":0},{"id":94,"x":82,"y":137,"width":23,"height":19,"xoffset":-4,"yoffset":8,"xadvance":14,"page":0,"chnl":0},{"id":44,"x":105,"y":137,"width":14,"height":19,"xoffset":-3,"yoffset":24,"xadvance":8,"page":0,"chnl":0},{"id":39,"x":119,"y":137,"width":13,"height":17,"xoffset":-3,"yoffset":6,"xadvance":7,"page":0,"chnl":0},{"id":96,"x":132,"y":137,"width":18,"height":17,"xoffset":-4,"yoffset":5,"xadvance":11,"page":0,"chnl":0},{"id":34,"x":150,"y":137,"width":18,"height":17,"xoffset":-3,"yoffset":6,"xadvance":12,"page":0,"chnl":0},{"id":126,"x":168,"y":137,"width":22,"height":14,"xoffset":-2,"yoffset":17,"xadvance":17,"page":0,"chnl":0},{"id":46,"x":190,"y":137,"width":14,"height":14,"xoffset":-3,"yoffset":24,"xadvance":8,"page":0,"chnl":0},{"id":95,"x":204,"y":137,"width":24,"height":13,"xoffset":-2,"yoffset":28,"xadvance":18,"page":0,"chnl":0},{"id":45,"x":228,"y":137,"width":19,"height":13,"xoffset":-2,"yoffset":18,"xadvance":14,"page":0,"chnl":0}],"kernings":[],"info":{"face":"Exo 2 Semi Bold","size":32,"bold":0,"italic":0,"charset":"","unicode":0,"stretchH":100,"smooth":1,"aa":1,"padding":[4,4,4,4],"spacing":[-8,-8]},"common":{"lineHeight":40,"base":33,"scaleW":512,"scaleH":512,"pages":1,"packed":0}}
},{}],"/projects/blackice/lib/RigScene.js":[function(require,module,exports){
(function (global){
var THREE = (typeof window !== "undefined" ? window.THREE : typeof global !== "undefined" ? global.THREE : null)
var inherits = require('inherits')
var mixes = require('mixes')
var Base = THREE.Scene

var YOFF = 2.5

function RigScene(opt) {
    if (!(this instanceof RigScene))
        return new RigScene(opt)
    Base.call(this)
    this.fog = new THREE.FogExp2( 0x0b0516, 0.00015 );


    // var box = new THREE.Mesh(
    //     new THREE.BoxGeometry(20, 20, 10),
    //     new THREE.MeshBasicMaterial({ color: 0xaaaaaa, wireframe: false })
    // )

    // this.add(box)


    this.time = 0
    this.cubeMap = null
    this.updateMaterial()

    var loader = new THREE.OBJMTLLoader()
    loader.load('model/Prirazlomnaya.obj', 'model/Prirazlomnaya.mtl', function(object, materials) {
        var s = 0.3
        console.log(object, materials)
        object.scale.set(s,s,s)
        object.position.y -= YOFF
        this.mesh = object

        this.mesh.traverse(function(obj) {
            if (obj instanceof THREE.Mesh) {
                obj.castShadow = true
                obj.receiveShadow = true
                obj.material.shininess = 1
                // console.log(obj.material.uniforms)
            }
        })

        this.add(object)
    }.bind(this))
    

    // var geometry = new THREE.TorusKnotGeometry( 10, 3, 100, 16 );
    // var material = new THREE.MeshBasicMaterial( { color: 0xffff00 } );
    // var torusKnot = new THREE.Mesh( geometry, material );
    // this.add( torusKnot );
    // torusKnot.castShadow = true
    // torusKnot.receiveShadow = true

    this.lights = [
        [ new THREE.Vector3(-10, 20, -20), 1 ],
        [ new THREE.Vector3(15, 10, 15), 0.5 ]
    ].map(function(args, i) {
        var light = new THREE.DirectionalLight( 0xddf4fd, args[1] )
        light.position.copy(args[0])
        light.castShadow = true
        light.shadowMapWidth = 1024
        light.shadowMapHeight = 1024
        light.shadowCameraNear = 1
        light.shadowCameraFar = 100

        // light.helper = new THREE.DirectionalLightHelper(light, 4)
        // this.add(light.helper)
        this.add(light)
        return light
    },this)
}

inherits(RigScene, Base)

mixes(RigScene, {

    updateMaterial: function() {
        this.material = new THREE.MeshLambertMaterial({
            color: 0xaaaaaa,
            reflectivity: 0.4,
            envMap: this.cubeMap
        })

    },

    update: function(dt) {
        this.time += Math.min(dt, 30)/1000
        var m = this.mesh
        if (!m)
            return
        var anim = Math.sin(this.time)

        // this.lights.forEach(function(light) { light.helper.update() })
        // m.position.y = YOFF + anim*0.2
        // m.position.x = Math.sin(this.time*0.1)*0.05
        // m.position.z = Math.sin(this.time*0.2)*0.1
        // m.rotation.x = anim*0.03
        // m.rotation.y = Math.sin(this.time*Math.cos(this.time*0.1))*0.005
    }
})

module.exports = RigScene
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"inherits":"/projects/blackice/node_modules/inherits/inherits_browser.js","mixes":"/projects/blackice/node_modules/mixes/index.js"}],"/projects/blackice/lib/TextPass.js":[function(require,module,exports){
(function (global){
var THREE = (typeof window !== "undefined" ? window.THREE : typeof global !== "undefined" ? global.THREE : null);
var EffectComposer = require("three-effectcomposer")(THREE);
var inherits = require("inherits");
var Base = EffectComposer.RenderPass;
var plucker = require("plucker");
var number = require("as-number");
var TextElement = require("three-sdf-text")(THREE);
var xtend = require("xtend");
var UNIT_SCALE = 0.1;
var SCALE = [UNIT_SCALE, UNIT_SCALE, UNIT_SCALE];

var mat4 = {
    scale: require("gl-mat4/scale"),
    identity: require("gl-mat4/identity"),
    multiply: require("gl-mat4/multiply"),
    translate: require("gl-mat4/translate")
};

var setVec3 = require("gl-vec3/set");
var tmpVec3 = [0, 0, 0];
var pluckPanels = plucker("panels");
var glslify = require("glslify");
var createSDFShader = require("glslify/adapter.js")("\n#define GLSLIFY 1\n\nattribute vec4 position;\nattribute vec4 color;\nattribute vec2 texcoord0;\nuniform mat4 projection;\nuniform mat4 view;\nuniform mat4 model;\nvarying vec4 v_col;\nvarying vec2 v_tex0;\nvarying float animOffset;\nvoid main() {\n  gl_Position = projection * view * model * position;\n  v_col = color;\n  v_tex0 = texcoord0;\n  gl_PointSize = 1.0;\n  animOffset = position.x / 100.0;\n}", "\n#define GLSLIFY 1\n\n#ifdef GL_ES\n\nprecision mediump float;\n#endif\n\nvarying vec4 v_col;\nvarying vec2 v_tex0;\nvarying float animOffset;\nuniform sampler2D texture0;\nuniform sampler2D texture1;\nuniform float smoothing;\nuniform float fade;\nconst vec2 shadowOffset = vec2(-1.0 / 512.0);\nconst vec4 glowColor = vec4(vec3(0.1), 1.0);\nconst float glowMin = 0.4;\nconst float glowMax = 0.8;\nvoid main() {\n  float anim = fade * animOffset;\n  anim = clamp(mix(anim, 1.0, fade * fade), 0.0, 1.0);\n  vec4 smoothColor = vec4(0.0);\n  vec4 texColor = texture2D(texture0, v_tex0);\n  float dst = texColor.a;\n  float smoothAmt = mix(1.5, smoothing, anim);\n  float alpha = smoothstep(0.5 - smoothAmt, 0.5 + smoothAmt, dst);\n  vec4 base = v_col * vec4(alpha);\n  float glowDst = texture2D(texture0, v_tex0 + shadowOffset).a;\n  vec4 glow = glowColor * smoothstep(glowMin, glowMax, glowDst);\n  float mask = 1.0 - alpha;\n  gl_FragColor = mix(vec4(0.0), base, anim);\n  if(gl_FragColor.a < 0.1)\n    discard;\n  \n}", [{"name":"projection","type":"mat4"},{"name":"view","type":"mat4"},{"name":"model","type":"mat4"},{"name":"texture0","type":"sampler2D"},{"name":"texture1","type":"sampler2D"},{"name":"smoothing","type":"float"},{"name":"fade","type":"float"}], [{"name":"position","type":"vec4"},{"name":"color","type":"vec4"},{"name":"texcoord0","type":"vec2"}]);
var sdfShader;

function TextPass(opt) {
    if (!(this instanceof TextPass))
        return new TextPass(opt);

    opt = opt || {};
    var renderer = opt.renderer;
    var camera = opt.camera;
    var scene = opt.scene;
    Base.call(this, scene, camera);
    var font = opt.font;

    if (!sdfShader)
        sdfShader = createSDFShader(renderer.getContext());

    this.groups = (opt.groups || []).map(createGroups(renderer, font));
    window.groups = this.groups;
}

function createGroups(renderer, font) {
    return function(group, groupIndex) {
        group.elements = group.panels.map(function(panel, index) {
            var side = (index === 0 ? 1 : -1);

            return panel.labels.map(function(label) {
                return createElement(label, side, renderer, font);
            });
        }).reduce(function(prev, b) {
            return prev.concat(b);
        }, []);

        group._opacity = 1;
        group.fade = 1;
        group.showing = true;
        group.animatingOut = false;

        Object.defineProperty(group, "opacity", {
            get: function() {
                return group._opacity;
            },

            set: function(val) {
                group._opacity = val;

                group.elements.forEach(function(e) {
                    e.text.opacity = val;
                });

                group.panels.forEach(function(p) {
                    p.container.visible = val > 0.01;

                    p.shapes.forEach(function(shape) {
                        shape.material.opacity = val;
                        shape.visible = val > 0.01;
                    });
                });
            }
        });

        return group;
    };
}

function createElement(label, side, renderer, font) {
    var textOpt = xtend(label, {
        font: font,
        textures: font.textures,
        shader: sdfShader
    });

    var textEl = TextElement(renderer, textOpt);

    return xtend(label, {
        text: textEl,
        side: side
    });
}

function renderElement(camera, e, fade) {
    e.object3d.updateMatrixWorld(true);
    var transform = e.text.transform;
    mat4.identity(transform);
    mat4.scale(transform, transform, SCALE);
    setVec3(tmpVec3, e.translation[0], e.translation[1], e.translation[2]);
    mat4.translate(transform, transform, tmpVec3);
    setVec3(tmpVec3, e.size, e.size, e.size);
    mat4.scale(transform, transform, tmpVec3);
    e.text.shader.bind();
    e.text.shader.uniforms.fade = fade;
    e.text.draw(camera, e.object3d);
}

inherits(TextPass, Base);

TextPass.prototype.render = function(renderer, writeBuffer, readBuffer, delta) {
    Base.prototype.render.call(this, renderer, writeBuffer, readBuffer, delta);
    var camera = this.camera;

    this.groups.forEach(function(g) {
        g.elements.forEach(function(e) {
            if (!g.showing)
                return;

            renderElement(camera, e, g.fade);
        });
    });

    renderer.resetGLState();
    renderer.resetAttributes();
};

module.exports = TextPass;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"as-number":"/projects/blackice/node_modules/as-number/index.js","gl-mat4/identity":"/projects/blackice/node_modules/gl-mat4/identity.js","gl-mat4/multiply":"/projects/blackice/node_modules/gl-mat4/multiply.js","gl-mat4/scale":"/projects/blackice/node_modules/gl-mat4/scale.js","gl-mat4/translate":"/projects/blackice/node_modules/gl-mat4/translate.js","gl-vec3/set":"/projects/blackice/node_modules/gl-vec3/set.js","glslify":"/projects/blackice/node_modules/glslify/browser.js","glslify/adapter.js":"/projects/blackice/node_modules/glslify/adapter.js","inherits":"/projects/blackice/node_modules/inherits/inherits_browser.js","plucker":"/projects/blackice/node_modules/plucker/index.js","three-effectcomposer":"/projects/blackice/node_modules/three-effectcomposer/index.js","three-sdf-text":"/projects/blackice/node_modules/three-sdf-text/index.js","xtend":"/projects/blackice/node_modules/xtend/immutable.js"}],"/projects/blackice/lib/animate-labels.js":[function(require,module,exports){
(function (global){
var TweenMax = (typeof window !== "undefined" ? window.TweenMax : typeof global !== "undefined" ? global.TweenMax : null)
var clamp = require('clamp')
var smoothstep = require('smoothstep')

var lastIndex = -1

module.exports = function(controller, labels) {
    var closeIndex = closest(controller, labels)

    // console.log(controller.theta)
    labels.forEach(function(label, i) {
        // setShowing(label, true)
        var visible = i===closeIndex
        if (visible && !label.showing) {
            animateInFeature(label)
        } else if (!visible && label.showing) {
            animateOutFeature(label)
        }
    })
}

module.exports.hideAll = function(features) {
    features.forEach(function(f) {
        setShowing(f, false)
    })
}

function distance(controller, label) {
    //signed distance
    var x = -label.theta, 
        y = controller.theta

    var abdist = Math.abs(x - y)
    return Math.min((2 * Math.PI) - abdist, abdist)

}

function closest(controller, labels) {
    var minDist = Number.MAX_VALUE
    var ret = -1
    labels.forEach(function(label, index) {
        var dist = distance(controller, label)
        
        if (dist < minDist) {
            minDist = dist
            ret = index
        }
    })
    return ret
}

function setShowing(feature, showing) {
    feature.showing = showing
}

function animateInFeature(feature) {
    feature.showing = true
    feature.fade = 0
    TweenMax.killTweensOf(feature)
    TweenMax.to(feature, 0.5, {
        fade: 1.0,
        ease: "easeOutQuad"
    })
}

function animateOutFeature(feature) {
    if (feature.animatingOut)
        return

    feature.animatingOut = true
    TweenMax.to(feature, 0.5, {
        fade: 0,
        ease: 'easeOutQuad',
        onComplete: hideFeature.bind(null, feature)
    })
}

function hideFeature(feature) {
    feature.animatingOut = false
    feature.showing = false
}
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"clamp":"/projects/blackice/node_modules/clamp/index.js","smoothstep":"/projects/blackice/node_modules/smoothstep/index.js"}],"/projects/blackice/lib/create-font.js":[function(require,module,exports){
var Font = require('../fonts/Exo2SemiBold.json')
var fontImage = 'fonts/Exo2SemiBold.png'
var img = require('img')
var createTexture = require('gl-texture2d')

module.exports = function(gl, cb) {
    img(fontImage, function(err, res) {
        if (err) {
            cb(err)
            return
        }

        Font.textures = [res].map(function(i) {
            var t = createTexture(gl, i)

            t.minFilter = gl.LINEAR_MIPMAP_LINEAR
            t.magFilter = gl.LINEAR

            var ext = (gl.getExtension('EXT_texture_filter_anisotropic') 
                            || gl.getExtension("MOZ_EXT_texture_filter_anisotropic"));
            if (ext) {
                var maxAnistrophy = gl.getParameter(ext.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
                gl.texParameterf(gl.TEXTURE_2D, ext.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(16, maxAnistrophy));
            }

            t.generateMipmap()
            return t
        })
        
        cb(null, Font)
    })
}
},{"../fonts/Exo2SemiBold.json":"/projects/blackice/fonts/Exo2SemiBold.json","gl-texture2d":"/projects/blackice/node_modules/gl-texture2d/texture.js","img":"/projects/blackice/node_modules/img/index.js"}],"/projects/blackice/lib/create-text-pass.js":[function(require,module,exports){
(function (global){
var TextPass = require('./TextPass')
var THREE = (typeof window !== "undefined" ? window.THREE : typeof global !== "undefined" ? global.THREE : null)
var xtend = require('xtend')
var getSVG = require('./get-svg')
var getPoly = require('./get-polygon')
var Complex = require('three-simplicial-complex')(THREE)

var UNIT_SCALE = 0.1

var data = require('./text-data')

module.exports = function(opt) {
    var groups = createGroups()
    
    groups.forEach(function(group) {
        // var len = 100
        // var dir = new THREE.Vector3(Math.cos(group.theta), 0, Math.sin(group.theta))
        // var arrow = new THREE.ArrowHelper(dir, new THREE.Vector3(), len)
        // opt.scene.add(arrow)

        group.panels.forEach(function(panel) {
            opt.scene.add(panel.container)
        })
    })

    return TextPass(xtend(opt, {
        groups: groups
    }))
}

function createGroups() {
    return data.map(function(group, i, list) {
        var theta = i/(list.length+1) * Math.PI * 2
        group = xtend(group, {
            panels: group.panels.map(function(panel, index) {
                return createPanel(panel, index, theta)
            }),
            theta: theta
        })
        return group
    })
}

function createPanel(data, index, rotation) {
    var container = new THREE.Object3D()
    var mirror = index === 1

    var radius = 20
    if (mirror) {
        rotation += Math.PI*2
        radius *= -1
    }

    //make text perpendicular to theta rotation
    // rotation -= Math.PI/2 

    container.position.set(
        Math.cos(rotation) * radius,
        15,
        Math.sin(rotation) * radius
    )
    

    // container.position.copy(data.origin)

    var pos = container.position
    var dir = pos.clone().sub(new THREE.Vector3(0,pos.y,0)).normalize()

    var rotOff = 0//Math.PI/10 * (mirror ? -1 : 1)

    var dx = pos.x,
        dz = pos.z,
        theta = -Math.atan2(dz, dx) - rotOff
    // container.rotation.y = theta
    container.rotation.y = theta
    container.rotation.x = 0
    
    if (mirror) {
        container.scale.x *= -1
    }

    var labels = data.labels.map(function(label) {
        var obj = new THREE.Object3D()
        container.add(obj)
        if (mirror)
            obj.position.x = -data.width||0
        return xtend({ size: 1, translation: [0, 0, 0] }, label, { 
            object3d: obj, 
            // theta: theta
        })
    })

    var shapes = (data.shapes||[]).map(function(shape) {
        var complex = shape.path ? getSVG(shape.path) : getPoly(shape.points)
        var geo = Complex(complex)
        var mesh = new THREE.Mesh(geo, new THREE.MeshBasicMaterial({ 
            color: 0xffffff,
            side: THREE.DoubleSide,
            opacity: 1,
            transparent: true
        }))
        
        if (shape.position) mesh.position.fromArray(shape.position)
        if (shape.scale) mesh.scale.fromArray(shape.scale)

        container.add(mesh)
        return mesh
    })

    return {
        labels: labels,
        shapes: shapes,
        container: container
    }
}
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./TextPass":"/projects/blackice/lib/TextPass.js","./get-polygon":"/projects/blackice/lib/get-polygon.js","./get-svg":"/projects/blackice/lib/get-svg.js","./text-data":"/projects/blackice/lib/text-data.js","three-simplicial-complex":"/projects/blackice/node_modules/three-simplicial-complex/index.js","xtend":"/projects/blackice/node_modules/xtend/immutable.js"}],"/projects/blackice/lib/get-polygon.js":[function(require,module,exports){
var triangulate = require('triangulate-contours')
var normalize = require('normalize-path-scale')

module.exports = function(points) {
    points = points.split(' ').map(function(p) {
        return p.split(',').map(function(n) {
            return parseFloat(n, 10)
        })
    })

    points = normalize(points)

    var triangulated = triangulate([ points ])
    triangulated.positions = triangulated.positions.map(function(p) {
        return [p[0], p[1], 0]
    })
    return triangulated
}
},{"normalize-path-scale":"/projects/blackice/node_modules/normalize-path-scale/index.js","triangulate-contours":"/projects/blackice/node_modules/triangulate-contours/index.js"}],"/projects/blackice/lib/get-svg.js":[function(require,module,exports){
var parse = require('parse-svg-path')
var contours = require('svg-path-contours')
var simplify = require('simplify-path')
var triangulate = require('triangulate-contours')
var normalize = require('normalize-path-scale')

module.exports = function(contents) {
    var parsed = parse(contents)
    console.log(parsed, contents)
    //get a list of polylines/contours from svg contents
    var lines = contours(parsed)

    //simplify the contours before triangulation
    // lines = lines.map(function(path) {
    //     return simplify(path, threshold)
    // })
    
    //turns into triangles, returns { positions, cells }
    var shape = triangulate(lines)

    //normalize(shape.positions)

    shape.positions = shape.positions.map(function(p) {
        return [p[0], p[1], 0]
    })
    return shape
}
},{"normalize-path-scale":"/projects/blackice/node_modules/normalize-path-scale/index.js","parse-svg-path":"/projects/blackice/node_modules/parse-svg-path/index.js","simplify-path":"/projects/blackice/node_modules/simplify-path/index.js","svg-path-contours":"/projects/blackice/node_modules/svg-path-contours/index.js","triangulate-contours":"/projects/blackice/node_modules/triangulate-contours/index.js"}],"/projects/blackice/lib/renderer.js":[function(require,module,exports){
(function (global){
var THREE = (typeof window !== "undefined" ? window.THREE : typeof global !== "undefined" ? global.THREE : null)

var RigScene = require('./RigScene')
var OrbitController = require('./three-orbit-camera')(THREE)
var Effects = require('./setup-effects')

var TweenMax = (typeof window !== "undefined" ? window.TweenMax : typeof global !== "undefined" ? global.TweenMax : null)
var animateLabels = require('./animate-labels')
var hideLabels = animateLabels.hideAll

var clamp = require('clamp')
var pluck = require('plucker')
var number = require('as-number')
var smoothstep = require('smoothstep')

module.exports = function(opt) {
    opt = opt||{}

    var Font = opt.font

    if (!Font || !Font.textures)
        throw new Error('must specify font with textures')

    var renderer,
        scene,
        camera,
        controller,
        features,
        water,
        effects,
        labels = [],
        time = 0

    if (!opt.gl)
        throw new Error('must specify GL context')

    setup(opt.gl, opt.width||0, opt.height||0)

    function draw(dt) {
        time +=  Math.min(dt, 30) / 1000
        renderer.resetAttributes()
        renderer.resetGLState()

        water.material.uniforms.time.value = time * 0.1
        water.render()

        controller.update()
        
        scene.update(dt)
        effects.render(dt)

        animateLabels(controller, labels)
    }

    function setup(gl, width, height) {
        renderer = new THREE.WebGLRenderer({ 
            canvas: gl.canvas,
            antialias: false,
            alpha: false
        })
        renderer.setClearColor(0xffffff, 0)
        renderer.shadowMapType = THREE.BasicShadowMap
        // renderer.shadowMapEnabled = true

        opt.fov = number(opt.fov, 50)
        camera = new THREE.PerspectiveCamera(opt.fov, width/height, 0.5, 20000)
        camera.position.x = -60
        camera.position.z = -40
        camera.position.y = 20
        camera.lookAt(new THREE.Vector3())

        controller = new OrbitController(camera)
        controller.userPan = false
        controller.userPanSpeed = 0.0
        controller.zoomSpeed = 0.1
        controller.rotateSpeed = 0.2
        controller.minDistance = 30
        controller.maxDistance = 200.0
        controller.maxPolarAngle = 88 * Math.PI/180
        controller.minPolarAngle = 40 * Math.PI/180
        controller.center.set( 0, 5, 0 )
        scene = RigScene()

        water = require('./setup-water')(renderer, camera, scene)
        
        scene.cubeMap = water.cubeMap
        scene.updateMaterial()

        var pass = require('./create-text-pass')({
            renderer: renderer,
            scene: scene,
            camera: camera,
            font: Font
        })

        labels = pass.groups

        effects = Effects({
            renderer: renderer,
            scene: scene,
            camera: camera,
            width: width,
            blur: false,
            height: height,
            renderPass: pass
        })

        hideLabels(labels)
    }

    function handleResize(width, height) {
        renderer.setSize(width, height)
        camera.aspect = width/height
        camera.updateProjectionMatrix()

        effects.resize(width, height)
    }

    return {
        draw: draw,
        resize: handleResize
    }
}
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./RigScene":"/projects/blackice/lib/RigScene.js","./animate-labels":"/projects/blackice/lib/animate-labels.js","./create-text-pass":"/projects/blackice/lib/create-text-pass.js","./setup-effects":"/projects/blackice/lib/setup-effects.js","./setup-water":"/projects/blackice/lib/setup-water.js","./three-orbit-camera":"/projects/blackice/lib/three-orbit-camera/index.js","as-number":"/projects/blackice/node_modules/as-number/index.js","clamp":"/projects/blackice/node_modules/clamp/index.js","plucker":"/projects/blackice/node_modules/plucker/index.js","smoothstep":"/projects/blackice/node_modules/smoothstep/index.js"}],"/projects/blackice/lib/setup-effects.js":[function(require,module,exports){
(function (global){
var THREE = (typeof window !== "undefined" ? window.THREE : typeof global !== "undefined" ? global.THREE : null)
var EffectComposer = require('three-effectcomposer')(THREE)
var createFXAA = require('three-shader-fxaa')(THREE)
var createBlur = require('./shaders/blur')
var createLens = require('./shaders/lens')
var createEmpty = require('./shaders/pass')
// var TextPass = require('./TextPass')

module.exports = Effects

function Effects(opt) {
    if (!(this instanceof Effects)) 
        return new Effects(opt)
    opt = opt||{}


    var parameters = { 
        minFilter: THREE.LinearFilter, 
        magFilter: THREE.LinearFilter, 
        format: THREE.RGBFormat, 
        stencilBuffer: false 
    }
    var width = opt.width
    var height = opt.height
    var renderTarget = new THREE.WebGLRenderTarget(width, height, parameters);

    this.composer = new EffectComposer(opt.renderer, renderTarget)
    this.composer.addPass(opt.renderPass)
    
    this.shaders = []
    this.noiseDelay = 33
    this.noiseTime = 0

    // this.shaders.push(new EffectComposer.ShaderPass(createEmpty()))


    var fxaaShader = new EffectComposer.ShaderPass(createFXAA())
    this.shaders.push(fxaaShader)

    if (opt.blur !== false) {
        var blur = createBlur()
        var iterations = 1;
        for (var i=0; i<iterations; i++) {
            var r = (i+1)*2;

            var horiz = new EffectComposer.ShaderPass( blur );
            horiz.uniforms.radius.value = r
            horiz.uniforms.strength.value = 1
            horiz.uniforms.dir.value.set(1,0)

            var vert = new EffectComposer.ShaderPass( blur );
            vert.uniforms.radius.value = r
            vert.uniforms.strength.value = 1
            vert.uniforms.dir.value.set(0,1)

            this.shaders.push(horiz, vert)
        }
    }

    var lensPass = new EffectComposer.ShaderPass(createLens())
    this.shaders.push(lensPass)

    //default values to avoid div by zero
    lensPass.uniforms.overlayResolution.value.set(1, 1)
    lensPass.uniforms.tLookup.value = loadTexture('img/lookup.png', { 
        generateMipmaps: false,
        filter: THREE.LinearFilter 
    })
    lensPass.uniforms.tOverlay.value = loadTexture('img/dust.jpg', {
        generateMipmaps: false,
        filter: THREE.LinearFilter
    }, function(err, tex) {
        lensPass.uniforms.overlayResolution.value.set(tex.image.width, tex.image.height)
    })

    this.shaders.forEach(function(pass, i, self) {
        this.composer.addPass(pass)
        if (i === self.length-1)
            pass.renderToScreen = true
    }, this)  
    if (opt.width && opt.height) 
        this.resize(opt.width, opt.height)
}


function loadTexture(path, opt, cb) {
    if (typeof opt === 'function') {
        cb = opt
        opt = {}
    }

    return THREE.ImageUtils.loadTexture(path, undefined, function(tex) {
        if (opt.filter) tex.minFilter = tex.magFilter = opt.filter
        if (opt.wrap) tex.wrapS = tex.wrapT = opt.wrap
        tex.generateMipmaps = opt.generateMipmaps
        if (typeof cb === 'function') 
            cb(null, tex)
    })
}

require('mixes')(Effects, {

    render: function(dt) {
        this.noiseTime += dt
        if (this.noiseTime > this.noiseDelay) {
            this.noiseTime = 0
            this.shaders.forEach(function(pass) {
                if (pass.uniforms.tick)
                    pass.uniforms.tick.value += 0.005
            })
        }

        this.composer.render()
    },

    resize: function(width, height) {
        width *= 2
        height *= 2
        this.composer.setSize(width, height)
        this.shaders.forEach(function(pass) {
            var dpr = 1
            // var dpr = (window.devicePixelRatio||1)
            if (pass.uniforms.resolution)
                pass.uniforms.resolution.value.set(width*dpr, height*dpr)
            
        })
    }
})
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./shaders/blur":"/projects/blackice/lib/shaders/blur.js","./shaders/lens":"/projects/blackice/lib/shaders/lens.js","./shaders/pass":"/projects/blackice/lib/shaders/pass.js","mixes":"/projects/blackice/node_modules/mixes/index.js","three-effectcomposer":"/projects/blackice/node_modules/three-effectcomposer/index.js","three-shader-fxaa":"/projects/blackice/node_modules/three-shader-fxaa/index.js"}],"/projects/blackice/lib/setup-water.js":[function(require,module,exports){
var cubeShader = {

    uniforms: THREE.UniformsUtils.merge( [
        { "tCube": { type: "t", value: null },
        "tFlip": { type: "f", value: - 1 } },
        THREE.UniformsLib[ "fog" ]
    ] ),

    vertexShader: [

        "varying vec3 vWorldPosition;",

        THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

        "void main() {",

        "   vec4 worldPosition = modelMatrix * vec4( position, 1.0 );",
        "   vWorldPosition = worldPosition.xyz;",

        "   gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

            THREE.ShaderChunk[ "logdepthbuf_vertex" ],

        "}"

    ].join("\n"),

    fragmentShader: [

        "uniform samplerCube tCube;",
        "uniform float tFlip;",

        "varying vec3 vWorldPosition;",
        THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],
        THREE.ShaderChunk[ "fog_pars_fragment" ],
        "void main() {",
        "   gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );",
            THREE.ShaderChunk[ "logdepthbuf_fragment" ],
            THREE.ShaderChunk[ "fog_fragment" ],
        "}"

    ].join("\n")

}
module.exports = function(renderer, camera, scene) {
    var light = new THREE.HemisphereLight(0xbbe9ff, 0x080820, 1)
    light.position.set(-1, 1, -1)
    scene.add(light)

    var waterNormals = new THREE.ImageUtils.loadTexture('img/waternormals5.jpg')
    waterNormals.wrapS = waterNormals.wrapT = THREE.RepeatWrapping

    var water = new THREE.Water(renderer, camera, scene, {
        textureWidth: 512,
        textureHeight: 512,
        waterNormals: waterNormals,
        alpha: 0.9,
        sunDirection: light.position.clone().normalize(),
        sunColor: 0xffffff,
        waterColor: 0x020d15,
        distortionScale: 80.0,
    })

    var mirrorMesh = new THREE.Mesh(
        new THREE.PlaneBufferGeometry(5000, 5000),
        water.material
    )

    mirrorMesh.add(water)
    mirrorMesh.rotation.x = -Math.PI * 0.5
    scene.add(mirrorMesh)


    // load skybox

    var cubeMap = new THREE.CubeTexture([])
    cubeMap.format = THREE.RGBFormat
    cubeMap.flipY = false

    var loader = new THREE.ImageLoader()
    loader.load('img/cloudy_night2.jpg', function(image) {

        var getSide = function(x, y) {

            var size = 1024

            var canvas = document.createElement('canvas')
            canvas.width = size
            canvas.height = size

            var context = canvas.getContext('2d')
            context.drawImage(image, -x * size, -y * size)

            return canvas

        }

        cubeMap.images[0] = getSide(2, 1) // px
        cubeMap.images[1] = getSide(0, 1) // nx
        cubeMap.images[2] = getSide(1, 0) // py
        cubeMap.images[3] = getSide(1, 2) // ny
        cubeMap.images[4] = getSide(1, 1) // pz
        cubeMap.images[5] = getSide(3, 1) // nz
        cubeMap.needsUpdate = true

    })

    cubeShader.uniforms.tCube.value = cubeMap

    var skyBoxMaterial = new THREE.ShaderMaterial({
        fragmentShader: cubeShader.fragmentShader,
        vertexShader: cubeShader.vertexShader,
        uniforms: cubeShader.uniforms,
        // depthWrite: false,
        side: THREE.BackSide,
        fog: true,
    })

    var skyBox = new THREE.Mesh(
        new THREE.BoxGeometry(5000, 5000, 5000),
        skyBoxMaterial
    )
    
    water.cubeMap = cubeMap

    scene.add(skyBox)
    return water
}
},{}],"/projects/blackice/lib/shaders/blur.js":[function(require,module,exports){
var glslify = require("glslify");
var source = require("glslify/simple-adapter.js")("\n#define GLSLIFY 1\n\nvarying vec2 vUv;\nvoid main() {\n  vUv = uv;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}", "\n#define GLSLIFY 1\n\nuniform vec2 resolution;\nuniform float radius;\nuniform vec2 dir;\nuniform float strength;\nuniform sampler2D tDiffuse;\nvarying vec2 vUv;\nvec4 a_x_blur(sampler2D tex, vec2 uv, vec2 blur, vec2 direction) {\n  vec4 sum = vec4(0.0);\n  sum += texture2D(tex, vec2(uv.x - 4.0 * blur.x * direction.x, uv.y - 4.0 * blur.y * direction.y)) * 0.0162162162;\n  sum += texture2D(tex, vec2(uv.x - 3.0 * blur.x * direction.x, uv.y - 3.0 * blur.y * direction.y)) * 0.0540540541;\n  sum += texture2D(tex, vec2(uv.x - 2.0 * blur.x * direction.x, uv.y - 2.0 * blur.y * direction.y)) * 0.1216216216;\n  sum += texture2D(tex, vec2(uv.x - 1.0 * blur.x * direction.x, uv.y - 1.0 * blur.y * direction.y)) * 0.1945945946;\n  sum += texture2D(tex, vec2(uv.x, uv.y)) * 0.2270270270;\n  sum += texture2D(tex, vec2(uv.x + 1.0 * blur.x * direction.x, uv.y + 1.0 * blur.y * direction.y)) * 0.1945945946;\n  sum += texture2D(tex, vec2(uv.x + 2.0 * blur.x * direction.x, uv.y + 2.0 * blur.y * direction.y)) * 0.1216216216;\n  sum += texture2D(tex, vec2(uv.x + 3.0 * blur.x * direction.x, uv.y + 3.0 * blur.y * direction.y)) * 0.0540540541;\n  sum += texture2D(tex, vec2(uv.x + 4.0 * blur.x * direction.x, uv.y + 4.0 * blur.y * direction.y)) * 0.0162162162;\n  return sum;\n}\nvoid main() {\n  vec2 blurAmt = vec2(radius) / resolution;\n  vec4 sum = a_x_blur(tDiffuse, vUv, blurAmt, dir);\n  vec2 p = (gl_FragCoord.xy / resolution.xy - 0.5);\n  p.x *= resolution.x / resolution.y;\n  float len = smoothstep(0.5, 1.2, length(p));\n  vec3 orig = texture2D(tDiffuse, vUv).rgb;\n  gl_FragColor.rgb = mix(orig, sum.rgb, len + 0.1);\n  gl_FragColor.a = 1.0;\n}", [{"name":"resolution","type":"vec2"},{"name":"radius","type":"float"},{"name":"dir","type":"vec2"},{"name":"strength","type":"float"},{"name":"tDiffuse","type":"sampler2D"}], []);
module.exports = require("./create")(source);
},{"./create":"/projects/blackice/lib/shaders/create.js","glslify":"/projects/blackice/node_modules/glslify/browser.js","glslify/simple-adapter.js":"/projects/blackice/node_modules/glslify/simple-adapter.js"}],"/projects/blackice/lib/shaders/create.js":[function(require,module,exports){
(function (global){
var THREE = (typeof window !== "undefined" ? window.THREE : typeof global !== "undefined" ? global.THREE : null)
var threeify = require('three-glslify')(THREE)
var xtend = require('xtend') 
 
module.exports = function(source) {
    return function(opt) {
        return xtend(threeify(source), opt)
    }
}
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"three-glslify":"/projects/blackice/node_modules/three-glslify/index.js","xtend":"/projects/blackice/node_modules/xtend/immutable.js"}],"/projects/blackice/lib/shaders/lens.js":[function(require,module,exports){
var glslify = require("glslify");
var source = require("glslify/simple-adapter.js")("\n#define GLSLIFY 1\n\nuniform vec2 overlayResolution;\nuniform vec2 resolution;\nvarying vec2 vUv;\nvarying vec2 overlayUV;\nvoid main() {\n  vUv = uv;\n  float aspect = overlayResolution.x / overlayResolution.y;\n  float ratio = resolution.x / resolution.y;\n  overlayUV = uv;\n  float tAspect = overlayResolution.x / overlayResolution.y;\n  float pAspect = resolution.x / resolution.y;\n  overlayUV = uv;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}", "\n#define GLSLIFY 1\n\nuniform float tick;\nuniform sampler2D tDiffuse;\nuniform sampler2D tLookup;\nuniform sampler2D tOverlay;\nvarying vec2 vUv;\nvarying vec2 overlayUV;\nhighp float a_x_random(vec2 co) {\n  highp float a = 12.9898;\n  highp float b = 78.233;\n  highp float c = 43758.5453;\n  highp float dt = dot(co.xy, vec2(a, b));\n  highp float sn = mod(dt, 3.14);\n  return fract(sin(sn) * c);\n}\nvec3 b_x_blendOverlay(vec3 base, vec3 blend) {\n  return vec3(base.r < 0.5 ? (2.0 * base.r * blend.r) : (1.0 - 2.0 * (1.0 - base.r) * (1.0 - blend.r)), base.g < 0.5 ? (2.0 * base.g * blend.g) : (1.0 - 2.0 * (1.0 - base.g) * (1.0 - blend.g)), base.b < 0.5 ? (2.0 * base.b * blend.b) : (1.0 - 2.0 * (1.0 - base.b) * (1.0 - blend.b)));\n}\nfloat c_x_luma(vec3 color) {\n  return dot(color, vec3(0.299, 0.587, 0.114));\n}\nfloat c_x_luma(vec4 color) {\n  return dot(color.rgb, vec3(0.299, 0.587, 0.114));\n}\n#define LUT_FLIP_Y\n\nvec4 e_x_lookup(in vec4 textureColor, in sampler2D lookupTable) {\n  \n  #ifndef LUT_NO_CLAMP\n  textureColor = clamp(textureColor, 0.0, 1.0);\n  #endif\n  mediump float blueColor = textureColor.b * 63.0;\n  mediump vec2 quad1;\n  quad1.y = floor(floor(blueColor) / 8.0);\n  quad1.x = floor(blueColor) - (quad1.y * 8.0);\n  mediump vec2 quad2;\n  quad2.y = floor(ceil(blueColor) / 8.0);\n  quad2.x = ceil(blueColor) - (quad2.y * 8.0);\n  highp vec2 texPos1;\n  texPos1.x = (quad1.x * 0.125) + 0.5 / 512.0 + ((0.125 - 1.0 / 512.0) * textureColor.r);\n  texPos1.y = (quad1.y * 0.125) + 0.5 / 512.0 + ((0.125 - 1.0 / 512.0) * textureColor.g);\n  #ifdef LUT_FLIP_Y\n  texPos1.y = 1.0 - texPos1.y;\n  #endif\n  highp vec2 texPos2;\n  texPos2.x = (quad2.x * 0.125) + 0.5 / 512.0 + ((0.125 - 1.0 / 512.0) * textureColor.r);\n  texPos2.y = (quad2.y * 0.125) + 0.5 / 512.0 + ((0.125 - 1.0 / 512.0) * textureColor.g);\n  #ifdef LUT_FLIP_Y\n  texPos2.y = 1.0 - texPos2.y;\n  #endif\n  lowp vec4 newColor1 = texture2D(lookupTable, texPos1);\n  lowp vec4 newColor2 = texture2D(lookupTable, texPos2);\n  lowp vec4 newColor = mix(newColor1, newColor2, fract(blueColor));\n  return newColor;\n}\nvoid main() {\n  vec3 texColor = texture2D(tDiffuse, vUv).rgb;\n  float luminance = c_x_luma(texColor);\n  float noiseMap = smoothstep(luminance, 0.5, 0.0);\n  vec2 tUv = vUv + tick;\n  vec3 noise = vec3(a_x_random(tUv), a_x_random(tUv * 1.5), a_x_random(tUv * 0.5));\n  vec3 noiseColor = mix(noise, vec3(0.5), noiseMap);\n  vec3 color = mix(texColor, b_x_blendOverlay(texColor, noise), 0.15);\n  vec3 corrected = e_x_lookup(vec4(color, 1.0), tLookup).rgb;\n  color = mix(color, corrected, 0.9);\n  gl_FragColor = vec4(color, 1.0);\n  vec4 scratches = texture2D(tOverlay, overlayUV);\n  vec3 scratchBlend = gl_FragColor.rgb + scratches.rgb;\n  float center = smoothstep(0.0, 0.6, length(vUv - 0.5));\n  float dirtMap = smoothstep(0.1, 0.4, luminance * center);\n  gl_FragColor.rgb = mix(gl_FragColor.rgb, scratchBlend, dirtMap);\n}", [{"name":"overlayResolution","type":"vec2"},{"name":"resolution","type":"vec2"},{"name":"tick","type":"float"},{"name":"tDiffuse","type":"sampler2D"},{"name":"tLookup","type":"sampler2D"},{"name":"tOverlay","type":"sampler2D"}], []);
module.exports = require("./create")(source);
},{"./create":"/projects/blackice/lib/shaders/create.js","glslify":"/projects/blackice/node_modules/glslify/browser.js","glslify/simple-adapter.js":"/projects/blackice/node_modules/glslify/simple-adapter.js"}],"/projects/blackice/lib/shaders/pass.js":[function(require,module,exports){
var glslify = require("glslify");
var source = require("glslify/simple-adapter.js")("\n#define GLSLIFY 1\n\nvarying vec2 vUv;\nvoid main() {\n  vUv = uv;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}", "\n#define GLSLIFY 1\n\nuniform sampler2D tDiffuse;\nvarying vec2 vUv;\nvoid main() {\n  gl_FragColor = texture2D(tDiffuse, vUv);\n}", [{"name":"tDiffuse","type":"sampler2D"}], []);
module.exports = require("./create")(source);
},{"./create":"/projects/blackice/lib/shaders/create.js","glslify":"/projects/blackice/node_modules/glslify/browser.js","glslify/simple-adapter.js":"/projects/blackice/node_modules/glslify/simple-adapter.js"}],"/projects/blackice/lib/text-data.js":[function(require,module,exports){
(function (global){
var THREE = (typeof window !== "undefined" ? window.THREE : typeof global !== "undefined" ? global.THREE : null)
var lineHeight = 22
var big = 0.7
var small = 0.5

var panelWidth = 20
module.exports = [
    
    {
        name: 'tonnes',
        panels: [ {
            // origin: new THREE.Vector3(18, 10, 2),
            labels: [
                { text: 'each year Russia spills', size: small },
                { text: '5 million tonnes of oil', size: big, translation: [-2, -lineHeight, 0] },
            ]
        }, 
        {
            // origin: new THREE.Vector3(-20, 10, 2),
            width: panelWidth,
            labels: [
                { text: 'expected yearly output', size: small },
                { text: '6.6 million tonnes of oil', size: big, translation: [0, -lineHeight, 0] },
            ]
        } 
        ]
    },
    {
        name: 'top',
        panels: [ {
            labels: [
                { text: 'technologically obsolete', size: big },
                { text: 'physically unsafe', size: small, translation: [0, -lineHeight, 0] },
            ]
        },
        {
            width: panelWidth,
            labels: [
                { text: '18 years to construct', size: big },
                { text: 'using secondhand materials', size: small, translation: [0, -lineHeight, 0] },
            ]
        } ]
    },
    {
        name: 'nature',
        panels: [ {
            labels: [
                { text: '16hrs for oil spill to reach', size: big },
                { text: 'nature reserve 50km away', size: small, translation: [0, -lineHeight, 0] },
            ]
        },
        {
            width: panelWidth,
            labels: [
                { text: 'crucial breeding grounds', size: big },
                { text: 'for walrus, whales & polar bears', size: small, translation: [0, -lineHeight, 0] },
            ]
        } ]
    },
    {
        name: 'response',
        panels: [ {
            labels: [
                { text: 'large scale spill equipment', size: big },
                { text: '1000km (3 days sailing) away', size: small, translation: [0, -lineHeight, 0] },
            ]
        },
        {
            width: panelWidth*1.5,
            labels: [
                { text: 'previous response plan included', size: big },
                { text: '15 buckets and 3 axes', size: small, translation: [0, -lineHeight, 0] },
            ]
        } ]
    },
    {
        name: 'spill',
        panels: [ {
            labels: [
                { text: 'impossible to clean up', size: big },
                { text: 'an arctic oil spill', size: small, translation: [0, -lineHeight, 0] },
            ]
        },
        {
            width: panelWidth,
            labels: [
                { text: 'oil spills are inevitable', size: big },
                { text: 'response plan not public', size: small, translation: [0, -lineHeight, 0] },
            ]
        } ]
    },
    {
        name: 'weather',
        panels: [ {
            labels: [
                { text: 'as cold as -50c / 122f', size: big },
                { text: 'iced in 8 months per year', size: small, translation: [0, -lineHeight, 0] },
            ]
        },
        {
            width: panelWidth,
            labels: [
                { text: 'plagued by bad weather', size: big },
                { text: 'waves reach up to 12m', size: small, translation: [0, -lineHeight, 0] },
            ]
        } ]
    },
]

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],"/projects/blackice/lib/three-orbit-camera/index.js":[function(require,module,exports){
(function (global){
var inherits = require('inherits')
var TweenMax = (typeof window !== "undefined" ? window.TweenMax : typeof global !== "undefined" ? global.TweenMax : null)

module.exports = function(THREE) {
    if (!THREE.MOUSE)
        THREE.MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };

    /**
     * @author qiao / https://github.com/qiao
     * @author mrdoob / http://mrdoob.com
     * @author alteredq / http://alteredqualia.com/
     * @author WestLangley / http://github.com/WestLangley
     * @author erich666 / http://erichaines.com
     */
    /*global THREE, console */

    // This set of controls performs orbiting, dollying (zooming), and panning. It maintains
    // the "up" direction as +Y, unlike the TrackballControls. Touch on tablet and phones is
    // supported.
    //
    //    Orbit - left mouse / touch: one finger move
    //    Zoom - middle mouse, or mousewheel / touch: two finger spread or squish
    //    Pan - right mouse, or arrow keys / touch: three finter swipe
    //
    // This is a drop-in replacement for (most) TrackballControls used in examples.
    // That is, include this js file and wherever you see:
    //      controls = new THREE.TrackballControls( camera );
    //      controls.target.z = 150;
    // Simple substitute "OrbitControls" and the control should work as-is.

    function OrbitControls( object, domElement ) {

        this.object = object;
        this.domElement = ( domElement !== undefined ) ? domElement : document;

        // API

        // Set to false to disable this control
        this.enabled = true;

        // "target" sets the location of focus, where the control orbits around
        // and where it pans with respect to.
        this.target = new THREE.Vector3();

        // center is old, deprecated; use "target" instead
        this.center = this.target;

        // This option actually enables dollying in and out; left as "zoom" for
        // backwards compatibility
        this.noZoom = false;
        this.zoomSpeed = 1.0;

        // Limits to how far you can dolly in and out
        this.minDistance = 0;
        this.maxDistance = Infinity;

        // Set to true to disable this control
        this.noRotate = false;
        this.rotateSpeed = 1.0;

        // Set to true to disable this control
        this.noPan = false;
        this.keyPanSpeed = 7.0; // pixels moved per arrow key push

        // Set to true to automatically rotate around the target
        this.autoRotate = false;
        this.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60

        // How far you can orbit vertically, upper and lower limits.
        // Range is 0 to Math.PI radians.
        this.minPolarAngle = 0; // radians
        this.maxPolarAngle = Math.PI; // radians

        // Set to true to disable use of the keys
        this.noKeys = false;

        this.phi = 0
        this.theta = 0 

        // The four arrow keys
        this.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 };

        this.constrainDelta = { x: 0, y: 0 };

        ////////////
        // internals

        var scope = this;

        var EPS = 0.000001;

        var rotateStart = new THREE.Vector2();
        var rotateEnd = new THREE.Vector2();
        var rotateDelta = new THREE.Vector2();

        var panStart = new THREE.Vector2();
        var panEnd = new THREE.Vector2();
        var panDelta = new THREE.Vector2();
        var panOffset = new THREE.Vector3();

        var offset = new THREE.Vector3();

        var dollyStart = new THREE.Vector2();
        var dollyEnd = new THREE.Vector2();
        var dollyDelta = new THREE.Vector2();

        var phiDelta = 0;
        var thetaDelta = 0;
        var scale = 1;
        var pan = new THREE.Vector3();

        var lastPosition = new THREE.Vector3();

        var STATE = { NONE : -1, ROTATE : 0, DOLLY : 1, PAN : 2, TOUCH_ROTATE : 3, TOUCH_DOLLY : 4, TOUCH_PAN : 5 };

        var state = STATE.NONE;

        // for reset

        this.target0 = this.target.clone();
        this.position0 = this.object.position.clone();

        // so camera.up is the orbit axis

        var quat = new THREE.Quaternion().setFromUnitVectors( object.up, new THREE.Vector3( 0, 1, 0 ) );
        var quatInverse = quat.clone().inverse();

        // events

        var changeEvent = { type: 'change' };
        var startEvent = { type: 'start'};
        var endEvent = { type: 'end'};

        this.rotateLeft = function ( angle ) {

            if ( angle === undefined ) {

                angle = getAutoRotationAngle();

            }

            thetaDelta -= angle;

        };

        this.rotateUp = function ( angle ) {

            if ( angle === undefined ) {

                angle = getAutoRotationAngle();

            }

            phiDelta -= angle;

        };

        // pass in distance in world space to move left
        this.panLeft = function ( distance ) {

            var te = this.object.matrix.elements;

            // get X column of matrix
            panOffset.set( te[ 0 ], te[ 1 ], te[ 2 ] );
            panOffset.multiplyScalar( - distance );
            
            pan.add( panOffset );

        };

        // pass in distance in world space to move up
        this.panUp = function ( distance ) {

            var te = this.object.matrix.elements;

            // get Y column of matrix
            panOffset.set( te[ 4 ], te[ 5 ], te[ 6 ] );
            panOffset.multiplyScalar( distance );
            
            pan.add( panOffset );

        };
        
        // pass in x,y of change desired in pixel space,
        // right and down are positive
        this.pan = function ( deltaX, deltaY ) {

            var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

            if ( scope.object.fov !== undefined ) {

                // perspective
                var position = scope.object.position;
                var offset = position.clone().sub( scope.target );
                var targetDistance = offset.length();

                // half of the fov is center to top of screen
                targetDistance *= Math.tan( ( scope.object.fov / 2 ) * Math.PI / 180.0 );

                // we actually don't use screenWidth, since perspective camera is fixed to screen height
                scope.panLeft( 2 * deltaX * targetDistance / element.clientHeight );
                scope.panUp( 2 * deltaY * targetDistance / element.clientHeight );

            } else if ( scope.object.top !== undefined ) {

                // orthographic
                scope.panLeft( deltaX * (scope.object.right - scope.object.left) / element.clientWidth );
                scope.panUp( deltaY * (scope.object.top - scope.object.bottom) / element.clientHeight );

            } else {

                // camera neither orthographic or perspective
                console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.' );

            }

        };

        this.dollyIn = function ( dollyScale ) {

            if ( dollyScale === undefined ) {

                dollyScale = getZoomScale();

            }

            scale /= dollyScale;

        };

        this.dollyOut = function ( dollyScale ) {

            if ( dollyScale === undefined ) {

                dollyScale = getZoomScale();

            }

            scale *= dollyScale;

        };

        this.update = function () {

            var position = this.object.position;

            // // rotating across whole screen goes 360 degrees around
            scope.rotateLeft( 2 * Math.PI * scope.constrainDelta.x / window.innerWidth * scope.rotateSpeed );

            // // rotating up and down along whole screen attempts to go 360, but limited to 180
            scope.rotateUp( 2 * Math.PI * scope.constrainDelta.y / window.innerHeight * scope.rotateSpeed );

            offset.copy( position ).sub( this.target );

            // rotate offset to "y-axis-is-up" space
            offset.applyQuaternion( quat );

            // angle from z-axis around y-axis

            var theta = Math.atan2( offset.x, offset.z );

            // angle from y-axis

            var phi = Math.atan2( Math.sqrt( offset.x * offset.x + offset.z * offset.z ), offset.y );

            if ( this.autoRotate ) {

                this.rotateLeft( getAutoRotationAngle() );

            }

            theta += thetaDelta;
            phi += phiDelta;

            // restrict phi to be between desired limits
            phi = Math.max( this.minPolarAngle, Math.min( this.maxPolarAngle, phi ) );

            // restrict phi to be betwee EPS and PI-EPS
            phi = Math.max( EPS, Math.min( Math.PI - EPS, phi ) );

            var radius = offset.length() * scale;

            // restrict radius to be between desired limits
            radius = Math.max( this.minDistance, Math.min( this.maxDistance, radius ) );
            
            // move target to panned location
            this.target.add( pan );

            scope.phi = phi
            scope.theta = theta

            offset.x = radius * Math.sin( phi ) * Math.sin( theta );
            offset.y = radius * Math.cos( phi );
            offset.z = radius * Math.sin( phi ) * Math.cos( theta );

            // rotate offset back to "camera-up-vector-is-up" space
            offset.applyQuaternion( quatInverse );

            position.copy( this.target ).add( offset );

            this.object.lookAt( this.target );

            thetaDelta = 0;
            phiDelta = 0;
            scale = 1;
            pan.set( 0, 0, 0 );

            if ( lastPosition.distanceToSquared( this.object.position ) > EPS ) {

                this.dispatchEvent( changeEvent );

                lastPosition.copy( this.object.position );

            }

        };


        this.reset = function () {

            state = STATE.NONE;

            this.target.copy( this.target0 );
            this.object.position.copy( this.position0 );

            this.update();

        };

        function getAutoRotationAngle() {

            return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;

        }

        function getZoomScale() {

            return Math.pow( 0.95, scope.zoomSpeed );

        }

        function onMouseDown( event ) {

            if ( scope.enabled === false ) return;
            event.preventDefault();

            if ( event.button === 0 ) {
                if ( scope.noRotate === true ) return;

                state = STATE.ROTATE;

                rotateStart.set( event.clientX, event.clientY );

            } else if ( event.button === 1 ) {
                if ( scope.noZoom === true ) return;

                state = STATE.DOLLY;

                dollyStart.set( event.clientX, event.clientY );

            } else if ( event.button === 2 ) {
                if ( scope.noPan === true ) return;

                state = STATE.PAN;

                panStart.set( event.clientX, event.clientY );

            }

            scope.domElement.addEventListener( 'mousemove', onMouseMove, false );
            scope.domElement.addEventListener( 'mouseup', onMouseUp, false );
            scope.dispatchEvent( startEvent );

        }

        function onMouseMove( event ) {

            if ( scope.enabled === false ) return;

            event.preventDefault();

            var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

            if ( state === STATE.ROTATE ) {

                if ( scope.noRotate === true ) return;

                rotateEnd.set( event.clientX, event.clientY );
                rotateDelta.subVectors( rotateEnd, rotateStart );

                scope.constrainDelta.x = rotateDelta.x;
                scope.constrainDelta.y = rotateDelta.y;
                
                TweenMax.killTweensOf(scope.constrainDelta);
                TweenMax.to(scope.constrainDelta, 0.50, {
                    x: 0,
                    y: 0,
                    ease: 'easeOutQuad',
                    delay: 0.0
                });

                rotateStart.copy( rotateEnd );

            } else if ( state === STATE.DOLLY ) {

                if ( scope.noZoom === true ) return;

                dollyEnd.set( event.clientX, event.clientY );
                dollyDelta.subVectors( dollyEnd, dollyStart );

                if ( dollyDelta.y > 0 ) {

                    scope.dollyIn();

                } else {

                    scope.dollyOut();

                }

                dollyStart.copy( dollyEnd );

            } else if ( state === STATE.PAN ) {

                if ( scope.noPan === true ) return;

                panEnd.set( event.clientX, event.clientY );
                panDelta.subVectors( panEnd, panStart );
                
                scope.pan( panDelta.x, panDelta.y );

                panStart.copy( panEnd );

            }

            scope.update();

        }

        function onMouseUp( /* event */ ) {

            if ( scope.enabled === false ) return;

            scope.domElement.removeEventListener( 'mousemove', onMouseMove, false );
            scope.domElement.removeEventListener( 'mouseup', onMouseUp, false );
            scope.dispatchEvent( endEvent );
            state = STATE.NONE;

        }

        function onMouseWheel( event ) {

            if ( scope.enabled === false || scope.noZoom === true ) return;

            event.preventDefault();
            event.stopPropagation();

            var delta = 0;

            if ( event.wheelDelta !== undefined ) { // WebKit / Opera / Explorer 9

                delta = event.wheelDelta;

            } else if ( event.detail !== undefined ) { // Firefox

                delta = - event.detail;

            }

            if ( delta > 0 ) {

                scope.dollyOut();

            } else {

                scope.dollyIn();

            }

            scope.update();
            scope.dispatchEvent( startEvent );
            scope.dispatchEvent( endEvent );

        }

        function onKeyDown( event ) {

            if ( scope.enabled === false || scope.noKeys === true || scope.noPan === true ) return;
            
            switch ( event.keyCode ) {

                case scope.keys.UP:
                    scope.pan( 0, scope.keyPanSpeed );
                    scope.update();
                    break;

                case scope.keys.BOTTOM:
                    scope.pan( 0, - scope.keyPanSpeed );
                    scope.update();
                    break;

                case scope.keys.LEFT:
                    scope.pan( scope.keyPanSpeed, 0 );
                    scope.update();
                    break;

                case scope.keys.RIGHT:
                    scope.pan( - scope.keyPanSpeed, 0 );
                    scope.update();
                    break;

            }

        }

        function touchstart( event ) {

            if ( scope.enabled === false ) return;

            switch ( event.touches.length ) {

                case 1: // one-fingered touch: rotate

                    if ( scope.noRotate === true ) return;

                    state = STATE.TOUCH_ROTATE;

                    rotateStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );
                    break;

                case 2: // two-fingered touch: dolly

                    if ( scope.noZoom === true ) return;

                    state = STATE.TOUCH_DOLLY;

                    var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;
                    var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;
                    var distance = Math.sqrt( dx * dx + dy * dy );
                    dollyStart.set( 0, distance );
                    break;

                case 3: // three-fingered touch: pan

                    if ( scope.noPan === true ) return;

                    state = STATE.TOUCH_PAN;

                    panStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );
                    break;

                default:

                    state = STATE.NONE;

            }

            scope.dispatchEvent( startEvent );

        }

        function touchmove( event ) {

            if ( scope.enabled === false ) return;

            event.preventDefault();
            event.stopPropagation();

            var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

            switch ( event.touches.length ) {

                case 1: // one-fingered touch: rotate

                    if ( scope.noRotate === true ) return;
                    if ( state !== STATE.TOUCH_ROTATE ) return;

                    rotateEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );
                    rotateDelta.subVectors( rotateEnd, rotateStart );

                    // rotating across whole screen goes 360 degrees around
                    scope.rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed );
                    // rotating up and down along whole screen attempts to go 360, but limited to 180
                    scope.rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed );

                    rotateStart.copy( rotateEnd );

                    scope.update();
                    break;

                case 2: // two-fingered touch: dolly

                    if ( scope.noZoom === true ) return;
                    if ( state !== STATE.TOUCH_DOLLY ) return;

                    var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;
                    var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;
                    var distance = Math.sqrt( dx * dx + dy * dy );

                    dollyEnd.set( 0, distance );
                    dollyDelta.subVectors( dollyEnd, dollyStart );

                    if ( dollyDelta.y > 0 ) {

                        scope.dollyOut();

                    } else {

                        scope.dollyIn();

                    }

                    dollyStart.copy( dollyEnd );

                    scope.update();
                    break;

                case 3: // three-fingered touch: pan

                    if ( scope.noPan === true ) return;
                    if ( state !== STATE.TOUCH_PAN ) return;

                    panEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );
                    panDelta.subVectors( panEnd, panStart );
                    
                    scope.pan( panDelta.x, panDelta.y );

                    panStart.copy( panEnd );

                    scope.update();
                    break;

                default:

                    state = STATE.NONE;

            }

        }

        function touchend( /* event */ ) {

            if ( scope.enabled === false ) return;

            scope.dispatchEvent( endEvent );
            state = STATE.NONE;

        }

        this.domElement.addEventListener( 'contextmenu', function ( event ) { event.preventDefault(); }, false );
        this.domElement.addEventListener( 'mousedown', onMouseDown, false );
        this.domElement.addEventListener( 'mousewheel', onMouseWheel, false );
        this.domElement.addEventListener( 'DOMMouseScroll', onMouseWheel, false ); // firefox

        this.domElement.addEventListener( 'touchstart', touchstart, false );
        this.domElement.addEventListener( 'touchend', touchend, false );
        this.domElement.addEventListener( 'touchmove', touchmove, false );

        window.addEventListener( 'keydown', onKeyDown, false );

        // force an update at start
        this.update();

    };

    inherits(OrbitControls, THREE.EventDispatcher)
    return OrbitControls
}
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"inherits":"/projects/blackice/node_modules/inherits/inherits_browser.js"}],"/projects/blackice/node_modules/as-number/index.js":[function(require,module,exports){
module.exports = function numtype(num, def) {
	return typeof num === 'number'
		? num 
		: (typeof def === 'number' ? def : 0)
}
},{}],"/projects/blackice/node_modules/browserify/node_modules/buffer/index.js":[function(require,module,exports){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var isArray = require('is-array')

exports.Buffer = Buffer
exports.SlowBuffer = Buffer
exports.INSPECT_MAX_BYTES = 50
Buffer.poolSize = 8192 // not used by this implementation

var kMaxLength = 0x3fffffff

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Note:
 *
 * - Implementation must support adding new properties to `Uint8Array` instances.
 *   Firefox 4-29 lacked support, fixed in Firefox 30+.
 *   See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *  - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *  - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *    incorrect length in some situations.
 *
 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they will
 * get the Object implementation, which is slower but will work correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = (function () {
  try {
    var buf = new ArrayBuffer(0)
    var arr = new Uint8Array(buf)
    arr.foo = function () { return 42 }
    return 42 === arr.foo() && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        new Uint8Array(1).subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
})()

/**
 * Class: Buffer
 * =============
 *
 * The Buffer constructor returns instances of `Uint8Array` that are augmented
 * with function properties for all the node `Buffer` API functions. We use
 * `Uint8Array` so that square bracket notation works as expected -- it returns
 * a single octet.
 *
 * By augmenting the instances, we can avoid modifying the `Uint8Array`
 * prototype.
 */
function Buffer (subject, encoding, noZero) {
  if (!(this instanceof Buffer))
    return new Buffer(subject, encoding, noZero)

  var type = typeof subject

  // Find the length
  var length
  if (type === 'number')
    length = subject > 0 ? subject >>> 0 : 0
  else if (type === 'string') {
    if (encoding === 'base64')
      subject = base64clean(subject)
    length = Buffer.byteLength(subject, encoding)
  } else if (type === 'object' && subject !== null) { // assume object is array-like
    if (subject.type === 'Buffer' && isArray(subject.data))
      subject = subject.data
    length = +subject.length > 0 ? Math.floor(+subject.length) : 0
  } else
    throw new TypeError('must start with number, buffer, array or string')

  if (this.length > kMaxLength)
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
      'size: 0x' + kMaxLength.toString(16) + ' bytes')

  var buf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Preferred: Return an augmented `Uint8Array` instance for best performance
    buf = Buffer._augment(new Uint8Array(length))
  } else {
    // Fallback: Return THIS instance of Buffer (created by `new`)
    buf = this
    buf.length = length
    buf._isBuffer = true
  }

  var i
  if (Buffer.TYPED_ARRAY_SUPPORT && typeof subject.byteLength === 'number') {
    // Speed optimization -- use set if we're copying from a typed array
    buf._set(subject)
  } else if (isArrayish(subject)) {
    // Treat array-ish objects as a byte array
    if (Buffer.isBuffer(subject)) {
      for (i = 0; i < length; i++)
        buf[i] = subject.readUInt8(i)
    } else {
      for (i = 0; i < length; i++)
        buf[i] = ((subject[i] % 256) + 256) % 256
    }
  } else if (type === 'string') {
    buf.write(subject, 0, encoding)
  } else if (type === 'number' && !Buffer.TYPED_ARRAY_SUPPORT && !noZero) {
    for (i = 0; i < length; i++) {
      buf[i] = 0
    }
  }

  return buf
}

Buffer.isBuffer = function (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b))
    throw new TypeError('Arguments must be Buffers')

  var x = a.length
  var y = b.length
  for (var i = 0, len = Math.min(x, y); i < len && a[i] === b[i]; i++) {}
  if (i !== len) {
    x = a[i]
    y = b[i]
  }
  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'raw':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function (list, totalLength) {
  if (!isArray(list)) throw new TypeError('Usage: Buffer.concat(list[, length])')

  if (list.length === 0) {
    return new Buffer(0)
  } else if (list.length === 1) {
    return list[0]
  }

  var i
  if (totalLength === undefined) {
    totalLength = 0
    for (i = 0; i < list.length; i++) {
      totalLength += list[i].length
    }
  }

  var buf = new Buffer(totalLength)
  var pos = 0
  for (i = 0; i < list.length; i++) {
    var item = list[i]
    item.copy(buf, pos)
    pos += item.length
  }
  return buf
}

Buffer.byteLength = function (str, encoding) {
  var ret
  str = str + ''
  switch (encoding || 'utf8') {
    case 'ascii':
    case 'binary':
    case 'raw':
      ret = str.length
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = str.length * 2
      break
    case 'hex':
      ret = str.length >>> 1
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8ToBytes(str).length
      break
    case 'base64':
      ret = base64ToBytes(str).length
      break
    default:
      ret = str.length
  }
  return ret
}

// pre-set for values that may exist in the future
Buffer.prototype.length = undefined
Buffer.prototype.parent = undefined

// toString(encoding, start=0, end=buffer.length)
Buffer.prototype.toString = function (encoding, start, end) {
  var loweredCase = false

  start = start >>> 0
  end = end === undefined || end === Infinity ? this.length : end >>> 0

  if (!encoding) encoding = 'utf8'
  if (start < 0) start = 0
  if (end > this.length) end = this.length
  if (end <= start) return ''

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'binary':
        return binarySlice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase)
          throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.equals = function (b) {
  if(!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max)
      str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  return Buffer.compare(this, b)
}

// `get` will be removed in Node 0.13+
Buffer.prototype.get = function (offset) {
  console.log('.get() is deprecated. Access using array indexes instead.')
  return this.readUInt8(offset)
}

// `set` will be removed in Node 0.13+
Buffer.prototype.set = function (v, offset) {
  console.log('.set() is deprecated. Access using array indexes instead.')
  return this.writeUInt8(v, offset)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new Error('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; i++) {
    var byte = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(byte)) throw new Error('Invalid hex string')
    buf[offset + i] = byte
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  var charsWritten = blitBuffer(utf8ToBytes(string), buf, offset, length)
  return charsWritten
}

function asciiWrite (buf, string, offset, length) {
  var charsWritten = blitBuffer(asciiToBytes(string), buf, offset, length)
  return charsWritten
}

function binaryWrite (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  var charsWritten = blitBuffer(base64ToBytes(string), buf, offset, length)
  return charsWritten
}

function utf16leWrite (buf, string, offset, length) {
  var charsWritten = blitBuffer(utf16leToBytes(string), buf, offset, length)
  return charsWritten
}

Buffer.prototype.write = function (string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length
      length = undefined
    }
  } else {  // legacy
    var swap = encoding
    encoding = offset
    offset = length
    length = swap
  }

  offset = Number(offset) || 0
  var remaining = this.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase()

  var ret
  switch (encoding) {
    case 'hex':
      ret = hexWrite(this, string, offset, length)
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8Write(this, string, offset, length)
      break
    case 'ascii':
      ret = asciiWrite(this, string, offset, length)
      break
    case 'binary':
      ret = binaryWrite(this, string, offset, length)
      break
    case 'base64':
      ret = base64Write(this, string, offset, length)
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = utf16leWrite(this, string, offset, length)
      break
    default:
      throw new TypeError('Unknown encoding: ' + encoding)
  }
  return ret
}

Buffer.prototype.toJSON = function () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  var res = ''
  var tmp = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    if (buf[i] <= 0x7F) {
      res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i])
      tmp = ''
    } else {
      tmp += '%' + buf[i].toString(16)
    }
  }

  return res + decodeUtf8Char(tmp)
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function binarySlice (buf, start, end) {
  return asciiSlice(buf, start, end)
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; i++) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len;
    if (start < 0)
      start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0)
      end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start)
    end = start

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    return Buffer._augment(this.subarray(start, end))
  } else {
    var sliceLen = end - start
    var newBuf = new Buffer(sliceLen, undefined, true)
    for (var i = 0; i < sliceLen; i++) {
      newBuf[i] = this[i + start]
    }
    return newBuf
  }
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0)
    throw new RangeError('offset is not uint')
  if (offset + ext > length)
    throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUInt8 = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
      ((this[offset + 1] << 16) |
      (this[offset + 2] << 8) |
      this[offset + 3])
}

Buffer.prototype.readInt8 = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80))
    return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)

  return (this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16) |
      (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
      (this[offset + 1] << 16) |
      (this[offset + 2] << 8) |
      (this[offset + 3])
}

Buffer.prototype.readFloatLE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')
  if (value > max || value < min) throw new TypeError('value is out of bounds')
  if (offset + ext > buf.length) throw new TypeError('index out of range')
}

Buffer.prototype.writeUInt8 = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = value
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
  } else objectWriteUInt16(this, value, offset, true)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = value
  } else objectWriteUInt16(this, value, offset, false)
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = value
  } else objectWriteUInt32(this, value, offset, true)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = value
  } else objectWriteUInt32(this, value, offset, false)
  return offset + 4
}

Buffer.prototype.writeInt8 = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = value
  return offset + 1
}

Buffer.prototype.writeInt16LE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
  } else objectWriteUInt16(this, value, offset, true)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = value
  } else objectWriteUInt16(this, value, offset, false)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else objectWriteUInt32(this, value, offset, true)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = value
  } else objectWriteUInt32(this, value, offset, false)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (value > max || value < min) throw new TypeError('value is out of bounds')
  if (offset + ext > buf.length) throw new TypeError('index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert)
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert)
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function (target, target_start, start, end) {
  var source = this

  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (!target_start) target_start = 0

  // Copy 0 bytes; we're done
  if (end === start) return
  if (target.length === 0 || source.length === 0) return

  // Fatal error conditions
  if (end < start) throw new TypeError('sourceEnd < sourceStart')
  if (target_start < 0 || target_start >= target.length)
    throw new TypeError('targetStart out of bounds')
  if (start < 0 || start >= source.length) throw new TypeError('sourceStart out of bounds')
  if (end < 0 || end > source.length) throw new TypeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length)
    end = this.length
  if (target.length - target_start < end - start)
    end = target.length - target_start + start

  var len = end - start

  if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < len; i++) {
      target[i + target_start] = this[i + start]
    }
  } else {
    target._set(this.subarray(start, start + len), target_start)
  }
}

// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function (value, start, end) {
  if (!value) value = 0
  if (!start) start = 0
  if (!end) end = this.length

  if (end < start) throw new TypeError('end < start')

  // Fill 0 bytes; we're done
  if (end === start) return
  if (this.length === 0) return

  if (start < 0 || start >= this.length) throw new TypeError('start out of bounds')
  if (end < 0 || end > this.length) throw new TypeError('end out of bounds')

  var i
  if (typeof value === 'number') {
    for (i = start; i < end; i++) {
      this[i] = value
    }
  } else {
    var bytes = utf8ToBytes(value.toString())
    var len = bytes.length
    for (i = start; i < end; i++) {
      this[i] = bytes[i % len]
    }
  }

  return this
}

/**
 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
 */
Buffer.prototype.toArrayBuffer = function () {
  if (typeof Uint8Array !== 'undefined') {
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      return (new Buffer(this)).buffer
    } else {
      var buf = new Uint8Array(this.length)
      for (var i = 0, len = buf.length; i < len; i += 1) {
        buf[i] = this[i]
      }
      return buf.buffer
    }
  } else {
    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')
  }
}

// HELPER FUNCTIONS
// ================

var BP = Buffer.prototype

/**
 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
 */
Buffer._augment = function (arr) {
  arr.constructor = Buffer
  arr._isBuffer = true

  // save reference to original Uint8Array get/set methods before overwriting
  arr._get = arr.get
  arr._set = arr.set

  // deprecated, will be removed in node 0.13+
  arr.get = BP.get
  arr.set = BP.set

  arr.write = BP.write
  arr.toString = BP.toString
  arr.toLocaleString = BP.toString
  arr.toJSON = BP.toJSON
  arr.equals = BP.equals
  arr.compare = BP.compare
  arr.copy = BP.copy
  arr.slice = BP.slice
  arr.readUInt8 = BP.readUInt8
  arr.readUInt16LE = BP.readUInt16LE
  arr.readUInt16BE = BP.readUInt16BE
  arr.readUInt32LE = BP.readUInt32LE
  arr.readUInt32BE = BP.readUInt32BE
  arr.readInt8 = BP.readInt8
  arr.readInt16LE = BP.readInt16LE
  arr.readInt16BE = BP.readInt16BE
  arr.readInt32LE = BP.readInt32LE
  arr.readInt32BE = BP.readInt32BE
  arr.readFloatLE = BP.readFloatLE
  arr.readFloatBE = BP.readFloatBE
  arr.readDoubleLE = BP.readDoubleLE
  arr.readDoubleBE = BP.readDoubleBE
  arr.writeUInt8 = BP.writeUInt8
  arr.writeUInt16LE = BP.writeUInt16LE
  arr.writeUInt16BE = BP.writeUInt16BE
  arr.writeUInt32LE = BP.writeUInt32LE
  arr.writeUInt32BE = BP.writeUInt32BE
  arr.writeInt8 = BP.writeInt8
  arr.writeInt16LE = BP.writeInt16LE
  arr.writeInt16BE = BP.writeInt16BE
  arr.writeInt32LE = BP.writeInt32LE
  arr.writeInt32BE = BP.writeInt32BE
  arr.writeFloatLE = BP.writeFloatLE
  arr.writeFloatBE = BP.writeFloatBE
  arr.writeDoubleLE = BP.writeDoubleLE
  arr.writeDoubleBE = BP.writeDoubleBE
  arr.fill = BP.fill
  arr.inspect = BP.inspect
  arr.toArrayBuffer = BP.toArrayBuffer

  return arr
}

var INVALID_BASE64_RE = /[^+\/0-9A-z]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function isArrayish (subject) {
  return isArray(subject) || Buffer.isBuffer(subject) ||
      subject && typeof subject === 'object' &&
      typeof subject.length === 'number'
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    var b = str.charCodeAt(i)
    if (b <= 0x7F) {
      byteArray.push(b)
    } else {
      var start = i
      if (b >= 0xD800 && b <= 0xDFFF) i++
      var h = encodeURIComponent(str.slice(start, i+1)).substr(1).split('%')
      for (var j = 0; j < h.length; j++) {
        byteArray.push(parseInt(h[j], 16))
      }
    }
  }
  return byteArray
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(str)
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; i++) {
    if ((i + offset >= dst.length) || (i >= src.length))
      break
    dst[i + offset] = src[i]
  }
  return i
}

function decodeUtf8Char (str) {
  try {
    return decodeURIComponent(str)
  } catch (err) {
    return String.fromCharCode(0xFFFD) // UTF 8 invalid char
  }
}

},{"base64-js":"/projects/blackice/node_modules/browserify/node_modules/buffer/node_modules/base64-js/lib/b64.js","ieee754":"/projects/blackice/node_modules/browserify/node_modules/buffer/node_modules/ieee754/index.js","is-array":"/projects/blackice/node_modules/browserify/node_modules/buffer/node_modules/is-array/index.js"}],"/projects/blackice/node_modules/browserify/node_modules/buffer/node_modules/base64-js/lib/b64.js":[function(require,module,exports){
var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

;(function (exports) {
	'use strict';

  var Arr = (typeof Uint8Array !== 'undefined')
    ? Uint8Array
    : Array

	var PLUS   = '+'.charCodeAt(0)
	var SLASH  = '/'.charCodeAt(0)
	var NUMBER = '0'.charCodeAt(0)
	var LOWER  = 'a'.charCodeAt(0)
	var UPPER  = 'A'.charCodeAt(0)

	function decode (elt) {
		var code = elt.charCodeAt(0)
		if (code === PLUS)
			return 62 // '+'
		if (code === SLASH)
			return 63 // '/'
		if (code < NUMBER)
			return -1 //no match
		if (code < NUMBER + 10)
			return code - NUMBER + 26 + 26
		if (code < UPPER + 26)
			return code - UPPER
		if (code < LOWER + 26)
			return code - LOWER + 26
	}

	function b64ToByteArray (b64) {
		var i, j, l, tmp, placeHolders, arr

		if (b64.length % 4 > 0) {
			throw new Error('Invalid string. Length must be a multiple of 4')
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		var len = b64.length
		placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

		// base64 is 4/3 + up to two characters of the original data
		arr = new Arr(b64.length * 3 / 4 - placeHolders)

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length

		var L = 0

		function push (v) {
			arr[L++] = v
		}

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
			push((tmp & 0xFF0000) >> 16)
			push((tmp & 0xFF00) >> 8)
			push(tmp & 0xFF)
		}

		if (placeHolders === 2) {
			tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
			push(tmp & 0xFF)
		} else if (placeHolders === 1) {
			tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
			push((tmp >> 8) & 0xFF)
			push(tmp & 0xFF)
		}

		return arr
	}

	function uint8ToBase64 (uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length

		function encode (num) {
			return lookup.charAt(num)
		}

		function tripletToBase64 (num) {
			return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
		}

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
			output += tripletToBase64(temp)
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1]
				output += encode(temp >> 2)
				output += encode((temp << 4) & 0x3F)
				output += '=='
				break
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
				output += encode(temp >> 10)
				output += encode((temp >> 4) & 0x3F)
				output += encode((temp << 2) & 0x3F)
				output += '='
				break
		}

		return output
	}

	exports.toByteArray = b64ToByteArray
	exports.fromByteArray = uint8ToBase64
}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))

},{}],"/projects/blackice/node_modules/browserify/node_modules/buffer/node_modules/ieee754/index.js":[function(require,module,exports){
exports.read = function(buffer, offset, isLE, mLen, nBytes) {
  var e, m,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      nBits = -7,
      i = isLE ? (nBytes - 1) : 0,
      d = isLE ? -1 : 1,
      s = buffer[offset + i];

  i += d;

  e = s & ((1 << (-nBits)) - 1);
  s >>= (-nBits);
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);

  m = e & ((1 << (-nBits)) - 1);
  e >>= (-nBits);
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity);
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
      i = isLE ? 0 : (nBytes - 1),
      d = isLE ? 1 : -1,
      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);

  e = (e << mLen) | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);

  buffer[offset + i - d] |= s * 128;
};

},{}],"/projects/blackice/node_modules/browserify/node_modules/buffer/node_modules/is-array/index.js":[function(require,module,exports){

/**
 * isArray
 */

var isArray = Array.isArray;

/**
 * toString
 */

var str = Object.prototype.toString;

/**
 * Whether or not the given `val`
 * is an array.
 *
 * example:
 *
 *        isArray([]);
 *        // > true
 *        isArray(arguments);
 *        // > false
 *        isArray('');
 *        // > false
 *
 * @param {mixed} val
 * @return {bool}
 */

module.exports = isArray || function (val) {
  return !! val && '[object Array]' == str.call(val);
};

},{}],"/projects/blackice/node_modules/canvas-app/index.js":[function(require,module,exports){
var isGL = require('is-webgl-context');
var getGL = require('webgl-context');
var debounce = require('debounce');
var addEvent = require('add-event-listener');

function isCanvasContext(obj) {
    var ctx2d = typeof CanvasRenderingContext2D !== 'undefined' && obj instanceof CanvasRenderingContext2D;
    return obj && (ctx2d || isGL(obj));
}

function CanvasApp(render, options) {
    if (!(this instanceof CanvasApp))
        return new CanvasApp(render, options);

    //allow options to be passed as first argument
    if (typeof render === 'object' && render) {
        options = render;
        render = null;
    }

    render = typeof render === 'function' ? render : options.onRender;

    options = options||{};
    options.retina = typeof options.retina === "boolean" ? options.retina : true;
    
    var hasWidth = typeof options.width === "number", 
        hasHeight = typeof options.height === "number";

    //if either width or height is specified, don't auto-resize to the window...
    if (hasWidth || hasHeight) 
        options.ignoreResize = true;

    options.width = hasWidth ? options.width : window.innerWidth;
    options.height = hasHeight ? options.height : window.innerHeight;

    var DPR = options.retina ? (window.devicePixelRatio||1) : 1; 

    //setup the canvas
    var canvas,
        context,
        attribs = options.contextAttributes||{};

    this.isWebGL = false;

    //if user provided a context object
    if (isCanvasContext(options.context)) {
        context = options.context;
        canvas = context.canvas;
    }

    //otherwise allow for a string to set one up
    if (!canvas)
        canvas = options.canvas || document.createElement("canvas");

    canvas.width = options.width * DPR;
    canvas.height = options.height * DPR;

    if (!context) {
        if (options.context === "webgl" || options.context === "experimental-webgl") {
            context = getGL({ canvas: canvas, attributes: attribs });
            if (!context) {
                throw "WebGL Context Not Supported -- try enabling it or using a different browser";
            }
        } else {
            context = canvas.getContext(options.context||"2d", attribs);
        }
    }

    this.isWebGL = isGL(context);

    if (options.retina) {
        canvas.style.width = options.width + 'px';
        canvas.style.height = options.height + 'px';
    }

    this.running = false;
    this.width = options.width;
    this.height = options.height;
    this.canvas = canvas;
    this.context = context;
    this.onResize = options.onResize;
    this._DPR = DPR;
    this._retina = options.retina;
    this._once = options.once;
    this._ignoreResize = options.ignoreResize;
    this._lastFrame = null;
    this._then = Date.now();

    //FPS counter
    this.fps = 60;
    this._frames = 0;
    this._prevTime = this._then;

    if (!this._ignoreResize) {
        options.resizeDebounce = typeof options.resizeDebounce === 'number'
                    ? options.resizeDebounce : 50;
        addEvent(window, "resize", debounce(function() {
            this.resize(window.innerWidth, window.innerHeight);
        }.bind(this), options.resizeDebounce, false));

        addEvent(window, "orientationchange", function() {
            this.resize(window.innerWidth, window.innerHeight);
        }.bind(this));
    }

    if (typeof render === "function") {
        this.onRender = render.bind(this);   
    } else {
        //dummy render function
        this.onRender = function (context, width, height, dt) { };
    }

    this.renderOnce = function() {
        var now = Date.now();
        var dt = (now-this._then);

        this._frames++;
        if (now > this._prevTime + 1000) {
            this.fps = Math.round((this._frames * 1000) / (now - this._prevTime));

            this._prevTime = now;
            this._frames = 0;
        }

        if (!this.isWebGL) {
            this.context.save();
            this.context.scale(this._DPR, this._DPR);
        } else {
            this.context.viewport(0, 0, this.width * this._DPR, this.height * this._DPR);
        }
        
        this.onRender(this.context, this.width, this.height, dt);

        if (!this.isWebGL)
            this.context.restore();

        this._then = now;
    };

    this._renderHandler = function() {
        if (!this.running) 
            return;
        
        if (!this._once) {
            this._lastFrame = requestAnimationFrame(this._renderHandler);
        }

        this.renderOnce();
    }.bind(this);

    if (typeof options.onReady === "function") {
        options.onReady.call(this, context, this.width, this.height);
    }
}

Object.defineProperty(CanvasApp.prototype, 'retinaEnabled', {

    set: function(v) {
        this._retina = v;
        this._DPR = this._retina ? (window.devicePixelRatio||1) : 1;
        this.resize(this.width, this.height);
    },

    get: function() {
        return this._retina;
    }
});

Object.defineProperty(CanvasApp.prototype, 'deviceWidth', {

    get: function() {
        return this.width * this._DPR;
    }
});

Object.defineProperty(CanvasApp.prototype, 'deviceHeight', {

    get: function() {
        return this.height * this._DPR;
    }
});

CanvasApp.prototype.resetFPS = function() {
    this._frames = 0;
    this._prevTime = Date.now();
    this._then = this._prevTime;
    this.fps = 60;
};

CanvasApp.prototype.start = function() {
    if (this.running)
        return;
    
    if (this._lastFrame) 
        cancelAnimationFrame(this._lastFrame);

    //reset FPS counter
    this.resetFPS();

    this.running = true;
    this._lastFrame = requestAnimationFrame(this._renderHandler);
};

CanvasApp.prototype.stop = function() {
    if (this._lastFrame) {
        cancelAnimationFrame(this._lastFrame);
        this._lastFrame = null;
    }
    this.running = false;
};

CanvasApp.prototype.resize = function(width, height) {
    var canvas = this.canvas;

    this.width = width;
    this.height = height;
    canvas.width = this.width * this._DPR;
    canvas.height = this.height * this._DPR;

    if (this._retina) {
        canvas.style.width = this.width + 'px';
        canvas.style.height = this.height + 'px';
    }

    if (this._once)
        requestAnimationFrame(this._renderHandler);
    if (typeof this.onResize === "function")
        this.onResize(this.width, this.height);
};

module.exports = CanvasApp;
},{"add-event-listener":"/projects/blackice/node_modules/canvas-app/node_modules/add-event-listener/index.js","debounce":"/projects/blackice/node_modules/canvas-app/node_modules/debounce/index.js","is-webgl-context":"/projects/blackice/node_modules/canvas-app/node_modules/is-webgl-context/index.js","webgl-context":"/projects/blackice/node_modules/canvas-app/node_modules/webgl-context/index.js"}],"/projects/blackice/node_modules/canvas-app/node_modules/add-event-listener/index.js":[function(require,module,exports){
addEventListener.removeEventListener = removeEventListener
addEventListener.addEventListener = addEventListener

module.exports = addEventListener

var Events = null

function addEventListener(el, eventName, listener, useCapture) {
  Events = Events || (
    document.addEventListener ?
    {add: stdAttach, rm: stdDetach} :
    {add: oldIEAttach, rm: oldIEDetach}
  )
  
  return Events.add(el, eventName, listener, useCapture)
}

function removeEventListener(el, eventName, listener, useCapture) {
  Events = Events || (
    document.addEventListener ?
    {add: stdAttach, rm: stdDetach} :
    {add: oldIEAttach, rm: oldIEDetach}
  )
  
  return Events.rm(el, eventName, listener, useCapture)
}

function stdAttach(el, eventName, listener, useCapture) {
  el.addEventListener(eventName, listener, useCapture)
}

function stdDetach(el, eventName, listener, useCapture) {
  el.removeEventListener(eventName, listener, useCapture)
}

function oldIEAttach(el, eventName, listener, useCapture) {
  if(useCapture) {
    throw new Error('cannot useCapture in oldIE')
  }

  el.attachEvent('on' + eventName, listener)
}

function oldIEDetach(el, eventName, listener, useCapture) {
  el.detachEvent('on' + eventName, listener)
}

},{}],"/projects/blackice/node_modules/canvas-app/node_modules/debounce/index.js":[function(require,module,exports){

/**
 * Module dependencies.
 */

var now = require('date-now');

/**
 * Returns a function, that, as long as it continues to be invoked, will not
 * be triggered. The function will be called after it stops being called for
 * N milliseconds. If `immediate` is passed, trigger the function on the
 * leading edge, instead of the trailing.
 *
 * @source underscore.js
 * @see http://unscriptable.com/2009/03/20/debouncing-javascript-methods/
 * @param {Function} function to wrap
 * @param {Number} timeout in ms (`100`)
 * @param {Boolean} whether to execute at the beginning (`false`)
 * @api public
 */

module.exports = function debounce(func, wait, immediate){
  var timeout, args, context, timestamp, result;
  if (null == wait) wait = 100;

  function later() {
    var last = now() - timestamp;

    if (last < wait && last > 0) {
      timeout = setTimeout(later, wait - last);
    } else {
      timeout = null;
      if (!immediate) {
        result = func.apply(context, args);
        if (!timeout) context = args = null;
      }
    }
  };

  return function debounced() {
    context = this;
    args = arguments;
    timestamp = now();
    var callNow = immediate && !timeout;
    if (!timeout) timeout = setTimeout(later, wait);
    if (callNow) {
      result = func.apply(context, args);
      context = args = null;
    }

    return result;
  };
};

},{"date-now":"/projects/blackice/node_modules/canvas-app/node_modules/debounce/node_modules/date-now/index.js"}],"/projects/blackice/node_modules/canvas-app/node_modules/debounce/node_modules/date-now/index.js":[function(require,module,exports){
module.exports = Date.now || now

function now() {
    return new Date().getTime()
}

},{}],"/projects/blackice/node_modules/canvas-app/node_modules/is-webgl-context/index.js":[function(require,module,exports){
module.exports = function(ctx) {
	if (!ctx) return false
	var gl = ctx
	//compatibility with Chrome WebGL Inspector Addon
	if (typeof ctx.rawgl !== 'undefined')
		gl = ctx.rawgl
	if (typeof WebGLRenderingContext !== 'undefined' && gl instanceof WebGLRenderingContext)
		return true
	return false
}
},{}],"/projects/blackice/node_modules/canvas-app/node_modules/webgl-context/index.js":[function(require,module,exports){
module.exports = function(opts) {
    opts = opts||{};
    var canvas = opts.canvas || document.createElement("canvas");
    if (typeof opts.width === "number")
        canvas.width = opts.width;
    if (typeof opts.height === "number")
        canvas.height = opts.height;
    
    var attribs = (opts.attributes || opts.attribs || {});
    try {
        gl = (canvas.getContext('webgl', attribs) || canvas.getContext('experimental-webgl', attribs));
    } catch (e) {
        gl = null;
    }
    return gl;
};
},{}],"/projects/blackice/node_modules/clamp/index.js":[function(require,module,exports){
module.exports = clamp

function clamp(value, min, max) {
  return min < max
    ? (value < min ? min : value > max ? max : value)
    : (value < max ? max : value > min ? min : value)
}

},{}],"/projects/blackice/node_modules/domready/ready.js":[function(require,module,exports){
/*!
  * domready (c) Dustin Diaz 2014 - License MIT
  */
!function (name, definition) {

  if (typeof module != 'undefined') module.exports = definition()
  else if (typeof define == 'function' && typeof define.amd == 'object') define(definition)
  else this[name] = definition()

}('domready', function () {

  var fns = [], listener
    , doc = document
    , hack = doc.documentElement.doScroll
    , domContentLoaded = 'DOMContentLoaded'
    , loaded = (hack ? /^loaded|^c/ : /^loaded|^i|^c/).test(doc.readyState)


  if (!loaded)
  doc.addEventListener(domContentLoaded, listener = function () {
    doc.removeEventListener(domContentLoaded, listener)
    loaded = 1
    while (listener = fns.shift()) listener()
  })

  return function (fn) {
    loaded ? fn() : fns.push(fn)
  }

});

},{}],"/projects/blackice/node_modules/gl-mat4/identity.js":[function(require,module,exports){
module.exports = identity;

/**
 * Set a mat4 to the identity matrix
 *
 * @param {mat4} out the receiving matrix
 * @returns {mat4} out
 */
function identity(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
};
},{}],"/projects/blackice/node_modules/gl-mat4/multiply.js":[function(require,module,exports){
module.exports = multiply;

/**
 * Multiplies two mat4's
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
function multiply(out, a, b) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

    // Cache only the current line of the second matrix
    var b0  = b[0], b1 = b[1], b2 = b[2], b3 = b[3];  
    out[0] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[1] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[2] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[3] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[4]; b1 = b[5]; b2 = b[6]; b3 = b[7];
    out[4] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[5] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[6] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[7] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[8]; b1 = b[9]; b2 = b[10]; b3 = b[11];
    out[8] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[9] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[10] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[11] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[12]; b1 = b[13]; b2 = b[14]; b3 = b[15];
    out[12] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[13] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[14] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[15] = b0*a03 + b1*a13 + b2*a23 + b3*a33;
    return out;
};
},{}],"/projects/blackice/node_modules/gl-mat4/scale.js":[function(require,module,exports){
module.exports = scale;

/**
 * Scales the mat4 by the dimensions in the given vec3
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {vec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 **/
function scale(out, a, v) {
    var x = v[0], y = v[1], z = v[2];

    out[0] = a[0] * x;
    out[1] = a[1] * x;
    out[2] = a[2] * x;
    out[3] = a[3] * x;
    out[4] = a[4] * y;
    out[5] = a[5] * y;
    out[6] = a[6] * y;
    out[7] = a[7] * y;
    out[8] = a[8] * z;
    out[9] = a[9] * z;
    out[10] = a[10] * z;
    out[11] = a[11] * z;
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};
},{}],"/projects/blackice/node_modules/gl-mat4/translate.js":[function(require,module,exports){
module.exports = translate;

/**
 * Translate a mat4 by the given vector
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to translate
 * @param {vec3} v vector to translate by
 * @returns {mat4} out
 */
function translate(out, a, v) {
    var x = v[0], y = v[1], z = v[2],
        a00, a01, a02, a03,
        a10, a11, a12, a13,
        a20, a21, a22, a23;

    if (a === out) {
        out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
        out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
        out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
        out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
    } else {
        a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
        a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
        a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

        out[0] = a00; out[1] = a01; out[2] = a02; out[3] = a03;
        out[4] = a10; out[5] = a11; out[6] = a12; out[7] = a13;
        out[8] = a20; out[9] = a21; out[10] = a22; out[11] = a23;

        out[12] = a00 * x + a10 * y + a20 * z + a[12];
        out[13] = a01 * x + a11 * y + a21 * z + a[13];
        out[14] = a02 * x + a12 * y + a22 * z + a[14];
        out[15] = a03 * x + a13 * y + a23 * z + a[15];
    }

    return out;
};
},{}],"/projects/blackice/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/gl-buffer/node_modules/ndarray-ops/ndarray-ops.js":[function(require,module,exports){
"use strict"

var compile = require("cwise-compiler")

var EmptyProc = {
  body: "",
  args: [],
  thisVars: [],
  localVars: []
}

function fixup(x) {
  if(!x) {
    return EmptyProc
  }
  for(var i=0; i<x.args.length; ++i) {
    var a = x.args[i]
    if(i === 0) {
      x.args[i] = {name: a, lvalue:true, rvalue: !!x.rvalue, count:x.count||1 }
    } else {
      x.args[i] = {name: a, lvalue:false, rvalue:true, count: 1}
    }
  }
  if(!x.thisVars) {
    x.thisVars = []
  }
  if(!x.localVars) {
    x.localVars = []
  }
  return x
}

function pcompile(user_args) {
  return compile({
    args:     user_args.args,
    pre:      fixup(user_args.pre),
    body:     fixup(user_args.body),
    post:     fixup(user_args.proc),
    funcName: user_args.funcName
  })
}

function makeOp(user_args) {
  var args = []
  for(var i=0; i<user_args.args.length; ++i) {
    args.push("a"+i)
  }
  var wrapper = new Function("P", [
    "return function ", user_args.funcName, "_ndarrayops(", args.join(","), ") {P(", args.join(","), ");return a0}"
  ].join(""))
  return wrapper(pcompile(user_args))
}

var assign_ops = {
  add:  "+",
  sub:  "-",
  mul:  "*",
  div:  "/",
  mod:  "%",
  band: "&",
  bor:  "|",
  bxor: "^",
  lshift: "<<",
  rshift: ">>",
  rrshift: ">>>"
}
;(function(){
  for(var id in assign_ops) {
    var op = assign_ops[id]
    exports[id] = makeOp({
      args: ["array","array","array"],
      body: {args:["a","b","c"],
             body: "a=b"+op+"c"},
      funcName: id
    })
    exports[id+"eq"] = makeOp({
      args: ["array","array"],
      body: {args:["a","b"],
             body:"a"+op+"=b"},
      rvalue: true,
      funcName: id+"eq"
    })
    exports[id+"s"] = makeOp({
      args: ["array", "array", "scalar"],
      body: {args:["a","b","s"],
             body:"a=b"+op+"s"},
      funcName: id+"s"
    })
    exports[id+"seq"] = makeOp({
      args: ["array","scalar"],
      body: {args:["a","s"],
             body:"a"+op+"=s"},
      rvalue: true,
      funcName: id+"seq"
    })
  }
})();

var unary_ops = {
  not: "!",
  bnot: "~",
  neg: "-",
  recip: "1.0/"
}
;(function(){
  for(var id in unary_ops) {
    var op = unary_ops[id]
    exports[id] = makeOp({
      args: ["array", "array"],
      body: {args:["a","b"],
             body:"a="+op+"b"},
      funcName: id
    })
    exports[id+"eq"] = makeOp({
      args: ["array"],
      body: {args:["a"],
             body:"a="+op+"a"},
      rvalue: true,
      count: 2,
      funcName: id+"eq"
    })
  }
})();

var binary_ops = {
  and: "&&",
  or: "||",
  eq: "===",
  neq: "!==",
  lt: "<",
  gt: ">",
  leq: "<=",
  geq: ">="
}
;(function() {
  for(var id in binary_ops) {
    var op = binary_ops[id]
    exports[id] = makeOp({
      args: ["array","array","array"],
      body: {args:["a", "b", "c"],
             body:"a=b"+op+"c"},
      funcName: id
    })
    exports[id+"s"] = makeOp({
      args: ["array","array","scalar"],
      body: {args:["a", "b", "s"],
             body:"a=b"+op+"s"},
      funcName: id+"s"
    })
    exports[id+"eq"] = makeOp({
      args: ["array", "array"],
      body: {args:["a", "b"],
             body:"a=a"+op+"b"},
      rvalue:true,
      count:2,
      funcName: id+"eq"
    })
    exports[id+"seq"] = makeOp({
      args: ["array", "scalar"],
      body: {args:["a","s"],
             body:"a=a"+op+"s"},
      rvalue:true,
      count:2,
      funcName: id+"seq"
    })
  }
})();

var math_unary = [
  "abs",
  "acos",
  "asin",
  "atan",
  "ceil",
  "cos",
  "exp",
  "floor",
  "log",
  "round",
  "sin",
  "sqrt",
  "tan"
]
;(function() {
  for(var i=0; i<math_unary.length; ++i) {
    var f = math_unary[i]
    exports[f] = makeOp({
                    args: ["array", "array"],
                    pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
                    body: {args:["a","b"], body:"a=this_f(b)", thisVars:["this_f"]},
                    funcName: f
                  })
    exports[f+"eq"] = makeOp({
                      args: ["array"],
                      pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
                      body: {args: ["a"], body:"a=this_f(a)", thisVars:["this_f"]},
                      rvalue: true,
                      count: 2,
                      funcName: f+"eq"
                    })
  }
})();

var math_comm = [
  "max",
  "min",
  "atan2",
  "pow"
]
;(function(){
  for(var i=0; i<math_comm.length; ++i) {
    var f= math_comm[i]
    exports[f] = makeOp({
                  args:["array", "array", "array"],
                  pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
                  body: {args:["a","b","c"], body:"a=this_f(b,c)", thisVars:["this_f"]},
                  funcName: f
                })
    exports[f+"s"] = makeOp({
                  args:["array", "array", "scalar"],
                  pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
                  body: {args:["a","b","c"], body:"a=this_f(b,c)", thisVars:["this_f"]},
                  funcName: f+"s"
                  })
    exports[f+"eq"] = makeOp({ args:["array", "array"],
                  pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
                  body: {args:["a","b"], body:"a=this_f(a,b)", thisVars:["this_f"]},
                  rvalue: true,
                  count: 2,
                  funcName: f+"eq"
                  })
    exports[f+"seq"] = makeOp({ args:["array", "scalar"],
                  pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
                  body: {args:["a","b"], body:"a=this_f(a,b)", thisVars:["this_f"]},
                  rvalue:true,
                  count:2,
                  funcName: f+"seq"
                  })
  }
})();

var math_noncomm = [
  "atan2",
  "pow"
]
;(function(){
  for(var i=0; i<math_noncomm.length; ++i) {
    var f= math_noncomm[i]
    exports[f+"op"] = makeOp({
                  args:["array", "array", "array"],
                  pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
                  body: {args:["a","b","c"], body:"a=this_f(c,b)", thisVars:["this_f"]},
                  funcName: f+"op"
                })
    exports[f+"ops"] = makeOp({
                  args:["array", "array", "scalar"],
                  pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
                  body: {args:["a","b","c"], body:"a=this_f(c,b)", thisVars:["this_f"]},
                  funcName: f+"ops"
                  })
    exports[f+"opeq"] = makeOp({ args:["array", "array"],
                  pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
                  body: {args:["a","b"], body:"a=this_f(b,a)", thisVars:["this_f"]},
                  rvalue: true,
                  count: 2,
                  funcName: f+"opeq"
                  })
    exports[f+"opseq"] = makeOp({ args:["array", "scalar"],
                  pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
                  body: {args:["a","b"], body:"a=this_f(b,a)", thisVars:["this_f"]},
                  rvalue:true,
                  count:2,
                  funcName: f+"opseq"
                  })
  }
})();

exports.any = compile({
  args:["array"],
  pre: EmptyProc,
  body: {args:[{name:"a", lvalue:false, rvalue:true, count:1}], body: "if(a){return true}", localVars: [], thisVars: []},
  post: {args:[], localVars:[], thisVars:[], body:"return false"},
  funcName: "any"
})

exports.all = compile({
  args:["array"],
  pre: EmptyProc,
  body: {args:[{name:"x", lvalue:false, rvalue:true, count:1}], body: "if(!x){return false}", localVars: [], thisVars: []},
  post: {args:[], localVars:[], thisVars:[], body:"return true"},
  funcName: "all"
})

exports.sum = compile({
  args:["array"],
  pre: {args:[], localVars:[], thisVars:["this_s"], body:"this_s=0"},
  body: {args:[{name:"a", lvalue:false, rvalue:true, count:1}], body: "this_s+=a", localVars: [], thisVars: ["this_s"]},
  post: {args:[], localVars:[], thisVars:["this_s"], body:"return this_s"},
  funcName: "sum"
})

exports.prod = compile({
  args:["array"],
  pre: {args:[], localVars:[], thisVars:["this_s"], body:"this_s=1"},
  body: {args:[{name:"a", lvalue:false, rvalue:true, count:1}], body: "this_s*=a", localVars: [], thisVars: ["this_s"]},
  post: {args:[], localVars:[], thisVars:["this_s"], body:"return this_s"},
  funcName: "prod"
})

exports.norm2squared = compile({
  args:["array"],
  pre: {args:[], localVars:[], thisVars:["this_s"], body:"this_s=0"},
  body: {args:[{name:"a", lvalue:false, rvalue:true, count:2}], body: "this_s+=a*a", localVars: [], thisVars: ["this_s"]},
  post: {args:[], localVars:[], thisVars:["this_s"], body:"return this_s"},
  funcName: "norm2squared"
})
  
exports.norm2 = compile({
  args:["array"],
  pre: {args:[], localVars:[], thisVars:["this_s"], body:"this_s=0"},
  body: {args:[{name:"a", lvalue:false, rvalue:true, count:2}], body: "this_s+=a*a", localVars: [], thisVars: ["this_s"]},
  post: {args:[], localVars:[], thisVars:["this_s"], body:"return Math.sqrt(this_s)"},
  funcName: "norm2"
})
  

exports.norminf = compile({
  args:["array"],
  pre: {args:[], localVars:[], thisVars:["this_s"], body:"this_s=0"},
  body: {args:[{name:"a", lvalue:false, rvalue:true, count:4}], body:"if(-a>this_s){this_s=-a}else if(a>this_s){this_s=a}", localVars: [], thisVars: ["this_s"]},
  post: {args:[], localVars:[], thisVars:["this_s"], body:"return this_s"},
  funcName: "norminf"
})

exports.norm1 = compile({
  args:["array"],
  pre: {args:[], localVars:[], thisVars:["this_s"], body:"this_s=0"},
  body: {args:[{name:"a", lvalue:false, rvalue:true, count:3}], body: "this_s+=a<0?-a:a", localVars: [], thisVars: ["this_s"]},
  post: {args:[], localVars:[], thisVars:["this_s"], body:"return this_s"},
  funcName: "norm1"
})

exports.sup = compile({
  args: [ "array" ],
  pre:
   { body: "this_h=-Infinity",
     args: [],
     thisVars: [ "this_h" ],
     localVars: [] },
  body:
   { body: "if(_inline_1_arg0_>this_h)this_h=_inline_1_arg0_",
     args: [{"name":"_inline_1_arg0_","lvalue":false,"rvalue":true,"count":2} ],
     thisVars: [ "this_h" ],
     localVars: [] },
  post:
   { body: "return this_h",
     args: [],
     thisVars: [ "this_h" ],
     localVars: [] }
 })

exports.inf = compile({
  args: [ "array" ],
  pre:
   { body: "this_h=Infinity",
     args: [],
     thisVars: [ "this_h" ],
     localVars: [] },
  body:
   { body: "if(_inline_1_arg0_<this_h)this_h=_inline_1_arg0_",
     args: [{"name":"_inline_1_arg0_","lvalue":false,"rvalue":true,"count":2} ],
     thisVars: [ "this_h" ],
     localVars: [] },
  post:
   { body: "return this_h",
     args: [],
     thisVars: [ "this_h" ],
     localVars: [] }
 })

exports.argmin = compile({
  args:["index","array","shape"],
  pre:{
    body:"{this_v=Infinity;this_i=_inline_0_arg2_.slice(0)}",
    args:[
      {name:"_inline_0_arg0_",lvalue:false,rvalue:false,count:0},
      {name:"_inline_0_arg1_",lvalue:false,rvalue:false,count:0},
      {name:"_inline_0_arg2_",lvalue:false,rvalue:true,count:1}
      ],
    thisVars:["this_i","this_v"],
    localVars:[]},
  body:{
    body:"{if(_inline_1_arg1_<this_v){this_v=_inline_1_arg1_;for(var _inline_1_k=0;_inline_1_k<_inline_1_arg0_.length;++_inline_1_k){this_i[_inline_1_k]=_inline_1_arg0_[_inline_1_k]}}}",
    args:[
      {name:"_inline_1_arg0_",lvalue:false,rvalue:true,count:2},
      {name:"_inline_1_arg1_",lvalue:false,rvalue:true,count:2}],
    thisVars:["this_i","this_v"],
    localVars:["_inline_1_k"]},
  post:{
    body:"{return this_i}",
    args:[],
    thisVars:["this_i"],
    localVars:[]}
})

exports.argmax = compile({
  args:["index","array","shape"],
  pre:{
    body:"{this_v=-Infinity;this_i=_inline_0_arg2_.slice(0)}",
    args:[
      {name:"_inline_0_arg0_",lvalue:false,rvalue:false,count:0},
      {name:"_inline_0_arg1_",lvalue:false,rvalue:false,count:0},
      {name:"_inline_0_arg2_",lvalue:false,rvalue:true,count:1}
      ],
    thisVars:["this_i","this_v"],
    localVars:[]},
  body:{
    body:"{if(_inline_1_arg1_>this_v){this_v=_inline_1_arg1_;for(var _inline_1_k=0;_inline_1_k<_inline_1_arg0_.length;++_inline_1_k){this_i[_inline_1_k]=_inline_1_arg0_[_inline_1_k]}}}",
    args:[
      {name:"_inline_1_arg0_",lvalue:false,rvalue:true,count:2},
      {name:"_inline_1_arg1_",lvalue:false,rvalue:true,count:2}],
    thisVars:["this_i","this_v"],
    localVars:["_inline_1_k"]},
  post:{
    body:"{return this_i}",
    args:[],
    thisVars:["this_i"],
    localVars:[]}
})  

exports.random = makeOp({
  args: ["array"],
  pre: {args:[], body:"this_f=Math.random", thisVars:["this_f"]},
  body: {args: ["a"], body:"a=this_f()", thisVars:["this_f"]},
  funcName: "random"
})

exports.assign = makeOp({
  args:["array", "array"],
  body: {args:["a", "b"], body:"a=b"},
  funcName: "assign" })

exports.assigns = makeOp({
  args:["array", "scalar"],
  body: {args:["a", "b"], body:"a=b"},
  funcName: "assigns" })


exports.equals = compile({
  args:["array", "array"],
  pre: EmptyProc,
  body: {args:[{name:"x", lvalue:false, rvalue:true, count:1},
               {name:"y", lvalue:false, rvalue:true, count:1}], 
        body: "if(x!==y){return false}", 
        localVars: [], 
        thisVars: []},
  post: {args:[], localVars:[], thisVars:[], body:"return true"},
  funcName: "equals"
})



},{"cwise-compiler":"/projects/blackice/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/gl-buffer/node_modules/ndarray-ops/node_modules/cwise-compiler/compiler.js"}],"/projects/blackice/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/gl-buffer/node_modules/ndarray-ops/node_modules/cwise-compiler/compiler.js":[function(require,module,exports){
"use strict"

var createThunk = require("./lib/thunk.js")

function Procedure() {
  this.argTypes = []
  this.shimArgs = []
  this.arrayArgs = []
  this.scalarArgs = []
  this.offsetArgs = []
  this.offsetArgIndex = []
  this.indexArgs = []
  this.shapeArgs = []
  this.funcName = ""
  this.pre = null
  this.body = null
  this.post = null
  this.debug = false
}

function compileCwise(user_args) {
  //Create procedure
  var proc = new Procedure()
  
  //Parse blocks
  proc.pre    = user_args.pre
  proc.body   = user_args.body
  proc.post   = user_args.post

  //Parse arguments
  var proc_args = user_args.args.slice(0)
  proc.argTypes = proc_args
  for(var i=0; i<proc_args.length; ++i) {
    var arg_type = proc_args[i]
    if(arg_type === "array") {
      proc.arrayArgs.push(i)
      proc.shimArgs.push("array" + i)
      if(i < proc.pre.args.length && proc.pre.args[i].count>0) {
        throw new Error("cwise: pre() block may not reference array args")
      }
      if(i < proc.post.args.length && proc.post.args[i].count>0) {
        throw new Error("cwise: post() block may not reference array args")
      }
    } else if(arg_type === "scalar") {
      proc.scalarArgs.push(i)
      proc.shimArgs.push("scalar" + i)
    } else if(arg_type === "index") {
      proc.indexArgs.push(i)
      if(i < proc.pre.args.length && proc.pre.args[i].count > 0) {
        throw new Error("cwise: pre() block may not reference array index")
      }
      if(i < proc.body.args.length && proc.body.args[i].lvalue) {
        throw new Error("cwise: body() block may not write to array index")
      }
      if(i < proc.post.args.length && proc.post.args[i].count > 0) {
        throw new Error("cwise: post() block may not reference array index")
      }
    } else if(arg_type === "shape") {
      proc.shapeArgs.push(i)
      if(i < proc.pre.args.length && proc.pre.args[i].lvalue) {
        throw new Error("cwise: pre() block may not write to array shape")
      }
      if(i < proc.body.args.length && proc.body.args[i].lvalue) {
        throw new Error("cwise: body() block may not write to array shape")
      }
      if(i < proc.post.args.length && proc.post.args[i].lvalue) {
        throw new Error("cwise: post() block may not write to array shape")
      }
    } else if(typeof arg_type === "object" && arg_type.offset) {
      proc.argTypes[i] = "offset"
      proc.offsetArgs.push({ array: arg_type.array, offset:arg_type.offset })
      proc.offsetArgIndex.push(i)
    } else {
      throw new Error("cwise: Unknown argument type " + proc_args[i])
    }
  }
  
  //Make sure at least one array argument was specified
  if(proc.arrayArgs.length <= 0) {
    throw new Error("cwise: No array arguments specified")
  }
  
  //Make sure arguments are correct
  if(proc.pre.args.length > proc_args.length) {
    throw new Error("cwise: Too many arguments in pre() block")
  }
  if(proc.body.args.length > proc_args.length) {
    throw new Error("cwise: Too many arguments in body() block")
  }
  if(proc.post.args.length > proc_args.length) {
    throw new Error("cwise: Too many arguments in post() block")
  }

  //Check debug flag
  proc.debug = !!user_args.printCode || !!user_args.debug
  
  //Retrieve name
  proc.funcName = user_args.funcName || "cwise"
  
  //Read in block size
  proc.blockSize = user_args.blockSize || 64

  return createThunk(proc)
}

module.exports = compileCwise

},{"./lib/thunk.js":"/projects/blackice/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/gl-buffer/node_modules/ndarray-ops/node_modules/cwise-compiler/lib/thunk.js"}],"/projects/blackice/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/gl-buffer/node_modules/ndarray-ops/node_modules/cwise-compiler/lib/compile.js":[function(require,module,exports){
"use strict"

var uniq = require("uniq")

function innerFill(order, proc, body) {
  var dimension = order.length
    , nargs = proc.arrayArgs.length
    , has_index = proc.indexArgs.length>0
    , code = []
    , vars = []
    , idx=0, pidx=0, i, j
  for(i=0; i<dimension; ++i) {
    vars.push(["i",i,"=0"].join(""))
  }
  //Compute scan deltas
  for(j=0; j<nargs; ++j) {
    for(i=0; i<dimension; ++i) {
      pidx = idx
      idx = order[i]
      if(i === 0) {
        vars.push(["d",j,"s",i,"=t",j,"p",idx].join(""))
      } else {
        vars.push(["d",j,"s",i,"=(t",j,"p",idx,"-s",pidx,"*t",j,"p",pidx,")"].join(""))
      }
    }
  }
  code.push("var " + vars.join(","))
  //Scan loop
  for(i=dimension-1; i>=0; --i) {
    idx = order[i]
    code.push(["for(i",i,"=0;i",i,"<s",idx,";++i",i,"){"].join(""))
  }
  //Push body of inner loop
  code.push(body)
  //Advance scan pointers
  for(i=0; i<dimension; ++i) {
    pidx = idx
    idx = order[i]
    for(j=0; j<nargs; ++j) {
      code.push(["p",j,"+=d",j,"s",i].join(""))
    }
    if(has_index) {
      if(i > 0) {
        code.push(["index[",pidx,"]-=s",pidx].join(""))
      }
      code.push(["++index[",idx,"]"].join(""))
    }
    code.push("}")
  }
  return code.join("\n")
}

function outerFill(matched, order, proc, body) {
  var dimension = order.length
    , nargs = proc.arrayArgs.length
    , blockSize = proc.blockSize
    , has_index = proc.indexArgs.length > 0
    , code = []
  for(var i=0; i<nargs; ++i) {
    code.push(["var offset",i,"=p",i].join(""))
  }
  //Generate matched loops
  for(var i=matched; i<dimension; ++i) {
    code.push(["for(var j"+i+"=SS[", order[i], "]|0;j", i, ">0;){"].join(""))
    code.push(["if(j",i,"<",blockSize,"){"].join(""))
    code.push(["s",order[i],"=j",i].join(""))
    code.push(["j",i,"=0"].join(""))
    code.push(["}else{s",order[i],"=",blockSize].join(""))
    code.push(["j",i,"-=",blockSize,"}"].join(""))
    if(has_index) {
      code.push(["index[",order[i],"]=j",i].join(""))
    }
  }
  for(var i=0; i<nargs; ++i) {
    var indexStr = ["offset"+i]
    for(var j=matched; j<dimension; ++j) {
      indexStr.push(["j",j,"*t",i,"p",order[j]].join(""))
    }
    code.push(["p",i,"=(",indexStr.join("+"),")"].join(""))
  }
  code.push(innerFill(order, proc, body))
  for(var i=matched; i<dimension; ++i) {
    code.push("}")
  }
  return code.join("\n")
}

//Count the number of compatible inner orders
function countMatches(orders) {
  var matched = 0, dimension = orders[0].length
  while(matched < dimension) {
    for(var j=1; j<orders.length; ++j) {
      if(orders[j][matched] !== orders[0][matched]) {
        return matched
      }
    }
    ++matched
  }
  return matched
}

//Processes a block according to the given data types
function processBlock(block, proc, dtypes) {
  var code = block.body
  var pre = []
  var post = []
  for(var i=0; i<block.args.length; ++i) {
    var carg = block.args[i]
    if(carg.count <= 0) {
      continue
    }
    var re = new RegExp(carg.name, "g")
    var ptrStr = ""
    var arrNum = proc.arrayArgs.indexOf(i)
    switch(proc.argTypes[i]) {
      case "offset":
        var offArgIndex = proc.offsetArgIndex.indexOf(i)
        var offArg = proc.offsetArgs[offArgIndex]
        arrNum = offArg.array
        ptrStr = "+q" + offArgIndex
      case "array":
        ptrStr = "p" + arrNum + ptrStr
        var localStr = "l" + i
        var arrStr = "a" + arrNum
        if(carg.count === 1) {
          if(dtypes[arrNum] === "generic") {
            if(carg.lvalue) {
              pre.push(["var ", localStr, "=", arrStr, ".get(", ptrStr, ")"].join(""))
              code = code.replace(re, localStr)
              post.push([arrStr, ".set(", ptrStr, ",", localStr,")"].join(""))
            } else {
              code = code.replace(re, [arrStr, ".get(", ptrStr, ")"].join(""))
            }
          } else {
            code = code.replace(re, [arrStr, "[", ptrStr, "]"].join(""))
          }
        } else if(dtypes[arrNum] === "generic") {
          pre.push(["var ", localStr, "=", arrStr, ".get(", ptrStr, ")"].join(""))
          code = code.replace(re, localStr)
          if(carg.lvalue) {
            post.push([arrStr, ".set(", ptrStr, ",", localStr,")"].join(""))
          }
        } else {
          pre.push(["var ", localStr, "=", arrStr, "[", ptrStr, "]"].join(""))
          code = code.replace(re, localStr)
          if(carg.lvalue) {
            post.push([arrStr, "[", ptrStr, "]=", localStr].join(""))
          }
        }
      break
      case "scalar":
        code = code.replace(re, "Y" + proc.scalarArgs.indexOf(i))
      break
      case "index":
        code = code.replace(re, "index")
      break
      case "shape":
        code = code.replace(re, "shape")
      break
    }
  }
  return [pre.join("\n"), code, post.join("\n")].join("\n").trim()
}

function typeSummary(dtypes) {
  var summary = new Array(dtypes.length)
  var allEqual = true
  for(var i=0; i<dtypes.length; ++i) {
    var t = dtypes[i]
    var digits = t.match(/\d+/)
    if(!digits) {
      digits = ""
    } else {
      digits = digits[0]
    }
    if(t.charAt(0) === 0) {
      summary[i] = "u" + t.charAt(1) + digits
    } else {
      summary[i] = t.charAt(0) + digits
    }
    if(i > 0) {
      allEqual = allEqual && summary[i] === summary[i-1]
    }
  }
  if(allEqual) {
    return summary[0]
  }
  return summary.join("")
}

//Generates a cwise operator
function generateCWiseOp(proc, typesig) {

  //Compute dimension
  var dimension = typesig[1].length|0
  var orders = new Array(proc.arrayArgs.length)
  var dtypes = new Array(proc.arrayArgs.length)

  //First create arguments for procedure
  var arglist = ["SS"]
  var code = ["'use strict'"]
  var vars = []
  
  for(var j=0; j<dimension; ++j) {
    vars.push(["s", j, "=SS[", j, "]"].join(""))
  }
  for(var i=0; i<proc.arrayArgs.length; ++i) {
    arglist.push("a"+i)
    arglist.push("t"+i)
    arglist.push("p"+i)
    dtypes[i] = typesig[2*i]
    orders[i] = typesig[2*i+1]
    
    for(var j=0; j<dimension; ++j) {
      vars.push(["t",i,"p",j,"=t",i,"[",j,"]"].join(""))
    }
  }
  for(var i=0; i<proc.scalarArgs.length; ++i) {
    arglist.push("Y" + i)
  }
  if(proc.shapeArgs.length > 0) {
    vars.push("shape=SS.slice(0)")
  }
  if(proc.indexArgs.length > 0) {
    var zeros = new Array(dimension)
    for(var i=0; i<dimension; ++i) {
      zeros[i] = "0"
    }
    vars.push(["index=[", zeros.join(","), "]"].join(""))
  }
  for(var i=0; i<proc.offsetArgs.length; ++i) {
    var off_arg = proc.offsetArgs[i]
    var init_string = []
    for(var j=0; j<off_arg.offset.length; ++j) {
      if(off_arg.offset[j] === 0) {
        continue
      } else if(off_arg.offset[j] === 1) {
        init_string.push(["t", off_arg.array, "p", j].join(""))      
      } else {
        init_string.push([off_arg.offset[j], "*t", off_arg.array, "p", j].join(""))
      }
    }
    if(init_string.length === 0) {
      vars.push("q" + i + "=0")
    } else {
      vars.push(["q", i, "=", init_string.join("+")].join(""))
    }
  }

  //Prepare this variables
  var thisVars = uniq([].concat(proc.pre.thisVars)
                      .concat(proc.body.thisVars)
                      .concat(proc.post.thisVars))
  vars = vars.concat(thisVars)
  code.push("var " + vars.join(","))
  for(var i=0; i<proc.arrayArgs.length; ++i) {
    code.push("p"+i+"|=0")
  }
  
  //Inline prelude
  if(proc.pre.body.length > 3) {
    code.push(processBlock(proc.pre, proc, dtypes))
  }

  //Process body
  var body = processBlock(proc.body, proc, dtypes)
  var matched = countMatches(orders)
  if(matched < dimension) {
    code.push(outerFill(matched, orders[0], proc, body))
  } else {
    code.push(innerFill(orders[0], proc, body))
  }

  //Inline epilog
  if(proc.post.body.length > 3) {
    code.push(processBlock(proc.post, proc, dtypes))
  }
  
  if(proc.debug) {
    console.log("Generated cwise routine for ", typesig, ":\n\n", code.join("\n"))
  }
  
  var loopName = [(proc.funcName||"unnamed"), "_cwise_loop_", orders[0].join("s"),"m",matched,typeSummary(dtypes)].join("")
  var f = new Function(["function ",loopName,"(", arglist.join(","),"){", code.join("\n"),"} return ", loopName].join(""))
  return f()
}
module.exports = generateCWiseOp
},{"uniq":"/projects/blackice/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/gl-buffer/node_modules/ndarray-ops/node_modules/cwise-compiler/node_modules/uniq/uniq.js"}],"/projects/blackice/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/gl-buffer/node_modules/ndarray-ops/node_modules/cwise-compiler/lib/thunk.js":[function(require,module,exports){
"use strict"

var compile = require("./compile.js")

function createThunk(proc) {
  var code = ["'use strict'", "var CACHED={}"]
  var vars = []
  var thunkName = proc.funcName + "_cwise_thunk"
  
  //Build thunk
  code.push(["return function ", thunkName, "(", proc.shimArgs.join(","), "){"].join(""))
  var typesig = []
  var string_typesig = []
  var proc_args = [["array",proc.arrayArgs[0],".shape"].join("")]
  for(var i=0; i<proc.arrayArgs.length; ++i) {
    var j = proc.arrayArgs[i]
    vars.push(["t", j, "=array", j, ".dtype,",
               "r", j, "=array", j, ".order"].join(""))
    typesig.push("t" + j)
    typesig.push("r" + j)
    string_typesig.push("t"+j)
    string_typesig.push("r"+j+".join()")
    proc_args.push("array" + j + ".data")
    proc_args.push("array" + j + ".stride")
    proc_args.push("array" + j + ".offset|0")
  }
  for(var i=0; i<proc.scalarArgs.length; ++i) {
    proc_args.push("scalar" + proc.scalarArgs[i])
  }
  vars.push(["type=[", string_typesig.join(","), "].join()"].join(""))
  vars.push("proc=CACHED[type]")
  code.push("var " + vars.join(","))
  
  code.push(["if(!proc){",
             "CACHED[type]=proc=compile([", typesig.join(","), "])}",
             "return proc(", proc_args.join(","), ")}"].join(""))

  if(proc.debug) {
    console.log("Generated thunk:", code.join("\n"))
  }
  
  //Compile thunk
  var thunk = new Function("compile", code.join("\n"))
  return thunk(compile.bind(undefined, proc))
}

module.exports = createThunk

},{"./compile.js":"/projects/blackice/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/gl-buffer/node_modules/ndarray-ops/node_modules/cwise-compiler/lib/compile.js"}],"/projects/blackice/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/gl-buffer/node_modules/ndarray-ops/node_modules/cwise-compiler/node_modules/uniq/uniq.js":[function(require,module,exports){
"use strict"

function unique_pred(list, compare) {
  var ptr = 1
    , len = list.length
    , a=list[0], b=list[0]
  for(var i=1; i<len; ++i) {
    b = a
    a = list[i]
    if(compare(a, b)) {
      if(i === ptr) {
        ptr++
        continue
      }
      list[ptr++] = a
    }
  }
  list.length = ptr
  return list
}

function unique_eq(list) {
  var ptr = 1
    , len = list.length
    , a=list[0], b = list[0]
  for(var i=1; i<len; ++i, b=a) {
    b = a
    a = list[i]
    if(a !== b) {
      if(i === ptr) {
        ptr++
        continue
      }
      list[ptr++] = a
    }
  }
  list.length = ptr
  return list
}

function unique(list, compare, sorted) {
  if(list.length === 0) {
    return list
  }
  if(compare) {
    if(!sorted) {
      list.sort(compare)
    }
    return unique_pred(list, compare)
  }
  if(!sorted) {
    list.sort()
  }
  return unique_eq(list)
}

module.exports = unique

},{}],"/projects/blackice/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/gl-buffer/node_modules/typedarray-pool/node_modules/bit-twiddle/twiddle.js":[function(require,module,exports){
/**
 * Bit twiddling hacks for JavaScript.
 *
 * Author: Mikola Lysenko
 *
 * Ported from Stanford bit twiddling hack library:
 *    http://graphics.stanford.edu/~seander/bithacks.html
 */

"use strict"; "use restrict";

//Number of bits in an integer
var INT_BITS = 32;

//Constants
exports.INT_BITS  = INT_BITS;
exports.INT_MAX   =  0x7fffffff;
exports.INT_MIN   = -1<<(INT_BITS-1);

//Returns -1, 0, +1 depending on sign of x
exports.sign = function(v) {
  return (v > 0) - (v < 0);
}

//Computes absolute value of integer
exports.abs = function(v) {
  var mask = v >> (INT_BITS-1);
  return (v ^ mask) - mask;
}

//Computes minimum of integers x and y
exports.min = function(x, y) {
  return y ^ ((x ^ y) & -(x < y));
}

//Computes maximum of integers x and y
exports.max = function(x, y) {
  return x ^ ((x ^ y) & -(x < y));
}

//Checks if a number is a power of two
exports.isPow2 = function(v) {
  return !(v & (v-1)) && (!!v);
}

//Computes log base 2 of v
exports.log2 = function(v) {
  var r, shift;
  r =     (v > 0xFFFF) << 4; v >>>= r;
  shift = (v > 0xFF  ) << 3; v >>>= shift; r |= shift;
  shift = (v > 0xF   ) << 2; v >>>= shift; r |= shift;
  shift = (v > 0x3   ) << 1; v >>>= shift; r |= shift;
  return r | (v >> 1);
}

//Computes log base 10 of v
exports.log10 = function(v) {
  return  (v >= 1000000000) ? 9 : (v >= 100000000) ? 8 : (v >= 10000000) ? 7 :
          (v >= 1000000) ? 6 : (v >= 100000) ? 5 : (v >= 10000) ? 4 :
          (v >= 1000) ? 3 : (v >= 100) ? 2 : (v >= 10) ? 1 : 0;
}

//Counts number of bits
exports.popCount = function(v) {
  v = v - ((v >>> 1) & 0x55555555);
  v = (v & 0x33333333) + ((v >>> 2) & 0x33333333);
  return ((v + (v >>> 4) & 0xF0F0F0F) * 0x1010101) >>> 24;
}

//Counts number of trailing zeros
function countTrailingZeros(v) {
  var c = 32;
  v &= -v;
  if (v) c--;
  if (v & 0x0000FFFF) c -= 16;
  if (v & 0x00FF00FF) c -= 8;
  if (v & 0x0F0F0F0F) c -= 4;
  if (v & 0x33333333) c -= 2;
  if (v & 0x55555555) c -= 1;
  return c;
}
exports.countTrailingZeros = countTrailingZeros;

//Rounds to next power of 2
exports.nextPow2 = function(v) {
  v += v === 0;
  --v;
  v |= v >>> 1;
  v |= v >>> 2;
  v |= v >>> 4;
  v |= v >>> 8;
  v |= v >>> 16;
  return v + 1;
}

//Rounds down to previous power of 2
exports.prevPow2 = function(v) {
  v |= v >>> 1;
  v |= v >>> 2;
  v |= v >>> 4;
  v |= v >>> 8;
  v |= v >>> 16;
  return v - (v>>>1);
}

//Computes parity of word
exports.parity = function(v) {
  v ^= v >>> 16;
  v ^= v >>> 8;
  v ^= v >>> 4;
  v &= 0xf;
  return (0x6996 >>> v) & 1;
}

var REVERSE_TABLE = new Array(256);

(function(tab) {
  for(var i=0; i<256; ++i) {
    var v = i, r = i, s = 7;
    for (v >>>= 1; v; v >>>= 1) {
      r <<= 1;
      r |= v & 1;
      --s;
    }
    tab[i] = (r << s) & 0xff;
  }
})(REVERSE_TABLE);

//Reverse bits in a 32 bit word
exports.reverse = function(v) {
  return  (REVERSE_TABLE[ v         & 0xff] << 24) |
          (REVERSE_TABLE[(v >>> 8)  & 0xff] << 16) |
          (REVERSE_TABLE[(v >>> 16) & 0xff] << 8)  |
           REVERSE_TABLE[(v >>> 24) & 0xff];
}

//Interleave bits of 2 coordinates with 16 bits.  Useful for fast quadtree codes
exports.interleave2 = function(x, y) {
  x &= 0xFFFF;
  x = (x | (x << 8)) & 0x00FF00FF;
  x = (x | (x << 4)) & 0x0F0F0F0F;
  x = (x | (x << 2)) & 0x33333333;
  x = (x | (x << 1)) & 0x55555555;

  y &= 0xFFFF;
  y = (y | (y << 8)) & 0x00FF00FF;
  y = (y | (y << 4)) & 0x0F0F0F0F;
  y = (y | (y << 2)) & 0x33333333;
  y = (y | (y << 1)) & 0x55555555;

  return x | (y << 1);
}

//Extracts the nth interleaved component
exports.deinterleave2 = function(v, n) {
  v = (v >>> n) & 0x55555555;
  v = (v | (v >>> 1))  & 0x33333333;
  v = (v | (v >>> 2))  & 0x0F0F0F0F;
  v = (v | (v >>> 4))  & 0x00FF00FF;
  v = (v | (v >>> 16)) & 0x000FFFF;
  return (v << 16) >> 16;
}


//Interleave bits of 3 coordinates, each with 10 bits.  Useful for fast octree codes
exports.interleave3 = function(x, y, z) {
  x &= 0x3FF;
  x  = (x | (x<<16)) & 4278190335;
  x  = (x | (x<<8))  & 251719695;
  x  = (x | (x<<4))  & 3272356035;
  x  = (x | (x<<2))  & 1227133513;

  y &= 0x3FF;
  y  = (y | (y<<16)) & 4278190335;
  y  = (y | (y<<8))  & 251719695;
  y  = (y | (y<<4))  & 3272356035;
  y  = (y | (y<<2))  & 1227133513;
  x |= (y << 1);
  
  z &= 0x3FF;
  z  = (z | (z<<16)) & 4278190335;
  z  = (z | (z<<8))  & 251719695;
  z  = (z | (z<<4))  & 3272356035;
  z  = (z | (z<<2))  & 1227133513;
  
  return x | (z << 2);
}

//Extracts nth interleaved component of a 3-tuple
exports.deinterleave3 = function(v, n) {
  v = (v >>> n)       & 1227133513;
  v = (v | (v>>>2))   & 3272356035;
  v = (v | (v>>>4))   & 251719695;
  v = (v | (v>>>8))   & 4278190335;
  v = (v | (v>>>16))  & 0x3FF;
  return (v<<22)>>22;
}

//Computes next combination in colexicographic order (this is mistakenly called nextPermutation on the bit twiddling hacks page)
exports.nextCombination = function(v) {
  var t = v | (v - 1);
  return (t + 1) | (((~t & -~t) - 1) >>> (countTrailingZeros(v) + 1));
}


},{}],"/projects/blackice/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/gl-buffer/node_modules/typedarray-pool/node_modules/dup/dup.js":[function(require,module,exports){
"use strict"

function dupe_array(count, value, i) {
  var c = count[i]|0
  if(c <= 0) {
    return []
  }
  var result = new Array(c), j
  if(i === count.length-1) {
    for(j=0; j<c; ++j) {
      result[j] = value
    }
  } else {
    for(j=0; j<c; ++j) {
      result[j] = dupe_array(count, value, i+1)
    }
  }
  return result
}

function dupe_number(count, value) {
  var result, i
  result = new Array(count)
  for(i=0; i<count; ++i) {
    result[i] = value
  }
  return result
}

function dupe(count, value) {
  if(typeof value === "undefined") {
    value = 0
  }
  switch(typeof count) {
    case "number":
      if(count > 0) {
        return dupe_number(count|0, value)
      }
    break
    case "object":
      if(typeof (count.length) === "number") {
        return dupe_array(count, value, 0)
      }
    break
  }
  return []
}

module.exports = dupe
},{}],"/projects/blackice/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/gl-buffer/node_modules/typedarray-pool/pool.js":[function(require,module,exports){
(function (global,Buffer){
'use strict'

var bits = require('bit-twiddle')
var dup = require('dup')

//Legacy pool support
if(!global.__TYPEDARRAY_POOL) {
  global.__TYPEDARRAY_POOL = {
      UINT8   : dup([32, 0])
    , UINT16  : dup([32, 0])
    , UINT32  : dup([32, 0])
    , INT8    : dup([32, 0])
    , INT16   : dup([32, 0])
    , INT32   : dup([32, 0])
    , FLOAT   : dup([32, 0])
    , DOUBLE  : dup([32, 0])
    , DATA    : dup([32, 0])
    , UINT8C  : dup([32, 0])
    , BUFFER  : dup([32, 0])
  }
}

var hasUint8C = (typeof Uint8ClampedArray) !== 'undefined'
var POOL = global.__TYPEDARRAY_POOL

//Upgrade pool
if(!POOL.UINT8C) {
  POOL.UINT8C = dup([32, 0])
}
if(!POOL.BUFFER) {
  POOL.BUFFER = dup([32, 0])
}

//New technique: Only allocate from ArrayBufferView and Buffer
var DATA    = POOL.DATA
  , BUFFER  = POOL.BUFFER

exports.free = function free(array) {
  if(Buffer.isBuffer(array)) {
    BUFFER[bits.log2(array.length)].push(array)
  } else {
    if(Object.prototype.toString.call(array) !== '[object ArrayBuffer]') {
      array = array.buffer
    }
    if(!array) {
      return
    }
    var n = array.length || array.byteLength
    var log_n = bits.log2(n)|0
    DATA[log_n].push(array)
  }
}

function freeArrayBuffer(buffer) {
  if(!buffer) {
    return
  }
  var n = buffer.length || buffer.byteLength
  var log_n = bits.log2(n)
  DATA[log_n].push(buffer)
}

function freeTypedArray(array) {
  freeArrayBuffer(array.buffer)
}

exports.freeUint8 =
exports.freeUint16 =
exports.freeUint32 =
exports.freeInt8 =
exports.freeInt16 =
exports.freeInt32 =
exports.freeFloat32 = 
exports.freeFloat =
exports.freeFloat64 = 
exports.freeDouble = 
exports.freeUint8Clamped = 
exports.freeDataView = freeTypedArray

exports.freeArrayBuffer = freeArrayBuffer

exports.freeBuffer = function freeBuffer(array) {
  BUFFER[bits.log2(array.length)].push(array)
}

exports.malloc = function malloc(n, dtype) {
  if(dtype === undefined || dtype === 'arraybuffer') {
    return mallocArrayBuffer(n)
  } else {
    switch(dtype) {
      case 'uint8':
        return mallocUint8(n)
      case 'uint16':
        return mallocUint16(n)
      case 'uint32':
        return mallocUint32(n)
      case 'int8':
        return mallocInt8(n)
      case 'int16':
        return mallocInt16(n)
      case 'int32':
        return mallocInt32(n)
      case 'float':
      case 'float32':
        return mallocFloat(n)
      case 'double':
      case 'float64':
        return mallocDouble(n)
      case 'uint8_clamped':
        return mallocUint8Clamped(n)
      case 'buffer':
        return mallocBuffer(n)
      case 'data':
      case 'dataview':
        return mallocDataView(n)

      default:
        return null
    }
  }
  return null
}

function mallocArrayBuffer(n) {
  var n = bits.nextPow2(n)
  var log_n = bits.log2(n)
  var d = DATA[log_n]
  if(d.length > 0) {
    return d.pop()
  }
  return new ArrayBuffer(n)
}
exports.mallocArrayBuffer = mallocArrayBuffer

function mallocUint8(n) {
  return new Uint8Array(mallocArrayBuffer(n), 0, n)
}
exports.mallocUint8 = mallocUint8

function mallocUint16(n) {
  return new Uint16Array(mallocArrayBuffer(2*n), 0, n)
}
exports.mallocUint16 = mallocUint16

function mallocUint32(n) {
  return new Uint32Array(mallocArrayBuffer(4*n), 0, n)
}
exports.mallocUint32 = mallocUint32

function mallocInt8(n) {
  return new Int8Array(mallocArrayBuffer(n), 0, n)
}
exports.mallocInt8 = mallocInt8

function mallocInt16(n) {
  return new Int16Array(mallocArrayBuffer(2*n), 0, n)
}
exports.mallocInt16 = mallocInt16

function mallocInt32(n) {
  return new Int32Array(mallocArrayBuffer(4*n), 0, n)
}
exports.mallocInt32 = mallocInt32

function mallocFloat(n) {
  return new Float32Array(mallocArrayBuffer(4*n), 0, n)
}
exports.mallocFloat32 = exports.mallocFloat = mallocFloat

function mallocDouble(n) {
  return new Float64Array(mallocArrayBuffer(8*n), 0, n)
}
exports.mallocFloat64 = exports.mallocDouble = mallocDouble

function mallocUint8Clamped(n) {
  if(hasUint8C) {
    return new Uint8ClampedArray(mallocArrayBuffer(n), 0, n)
  } else {
    return mallocUint8(n)
  }
}
exports.mallocUint8Clamped = mallocUint8Clamped

function mallocDataView(n) {
  return new DataView(mallocArrayBuffer(n), 0, n)
}
exports.mallocDataView = mallocDataView

function mallocBuffer(n) {
  n = bits.nextPow2(n)
  var log_n = bits.log2(n)
  var cache = BUFFER[log_n]
  if(cache.length > 0) {
    return cache.pop()
  }
  return new Buffer(n)
}
exports.mallocBuffer = mallocBuffer

exports.clearCache = function clearCache() {
  for(var i=0; i<32; ++i) {
    POOL.UINT8[i].length = 0
    POOL.UINT16[i].length = 0
    POOL.UINT32[i].length = 0
    POOL.INT8[i].length = 0
    POOL.INT16[i].length = 0
    POOL.INT32[i].length = 0
    POOL.FLOAT[i].length = 0
    POOL.DOUBLE[i].length = 0
    POOL.UINT8C[i].length = 0
    DATA[i].length = 0
    BUFFER[i].length = 0
  }
}
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer)
},{"bit-twiddle":"/projects/blackice/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/gl-buffer/node_modules/typedarray-pool/node_modules/bit-twiddle/twiddle.js","buffer":"/projects/blackice/node_modules/browserify/node_modules/buffer/index.js","dup":"/projects/blackice/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/gl-buffer/node_modules/typedarray-pool/node_modules/dup/dup.js"}],"/projects/blackice/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/gl-buffer/node_modules/webglew/node_modules/weak-map/weak-map.js":[function(require,module,exports){
// Copyright (C) 2011 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Install a leaky WeakMap emulation on platforms that
 * don't provide a built-in one.
 *
 * <p>Assumes that an ES5 platform where, if {@code WeakMap} is
 * already present, then it conforms to the anticipated ES6
 * specification. To run this file on an ES5 or almost ES5
 * implementation where the {@code WeakMap} specification does not
 * quite conform, run <code>repairES5.js</code> first.
 *
 * <p>Even though WeakMapModule is not global, the linter thinks it
 * is, which is why it is in the overrides list below.
 *
 * <p>NOTE: Before using this WeakMap emulation in a non-SES
 * environment, see the note below about hiddenRecord.
 *
 * @author Mark S. Miller
 * @requires crypto, ArrayBuffer, Uint8Array, navigator, console
 * @overrides WeakMap, ses, Proxy
 * @overrides WeakMapModule
 */

/**
 * This {@code WeakMap} emulation is observably equivalent to the
 * ES-Harmony WeakMap, but with leakier garbage collection properties.
 *
 * <p>As with true WeakMaps, in this emulation, a key does not
 * retain maps indexed by that key and (crucially) a map does not
 * retain the keys it indexes. A map by itself also does not retain
 * the values associated with that map.
 *
 * <p>However, the values associated with a key in some map are
 * retained so long as that key is retained and those associations are
 * not overridden. For example, when used to support membranes, all
 * values exported from a given membrane will live for the lifetime
 * they would have had in the absence of an interposed membrane. Even
 * when the membrane is revoked, all objects that would have been
 * reachable in the absence of revocation will still be reachable, as
 * far as the GC can tell, even though they will no longer be relevant
 * to ongoing computation.
 *
 * <p>The API implemented here is approximately the API as implemented
 * in FF6.0a1 and agreed to by MarkM, Andreas Gal, and Dave Herman,
 * rather than the offially approved proposal page. TODO(erights):
 * upgrade the ecmascript WeakMap proposal page to explain this API
 * change and present to EcmaScript committee for their approval.
 *
 * <p>The first difference between the emulation here and that in
 * FF6.0a1 is the presence of non enumerable {@code get___, has___,
 * set___, and delete___} methods on WeakMap instances to represent
 * what would be the hidden internal properties of a primitive
 * implementation. Whereas the FF6.0a1 WeakMap.prototype methods
 * require their {@code this} to be a genuine WeakMap instance (i.e.,
 * an object of {@code [[Class]]} "WeakMap}), since there is nothing
 * unforgeable about the pseudo-internal method names used here,
 * nothing prevents these emulated prototype methods from being
 * applied to non-WeakMaps with pseudo-internal methods of the same
 * names.
 *
 * <p>Another difference is that our emulated {@code
 * WeakMap.prototype} is not itself a WeakMap. A problem with the
 * current FF6.0a1 API is that WeakMap.prototype is itself a WeakMap
 * providing ambient mutability and an ambient communications
 * channel. Thus, if a WeakMap is already present and has this
 * problem, repairES5.js wraps it in a safe wrappper in order to
 * prevent access to this channel. (See
 * PATCH_MUTABLE_FROZEN_WEAKMAP_PROTO in repairES5.js).
 */

/**
 * If this is a full <a href=
 * "http://code.google.com/p/es-lab/wiki/SecureableES5"
 * >secureable ES5</a> platform and the ES-Harmony {@code WeakMap} is
 * absent, install an approximate emulation.
 *
 * <p>If WeakMap is present but cannot store some objects, use our approximate
 * emulation as a wrapper.
 *
 * <p>If this is almost a secureable ES5 platform, then WeakMap.js
 * should be run after repairES5.js.
 *
 * <p>See {@code WeakMap} for documentation of the garbage collection
 * properties of this WeakMap emulation.
 */
(function WeakMapModule() {
  "use strict";

  if (typeof ses !== 'undefined' && ses.ok && !ses.ok()) {
    // already too broken, so give up
    return;
  }

  /**
   * In some cases (current Firefox), we must make a choice betweeen a
   * WeakMap which is capable of using all varieties of host objects as
   * keys and one which is capable of safely using proxies as keys. See
   * comments below about HostWeakMap and DoubleWeakMap for details.
   *
   * This function (which is a global, not exposed to guests) marks a
   * WeakMap as permitted to do what is necessary to index all host
   * objects, at the cost of making it unsafe for proxies.
   *
   * Do not apply this function to anything which is not a genuine
   * fresh WeakMap.
   */
  function weakMapPermitHostObjects(map) {
    // identity of function used as a secret -- good enough and cheap
    if (map.permitHostObjects___) {
      map.permitHostObjects___(weakMapPermitHostObjects);
    }
  }
  if (typeof ses !== 'undefined') {
    ses.weakMapPermitHostObjects = weakMapPermitHostObjects;
  }

  // IE 11 has no Proxy but has a broken WeakMap such that we need to patch
  // it using DoubleWeakMap; this flag tells DoubleWeakMap so.
  var doubleWeakMapCheckSilentFailure = false;

  // Check if there is already a good-enough WeakMap implementation, and if so
  // exit without replacing it.
  if (typeof WeakMap === 'function') {
    var HostWeakMap = WeakMap;
    // There is a WeakMap -- is it good enough?
    if (typeof navigator !== 'undefined' &&
        /Firefox/.test(navigator.userAgent)) {
      // We're now *assuming not*, because as of this writing (2013-05-06)
      // Firefox's WeakMaps have a miscellany of objects they won't accept, and
      // we don't want to make an exhaustive list, and testing for just one
      // will be a problem if that one is fixed alone (as they did for Event).

      // If there is a platform that we *can* reliably test on, here's how to
      // do it:
      //  var problematic = ... ;
      //  var testHostMap = new HostWeakMap();
      //  try {
      //    testHostMap.set(problematic, 1);  // Firefox 20 will throw here
      //    if (testHostMap.get(problematic) === 1) {
      //      return;
      //    }
      //  } catch (e) {}

    } else {
      // IE 11 bug: WeakMaps silently fail to store frozen objects.
      var testMap = new HostWeakMap();
      var testObject = Object.freeze({});
      testMap.set(testObject, 1);
      if (testMap.get(testObject) !== 1) {
        doubleWeakMapCheckSilentFailure = true;
        // Fall through to installing our WeakMap.
      } else {
        module.exports = WeakMap;
        return;
      }
    }
  }

  var hop = Object.prototype.hasOwnProperty;
  var gopn = Object.getOwnPropertyNames;
  var defProp = Object.defineProperty;
  var isExtensible = Object.isExtensible;

  /**
   * Security depends on HIDDEN_NAME being both <i>unguessable</i> and
   * <i>undiscoverable</i> by untrusted code.
   *
   * <p>Given the known weaknesses of Math.random() on existing
   * browsers, it does not generate unguessability we can be confident
   * of.
   *
   * <p>It is the monkey patching logic in this file that is intended
   * to ensure undiscoverability. The basic idea is that there are
   * three fundamental means of discovering properties of an object:
   * The for/in loop, Object.keys(), and Object.getOwnPropertyNames(),
   * as well as some proposed ES6 extensions that appear on our
   * whitelist. The first two only discover enumerable properties, and
   * we only use HIDDEN_NAME to name a non-enumerable property, so the
   * only remaining threat should be getOwnPropertyNames and some
   * proposed ES6 extensions that appear on our whitelist. We monkey
   * patch them to remove HIDDEN_NAME from the list of properties they
   * returns.
   *
   * <p>TODO(erights): On a platform with built-in Proxies, proxies
   * could be used to trap and thereby discover the HIDDEN_NAME, so we
   * need to monkey patch Proxy.create, Proxy.createFunction, etc, in
   * order to wrap the provided handler with the real handler which
   * filters out all traps using HIDDEN_NAME.
   *
   * <p>TODO(erights): Revisit Mike Stay's suggestion that we use an
   * encapsulated function at a not-necessarily-secret name, which
   * uses the Stiegler shared-state rights amplification pattern to
   * reveal the associated value only to the WeakMap in which this key
   * is associated with that value. Since only the key retains the
   * function, the function can also remember the key without causing
   * leakage of the key, so this doesn't violate our general gc
   * goals. In addition, because the name need not be a guarded
   * secret, we could efficiently handle cross-frame frozen keys.
   */
  var HIDDEN_NAME_PREFIX = 'weakmap:';
  var HIDDEN_NAME = HIDDEN_NAME_PREFIX + 'ident:' + Math.random() + '___';

  if (typeof crypto !== 'undefined' &&
      typeof crypto.getRandomValues === 'function' &&
      typeof ArrayBuffer === 'function' &&
      typeof Uint8Array === 'function') {
    var ab = new ArrayBuffer(25);
    var u8s = new Uint8Array(ab);
    crypto.getRandomValues(u8s);
    HIDDEN_NAME = HIDDEN_NAME_PREFIX + 'rand:' +
      Array.prototype.map.call(u8s, function(u8) {
        return (u8 % 36).toString(36);
      }).join('') + '___';
  }

  function isNotHiddenName(name) {
    return !(
        name.substr(0, HIDDEN_NAME_PREFIX.length) == HIDDEN_NAME_PREFIX &&
        name.substr(name.length - 3) === '___');
  }

  /**
   * Monkey patch getOwnPropertyNames to avoid revealing the
   * HIDDEN_NAME.
   *
   * <p>The ES5.1 spec requires each name to appear only once, but as
   * of this writing, this requirement is controversial for ES6, so we
   * made this code robust against this case. If the resulting extra
   * search turns out to be expensive, we can probably relax this once
   * ES6 is adequately supported on all major browsers, iff no browser
   * versions we support at that time have relaxed this constraint
   * without providing built-in ES6 WeakMaps.
   */
  defProp(Object, 'getOwnPropertyNames', {
    value: function fakeGetOwnPropertyNames(obj) {
      return gopn(obj).filter(isNotHiddenName);
    }
  });

  /**
   * getPropertyNames is not in ES5 but it is proposed for ES6 and
   * does appear in our whitelist, so we need to clean it too.
   */
  if ('getPropertyNames' in Object) {
    var originalGetPropertyNames = Object.getPropertyNames;
    defProp(Object, 'getPropertyNames', {
      value: function fakeGetPropertyNames(obj) {
        return originalGetPropertyNames(obj).filter(isNotHiddenName);
      }
    });
  }

  /**
   * <p>To treat objects as identity-keys with reasonable efficiency
   * on ES5 by itself (i.e., without any object-keyed collections), we
   * need to add a hidden property to such key objects when we
   * can. This raises several issues:
   * <ul>
   * <li>Arranging to add this property to objects before we lose the
   *     chance, and
   * <li>Hiding the existence of this new property from most
   *     JavaScript code.
   * <li>Preventing <i>certification theft</i>, where one object is
   *     created falsely claiming to be the key of an association
   *     actually keyed by another object.
   * <li>Preventing <i>value theft</i>, where untrusted code with
   *     access to a key object but not a weak map nevertheless
   *     obtains access to the value associated with that key in that
   *     weak map.
   * </ul>
   * We do so by
   * <ul>
   * <li>Making the name of the hidden property unguessable, so "[]"
   *     indexing, which we cannot intercept, cannot be used to access
   *     a property without knowing the name.
   * <li>Making the hidden property non-enumerable, so we need not
   *     worry about for-in loops or {@code Object.keys},
   * <li>monkey patching those reflective methods that would
   *     prevent extensions, to add this hidden property first,
   * <li>monkey patching those methods that would reveal this
   *     hidden property.
   * </ul>
   * Unfortunately, because of same-origin iframes, we cannot reliably
   * add this hidden property before an object becomes
   * non-extensible. Instead, if we encounter a non-extensible object
   * without a hidden record that we can detect (whether or not it has
   * a hidden record stored under a name secret to us), then we just
   * use the key object itself to represent its identity in a brute
   * force leaky map stored in the weak map, losing all the advantages
   * of weakness for these.
   */
  function getHiddenRecord(key) {
    if (key !== Object(key)) {
      throw new TypeError('Not an object: ' + key);
    }
    var hiddenRecord = key[HIDDEN_NAME];
    if (hiddenRecord && hiddenRecord.key === key) { return hiddenRecord; }
    if (!isExtensible(key)) {
      // Weak map must brute force, as explained in doc-comment above.
      return void 0;
    }

    // The hiddenRecord and the key point directly at each other, via
    // the "key" and HIDDEN_NAME properties respectively. The key
    // field is for quickly verifying that this hidden record is an
    // own property, not a hidden record from up the prototype chain.
    //
    // NOTE: Because this WeakMap emulation is meant only for systems like
    // SES where Object.prototype is frozen without any numeric
    // properties, it is ok to use an object literal for the hiddenRecord.
    // This has two advantages:
    // * It is much faster in a performance critical place
    // * It avoids relying on Object.create(null), which had been
    //   problematic on Chrome 28.0.1480.0. See
    //   https://code.google.com/p/google-caja/issues/detail?id=1687
    hiddenRecord = { key: key };

    // When using this WeakMap emulation on platforms where
    // Object.prototype might not be frozen and Object.create(null) is
    // reliable, use the following two commented out lines instead.
    // hiddenRecord = Object.create(null);
    // hiddenRecord.key = key;

    // Please contact us if you need this to work on platforms where
    // Object.prototype might not be frozen and
    // Object.create(null) might not be reliable.

    try {
      defProp(key, HIDDEN_NAME, {
        value: hiddenRecord,
        writable: false,
        enumerable: false,
        configurable: false
      });
      return hiddenRecord;
    } catch (error) {
      // Under some circumstances, isExtensible seems to misreport whether
      // the HIDDEN_NAME can be defined.
      // The circumstances have not been isolated, but at least affect
      // Node.js v0.10.26 on TravisCI / Linux, but not the same version of
      // Node.js on OS X.
      return void 0;
    }
  }

  /**
   * Monkey patch operations that would make their argument
   * non-extensible.
   *
   * <p>The monkey patched versions throw a TypeError if their
   * argument is not an object, so it should only be done to functions
   * that should throw a TypeError anyway if their argument is not an
   * object.
   */
  (function(){
    var oldFreeze = Object.freeze;
    defProp(Object, 'freeze', {
      value: function identifyingFreeze(obj) {
        getHiddenRecord(obj);
        return oldFreeze(obj);
      }
    });
    var oldSeal = Object.seal;
    defProp(Object, 'seal', {
      value: function identifyingSeal(obj) {
        getHiddenRecord(obj);
        return oldSeal(obj);
      }
    });
    var oldPreventExtensions = Object.preventExtensions;
    defProp(Object, 'preventExtensions', {
      value: function identifyingPreventExtensions(obj) {
        getHiddenRecord(obj);
        return oldPreventExtensions(obj);
      }
    });
  })();

  function constFunc(func) {
    func.prototype = null;
    return Object.freeze(func);
  }

  var calledAsFunctionWarningDone = false;
  function calledAsFunctionWarning() {
    // Future ES6 WeakMap is currently (2013-09-10) expected to reject WeakMap()
    // but we used to permit it and do it ourselves, so warn only.
    if (!calledAsFunctionWarningDone && typeof console !== 'undefined') {
      calledAsFunctionWarningDone = true;
      console.warn('WeakMap should be invoked as new WeakMap(), not ' +
          'WeakMap(). This will be an error in the future.');
    }
  }

  var nextId = 0;

  var OurWeakMap = function() {
    if (!(this instanceof OurWeakMap)) {  // approximate test for new ...()
      calledAsFunctionWarning();
    }

    // We are currently (12/25/2012) never encountering any prematurely
    // non-extensible keys.
    var keys = []; // brute force for prematurely non-extensible keys.
    var values = []; // brute force for corresponding values.
    var id = nextId++;

    function get___(key, opt_default) {
      var index;
      var hiddenRecord = getHiddenRecord(key);
      if (hiddenRecord) {
        return id in hiddenRecord ? hiddenRecord[id] : opt_default;
      } else {
        index = keys.indexOf(key);
        return index >= 0 ? values[index] : opt_default;
      }
    }

    function has___(key) {
      var hiddenRecord = getHiddenRecord(key);
      if (hiddenRecord) {
        return id in hiddenRecord;
      } else {
        return keys.indexOf(key) >= 0;
      }
    }

    function set___(key, value) {
      var index;
      var hiddenRecord = getHiddenRecord(key);
      if (hiddenRecord) {
        hiddenRecord[id] = value;
      } else {
        index = keys.indexOf(key);
        if (index >= 0) {
          values[index] = value;
        } else {
          // Since some browsers preemptively terminate slow turns but
          // then continue computing with presumably corrupted heap
          // state, we here defensively get keys.length first and then
          // use it to update both the values and keys arrays, keeping
          // them in sync.
          index = keys.length;
          values[index] = value;
          // If we crash here, values will be one longer than keys.
          keys[index] = key;
        }
      }
      return this;
    }

    function delete___(key) {
      var hiddenRecord = getHiddenRecord(key);
      var index, lastIndex;
      if (hiddenRecord) {
        return id in hiddenRecord && delete hiddenRecord[id];
      } else {
        index = keys.indexOf(key);
        if (index < 0) {
          return false;
        }
        // Since some browsers preemptively terminate slow turns but
        // then continue computing with potentially corrupted heap
        // state, we here defensively get keys.length first and then use
        // it to update both the keys and the values array, keeping
        // them in sync. We update the two with an order of assignments,
        // such that any prefix of these assignments will preserve the
        // key/value correspondence, either before or after the delete.
        // Note that this needs to work correctly when index === lastIndex.
        lastIndex = keys.length - 1;
        keys[index] = void 0;
        // If we crash here, there's a void 0 in the keys array, but
        // no operation will cause a "keys.indexOf(void 0)", since
        // getHiddenRecord(void 0) will always throw an error first.
        values[index] = values[lastIndex];
        // If we crash here, values[index] cannot be found here,
        // because keys[index] is void 0.
        keys[index] = keys[lastIndex];
        // If index === lastIndex and we crash here, then keys[index]
        // is still void 0, since the aliasing killed the previous key.
        keys.length = lastIndex;
        // If we crash here, keys will be one shorter than values.
        values.length = lastIndex;
        return true;
      }
    }

    return Object.create(OurWeakMap.prototype, {
      get___:    { value: constFunc(get___) },
      has___:    { value: constFunc(has___) },
      set___:    { value: constFunc(set___) },
      delete___: { value: constFunc(delete___) }
    });
  };

  OurWeakMap.prototype = Object.create(Object.prototype, {
    get: {
      /**
       * Return the value most recently associated with key, or
       * opt_default if none.
       */
      value: function get(key, opt_default) {
        return this.get___(key, opt_default);
      },
      writable: true,
      configurable: true
    },

    has: {
      /**
       * Is there a value associated with key in this WeakMap?
       */
      value: function has(key) {
        return this.has___(key);
      },
      writable: true,
      configurable: true
    },

    set: {
      /**
       * Associate value with key in this WeakMap, overwriting any
       * previous association if present.
       */
      value: function set(key, value) {
        return this.set___(key, value);
      },
      writable: true,
      configurable: true
    },

    'delete': {
      /**
       * Remove any association for key in this WeakMap, returning
       * whether there was one.
       *
       * <p>Note that the boolean return here does not work like the
       * {@code delete} operator. The {@code delete} operator returns
       * whether the deletion succeeds at bringing about a state in
       * which the deleted property is absent. The {@code delete}
       * operator therefore returns true if the property was already
       * absent, whereas this {@code delete} method returns false if
       * the association was already absent.
       */
      value: function remove(key) {
        return this.delete___(key);
      },
      writable: true,
      configurable: true
    }
  });

  if (typeof HostWeakMap === 'function') {
    (function() {
      // If we got here, then the platform has a WeakMap but we are concerned
      // that it may refuse to store some key types. Therefore, make a map
      // implementation which makes use of both as possible.

      // In this mode we are always using double maps, so we are not proxy-safe.
      // This combination does not occur in any known browser, but we had best
      // be safe.
      if (doubleWeakMapCheckSilentFailure && typeof Proxy !== 'undefined') {
        Proxy = undefined;
      }

      function DoubleWeakMap() {
        if (!(this instanceof OurWeakMap)) {  // approximate test for new ...()
          calledAsFunctionWarning();
        }

        // Preferable, truly weak map.
        var hmap = new HostWeakMap();

        // Our hidden-property-based pseudo-weak-map. Lazily initialized in the
        // 'set' implementation; thus we can avoid performing extra lookups if
        // we know all entries actually stored are entered in 'hmap'.
        var omap = undefined;

        // Hidden-property maps are not compatible with proxies because proxies
        // can observe the hidden name and either accidentally expose it or fail
        // to allow the hidden property to be set. Therefore, we do not allow
        // arbitrary WeakMaps to switch to using hidden properties, but only
        // those which need the ability, and unprivileged code is not allowed
        // to set the flag.
        //
        // (Except in doubleWeakMapCheckSilentFailure mode in which case we
        // disable proxies.)
        var enableSwitching = false;

        function dget(key, opt_default) {
          if (omap) {
            return hmap.has(key) ? hmap.get(key)
                : omap.get___(key, opt_default);
          } else {
            return hmap.get(key, opt_default);
          }
        }

        function dhas(key) {
          return hmap.has(key) || (omap ? omap.has___(key) : false);
        }

        var dset;
        if (doubleWeakMapCheckSilentFailure) {
          dset = function(key, value) {
            hmap.set(key, value);
            if (!hmap.has(key)) {
              if (!omap) { omap = new OurWeakMap(); }
              omap.set(key, value);
            }
            return this;
          };
        } else {
          dset = function(key, value) {
            if (enableSwitching) {
              try {
                hmap.set(key, value);
              } catch (e) {
                if (!omap) { omap = new OurWeakMap(); }
                omap.set___(key, value);
              }
            } else {
              hmap.set(key, value);
            }
            return this;
          };
        }

        function ddelete(key) {
          var result = !!hmap['delete'](key);
          if (omap) { return omap.delete___(key) || result; }
          return result;
        }

        return Object.create(OurWeakMap.prototype, {
          get___:    { value: constFunc(dget) },
          has___:    { value: constFunc(dhas) },
          set___:    { value: constFunc(dset) },
          delete___: { value: constFunc(ddelete) },
          permitHostObjects___: { value: constFunc(function(token) {
            if (token === weakMapPermitHostObjects) {
              enableSwitching = true;
            } else {
              throw new Error('bogus call to permitHostObjects___');
            }
          })}
        });
      }
      DoubleWeakMap.prototype = OurWeakMap.prototype;
      module.exports = DoubleWeakMap;

      // define .constructor to hide OurWeakMap ctor
      Object.defineProperty(WeakMap.prototype, 'constructor', {
        value: WeakMap,
        enumerable: false,  // as default .constructor is
        configurable: true,
        writable: true
      });
    })();
  } else {
    // There is no host WeakMap, so we must use the emulation.

    // Emulated WeakMaps are incompatible with native proxies (because proxies
    // can observe the hidden name), so we must disable Proxy usage (in
    // ArrayLike and Domado, currently).
    if (typeof Proxy !== 'undefined') {
      Proxy = undefined;
    }

    module.exports = OurWeakMap;
  }
})();

},{}],"/projects/blackice/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/gl-buffer/node_modules/webglew/webglew.js":[function(require,module,exports){
'use strict'

var weakMap = typeof WeakMap === 'undefined' ? require('weak-map') : WeakMap

var WebGLEWStruct = new weakMap()

function baseName(ext_name) {
  return ext_name.replace(/^[A-Z]+_/, '')
}

function initWebGLEW(gl) {
  var struct = WebGLEWStruct.get(gl)
  if(struct) {
    return struct
  }
  var extensions = {}
  var supported = gl.getSupportedExtensions()
  for(var i=0; i<supported.length; ++i) {
    var extName = supported[i]

    //Skip MOZ_ extensions
    if(extName.indexOf('MOZ_') === 0) {
      continue
    }
    var ext = gl.getExtension(supported[i])
    if(!ext) {
      continue
    }
    while(true) {
      extensions[extName] = ext
      var base = baseName(extName)
      if(base === extName) {
        break
      }
      extName = base
    }
  }
  WebGLEWStruct.set(gl, extensions)
  return extensions
}
module.exports = initWebGLEW
},{"weak-map":"/projects/blackice/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/gl-buffer/node_modules/webglew/node_modules/weak-map/weak-map.js"}],"/projects/blackice/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/mixes/index.js":[function(require,module,exports){
var xtend = require('xtend')

var defaults = {
	enumerable: true,
	configurable: true
}

function mix(obj, entries) {
	for (var k in entries) {
		if (!entries.hasOwnProperty(k))
			continue
		var f = entries[k]
		if (typeof f === 'function') {
			obj[k] = f
		} else if (f && typeof f === 'object') {
			var def = xtend(defaults, f)
			Object.defineProperty(obj, k, def);
		}
	}
}

module.exports = function mixes(ctor, entries) {
	mix(ctor.prototype, entries)
}

module.exports.mix = mix
},{"xtend":"/projects/blackice/node_modules/gl-sprite-text/node_modules/xtend/immutable.js"}],"/projects/blackice/node_modules/gl-sprite-text/node_modules/gl-texture2d/node_modules/ndarray-ops/ndarray-ops.js":[function(require,module,exports){
module.exports=require("/projects/blackice/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/gl-buffer/node_modules/ndarray-ops/ndarray-ops.js")
},{"/projects/blackice/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/gl-buffer/node_modules/ndarray-ops/ndarray-ops.js":"/projects/blackice/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/gl-buffer/node_modules/ndarray-ops/ndarray-ops.js"}],"/projects/blackice/node_modules/gl-sprite-text/node_modules/gl-texture2d/node_modules/typedarray-pool/pool.js":[function(require,module,exports){
module.exports=require("/projects/blackice/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/gl-buffer/node_modules/typedarray-pool/pool.js")
},{"/projects/blackice/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/gl-buffer/node_modules/typedarray-pool/pool.js":"/projects/blackice/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/gl-buffer/node_modules/typedarray-pool/pool.js"}],"/projects/blackice/node_modules/gl-sprite-text/node_modules/gl-texture2d/node_modules/webglew/webglew.js":[function(require,module,exports){
module.exports=require("/projects/blackice/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/gl-buffer/node_modules/webglew/webglew.js")
},{"/projects/blackice/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/gl-buffer/node_modules/webglew/webglew.js":"/projects/blackice/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/gl-buffer/node_modules/webglew/webglew.js"}],"/projects/blackice/node_modules/gl-sprite-text/node_modules/gl-texture2d/texture.js":[function(require,module,exports){
'use strict'

var ndarray = require('ndarray')
var ops     = require('ndarray-ops')
var pool    = require('typedarray-pool')
var webglew = require('webglew')

module.exports = createTexture2D

var linearTypes = null
var filterTypes = null
var wrapTypes   = null

function lazyInitLinearTypes(gl) {
  linearTypes = [
    gl.LINEAR,
    gl.NEAREST_MIPMAP_LINEAR,
    gl.LINEAR_MIPMAP_NEAREST,
    gl.LINEAR_MIPMAP_NEAREST
  ]
  filterTypes = [
    gl.NEAREST,
    gl.LINEAR,
    gl.NEAREST_MIPMAP_NEAREST,
    gl.NEAREST_MIPMAP_LINEAR,
    gl.LINEAR_MIPMAP_NEAREST,
    gl.LINEAR_MIPMAP_LINEAR
  ]
  wrapTypes = [
    gl.REPEAT,
    gl.CLAMP_TO_EDGE,
    gl.MIRRORED_REPEAT
  ]
}

var convertFloatToUint8 = function(out, inp) {
  ops.muls(out, inp, 255.0)
}

function reshapeTexture(tex, w, h) {
  var gl = tex.gl
  var maxSize = gl.getParameter(gl.MAX_TEXTURE_SIZE)
  if(w < 0 || w > maxSize || h < 0 || h > maxSize) {
    throw new Error('gl-texture2d: Invalid texture size')
  }
  tex._shape = [w, h]
  tex.bind()
  gl.texImage2D(gl.TEXTURE_2D, 0, tex.format, w, h, 0, tex.format, tex.type, null)
  tex._mipLevels = [0]
  return tex
}

function Texture2D(gl, handle, width, height, format, type) {
  this.gl = gl
  this.handle = handle
  this.format = format
  this.type = type
  this._shape = [width, height]
  this._mipLevels = [0]
  this._magFilter = gl.NEAREST
  this._minFilter = gl.NEAREST
  this._wrapS = gl.CLAMP_TO_EDGE
  this._wrapT = gl.CLAMP_TO_EDGE
  this._anisoSamples = 1

  var parent = this
  var wrapVector = [this._wrapS, this._wrapT]
  Object.defineProperties(wrapVector, [
    {
      get: function() {
        return parent._wrapS
      },
      set: function(v) {
        return parent.wrapS = v
      }
    },
    {
      get: function() {
        return parent._wrapT
      },
      set: function(v) {
        return parent.wrapT = v
      }
    }
  ])
  this._wrapVector = wrapVector

  var shapeVector = [this._shape[0], this._shape[1]]
  Object.defineProperties(shapeVector, [
    {
      get: function() {
        return parent._shape[0]
      },
      set: function(v) {
        return parent.width = v
      }
    },
    {
      get: function() {
        return parent._shape[1]
      },
      set: function(v) {
        return parent.height = v
      }
    }
  ])
  this._shapeVector = shapeVector
}

var proto = Texture2D.prototype

Object.defineProperties(proto, {
  minFilter: {
    get: function() {
      return this._minFilter
    },
    set: function(v) {
      this.bind()
      var gl = this.gl
      if(this.type === gl.FLOAT && linearTypes.indexOf(v) >= 0) {
        if(!webglew(gl).texture_float_linear) {
          v = gl.NEAREST
        }
      }
      if(filterTypes.indexOf(v) < 0) {
        throw new Error('gl-texture2d: Unknown filter mode ' + v)
      }
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, v)
      return this._minFilter = v
    }
  },
  magFilter: {
    get: function() {
      return this._magFilter
    },
    set: function(v) {
      this.bind()
      var gl = this.gl
      if(this.type === gl.FLOAT && linearTypes.indexOf(v) >= 0) {
        if(!webglew(gl).texture_float_linear) {
          v = gl.NEAREST
        }
      }
      if(filterTypes.indexOf(v) < 0) {
        throw new Error('gl-texture2d: Unknown filter mode ' + v)
      }
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, v)
      return this._magFilter = v
    }
  },
  mipSamples: {
    get: function() {
      return this._anisoSamples
    },
    set: function(i) {
      var psamples = this._anisoSamples
      this._anisoSamples = Math.max(i, 1)|0
      if(psamples !== this._anisoSamples) {
        var ext = webglew(this.gl).EXT_texture_filter_anisotropic
        if(ext) {
          this.gl.texParameterf(this.gl.TEXTURE_2D, ext.TEXTURE_MAX_ANISOTROPY_EXT, this._anisoSamples)
        }
      }
      return this._anisoSamples
    }
  },
  wrapS: {
    get: function() {
      return this._wrapS
    },
    set: function(v) {
      this.bind()
      if(wrapTypes.indexOf(v) < 0) {
        throw new Error('gl-texture2d: Unknown wrap mode ' + v)
      }
      this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, v)
      return this._wrapS = v
    }
  },
  wrapT: {
    get: function() {
      return this._wrapT
    },
    set: function(v) {
      this.bind()
      if(wrapTypes.indexOf(v) < 0) {
        throw new Error('gl-texture2d: Unknown wrap mode ' + v)
      }
      this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, v)
      return this._wrapT = v
    }
  },
  wrap: {
    get: function() {
      return this._wrapVector
    },
    set: function(v) {
      if(!Array.isArray(v)) {
        v = [v,v]
      }
      if(v.length !== 2) {
        throw new Error('gl-texture2d: Must specify wrap mode for rows and columns')
      }
      for(var i=0; i<2; ++i) {
        if(wrapTypes.indexOf(v[i]) < 0) {
          throw new Error('gl-texture2d: Unknown wrap mode ' + v)
        }
      }
      this._wrapS = v[0]
      this._wrapT = v[1]

      var gl = this.gl
      this.bind()
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, this._wrapS)
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, this._wrapT)

      return v
    }
  },
  shape: {
    get: function() {
      return this._shapeVector
    }, 
    set: function(x) {
      if(!Array.isArray(x)) {
        x = [x|0,x|0]
      } else {
        if(x.length !== 2) {
          throw new Error('gl-texture2d: Invalid texture shape')
        }
      }
      reshapeTexture(this, x[0]|0, x[1]|0)
      return [x[0]|0, x[1]|0]
    }
  },
  width: {
    get: function() {
      return this._shape[0]
    },
    set: function(w) {
      w = w|0
      reshapeTexture(this, w, this._shape[1])
      return w
    }
  },
  height: {
    get: function() {
      return this._shape[1]
    },
    set: function(h) {
      h = h|0
      reshapeTexture(this, this._shape[0], h)
      return h
    }
  }
})

proto.bind = function(unit) {
  var gl = this.gl
  if(unit !== undefined) {
    gl.activeTexture(gl.TEXTURE0 + (unit|0))
  }
  gl.bindTexture(gl.TEXTURE_2D, this.handle)
  if(unit !== undefined) {
    return (unit|0)
  }
  return gl.getParameter(gl.ACTIVE_TEXTURE) - gl.TEXTURE0
}

proto.dispose = function() {
  this.gl.deleteTexture(this.handle)
}

proto.generateMipmap = function() {
  this.bind()
  this.gl.generateMipmap(this.gl.TEXTURE_2D)
  
  //Update mip levels
  var l = Math.min(this._shape[0], this._shape[1])
  for(var i=0; l>0; ++i, l>>>=1) {
    if(this._mipLevels.indexOf(i) < 0) {
      this._mipLevels.push(i)
    }
  }
}

proto.setPixels = function(data, x_off, y_off, mip_level) {
  var gl = this.gl
  this.bind()
  if(Array.isArray(x_off)) {
    mip_level = y_off
    y_off = x_off[1]|0
    x_off = x_off[0]|0
  } else {
    x_off = x_off || 0
    y_off = y_off || 0
  }
  mip_level = mip_level || 0
  if(data instanceof HTMLCanvasElement ||
     data instanceof ImageData ||
     data instanceof HTMLImageElement ||
     data instanceof HTMLVideoElement) {
    var needsMip = this._mipLevels.indexOf(mip_level) < 0
    if(needsMip) {
      gl.texImage2D(gl.TEXTURE_2D, 0, this.format, this.format, this.type, data)
      this._mipLevels.push(mip_level)
    } else {
      gl.texSubImage2D(gl.TEXTURE_2D, mip_level, x_off, y_off, this.format, this.type, data)
    }
  } else if(data.shape && data.stride && data.data) {
    if(data.shape.length < 2 ||
       x_off + data.shape[1] > this._shape[1]>>>mip_level ||
       y_off + data.shape[0] > this._shape[0]>>>mip_level ||
       x_off < 0 ||
       y_off < 0) {
      throw new Error('gl-texture2d: Texture dimensions are out of bounds')
    }
    texSubImageArray(gl, x_off, y_off, mip_level, this.format, this.type, this._mipLevels, data)
  } else {
    throw new Error('gl-texture2d: Unsupported data type')
  }
}


function isPacked(shape, stride) {
  if(shape.length === 3) {
    return  (stride[2] === 1) && 
            (stride[1] === shape[0]*shape[2]) &&
            (stride[0] === shape[2])
  }
  return  (stride[0] === 1) && 
          (stride[1] === shape[0])
}

function texSubImageArray(gl, x_off, y_off, mip_level, cformat, ctype, mipLevels, array) {
  var dtype = array.dtype
  var shape = array.shape.slice()
  if(shape.length < 2 || shape.length > 3) {
    throw new Error('gl-texture2d: Invalid ndarray, must be 2d or 3d')
  }
  var type = 0, format = 0
  var packed = isPacked(shape, array.stride.slice())
  if(dtype === 'float32') {
    type = gl.FLOAT
  } else if(dtype === 'float64') {
    type = gl.FLOAT
    packed = false
    dtype = 'float32'
  } else if(dtype === 'uint8') {
    type = gl.UNSIGNED_BYTE
  } else {
    type = gl.UNSIGNED_BYTE
    packed = false
    dtype = 'uint8'
  }
  var channels = 1
  if(shape.length === 2) {
    format = gl.LUMINANCE
    shape = [shape[0], shape[1], 1]
    array = ndarray(array.data, shape, [array.stride[0], array.stride[1], 1], array.offset)
  } else if(shape.length === 3) {
    if(shape[2] === 1) {
      format = gl.ALPHA
    } else if(shape[2] === 2) {
      format = gl.LUMINANCE_ALPHA
    } else if(shape[2] === 3) {
      format = gl.RGB
    } else if(shape[2] === 4) {
      format = gl.RGBA
    } else {
      throw new Error('gl-texture2d: Invalid shape for pixel coords')
    }
    channels = shape[2]
  } else {
    throw new Error('gl-texture2d: Invalid shape for texture')
  }
  //For 1-channel textures allow conversion between formats
  if((format  === gl.LUMINANCE || format  === gl.ALPHA) &&
     (cformat === gl.LUMINANCE || cformat === gl.ALPHA)) {
    format = cformat
  }
  if(format !== cformat) {
    throw new Error('gl-texture2d: Incompatible texture format for setPixels')
  }
  var size = array.size
  var needsMip = mipLevels.indexOf(mip_level) < 0
  if(needsMip) {
    mipLevels.push(mip_level)
  }
  if(type === ctype && packed) {
    //Array data types are compatible, can directly copy into texture
    if(array.offset === 0 && array.data.length === size) {
      if(needsMip) {
        gl.texImage2D(gl.TEXTURE_2D, mip_level, cformat, shape[0], shape[1], 0, cformat, ctype, array.data)
      } else {
        gl.texSubImage2D(gl.TEXTURE_2D, mip_level, x_off, y_off, shape[0], shape[1], cformat, ctype, array.data)
      }
    } else {
      if(needsMip) {
        gl.texImage2D(gl.TEXTURE_2D, mip_level, cformat, shape[0], shape[1], 0, cformat, ctype, array.data.subarray(array.offset, array.offset+size))
      } else {
        gl.texSubImage2D(gl.TEXTURE_2D, mip_level, x_off, y_off, shape[0], shape[1], cformat, ctype, array.data.subarray(array.offset, array.offset+size))
      }
    }
  } else {
    //Need to do type conversion to pack data into buffer
    var pack_buffer
    if(ctype === gl.FLOAT) {
      pack_buffer = pool.mallocFloat32(size)
    } else {
      pack_buffer = pool.mallocUint8(size)
    }
    var pack_view = ndarray(pack_buffer, shape, [shape[2], shape[2]*shape[0], 1])
    if(type === gl.FLOAT && ctype === gl.UNSIGNED_BYTE) {
      convertFloatToUint8(pack_view, array)
    } else {
      ops.assign(pack_view, array)
    }
    if(needsMip) {
      gl.texImage2D(gl.TEXTURE_2D, mip_level, cformat, shape[0], shape[1], 0, cformat, ctype, pack_buffer.subarray(0, size))
    } else {
      gl.texSubImage2D(gl.TEXTURE_2D, mip_level, x_off, y_off, shape[0], shape[1], cformat, ctype, pack_buffer.subarray(0, size))
    }
    if(ctype === gl.FLOAT) {
      pool.freeFloat32(pack_buffer)
    } else {
      pool.freeUint8(pack_buffer)
    }
  }
}

function initTexture(gl) {
  var tex = gl.createTexture()
  gl.bindTexture(gl.TEXTURE_2D, tex)
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST)
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST)
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE)
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE)
  return tex
}

function createTextureShape(gl, width, height, format, type) {
  var maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE)
  if(width < 0 || width > maxTextureSize || height < 0 || height  > maxTextureSize) {
    throw new Error('gl-texture2d: Invalid texture shape')
  }
  if(type === gl.FLOAT && !webglew(gl).texture_float) {
    throw new Error('gl-texture2d: Floating point textures not supported on this platform')
  }
  var tex = initTexture(gl)
  gl.texImage2D(gl.TEXTURE_2D, 0, format, width, height, 0, format, type, null)
  return new Texture2D(gl, tex, width, height, format, type)
}

function createTextureDOM(gl, element, format, type) {
  var tex = initTexture(gl)
  gl.texImage2D(gl.TEXTURE_2D, 0, format, format, type, element)
  return new Texture2D(gl, tex, element.width|0, element.height|0, format, type)
}

//Creates a texture from an ndarray
function createTextureArray(gl, array) {
  var dtype = array.dtype
  var shape = array.shape.slice()
  var maxSize = gl.getParameter(gl.MAX_TEXTURE_SIZE)
  if(shape[0] < 0 || shape[0] > maxSize || shape[1] < 0 || shape[1] > maxSize) {
    throw new Error('gl-texture2d: Invalid texture size')
  }
  var packed = isPacked(shape, array.stride.slice())
  var type = 0
  if(dtype === 'float32') {
    type = gl.FLOAT
  } else if(dtype === 'float64') {
    type = gl.FLOAT
    packed = false
    dtype = 'float32'
  } else if(dtype === 'uint8') {
    type = gl.UNSIGNED_BYTE
  } else {
    type = gl.UNSIGNED_BYTE
    packed = false
    dtype = 'uint8'
  }
  var format = 0
  if(shape.length === 2) {
    format = gl.LUMINANCE
    shape = [shape[0], shape[1], 1]
    array = ndarray(array.data, shape, [array.stride[0], array.stride[1], 1], array.offset)
  } else if(shape.length === 3) {
    if(shape[2] === 1) {
      format = gl.ALPHA
    } else if(shape[2] === 2) {
      format = gl.LUMINANCE_ALPHA
    } else if(shape[2] === 3) {
      format = gl.RGB
    } else if(shape[2] === 4) {
      format = gl.RGBA
    } else {
      throw new Error('gl-texture2d: Invalid shape for pixel coords')
    }
  } else {
    throw new Error('gl-texture2d: Invalid shape for texture')
  }
  if(type === gl.FLOAT && !webglew(gl).texture_float) {
    type = gl.UNSIGNED_BYTE
    packed = false
  }
  var buffer, buf_store
  var size = array.size
  if(!packed) {
    var stride = [shape[2], shape[2]*shape[0], 1]
    buf_store = pool.malloc(size, dtype)
    var buf_array = ndarray(buf_store, shape, stride, 0)
    if((dtype === 'float32' || dtype === 'float64') && type === gl.UNSIGNED_BYTE) {
      convertFloatToUint8(buf_array, array)
    } else {
      ops.assign(buf_array, array)
    }
    buffer = buf_store.subarray(0, size)
  } else if (array.offset === 0 && array.data.length === size) {
    buffer = array.data
  } else {
    buffer = array.data.subarray(array.offset, array.offset + size)
  }
  var tex = initTexture(gl)
  gl.texImage2D(gl.TEXTURE_2D, 0, format, shape[0], shape[1], 0, format, type, buffer)
  if(!packed) {
    pool.free(buf_store)
  }
  return new Texture2D(gl, tex, shape[0], shape[1], format, type)
}

function createTexture2D(gl) {
  if(arguments.length <= 1) {
    throw new Error('gl-texture2d: Missing arguments for texture2d constructor')
  }
  if(!linearTypes) {
    lazyInitLinearTypes(gl)
  }
  if(typeof arguments[1] === 'number') {
    return createTextureShape(gl, arguments[1], arguments[2], arguments[3]||gl.RGBA, arguments[4]||gl.UNSIGNED_BYTE)
  }
  if(Array.isArray(arguments[1])) {
    return createTextureShape(gl, arguments[1][0]|0, arguments[1][1]|0, arguments[2]||gl.RGBA, arguments[3]||gl.UNSIGNED_BYTE)
  }
  if(typeof arguments[1] === 'object') {
    var obj = arguments[1]
    if(obj instanceof HTMLCanvasElement ||
       obj instanceof HTMLImageElement ||
       obj instanceof HTMLVideoElement ||
       obj instanceof ImageData) {
      return createTextureDOM(gl, obj, arguments[2]||gl.RGBA, arguments[3]||gl.UNSIGNED_BYTE)
    } else if(obj.shape && obj.data && obj.stride) {
      return createTextureArray(gl, obj)
    }
  }
  throw new Error('gl-texture2d: Invalid arguments for texture2d constructor')
}

},{"ndarray":"/projects/blackice/node_modules/gl-sprite-text/node_modules/ndarray/ndarray.js","ndarray-ops":"/projects/blackice/node_modules/gl-sprite-text/node_modules/gl-texture2d/node_modules/ndarray-ops/ndarray-ops.js","typedarray-pool":"/projects/blackice/node_modules/gl-sprite-text/node_modules/gl-texture2d/node_modules/typedarray-pool/pool.js","webglew":"/projects/blackice/node_modules/gl-sprite-text/node_modules/gl-texture2d/node_modules/webglew/webglew.js"}],"/projects/blackice/node_modules/gl-sprite-text/node_modules/gl-white-texture/node_modules/ndarray/ndarray.js":[function(require,module,exports){
(function (Buffer){
var iota = require("iota-array")

var arrayMethods = [
  "concat",
  "join",
  "slice",
  "toString",
  "indexOf",
  "lastIndexOf",
  "forEach",
  "every",
  "some",
  "filter",
  "map",
  "reduce",
  "reduceRight"
]

var hasTypedArrays  = ((typeof Float64Array) !== "undefined")
var hasBuffer       = ((typeof Buffer) !== "undefined")

function compare1st(a, b) {
  return a[0] - b[0]
}

function order() {
  var stride = this.stride
  var terms = new Array(stride.length)
  var i
  for(i=0; i<terms.length; ++i) {
    terms[i] = [Math.abs(stride[i]), i]
  }
  terms.sort(compare1st)
  var result = new Array(terms.length)
  for(i=0; i<result.length; ++i) {
    result[i] = terms[i][1]
  }
  return result
}

function compileConstructor(dtype, dimension) {
  var className = ["View", dimension, "d", dtype].join("")
  if(dimension < 0) {
    className = "View_Nil" + dtype
  }
  var useGetters = (dtype === "generic")
  
  if(dimension === -1) {
    //Special case for trivial arrays
    var code = 
      "function "+className+"(a){this.data=a;};\
var proto="+className+".prototype;\
proto.dtype='"+dtype+"';\
proto.index=function(){return -1};\
proto.size=0;\
proto.dimension=-1;\
proto.shape=proto.stride=proto.order=[];\
proto.lo=proto.hi=proto.transpose=proto.step=\
function(){return new "+className+"(this.data);};\
proto.get=proto.set=function(){};\
proto.pick=function(){return null};\
return function construct_"+className+"(a){return new "+className+"(a);}"
    var procedure = new Function(code)
    return procedure()
  } else if(dimension === 0) {
    //Special case for 0d arrays
    var code =
      "function "+className+"(a,d) {\
this.data = a;\
this.offset = d\
};\
var proto="+className+".prototype;\
proto.dtype='"+dtype+"';\
proto.index=function(){return this.offset};\
proto.dimension=0;\
proto.size=1;\
proto.shape=\
proto.stride=\
proto.order=[];\
proto.lo=\
proto.hi=\
proto.transpose=\
proto.step=function "+className+"_copy() {\
return new "+className+"(this.data,this.offset)\
};\
proto.pick=function "+className+"_pick(){\
return TrivialArray(this.data);\
};\
proto.valueOf=proto.get=function "+className+"_get(){\
return "+(useGetters ? "this.data.get(this.offset)" : "this.data[this.offset]")+
"};\
proto.set=function "+className+"_set(v){\
return "+(useGetters ? "this.data.set(this.offset,v)" : "this.data[this.offset]=v")+"\
};\
return function construct_"+className+"(a,b,c,d){return new "+className+"(a,d)}"
    var procedure = new Function("TrivialArray", code)
    return procedure(CACHED_CONSTRUCTORS[dtype][0])
  }

  var code = ["'use strict'"]
    
  //Create constructor for view
  var indices = iota(dimension)
  var args = indices.map(function(i) { return "i"+i })
  var index_str = "this.offset+" + indices.map(function(i) {
        return "this._stride" + i + "*i" + i
      }).join("+")
  code.push("function "+className+"(a,"+
    indices.map(function(i) {
      return "b"+i
    }).join(",") + "," +
    indices.map(function(i) {
      return "c"+i
    }).join(",") + ",d){this.data=a")
  for(var i=0; i<dimension; ++i) {
    code.push("this._shape"+i+"=b"+i+"|0")
  }
  for(var i=0; i<dimension; ++i) {
    code.push("this._stride"+i+"=c"+i+"|0")
  }
  code.push("this.offset=d|0}",
    "var proto="+className+".prototype",
    "proto.dtype='"+dtype+"'",
    "proto.dimension="+dimension)
  
  //view.stride and view.shape
  var strideClassName = "VStride" + dimension + "d" + dtype
  var shapeClassName = "VShape" + dimension + "d" + dtype
  var props = {"stride":strideClassName, "shape":shapeClassName}
  for(var prop in props) {
    var arrayName = props[prop]
    code.push(
      "function " + arrayName + "(v) {this._v=v} var aproto=" + arrayName + ".prototype",
      "aproto.length="+dimension)
    
    var array_elements = []
    for(var i=0; i<dimension; ++i) {
      array_elements.push(["this._v._", prop, i].join(""))
    }
    code.push(
      "aproto.toJSON=function " + arrayName + "_toJSON(){return [" + array_elements.join(",") + "]}",
      "aproto.valueOf=aproto.toString=function " + arrayName + "_toString(){return [" + array_elements.join(",") + "].join()}")
    
    for(var i=0; i<dimension; ++i) {
      code.push("Object.defineProperty(aproto,"+i+",{get:function(){return this._v._"+prop+i+"},set:function(v){return this._v._"+prop+i+"=v|0},enumerable:true})")
    }
    for(var i=0; i<arrayMethods.length; ++i) {
      if(arrayMethods[i] in Array.prototype) {
        code.push("aproto."+arrayMethods[i]+"=Array.prototype."+arrayMethods[i])
      }
    }
    code.push(["Object.defineProperty(proto,'",prop,"',{get:function ", arrayName, "_get(){return new ", arrayName, "(this)},set: function ", arrayName, "_set(v){"].join(""))
    for(var i=0; i<dimension; ++i) {
      code.push("this._"+prop+i+"=v["+i+"]|0")
    }
    code.push("return v}})")
  }
  
  //view.size:
  code.push("Object.defineProperty(proto,'size',{get:function "+className+"_size(){\
return "+indices.map(function(i) { return "this._shape"+i }).join("*"),
"}})")

  //view.order:
  if(dimension === 1) {
    code.push("proto.order=[0]")
  } else {
    code.push("Object.defineProperty(proto,'order',{get:")
    if(dimension < 4) {
      code.push("function "+className+"_order(){")
      if(dimension === 2) {
        code.push("return (Math.abs(this._stride0)>Math.abs(this._stride1))?[1,0]:[0,1]}})")
      } else if(dimension === 3) {
        code.push(
"var s0=Math.abs(this._stride0),s1=Math.abs(this._stride1),s2=Math.abs(this._stride2);\
if(s0>s1){\
if(s1>s2){\
return [2,1,0];\
}else if(s0>s2){\
return [1,2,0];\
}else{\
return [1,0,2];\
}\
}else if(s0>s2){\
return [2,0,1];\
}else if(s2>s1){\
return [0,1,2];\
}else{\
return [0,2,1];\
}}})")
      }
    } else {
      code.push("ORDER})")
    }
  }
  
  //view.set(i0, ..., v):
  code.push(
"proto.set=function "+className+"_set("+args.join(",")+",v){")
  if(useGetters) {
    code.push("return this.data.set("+index_str+",v)}")
  } else {
    code.push("return this.data["+index_str+"]=v}")
  }
  
  //view.get(i0, ...):
  code.push("proto.get=function "+className+"_get("+args.join(",")+"){")
  if(useGetters) {
    code.push("return this.data.get("+index_str+")}")
  } else {
    code.push("return this.data["+index_str+"]}")
  }
  
  //view.index:
  code.push(
    "proto.index=function "+className+"_index(", args.join(), "){return "+index_str+"}")

  //view.hi():
  code.push("proto.hi=function "+className+"_hi("+args.join(",")+"){return new "+className+"(this.data,"+
    indices.map(function(i) {
      return ["(typeof i",i,"!=='number'||i",i,"<0)?this._shape", i, ":i", i,"|0"].join("")
    }).join(",")+","+
    indices.map(function(i) {
      return "this._stride"+i
    }).join(",")+",this.offset)}")
  
  //view.lo():
  var a_vars = indices.map(function(i) { return "a"+i+"=this._shape"+i })
  var c_vars = indices.map(function(i) { return "c"+i+"=this._stride"+i })
  code.push("proto.lo=function "+className+"_lo("+args.join(",")+"){var b=this.offset,d=0,"+a_vars.join(",")+","+c_vars.join(","))
  for(var i=0; i<dimension; ++i) {
    code.push(
"if(typeof i"+i+"==='number'&&i"+i+">=0){\
d=i"+i+"|0;\
b+=c"+i+"*d;\
a"+i+"-=d}")
  }
  code.push("return new "+className+"(this.data,"+
    indices.map(function(i) {
      return "a"+i
    }).join(",")+","+
    indices.map(function(i) {
      return "c"+i
    }).join(",")+",b)}")
  
  //view.step():
  code.push("proto.step=function "+className+"_step("+args.join(",")+"){var "+
    indices.map(function(i) {
      return "a"+i+"=this._shape"+i
    }).join(",")+","+
    indices.map(function(i) {
      return "b"+i+"=this._stride"+i
    }).join(",")+",c=this.offset,d=0,ceil=Math.ceil")
  for(var i=0; i<dimension; ++i) {
    code.push(
"if(typeof i"+i+"==='number'){\
d=i"+i+"|0;\
if(d<0){\
c+=b"+i+"*(a"+i+"-1);\
a"+i+"=ceil(-a"+i+"/d)\
}else{\
a"+i+"=ceil(a"+i+"/d)\
}\
b"+i+"*=d\
}")
  }
  code.push("return new "+className+"(this.data,"+
    indices.map(function(i) {
      return "a" + i
    }).join(",")+","+
    indices.map(function(i) {
      return "b" + i
    }).join(",")+",c)}")
  
  //view.transpose():
  var tShape = new Array(dimension)
  var tStride = new Array(dimension)
  for(var i=0; i<dimension; ++i) {
    tShape[i] = "a[i"+i+"]"
    tStride[i] = "b[i"+i+"]"
  }
  code.push("proto.transpose=function "+className+"_transpose("+args+"){"+
    args.map(function(n,idx) { return n + "=(" + n + "===undefined?" + idx + ":" + n + "|0)"}).join(";"),
    "var a=this.shape,b=this.stride;return new "+className+"(this.data,"+tShape.join(",")+","+tStride.join(",")+",this.offset)}")
  
  //view.pick():
  code.push("proto.pick=function "+className+"_pick("+args+"){var a=[],b=[],c=this.offset")
  for(var i=0; i<dimension; ++i) {
    code.push("if(typeof i"+i+"==='number'&&i"+i+">=0){c=(c+this._stride"+i+"*i"+i+")|0}else{a.push(this._shape"+i+");b.push(this._stride"+i+")}")
  }
  code.push("var ctor=CTOR_LIST[a.length+1];return ctor(this.data,a,b,c)}")
    
  //Add return statement
  code.push("return function construct_"+className+"(data,shape,stride,offset){return new "+className+"(data,"+
    indices.map(function(i) {
      return "shape["+i+"]"
    }).join(",")+","+
    indices.map(function(i) {
      return "stride["+i+"]"
    }).join(",")+",offset)}")

  //Compile procedure
  var procedure = new Function("CTOR_LIST", "ORDER", code.join("\n"))
  return procedure(CACHED_CONSTRUCTORS[dtype], order)
}

function arrayDType(data) {
  if(hasBuffer) {
    if(Buffer.isBuffer(data)) {
      return "buffer"
    }
  }
  if(hasTypedArrays) {
    switch(Object.prototype.toString.call(data)) {
      case "[object Float64Array]":
        return "float64"
      case "[object Float32Array]":
        return "float32"
      case "[object Int8Array]":
        return "int8"
      case "[object Int16Array]":
        return "int16"
      case "[object Int32Array]":
        return "int32"
      case "[object Uint8Array]":
        return "uint8"
      case "[object Uint16Array]":
        return "uint16"
      case "[object Uint32Array]":
        return "uint32"
      case "[object Uint8ClampedArray]":
        return "uint8_clamped"
    }
  }
  if(Array.isArray(data)) {
    return "array"
  }
  return "generic"
}

var CACHED_CONSTRUCTORS = {
  "float32":[],
  "float64":[],
  "int8":[],
  "int16":[],
  "int32":[],
  "uint8":[],
  "uint16":[],
  "uint32":[],
  "array":[],
  "uint8_clamped":[],
  "buffer":[],
  "generic":[]
}

;(function() {
  for(var id in CACHED_CONSTRUCTORS) {
    CACHED_CONSTRUCTORS[id].push(compileConstructor(id, -1))
  }
});

function wrappedNDArrayCtor(data, shape, stride, offset) {
  if(data === undefined) {
    var ctor = CACHED_CONSTRUCTORS.array[0]
    return ctor([])
  } else if(typeof data === "number") {
    data = [data]
  }
  if(shape === undefined) {
    shape = [ data.length ]
  }
  var d = shape.length
  if(stride === undefined) {
    stride = new Array(d)
    for(var i=d-1, sz=1; i>=0; --i) {
      stride[i] = sz
      sz *= shape[i]
    }
  }
  if(offset === undefined) {
    offset = 0
    for(var i=0; i<d; ++i) {
      if(stride[i] < 0) {
        offset -= (shape[i]-1)*stride[i]
      }
    }
  }
  var dtype = arrayDType(data)
  var ctor_list = CACHED_CONSTRUCTORS[dtype]
  while(ctor_list.length <= d+1) {
    ctor_list.push(compileConstructor(dtype, ctor_list.length-1))
  }
  var ctor = ctor_list[d+1]
  return ctor(data, shape, stride, offset)
}

module.exports = wrappedNDArrayCtor
}).call(this,require("buffer").Buffer)
},{"buffer":"/projects/blackice/node_modules/browserify/node_modules/buffer/index.js","iota-array":"/projects/blackice/node_modules/gl-sprite-text/node_modules/gl-white-texture/node_modules/ndarray/node_modules/iota-array/iota.js"}],"/projects/blackice/node_modules/gl-sprite-text/node_modules/gl-white-texture/node_modules/ndarray/node_modules/iota-array/iota.js":[function(require,module,exports){
"use strict"

function iota(n) {
  var result = new Array(n)
  for(var i=0; i<n; ++i) {
    result[i] = i
  }
  return result
}

module.exports = iota
},{}],"/projects/blackice/node_modules/gl-sprite-text/node_modules/inherits/inherits_browser.js":[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],"/projects/blackice/node_modules/gl-sprite-text/node_modules/ndarray/ndarray.js":[function(require,module,exports){
module.exports=require("/projects/blackice/node_modules/gl-sprite-text/node_modules/gl-white-texture/node_modules/ndarray/ndarray.js")
},{"/projects/blackice/node_modules/gl-sprite-text/node_modules/gl-white-texture/node_modules/ndarray/ndarray.js":"/projects/blackice/node_modules/gl-sprite-text/node_modules/gl-white-texture/node_modules/ndarray/ndarray.js"}],"/projects/blackice/node_modules/gl-sprite-text/node_modules/xtend/immutable.js":[function(require,module,exports){
module.exports = extend

function extend() {
    var target = {}

    for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i]

        for (var key in source) {
            if (source.hasOwnProperty(key)) {
                target[key] = source[key]
            }
        }
    }

    return target
}

},{}],"/projects/blackice/node_modules/gl-texture2d/texture.js":[function(require,module,exports){
module.exports=require("/projects/blackice/node_modules/gl-sprite-text/node_modules/gl-texture2d/texture.js")
},{"/projects/blackice/node_modules/gl-sprite-text/node_modules/gl-texture2d/texture.js":"/projects/blackice/node_modules/gl-sprite-text/node_modules/gl-texture2d/texture.js"}],"/projects/blackice/node_modules/gl-vec3/set.js":[function(require,module,exports){
module.exports = set;

/**
 * Set the components of a vec3 to the given values
 *
 * @param {vec3} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} out
 */
function set(out, x, y, z) {
    out[0] = x
    out[1] = y
    out[2] = z
    return out
}
},{}],"/projects/blackice/node_modules/glslify/adapter.js":[function(require,module,exports){
module.exports = programify

var shader = require('gl-shader-core')

function programify(vertex, fragment, uniforms, attributes) {
  return function(gl) {
    return shader(gl, vertex, fragment, uniforms, attributes)
  }
}

},{"gl-shader-core":"/projects/blackice/node_modules/glslify/node_modules/gl-shader-core/shader-core.js"}],"/projects/blackice/node_modules/glslify/browser.js":[function(require,module,exports){
module.exports = noop

function noop() {
  throw new Error(
      'You should bundle your code ' +
      'using `glslify` as a transform.'
  )
}

},{}],"/projects/blackice/node_modules/glslify/node_modules/gl-shader-core/lib/create-attributes.js":[function(require,module,exports){
'use strict'

module.exports = createAttributeWrapper

//Shader attribute class
function ShaderAttribute(gl, program, location, dimension, name, constFunc, relink) {
  this._gl = gl
  this._program = program
  this._location = location
  this._dimension = dimension
  this._name = name
  this._constFunc = constFunc
  this._relink = relink
}

var proto = ShaderAttribute.prototype

proto.pointer = function setAttribPointer(type, normalized, stride, offset) {
  var gl = this._gl
  gl.vertexAttribPointer(this._location, this._dimension, type||gl.FLOAT, !!normalized, stride||0, offset||0)
  this._gl.enableVertexAttribArray(this._location)
}

Object.defineProperty(proto, 'location', {
  get: function() {
    return this._location
  }
  , set: function(v) {
    if(v !== this._location) {
      this._location = v
      this._gl.bindAttribLocation(this._program, v, this._name)
      this._gl.linkProgram(this._program)
      this._relink()
    }
  }
})


//Adds a vector attribute to obj
function addVectorAttribute(gl, program, location, dimension, obj, name, doLink) {
  var constFuncArgs = [ 'gl', 'v' ]
  var varNames = []
  for(var i=0; i<dimension; ++i) {
    constFuncArgs.push('x'+i)
    varNames.push('x'+i)
  }
  constFuncArgs.push([
    'if(x0.length===void 0){return gl.vertexAttrib', dimension, 'f(v,', varNames.join(), ')}else{return gl.vertexAttrib', dimension, 'fv(v,x0)}'
  ].join(''))
  var constFunc = Function.apply(undefined, constFuncArgs)
  var attr = new ShaderAttribute(gl, program, location, dimension, name, constFunc, doLink)
  Object.defineProperty(obj, name, {
    set: function(x) {
      gl.disableVertexAttribArray(attr._location)
      constFunc(gl, attr._location, x)
      return x
    }
    , get: function() {
      return attr
    }
    , enumerable: true
  })
}

//Create shims for attributes
function createAttributeWrapper(gl, program, attributes, doLink) {
  var obj = {}
  for(var i=0, n=attributes.length; i<n; ++i) {
    var a = attributes[i]
    var name = a.name
    var type = a.type
    var location = gl.getAttribLocation(program, name)
    
    switch(type) {
      case 'bool':
      case 'int':
      case 'float':
        addVectorAttribute(gl, program, location, 1, obj, name, doLink)
      break
      
      default:
        if(type.indexOf('vec') >= 0) {
          var d = type.charCodeAt(type.length-1) - 48
          if(d < 2 || d > 4) {
            throw new Error('gl-shader: Invalid data type for attribute ' + name + ': ' + type)
          }
          addVectorAttribute(gl, program, location, d, obj, name, doLink)
        } else {
          throw new Error('gl-shader: Unknown data type for attribute ' + name + ': ' + type)
        }
      break
    }
  }
  return obj
}
},{}],"/projects/blackice/node_modules/glslify/node_modules/gl-shader-core/lib/create-uniforms.js":[function(require,module,exports){
'use strict'

var dup = require('dup')
var coallesceUniforms = require('./reflect')

module.exports = createUniformWrapper

//Binds a function and returns a value
function identity(x) {
  var c = new Function('y', 'return function(){return y}')
  return c(x)
}

//Create shims for uniforms
function createUniformWrapper(gl, program, uniforms, locations) {

  function makeGetter(index) {
    var proc = new Function('gl', 'prog', 'locations', 
      'return function(){return gl.getUniform(prog,locations[' + index + '])}') 
    return proc(gl, program, locations)
  }

  function makePropSetter(path, index, type) {
    switch(type) {
      case 'bool':
      case 'int':
      case 'sampler2D':
      case 'samplerCube':
        return 'gl.uniform1i(locations[' + index + '],obj' + path + ')'
      case 'float':
        return 'gl.uniform1f(locations[' + index + '],obj' + path + ')'
      default:
        var vidx = type.indexOf('vec')
        if(0 <= vidx && vidx <= 1 && type.length === 4 + vidx) {
          var d = type.charCodeAt(type.length-1) - 48
          if(d < 2 || d > 4) {
            throw new Error('gl-shader: Invalid data type')
          }
          switch(type.charAt(0)) {
            case 'b':
            case 'i':
              return 'gl.uniform' + d + 'iv(locations[' + index + '],obj' + path + ')'
            case 'v':
              return 'gl.uniform' + d + 'fv(locations[' + index + '],obj' + path + ')'
            default:
              throw new Error('gl-shader: Unrecognized data type for vector ' + name + ': ' + type)
          }
        } else if(type.indexOf('mat') === 0 && type.length === 4) {
          var d = type.charCodeAt(type.length-1) - 48
          if(d < 2 || d > 4) {
            throw new Error('gl-shader: Invalid uniform dimension type for matrix ' + name + ': ' + type)
          }
          return 'gl.uniformMatrix' + d + 'fv(locations[' + index + '],false,obj' + path + ')'
        } else {
          throw new Error('gl-shader: Unknown uniform data type for ' + name + ': ' + type)
        }
      break
    }
  }

  function enumerateIndices(prefix, type) {
    if(typeof type !== 'object') {
      return [ [prefix, type] ]
    }
    var indices = []
    for(var id in type) {
      var prop = type[id]
      var tprefix = prefix
      if(parseInt(id) + '' === id) {
        tprefix += '[' + id + ']'
      } else {
        tprefix += '.' + id
      }
      if(typeof prop === 'object') {
        indices.push.apply(indices, enumerateIndices(tprefix, prop))
      } else {
        indices.push([tprefix, prop])
      }
    }
    return indices
  }

  function makeSetter(type) {
    var code = [ 'return function updateProperty(obj){' ]
    var indices = enumerateIndices('', type)
    for(var i=0; i<indices.length; ++i) {
      var item = indices[i]
      var path = item[0]
      var idx  = item[1]
      if(locations[idx]) {
        code.push(makePropSetter(path, idx, uniforms[idx].type))
      }
    }
    code.push('return obj}')
    var proc = new Function('gl', 'prog', 'locations', code.join('\n'))
    return proc(gl, program, locations)
  }

  function defaultValue(type) {
    switch(type) {
      case 'bool':
        return false
      case 'int':
      case 'sampler2D':
      case 'samplerCube':
        return 0
      case 'float':
        return 0.0
      default:
        var vidx = type.indexOf('vec')
        if(0 <= vidx && vidx <= 1 && type.length === 4 + vidx) {
          var d = type.charCodeAt(type.length-1) - 48
          if(d < 2 || d > 4) {
            throw new Error('gl-shader: Invalid data type')
          }
          if(type.charAt(0) === 'b') {
            return dup(d, false)
          }
          return dup(d)
        } else if(type.indexOf('mat') === 0 && type.length === 4) {
          var d = type.charCodeAt(type.length-1) - 48
          if(d < 2 || d > 4) {
            throw new Error('gl-shader: Invalid uniform dimension type for matrix ' + name + ': ' + type)
          }
          return dup([d,d])
        } else {
          throw new Error('gl-shader: Unknown uniform data type for ' + name + ': ' + type)
        }
      break
    }
  }

  function storeProperty(obj, prop, type) {
    if(typeof type === 'object') {
      var child = processObject(type)
      Object.defineProperty(obj, prop, {
        get: identity(child),
        set: makeSetter(type),
        enumerable: true,
        configurable: false
      })
    } else {
      if(locations[type]) {
        Object.defineProperty(obj, prop, {
          get: makeGetter(type),
          set: makeSetter(type),
          enumerable: true,
          configurable: false
        })
      } else {
        obj[prop] = defaultValue(uniforms[type].type)
      }
    }
  }

  function processObject(obj) {
    var result
    if(Array.isArray(obj)) {
      result = new Array(obj.length)
      for(var i=0; i<obj.length; ++i) {
        storeProperty(result, i, obj[i])
      }
    } else {
      result = {}
      for(var id in obj) {
        storeProperty(result, id, obj[id])
      }
    }
    return result
  }

  //Return data
  var coallesced = coallesceUniforms(uniforms, true)
  return {
    get: identity(processObject(coallesced)),
    set: makeSetter(coallesced),
    enumerable: true,
    configurable: true
  }
}

},{"./reflect":"/projects/blackice/node_modules/glslify/node_modules/gl-shader-core/lib/reflect.js","dup":"/projects/blackice/node_modules/glslify/node_modules/gl-shader-core/node_modules/dup/dup.js"}],"/projects/blackice/node_modules/glslify/node_modules/gl-shader-core/lib/reflect.js":[function(require,module,exports){
'use strict'

module.exports = makeReflectTypes

//Construct type info for reflection.
//
// This iterates over the flattened list of uniform type values and smashes them into a JSON object.
//
// The leaves of the resulting object are either indices or type strings representing primitive glslify types
function makeReflectTypes(uniforms, useIndex) {
  var obj = {}
  for(var i=0; i<uniforms.length; ++i) {
    var n = uniforms[i].name
    var parts = n.split(".")
    var o = obj
    for(var j=0; j<parts.length; ++j) {
      var x = parts[j].split("[")
      if(x.length > 1) {
        if(!(x[0] in o)) {
          o[x[0]] = []
        }
        o = o[x[0]]
        for(var k=1; k<x.length; ++k) {
          var y = parseInt(x[k])
          if(k<x.length-1 || j<parts.length-1) {
            if(!(y in o)) {
              if(k < x.length-1) {
                o[y] = []
              } else {
                o[y] = {}
              }
            }
            o = o[y]
          } else {
            if(useIndex) {
              o[y] = i
            } else {
              o[y] = uniforms[i].type
            }
          }
        }
      } else if(j < parts.length-1) {
        if(!(x[0] in o)) {
          o[x[0]] = {}
        }
        o = o[x[0]]
      } else {
        if(useIndex) {
          o[x[0]] = i
        } else {
          o[x[0]] = uniforms[i].type
        }
      }
    }
  }
  return obj
}
},{}],"/projects/blackice/node_modules/glslify/node_modules/gl-shader-core/node_modules/dup/dup.js":[function(require,module,exports){
module.exports=require("/projects/blackice/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/gl-buffer/node_modules/typedarray-pool/node_modules/dup/dup.js")
},{"/projects/blackice/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/gl-buffer/node_modules/typedarray-pool/node_modules/dup/dup.js":"/projects/blackice/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/gl-buffer/node_modules/typedarray-pool/node_modules/dup/dup.js"}],"/projects/blackice/node_modules/glslify/node_modules/gl-shader-core/shader-core.js":[function(require,module,exports){
'use strict'

var createUniformWrapper = require('./lib/create-uniforms')
var createAttributeWrapper = require('./lib/create-attributes')
var makeReflect = require('./lib/reflect')

//Shader object
function Shader(gl, prog, vertShader, fragShader) {
  this.gl = gl
  this.handle = prog
  this.attributes = null
  this.uniforms = null
  this.types = null
  this.vertexShader = vertShader
  this.fragmentShader = fragShader
}

//Binds the shader
Shader.prototype.bind = function() {
  this.gl.useProgram(this.handle)
}

//Destroy shader, release resources
Shader.prototype.dispose = function() {
  var gl = this.gl
  gl.deleteShader(this.vertexShader)
  gl.deleteShader(this.fragmentShader)
  gl.deleteProgram(this.handle)
}

Shader.prototype.updateExports = function(uniforms, attributes) {
  var locations = new Array(uniforms.length)
  var program = this.handle
  var gl = this.gl

  var doLink = relinkUniforms.bind(void 0,
    gl,
    program,
    locations,
    uniforms
  )
  doLink()

  this.types = {
    uniforms: makeReflect(uniforms),
    attributes: makeReflect(attributes)
  }

  this.attributes = createAttributeWrapper(
    gl,
    program,
    attributes,
    doLink
  )

  Object.defineProperty(this, 'uniforms', createUniformWrapper(
    gl,
    program,
    uniforms,
    locations
  ))
}

//Relinks all uniforms
function relinkUniforms(gl, program, locations, uniforms) {
  for(var i=0; i<uniforms.length; ++i) {
    locations[i] = gl.getUniformLocation(program, uniforms[i].name)
  }
}

//Compiles and links a shader program with the given attribute and vertex list
function createShader(
    gl
  , vertSource
  , fragSource
  , uniforms
  , attributes) {
  
  //Compile vertex shader
  var vertShader = gl.createShader(gl.VERTEX_SHADER)
  gl.shaderSource(vertShader, vertSource)
  gl.compileShader(vertShader)
  if(!gl.getShaderParameter(vertShader, gl.COMPILE_STATUS)) {
    var errLog = gl.getShaderInfoLog(vertShader)
    console.error('gl-shader: Error compling vertex shader:', errLog)
    throw new Error('gl-shader: Error compiling vertex shader:' + errLog)
  }
  
  //Compile fragment shader
  var fragShader = gl.createShader(gl.FRAGMENT_SHADER)
  gl.shaderSource(fragShader, fragSource)
  gl.compileShader(fragShader)
  if(!gl.getShaderParameter(fragShader, gl.COMPILE_STATUS)) {
    var errLog = gl.getShaderInfoLog(fragShader)
    console.error('gl-shader: Error compiling fragment shader:', errLog)
    throw new Error('gl-shader: Error compiling fragment shader:' + errLog)
  }
  
  //Link program
  var program = gl.createProgram()
  gl.attachShader(program, fragShader)
  gl.attachShader(program, vertShader)

  //Optional default attriubte locations
  attributes.forEach(function(a) {
    if (typeof a.location === 'number') 
      gl.bindAttribLocation(program, a.location, a.name)
  })

  gl.linkProgram(program)
  if(!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    var errLog = gl.getProgramInfoLog(program)
    console.error('gl-shader: Error linking shader program:', errLog)
    throw new Error('gl-shader: Error linking shader program:' + errLog)
  }
  
  //Return final linked shader object
  var shader = new Shader(
    gl,
    program,
    vertShader,
    fragShader
  )
  shader.updateExports(uniforms, attributes)

  return shader
}

module.exports = createShader

},{"./lib/create-attributes":"/projects/blackice/node_modules/glslify/node_modules/gl-shader-core/lib/create-attributes.js","./lib/create-uniforms":"/projects/blackice/node_modules/glslify/node_modules/gl-shader-core/lib/create-uniforms.js","./lib/reflect":"/projects/blackice/node_modules/glslify/node_modules/gl-shader-core/lib/reflect.js"}],"/projects/blackice/node_modules/glslify/simple-adapter.js":[function(require,module,exports){
module.exports = programify

function programify(vertex, fragment, uniforms, attributes) {
  return {
    vertex: vertex, 
    fragment: fragment,
    uniforms: uniforms, 
    attributes: attributes
  };
}

},{}],"/projects/blackice/node_modules/img/index.js":[function(require,module,exports){
module.exports = img;

function img (src, opt, callback) {
  if (typeof opt === 'function') {
    callback = opt
    opt = null
  }


  var el = document.createElement('img');
  var locked;

  el.onload = function () {
    if (locked) return;
    locked = true;

    callback && callback(undefined, el);
  };

  el.onerror = function (err) {
    if (locked) return;
    locked = true;

    callback && callback(new Error('Unable to load "' + src + '"'), el);
  };
  
  if (opt && opt.crossOrigin)
    el.crossOrigin = opt.crossOrigin;

  el.src = src;

  return el;
}

},{}],"/projects/blackice/node_modules/inherits/inherits_browser.js":[function(require,module,exports){
module.exports=require("/projects/blackice/node_modules/gl-sprite-text/node_modules/inherits/inherits_browser.js")
},{"/projects/blackice/node_modules/gl-sprite-text/node_modules/inherits/inherits_browser.js":"/projects/blackice/node_modules/gl-sprite-text/node_modules/inherits/inherits_browser.js"}],"/projects/blackice/node_modules/mixes/index.js":[function(require,module,exports){
module.exports=require("/projects/blackice/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/mixes/index.js")
},{"/projects/blackice/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/mixes/index.js":"/projects/blackice/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/mixes/index.js"}],"/projects/blackice/node_modules/normalize-path-scale/index.js":[function(require,module,exports){
var bounds = require('getboundingbox')
var unlerp = require('unlerp')

module.exports = function normalize(path, box) {
    var b
    if (box && typeof box === 'object') {
        b = box
    } else
        b = bounds(path)

    //TODO: hmm, doesn't really handle div by zero
    //in any sane manner

    var w = (b.maxX-b.minX),
        h = (b.maxY-b.minY)

    var aspectX = w>h ? 1 : h/w,
        aspectY = w>h ? w/h : 1

    return path.map(function(p) {
        return [
            range(b.minX, b.maxX, p[0])*1/aspectX,
            range(b.minY, b.maxY, p[1])*1/aspectY
        ]
    })
}

function range(min, max, value) {
    return ((max-min===0) ? 0 : unlerp(min, max, value))*2-1
}
},{"getboundingbox":"/projects/blackice/node_modules/normalize-path-scale/node_modules/getboundingbox/index.js","unlerp":"/projects/blackice/node_modules/unlerp/index.js"}],"/projects/blackice/node_modules/normalize-path-scale/node_modules/getboundingbox/index.js":[function(require,module,exports){
module.exports = function( path, box, xKey, yKey ) {
    xKey = typeof xKey === 'string' ? xKey : 0;
    yKey = typeof yKey === 'string' ? yKey : 1;
    if (!box || typeof box === 'number')
        box = {};

    box.minX = Infinity;
    box.minY = Infinity;
    box.maxX = -Infinity;
    box.maxY = -Infinity;

    for (var i=0; i<path.length; i++) {
        var x = path[i][ xKey ],
            y = path[i][ yKey ];
        box.minX = Math.min( box.minX, x );
        box.minY = Math.min( box.minY, y );
        box.maxX = Math.max( box.maxX, x );
        box.maxY = Math.max( box.maxY, y );
    }
    
    if (path.length === 0) 
        box.minX = box.maxX = box.minY = box.maxY = 0
    return box;
};
},{}],"/projects/blackice/node_modules/parse-svg-path/index.js":[function(require,module,exports){

module.exports = parse

/**
 * expected argument lengths
 * @type {Object}
 */

var length = {a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0}

/**
 * segment pattern
 * @type {RegExp}
 */

var segment = /([astvzqmhlc])([^astvzqmhlc]*)/ig

/**
 * parse an svg path data string. Generates an Array
 * of commands where each command is an Array of the
 * form `[command, arg1, arg2, ...]`
 *
 * @param {String} path
 * @return {Array}
 */

function parse(path) {
	var data = []
	path.replace(segment, function(_, command, args){
		var type = command.toLowerCase()
		args = parseValues(args)

		// overloaded moveTo
		if (type == 'm' && args.length > 2) {
			data.push([command].concat(args.splice(0, 2)))
			type = 'l'
			command = command == 'm' ? 'l' : 'L'
		}

		while (true) {
			if (args.length == length[type]) {
				args.unshift(command)
				return data.push(args)
			}
			if (args.length < length[type]) throw new Error('malformed path data')
			data.push([command].concat(args.splice(0, length[type])))
		}
	})
	return data
}

function parseValues(args){
	args = args.match(/-?[.0-9]+(?:e[-+]?\d+)?/ig)
	return args ? args.map(Number) : []
}

},{}],"/projects/blackice/node_modules/plucker/index.js":[function(require,module,exports){
module.exports = plucker

function plucker(path, object) {
  return arguments.length >= 2
    ? pluck(path)(object)
    : pluck(path)
}

function pluck(path) {
  path = typeof path === 'string'
    ? String(path).trim().split('.')
    : path

  if (path.length < 2) {
    path = path[0]
    return pluckSingle
  } else {
    var l = path.length
    return pluckPath
  }

  function pluckSingle(object) {
    return object[path]
  }

  function pluckPath(object) {
    for (var i = 0; i < l; i++) {
      if (typeof object === 'undefined') break

      object = object[path[i]]
    }

    return object
  }
}

},{}],"/projects/blackice/node_modules/raf.js/raf.js":[function(require,module,exports){
/*
 * raf.js
 * https://github.com/ngryman/raf.js
 *
 * original requestAnimationFrame polyfill by Erik Mller
 * inspired from paul_irish gist and post
 *
 * Copyright (c) 2013 ngryman
 * Licensed under the MIT license.
 */

(function(window) {
	var lastTime = 0,
		vendors = ['webkit', 'moz'],
		requestAnimationFrame = window.requestAnimationFrame,
		cancelAnimationFrame = window.cancelAnimationFrame,
		i = vendors.length;

	// try to un-prefix existing raf
	while (--i >= 0 && !requestAnimationFrame) {
		requestAnimationFrame = window[vendors[i] + 'RequestAnimationFrame'];
		cancelAnimationFrame = window[vendors[i] + 'CancelAnimationFrame'];
	}

	// polyfill with setTimeout fallback
	// heavily inspired from @darius gist mod: https://gist.github.com/paulirish/1579671#comment-837945
	if (!requestAnimationFrame || !cancelAnimationFrame) {
		requestAnimationFrame = function(callback) {
			var now = +new Date(), nextTime = Math.max(lastTime + 16, now);
			return setTimeout(function() {
				callback(lastTime = nextTime);
			}, nextTime - now);
		};

		cancelAnimationFrame = clearTimeout;
	}

	// export to window
	window.requestAnimationFrame = requestAnimationFrame;
	window.cancelAnimationFrame = cancelAnimationFrame;
}(window));

},{}],"/projects/blackice/node_modules/simplify-path/douglas-peucker.js":[function(require,module,exports){
// square distance from a point to a segment
function getSqSegDist(p, p1, p2) {
    var x = p1[0],
        y = p1[1],
        dx = p2[0] - x,
        dy = p2[1] - y;

    if (dx !== 0 || dy !== 0) {

        var t = ((p[0] - x) * dx + (p[1] - y) * dy) / (dx * dx + dy * dy);

        if (t > 1) {
            x = p2[0];
            y = p2[1];

        } else if (t > 0) {
            x += dx * t;
            y += dy * t;
        }
    }

    dx = p[0] - x;
    dy = p[1] - y;

    return dx * dx + dy * dy;
}

// simplification using optimized Douglas-Peucker algorithm with recursion elimination
module.exports = function simplifyDouglasPeucker(points, tolerance) {
    if (points.length<=1)
        return points;
    tolerance = typeof tolerance === 'number' ? tolerance : 1;
    var sqTolerance = tolerance * tolerance;

    var len = points.length,
        MarkerArray = typeof Uint8Array !== 'undefined' ? Uint8Array : Array,
        markers = new MarkerArray(len),
        first = 0,
        last = len - 1,
        stack = [],
        newPoints = [],
        i, maxSqDist, sqDist, index;

    markers[first] = markers[last] = 1;

    while (last) {

        maxSqDist = 0;

        for (i = first + 1; i < last; i++) {
            sqDist = getSqSegDist(points[i], points[first], points[last]);

            if (sqDist > maxSqDist) {
                index = i;
                maxSqDist = sqDist;
            }
        }

        if (maxSqDist > sqTolerance) {
            markers[index] = 1;
            stack.push(first, index, index, last);
        }

        last = stack.pop();
        first = stack.pop();
    }

    for (i = 0; i < len; i++) {
        if (markers[i]) newPoints.push(points[i]);
    }

    return newPoints;
}
},{}],"/projects/blackice/node_modules/simplify-path/index.js":[function(require,module,exports){
var simplifyRadialDist = require('./radial-distance')
var simplifyDouglasPeucker = require('./douglas-peucker')

//simplifies using both algorithms
module.exports = function simplify(points, tolerance) {
    points = simplifyRadialDist(points, tolerance);
    points = simplifyDouglasPeucker(points, tolerance);
    return points;
}

module.exports.radialDistance = simplifyRadialDist;
module.exports.douglasPeucker = simplifyDouglasPeucker;
},{"./douglas-peucker":"/projects/blackice/node_modules/simplify-path/douglas-peucker.js","./radial-distance":"/projects/blackice/node_modules/simplify-path/radial-distance.js"}],"/projects/blackice/node_modules/simplify-path/radial-distance.js":[function(require,module,exports){
function getSqDist(p1, p2) {
    var dx = p1[0] - p2[0],
        dy = p1[1] - p2[1];

    return dx * dx + dy * dy;
}

// basic distance-based simplification
module.exports = function simplifyRadialDist(points, tolerance) {
    if (points.length<=1)
        return points;
    tolerance = typeof tolerance === 'number' ? tolerance : 1;
    var sqTolerance = tolerance * tolerance;
    
    var prevPoint = points[0],
        newPoints = [prevPoint],
        point;

    for (var i = 1, len = points.length; i < len; i++) {
        point = points[i];

        if (getSqDist(point, prevPoint) > sqTolerance) {
            newPoints.push(point);
            prevPoint = point;
        }
    }

    if (prevPoint !== point) newPoints.push(point);

    return newPoints;
}
},{}],"/projects/blackice/node_modules/smoothstep/index.js":[function(require,module,exports){
module.exports = function smoothstep (min, max, value) {
  var x = Math.max(0, Math.min(1, (value-min)/(max-min)));
  return x*x*(3 - 2*x);
};

},{}],"/projects/blackice/node_modules/svg-path-contours/index.js":[function(require,module,exports){
var bezier = require('adaptive-bezier-curve')
var abs = require('abs-svg-path')
var norm = require('normalize-svg-path')
var copy = require('vec2-copy')

function set(out, x, y) {
    out[0] = x
    out[1] = y
    return out
}

var tmp1 = [0,0],
    tmp2 = [0,0],
    tmp3 = [0,0]

function bezierTo(points, scale, start, seg) {
    bezier(start, 
        set(tmp1, seg[1], seg[2]), 
        set(tmp2, seg[3], seg[4]),
        set(tmp3, seg[5], seg[6]), scale, points)
}

module.exports = function contours(svg, scale) {
    var paths = []

    var points = []
    var pen = [0, 0]
    norm(abs(svg)).forEach(function(segment, i, self) {
        if (segment[0] === 'M') {
            copy(pen, segment.slice(1))
            if (points.length>0) {
                paths.push(points)
                points = []
            }
            points.push(pen)
        } else if (segment[0] === 'C') {
            bezierTo(points, scale, pen, segment)
            set(pen, segment[5], segment[6])
        } else {
            throw new Error('illegal type in SVG: '+segment[0])
        }
    })
    if (points.length>0)
        paths.push(points)
    return paths
}
},{"abs-svg-path":"/projects/blackice/node_modules/svg-path-contours/node_modules/abs-svg-path/index.js","adaptive-bezier-curve":"/projects/blackice/node_modules/svg-path-contours/node_modules/adaptive-bezier-curve/index.js","normalize-svg-path":"/projects/blackice/node_modules/svg-path-contours/node_modules/normalize-svg-path/index.js","vec2-copy":"/projects/blackice/node_modules/svg-path-contours/node_modules/vec2-copy/index.js"}],"/projects/blackice/node_modules/svg-path-contours/node_modules/abs-svg-path/index.js":[function(require,module,exports){

module.exports = absolutize

/**
 * redefine `path` with absolute coordinates
 *
 * @param {Array} path
 * @return {Array}
 */

function absolutize(path){
	var startX = 0
	var startY = 0
	var x = 0
	var y = 0

	return path.map(function(seg){
		seg = seg.slice()
		var type = seg[0]
		var command = type.toUpperCase()

		// is relative
		if (type != command) {
			seg[0] = command
			switch (type) {
				case 'a':
					seg[6] += x
					seg[7] += y
					break
				case 'v':
					seg[1] += y
					break
				case 'h':
					seg[1] += x
					break
				default:
					for (var i = 1; i < seg.length;) {
						seg[i++] += x
						seg[i++] += y
					}
			}
		}

		// update cursor state
		switch (command) {
			case 'Z':
				x = startX
				y = startY
				break
			case 'H':
				x = seg[1]
				break
			case 'V':
				y = seg[1]
				break
			case 'M':
				x = startX = seg[1]
				y = startY = seg[2]
				break
			default:
				x = seg[seg.length - 2]
				y = seg[seg.length - 1]
		}

		return seg
	})
}

},{}],"/projects/blackice/node_modules/svg-path-contours/node_modules/adaptive-bezier-curve/function.js":[function(require,module,exports){
function clone(point) { //TODO: use gl-vec2 for this
    return [point[0], point[1]]
}

function vec2(x, y) {
    return [x, y]
}

module.exports = function createBezierBuilder(opt) {
    opt = opt||{}

    var RECURSION_LIMIT = typeof opt.recursion === 'number' ? opt.recursion : 8
    var FLT_EPSILON = typeof opt.epsilon === 'number' ? opt.epsilon : 1.19209290e-7
    var PATH_DISTANCE_EPSILON = typeof opt.pathEpsilon === 'number' ? opt.pathEpsilon : 1.0

    var curve_angle_tolerance_epsilon = typeof opt.angleEpsilon === 'number' ? opt.angleEpsilon : 0.01
    var m_angle_tolerance = opt.angleTolerance || 0
    var m_cusp_limit = opt.cuspLimit || 0

    return function bezierCurve(start, c1, c2, end, scale, points) {
        if (!points)
            points = []

        scale = typeof scale === 'number' ? scale : 1.0
        var distanceTolerance = PATH_DISTANCE_EPSILON / scale
        distanceTolerance *= distanceTolerance
        begin(start, c1, c2, end, points, distanceTolerance)
        return points
    }


    ////// Based on:
    ////// https://github.com/pelson/antigrain/blob/master/agg-2.4/src/agg_curves.cpp

    function begin(start, c1, c2, end, points, distanceTolerance) {
        points.push(clone(start))
        var x1 = start[0],
            y1 = start[1],
            x2 = c1[0],
            y2 = c1[1],
            x3 = c2[0],
            y3 = c2[1],
            x4 = end[0],
            y4 = end[1]
        recursive(x1, y1, x2, y2, x3, y3, x4, y4, points, distanceTolerance, 0)
        points.push(clone(end))
    }

    function recursive(x1, y1, x2, y2, x3, y3, x4, y4, points, distanceTolerance, level) {
        if(level > RECURSION_LIMIT) 
            return

        var pi = Math.PI

        // Calculate all the mid-points of the line segments
        //----------------------
        var x12   = (x1 + x2) / 2
        var y12   = (y1 + y2) / 2
        var x23   = (x2 + x3) / 2
        var y23   = (y2 + y3) / 2
        var x34   = (x3 + x4) / 2
        var y34   = (y3 + y4) / 2
        var x123  = (x12 + x23) / 2
        var y123  = (y12 + y23) / 2
        var x234  = (x23 + x34) / 2
        var y234  = (y23 + y34) / 2
        var x1234 = (x123 + x234) / 2
        var y1234 = (y123 + y234) / 2

        if(level > 0) { // Enforce subdivision first time
            // Try to approximate the full cubic curve by a single straight line
            //------------------
            var dx = x4-x1
            var dy = y4-y1

            var d2 = Math.abs((x2 - x4) * dy - (y2 - y4) * dx)
            var d3 = Math.abs((x3 - x4) * dy - (y3 - y4) * dx)

            var da1, da2

            if(d2 > FLT_EPSILON && d3 > FLT_EPSILON) {
                // Regular care
                //-----------------
                if((d2 + d3)*(d2 + d3) <= distanceTolerance * (dx*dx + dy*dy)) {
                    // If the curvature doesn't exceed the distanceTolerance value
                    // we tend to finish subdivisions.
                    //----------------------
                    if(m_angle_tolerance < curve_angle_tolerance_epsilon) {
                        points.push(vec2(x1234, y1234))
                        return
                    }

                    // Angle & Cusp Condition
                    //----------------------
                    var a23 = Math.atan2(y3 - y2, x3 - x2)
                    da1 = Math.abs(a23 - Math.atan2(y2 - y1, x2 - x1))
                    da2 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - a23)
                    if(da1 >= pi) da1 = 2*pi - da1
                    if(da2 >= pi) da2 = 2*pi - da2

                    if(da1 + da2 < m_angle_tolerance) {
                        // Finally we can stop the recursion
                        //----------------------
                        points.push(vec2(x1234, y1234))
                        return
                    }

                    if(m_cusp_limit !== 0.0) {
                        if(da1 > m_cusp_limit) {
                            points.push(vec2(x2, y2))
                            return
                        }

                        if(da2 > m_cusp_limit) {
                            points.push(vec2(x3, y3))
                            return
                        }
                    }
                }
            }
            else {
                if(d2 > FLT_EPSILON) {
                    // p1,p3,p4 are collinear, p2 is considerable
                    //----------------------
                    if(d2 * d2 <= distanceTolerance * (dx*dx + dy*dy)) {
                        if(m_angle_tolerance < curve_angle_tolerance_epsilon) {
                            points.push(vec2(x1234, y1234))
                            return
                        }

                        // Angle Condition
                        //----------------------
                        da1 = Math.abs(Math.atan2(y3 - y2, x3 - x2) - Math.atan2(y2 - y1, x2 - x1))
                        if(da1 >= pi) da1 = 2*pi - da1

                        if(da1 < m_angle_tolerance) {
                            points.push(vec2(x2, y2))
                            points.push(vec2(x3, y3))
                            return
                        }

                        if(m_cusp_limit !== 0.0) {
                            if(da1 > m_cusp_limit) {
                                points.push(vec2(x2, y2))
                                return
                            }
                        }
                    }
                }
                else if(d3 > FLT_EPSILON) {
                    // p1,p2,p4 are collinear, p3 is considerable
                    //----------------------
                    if(d3 * d3 <= distanceTolerance * (dx*dx + dy*dy)) {
                        if(m_angle_tolerance < curve_angle_tolerance_epsilon) {
                            points.push(vec2(x1234, y1234))
                            return
                        }

                        // Angle Condition
                        //----------------------
                        da1 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - Math.atan2(y3 - y2, x3 - x2))
                        if(da1 >= pi) da1 = 2*pi - da1

                        if(da1 < m_angle_tolerance) {
                            points.push(vec2(x2, y2))
                            points.push(vec2(x3, y3))
                            return
                        }

                        if(m_cusp_limit !== 0.0) {
                            if(da1 > m_cusp_limit)
                            {
                                points.push(vec2(x3, y3))
                                return
                            }
                        }
                    }
                }
                else {
                    // Collinear case
                    //-----------------
                    dx = x1234 - (x1 + x4) / 2
                    dy = y1234 - (y1 + y4) / 2
                    if(dx*dx + dy*dy <= distanceTolerance) {
                        points.push(vec2(x1234, y1234))
                        return
                    }
                }
            }
        }

        // Continue subdivision
        //----------------------
        recursive(x1, y1, x12, y12, x123, y123, x1234, y1234, points, distanceTolerance, level + 1) 
        recursive(x1234, y1234, x234, y234, x34, y34, x4, y4, points, distanceTolerance, level + 1) 
    }
}

},{}],"/projects/blackice/node_modules/svg-path-contours/node_modules/adaptive-bezier-curve/index.js":[function(require,module,exports){
module.exports = require('./function')()
},{"./function":"/projects/blackice/node_modules/svg-path-contours/node_modules/adaptive-bezier-curve/function.js"}],"/projects/blackice/node_modules/svg-path-contours/node_modules/normalize-svg-path/index.js":[function(require,module,exports){

var  = Math.PI
var _120 = radians(120)

module.exports = normalize

/**
 * describe `path` in terms of cubic bzier 
 * curves and move commands
 *
 * @param {Array} path
 * @return {Array}
 */

function normalize(path){
	// init state
	var prev
	var result = []
	var bezierX = 0
	var bezierY = 0
	var startX = 0
	var startY = 0
	var quadX = null
	var quadY = null
	var x = 0
	var y = 0

	for (var i = 0, len = path.length; i < len; i++) {
		var seg = path[i]
		var command = seg[0]
		switch (command) {
			case 'M':
				startX = seg[1]
				startY = seg[2]
				break
			case 'A':
				seg = arc(x, y,seg[1],seg[2],radians(seg[3]),seg[4],seg[5],seg[6],seg[7])
				// split multi part
				seg.unshift('C')
				if (seg.length > 7) {
					result.push(seg.splice(0, 7))
					seg.unshift('C')
				}
				break
			case 'S':
				// default control point
				var cx = x
				var cy = y
				if (prev == 'C' || prev == 'S') {
					cx += cx - bezierX // reflect the previous command's control
					cy += cy - bezierY // point relative to the current point
				}
				seg = ['C', cx, cy, seg[1], seg[2], seg[3], seg[4]]
				break
			case 'T':
				if (prev == 'Q' || prev == 'T') {
					quadX = x * 2 - quadX // as with 'S' reflect previous control point
					quadY = y * 2 - quadY
				} else {
					quadX = x
					quadY = y
				}
				seg = quadratic(x, y, quadX, quadY, seg[1], seg[2])
				break
			case 'Q':
				quadX = seg[1]
				quadY = seg[2]
				seg = quadratic(x, y, seg[1], seg[2], seg[3], seg[4])
				break
			case 'L':
				seg = line(x, y, seg[1], seg[2])
				break
			case 'H':
				seg = line(x, y, seg[1], y)
				break
			case 'V':
				seg = line(x, y, x, seg[1])
				break
			case 'Z':
				seg = line(x, y, startX, startY)
				break
		}

		// update state
		prev = command
		x = seg[seg.length - 2]
		y = seg[seg.length - 1]
		if (seg.length > 4) {
			bezierX = seg[seg.length - 4]
			bezierY = seg[seg.length - 3]
		} else {
			bezierX = x
			bezierY = y
		}
		result.push(seg)
	}

	return result
}

function line(x1, y1, x2, y2){
	return ['C', x1, y1, x2, y2, x2, y2]
}

function quadratic(x1, y1, cx, cy, x2, y2){
	return [
		'C',
		x1/3 + (2/3) * cx,
		y1/3 + (2/3) * cy,
		x2/3 + (2/3) * cx,
		y2/3 + (2/3) * cy,
		x2,
		y2
	]
}

// This function is ripped from 
// github.com/DmitryBaranovskiy/raphael/blob/4d97d4/raphael.js#L2216-L2304 
// which references w3.org/TR/SVG11/implnote.html#ArcImplementationNotes
// TODO: make it human readable

function arc(x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {
	if (!recursive) {
		var xy = rotate(x1, y1, -angle)
		x1 = xy.x
		y1 = xy.y
		xy = rotate(x2, y2, -angle)
		x2 = xy.x
		y2 = xy.y
		var x = (x1 - x2) / 2
		var y = (y1 - y2) / 2
		var h = (x * x) / (rx * rx) + (y * y) / (ry * ry)
		if (h > 1) {
			h = Math.sqrt(h)
			rx = h * rx
			ry = h * ry
		}
		var rx2 = rx * rx
		var ry2 = ry * ry
		var k = (large_arc_flag == sweep_flag ? -1 : 1)
			* Math.sqrt(Math.abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x)))
		if (k == Infinity) k = 1 // neutralize
		var cx = k * rx * y / ry + (x1 + x2) / 2
		var cy = k * -ry * x / rx + (y1 + y2) / 2
		var f1 = Math.asin(((y1 - cy) / ry).toFixed(9))
		var f2 = Math.asin(((y2 - cy) / ry).toFixed(9))

		f1 = x1 < cx ?  - f1 : f1
		f2 = x2 < cx ?  - f2 : f2
		if (f1 < 0) f1 =  * 2 + f1
		if (f2 < 0) f2 =  * 2 + f2
		if (sweep_flag && f1 > f2) f1 = f1 -  * 2
		if (!sweep_flag && f2 > f1) f2 = f2 -  * 2
	} else {
		f1 = recursive[0]
		f2 = recursive[1]
		cx = recursive[2]
		cy = recursive[3]
	}
	// greater than 120 degrees requires multiple segments
	if (Math.abs(f2 - f1) > _120) {
		var f2old = f2
		var x2old = x2
		var y2old = y2
		f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1)
		x2 = cx + rx * Math.cos(f2)
		y2 = cy + ry * Math.sin(f2)
		var res = arc(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy])
	}
	var t = Math.tan((f2 - f1) / 4)
	var hx = 4 / 3 * rx * t
	var hy = 4 / 3 * ry * t
	var curve = [
		2 * x1 - (x1 + hx * Math.sin(f1)),
		2 * y1 - (y1 - hy * Math.cos(f1)),
		x2 + hx * Math.sin(f2),
		y2 - hy * Math.cos(f2),
		x2,
		y2
	]
	if (recursive) return curve
	if (res) curve = curve.concat(res)
	for (var i = 0; i < curve.length;) {
		var rot = rotate(curve[i], curve[i+1], angle)
		curve[i++] = rot.x
		curve[i++] = rot.y
	}
	return curve
}

function rotate(x, y, rad){
	return {
		x: x * Math.cos(rad) - y * Math.sin(rad),
		y: x * Math.sin(rad) + y * Math.cos(rad)
	}
}

function radians(degress){
	return degress * ( / 180)
}

},{}],"/projects/blackice/node_modules/svg-path-contours/node_modules/vec2-copy/index.js":[function(require,module,exports){
module.exports = function vec2Copy(out, a) {
    out[0] = a[0]
    out[1] = a[1]
    return out
}
},{}],"/projects/blackice/node_modules/three-effectcomposer/index.js":[function(require,module,exports){
/**
 * @author alteredq / http://alteredqualia.com/
 */

module.exports = function(THREE) {
  var CopyShader = EffectComposer.CopyShader = require('three-copyshader')
    , RenderPass = EffectComposer.RenderPass = require('./lib/renderpass')(THREE)
    , ShaderPass = EffectComposer.ShaderPass = require('./lib/shaderpass')(THREE, EffectComposer)
    , MaskPass = EffectComposer.MaskPass = require('./lib/maskpass')(THREE)
    , ClearMaskPass = EffectComposer.ClearMaskPass = require('./lib/clearmaskpass')(THREE)

  function EffectComposer( renderer, renderTarget ) {
    this.renderer = renderer;

    if ( renderTarget === undefined ) {
      var width = window.innerWidth || 1;
      var height = window.innerHeight || 1;
      var parameters = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBFormat, stencilBuffer: false };

      renderTarget = new THREE.WebGLRenderTarget( width, height, parameters );
    }

    this.renderTarget1 = renderTarget;
    this.renderTarget2 = renderTarget.clone();

    this.writeBuffer = this.renderTarget1;
    this.readBuffer = this.renderTarget2;

    this.passes = [];

    this.copyPass = new ShaderPass( CopyShader );
  };

  EffectComposer.prototype = {
    swapBuffers: function() {

      var tmp = this.readBuffer;
      this.readBuffer = this.writeBuffer;
      this.writeBuffer = tmp;

    },

    addPass: function ( pass ) {

      this.passes.push( pass );

    },

    insertPass: function ( pass, index ) {

      this.passes.splice( index, 0, pass );

    },

    render: function ( delta ) {

      this.writeBuffer = this.renderTarget1;
      this.readBuffer = this.renderTarget2;

      var maskActive = false;

      var pass, i, il = this.passes.length;

      for ( i = 0; i < il; i ++ ) {

        pass = this.passes[ i ];

        if ( !pass.enabled ) continue;

        pass.render( this.renderer, this.writeBuffer, this.readBuffer, delta, maskActive );

        if ( pass.needsSwap ) {

          if ( maskActive ) {

            var context = this.renderer.context;

            context.stencilFunc( context.NOTEQUAL, 1, 0xffffffff );

            this.copyPass.render( this.renderer, this.writeBuffer, this.readBuffer, delta );

            context.stencilFunc( context.EQUAL, 1, 0xffffffff );

          }

          this.swapBuffers();

        }

        if ( pass instanceof MaskPass ) {

          maskActive = true;

        } else if ( pass instanceof ClearMaskPass ) {

          maskActive = false;

        }

      }

    },

    reset: function ( renderTarget ) {

      if ( renderTarget === undefined ) {

        renderTarget = this.renderTarget1.clone();

        renderTarget.width = window.innerWidth;
        renderTarget.height = window.innerHeight;

      }

      this.renderTarget1 = renderTarget;
      this.renderTarget2 = renderTarget.clone();

      this.writeBuffer = this.renderTarget1;
      this.readBuffer = this.renderTarget2;

    },

    setSize: function ( width, height ) {

      var renderTarget = this.renderTarget1.clone();

      renderTarget.width = width;
      renderTarget.height = height;

      this.reset( renderTarget );

    }

  };

  // shared ortho camera

  EffectComposer.camera = new THREE.OrthographicCamera( -1, 1, 1, -1, 0, 1 );

  EffectComposer.quad = new THREE.Mesh( new THREE.PlaneGeometry( 2, 2 ), null );

  EffectComposer.scene = new THREE.Scene();
  EffectComposer.scene.add( EffectComposer.quad );

  return EffectComposer
};
},{"./lib/clearmaskpass":"/projects/blackice/node_modules/three-effectcomposer/lib/clearmaskpass.js","./lib/maskpass":"/projects/blackice/node_modules/three-effectcomposer/lib/maskpass.js","./lib/renderpass":"/projects/blackice/node_modules/three-effectcomposer/lib/renderpass.js","./lib/shaderpass":"/projects/blackice/node_modules/three-effectcomposer/lib/shaderpass.js","three-copyshader":"/projects/blackice/node_modules/three-effectcomposer/node_modules/three-copyshader/index.js"}],"/projects/blackice/node_modules/three-effectcomposer/lib/clearmaskpass.js":[function(require,module,exports){
/**
 * @author alteredq / http://alteredqualia.com/
 */

module.exports = function(THREE) {
  function ClearMaskPass() {
    if (!(this instanceof ClearMaskPass)) return new ClearMaskPass(scene, camera);
    this.enabled = true;
  };

  ClearMaskPass.prototype = {
    render: function ( renderer, writeBuffer, readBuffer, delta ) {
      var context = renderer.context;
      context.disable( context.STENCIL_TEST );
    }
  };

  return ClearMaskPass
};
},{}],"/projects/blackice/node_modules/three-effectcomposer/lib/maskpass.js":[function(require,module,exports){
/**
 * @author alteredq / http://alteredqualia.com/
 */

module.exports = function(THREE) {
  function MaskPass( scene, camera ) {
    if (!(this instanceof MaskPass)) return new MaskPass(scene, camera);

    this.scene = scene;
    this.camera = camera;

    this.enabled = true;
    this.clear = true;
    this.needsSwap = false;

    this.inverse = false;
  };

  MaskPass.prototype = {

    render: function ( renderer, writeBuffer, readBuffer, delta ) {

      var context = renderer.context;

      // don't update color or depth

      context.colorMask( false, false, false, false );
      context.depthMask( false );

      // set up stencil

      var writeValue, clearValue;

      if ( this.inverse ) {

        writeValue = 0;
        clearValue = 1;

      } else {

        writeValue = 1;
        clearValue = 0;

      }

      context.enable( context.STENCIL_TEST );
      context.stencilOp( context.REPLACE, context.REPLACE, context.REPLACE );
      context.stencilFunc( context.ALWAYS, writeValue, 0xffffffff );
      context.clearStencil( clearValue );

      // draw into the stencil buffer

      renderer.render( this.scene, this.camera, readBuffer, this.clear );
      renderer.render( this.scene, this.camera, writeBuffer, this.clear );

      // re-enable update of color and depth

      context.colorMask( true, true, true, true );
      context.depthMask( true );

      // only render where stencil is set to 1

      context.stencilFunc( context.EQUAL, 1, 0xffffffff );  // draw if == 1
      context.stencilOp( context.KEEP, context.KEEP, context.KEEP );

    }

  };

  return MaskPass
};

},{}],"/projects/blackice/node_modules/three-effectcomposer/lib/renderpass.js":[function(require,module,exports){
/**
 * @author alteredq / http://alteredqualia.com/
 */

module.exports = function(THREE) {
  function RenderPass( scene, camera, overrideMaterial, clearColor, clearAlpha ) {
    if (!(this instanceof RenderPass)) return new RenderPass(scene, camera, overrideMaterial, clearColor, clearAlpha);

    this.scene = scene;
    this.camera = camera;

    this.overrideMaterial = overrideMaterial;

    this.clearColor = clearColor;
    this.clearAlpha = ( clearAlpha !== undefined ) ? clearAlpha : 1;

    this.oldClearColor = new THREE.Color();
    this.oldClearAlpha = 1;

    this.enabled = true;
    this.clear = true;
    this.needsSwap = false;

  };

  RenderPass.prototype = {

    render: function ( renderer, writeBuffer, readBuffer, delta ) {

      this.scene.overrideMaterial = this.overrideMaterial;

      if ( this.clearColor ) {

        this.oldClearColor.copy( renderer.getClearColor() );
        this.oldClearAlpha = renderer.getClearAlpha();

        renderer.setClearColor( this.clearColor, this.clearAlpha );

      }

      renderer.render( this.scene, this.camera, readBuffer, this.clear );

      if ( this.clearColor ) {

        renderer.setClearColor( this.oldClearColor, this.oldClearAlpha );

      }

      this.scene.overrideMaterial = null;

    }

  };

  return RenderPass;

};

},{}],"/projects/blackice/node_modules/three-effectcomposer/lib/shaderpass.js":[function(require,module,exports){
/**
 * @author alteredq / http://alteredqualia.com/
 */

module.exports = function(THREE, EffectComposer) {
  function ShaderPass( shader, textureID ) {
    if (!(this instanceof ShaderPass)) return new ShaderPass(shader, textureID);

    this.textureID = ( textureID !== undefined ) ? textureID : "tDiffuse";

    this.uniforms = THREE.UniformsUtils.clone( shader.uniforms );

    this.material = new THREE.ShaderMaterial( {

      uniforms: this.uniforms,
      vertexShader: shader.vertexShader,
      fragmentShader: shader.fragmentShader

    } );

    this.renderToScreen = false;

    this.enabled = true;
    this.needsSwap = true;
    this.clear = false;

  };

  ShaderPass.prototype = {

    render: function ( renderer, writeBuffer, readBuffer, delta ) {

      if ( this.uniforms[ this.textureID ] ) {

        this.uniforms[ this.textureID ].value = readBuffer;

      }

      EffectComposer.quad.material = this.material;

      if ( this.renderToScreen ) {

        renderer.render( EffectComposer.scene, EffectComposer.camera );

      } else {

        renderer.render( EffectComposer.scene, EffectComposer.camera, writeBuffer, this.clear );

      }

    }

  };

  return ShaderPass;

};
},{}],"/projects/blackice/node_modules/three-effectcomposer/node_modules/three-copyshader/index.js":[function(require,module,exports){
/**
 * @author alteredq / http://alteredqualia.com/
 *
 * Full-screen textured quad shader
 */

module.exports = {
  uniforms: {
    "tDiffuse": { type: "t", value: null },
    "opacity":  { type: "f", value: 1.0 }
  },
  vertexShader: [
    "varying vec2 vUv;",

    "void main() {",

      "vUv = uv;",
      "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

    "}"
  ].join("\n"),
  fragmentShader: [
    "uniform float opacity;",

    "uniform sampler2D tDiffuse;",

    "varying vec2 vUv;",

    "void main() {",

      "vec4 texel = texture2D( tDiffuse, vUv );",
      "gl_FragColor = opacity * texel;",

    "}"
  ].join("\n")
};

},{}],"/projects/blackice/node_modules/three-glslify/index.js":[function(require,module,exports){
var createTypes = require('./types')


module.exports = function(THREE) {

    var types = createTypes(THREE) 

    return function create(glShader, opts) {
        opts = opts||{}

        if (typeof opts.colors === 'string')
            opts.colors = [opts.colors]
        
        var tUniforms = types( glShader.uniforms, opts.colors )
        var tAttribs = types( glShader.attributes, opts.colors )
            
        //clear the attribute arrays
        for (var k in tAttribs) {
            tAttribs[k].value = []
        }

        return {
            vertexShader: glShader.vertex,
            fragmentShader: glShader.fragment,
            uniforms: tUniforms,
            attributes: tAttribs
        }
    }
}
},{"./types":"/projects/blackice/node_modules/three-glslify/types.js"}],"/projects/blackice/node_modules/three-glslify/types.js":[function(require,module,exports){
var typeMap = {
    'int': 'i',
    'float': 'f',
    'ivec2': 'i2',
    'ivec3': 'i3',
    'ivec4': 'i4',
    'vec2': 'v2',
    'vec3': 'v3',
    'vec4': 'v4',
    'mat4': 'm4',
    'mat3': 'm3',
    'sampler2D': 't',
    'samplerCube': 't'
}

function create(THREE) {
    function newInstance(type, isArray) {
        switch (type) {
            case 'float': 
            case 'int':
                return 0
            case 'vec2':
            case 'ivec2':
                return new THREE.Vector2()
            case 'vec3':
            case 'ivec3':
                return new THREE.Vector3()
            case 'vec4':
            case 'ivec4':
                return new THREE.Vector4()
            case 'mat4':
                return new THREE.Matrix4()
            case 'mat3':
                return new THREE.Matrix3()
            case 'samplerCube':
            case 'sampler2D':
                return new THREE.Texture()
            default:
                return undefined
        }
    }

    function defaultValue(type, isArray, arrayLen) {
        if (isArray) {
            //ThreeJS flattens ivec3 type
            //(we don't support 'fv' type)
            if (type === 'ivec3')
                arrayLen *= 3
            var ar = new Array(arrayLen)
            for (var i=0; i<ar.length; i++)
                ar[i] = newInstance(type, isArray)
            return ar
        }  
        return newInstance(type)
    }

    function getType(type, isArray) {
        if (!isArray)
            return typeMap[type]

        if (type === 'int')
            return 'iv1'
        else if (type === 'float')
            return 'fv1'
        else
            return typeMap[type]+'v'
    }

    return function setupUniforms(glUniforms, colorNames) {
        if (!Array.isArray(colorNames))
            colorNames = Array.prototype.slice.call(arguments, 1)

        var result = {}
        var arrays = {}

        //map uniform types
        glUniforms.forEach(function(uniform) {
            var name = uniform.name
            var isArray = /(.+)\[[0-9]+\]/.exec(name)

            //special case: colors...
            if (colorNames && colorNames.indexOf(name) !== -1) {
                if (isArray)
                    throw new Error("array of color uniforms not supported")
                if (uniform.type !== 'vec3')
                    throw new Error("ThreeJS expects vec3 for Color uniforms") 
                result[name] = {
                    type: 'c',
                    value: new THREE.Color()
                }
                return
            }

            if (isArray) {
                name = isArray[1]
                if (name in arrays) 
                    arrays[name].count++ 
                else
                    arrays[name] = { count: 1, type: uniform.type }
            }
            result[name] = { 
                type: getType(uniform.type, isArray), 
                value: isArray ? null : defaultValue(uniform.type) 
            }
        })

        //now clean up any array values
        for (var k in result) {
            var u = result[k]
            if (k in arrays) { //is an array
                var a = arrays[k]
                u.value = defaultValue(a.type, true, a.count)
            }
        }
        return result
    }
}

module.exports = create
},{}],"/projects/blackice/node_modules/three-sdf-text/index.js":[function(require,module,exports){
module.exports = require('./lib/renderer')
},{"./lib/renderer":"/projects/blackice/node_modules/three-sdf-text/lib/renderer.js"}],"/projects/blackice/node_modules/three-sdf-text/lib/renderer.js":[function(require,module,exports){
var createText = require('gl-sprite-text')
var mat4 = {
    create: require('gl-mat4/create'),
    scale: require('gl-mat4/scale'),
    multiply: require('gl-mat4/multiply')
}

var modelTransform = mat4.create()
var flip = mat4.create()
mat4.scale(flip, flip, [1, -1, 1])

var WrapTexture = require('./texture-wrap')
var number = require('as-number')
var xtend = require('xtend')

var createShader = require('gl-shader-core')
var vertex = 'attribute vec4 position;\nattribute vec4 color;\nattribute vec2 texcoord0;\n\nuniform mat4 projection;\nuniform mat4 view;\nuniform mat4 model;\n\nvarying vec4 v_col;\nvarying vec2 v_tex0;\n\nvoid main() {\n gl_Position = projection * view * model * position;\n v_col = color;\n v_tex0 = texcoord0;\n gl_PointSize = 1.0;\n}'
var fragment = '#ifdef GL_ES\nprecision mediump float;\n#endif\n\nvarying vec4 v_col;\nvarying vec2 v_tex0;\nuniform sampler2D texture0;\n\nuniform float smoothing;\n// = 1.0/32.0;\n\n// drop shadow computed in fragment shader\nvoid main() {\n vec4 texColor = texture2D(texture0, v_tex0);\n\n float dst = texColor.a;\n float alpha = smoothstep(0.5 - smoothing, 0.5 + smoothing, dst);\n vec4 base = v_col * vec4(alpha);\n\n gl_FragColor = base;\n if (gl_FragColor.a<0.1)\n discard;\n}'

var uniforms = [
        { type: 'float', name: 'smoothing' },
        { type: 'sampler2D', name: 'texture0' },
        { type: 'mat4', name: 'projection' },
        { type: 'mat4', name: 'view' },
        { type: 'mat4', name: 'model' }        
    ],
    attributes = [
        { type: 'vec4', name: 'position' },
        { type: 'vec4', name: 'color' },
        { type: 'vec2', name: 'texcoord0' }
    ]



function copyColor(out, color, opacity) {
    out[0] = color.r
    out[1] = color.g 
    out[2] = color.b 
    out[3] = opacity
}

module.exports = function(THREE) {
    var sharedShader

    function TextRenderer(renderer, opt) {
        if (!(this instanceof TextRenderer))
            return new TextRenderer(renderer, opt)
        opt=opt||{}

        var gl = renderer.getContext()
        this.gl = gl
        this.color = new THREE.Color()
        if (opt.color !== null && typeof opt.color !== 'undefined')
            this.color.set(opt.color)
        this.opacity = number(opt.opacity, 1.0)

        //if no textures are given, presume they are base64 packed
        //into the Font object (like with bmfont-lato)
        var textOpts = xtend(opt)
        if (textOpts.textures) {
            textOpts.textures = textOpts.textures.map(function(tex) {
                // return require('gl-texture2d')(gl, tex.image)
                if (tex instanceof THREE.Texture)
                    return WrapTexture(renderer, tex)
                return tex
            })
        }
        
        this.element = createText(gl, textOpts)
        this.transform = mat4.create()

        if (!sharedShader && !opt.shader)
            sharedShader = createShader(gl, vertex, fragment, uniforms, attributes)
        this.shader = opt.shader || sharedShader
        this.shader.bind()

        this.padding = number(opt.padding, 0)

        var s = number(opt.smoothing, 1.0/32.0)
        this.shader.uniforms.smoothing = s
        this.shader.uniforms.texture0 = 0
    }

    TextRenderer.prototype.draw = function(camera, object) {
        var gl = this.gl

        if (!object.visible)
            return

        if (!this.element.textures || this.element.textures.length === 0)
            return

        gl.enable(gl.BLEND)
        // gl.bindFramebuffer(gl.FRAMEBUFFER, null)

        gl.enable(gl.DEPTH_TEST)
        gl.depthFunc(gl.LEQUAL)

        // gl.frontFace( gl.CCW )    
        gl.enable(gl.CULL_FACE)
        // gl.cullFace( gl.FRONT )
        gl.colorMask(true, true, true, true)
        gl.disable(gl.STENCIL_TEST)
        gl.activeTexture(gl.TEXTURE0)
        gl.depthMask(true)
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA)

        this.shader.bind()
        this.element.textures[0].bind(0)

        // gl.colorMask(true, true, true, true)

        gl.cullFace(gl.FRONT)

        mat4.multiply(modelTransform, object.matrixWorld.elements, this.transform)
        mat4.multiply(modelTransform, modelTransform, flip)

        this.shader.bind()
        this.shader.uniforms.projection = camera.projectionMatrix.elements
        this.shader.uniforms.view = camera.matrixWorldInverse.elements
        this.shader.uniforms.model = modelTransform
            
        copyColor(this.element.batch.color, this.color, this.opacity)
        this.element.draw(this.shader, this.padding, this.padding)

        gl.cullFace( gl.BACK )
    }


    return TextRenderer
}
},{"./texture-wrap":"/projects/blackice/node_modules/three-sdf-text/lib/texture-wrap.js","as-number":"/projects/blackice/node_modules/three-sdf-text/node_modules/as-number/index.js","gl-mat4/create":"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-mat4/create.js","gl-mat4/multiply":"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-mat4/multiply.js","gl-mat4/scale":"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-mat4/scale.js","gl-shader-core":"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-shader-core/shader-core.js","gl-sprite-text":"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/index.js","xtend":"/projects/blackice/node_modules/three-sdf-text/node_modules/xtend/immutable.js"}],"/projects/blackice/node_modules/three-sdf-text/lib/texture-wrap.js":[function(require,module,exports){
// in time this will be replaced with a solution
// that better supported ThreeJS Texture objects


function TextureWrap(renderer, tex) {
    if (!(this instanceof TextureWrap))
        return new TextureWrap(renderer, tex)
    this.renderer = renderer
    this.texture = tex
    this._shape = [0, 0]
}

TextureWrap.prototype.bind = function(unit) {
    updateSize(this._shape, this.texture)


    var gl = this.renderer.getContext()
    this.renderer.setTexture(this.texture, unit|0)
    
    gl.bindTexture(gl.TEXTURE_2D, this.texture.__webglTexture)
}

Object.defineProperty(TextureWrap.prototype, "shape", {

    get: function() {
        updateSize(this._shape, this.texture)
        return this._shape
    }
})

function updateSize(shape, texture) {
    shape[0] = (texture.image && texture.image.width)  |0
    shape[1] = (texture.image && texture.image.height) |0
}

module.exports = TextureWrap
},{}],"/projects/blackice/node_modules/three-sdf-text/node_modules/as-number/index.js":[function(require,module,exports){
module.exports=require("/projects/blackice/node_modules/as-number/index.js")
},{"/projects/blackice/node_modules/as-number/index.js":"/projects/blackice/node_modules/as-number/index.js"}],"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-mat4/create.js":[function(require,module,exports){
module.exports = create;

/**
 * Creates a new identity mat4
 *
 * @returns {mat4} a new 4x4 matrix
 */
function create() {
    var out = new Float32Array(16);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
};
},{}],"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-mat4/multiply.js":[function(require,module,exports){
module.exports=require("/projects/blackice/node_modules/gl-mat4/multiply.js")
},{"/projects/blackice/node_modules/gl-mat4/multiply.js":"/projects/blackice/node_modules/gl-mat4/multiply.js"}],"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-mat4/scale.js":[function(require,module,exports){
module.exports=require("/projects/blackice/node_modules/gl-mat4/scale.js")
},{"/projects/blackice/node_modules/gl-mat4/scale.js":"/projects/blackice/node_modules/gl-mat4/scale.js"}],"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-shader-core/shader-core.js":[function(require,module,exports){
module.exports=require("/projects/blackice/node_modules/glslify/node_modules/gl-shader-core/shader-core.js")
},{"/projects/blackice/node_modules/glslify/node_modules/gl-shader-core/shader-core.js":"/projects/blackice/node_modules/glslify/node_modules/gl-shader-core/shader-core.js"}],"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/index.js":[function(require,module,exports){
var Base = require('fontpath-simple-renderer')
var inherits = require('inherits')
var bmfont2fontpath = require('fontpath-bmfont')
var texcoord = require('texcoord')
var xtend = require('xtend')
var createTexture = require('gl-texture2d')

var Batch = require('gl-sprite-batch')

var tmpPos = [0, 0],
    tmpShape = [0, 0],
    tmp1 = [0, 0],
    tmp2 = [0, 0]
var DEFAULT_TEXCOORD = [0, 0, 1, 1]
var maxInitialCapacity = 500

function texcoordGlyph(glyph, atlas, out) {
    tmp1[0] = glyph.x
    tmp1[1] = glyph.y
    tmp2[0] = glyph.width
    tmp2[1] = glyph.height
    return texcoord(tmp1, tmp2, atlas, out)
}

function TextRenderer(gl, opt) {
    if (!(this instanceof TextRenderer))
        return new TextRenderer(gl, opt)
    opt = opt||{}

    if (!opt.font) 
        throw new Error('must specify bmfont at creation time')

    //if the font has Image/ndarray array
    if (!opt.textures && Array.isArray(opt.font.images)) {
        opt.textures = opt.font.images.map(function(img) {
            return createTexture(gl, img)
        })
    }

    opt.font = bmfont2fontpath(opt.font)

    Base.call(this, opt)

    this.textures = opt.textures || []
    this.gl = gl
    if (!gl)
        throw new Error("must specify gl context")
    
    //assume text will be used dynamically 
    if (typeof opt.dynamic !== 'boolean')
        opt.dynamic = true

    var batch = opt.batch
    if (!batch)
        this.defaultBatch = Batch(gl, opt)
    this.batch = batch || this.defaultBatch

    if (typeof opt.wrapWidth !== 'number')
        this.layout()
}

inherits(TextRenderer, Base)

TextRenderer.prototype.dispose = function(textures) {
    if (this.defaultBatch)
        this.defaultBatch.dispose()
    if (textures) {
        this.textures.forEach(function(t) {
            if (typeof t.dispose === 'function')
                t.dispose()
        })
    }
    return this
}

TextRenderer.prototype.uncache = function() {
    this._cache = false
    this.batch.clear()
    return this
}

TextRenderer.prototype.cache = function(x, y, start, end) {
    // if (this.underline || this.font.pages.length > 1)
    //     throw new Error('currently cached text does not support underlines or multiple texture pages')
    
    this._cache = true
    this.batch.ensureCapacity(this.text.length)
    this.batch.clear()
    this._build(x, y, start, end)
    return this
}

TextRenderer.prototype.draw = function(shader, x, y, start, end) {
    var batch = this.batch
    batch.bind(shader)

    //if we're drawing dynamically
    if (!this._cache) {
        batch.clear()
        this._build(x, y, start, end)
    }
    
    batch.draw()
    batch.unbind()
    return this
}

TextRenderer.prototype._build = function(x, y, start, end) {
    var result = this.render(x, y, start, end)

    var batch = this.batch
    var i = 0
    
    //underlines currently not supported with cache()
    if (!this._cache) {
        batch.texcoord = DEFAULT_TEXCOORD
        batch.texture = null

        for (i = 0; i < result.underlines.length; i++) {
            var underline = result.underlines[i]
            batch.position = underline.position
            batch.shape = underline.size
            batch.push()
        }
    }

    //now draw our glyphs into the batch...
    for (i = 0; i < result.glyphs.length; i++) {
        var g = result.glyphs[i]
        this._drawGlyph(batch, g)
    }
}

TextRenderer.prototype._drawGlyph = function(batch, data) {
    //... we could sort these by texture page to reduce draws
    var glyph = data.glyph
    var img = this.textures[glyph.page]
    tmpPos[0] = data.position[0]+glyph.hbx
    tmpPos[1] = data.position[1]+glyph.hby - this.font.descender
    tmpShape[0] = glyph.width * data.scale[0]
    tmpShape[1] = glyph.height * data.scale[1]
    
    batch.texture = img
    texcoordGlyph(glyph, img && img.shape, batch.texcoord)
    batch.position = tmpPos
    batch.shape = tmpShape
    batch.push()
}

module.exports = TextRenderer
},{"fontpath-bmfont":"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/fontpath-bmfont/index.js","fontpath-simple-renderer":"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/fontpath-simple-renderer/index.js","gl-sprite-batch":"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/index.js","gl-texture2d":"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-texture2d/texture.js","inherits":"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/inherits/inherits_browser.js","texcoord":"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/texcoord/index.js","xtend":"/projects/blackice/node_modules/three-sdf-text/node_modules/xtend/immutable.js"}],"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/fontpath-bmfont/index.js":[function(require,module,exports){
function glyph(data) {
    return {
        page: data.page,
        hbx: data.xoffset,
        hby: data.yoffset,
        width: data.width,
        height: data.height,
        xoff: data.xadvance,
        x: data.x,
        y: data.y
    }
}

function glyphs(chars) {
    var out = {}
    chars.forEach(function(c) {
        out[String.fromCharCode(c.id)] = glyph(c)
    })
    return out
}

module.exports = function(bmfont) {
    return {
        pages: bmfont.pages,
        resolution: 72,
        size: bmfont.info.size,
        units_per_EM: 1,
        bitmap: true,
        family_name: bmfont.info.face,
        height: bmfont.common.lineHeight,
        descender: bmfont.common.base,
        ascender: bmfont.common.base,
        glyphs: glyphs(bmfont.chars),
        kerning: bmfont.kernings.map(function(k) {
            return [String.fromCharCode(k.first),String.fromCharCode(k.second),k.amount]
        })
    }
}
},{}],"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/fontpath-simple-renderer/index.js":[function(require,module,exports){
var Base = require('fontpath-renderer')
var inherits = require('inherits')

//TODO: Eventually lots of this code will just replace fontpath-renderer...

function FontpathRenderer(options) {
    if (!(this instanceof FontpathRenderer))
        return new FontpathRenderer(options)
    Base.call(this, options)

    this.data = {
        glyphs: [],
        underlines: []
    }
}

inherits(FontpathRenderer, Base)

FontpathRenderer.prototype.renderGlyph = function(i, glyph, scale, x, y) {
    this.data.glyphs.push(new Glyph(i, glyph, 
                this.text.charCodeAt(i), 
                [ scale, this.font.bitmap ? scale : -scale ],
                [ x, y ]))
}

FontpathRenderer.prototype.renderUnderline = function(x, y, width, height) {
    this.data.underlines.push(new Underline(
        [ x, y ],
        [ width, height ]
    ))
}

FontpathRenderer.prototype.render = function(x, y, start, end) {
    //new data for result
    this.data.glyphs.length = 0
    this.data.underlines.length = 0
    Base.prototype.render.call(this, x, y, start, end)
    return this.data
}

function Glyph(index, glyph, charCode, scale, position) {
    this.glyph = glyph
    this.index = index
    this.charCode = charCode
    this.position = position
    this.scale = scale
}

function Underline(position, size) {
    this.position = position
    this.size = size
}

module.exports = FontpathRenderer
},{"fontpath-renderer":"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/fontpath-simple-renderer/node_modules/fontpath-renderer/index.js","inherits":"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/inherits/inherits_browser.js"}],"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/fontpath-simple-renderer/node_modules/fontpath-renderer/index.js":[function(require,module,exports){
var GlyphIterator = require('fontpath-glyph-iterator');
var WordWrap = require('fontpath-wordwrap');

var tmpBounds = { x: 0, y: 0, width: 0, height: 0, glyphs: 0 };

function TextRenderer(options) {
    if (!(this instanceof TextRenderer))
        return new TextRenderer(options);
    options = options||{}

    this.iterator = new GlyphIterator(options.font, options.fontSize);
    this.wordwrap = new WordWrap();

    this.align = 'left';
    this.underline = false;

    this.underlineThickness = undefined;
    this.underlinePosition = undefined;
    this._text = "";

    if (typeof options.align === 'string')
        this.align = options.align;
    if (typeof options.underline === 'boolean')
        this.underline = options.underline;
    if (typeof options.underlineThickness === 'number')
        this.underlineThickness = options.underlineThickness;
    if (typeof options.underlinePosition === 'number')
        this.underlinePosition = options.underlinePosition;
    if (typeof options.text === 'string')
        this.text = options.text;
    if (typeof options.lineHeight === 'number')
        this.lineHeight = options.lineHeight;
    if (typeof options.letterSpacing === 'number')
        this.letterSpacing = options.letterSpacing;
    if (typeof options.wrapMode === 'string')
        this.wordwrap.mode = options.wrapMode;
    if (typeof options.wrapWidth === 'number')
        this.layout(options.wrapWidth);
}

//Internally we will use integers to avoid string comparison for each glyph
var LEFT_ALIGN = 0, CENTER_ALIGN = 1, RIGHT_ALIGN = 2;
var ALIGN_ARRAY = [
    'left', 
    'center', 
    'right'
];
    
Object.defineProperties(TextRenderer.prototype, {
    /**
     * If the new font differs from the last, the text layout is cleared
     * and placed onto a single line. Users must manually re-layout the text 
     * for word wrapping.
     */
    "font": {
        get: function() {
            return this.iterator.font;
        },
        set: function(val) {
            var oldFont = this.iterator.font;
            this.iterator.font = val;
            if (oldFont !== this.iterator.font)
                this.clearLayout();
        },
    },

    /**
     * If the new font size differs from the last, the text layout is cleared
     * and placed onto a single line. Users must manually re-layout the text 
     * for word wrapping.
     */
    "fontSize": {
        get: function() {
            return this.iterator.fontSize;
        },
        set: function(val) {
            var oldSize = this.iterator.fontSize;

            this.iterator.fontSize = val;

            if (oldSize !== this.iterator.fontSize)
                this.clearLayout();
        },
    },
    "lineHeight": {
        get: function() {
            return this.iterator.lineHeight;
        },
        set: function(val) {
            this.iterator.lineHeight = val;
        },
    },
    "letterSpacing": {
         get: function() {
            return this.iterator.letterSpacing;
        },
        set: function(val) {
            this.iterator.letterSpacing = val;
        },
    },

    /**
     * If the new text is different from the last, the layout (i.e. word-wrapping)
     * is cleared and the result is a single line of text (similar to HTML5 canvas text
     * rendering).
     * 
     * The text then needs to be re-wordwrapped with a call to `layout()`.
     */
    "text": {
        get: function() {
            return this._text;
        },

        set: function(text) {
            text = text||"";

            var old = this._text;
            this._text = text;
            this.wordwrap.text = this.text;

            if (this._text !== old) 
                this.clearLayout();
        }
    }
});

/**
 * Clears the text layout and word-wrapping, placing all of it on a single line.
 */
TextRenderer.prototype.clearLayout = function() {
    this.wordwrap.text = this.text;
    this.wordwrap.empty();

    if (this.iterator.font) //font might not have been passed at constructor
        this.wordwrap.clearLayout(this.iterator);
};

/**
 * Calls the word wrapper to layout the current text string,
 * based on the wrap width and any current wordwrapping options.
 *
 * This is called when the text is changed. 
 * 
 * @return {[type]} [description]
 */
TextRenderer.prototype.layout = function(wrapWidth) {
    this.wordwrap.text = this.text;
    this.wordwrap.empty();
    this.wordwrap.layout(this.iterator, wrapWidth);
};

/**
 * "Renders" this glyph at the given location. This may involve filling
 * a VBO with vertex data, or it may be a direct call to draw a bitmap glyph
 * or shape outline.
 * @return {[type]} [description]
 */
TextRenderer.prototype.renderGlyph = function() {

};

TextRenderer.prototype.renderUnderline = function() {

};

/**
 * Returns the bounds of the current text layout. 
 *
 * The height does not extend past the baseline of the
 * last line; unless `includeUnderline` is true, in which
 * case the underline's position and height is included
 * in the calculation. 
 *
 * The bounding y position is offset so that the box has an upper-left
 * origin, for parity with HTML5 canvas rendering.
 * 
 * @param {Boolean} includeUnderline whether to include the underline in the calculation, default false
 * @param {Object} out an optional {width, height} object for re-use
 * @return {Object} a size with { width, height } properties
 */
TextRenderer.prototype.getBounds = function (includeUnderline, out) {
    if (!out)
        out = { x: 0, y: 0, width: 0, height: 0 };

    var wordwrapper = this.wordwrap;
    var itr = this.iterator;

    //tighten the bounding box around the first line..
    var firstLineHeight = 0;
    if (wordwrapper.lines.length > 0) {
        var firstLine = wordwrapper.lines[0];
        itr.getBounds(this.text, firstLine.start, firstLine.end, undefined, tmpBounds);
        firstLineHeight = tmpBounds.height;
    }

    out.width = wordwrapper.getMaxLineWidth();   
    out.height = Math.max(0, wordwrapper.lines.length-1) * itr.getLineGap() + firstLineHeight;

    out.x = 0;
    out.y = -out.height;

    if (includeUnderline) {
        var underlineHeight = this.computeUnderlineHeight();
        var underlinePosition = this.computeUnderlinePosition();
        var underlineOff = underlinePosition+underlineHeight/2;
        out.height += underlineOff;
    }

    return out;
};

/**
 * Computes the scaled underline height as pixels, based on 
 * the explicit `underlineHeight` (in pixels). If `underlineHeight` is
 * undefined or null, it will try to use the font's non-zero underline height, 
 * otherwise default to 1/8 of the font's EM square.
 * 
 * @return {Number} the pixel height of the underline 
 */
TextRenderer.prototype.computeUnderlineHeight = function () {
    var font = this.font;
    var scale = this.iterator.fontScale;
    if (this.underlineThickness===0||this.underlineThickness) {
        return this.underlineThickness; 
    } else if (font.underline_thickness) {
        return font.underline_thickness * scale; 
    } else if (font.bitmap)
        return font.size/8;
    else
        return (font.units_per_EM/8)*scale;
};

/**
 * Computes the scaled underline height as pixels, based on 
 * the explicit `underlinePosition` (in pixels). If `underlinePosition` is
 * undefined or null, it will try to use the font's non-zero underline position, 
 * otherwise default to 1/4 of the font's EM square.
 *
 * This is the Y offset from the text baseline to the center of the underline 
 * bar, in pixels. It is generally a positive value.
 * 
 * @return {Number} the pixel position of the underline 
 */
TextRenderer.prototype.computeUnderlinePosition = function () {
    var font = this.font;
    var scale = this.iterator.fontScale;
        
    if (this.underlinePosition===0||this.underlinePosition) {
        return this.underlinePosition; 
    } else if (font.underline_position) {
        return -font.underline_position * scale; 
    } else if (font.bitmap) {
        return font.size/4;
    } else {
        return (font.units_per_EM/4)*scale;
    }
};

/**
 * Gets the descent of the current font (assumes its size 
 * is already set). This is an absolute (positive) value.
 * 
 * @return {[type]} [description]
 */
TextRenderer.prototype.getDescender = function () {
    return Math.abs(this.iterator.fontScale * this.iterator.font.descender);
};

/**
 * Gets the descent of the current font (assumes its size 
 * is already set). This is an absolute (positive) value.
 * 
 * @return {[type]} [description]
 */
TextRenderer.prototype.getAscender = function () {
    return Math.abs(this.iterator.fontScale * this.iterator.font.ascender);
};

//Signals for subclasses to optionally implmeent
//This may be useful to stop/start paths with different fills
TextRenderer.prototype.onBegin = function() { }
TextRenderer.prototype.onEnd = function() { }
TextRenderer.prototype.onBeginLine = function(lineIndex) { }
TextRenderer.prototype.onEndLine = function(lineIndex) { }

/**
 * Renders the current text layout, where lower-left is 
 * the origin. Multiple lines will be positioned above the
 * origin.
 */
TextRenderer.prototype.render = function (x, y, start, end) {
    x = x||0;
    y = y||0;

    var text = this.text;
    var wordwrapper = this.wordwrap;

    //if we have nothing to draw
    if (!text || wordwrapper.lines.length === 0)
        return;

    //default start/end params
    start = start||0;
    end = typeof end === "number" ? end : text.length;

    var itr = this.iterator;
    var scale = itr.fontScale;
    var font = itr.font;
    var underline = this.underline;

    //used for alignment...
    var maxLineWidth = wordwrapper.getMaxLineWidth();
    
    y -= Math.max(0, wordwrapper.lines.length-1) * itr.getLineGap();


    //use numbers to avoid str compare for each glyph
    var alignType = ALIGN_ARRAY.indexOf(this.align||"");
    if (alignType===-1)
        alignType = LEFT_ALIGN;

    var underlineX = 0;
    var underlineStartX = 0;
    var underlineY = 0;
    var underlineWidth = 0;

    var underlineStarted = false;

    //Try to use user-specified underline settings, otherwise use the font if possible,
    //otherwise just use a rough default based on EM square.    
    var underlinePos = this.computeUnderlinePosition();
    var underlineHeight = this.computeUnderlineHeight();

    this.onBegin();
    
    //set the origin and pen position
    itr.begin(x, y);
    for (var k=0; k<wordwrapper.lines.length; k++) {
        var line = wordwrapper.lines[k];
        underlineStarted = false;

        var lastAdvance = 0;

        var lineX = itr.pen.x;
        var lineY = itr.pen.y;

        this.onBeginLine(k);

        //TODO: use multiple Nodes inside a single line
        //a node will have attributes like font, size, color, 
        //letter-spacing, underline, etc.
        //This will affect the line height, as it will have to be the max of all nodes.

        for (var i=line.start; i<line.end; i++) {
            var chr = text.charAt(i);

            //Step the iterator, moving forward based on kerning from last char
            var glyph = itr.step(text, i);

            if (!glyph)
                continue;

            //within desired range
            if (i >= start && i < end) {
                var tx = itr.pen.x;
                var ty = itr.pen.y;

                if (alignType === CENTER_ALIGN) {
                    tx += (maxLineWidth-line.width)/2;
                } else if (alignType === RIGHT_ALIGN) {
                    tx += (maxLineWidth-line.width);
                }

                if (!underlineStarted) {
                    underlineX = tx;
                    underlineStartX = tx;
                    underlineY = ty + underlinePos;
                    underlineWidth = 0;
                    underlineStarted = true;
                } else {
                    underlineWidth = tx - underlineStartX;
                }

                this.renderGlyph(i, glyph, scale, tx, ty);
            }

            //Advance the iterator to the next glyph in the string
            var newAdvance = itr.advance(glyph);

            if (i >= start && i < end)
                lastAdvance = newAdvance;
        }

        this.onEndLine(k);

        if (underline) {
            underlineWidth += lastAdvance;
            this.renderUnderline(underlineX, underlineY-underlineHeight/2, underlineWidth, underlineHeight);
        }
        
        //Steps down a line...
        if (k < wordwrapper.lines.length-1) {
            itr.advanceLine();
        }
    }

    //finish the iterator...
    itr.end();
    this.onEnd();
};

module.exports = TextRenderer;
},{"fontpath-glyph-iterator":"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/fontpath-simple-renderer/node_modules/fontpath-renderer/node_modules/fontpath-glyph-iterator/index.js","fontpath-wordwrap":"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/fontpath-simple-renderer/node_modules/fontpath-renderer/node_modules/fontpath-wordwrap/index.js"}],"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/fontpath-simple-renderer/node_modules/fontpath-renderer/node_modules/fontpath-glyph-iterator/index.js":[function(require,module,exports){
var util = require('fontpath-util');

var DEFAULT_TAB_WIDTH = 4;

function GlyphIterator(font, fontSize) {
    this._fontSize = undefined;
    this._fontScale = undefined;
    this._font = undefined;
    this.fontScale = 1.0;
    this.kerning = true;
    this.letterSpacing = 0;
    this.lineHeight = undefined;
    
    this.fontSize = typeof fontSize === 'number'
            ? fontSize
            : (font ? font.size : undefined);
    this.font = font;

    //Number of spaces for a tab character
    this.tabWidth = DEFAULT_TAB_WIDTH;
    this._tabGlyph = null;

    this.origin = { x: 0, y: 0 };
    this.pen = { x: 0, y: 0 };
}

Object.defineProperty(GlyphIterator.prototype, "font", {
    get: function() {
        return this._font;
    },

    set: function(font) {
        this._font = font;

        //Determine the new scaling factor...
        if (font) {
            this.fontScale = util.getPxScale(font, this.fontSize);

            //Updates the tab glyph
            this.tabWidth = this._tabWidth;
        }
    },
});

//There might be a better way of handling tab width using FreeType ? 
Object.defineProperty(GlyphIterator.prototype, "tabWidth", {

    get: function() {
        return this._tabWidth;
    },

    set: function(val) {
        this._tabWidth = val===0 || val ? val : DEFAULT_TAB_WIDTH;
        this._tabGlyph = {};

        var spaceGlyph = this.font ? this.font.glyphs[" "] : null;
        if (spaceGlyph) {
            this._tabGlyph = {};
            for (var k in spaceGlyph) {
                this._tabGlyph[k] = spaceGlyph[k];
            }
            if (this._tabGlyph.xoff)
                this._tabGlyph.xoff *= this._tabWidth;
        }
    },
});

Object.defineProperty(GlyphIterator.prototype, "fontSize", {
    get: function() {
        if (typeof this._fontSize !== 'number')
            return this.font.bitmap 
                ? this.font.size 
                : util.pointToPixel(this.font.size)
        return this._fontSize;
    },

    set: function(val) {
        this._fontSize = val;

        //If the font is already set, determine the new scaling factor
        if (this._font) {
            this.fontScale = util.getPxScale(this._font, this._fontSize);
        }
    },
});

GlyphIterator.prototype.getKerning = function(left, right) {
    var font = this.font;

    if (!font || !font.kerning)
        return 0;

    var table = this.kerningTable;

    for (var i=0; i<font.kerning.length; i++) {
        var k = font.kerning[i];
        if (k[0] === left && k[1] === right) 
            return k[2];
    }
    return 0;
};

GlyphIterator.prototype.begin = function(x, y) {
    this.origin.x = x||0;
    this.origin.y = y||0;

    this.pen.x = this.origin.x;
    this.pen.y = this.origin.y;
};

GlyphIterator.prototype.end = function() {
    //.. mainly for consistency with begin()
    //Might be useful later on
};

GlyphIterator.prototype.getLineGap = function() {
    //Line height handling is a mess in browsers.
    //Maybe the best solution is to encourage users to 
    //specify pixel line heights if they want to match browser standards,
    //otherwise it's unreasonable to expect the line gaps to line up exactly
    //across all browsers. Example of the disaster:
    //http://lists.w3.org/Archives/Public/www-style/2008Jan/0413.html

    //For reference, some baseline-to-baseline calculations:
    //http://www.microsoft.com/typography/otspec/recom.htm
    //freetype.org/freetype2/docs/reference/ft2-base_interface.html
    //http://www.freetype.org/freetype2/docs/glyphs/glyphs-3.html

    //Unfortunately none of these are producing line-heights that avoid overlapping
    //or resemble browser rendering in any way. 

    // If CSS uses 1em or 1, the browser offsets the line by the 
    // font's pixel size. If an exact pixel line-height is specified,
    // the browser will use that + a computed "linegap." 
    // If 'auto' is specified for line-height, the calculations seem
    // much more complex and browser/platform dependent (not included here).
    
    var font = this.font,
        scale = this.fontScale;
    var gap = (font.height - font.ascender + Math.abs(font.descender)) * scale;    
    var lineHeight = this.lineHeight;
    
    lineHeight = (lineHeight===0||lineHeight) 
            ? (lineHeight + gap)
            : this.fontSize;
    return lineHeight;
};

GlyphIterator.prototype.translate = function(x, y) {
    this.origin.x += x||0;
    this.origin.y += y||0;

    this.pen.x += x||0;
    this.pen.y += y||0;
};

GlyphIterator.prototype.step = function(text, index) {
    var scale = this.fontScale,
        font = this._font;

    var chr = text.charAt(index); 

    if (chr === '\t' && this._tabGlyph) {
        return this._tabGlyph;
    }

    //Skip missing characters...
    if (!(chr in font.glyphs))
        return;
    
    var glyph = font.glyphs[chr];

    //If we have a char to the left, determine its kerning
    if (index > 0 && this.kerning) {
        var kern = this.getKerning(text.charAt(index-1), chr);
        this.pen.x += (kern*scale);
    }

    return glyph;
};

GlyphIterator.prototype.advanceLine = function() {
    this.pen.y += this.getLineGap();
    this.pen.x = this.origin.x;
};

/**
 * Called after step. 
 */
GlyphIterator.prototype.advance = function(glyph) {
    var advance = (glyph.xoff * this.fontScale);
    // Advance to next pen position
    this.pen.x += advance + this.letterSpacing;
    return advance;
};

/**
 * This is a utility function that provides the bounds of the given
 * text (from start and end positions) as if they were laid out horizontally,
 * left to right.
 *
 * For convenience, this will not alter the current pen and origin positions.
 * This way it can be utilized inside a glyph iteration (i.e. for rendering).
 *
 * If `availableWidth` is specified, this will break before reaching the specified
 * pixel width, to ensure that all glyphs will fit inside the bounds. 
 *
 * The return object also includes a `glyphs` property, which is the number of glyphs
 * that are visible within the returned bounds. 
 *
 * If `out` is specified (an object with x, y, width, height, and glyph properties),
 * it will be re-used. Otherwise a new object is created.
 * 
 * @param {String} text the text to check
 * @param {Number} start the start position, defaults to 0
 * @param {Number} end the end position, exclusive, defaults to text length
 * @param {Number} availableWidth the width before stopping the bound check
 * @param {Object} out an object to re-use for the return value
 * @return {Object} the bounds and glyph count {x,y,width,height,glyphs}
 */
GlyphIterator.prototype.getBounds = function(text, start, end, availableWidth, out) {
    if (!out)
        out = { x:0, y:0, width: 0, height: 0, glyphs: 0 };

    var checkWidth = availableWidth===0||availableWidth;

    start = start||0;
    end = end===0||end ? end : text.length;

    var maxHeight = 0;

    out.x = 0;
    out.y = 0;
    out.glyphs = 0;

    var oldPenX = this.pen.x,
        oldPenY = this.pen.y,
        oldOriginX = this.origin.x,
        oldOriginY = this.origin.y;


    var font = this.font;
    this.begin();
    for (var i=start; i<end; i++) {
        var chr = text.charAt(i);

        //step the iterator
        var glyph = this.step(text, i);

        //if the glyph is valid, we can advance past it and calculate new height
        if (glyph) {
            var height = (glyph.height)*this.fontScale;

            out.y = Math.max(out.y, this.fontScale*(glyph.height-glyph.hby));

            maxHeight = Math.max(maxHeight, height);
            var lastAdvance = this.advance(glyph);

            //if we're past the available width
            var newWidth = this.pen.x - this.origin.x;
            if (checkWidth && (newWidth - availableWidth > 0.001)) {
                this.pen.x -= lastAdvance;
                break;
            }

            out.glyphs++;
        }
    }
    this.end();

    out.width = this.pen.x - this.origin.x;
    out.height = maxHeight;

    this.pen.x = oldPenX;
    this.pen.y = oldPenY;
    this.origin.x = oldOriginX;
    this.origin.y = oldOriginY;

    return out;
};

module.exports = GlyphIterator;
},{"fontpath-util":"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/fontpath-simple-renderer/node_modules/fontpath-renderer/node_modules/fontpath-util/index.js"}],"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/fontpath-simple-renderer/node_modules/fontpath-renderer/node_modules/fontpath-util/index.js":[function(require,module,exports){
// module.exports.pointsToPixels = function(pointSize, resolution) {
// 	resolution = typeof resolution === "number" ? resolution : 72;
// 	return pointSize * resolution / 72;
// };

// module.exports.coordToPixel = function(coord, pixelSize, emSize) {
// 	emSize = typeof emSize === "number" ? emSize : 2048;
// 	return coord * pixelSize / emSize;
// };

/**
 * Converts a pt size to px size, namely useful for matching
 * size with CSS styles. If no DPI is specified, 96 is assumed
 * (as it leads to correct rendering in all browsers).
 * 
 * @param  {Number} fontSize the desired font size in points
 * @param  {Number} dpi      the expected DPI, generally 96 for browsers
 * @return {Number}          the rounded pixel font size
 */
module.exports.pointToPixel = function(fontSize, dpi) {
    dpi = dpi||dpi===0 ? dpi : 96;
    fontSize = fontSize * dpi / 72;
    return Math.round(fontSize);
};

/**
 * For the given font and (pixel) font size, this method returns the
 * scale that will need to be applied to EM units (i.e. font paths) 
 * to have the font render at the expected size (i.e. to match the browser).
 *
 * If no font size is specified, we will use the default font size (which is in points)
 * and convert it to pixels. 
 * 
 * @param  {Font} font     a font object from the fontpath tool
 * @param  {Number} fontSize the desired font size, defaults to the font's default size
 * @return {Number} returns the scale for this font size         
 */
module.exports.getPxScale = function(font, fontSize) {
    if (font.bitmap)
        return 1.0;

    //If no fontSize is specified, it will just fall back to using the font's own size with 96 DPI.
    fontSize = typeof fontSize === "number" ? fontSize : this.pointToPixel(font.size);

    //Takes in a font size in PIXELS and gives us the expected scaling factor
    var sz = font.units_per_EM/64;
    sz = (sz/font.size * fontSize);

    return ((font.resolution * 1/72 * sz) / font.units_per_EM);
};

/**
 * For the given font and (point) font size, this method returns the
 * scale that will need to be applied to EM units (i.e. font paths) 
 * to have the font render at the expected size (i.e. to match the browser).
 * 
 * If no font size is specified, we will use the default font size.
 * 
 * @param  {Font} font       a font object from the fontpath tool
 * @param  {Number} fontSize the desired font size, defaults to the font's default size
 * @return {Number}          the scale for this font size
 */
module.exports.getPtScale = function(font, fontSize) {
    fontSize = typeof fontSize === "number" ? fontSize : font.size;
    fontSize = this.pointToPixel(fontSize);
    return this.getPxScale(font, fontSize);
};

},{}],"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/fontpath-simple-renderer/node_modules/fontpath-renderer/node_modules/fontpath-wordwrap/index.js":[function(require,module,exports){
var tmpBounds = { x: 0, y: 0, width: 0, height: 0, glyphs: 0 };

function isWhitespace(chr) {
	return chr===' '
		|| chr==='\n'
		|| chr==='\r'
		|| chr==='\t';
}

function idxOf(text, chr, start, end) {
	var idx = text.indexOf(chr, start);
	if (idx === -1 || idx > end)
		return end;
	return idx;
}

function WordWrap(text) {
	/**
	 * The text being operated on.
	 * @param {String} text
	 */
	this.text = text||"";

	/**
	 * An array of lines representing the state of this word wrapper.
	 * @param {Array} lines
	 */
	this.lines = [];

	/** 
	 * The newline character to break on, default '\n'
	 * @param {String} newline
	 */
	this.newline = '\n';

	/**
	 * Whether to clip non-breaking text (nowrap and pre)
	 * if the wrapWidth is too small. 
	 *  
	 * @param {Boolean} clip
	 */
	this.clip = false;

	/**
	 * The mode for wordwrapping: 'pre', 'normal', or 'nowrap'.
	 *
	 * You can also use the `PRE`, `NORMAL`, and `NOWRAP` constants
	 * in `WordWrap.Mode`.
	 * 
	 * @param {String} mode
	 */
	this.mode = WordWrap.Mode.NORMAL;
}

WordWrap.Mode = {
	PRE: 'pre',       //whitespace isn't collapsed
	NORMAL: 'normal', //whitespace is collapsed
	NOWRAP: 'nowrap'  //only break on '\n'
};

/**
 * Clears any multi-line layout by placing all the text in a single Line object.
 * 
 * @param {GlyphIterator} iterator the iterator to use 
 * @method  clearLayout
 */
WordWrap.prototype.clearLayout = function(iterator) {
	this.lines.length = 0;
	
	if (this.text.length > 0) {
		iterator.getBounds(this.text, 0, this.text.length, undefined, tmpBounds);
		
		var line = new WordWrap.Line(0, this.text.length, tmpBounds.width);
		this.lines.push(line);
	}
};

/**
 * Resets the word wrapper by emptying all current lines.
 * @method  empty
 */
WordWrap.prototype.empty = function() {
	this.lines.length = 0;
};

/**
 * Word-wraps the given text into multiple lines.
 * @param  {[type]} iterator [description]
 * @param  {[type]} width    [description]
 * @param  {[type]} start    [description]
 * @param  {[type]} end      [description]
 * @return {[type]}          [description]
 */
WordWrap.prototype.layout = function(iterator, wrapWidth, start, end) {
	var text = this.text;

	var lines = this.lines;

	start = Math.max(0, start||0);
	end = (end===0||end) ? end : text.length;

	iterator.begin();

	//default wrap width...
	wrapWidth = (wrapWidth===0 || wrapWidth) ? wrapWidth : Number.MAX_VALUE;

	//<pre> mode just uses a simple algorithm...
	if (this.mode === WordWrap.Mode.PRE) {
		var lineStart = start;
		for (var i=start; i<end; i++) {
			var chr = text.charAt(i);

			//If we've reached a newline, then step down a line
			//Or if we've reached the EOF
			if ( chr === this.newline || i===end-1) {
				var availableWidth = this.clip ? wrapWidth : undefined;
				iterator.getBounds(text, lineStart, i+1, availableWidth, tmpBounds);
				lines.push( new WordWrap.Line(lineStart, lineStart+tmpBounds.glyphs, tmpBounds.width) );
				lineStart = i+1;
			}
		}
	} 
	//'normal' mode uses LibGDX's word wrapping algorithm:
	//https://github.com/libgdx/libgdx/blob/master/gdx/src/com/badlogic/gdx/graphics/g2d/BitmapFontCache.java
	else {
		//if 'nowrap' is specified, we only wrap on newline chars
		
		var testWidth = wrapWidth;
		if (this.mode === WordWrap.Mode.NOWRAP) {
			testWidth = Number.MAX_VALUE;
		}

		while (start < end) {
			//get next newline position
			var newLine = idxOf(text, this.newline, start, end);

			//eat whitespace at start of line
			while (start < newLine) {
				if (!isWhitespace( text.charAt(start) ))
					break;
				start++;
			}

			//determine visible # of glyphs for the available width
			iterator.getBounds(text, start, newLine, testWidth, tmpBounds)

			var lineEnd = start + tmpBounds.glyphs;
			var nextStart = lineEnd + this.newline.length;

			//if we had to cut the line before the next newline...
			if (lineEnd < newLine) {
				//find char to break on
				while (lineEnd > start) {
					if (isWhitespace(text.charAt(lineEnd)))
						break;
					lineEnd--;
				}
				if (lineEnd === start) {
					if (nextStart > start + this.newline.length) nextStart--;
					lineEnd = nextStart; // If no characters to break, show all.
				} else {
					nextStart = lineEnd;
					//eat whitespace at end of line
					while (lineEnd > start) {
						if (!isWhitespace(text.charAt(lineEnd - this.newline.length)))
							break;
						lineEnd--;
					}
				}
			}

			if (lineEnd > start) {
				//to clip, use the original wrap width (unaltered by mode)
				var availableWidth = this.clip ? wrapWidth : undefined;
				iterator.getBounds(text, start, lineEnd, availableWidth, tmpBounds);
				var lineWidth = tmpBounds.width;

				var rLineEnd = this.clip ? start+tmpBounds.glyphs : lineEnd;
				lines.push( new WordWrap.Line(start, rLineEnd, lineWidth) );
			}
			start = nextStart;

		}
	}

	iterator.end();
};

/**
 * A convenience method to return the maximum width of all current lines.
 * This is useful for aligning blocks of text.
 *
 * @method  getMaxLineWidth
 * @return {Number} the maximum width of all lines
 */
WordWrap.prototype.getMaxLineWidth = function() {
	var maxWidth = 0;
	for (var i=0; i<this.lines.length; i++) {
		var line = this.lines[i];
		maxWidth = Math.max(line.width, maxWidth);
	}
	return maxWidth;
};

/**
 * The Line object holds the start and end indices into the string,
 * and the width as computed by GlyphIterator.
 * 
 * @class  WordWrap.Line
 * @param {Number} start the start index, inclusive
 * @param {Number} end   the end index, exclusive
 * @param {Number} width the computed width of this line
 */
WordWrap.Line = function(start, end, width) {
	this.start = start;
	this.end = end;
	this.width = width;
};

module.exports = WordWrap;
},{}],"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/common.js":[function(require,module,exports){
var createVAO = require('gl-aliased-vao') //TODO: improve this with gl-vao
var createBuffer = require('gl-buffer')

module.exports.floatsPerVertex = 5

function createIndices(capacity) {
    var numIndices = capacity * 6
    var indices = new Uint16Array(numIndices)

    for (var i = 0, j = 0; i < numIndices; i += 6, j += 4) {
        indices[i + 0] = j + 0
        indices[i + 1] = j + 1
        indices[i + 2] = j + 2
        indices[i + 3] = j + 0
        indices[i + 4] = j + 2
        indices[i + 5] = j + 3
    }
    return indices
}

module.exports.mixins = {

    create: function create(opt) {
        opt = opt||{}
        this.clear()

        //dispose before building...
        if (this.vao)
            this.dispose()

        var capacity = typeof opt.capacity === 'number' ? opt.capacity : 100

        // 65535 is max index, so 65535 / 6 = 10922.
        if (capacity > 10922)
            throw new Error("Can't have more than 10922 quads per batch: " + capacity)

        this._capacity = capacity

        //the total number of floats in our batch
        var numVerts = capacity * 4 * module.exports.floatsPerVertex

        this.vertices = new Float32Array(numVerts)
        this.indices = createIndices(capacity)

        var gl = this.gl
        var usage = opt.dynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW
        this.vertexBuffer = createBuffer(gl, this.vertices, gl.ARRAY_BUFFER, usage)
        this.indexBuffer = createBuffer(gl, this.indices, gl.ELEMENT_ARRAY_BUFFER, gl.STATIC_DRAW)

        var stride = 5 * 4
        this.vao = createVAO(gl, [{ //position XY
            name: 'position',
            buffer: this.vertexBuffer,
            size: 2,
            stride: stride
        }, { //texcoord UV
            name: 'texcoord0',
            buffer: this.vertexBuffer,
            size: 2,
            offset: 2 * 4,
            stride: stride
        }, { //color (packed) C
            name: 'color',
            buffer: this.vertexBuffer,
            size: 4,
            stride: stride,
            offset: 4 * 4,
            type: gl.UNSIGNED_BYTE,
            normalized: true
        }], this.indexBuffer)
        return this
    },

    ensureCapacity: function(capacity) {
        if (this.capacity < capacity)
            this.create({ capacity: capacity })
        return this
    }
}
},{"gl-aliased-vao":"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/gl-aliased-vao/index.js","gl-buffer":"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/gl-buffer/buffer.js"}],"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/index.js":[function(require,module,exports){
var colorToFloat = require('./pack-rgba-float')
var mixes = require('mixes')
var premult = require('premultiplied-rgba')
var WhiteTex = require('gl-white-texture')

var vertNumFloats = require('./common').floatsPerVertex

//Temporary arrays to avoid GC thrashing
var position = [0, 0],
    shape = [0, 0],
    texcoord = [0, 0, 0, 0],
    color = [0, 0, 0, 0]

var tmp4 = [0, 0, 0, 0],
    rotOrigin = [0, 0],
    tmp2 = [0, 0]

function SpriteBatch(gl, opt) {
    if (!(this instanceof SpriteBatch))
        return new SpriteBatch(gl, opt)
    if (!gl)
        throw new Error("must specify gl context")
    this.gl = gl
    opt = opt || {}
    
    this._bound = false
    this.idx = 0

    //no transform means identity
    this.transform = null

    //white texture is akin to "no texture" (without switching shaders)
    this._defaultTexture = opt.defaultTexture || WhiteTex(gl)
    this._ownsDefault = !opt.defaultTexture
    this._lastTexture = this._defaultTexture
    this._texture = this._defaultTexture
    this.texture = null

    this.mode = typeof opt.mode === 'number' ? opt.mode : gl.TRIANGLES
    this.premultiplied = opt.premultiplied || false

    this._dirty = true
    this.create(opt)

    //set default attributes
    this.defaults()
}

//mix in create() and ensureCapacity() functions
mixes(SpriteBatch, require('./common').mixins)

mixes(SpriteBatch, {

    capacity: {
        get: function() {
            return this._capacity
        }
    },

    texture: {
        get: function() {
            return this._texture
        },

        set: function(tex) {
            this._texture = tex || this._defaultTexture
        }
    },

    dispose: function() {
        if (this.vertexBuffer)
            this.vertexBuffer.dispose()
        if (this.indexBuffer)
            this.indexBuffer.dispose()
        if (this.vao)
            this.vao.dispose()
        if (this._ownsDefault)
            this._defaultTexture.dispose()
    },

    clear: function() {
        this.idx = 0
        return this
    },

    bind: function(shader) {
        shader.bind()
        this.vao.bind(shader)
        this._bound = true
    },

    unbind: function() {
        this.vao.unbind()
        this._bound = false
    },

    defaults: function() {
        this.position = copy2(position, 0, 0)
        this.texcoord = copy4(texcoord, 0, 0, 1, 1)
        this.color = copy4(color, 1, 1, 1, 1)
        this.shape = copy2(shape, 0, 0)
        return this
    },

    push: function(sprite) {
        //if we are defining attributes on the fly
        if (sprite) {
            this.texture = sprite.texture
            this.position = sprite.position || copy2(position, 0, 0)
            this.texcoord = sprite.texcoord || copy4(texcoord, 0, 0, 1, 1)
            this.color = sprite.color || copy4(color, 1, 1, 1, 1)
            this.shape = sprite.shape || copy2(shape, 0, 0)
        }

        if (this.texture !== this._lastTexture) {
            //new texture, flush previous data
            if (this._bound)
                this.flush()
            this._lastTexture = this.texture
        } else if (this.idx === this.vertices.length) {
            //if we AREN'T bound, we need to stop pushing vertex data!
            if (!this._bound)
                return this

            //if we ARE bound, we can flush the batch and continue drawing
            this.flush()
        }

        this._dirty = true

        //get RGBA components and pack into a single float
        var colorRGBA = this.premultiplied ? premult(this.color, tmp4) : this.color
        var c = colorToFloat(colorRGBA)

        var u1 = this.texcoord[0],
            v1 = this.texcoord[1],
            u2 = this.texcoord[2],
            v2 = this.texcoord[3]

        var x = this.position[0],
            y = this.position[1],
            width = this.shape[0],
            height = this.shape[1]

        this._vert(x, y, u1, v1, c)
        this._vert(x+width, y, u2, v1, c)
        this._vert(x+width, y+height, u2, v2, c)
        this._vert(x, y+height, u1, v2, c)
        
        return this
    },

    _vert: function(x1, y1, u1, v1, c) {
        var idx = this.idx,
            verts = this.vertices,
            transform = this.transform

        if (transform) {
            var x = x1, y = y1
            x1 = transform[0] * x + transform[4] * y + transform[12]
            y1 = transform[1] * x + transform[5] * y + transform[13]
        }

        //xy
        verts[idx++] = x1
        verts[idx++] = y1
        //uv
        verts[idx++] = u1
        verts[idx++] = v1
        //color
        verts[idx++] = c
        this.idx = idx
    },

    flush: function() {
        this.draw()
        return this.clear()
    },

    draw: function() {
        //If we've reached a new texture or capacity
        //while not bound, then we will just clear the batch
        //to zero and draw nothing
        if (this.idx === 0 || !this._bound)
            return this

        var gl = this.gl
        
        if (this._dirty) {
            var view = this.vertices.subarray(0, this.idx)
            this.vertexBuffer.update(view, 0)
            this._dirty = false
        }

        if (this._lastTexture)
            this._lastTexture.bind()
        this._lastTexture = this.texture

        var sprites = (this.idx / (vertNumFloats * 4))
        if (sprites > 0)
            this.vao.draw(this.mode, sprites * 6, 0)
        return this
    },
})

module.exports = SpriteBatch

//TODO: will use modular gl-matrix for these...
function copy2(out, x, y) {
    out[0] = x
    out[1] = y
    return out
}

function copy4(out, x, y, z, w) {
    out[0] = x
    out[1] = y
    out[2] = z
    out[3] = w
    return out
}

function copyVec2(out, vec) {
    return copy2(out, vec[0], vec[1])
}

function transformMat4(out, a, m) {
    var x = a[0], 
        y = a[1]
    out[0] = m[0] * x + m[4] * y + m[12]
    out[1] = m[1] * x + m[5] * y + m[13]
    return out
}
},{"./common":"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/common.js","./pack-rgba-float":"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/pack-rgba-float.js","gl-white-texture":"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/gl-white-texture/index.js","mixes":"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/mixes/index.js","premultiplied-rgba":"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/premultiplied-rgba/index.js"}],"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/gl-aliased-vao/index.js":[function(require,module,exports){
var createVAOEmulated = require("./lib/vao-emulated.js")

function createVAO(gl, attributes, elements, elementsType) {
  var vao = createVAOEmulated(gl)
  vao.update(attributes, elements, elementsType)
  return vao
}

module.exports = createVAO
},{"./lib/vao-emulated.js":"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/gl-aliased-vao/lib/vao-emulated.js"}],"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/gl-aliased-vao/lib/do-bind.js":[function(require,module,exports){
function getAttributeLocation(name, shader) {
    if (!name)
        return null
    var attr = shader.attributes
    if (attr[name]) 
        return attr[name].location
    return null
}

var nattribs = null
var bound = null

function doBind(gl, elements, attributes, shader) {
    if (elements) {
        elements.bind()
    } else {
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null)
    }
    if (nattribs === null) {
      nattribs = gl.getParameter(gl.MAX_VERTEX_ATTRIBS) | 0
      bound = new Array(nattribs)
    }

    if (attributes) {
        if (attributes.length > nattribs) {
            throw new Error("gl-vao: Too many vertex attributes")
        }

        var lastBound = null

        for (i=0; i<nattribs; i++)
          bound[i] = false

        //now bind aliased attributes
        for (i=0; i<attributes.length; i++) {
            var attrib = attributes[i]
            var loc = getAttributeLocation(attrib.name, shader)
            if (loc === null)
                continue

            bound[loc] = true

            if(attrib.buffer) {
              var buffer = attrib.buffer
              var size = attrib.size || 4
              var type = attrib.type || gl.FLOAT
              var normalized = !!attrib.normalized
              var stride = attrib.stride || 0
              var offset = attrib.offset || 0
              if (lastBound !== buffer) {
                buffer.bind()
                lastBound = buffer
              }
              gl.enableVertexAttribArray(loc)
              gl.vertexAttribPointer(loc, size, type, normalized, stride, offset)
            } else {
              if(typeof attrib === "number") {
                gl.vertexAttrib1f(loc, attrib)
              } else if(attrib.length === 1) {
                gl.vertexAttrib1f(loc, attrib[0])
              } else if(attrib.length === 2) {
                gl.vertexAttrib2f(loc, attrib[0], attrib[1])
              } else if(attrib.length === 3) {
                gl.vertexAttrib3f(loc, attrib[0], attrib[1], attrib[2])
              } else if(attrib.length === 4) {
                gl.vertexAttrib4f(loc, attrib[0], attrib[1], attrib[2], attrib[3])
              } else {
                throw new Error("gl-vao: Invalid vertex attribute")
              }
              gl.disableVertexAttribArray(loc)
            }

        }
        
        for (i=0; i<nattribs; i++) {
          if (!bound[i])
            gl.disableVertexAttribArray(i)
        }
    } else {
      gl.bindBuffer(gl.ARRAY_BUFFER, null)
      for(var i=0; i<nattribs; ++i) {
        gl.disableVertexAttribArray(i)
      }
    }
}

module.exports = doBind
},{}],"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/gl-aliased-vao/lib/vao-emulated.js":[function(require,module,exports){
var bindAttribs = require("./do-bind.js")

function VAOEmulated(gl) {
  this.gl = gl
  this._elements = null
  this._attributes = null
  this._elementsType = gl.UNSIGNED_SHORT
}

VAOEmulated.prototype.bind = function(shader) {
  if (!shader)
    throw new Error('must associate shader with vertex array')
  bindAttribs(this.gl, this._elements, this._attributes, shader)
}

VAOEmulated.prototype.update = function(attributes, elements, elementsType) {
  this._elements = elements
  this._attributes = attributes
  this._elementsType = elementsType || this.gl.UNSIGNED_SHORT
}

VAOEmulated.prototype.dispose = function() { }
VAOEmulated.prototype.unbind = function() {
  bindAttribs(this.gl)
}

VAOEmulated.prototype.draw = function(mode, count, offset) {
  offset = offset || 0
  var gl = this.gl
  if(this._elements) {
    gl.drawElements(mode, count, this._elementsType, offset)
  } else {
    gl.drawArrays(mode, offset, count)
  }
}

function createVAOEmulated(gl) {
  return new VAOEmulated(gl)
}

module.exports = createVAOEmulated
},{"./do-bind.js":"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/gl-aliased-vao/lib/do-bind.js"}],"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/gl-buffer/buffer.js":[function(require,module,exports){
"use strict"

var pool = require("typedarray-pool")
var ops = require("ndarray-ops")
var ndarray = require("ndarray")
var webglew = require("webglew")

var SUPPORTED_TYPES = [
  "uint8",
  "uint8_clamped",
  "uint16",
  "uint32",
  "int8",
  "int16",
  "int32",
  "float32" ]

function GLBuffer(gl, type, handle, length, usage) {
  this.gl = gl
  this.type = type
  this.handle = handle
  this.length = length
  this.usage = usage
}

var proto = GLBuffer.prototype

proto.bind = function() {
  this.gl.bindBuffer(this.type, this.handle)
}

proto.unbind = function() {
  this.gl.bindBuffer(this.type, null)
}

proto.dispose = function() {
  this.gl.deleteBuffer(this.handle)
}

function updateTypeArray(gl, type, len, usage, data, offset) {
  var dataLen = data.length * data.BYTES_PER_ELEMENT 
  if(offset < 0) {
    gl.bufferData(type, data, usage)
    return dataLen
  }
  if(dataLen + offset > len) {
    throw new Error("gl-buffer: If resizing buffer, must not specify offset")
  }
  gl.bufferSubData(type, offset, data)
  return len
}

function makeScratchTypeArray(array, dtype) {
  var res = pool.malloc(array.length, dtype)
  var n = array.length
  for(var i=0; i<n; ++i) {
    res[i] = array[i]
  }
  return res
}

function isPacked(shape, stride) {
  var n = 1
  for(var i=stride.length-1; i>=0; --i) {
    if(stride[i] !== n) {
      return false
    }
    n *= shape[i]
  }
  return true
}

proto.update = function(array, offset) {
  if(typeof offset !== "number") {
    offset = -1
  }
  this.bind()
  if(typeof array === "object" && typeof array.shape !== "undefined") { //ndarray
    var dtype = array.dtype
    if(SUPPORTED_TYPES.indexOf(dtype) < 0) {
      dtype = "float32"
    }
    if(this.type === this.gl.ELEMENT_ARRAY_BUFFER) {
      var wgl = webglew(this.gl)
      var ext = wgl.OES_element_index_uint
      if(ext && dtype !== "uint16") {
        dtype = "uint32"
      } else {
        dtype = "uint16"
      }
    }
    if(dtype === array.dtype && isPacked(array.shape, array.stride)) {
      if(array.offset === 0 && array.data.length === array.shape[0]) {
        this.length = updateTypeArray(this.gl, this.type, this.length, this.usage, array.data, offset)
      } else {
        this.length = updateTypeArray(this.gl, this.type, this.length, this.usage, array.data.subarray(array.offset, array.shape[0]), offset)
      }
    } else {
      var tmp = pool.malloc(array.size, dtype)
      var ndt = ndarray(tmp, array.shape)
      ops.assign(ndt, array)
      if(offset < 0) {
        this.length = updateTypeArray(this.gl, this.type, this.length, this.usage, tmp, offset)  
      } else {
        this.length = updateTypeArray(this.gl, this.type, this.length, this.usage, tmp.subarray(0, array.size), offset)  
      }
      pool.free(tmp)
    }
  } else if(Array.isArray(array)) { //Vanilla array
    var t
    if(this.type === this.gl.ELEMENT_ARRAY_BUFFER) {
      t = makeScratchTypeArray(array, "uint16")
    } else {
      t = makeScratchTypeArray(array, "float32")
    }
    if(offset < 0) {
      this.length = updateTypeArray(this.gl, this.type, this.length, this.usage, t, offset)
    } else {
      this.length = updateTypeArray(this.gl, this.type, this.length, this.usage, t.subarray(0, array.length), offset)
    }
    pool.free(t)
  } else if(typeof array === "object" && typeof array.length === "number") { //Typed array
    this.length = updateTypeArray(this.gl, this.type, this.length, this.usage, array, offset)
  } else if(typeof array === "number" || array === undefined) { //Number/default
    if(offset >= 0) {
      throw new Error("gl-buffer: Cannot specify offset when resizing buffer")
    }
    array = array | 0
    if(array <= 0) {
      array = 1
    }
    this.gl.bufferData(this.type, array|0, this.usage)
    this.length = array
  } else { //Error, case should not happen
    throw new Error("gl-buffer: Invalid data type")
  }
}

function createBuffer(gl, data, type, usage) {
  webglew(gl)
  type = type || gl.ARRAY_BUFFER
  usage = usage || gl.DYNAMIC_DRAW
  if(type !== gl.ARRAY_BUFFER && type !== gl.ELEMENT_ARRAY_BUFFER) {
    throw new Error("gl-buffer: Invalid type for webgl buffer, must be either gl.ARRAY_BUFFER or gl.ELEMENT_ARRAY_BUFFER")
  }
  if(usage !== gl.DYNAMIC_DRAW && usage !== gl.STATIC_DRAW && usage !== gl.STREAM_DRAW) {
    throw new Error("gl-buffer: Invalid usage for buffer, must be either gl.DYNAMIC_DRAW, gl.STATIC_DRAW or gl.STREAM_DRAW")
  }
  var handle = gl.createBuffer()
  var result = new GLBuffer(gl, type, handle, 0, usage)
  result.update(data)
  return result
}

module.exports = createBuffer
},{"ndarray":"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/gl-buffer/node_modules/ndarray/ndarray.js","ndarray-ops":"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/gl-buffer/node_modules/ndarray-ops/ndarray-ops.js","typedarray-pool":"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/gl-buffer/node_modules/typedarray-pool/pool.js","webglew":"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/gl-buffer/node_modules/webglew/webglew.js"}],"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/gl-buffer/node_modules/ndarray-ops/ndarray-ops.js":[function(require,module,exports){
module.exports=require("/projects/blackice/node_modules/gl-sprite-text/node_modules/gl-texture2d/node_modules/ndarray-ops/ndarray-ops.js")
},{"/projects/blackice/node_modules/gl-sprite-text/node_modules/gl-texture2d/node_modules/ndarray-ops/ndarray-ops.js":"/projects/blackice/node_modules/gl-sprite-text/node_modules/gl-texture2d/node_modules/ndarray-ops/ndarray-ops.js"}],"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/gl-buffer/node_modules/ndarray/ndarray.js":[function(require,module,exports){
(function (Buffer){
var iota = require("iota-array")

var hasTypedArrays  = ((typeof Float64Array) !== "undefined")
var hasBuffer       = ((typeof Buffer) !== "undefined")

function compare1st(a, b) {
  return a[0] - b[0]
}

function order() {
  var stride = this.stride
  var terms = new Array(stride.length)
  var i
  for(i=0; i<terms.length; ++i) {
    terms[i] = [Math.abs(stride[i]), i]
  }
  terms.sort(compare1st)
  var result = new Array(terms.length)
  for(i=0; i<result.length; ++i) {
    result[i] = terms[i][1]
  }
  return result
}

function compileConstructor(dtype, dimension) {
  var className = ["View", dimension, "d", dtype].join("")
  if(dimension < 0) {
    className = "View_Nil" + dtype
  }
  var useGetters = (dtype === "generic")
  
  if(dimension === -1) {
    //Special case for trivial arrays
    var code = 
      "function "+className+"(a){this.data=a;};\
var proto="+className+".prototype;\
proto.dtype='"+dtype+"';\
proto.index=function(){return -1};\
proto.size=0;\
proto.dimension=-1;\
proto.shape=proto.stride=proto.order=[];\
proto.lo=proto.hi=proto.transpose=proto.step=\
function(){return new "+className+"(this.data);};\
proto.get=proto.set=function(){};\
proto.pick=function(){return null};\
return function construct_"+className+"(a){return new "+className+"(a);}"
    var procedure = new Function(code)
    return procedure()
  } else if(dimension === 0) {
    //Special case for 0d arrays
    var code =
      "function "+className+"(a,d) {\
this.data = a;\
this.offset = d\
};\
var proto="+className+".prototype;\
proto.dtype='"+dtype+"';\
proto.index=function(){return this.offset};\
proto.dimension=0;\
proto.size=1;\
proto.shape=\
proto.stride=\
proto.order=[];\
proto.lo=\
proto.hi=\
proto.transpose=\
proto.step=function "+className+"_copy() {\
return new "+className+"(this.data,this.offset)\
};\
proto.pick=function "+className+"_pick(){\
return TrivialArray(this.data);\
};\
proto.valueOf=proto.get=function "+className+"_get(){\
return "+(useGetters ? "this.data.get(this.offset)" : "this.data[this.offset]")+
"};\
proto.set=function "+className+"_set(v){\
return "+(useGetters ? "this.data.set(this.offset,v)" : "this.data[this.offset]=v")+"\
};\
return function construct_"+className+"(a,b,c,d){return new "+className+"(a,d)}"
    var procedure = new Function("TrivialArray", code)
    return procedure(CACHED_CONSTRUCTORS[dtype][0])
  }

  var code = ["'use strict'"]
    
  //Create constructor for view
  var indices = iota(dimension)
  var args = indices.map(function(i) { return "i"+i })
  var index_str = "this.offset+" + indices.map(function(i) {
        return "this.stride[" + i + "]*i" + i
      }).join("+")
  var shapeArg = indices.map(function(i) {
      return "b"+i
    }).join(",")
  var strideArg = indices.map(function(i) {
      return "c"+i
    }).join(",")
  code.push(
    "function "+className+"(a," + shapeArg + "," + strideArg + ",d){this.data=a",
      "this.shape=[" + shapeArg + "]",
      "this.stride=[" + strideArg + "]",
      "this.offset=d|0}",
    "var proto="+className+".prototype",
    "proto.dtype='"+dtype+"'",
    "proto.dimension="+dimension)
  
  //view.size:
  code.push("Object.defineProperty(proto,'size',{get:function "+className+"_size(){\
return "+indices.map(function(i) { return "this.shape["+i+"]" }).join("*"),
"}})")

  //view.order:
  if(dimension === 1) {
    code.push("proto.order=[0]")
  } else {
    code.push("Object.defineProperty(proto,'order',{get:")
    if(dimension < 4) {
      code.push("function "+className+"_order(){")
      if(dimension === 2) {
        code.push("return (Math.abs(this.stride[0])>Math.abs(this.stride[1]))?[1,0]:[0,1]}})")
      } else if(dimension === 3) {
        code.push(
"var s0=Math.abs(this.stride[0]),s1=Math.abs(this.stride[1]),s2=Math.abs(this.stride[2]);\
if(s0>s1){\
if(s1>s2){\
return [2,1,0];\
}else if(s0>s2){\
return [1,2,0];\
}else{\
return [1,0,2];\
}\
}else if(s0>s2){\
return [2,0,1];\
}else if(s2>s1){\
return [0,1,2];\
}else{\
return [0,2,1];\
}}})")
      }
    } else {
      code.push("ORDER})")
    }
  }
  
  //view.set(i0, ..., v):
  code.push(
"proto.set=function "+className+"_set("+args.join(",")+",v){")
  if(useGetters) {
    code.push("return this.data.set("+index_str+",v)}")
  } else {
    code.push("return this.data["+index_str+"]=v}")
  }
  
  //view.get(i0, ...):
  code.push("proto.get=function "+className+"_get("+args.join(",")+"){")
  if(useGetters) {
    code.push("return this.data.get("+index_str+")}")
  } else {
    code.push("return this.data["+index_str+"]}")
  }
  
  //view.index:
  code.push(
    "proto.index=function "+className+"_index(", args.join(), "){return "+index_str+"}")

  //view.hi():
  code.push("proto.hi=function "+className+"_hi("+args.join(",")+"){return new "+className+"(this.data,"+
    indices.map(function(i) {
      return ["(typeof i",i,"!=='number'||i",i,"<0)?this.shape[", i, "]:i", i,"|0"].join("")
    }).join(",")+","+
    indices.map(function(i) {
      return "this.stride["+i + "]"
    }).join(",")+",this.offset)}")
  
  //view.lo():
  var a_vars = indices.map(function(i) { return "a"+i+"=this.shape["+i+"]" })
  var c_vars = indices.map(function(i) { return "c"+i+"=this.stride["+i+"]" })
  code.push("proto.lo=function "+className+"_lo("+args.join(",")+"){var b=this.offset,d=0,"+a_vars.join(",")+","+c_vars.join(","))
  for(var i=0; i<dimension; ++i) {
    code.push(
"if(typeof i"+i+"==='number'&&i"+i+">=0){\
d=i"+i+"|0;\
b+=c"+i+"*d;\
a"+i+"-=d}")
  }
  code.push("return new "+className+"(this.data,"+
    indices.map(function(i) {
      return "a"+i
    }).join(",")+","+
    indices.map(function(i) {
      return "c"+i
    }).join(",")+",b)}")
  
  //view.step():
  code.push("proto.step=function "+className+"_step("+args.join(",")+"){var "+
    indices.map(function(i) {
      return "a"+i+"=this.shape["+i+"]"
    }).join(",")+","+
    indices.map(function(i) {
      return "b"+i+"=this.stride["+i+"]"
    }).join(",")+",c=this.offset,d=0,ceil=Math.ceil")
  for(var i=0; i<dimension; ++i) {
    code.push(
"if(typeof i"+i+"==='number'){\
d=i"+i+"|0;\
if(d<0){\
c+=b"+i+"*(a"+i+"-1);\
a"+i+"=ceil(-a"+i+"/d)\
}else{\
a"+i+"=ceil(a"+i+"/d)\
}\
b"+i+"*=d\
}")
  }
  code.push("return new "+className+"(this.data,"+
    indices.map(function(i) {
      return "a" + i
    }).join(",")+","+
    indices.map(function(i) {
      return "b" + i
    }).join(",")+",c)}")
  
  //view.transpose():
  var tShape = new Array(dimension)
  var tStride = new Array(dimension)
  for(var i=0; i<dimension; ++i) {
    tShape[i] = "a[i"+i+"]"
    tStride[i] = "b[i"+i+"]"
  }
  code.push("proto.transpose=function "+className+"_transpose("+args+"){"+
    args.map(function(n,idx) { return n + "=(" + n + "===undefined?" + idx + ":" + n + "|0)"}).join(";"),
    "var a=this.shape,b=this.stride;return new "+className+"(this.data,"+tShape.join(",")+","+tStride.join(",")+",this.offset)}")
  
  //view.pick():
  code.push("proto.pick=function "+className+"_pick("+args+"){var a=[],b=[],c=this.offset")
  for(var i=0; i<dimension; ++i) {
    code.push("if(typeof i"+i+"==='number'&&i"+i+">=0){c=(c+this.stride["+i+"]*i"+i+")|0}else{a.push(this.shape["+i+"]);b.push(this.stride["+i+"])}")
  }
  code.push("var ctor=CTOR_LIST[a.length+1];return ctor(this.data,a,b,c)}")
    
  //Add return statement
  code.push("return function construct_"+className+"(data,shape,stride,offset){return new "+className+"(data,"+
    indices.map(function(i) {
      return "shape["+i+"]"
    }).join(",")+","+
    indices.map(function(i) {
      return "stride["+i+"]"
    }).join(",")+",offset)}")

  //Compile procedure
  var procedure = new Function("CTOR_LIST", "ORDER", code.join("\n"))
  return procedure(CACHED_CONSTRUCTORS[dtype], order)
}

function arrayDType(data) {
  if(hasBuffer) {
    if(Buffer.isBuffer(data)) {
      return "buffer"
    }
  }
  if(hasTypedArrays) {
    switch(Object.prototype.toString.call(data)) {
      case "[object Float64Array]":
        return "float64"
      case "[object Float32Array]":
        return "float32"
      case "[object Int8Array]":
        return "int8"
      case "[object Int16Array]":
        return "int16"
      case "[object Int32Array]":
        return "int32"
      case "[object Uint8Array]":
        return "uint8"
      case "[object Uint16Array]":
        return "uint16"
      case "[object Uint32Array]":
        return "uint32"
      case "[object Uint8ClampedArray]":
        return "uint8_clamped"
    }
  }
  if(Array.isArray(data)) {
    return "array"
  }
  return "generic"
}

var CACHED_CONSTRUCTORS = {
  "float32":[],
  "float64":[],
  "int8":[],
  "int16":[],
  "int32":[],
  "uint8":[],
  "uint16":[],
  "uint32":[],
  "array":[],
  "uint8_clamped":[],
  "buffer":[],
  "generic":[]
}

;(function() {
  for(var id in CACHED_CONSTRUCTORS) {
    CACHED_CONSTRUCTORS[id].push(compileConstructor(id, -1))
  }
});

function wrappedNDArrayCtor(data, shape, stride, offset) {
  if(data === undefined) {
    var ctor = CACHED_CONSTRUCTORS.array[0]
    return ctor([])
  } else if(typeof data === "number") {
    data = [data]
  }
  if(shape === undefined) {
    shape = [ data.length ]
  }
  var d = shape.length
  if(stride === undefined) {
    stride = new Array(d)
    for(var i=d-1, sz=1; i>=0; --i) {
      stride[i] = sz
      sz *= shape[i]
    }
  }
  if(offset === undefined) {
    offset = 0
    for(var i=0; i<d; ++i) {
      if(stride[i] < 0) {
        offset -= (shape[i]-1)*stride[i]
      }
    }
  }
  var dtype = arrayDType(data)
  var ctor_list = CACHED_CONSTRUCTORS[dtype]
  while(ctor_list.length <= d+1) {
    ctor_list.push(compileConstructor(dtype, ctor_list.length-1))
  }
  var ctor = ctor_list[d+1]
  return ctor(data, shape, stride, offset)
}

module.exports = wrappedNDArrayCtor
}).call(this,require("buffer").Buffer)
},{"buffer":"/projects/blackice/node_modules/browserify/node_modules/buffer/index.js","iota-array":"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/gl-buffer/node_modules/ndarray/node_modules/iota-array/iota.js"}],"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/gl-buffer/node_modules/ndarray/node_modules/iota-array/iota.js":[function(require,module,exports){
module.exports=require("/projects/blackice/node_modules/gl-sprite-text/node_modules/gl-white-texture/node_modules/ndarray/node_modules/iota-array/iota.js")
},{"/projects/blackice/node_modules/gl-sprite-text/node_modules/gl-white-texture/node_modules/ndarray/node_modules/iota-array/iota.js":"/projects/blackice/node_modules/gl-sprite-text/node_modules/gl-white-texture/node_modules/ndarray/node_modules/iota-array/iota.js"}],"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/gl-buffer/node_modules/typedarray-pool/pool.js":[function(require,module,exports){
module.exports=require("/projects/blackice/node_modules/gl-sprite-text/node_modules/gl-texture2d/node_modules/typedarray-pool/pool.js")
},{"/projects/blackice/node_modules/gl-sprite-text/node_modules/gl-texture2d/node_modules/typedarray-pool/pool.js":"/projects/blackice/node_modules/gl-sprite-text/node_modules/gl-texture2d/node_modules/typedarray-pool/pool.js"}],"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/gl-buffer/node_modules/webglew/webglew.js":[function(require,module,exports){
module.exports=require("/projects/blackice/node_modules/gl-sprite-text/node_modules/gl-texture2d/node_modules/webglew/webglew.js")
},{"/projects/blackice/node_modules/gl-sprite-text/node_modules/gl-texture2d/node_modules/webglew/webglew.js":"/projects/blackice/node_modules/gl-sprite-text/node_modules/gl-texture2d/node_modules/webglew/webglew.js"}],"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/gl-white-texture/index.js":[function(require,module,exports){
var create = require('gl-texture2d')
var ndarray = require('ndarray')

module.exports = function(gl) {
    //fill an array with 0xff
    var data = Array.apply(null, new Array(16))
            .map(Number.prototype.valueOf, 0xFF);
    //create a 2D ndarray
    var array = ndarray(new Uint8Array(data), [2, 2, 4])
    return create(gl, array)
}
},{"gl-texture2d":"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-texture2d/texture.js","ndarray":"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/gl-white-texture/node_modules/ndarray/ndarray.js"}],"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/gl-white-texture/node_modules/ndarray/ndarray.js":[function(require,module,exports){
module.exports=require("/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/gl-buffer/node_modules/ndarray/ndarray.js")
},{"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/gl-buffer/node_modules/ndarray/ndarray.js":"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/gl-buffer/node_modules/ndarray/ndarray.js"}],"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/mixes/index.js":[function(require,module,exports){
module.exports=require("/projects/blackice/node_modules/mixes/index.js")
},{"/projects/blackice/node_modules/mixes/index.js":"/projects/blackice/node_modules/mixes/index.js"}],"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/number-util/index.js":[function(require,module,exports){
var int8 = new Int8Array(4);
var int32 = new Int32Array(int8.buffer, 0, 1);
var float32 = new Float32Array(int8.buffer, 0, 1);

/**
 * A singleton for number utilities. 
 * @class NumberUtil
 */
var NumberUtil = function() {

};


/**
 * Returns a float representation of the given int bits. ArrayBuffer
 * is used for the conversion.
 *
 * @method  intBitsToFloat
 * @static
 * @param  {Number} i the int to cast
 * @return {Number}   the float
 */
NumberUtil.intBitsToFloat = function(i) {
	int32[0] = i;
	return float32[0];
};

/**
 * Returns the int bits from the given float. ArrayBuffer is used
 * for the conversion.
 *
 * @method  floatToIntBits
 * @static
 * @param  {Number} f the float to cast
 * @return {Number}   the int bits
 */
NumberUtil.floatToIntBits = function(f) {
	float32[0] = f;
	return int32[0];
};

/**
 * Encodes ABGR int as a float, with slight precision loss.
 *
 * @method  intToFloatColor
 * @static
 * @param {Number} value an ABGR packed integer
 */
NumberUtil.intToFloatColor = function(value) {
	return NumberUtil.intBitsToFloat( value & 0xfeffffff );
};

/**
 * Returns a float encoded ABGR value from the given RGBA
 * bytes (0 - 255). Useful for saving bandwidth in vertex data.
 *
 * @method  colorToFloat
 * @static
 * @param {Number} r the Red byte (0 - 255)
 * @param {Number} g the Green byte (0 - 255)
 * @param {Number} b the Blue byte (0 - 255)
 * @param {Number} a the Alpha byte (0 - 255)
 * @return {Float32}  a Float32 of the RGBA color
 */
NumberUtil.colorToFloat = function(r, g, b, a) {
	var bits = (a << 24 | b << 16 | g << 8 | r);
	return NumberUtil.intToFloatColor(bits);
};

/**
 * Returns true if the number is a power-of-two.
 *
 * @method  isPowerOfTwo
 * @param  {Number}  n the number to test
 * @return {Boolean}   true if power-of-two
 */
NumberUtil.isPowerOfTwo = function(n) {
	return (n & (n - 1)) === 0;
};

/**
 * Returns the next highest power-of-two from the specified number. 
 * 
 * @param  {Number} n the number to test
 * @return {Number}   the next highest power of two
 */
NumberUtil.nextPowerOfTwo = function(n) {
	n--;
	n |= n >> 1;
	n |= n >> 2;
	n |= n >> 4;
	n |= n >> 8;
	n |= n >> 16;
	return n+1;
};

module.exports = NumberUtil;
},{}],"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/premultiplied-rgba/index.js":[function(require,module,exports){
function premultiply(rgba, out) {
	if (!out || typeof out === 'number')
		out = [0,0,0,0]
	out[0] = rgba[0] * rgba[3]
	out[1] = rgba[1] * rgba[3]
	out[2] = rgba[2] * rgba[3]
	out[3] = rgba[3]
	return out
}
module.exports = premultiply
},{}],"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/pack-rgba-float.js":[function(require,module,exports){
var packColor = require('number-util').colorToFloat

module.exports = function colorToFloat(rgba) {
    return packColor(
        ~~(rgba[0] * 255),
        ~~(rgba[1] * 255),
        ~~(rgba[2] * 255),
        ~~(rgba[3] * 255)
    )
}
},{"number-util":"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/number-util/index.js"}],"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/inherits/inherits_browser.js":[function(require,module,exports){
module.exports=require("/projects/blackice/node_modules/inherits/inherits_browser.js")
},{"/projects/blackice/node_modules/inherits/inherits_browser.js":"/projects/blackice/node_modules/inherits/inherits_browser.js"}],"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/texcoord/index.js":[function(require,module,exports){
module.exports = function texcoord(position, shape, texShape, out) {
    if (!out)
        out = [0, 0, 1, 1]

    position = position || [0, 0]
    shape = shape || [1, 1]

    texShape = texShape || shape

    var invWidth = 1 / texShape[0]
    var invHeight = 1 / texShape[1]
    var x = position[0],
        y = position[1],
        w = shape[0],
        h = shape[1]

    out[0] = x * invWidth
    out[1] = y * invHeight
    out[2] = (x + w) * invWidth
    out[3] = (y + h) * invHeight
    return out
}
},{}],"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-texture2d/texture.js":[function(require,module,exports){
module.exports=require("/projects/blackice/node_modules/gl-texture2d/texture.js")
},{"/projects/blackice/node_modules/gl-texture2d/texture.js":"/projects/blackice/node_modules/gl-texture2d/texture.js"}],"/projects/blackice/node_modules/three-sdf-text/node_modules/xtend/immutable.js":[function(require,module,exports){
module.exports=require("/projects/blackice/node_modules/gl-sprite-text/node_modules/xtend/immutable.js")
},{"/projects/blackice/node_modules/gl-sprite-text/node_modules/xtend/immutable.js":"/projects/blackice/node_modules/gl-sprite-text/node_modules/xtend/immutable.js"}],"/projects/blackice/node_modules/three-shader-fxaa/index.js":[function(require,module,exports){
var glslify = require("glslify");
var threeify = require("three-glslify");
var source = require("glslify/simple-adapter.js")("\n#define GLSLIFY 1\n\nvarying vec2 vUv;\nvarying vec2 v_rgbNW;\nvarying vec2 v_rgbNE;\nvarying vec2 v_rgbSW;\nvarying vec2 v_rgbSE;\nvarying vec2 v_rgbM;\nuniform vec2 resolution;\nvoid a_x_texcoords(vec2 fragCoord, vec2 resolution, out vec2 v_rgbNW, out vec2 v_rgbNE, out vec2 v_rgbSW, out vec2 v_rgbSE, out vec2 v_rgbM) {\n  vec2 inverseVP = 1.0 / resolution.xy;\n  v_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;\n  v_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;\n  v_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;\n  v_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;\n  v_rgbM = vec2(fragCoord * inverseVP);\n}\nvoid main() {\n  vUv = uv;\n  vec2 fragCoord = uv * resolution;\n  a_x_texcoords(fragCoord, resolution, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}", "\n#define GLSLIFY 1\n\nvarying vec2 vUv;\nvarying vec2 v_rgbNW;\nvarying vec2 v_rgbNE;\nvarying vec2 v_rgbSW;\nvarying vec2 v_rgbSE;\nvarying vec2 v_rgbM;\nuniform vec2 resolution;\nuniform sampler2D tDiffuse;\n#ifndef FXAA_REDUCE_MIN\n\n#define FXAA_REDUCE_MIN   (1.0/ 128.0)\n\n#endif\n\n#ifndef FXAA_REDUCE_MUL\n\n#define FXAA_REDUCE_MUL   (1.0 / 8.0)\n\n#endif\n\n#ifndef FXAA_SPAN_MAX\n\n#define FXAA_SPAN_MAX     8.0\n\n#endif\n\nvec4 a_x_fxaa(sampler2D tex, vec2 fragCoord, vec2 resolution, vec2 v_rgbNW, vec2 v_rgbNE, vec2 v_rgbSW, vec2 v_rgbSE, vec2 v_rgbM) {\n  vec4 color;\n  mediump vec2 inverseVP = vec2(1.0 / resolution.x, 1.0 / resolution.y);\n  vec3 rgbNW = texture2D(tex, v_rgbNW).xyz;\n  vec3 rgbNE = texture2D(tex, v_rgbNE).xyz;\n  vec3 rgbSW = texture2D(tex, v_rgbSW).xyz;\n  vec3 rgbSE = texture2D(tex, v_rgbSE).xyz;\n  vec4 texColor = texture2D(tex, v_rgbM);\n  vec3 rgbM = texColor.xyz;\n  vec3 luma = vec3(0.299, 0.587, 0.114);\n  float lumaNW = dot(rgbNW, luma);\n  float lumaNE = dot(rgbNE, luma);\n  float lumaSW = dot(rgbSW, luma);\n  float lumaSE = dot(rgbSE, luma);\n  float lumaM = dot(rgbM, luma);\n  float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n  float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n  mediump vec2 dir;\n  dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n  dir.y = ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n  float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) * (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\n  float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n  dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX), max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX), dir * rcpDirMin)) * inverseVP;\n  vec3 rgbA = 0.5 * (texture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz + texture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);\n  vec3 rgbB = rgbA * 0.5 + 0.25 * (texture2D(tex, fragCoord * inverseVP + dir * -0.5).xyz + texture2D(tex, fragCoord * inverseVP + dir * 0.5).xyz);\n  float lumaB = dot(rgbB, luma);\n  if((lumaB < lumaMin) || (lumaB > lumaMax))\n    color = vec4(rgbA, texColor.a);\n  else\n    color = vec4(rgbB, texColor.a);\n  return color;\n}\nvoid main() {\n  vec2 fragCoord = vUv * resolution;\n  gl_FragColor = a_x_fxaa(tDiffuse, fragCoord, resolution, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n}", [{"name":"resolution","type":"vec2"},{"name":"resolution","type":"vec2"},{"name":"tDiffuse","type":"sampler2D"}], []);

module.exports = function(THREE) {
    var createShader = threeify(THREE);

    return function() {
        return createShader(source);
    };
};
},{"glslify":"/projects/blackice/node_modules/glslify/browser.js","glslify/simple-adapter.js":"/projects/blackice/node_modules/glslify/simple-adapter.js","three-glslify":"/projects/blackice/node_modules/three-glslify/index.js"}],"/projects/blackice/node_modules/three-simplicial-complex/index.js":[function(require,module,exports){
var inherits = require('inherits')

module.exports = function(THREE) {

    function Complex(mesh) {
        if (!(this instanceof Complex))
            return new Complex(mesh)
        THREE.Geometry.call(this)
        this.dynamic = true

        if (mesh)
            this.update(mesh)
    }

    inherits(Complex, THREE.Geometry)

    //may expose these in next version
    Complex.prototype._updatePositions = function(positions) {
        for (var i=0; i<positions.length; i++) {
            var pos = positions[i]
            if (i > this.vertices.length-1)
                this.vertices.push(new THREE.Vector3().fromArray(pos))
            else 
                this.vertices[i].fromArray(pos)
        }
        this.vertices.length = positions.length
        this.verticesNeedUpdate = true
    }

    Complex.prototype._updateCells = function(cells) {
        for (var i=0; i<cells.length; i++) {
            var face = cells[i]
            if (i > this.faces.length-1)
                this.faces.push(new THREE.Face3(face[0], face[1], face[2]))
            else {
                var tf = this.faces[i]
                tf.a = face[0]
                tf.b = face[1]
                tf.c = face[2]
            }
        }

        this.faces.length = cells.length
        this.elementsNeedUpdate = true
    }

    Complex.prototype.update = function(mesh) {
        this._updatePositions(mesh.positions)
        this._updateCells(mesh.cells)
    }

    return Complex
}
},{"inherits":"/projects/blackice/node_modules/inherits/inherits_browser.js"}],"/projects/blackice/node_modules/triangulate-contours/index.js":[function(require,module,exports){
var Tess2 = require('tess2')
var xtend = require('xtend')

module.exports = function(contours, opt) {
    opt = opt||{}
    contours = contours.filter(function(c) {
        return c.length>0
    })
    
    if (contours.length === 0) {
        return { 
            positions: [],
            cells: []
        }
    }

    if (typeof opt.vertexSize !== 'number')
        opt.vertexSize = contours[0][0].length

    //flatten for tess2.js
    contours = contours.map(function(c) {
        return c.reduce(function(a, b) {
            return a.concat(b)
        })
    })

    // Tesselate
    var res = Tess2.tesselate(xtend({
        contours: contours,
        windingRule: Tess2.WINDING_ODD,
        elementType: Tess2.POLYGONS,
        polySize: 3,
        vertexSize: 2
    }, opt))

    var positions = []
    for (var i=0; i<res.vertices.length; i+=opt.vertexSize) {
        var pos = res.vertices.slice(i, i+opt.vertexSize)
        positions.push(pos)
    }
    
    var cells = []
    for (i=0; i<res.elements.length; i+=3) {
        var a = res.elements[i],
            b = res.elements[i+1],
            c = res.elements[i+2]
        cells.push([a, b, c])
    }

    //return a simplicial complex
    return {
        positions: positions,
        cells: cells
    }
}
},{"tess2":"/projects/blackice/node_modules/triangulate-contours/node_modules/tess2/index.js","xtend":"/projects/blackice/node_modules/xtend/immutable.js"}],"/projects/blackice/node_modules/triangulate-contours/node_modules/tess2/index.js":[function(require,module,exports){
module.exports = require('./src/tess2');
},{"./src/tess2":"/projects/blackice/node_modules/triangulate-contours/node_modules/tess2/src/tess2.js"}],"/projects/blackice/node_modules/triangulate-contours/node_modules/tess2/src/tess2.js":[function(require,module,exports){
/*
** SGI FREE SOFTWARE LICENSE B (Version 2.0, Sept. 18, 2008) 
** Copyright (C) [dates of first publication] Silicon Graphics, Inc.
** All Rights Reserved.
**
** Permission is hereby granted, free of charge, to any person obtaining a copy
** of this software and associated documentation files (the "Software"), to deal
** in the Software without restriction, including without limitation the rights
** to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
** of the Software, and to permit persons to whom the Software is furnished to do so,
** subject to the following conditions:
** 
** The above copyright notice including the dates of first publication and either this
** permission notice or a reference to http://oss.sgi.com/projects/FreeB/ shall be
** included in all copies or substantial portions of the Software. 
**
** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
** INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
** PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL SILICON GRAPHICS, INC.
** BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
** TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
** OR OTHER DEALINGS IN THE SOFTWARE.
** 
** Except as contained in this notice, the name of Silicon Graphics, Inc. shall not
** be used in advertising or otherwise to promote the sale, use or other dealings in
** this Software without prior written authorization from Silicon Graphics, Inc.
*/
/*
** Author: Mikko Mononen, Aug 2013.
** The code is based on GLU libtess by Eric Veach, July 1994
*/

	"use strict";

	/* Public API */

	var Tess2 = {};

	module.exports = Tess2;
	
	Tess2.WINDING_ODD = 0;
	Tess2.WINDING_NONZERO = 1;
	Tess2.WINDING_POSITIVE = 2;
	Tess2.WINDING_NEGATIVE = 3;
	Tess2.WINDING_ABS_GEQ_TWO = 4;

	Tess2.POLYGONS = 0;
	Tess2.CONNECTED_POLYGONS = 1;
	Tess2.BOUNDARY_CONTOURS = 2;

	Tess2.tesselate = function(opts) {
		var debug =  opts.debug || false;
		var tess = new Tesselator();
		for (var i = 0; i < opts.contours.length; i++) {
			tess.addContour(opts.vertexSize || 2, opts.contours[i]);
		}
		tess.tesselate(opts.windingRule || Tess2.WINDING_ODD,
					   opts.elementType || Tess2.POLYGONS,
					   opts.polySize || 3,
					   opts.vertexSize || 2,
					   opts.normal || [0,0,1]);
		return {
			vertices: tess.vertices,
			vertexIndices: tess.vertexIndices,
			vertexCount: tess.vertexCount,
			elements: tess.elements,
			elementCount: tess.elementCount,
			mesh: debug ? tess.mesh : undefined
		};
	};

	/* Internal */

	var assert = function(cond) {
		if (!cond) {
			throw "Assertion Failed!";
		}
	}

	/* The mesh structure is similar in spirit, notation, and operations
	* to the "quad-edge" structure (see L. Guibas and J. Stolfi, Primitives
	* for the manipulation of general subdivisions and the computation of
	* Voronoi diagrams, ACM Transactions on Graphics, 4(2):74-123, April 1985).
	* For a simplified description, see the course notes for CS348a,
	* "Mathematical Foundations of Computer Graphics", available at the
	* Stanford bookstore (and taught during the fall quarter).
	* The implementation also borrows a tiny subset of the graph-based approach
	* use in Mantyla's Geometric Work Bench (see M. Mantyla, An Introduction
	* to Sold Modeling, Computer Science Press, Rockville, Maryland, 1988).
	*
	* The fundamental data structure is the "half-edge".  Two half-edges
	* go together to make an edge, but they point in opposite directions.
	* Each half-edge has a pointer to its mate (the "symmetric" half-edge Sym),
	* its origin vertex (Org), the face on its left side (Lface), and the
	* adjacent half-edges in the CCW direction around the origin vertex
	* (Onext) and around the left face (Lnext).  There is also a "next"
	* pointer for the global edge list (see below).
	*
	* The notation used for mesh navigation:
	*  Sym   = the mate of a half-edge (same edge, but opposite direction)
	*  Onext = edge CCW around origin vertex (keep same origin)
	*  Dnext = edge CCW around destination vertex (keep same dest)
	*  Lnext = edge CCW around left face (dest becomes new origin)
	*  Rnext = edge CCW around right face (origin becomes new dest)
	*
	* "prev" means to substitute CW for CCW in the definitions above.
	*
	* The mesh keeps global lists of all vertices, faces, and edges,
	* stored as doubly-linked circular lists with a dummy header node.
	* The mesh stores pointers to these dummy headers (vHead, fHead, eHead).
	*
	* The circular edge list is special; since half-edges always occur
	* in pairs (e and e->Sym), each half-edge stores a pointer in only
	* one direction.  Starting at eHead and following the e->next pointers
	* will visit each *edge* once (ie. e or e->Sym, but not both).
	* e->Sym stores a pointer in the opposite direction, thus it is
	* always true that e->Sym->next->Sym->next == e.
	*
	* Each vertex has a pointer to next and previous vertices in the
	* circular list, and a pointer to a half-edge with this vertex as
	* the origin (NULL if this is the dummy header).  There is also a
	* field "data" for client data.
	*
	* Each face has a pointer to the next and previous faces in the
	* circular list, and a pointer to a half-edge with this face as
	* the left face (NULL if this is the dummy header).  There is also
	* a field "data" for client data.
	*
	* Note that what we call a "face" is really a loop; faces may consist
	* of more than one loop (ie. not simply connected), but there is no
	* record of this in the data structure.  The mesh may consist of
	* several disconnected regions, so it may not be possible to visit
	* the entire mesh by starting at a half-edge and traversing the edge
	* structure.
	*
	* The mesh does NOT support isolated vertices; a vertex is deleted along
	* with its last edge.  Similarly when two faces are merged, one of the
	* faces is deleted (see tessMeshDelete below).  For mesh operations,
	* all face (loop) and vertex pointers must not be NULL.  However, once
	* mesh manipulation is finished, TESSmeshZapFace can be used to delete
	* faces of the mesh, one at a time.  All external faces can be "zapped"
	* before the mesh is returned to the client; then a NULL face indicates
	* a region which is not part of the output polygon.
	*/

	function TESSvertex() {
		this.next = null;	/* next vertex (never NULL) */
		this.prev = null;	/* previous vertex (never NULL) */
		this.anEdge = null;	/* a half-edge with this origin */

		/* Internal data (keep hidden) */
		this.coords = [0,0,0];	/* vertex location in 3D */
		this.s = 0.0;
		this.t = 0.0;			/* projection onto the sweep plane */
		this.pqHandle = 0;		/* to allow deletion from priority queue */
		this.n = 0;				/* to allow identify unique vertices */
		this.idx = 0;			/* to allow map result to original verts */
	} 

	function TESSface() {
		this.next = null;		/* next face (never NULL) */
		this.prev = null;		/* previous face (never NULL) */
		this.anEdge = null;		/* a half edge with this left face */

		/* Internal data (keep hidden) */
		this.trail = null;		/* "stack" for conversion to strips */
		this.n = 0;				/* to allow identiy unique faces */
		this.marked = false;	/* flag for conversion to strips */
		this.inside = false;	/* this face is in the polygon interior */
	};

	function TESShalfEdge(side) {
		this.next = null;		/* doubly-linked list (prev==Sym->next) */
		this.Sym = null;		/* same edge, opposite direction */
		this.Onext = null;		/* next edge CCW around origin */
		this.Lnext = null;		/* next edge CCW around left face */
		this.Org = null;		/* origin vertex (Overtex too long) */
		this.Lface = null;		/* left face */

		/* Internal data (keep hidden) */
		this.activeRegion = null;	/* a region with this upper edge (sweep.c) */
		this.winding = 0;			/* change in winding number when crossing
									   from the right face to the left face */
		this.side = side;
	};

	TESShalfEdge.prototype = {
		get Rface() { return this.Sym.Lface; },
		set Rface(v) { this.Sym.Lface = v; },
		get Dst() { return this.Sym.Org; },
		set Dst(v) { this.Sym.Org = v; },
		get Oprev() { return this.Sym.Lnext; },
		set Oprev(v) { this.Sym.Lnext = v; },
		get Lprev() { return this.Onext.Sym; },
		set Lprev(v) { this.Onext.Sym = v; },
		get Dprev() { return this.Lnext.Sym; },
		set Dprev(v) { this.Lnext.Sym = v; },
		get Rprev() { return this.Sym.Onext; },
		set Rprev(v) { this.Sym.Onext = v; },
		get Dnext() { return /*this.Rprev*/this.Sym.Onext.Sym; },  /* 3 pointers */
		set Dnext(v) { /*this.Rprev*/this.Sym.Onext.Sym = v; },  /* 3 pointers */
		get Rnext() { return /*this.Oprev*/this.Sym.Lnext.Sym; },  /* 3 pointers */
		set Rnext(v) { /*this.Oprev*/this.Sym.Lnext.Sym = v; },  /* 3 pointers */
	};



	function TESSmesh() {
		var v = new TESSvertex();
		var f = new TESSface();
		var e = new TESShalfEdge(0);
		var eSym = new TESShalfEdge(1);

		v.next = v.prev = v;
		v.anEdge = null;

		f.next = f.prev = f;
		f.anEdge = null;
		f.trail = null;
		f.marked = false;
		f.inside = false;

		e.next = e;
		e.Sym = eSym;
		e.Onext = null;
		e.Lnext = null;
		e.Org = null;
		e.Lface = null;
		e.winding = 0;
		e.activeRegion = null;

		eSym.next = eSym;
		eSym.Sym = e;
		eSym.Onext = null;
		eSym.Lnext = null;
		eSym.Org = null;
		eSym.Lface = null;
		eSym.winding = 0;
		eSym.activeRegion = null;

		this.vHead = v;		/* dummy header for vertex list */
		this.fHead = f;		/* dummy header for face list */
		this.eHead = e;		/* dummy header for edge list */
		this.eHeadSym = eSym;	/* and its symmetric counterpart */
	};

	/* The mesh operations below have three motivations: completeness,
	* convenience, and efficiency.  The basic mesh operations are MakeEdge,
	* Splice, and Delete.  All the other edge operations can be implemented
	* in terms of these.  The other operations are provided for convenience
	* and/or efficiency.
	*
	* When a face is split or a vertex is added, they are inserted into the
	* global list *before* the existing vertex or face (ie. e->Org or e->Lface).
	* This makes it easier to process all vertices or faces in the global lists
	* without worrying about processing the same data twice.  As a convenience,
	* when a face is split, the "inside" flag is copied from the old face.
	* Other internal data (v->data, v->activeRegion, f->data, f->marked,
	* f->trail, e->winding) is set to zero.
	*
	* ********************** Basic Edge Operations **************************
	*
	* tessMeshMakeEdge( mesh ) creates one edge, two vertices, and a loop.
	* The loop (face) consists of the two new half-edges.
	*
	* tessMeshSplice( eOrg, eDst ) is the basic operation for changing the
	* mesh connectivity and topology.  It changes the mesh so that
	*  eOrg->Onext <- OLD( eDst->Onext )
	*  eDst->Onext <- OLD( eOrg->Onext )
	* where OLD(...) means the value before the meshSplice operation.
	*
	* This can have two effects on the vertex structure:
	*  - if eOrg->Org != eDst->Org, the two vertices are merged together
	*  - if eOrg->Org == eDst->Org, the origin is split into two vertices
	* In both cases, eDst->Org is changed and eOrg->Org is untouched.
	*
	* Similarly (and independently) for the face structure,
	*  - if eOrg->Lface == eDst->Lface, one loop is split into two
	*  - if eOrg->Lface != eDst->Lface, two distinct loops are joined into one
	* In both cases, eDst->Lface is changed and eOrg->Lface is unaffected.
	*
	* tessMeshDelete( eDel ) removes the edge eDel.  There are several cases:
	* if (eDel->Lface != eDel->Rface), we join two loops into one; the loop
	* eDel->Lface is deleted.  Otherwise, we are splitting one loop into two;
	* the newly created loop will contain eDel->Dst.  If the deletion of eDel
	* would create isolated vertices, those are deleted as well.
	*
	* ********************** Other Edge Operations **************************
	*
	* tessMeshAddEdgeVertex( eOrg ) creates a new edge eNew such that
	* eNew == eOrg->Lnext, and eNew->Dst is a newly created vertex.
	* eOrg and eNew will have the same left face.
	*
	* tessMeshSplitEdge( eOrg ) splits eOrg into two edges eOrg and eNew,
	* such that eNew == eOrg->Lnext.  The new vertex is eOrg->Dst == eNew->Org.
	* eOrg and eNew will have the same left face.
	*
	* tessMeshConnect( eOrg, eDst ) creates a new edge from eOrg->Dst
	* to eDst->Org, and returns the corresponding half-edge eNew.
	* If eOrg->Lface == eDst->Lface, this splits one loop into two,
	* and the newly created loop is eNew->Lface.  Otherwise, two disjoint
	* loops are merged into one, and the loop eDst->Lface is destroyed.
	*
	* ************************ Other Operations *****************************
	*
	* tessMeshNewMesh() creates a new mesh with no edges, no vertices,
	* and no loops (what we usually call a "face").
	*
	* tessMeshUnion( mesh1, mesh2 ) forms the union of all structures in
	* both meshes, and returns the new mesh (the old meshes are destroyed).
	*
	* tessMeshDeleteMesh( mesh ) will free all storage for any valid mesh.
	*
	* tessMeshZapFace( fZap ) destroys a face and removes it from the
	* global face list.  All edges of fZap will have a NULL pointer as their
	* left face.  Any edges which also have a NULL pointer as their right face
	* are deleted entirely (along with any isolated vertices this produces).
	* An entire mesh can be deleted by zapping its faces, one at a time,
	* in any order.  Zapped faces cannot be used in further mesh operations!
	*
	* tessMeshCheckMesh( mesh ) checks a mesh for self-consistency.
	*/

	TESSmesh.prototype = {

		/* MakeEdge creates a new pair of half-edges which form their own loop.
		* No vertex or face structures are allocated, but these must be assigned
		* before the current edge operation is completed.
		*/
		//static TESShalfEdge *MakeEdge( TESSmesh* mesh, TESShalfEdge *eNext )
		makeEdge_: function(eNext) {
			var e = new TESShalfEdge(0);
			var eSym = new TESShalfEdge(1);

			/* Make sure eNext points to the first edge of the edge pair */
			if( eNext.Sym.side < eNext.side ) { eNext = eNext.Sym; }

			/* Insert in circular doubly-linked list before eNext.
			* Note that the prev pointer is stored in Sym->next.
			*/
			var ePrev = eNext.Sym.next;
			eSym.next = ePrev;
			ePrev.Sym.next = e;
			e.next = eNext;
			eNext.Sym.next = eSym;

			e.Sym = eSym;
			e.Onext = e;
			e.Lnext = eSym;
			e.Org = null;
			e.Lface = null;
			e.winding = 0;
			e.activeRegion = null;

			eSym.Sym = e;
			eSym.Onext = eSym;
			eSym.Lnext = e;
			eSym.Org = null;
			eSym.Lface = null;
			eSym.winding = 0;
			eSym.activeRegion = null;

			return e;
		},

		/* Splice( a, b ) is best described by the Guibas/Stolfi paper or the
		* CS348a notes (see mesh.h).  Basically it modifies the mesh so that
		* a->Onext and b->Onext are exchanged.  This can have various effects
		* depending on whether a and b belong to different face or vertex rings.
		* For more explanation see tessMeshSplice() below.
		*/
		// static void Splice( TESShalfEdge *a, TESShalfEdge *b )
		splice_: function(a, b) {
			var aOnext = a.Onext;
			var bOnext = b.Onext;
			aOnext.Sym.Lnext = b;
			bOnext.Sym.Lnext = a;
			a.Onext = bOnext;
			b.Onext = aOnext;
		},

		/* MakeVertex( newVertex, eOrig, vNext ) attaches a new vertex and makes it the
		* origin of all edges in the vertex loop to which eOrig belongs. "vNext" gives
		* a place to insert the new vertex in the global vertex list.  We insert
		* the new vertex *before* vNext so that algorithms which walk the vertex
		* list will not see the newly created vertices.
		*/
		//static void MakeVertex( TESSvertex *newVertex, TESShalfEdge *eOrig, TESSvertex *vNext )
		makeVertex_: function(newVertex, eOrig, vNext) {
			var vNew = newVertex;
			assert(vNew !== null);

			/* insert in circular doubly-linked list before vNext */
			var vPrev = vNext.prev;
			vNew.prev = vPrev;
			vPrev.next = vNew;
			vNew.next = vNext;
			vNext.prev = vNew;

			vNew.anEdge = eOrig;
			/* leave coords, s, t undefined */

			/* fix other edges on this vertex loop */
			var e = eOrig;
			do {
				e.Org = vNew;
				e = e.Onext;
			} while(e !== eOrig);
		},

		/* MakeFace( newFace, eOrig, fNext ) attaches a new face and makes it the left
		* face of all edges in the face loop to which eOrig belongs.  "fNext" gives
		* a place to insert the new face in the global face list.  We insert
		* the new face *before* fNext so that algorithms which walk the face
		* list will not see the newly created faces.
		*/
		// static void MakeFace( TESSface *newFace, TESShalfEdge *eOrig, TESSface *fNext )
		makeFace_: function(newFace, eOrig, fNext) {
			var fNew = newFace;
			assert(fNew !== null); 

			/* insert in circular doubly-linked list before fNext */
			var fPrev = fNext.prev;
			fNew.prev = fPrev;
			fPrev.next = fNew;
			fNew.next = fNext;
			fNext.prev = fNew;

			fNew.anEdge = eOrig;
			fNew.trail = null;
			fNew.marked = false;

			/* The new face is marked "inside" if the old one was.  This is a
			* convenience for the common case where a face has been split in two.
			*/
			fNew.inside = fNext.inside;

			/* fix other edges on this face loop */
			var e = eOrig;
			do {
				e.Lface = fNew;
				e = e.Lnext;
			} while(e !== eOrig);
		},

		/* KillEdge( eDel ) destroys an edge (the half-edges eDel and eDel->Sym),
		* and removes from the global edge list.
		*/
		//static void KillEdge( TESSmesh *mesh, TESShalfEdge *eDel )
		killEdge_: function(eDel) {
			/* Half-edges are allocated in pairs, see EdgePair above */
			if( eDel.Sym.side < eDel.side ) { eDel = eDel.Sym; }

			/* delete from circular doubly-linked list */
			var eNext = eDel.next;
			var ePrev = eDel.Sym.next;
			eNext.Sym.next = ePrev;
			ePrev.Sym.next = eNext;
		},


		/* KillVertex( vDel ) destroys a vertex and removes it from the global
		* vertex list.  It updates the vertex loop to point to a given new vertex.
		*/
		//static void KillVertex( TESSmesh *mesh, TESSvertex *vDel, TESSvertex *newOrg )
		killVertex_: function(vDel, newOrg) {
			var eStart = vDel.anEdge;
			/* change the origin of all affected edges */
			var e = eStart;
			do {
				e.Org = newOrg;
				e = e.Onext;
			} while(e !== eStart);

			/* delete from circular doubly-linked list */
			var vPrev = vDel.prev;
			var vNext = vDel.next;
			vNext.prev = vPrev;
			vPrev.next = vNext;
		},

		/* KillFace( fDel ) destroys a face and removes it from the global face
		* list.  It updates the face loop to point to a given new face.
		*/
		//static void KillFace( TESSmesh *mesh, TESSface *fDel, TESSface *newLface )
		killFace_: function(fDel, newLface) {
			var eStart = fDel.anEdge;

			/* change the left face of all affected edges */
			var e = eStart;
			do {
				e.Lface = newLface;
				e = e.Lnext;
			} while(e !== eStart);

			/* delete from circular doubly-linked list */
			var fPrev = fDel.prev;
			var fNext = fDel.next;
			fNext.prev = fPrev;
			fPrev.next = fNext;
		},

		/****************** Basic Edge Operations **********************/

		/* tessMeshMakeEdge creates one edge, two vertices, and a loop (face).
		* The loop consists of the two new half-edges.
		*/
		//TESShalfEdge *tessMeshMakeEdge( TESSmesh *mesh )
		makeEdge: function() {
			var newVertex1 = new TESSvertex();
			var newVertex2 = new TESSvertex();
			var newFace = new TESSface();
			var e = this.makeEdge_( this.eHead);
			this.makeVertex_( newVertex1, e, this.vHead );
			this.makeVertex_( newVertex2, e.Sym, this.vHead );
			this.makeFace_( newFace, e, this.fHead );
			return e;
		},

		/* tessMeshSplice( eOrg, eDst ) is the basic operation for changing the
		* mesh connectivity and topology.  It changes the mesh so that
		*	eOrg->Onext <- OLD( eDst->Onext )
		*	eDst->Onext <- OLD( eOrg->Onext )
		* where OLD(...) means the value before the meshSplice operation.
		*
		* This can have two effects on the vertex structure:
		*  - if eOrg->Org != eDst->Org, the two vertices are merged together
		*  - if eOrg->Org == eDst->Org, the origin is split into two vertices
		* In both cases, eDst->Org is changed and eOrg->Org is untouched.
		*
		* Similarly (and independently) for the face structure,
		*  - if eOrg->Lface == eDst->Lface, one loop is split into two
		*  - if eOrg->Lface != eDst->Lface, two distinct loops are joined into one
		* In both cases, eDst->Lface is changed and eOrg->Lface is unaffected.
		*
		* Some special cases:
		* If eDst == eOrg, the operation has no effect.
		* If eDst == eOrg->Lnext, the new face will have a single edge.
		* If eDst == eOrg->Lprev, the old face will have a single edge.
		* If eDst == eOrg->Onext, the new vertex will have a single edge.
		* If eDst == eOrg->Oprev, the old vertex will have a single edge.
		*/
		//int tessMeshSplice( TESSmesh* mesh, TESShalfEdge *eOrg, TESShalfEdge *eDst )
		splice: function(eOrg, eDst) {
			var joiningLoops = false;
			var joiningVertices = false;

			if( eOrg === eDst ) return;

			if( eDst.Org !== eOrg.Org ) {
				/* We are merging two disjoint vertices -- destroy eDst->Org */
				joiningVertices = true;
				this.killVertex_( eDst.Org, eOrg.Org );
			}
			if( eDst.Lface !== eOrg.Lface ) {
				/* We are connecting two disjoint loops -- destroy eDst->Lface */
				joiningLoops = true;
				this.killFace_( eDst.Lface, eOrg.Lface );
			}

			/* Change the edge structure */
			this.splice_( eDst, eOrg );

			if( ! joiningVertices ) {
				var newVertex = new TESSvertex();

				/* We split one vertex into two -- the new vertex is eDst->Org.
				* Make sure the old vertex points to a valid half-edge.
				*/
				this.makeVertex_( newVertex, eDst, eOrg.Org );
				eOrg.Org.anEdge = eOrg;
			}
			if( ! joiningLoops ) {
				var newFace = new TESSface();  

				/* We split one loop into two -- the new loop is eDst->Lface.
				* Make sure the old face points to a valid half-edge.
				*/
				this.makeFace_( newFace, eDst, eOrg.Lface );
				eOrg.Lface.anEdge = eOrg;
			}
		},

		/* tessMeshDelete( eDel ) removes the edge eDel.  There are several cases:
		* if (eDel->Lface != eDel->Rface), we join two loops into one; the loop
		* eDel->Lface is deleted.  Otherwise, we are splitting one loop into two;
		* the newly created loop will contain eDel->Dst.  If the deletion of eDel
		* would create isolated vertices, those are deleted as well.
		*
		* This function could be implemented as two calls to tessMeshSplice
		* plus a few calls to memFree, but this would allocate and delete
		* unnecessary vertices and faces.
		*/
		//int tessMeshDelete( TESSmesh *mesh, TESShalfEdge *eDel )
		delete: function(eDel) {
			var eDelSym = eDel.Sym;
			var joiningLoops = false;

			/* First step: disconnect the origin vertex eDel->Org.  We make all
			* changes to get a consistent mesh in this "intermediate" state.
			*/
			if( eDel.Lface !== eDel.Rface ) {
				/* We are joining two loops into one -- remove the left face */
				joiningLoops = true;
				this.killFace_( eDel.Lface, eDel.Rface );
			}

			if( eDel.Onext === eDel ) {
				this.killVertex_( eDel.Org, null );
			} else {
				/* Make sure that eDel->Org and eDel->Rface point to valid half-edges */
				eDel.Rface.anEdge = eDel.Oprev;
				eDel.Org.anEdge = eDel.Onext;

				this.splice_( eDel, eDel.Oprev );
				if( ! joiningLoops ) {
					var newFace = new TESSface();

					/* We are splitting one loop into two -- create a new loop for eDel. */
					this.makeFace_( newFace, eDel, eDel.Lface );
				}
			}

			/* Claim: the mesh is now in a consistent state, except that eDel->Org
			* may have been deleted.  Now we disconnect eDel->Dst.
			*/
			if( eDelSym.Onext === eDelSym ) {
				this.killVertex_( eDelSym.Org, null );
				this.killFace_( eDelSym.Lface, null );
			} else {
				/* Make sure that eDel->Dst and eDel->Lface point to valid half-edges */
				eDel.Lface.anEdge = eDelSym.Oprev;
				eDelSym.Org.anEdge = eDelSym.Onext;
				this.splice_( eDelSym, eDelSym.Oprev );
			}

			/* Any isolated vertices or faces have already been freed. */
			this.killEdge_( eDel );
		},

		/******************** Other Edge Operations **********************/

		/* All these routines can be implemented with the basic edge
		* operations above.  They are provided for convenience and efficiency.
		*/


		/* tessMeshAddEdgeVertex( eOrg ) creates a new edge eNew such that
		* eNew == eOrg->Lnext, and eNew->Dst is a newly created vertex.
		* eOrg and eNew will have the same left face.
		*/
		// TESShalfEdge *tessMeshAddEdgeVertex( TESSmesh *mesh, TESShalfEdge *eOrg );
		addEdgeVertex: function(eOrg) {
			var eNew = this.makeEdge_( eOrg );
			var eNewSym = eNew.Sym;

			/* Connect the new edge appropriately */
			this.splice_( eNew, eOrg.Lnext );

			/* Set the vertex and face information */
			eNew.Org = eOrg.Dst;

			var newVertex = new TESSvertex();
			this.makeVertex_( newVertex, eNewSym, eNew.Org );

			eNew.Lface = eNewSym.Lface = eOrg.Lface;

			return eNew;
		},


		/* tessMeshSplitEdge( eOrg ) splits eOrg into two edges eOrg and eNew,
		* such that eNew == eOrg->Lnext.  The new vertex is eOrg->Dst == eNew->Org.
		* eOrg and eNew will have the same left face.
		*/
		// TESShalfEdge *tessMeshSplitEdge( TESSmesh *mesh, TESShalfEdge *eOrg );
		splitEdge: function(eOrg, eDst) {
			var tempHalfEdge = this.addEdgeVertex( eOrg );
			var eNew = tempHalfEdge.Sym;

			/* Disconnect eOrg from eOrg->Dst and connect it to eNew->Org */
			this.splice_( eOrg.Sym, eOrg.Sym.Oprev );
			this.splice_( eOrg.Sym, eNew );

			/* Set the vertex and face information */
			eOrg.Dst = eNew.Org;
			eNew.Dst.anEdge = eNew.Sym;	/* may have pointed to eOrg->Sym */
			eNew.Rface = eOrg.Rface;
			eNew.winding = eOrg.winding;	/* copy old winding information */
			eNew.Sym.winding = eOrg.Sym.winding;

			return eNew;
		},


		/* tessMeshConnect( eOrg, eDst ) creates a new edge from eOrg->Dst
		* to eDst->Org, and returns the corresponding half-edge eNew.
		* If eOrg->Lface == eDst->Lface, this splits one loop into two,
		* and the newly created loop is eNew->Lface.  Otherwise, two disjoint
		* loops are merged into one, and the loop eDst->Lface is destroyed.
		*
		* If (eOrg == eDst), the new face will have only two edges.
		* If (eOrg->Lnext == eDst), the old face is reduced to a single edge.
		* If (eOrg->Lnext->Lnext == eDst), the old face is reduced to two edges.
		*/

		// TESShalfEdge *tessMeshConnect( TESSmesh *mesh, TESShalfEdge *eOrg, TESShalfEdge *eDst );
		connect: function(eOrg, eDst) {
			var joiningLoops = false;  
			var eNew = this.makeEdge_( eOrg );
			var eNewSym = eNew.Sym;

			if( eDst.Lface !== eOrg.Lface ) {
				/* We are connecting two disjoint loops -- destroy eDst->Lface */
				joiningLoops = true;
				this.killFace_( eDst.Lface, eOrg.Lface );
			}

			/* Connect the new edge appropriately */
			this.splice_( eNew, eOrg.Lnext );
			this.splice_( eNewSym, eDst );

			/* Set the vertex and face information */
			eNew.Org = eOrg.Dst;
			eNewSym.Org = eDst.Org;
			eNew.Lface = eNewSym.Lface = eOrg.Lface;

			/* Make sure the old face points to a valid half-edge */
			eOrg.Lface.anEdge = eNewSym;

			if( ! joiningLoops ) {
				var newFace = new TESSface();
				/* We split one loop into two -- the new loop is eNew->Lface */
				this.makeFace_( newFace, eNew, eOrg.Lface );
			}
			return eNew;
		},

		/* tessMeshZapFace( fZap ) destroys a face and removes it from the
		* global face list.  All edges of fZap will have a NULL pointer as their
		* left face.  Any edges which also have a NULL pointer as their right face
		* are deleted entirely (along with any isolated vertices this produces).
		* An entire mesh can be deleted by zapping its faces, one at a time,
		* in any order.  Zapped faces cannot be used in further mesh operations!
		*/
		zapFace: function( fZap )
		{
			var eStart = fZap.anEdge;
			var e, eNext, eSym;
			var fPrev, fNext;

			/* walk around face, deleting edges whose right face is also NULL */
			eNext = eStart.Lnext;
			do {
				e = eNext;
				eNext = e.Lnext;

				e.Lface = null;
				if( e.Rface === null ) {
					/* delete the edge -- see TESSmeshDelete above */

					if( e.Onext === e ) {
						this.killVertex_( e.Org, null );
					} else {
						/* Make sure that e->Org points to a valid half-edge */
						e.Org.anEdge = e.Onext;
						this.splice_( e, e.Oprev );
					}
					eSym = e.Sym;
					if( eSym.Onext === eSym ) {
						this.killVertex_( eSym.Org, null );
					} else {
						/* Make sure that eSym->Org points to a valid half-edge */
						eSym.Org.anEdge = eSym.Onext;
						this.splice_( eSym, eSym.Oprev );
					}
					this.killEdge_( e );
				}
			} while( e != eStart );

			/* delete from circular doubly-linked list */
			fPrev = fZap.prev;
			fNext = fZap.next;
			fNext.prev = fPrev;
			fPrev.next = fNext;
		},

		countFaceVerts_: function(f) {
			var eCur = f.anEdge;
			var n = 0;
			do
			{
				n++;
				eCur = eCur.Lnext;
			}
			while (eCur !== f.anEdge);
			return n;
		},

		//int tessMeshMergeConvexFaces( TESSmesh *mesh, int maxVertsPerFace )
		mergeConvexFaces: function(maxVertsPerFace) {
			var f;
			var eCur, eNext, eSym;
			var vStart;
			var curNv, symNv;

			for( f = this.fHead.next; f !== this.fHead; f = f.next )
			{
				// Skip faces which are outside the result.
				if( !f.inside )
					continue;

				eCur = f.anEdge;
				vStart = eCur.Org;
					
				while (true)
				{
					eNext = eCur.Lnext;
					eSym = eCur.Sym;

					// Try to merge if the neighbour face is valid.
					if( eSym && eSym.Lface && eSym.Lface.inside )
					{
						// Try to merge the neighbour faces if the resulting polygons
						// does not exceed maximum number of vertices.
						curNv = this.countFaceVerts_( f );
						symNv = this.countFaceVerts_( eSym.Lface );
						if( (curNv+symNv-2) <= maxVertsPerFace )
						{
							// Merge if the resulting poly is convex.
							if( Geom.vertCCW( eCur.Lprev.Org, eCur.Org, eSym.Lnext.Lnext.Org ) &&
								Geom.vertCCW( eSym.Lprev.Org, eSym.Org, eCur.Lnext.Lnext.Org ) )
							{
								eNext = eSym.Lnext;
								this.delete( eSym );
								eCur = null;
								eSym = null;
							}
						}
					}
					
					if( eCur && eCur.Lnext.Org === vStart )
						break;
						
					// Continue to next edge.
					eCur = eNext;
				}
			}
			
			return true;
		},

		/* tessMeshCheckMesh( mesh ) checks a mesh for self-consistency.
		*/
		check: function() {
			var fHead = this.fHead;
			var vHead = this.vHead;
			var eHead = this.eHead;
			var f, fPrev, v, vPrev, e, ePrev;

			fPrev = fHead;
			for( fPrev = fHead ; (f = fPrev.next) !== fHead; fPrev = f) {
				assert( f.prev === fPrev );
				e = f.anEdge;
				do {
					assert( e.Sym !== e );
					assert( e.Sym.Sym === e );
					assert( e.Lnext.Onext.Sym === e );
					assert( e.Onext.Sym.Lnext === e );
					assert( e.Lface === f );
					e = e.Lnext;
				} while( e !== f.anEdge );
			}
			assert( f.prev === fPrev && f.anEdge === null );

			vPrev = vHead;
			for( vPrev = vHead ; (v = vPrev.next) !== vHead; vPrev = v) {
				assert( v.prev === vPrev );
				e = v.anEdge;
				do {
					assert( e.Sym !== e );
					assert( e.Sym.Sym === e );
					assert( e.Lnext.Onext.Sym === e );
					assert( e.Onext.Sym.Lnext === e );
					assert( e.Org === v );
					e = e.Onext;
				} while( e !== v.anEdge );
			}
			assert( v.prev === vPrev && v.anEdge === null );

			ePrev = eHead;
			for( ePrev = eHead ; (e = ePrev.next) !== eHead; ePrev = e) {
				assert( e.Sym.next === ePrev.Sym );
				assert( e.Sym !== e );
				assert( e.Sym.Sym === e );
				assert( e.Org !== null );
				assert( e.Dst !== null );
				assert( e.Lnext.Onext.Sym === e );
				assert( e.Onext.Sym.Lnext === e );
			}
			assert( e.Sym.next === ePrev.Sym
				&& e.Sym === this.eHeadSym
				&& e.Sym.Sym === e
				&& e.Org === null && e.Dst === null
				&& e.Lface === null && e.Rface === null );
		}

	};

	var Geom = {};

	Geom.vertEq = function(u,v) {
		return (u.s === v.s && u.t === v.t);
	};

	/* Returns TRUE if u is lexicographically <= v. */
	Geom.vertLeq = function(u,v) {
		return ((u.s < v.s) || (u.s === v.s && u.t <= v.t));
	};

	/* Versions of VertLeq, EdgeSign, EdgeEval with s and t transposed. */
	Geom.transLeq = function(u,v) {
		return ((u.t < v.t) || (u.t === v.t && u.s <= v.s));
	};

	Geom.edgeGoesLeft = function(e) {
		return Geom.vertLeq( e.Dst, e.Org );
	};

	Geom.edgeGoesRight = function(e) {
		return Geom.vertLeq( e.Org, e.Dst );
	};

	Geom.vertL1dist = function(u,v) {
		return (Math.abs(u.s - v.s) + Math.abs(u.t - v.t));
	};

	//TESSreal tesedgeEval( TESSvertex *u, TESSvertex *v, TESSvertex *w )
	Geom.edgeEval = function( u, v, w ) {
		/* Given three vertices u,v,w such that VertLeq(u,v) && VertLeq(v,w),
		* evaluates the t-coord of the edge uw at the s-coord of the vertex v.
		* Returns v->t - (uw)(v->s), ie. the signed distance from uw to v.
		* If uw is vertical (and thus passes thru v), the result is zero.
		*
		* The calculation is extremely accurate and stable, even when v
		* is very close to u or w.  In particular if we set v->t = 0 and
		* let r be the negated result (this evaluates (uw)(v->s)), then
		* r is guaranteed to satisfy MIN(u->t,w->t) <= r <= MAX(u->t,w->t).
		*/
		assert( Geom.vertLeq( u, v ) && Geom.vertLeq( v, w ));

		var gapL = v.s - u.s;
		var gapR = w.s - v.s;

		if( gapL + gapR > 0.0 ) {
			if( gapL < gapR ) {
				return (v.t - u.t) + (u.t - w.t) * (gapL / (gapL + gapR));
			} else {
				return (v.t - w.t) + (w.t - u.t) * (gapR / (gapL + gapR));
			}
		}
		/* vertical line */
		return 0.0;
	};

	//TESSreal tesedgeSign( TESSvertex *u, TESSvertex *v, TESSvertex *w )
	Geom.edgeSign = function( u, v, w ) {
		/* Returns a number whose sign matches EdgeEval(u,v,w) but which
		* is cheaper to evaluate.  Returns > 0, == 0 , or < 0
		* as v is above, on, or below the edge uw.
		*/
		assert( Geom.vertLeq( u, v ) && Geom.vertLeq( v, w ));

		var gapL = v.s - u.s;
		var gapR = w.s - v.s;

		if( gapL + gapR > 0.0 ) {
			return (v.t - w.t) * gapL + (v.t - u.t) * gapR;
		}
		/* vertical line */
		return 0.0;
	};


	/***********************************************************************
	* Define versions of EdgeSign, EdgeEval with s and t transposed.
	*/

	//TESSreal testransEval( TESSvertex *u, TESSvertex *v, TESSvertex *w )
	Geom.transEval = function( u, v, w ) {
		/* Given three vertices u,v,w such that TransLeq(u,v) && TransLeq(v,w),
		* evaluates the t-coord of the edge uw at the s-coord of the vertex v.
		* Returns v->s - (uw)(v->t), ie. the signed distance from uw to v.
		* If uw is vertical (and thus passes thru v), the result is zero.
		*
		* The calculation is extremely accurate and stable, even when v
		* is very close to u or w.  In particular if we set v->s = 0 and
		* let r be the negated result (this evaluates (uw)(v->t)), then
		* r is guaranteed to satisfy MIN(u->s,w->s) <= r <= MAX(u->s,w->s).
		*/
		assert( Geom.transLeq( u, v ) && Geom.transLeq( v, w ));

		var gapL = v.t - u.t;
		var gapR = w.t - v.t;

		if( gapL + gapR > 0.0 ) {
			if( gapL < gapR ) {
				return (v.s - u.s) + (u.s - w.s) * (gapL / (gapL + gapR));
			} else {
				return (v.s - w.s) + (w.s - u.s) * (gapR / (gapL + gapR));
			}
		}
		/* vertical line */
		return 0.0;
	};

	//TESSreal testransSign( TESSvertex *u, TESSvertex *v, TESSvertex *w )
	Geom.transSign = function( u, v, w ) {
		/* Returns a number whose sign matches TransEval(u,v,w) but which
		* is cheaper to evaluate.  Returns > 0, == 0 , or < 0
		* as v is above, on, or below the edge uw.
		*/
		assert( Geom.transLeq( u, v ) && Geom.transLeq( v, w ));

		var gapL = v.t - u.t;
		var gapR = w.t - v.t;

		if( gapL + gapR > 0.0 ) {
			return (v.s - w.s) * gapL + (v.s - u.s) * gapR;
		}
		/* vertical line */
		return 0.0;
	};


	//int tesvertCCW( TESSvertex *u, TESSvertex *v, TESSvertex *w )
	Geom.vertCCW = function( u, v, w ) {
		/* For almost-degenerate situations, the results are not reliable.
		* Unless the floating-point arithmetic can be performed without
		* rounding errors, *any* implementation will give incorrect results
		* on some degenerate inputs, so the client must have some way to
		* handle this situation.
		*/
		return (u.s*(v.t - w.t) + v.s*(w.t - u.t) + w.s*(u.t - v.t)) >= 0.0;
	};

	/* Given parameters a,x,b,y returns the value (b*x+a*y)/(a+b),
	* or (x+y)/2 if a==b==0.  It requires that a,b >= 0, and enforces
	* this in the rare case that one argument is slightly negative.
	* The implementation is extremely stable numerically.
	* In particular it guarantees that the result r satisfies
	* MIN(x,y) <= r <= MAX(x,y), and the results are very accurate
	* even when a and b differ greatly in magnitude.
	*/
	Geom.interpolate = function(a,x,b,y) {
		return (a = (a < 0) ? 0 : a, b = (b < 0) ? 0 : b, ((a <= b) ? ((b == 0) ? ((x+y) / 2) : (x + (y-x) * (a/(a+b)))) : (y + (x-y) * (b/(a+b)))));
	};

	/*
	#ifndef FOR_TRITE_TEST_PROGRAM
	#define Interpolate(a,x,b,y)	RealInterpolate(a,x,b,y)
	#else

	// Claim: the ONLY property the sweep algorithm relies on is that
	// MIN(x,y) <= r <= MAX(x,y).  This is a nasty way to test that.
	#include <stdlib.h>
	extern int RandomInterpolate;

	double Interpolate( double a, double x, double b, double y)
	{
		printf("*********************%d\n",RandomInterpolate);
		if( RandomInterpolate ) {
			a = 1.2 * drand48() - 0.1;
			a = (a < 0) ? 0 : ((a > 1) ? 1 : a);
			b = 1.0 - a;
		}
		return RealInterpolate(a,x,b,y);
	}
	#endif*/

	Geom.intersect = function( o1, d1, o2, d2, v ) {
		/* Given edges (o1,d1) and (o2,d2), compute their point of intersection.
		* The computed point is guaranteed to lie in the intersection of the
		* bounding rectangles defined by each edge.
		*/
		var z1, z2;
		var t;

		/* This is certainly not the most efficient way to find the intersection
		* of two line segments, but it is very numerically stable.
		*
		* Strategy: find the two middle vertices in the VertLeq ordering,
		* and interpolate the intersection s-value from these.  Then repeat
		* using the TransLeq ordering to find the intersection t-value.
		*/

		if( ! Geom.vertLeq( o1, d1 )) { t = o1; o1 = d1; d1 = t; } //swap( o1, d1 ); }
		if( ! Geom.vertLeq( o2, d2 )) { t = o2; o2 = d2; d2 = t; } //swap( o2, d2 ); }
		if( ! Geom.vertLeq( o1, o2 )) { t = o1; o1 = o2; o2 = t; t = d1; d1 = d2; d2 = t; }//swap( o1, o2 ); swap( d1, d2 ); }

		if( ! Geom.vertLeq( o2, d1 )) {
			/* Technically, no intersection -- do our best */
			v.s = (o2.s + d1.s) / 2;
		} else if( Geom.vertLeq( d1, d2 )) {
			/* Interpolate between o2 and d1 */
			z1 = Geom.edgeEval( o1, o2, d1 );
			z2 = Geom.edgeEval( o2, d1, d2 );
			if( z1+z2 < 0 ) { z1 = -z1; z2 = -z2; }
			v.s = Geom.interpolate( z1, o2.s, z2, d1.s );
		} else {
			/* Interpolate between o2 and d2 */
			z1 = Geom.edgeSign( o1, o2, d1 );
			z2 = -Geom.edgeSign( o1, d2, d1 );
			if( z1+z2 < 0 ) { z1 = -z1; z2 = -z2; }
			v.s = Geom.interpolate( z1, o2.s, z2, d2.s );
		}

		/* Now repeat the process for t */

		if( ! Geom.transLeq( o1, d1 )) { t = o1; o1 = d1; d1 = t; } //swap( o1, d1 ); }
		if( ! Geom.transLeq( o2, d2 )) { t = o2; o2 = d2; d2 = t; } //swap( o2, d2 ); }
		if( ! Geom.transLeq( o1, o2 )) { t = o1; o1 = o2; o2 = t; t = d1; d1 = d2; d2 = t; } //swap( o1, o2 ); swap( d1, d2 ); }

		if( ! Geom.transLeq( o2, d1 )) {
			/* Technically, no intersection -- do our best */
			v.t = (o2.t + d1.t) / 2;
		} else if( Geom.transLeq( d1, d2 )) {
			/* Interpolate between o2 and d1 */
			z1 = Geom.transEval( o1, o2, d1 );
			z2 = Geom.transEval( o2, d1, d2 );
			if( z1+z2 < 0 ) { z1 = -z1; z2 = -z2; }
			v.t = Geom.interpolate( z1, o2.t, z2, d1.t );
		} else {
			/* Interpolate between o2 and d2 */
			z1 = Geom.transSign( o1, o2, d1 );
			z2 = -Geom.transSign( o1, d2, d1 );
			if( z1+z2 < 0 ) { z1 = -z1; z2 = -z2; }
			v.t = Geom.interpolate( z1, o2.t, z2, d2.t );
		}
	};



	function DictNode() {
		this.key = null;
		this.next = null;
		this.prev = null;
	};

	function Dict(frame, leq) {
		this.head = new DictNode();
		this.head.next = this.head;
		this.head.prev = this.head;
		this.frame = frame;
		this.leq = leq;
	};

	Dict.prototype = {
		min: function() {
			return this.head.next;
		},

		max: function() {
			return this.head.prev;
		},

		insert: function(k) {
			return this.insertBefore(this.head, k);
		},

		search: function(key) {
			/* Search returns the node with the smallest key greater than or equal
			* to the given key.  If there is no such key, returns a node whose
			* key is NULL.  Similarly, Succ(Max(d)) has a NULL key, etc.
			*/
			var node = this.head;
			do {
				node = node.next;
			} while( node.key !== null && ! this.leq(this.frame, key, node.key));

			return node;
		},

		insertBefore: function(node, key) {
			do {
				node = node.prev;
			} while( node.key !== null && ! this.leq(this.frame, node.key, key));

			var newNode = new DictNode();
			newNode.key = key;
			newNode.next = node.next;
			node.next.prev = newNode;
			newNode.prev = node;
			node.next = newNode;

			return newNode;
		},

		delete: function(node) {
			node.next.prev = node.prev;
			node.prev.next = node.next;
		}
	};


	function PQnode() {
		this.handle = null;
	}

	function PQhandleElem() {
		this.key = null;
		this.node = null;
	}

	function PriorityQ(size, leq) {
		this.size = 0;
		this.max = size;

		this.nodes = [];
		this.nodes.length = size+1;
		for (var i = 0; i < this.nodes.length; i++)
			this.nodes[i] = new PQnode();

		this.handles = [];
		this.handles.length = size+1;
		for (var i = 0; i < this.handles.length; i++)
			this.handles[i] = new PQhandleElem();

		this.initialized = false;
		this.freeList = 0;
		this.leq = leq;

		this.nodes[1].handle = 1;	/* so that Minimum() returns NULL */
		this.handles[1].key = null;
	};

	PriorityQ.prototype = {

		floatDown_: function( curr )
		{
			var n = this.nodes;
			var h = this.handles;
			var hCurr, hChild;
			var child;

			hCurr = n[curr].handle;
			for( ;; ) {
				child = curr << 1;
				if( child < this.size && this.leq( h[n[child+1].handle].key, h[n[child].handle].key )) {
					++child;
				}

				assert(child <= this.max);

				hChild = n[child].handle;
				if( child > this.size || this.leq( h[hCurr].key, h[hChild].key )) {
					n[curr].handle = hCurr;
					h[hCurr].node = curr;
					break;
				}
				n[curr].handle = hChild;
				h[hChild].node = curr;
				curr = child;
			}
		},

		floatUp_: function( curr )
		{
			var n = this.nodes;
			var h = this.handles;
			var hCurr, hParent;
			var parent;

			hCurr = n[curr].handle;
			for( ;; ) {
				parent = curr >> 1;
				hParent = n[parent].handle;
				if( parent == 0 || this.leq( h[hParent].key, h[hCurr].key )) {
					n[curr].handle = hCurr;
					h[hCurr].node = curr;
					break;
				}
				n[curr].handle = hParent;
				h[hParent].node = curr;
				curr = parent;
			}
		},

		init: function() {
			/* This method of building a heap is O(n), rather than O(n lg n). */
			for( var i = this.size; i >= 1; --i ) {
				this.floatDown_( i );
			}
			this.initialized = true;
		},

		min: function() {
			return this.handles[this.nodes[1].handle].key;
		},

		isEmpty: function() {
			this.size === 0;
		},

		/* really pqHeapInsert */
		/* returns INV_HANDLE iff out of memory */
		//PQhandle pqHeapInsert( TESSalloc* alloc, PriorityQHeap *pq, PQkey keyNew )
		insert: function(keyNew)
		{
			var curr;
			var free;

			curr = ++this.size;
			if( (curr*2) > this.max ) {
				this.max *= 2;
				var s;
				s = this.nodes.length;
				this.nodes.length = this.max+1;
				for (var i = s; i < this.nodes.length; i++)
					this.nodes[i] = new PQnode();

				s = this.handles.length;
				this.handles.length = this.max+1;
				for (var i = s; i < this.handles.length; i++)
					this.handles[i] = new PQhandleElem();
			}

			if( this.freeList === 0 ) {
				free = curr;
			} else {
				free = this.freeList;
				this.freeList = this.handles[free].node;
			}

			this.nodes[curr].handle = free;
			this.handles[free].node = curr;
			this.handles[free].key = keyNew;

			if( this.initialized ) {
				this.floatUp_( curr );
			}
			return free;
		},

		//PQkey pqHeapExtractMin( PriorityQHeap *pq )
		extractMin: function() {
			var n = this.nodes;
			var h = this.handles;
			var hMin = n[1].handle;
			var min = h[hMin].key;

			if( this.size > 0 ) {
				n[1].handle = n[this.size].handle;
				h[n[1].handle].node = 1;

				h[hMin].key = null;
				h[hMin].node = this.freeList;
				this.freeList = hMin;

				--this.size;
				if( this.size > 0 ) {
					this.floatDown_( 1 );
				}
			}
			return min;
		},

		delete: function( hCurr ) {
			var n = this.nodes;
			var h = this.handles;
			var curr;

			assert( hCurr >= 1 && hCurr <= this.max && h[hCurr].key !== null );

			curr = h[hCurr].node;
			n[curr].handle = n[this.size].handle;
			h[n[curr].handle].node = curr;

			--this.size;
			if( curr <= this.size ) {
				if( curr <= 1 || this.leq( h[n[curr>>1].handle].key, h[n[curr].handle].key )) {
					this.floatDown_( curr );
				} else {
					this.floatUp_( curr );
				}
			}
			h[hCurr].key = null;
			h[hCurr].node = this.freeList;
			this.freeList = hCurr;
		}
	};


	/* For each pair of adjacent edges crossing the sweep line, there is
	* an ActiveRegion to represent the region between them.  The active
	* regions are kept in sorted order in a dynamic dictionary.  As the
	* sweep line crosses each vertex, we update the affected regions.
	*/

	function ActiveRegion() {
		this.eUp = null;		/* upper edge, directed right to left */
		this.nodeUp = null;	/* dictionary node corresponding to eUp */
		this.windingNumber = 0;	/* used to determine which regions are
								* inside the polygon */
		this.inside = false;		/* is this region inside the polygon? */
		this.sentinel = false;	/* marks fake edges at t = +/-infinity */
		this.dirty = false;		/* marks regions where the upper or lower
						* edge has changed, but we haven't checked
						* whether they intersect yet */
		this.fixUpperEdge = false;	/* marks temporary edges introduced when
							* we process a "right vertex" (one without
							* any edges leaving to the right) */
	};

	var Sweep = {};

	Sweep.regionBelow = function(r) {
		return r.nodeUp.prev.key;
	}

	Sweep.regionAbove = function(r) {
		return r.nodeUp.next.key;
	}

	Sweep.debugEvent = function( tess ) {
		// empty
	}


	/*
	* Invariants for the Edge Dictionary.
	* - each pair of adjacent edges e2=Succ(e1) satisfies EdgeLeq(e1,e2)
	*   at any valid location of the sweep event
	* - if EdgeLeq(e2,e1) as well (at any valid sweep event), then e1 and e2
	*   share a common endpoint
	* - for each e, e->Dst has been processed, but not e->Org
	* - each edge e satisfies VertLeq(e->Dst,event) && VertLeq(event,e->Org)
	*   where "event" is the current sweep line event.
	* - no edge e has zero length
	*
	* Invariants for the Mesh (the processed portion).
	* - the portion of the mesh left of the sweep line is a planar graph,
	*   ie. there is *some* way to embed it in the plane
	* - no processed edge has zero length
	* - no two processed vertices have identical coordinates
	* - each "inside" region is monotone, ie. can be broken into two chains
	*   of monotonically increasing vertices according to VertLeq(v1,v2)
	*   - a non-invariant: these chains may intersect (very slightly)
	*
	* Invariants for the Sweep.
	* - if none of the edges incident to the event vertex have an activeRegion
	*   (ie. none of these edges are in the edge dictionary), then the vertex
	*   has only right-going edges.
	* - if an edge is marked "fixUpperEdge" (it is a temporary edge introduced
	*   by ConnectRightVertex), then it is the only right-going edge from
	*   its associated vertex.  (This says that these edges exist only
	*   when it is necessary.)
	*/

	/* When we merge two edges into one, we need to compute the combined
	* winding of the new edge.
	*/
	Sweep.addWinding = function(eDst,eSrc) {
		eDst.winding += eSrc.winding;
		eDst.Sym.winding += eSrc.Sym.winding;
	}


	//static int EdgeLeq( TESStesselator *tess, ActiveRegion *reg1, ActiveRegion *reg2 )
	Sweep.edgeLeq = function( tess, reg1, reg2 ) {
		/*
		* Both edges must be directed from right to left (this is the canonical
		* direction for the upper edge of each region).
		*
		* The strategy is to evaluate a "t" value for each edge at the
		* current sweep line position, given by tess->event.  The calculations
		* are designed to be very stable, but of course they are not perfect.
		*
		* Special case: if both edge destinations are at the sweep event,
		* we sort the edges by slope (they would otherwise compare equally).
		*/
		var ev = tess.event;
		var t1, t2;

		var e1 = reg1.eUp;
		var e2 = reg2.eUp;

		if( e1.Dst === ev ) {
			if( e2.Dst === ev ) {
				/* Two edges right of the sweep line which meet at the sweep event.
				* Sort them by slope.
				*/
				if( Geom.vertLeq( e1.Org, e2.Org )) {
					return Geom.edgeSign( e2.Dst, e1.Org, e2.Org ) <= 0;
				}
				return Geom.edgeSign( e1.Dst, e2.Org, e1.Org ) >= 0;
			}
			return Geom.edgeSign( e2.Dst, ev, e2.Org ) <= 0;
		}
		if( e2.Dst === ev ) {
			return Geom.edgeSign( e1.Dst, ev, e1.Org ) >= 0;
		}

		/* General case - compute signed distance *from* e1, e2 to event */
		var t1 = Geom.edgeEval( e1.Dst, ev, e1.Org );
		var t2 = Geom.edgeEval( e2.Dst, ev, e2.Org );
		return (t1 >= t2);
	}


	//static void DeleteRegion( TESStesselator *tess, ActiveRegion *reg )
	Sweep.deleteRegion = function( tess, reg ) {
		if( reg.fixUpperEdge ) {
			/* It was created with zero winding number, so it better be
			* deleted with zero winding number (ie. it better not get merged
			* with a real edge).
			*/
			assert( reg.eUp.winding === 0 );
		}
		reg.eUp.activeRegion = null;
		tess.dict.delete( reg.nodeUp );
	}

	//static int FixUpperEdge( TESStesselator *tess, ActiveRegion *reg, TESShalfEdge *newEdge )
	Sweep.fixUpperEdge = function( tess, reg, newEdge ) {
		/*
		* Replace an upper edge which needs fixing (see ConnectRightVertex).
		*/
		assert( reg.fixUpperEdge );
		tess.mesh.delete( reg.eUp );
		reg.fixUpperEdge = false;
		reg.eUp = newEdge;
		newEdge.activeRegion = reg;
	}

	//static ActiveRegion *TopLeftRegion( TESStesselator *tess, ActiveRegion *reg )
	Sweep.topLeftRegion = function( tess, reg ) {
		var org = reg.eUp.Org;
		var e;

		/* Find the region above the uppermost edge with the same origin */
		do {
			reg = Sweep.regionAbove( reg );
		} while( reg.eUp.Org === org );

		/* If the edge above was a temporary edge introduced by ConnectRightVertex,
		* now is the time to fix it.
		*/
		if( reg.fixUpperEdge ) {
			e = tess.mesh.connect( Sweep.regionBelow(reg).eUp.Sym, reg.eUp.Lnext );
			if (e === null) return null;
			Sweep.fixUpperEdge( tess, reg, e );
			reg = Sweep.regionAbove( reg );
		}
		return reg;
	}

	//static ActiveRegion *TopRightRegion( ActiveRegion *reg )
	Sweep.topRightRegion = function( reg )
	{
		var dst = reg.eUp.Dst;
		var reg = null;
		/* Find the region above the uppermost edge with the same destination */
		do {
			reg = Sweep.regionAbove( reg );
		} while( reg.eUp.Dst === dst );
		return reg;
	}

	//static ActiveRegion *AddRegionBelow( TESStesselator *tess, ActiveRegion *regAbove, TESShalfEdge *eNewUp )
	Sweep.addRegionBelow = function( tess, regAbove, eNewUp ) {
		/*
		* Add a new active region to the sweep line, *somewhere* below "regAbove"
		* (according to where the new edge belongs in the sweep-line dictionary).
		* The upper edge of the new region will be "eNewUp".
		* Winding number and "inside" flag are not updated.
		*/
		var regNew = new ActiveRegion();
		regNew.eUp = eNewUp;
		regNew.nodeUp = tess.dict.insertBefore( regAbove.nodeUp, regNew );
	//	if (regNew->nodeUp == NULL) longjmp(tess->env,1);
		regNew.fixUpperEdge = false;
		regNew.sentinel = false;
		regNew.dirty = false;

		eNewUp.activeRegion = regNew;
		return regNew;
	}

	//static int IsWindingInside( TESStesselator *tess, int n )
	Sweep.isWindingInside = function( tess, n ) {
		switch( tess.windingRule ) {
			case Tess2.WINDING_ODD:
				return (n & 1) != 0;
			case Tess2.WINDING_NONZERO:
				return (n != 0);
			case Tess2.WINDING_POSITIVE:
				return (n > 0);
			case Tess2.WINDING_NEGATIVE:
				return (n < 0);
			case Tess2.WINDING_ABS_GEQ_TWO:
				return (n >= 2) || (n <= -2);
		}
		assert( false );
		return false;
	}

	//static void ComputeWinding( TESStesselator *tess, ActiveRegion *reg )
	Sweep.computeWinding = function( tess, reg ) {
		reg.windingNumber = Sweep.regionAbove(reg).windingNumber + reg.eUp.winding;
		reg.inside = Sweep.isWindingInside( tess, reg.windingNumber );
	}


	//static void FinishRegion( TESStesselator *tess, ActiveRegion *reg )
	Sweep.finishRegion = function( tess, reg ) {
		/*
		* Delete a region from the sweep line.  This happens when the upper
		* and lower chains of a region meet (at a vertex on the sweep line).
		* The "inside" flag is copied to the appropriate mesh face (we could
		* not do this before -- since the structure of the mesh is always
		* changing, this face may not have even existed until now).
		*/
		var e = reg.eUp;
		var f = e.Lface;

		f.inside = reg.inside;
		f.anEdge = e;   /* optimization for tessMeshTessellateMonoRegion() */
		Sweep.deleteRegion( tess, reg );
	}


	//static TESShalfEdge *FinishLeftRegions( TESStesselator *tess, ActiveRegion *regFirst, ActiveRegion *regLast )
	Sweep.finishLeftRegions = function( tess, regFirst, regLast ) {
		/*
		* We are given a vertex with one or more left-going edges.  All affected
		* edges should be in the edge dictionary.  Starting at regFirst->eUp,
		* we walk down deleting all regions where both edges have the same
		* origin vOrg.  At the same time we copy the "inside" flag from the
		* active region to the face, since at this point each face will belong
		* to at most one region (this was not necessarily true until this point
		* in the sweep).  The walk stops at the region above regLast; if regLast
		* is NULL we walk as far as possible.  At the same time we relink the
		* mesh if necessary, so that the ordering of edges around vOrg is the
		* same as in the dictionary.
		*/
		var e, ePrev;
		var reg = null;
		var regPrev = regFirst;
		var ePrev = regFirst.eUp;
		while( regPrev !== regLast ) {
			regPrev.fixUpperEdge = false;	/* placement was OK */
			reg = Sweep.regionBelow( regPrev );
			e = reg.eUp;
			if( e.Org != ePrev.Org ) {
				if( ! reg.fixUpperEdge ) {
					/* Remove the last left-going edge.  Even though there are no further
					* edges in the dictionary with this origin, there may be further
					* such edges in the mesh (if we are adding left edges to a vertex
					* that has already been processed).  Thus it is important to call
					* FinishRegion rather than just DeleteRegion.
					*/
					Sweep.finishRegion( tess, regPrev );
					break;
				}
				/* If the edge below was a temporary edge introduced by
				* ConnectRightVertex, now is the time to fix it.
				*/
				e = tess.mesh.connect( ePrev.Lprev, e.Sym );
	//			if (e == NULL) longjmp(tess->env,1);
				Sweep.fixUpperEdge( tess, reg, e );
			}

			/* Relink edges so that ePrev->Onext == e */
			if( ePrev.Onext !== e ) {
				tess.mesh.splice( e.Oprev, e );
				tess.mesh.splice( ePrev, e );
			}
			Sweep.finishRegion( tess, regPrev );	/* may change reg->eUp */
			ePrev = reg.eUp;
			regPrev = reg;
		}
		return ePrev;
	}


	//static void AddRightEdges( TESStesselator *tess, ActiveRegion *regUp, TESShalfEdge *eFirst, TESShalfEdge *eLast, TESShalfEdge *eTopLeft, int cleanUp )
	Sweep.addRightEdges = function( tess, regUp, eFirst, eLast, eTopLeft, cleanUp ) {
		/*
		* Purpose: insert right-going edges into the edge dictionary, and update
		* winding numbers and mesh connectivity appropriately.  All right-going
		* edges share a common origin vOrg.  Edges are inserted CCW starting at
		* eFirst; the last edge inserted is eLast->Oprev.  If vOrg has any
		* left-going edges already processed, then eTopLeft must be the edge
		* such that an imaginary upward vertical segment from vOrg would be
		* contained between eTopLeft->Oprev and eTopLeft; otherwise eTopLeft
		* should be NULL.
		*/
		var reg, regPrev;
		var e, ePrev;
		var firstTime = true;

		/* Insert the new right-going edges in the dictionary */
		e = eFirst;
		do {
			assert( Geom.vertLeq( e.Org, e.Dst ));
			Sweep.addRegionBelow( tess, regUp, e.Sym );
			e = e.Onext;
		} while ( e !== eLast );

		/* Walk *all* right-going edges from e->Org, in the dictionary order,
		* updating the winding numbers of each region, and re-linking the mesh
		* edges to match the dictionary ordering (if necessary).
		*/
		if( eTopLeft === null ) {
			eTopLeft = Sweep.regionBelow( regUp ).eUp.Rprev;
		}
		regPrev = regUp;
		ePrev = eTopLeft;
		for( ;; ) {
			reg = Sweep.regionBelow( regPrev );
			e = reg.eUp.Sym;
			if( e.Org !== ePrev.Org ) break;

			if( e.Onext !== ePrev ) {
				/* Unlink e from its current position, and relink below ePrev */
				tess.mesh.splice( e.Oprev, e );
				tess.mesh.splice( ePrev.Oprev, e );
			}
			/* Compute the winding number and "inside" flag for the new regions */
			reg.windingNumber = regPrev.windingNumber - e.winding;
			reg.inside = Sweep.isWindingInside( tess, reg.windingNumber );

			/* Check for two outgoing edges with same slope -- process these
			* before any intersection tests (see example in tessComputeInterior).
			*/
			regPrev.dirty = true;
			if( ! firstTime && Sweep.checkForRightSplice( tess, regPrev )) {
				Sweep.addWinding( e, ePrev );
				Sweep.deleteRegion( tess, regPrev );
				tess.mesh.delete( ePrev );
			}
			firstTime = false;
			regPrev = reg;
			ePrev = e;
		}
		regPrev.dirty = true;
		assert( regPrev.windingNumber - e.winding === reg.windingNumber );

		if( cleanUp ) {
			/* Check for intersections between newly adjacent edges. */
			Sweep.walkDirtyRegions( tess, regPrev );
		}
	}


	//static void SpliceMergeVertices( TESStesselator *tess, TESShalfEdge *e1, TESShalfEdge *e2 )
	Sweep.spliceMergeVertices = function( tess, e1, e2 ) {
		/*
		* Two vertices with idential coordinates are combined into one.
		* e1->Org is kept, while e2->Org is discarded.
		*/
		tess.mesh.splice( e1, e2 ); 
	}

	//static void VertexWeights( TESSvertex *isect, TESSvertex *org, TESSvertex *dst, TESSreal *weights )
	Sweep.vertexWeights = function( isect, org, dst ) {
		/*
		* Find some weights which describe how the intersection vertex is
		* a linear combination of "org" and "dest".  Each of the two edges
		* which generated "isect" is allocated 50% of the weight; each edge
		* splits the weight between its org and dst according to the
		* relative distance to "isect".
		*/
		var t1 = Geom.vertL1dist( org, isect );
		var t2 = Geom.vertL1dist( dst, isect );
		var w0 = 0.5 * t2 / (t1 + t2);
		var w1 = 0.5 * t1 / (t1 + t2);
		isect.coords[0] += w0*org.coords[0] + w1*dst.coords[0];
		isect.coords[1] += w0*org.coords[1] + w1*dst.coords[1];
		isect.coords[2] += w0*org.coords[2] + w1*dst.coords[2];
	}


	//static void GetIntersectData( TESStesselator *tess, TESSvertex *isect, TESSvertex *orgUp, TESSvertex *dstUp, TESSvertex *orgLo, TESSvertex *dstLo )
	Sweep.getIntersectData = function( tess, isect, orgUp, dstUp, orgLo, dstLo ) {
		 /*
		 * We've computed a new intersection point, now we need a "data" pointer
		 * from the user so that we can refer to this new vertex in the
		 * rendering callbacks.
		 */
		isect.coords[0] = isect.coords[1] = isect.coords[2] = 0;
		isect.idx = -1;
		Sweep.vertexWeights( isect, orgUp, dstUp );
		Sweep.vertexWeights( isect, orgLo, dstLo );
	}

	//static int CheckForRightSplice( TESStesselator *tess, ActiveRegion *regUp )
	Sweep.checkForRightSplice = function( tess, regUp ) {
		/*
		* Check the upper and lower edge of "regUp", to make sure that the
		* eUp->Org is above eLo, or eLo->Org is below eUp (depending on which
		* origin is leftmost).
		*
		* The main purpose is to splice right-going edges with the same
		* dest vertex and nearly identical slopes (ie. we can't distinguish
		* the slopes numerically).  However the splicing can also help us
		* to recover from numerical errors.  For example, suppose at one
		* point we checked eUp and eLo, and decided that eUp->Org is barely
		* above eLo.  Then later, we split eLo into two edges (eg. from
		* a splice operation like this one).  This can change the result of
		* our test so that now eUp->Org is incident to eLo, or barely below it.
		* We must correct this condition to maintain the dictionary invariants.
		*
		* One possibility is to check these edges for intersection again
		* (ie. CheckForIntersect).  This is what we do if possible.  However
		* CheckForIntersect requires that tess->event lies between eUp and eLo,
		* so that it has something to fall back on when the intersection
		* calculation gives us an unusable answer.  So, for those cases where
		* we can't check for intersection, this routine fixes the problem
		* by just splicing the offending vertex into the other edge.
		* This is a guaranteed solution, no matter how degenerate things get.
		* Basically this is a combinatorial solution to a numerical problem.
		*/
		var regLo = Sweep.regionBelow(regUp);
		var eUp = regUp.eUp;
		var eLo = regLo.eUp;

		if( Geom.vertLeq( eUp.Org, eLo.Org )) {
			if( Geom.edgeSign( eLo.Dst, eUp.Org, eLo.Org ) > 0 ) return false;

			/* eUp->Org appears to be below eLo */
			if( ! Geom.vertEq( eUp.Org, eLo.Org )) {
				/* Splice eUp->Org into eLo */
				tess.mesh.splitEdge( eLo.Sym );
				tess.mesh.splice( eUp, eLo.Oprev );
				regUp.dirty = regLo.dirty = true;

			} else if( eUp.Org !== eLo.Org ) {
				/* merge the two vertices, discarding eUp->Org */
				tess.pq.delete( eUp.Org.pqHandle );
				Sweep.spliceMergeVertices( tess, eLo.Oprev, eUp );
			}
		} else {
			if( Geom.edgeSign( eUp.Dst, eLo.Org, eUp.Org ) < 0 ) return false;

			/* eLo->Org appears to be above eUp, so splice eLo->Org into eUp */
			Sweep.regionAbove(regUp).dirty = regUp.dirty = true;
			tess.mesh.splitEdge( eUp.Sym );
			tess.mesh.splice( eLo.Oprev, eUp );
		}
		return true;
	}

	//static int CheckForLeftSplice( TESStesselator *tess, ActiveRegion *regUp )
	Sweep.checkForLeftSplice = function( tess, regUp ) {
		/*
		* Check the upper and lower edge of "regUp", to make sure that the
		* eUp->Dst is above eLo, or eLo->Dst is below eUp (depending on which
		* destination is rightmost).
		*
		* Theoretically, this should always be true.  However, splitting an edge
		* into two pieces can change the results of previous tests.  For example,
		* suppose at one point we checked eUp and eLo, and decided that eUp->Dst
		* is barely above eLo.  Then later, we split eLo into two edges (eg. from
		* a splice operation like this one).  This can change the result of
		* the test so that now eUp->Dst is incident to eLo, or barely below it.
		* We must correct this condition to maintain the dictionary invariants
		* (otherwise new edges might get inserted in the wrong place in the
		* dictionary, and bad stuff will happen).
		*
		* We fix the problem by just splicing the offending vertex into the
		* other edge.
		*/
		var regLo = Sweep.regionBelow(regUp);
		var eUp = regUp.eUp;
		var eLo = regLo.eUp;
		var e;

		assert( ! Geom.vertEq( eUp.Dst, eLo.Dst ));

		if( Geom.vertLeq( eUp.Dst, eLo.Dst )) {
			if( Geom.edgeSign( eUp.Dst, eLo.Dst, eUp.Org ) < 0 ) return false;

			/* eLo->Dst is above eUp, so splice eLo->Dst into eUp */
			Sweep.regionAbove(regUp).dirty = regUp.dirty = true;
			e = tess.mesh.splitEdge( eUp );
			tess.mesh.splice( eLo.Sym, e );
			e.Lface.inside = regUp.inside;
		} else {
			if( Geom.edgeSign( eLo.Dst, eUp.Dst, eLo.Org ) > 0 ) return false;

			/* eUp->Dst is below eLo, so splice eUp->Dst into eLo */
			regUp.dirty = regLo.dirty = true;
			e = tess.mesh.splitEdge( eLo );
			tess.mesh.splice( eUp.Lnext, eLo.Sym );
			e.Rface.inside = regUp.inside;
		}
		return true;
	}


	//static int CheckForIntersect( TESStesselator *tess, ActiveRegion *regUp )
	Sweep.checkForIntersect = function( tess, regUp ) {
		/*
		* Check the upper and lower edges of the given region to see if
		* they intersect.  If so, create the intersection and add it
		* to the data structures.
		*
		* Returns TRUE if adding the new intersection resulted in a recursive
		* call to AddRightEdges(); in this case all "dirty" regions have been
		* checked for intersections, and possibly regUp has been deleted.
		*/
		var regLo = Sweep.regionBelow(regUp);
		var eUp = regUp.eUp;
		var eLo = regLo.eUp;
		var orgUp = eUp.Org;
		var orgLo = eLo.Org;
		var dstUp = eUp.Dst;
		var dstLo = eLo.Dst;
		var tMinUp, tMaxLo;
		var isect = new TESSvertex, orgMin;
		var e;

		assert( ! Geom.vertEq( dstLo, dstUp ));
		assert( Geom.edgeSign( dstUp, tess.event, orgUp ) <= 0 );
		assert( Geom.edgeSign( dstLo, tess.event, orgLo ) >= 0 );
		assert( orgUp !== tess.event && orgLo !== tess.event );
		assert( ! regUp.fixUpperEdge && ! regLo.fixUpperEdge );

		if( orgUp === orgLo ) return false;	/* right endpoints are the same */

		tMinUp = Math.min( orgUp.t, dstUp.t );
		tMaxLo = Math.max( orgLo.t, dstLo.t );
		if( tMinUp > tMaxLo ) return false;	/* t ranges do not overlap */

		if( Geom.vertLeq( orgUp, orgLo )) {
			if( Geom.edgeSign( dstLo, orgUp, orgLo ) > 0 ) return false;
		} else {
			if( Geom.edgeSign( dstUp, orgLo, orgUp ) < 0 ) return false;
		}

		/* At this point the edges intersect, at least marginally */
		Sweep.debugEvent( tess );

		Geom.intersect( dstUp, orgUp, dstLo, orgLo, isect );
		/* The following properties are guaranteed: */
		assert( Math.min( orgUp.t, dstUp.t ) <= isect.t );
		assert( isect.t <= Math.max( orgLo.t, dstLo.t ));
		assert( Math.min( dstLo.s, dstUp.s ) <= isect.s );
		assert( isect.s <= Math.max( orgLo.s, orgUp.s ));

		if( Geom.vertLeq( isect, tess.event )) {
			/* The intersection point lies slightly to the left of the sweep line,
			* so move it until it''s slightly to the right of the sweep line.
			* (If we had perfect numerical precision, this would never happen
			* in the first place).  The easiest and safest thing to do is
			* replace the intersection by tess->event.
			*/
			isect.s = tess.event.s;
			isect.t = tess.event.t;
		}
		/* Similarly, if the computed intersection lies to the right of the
		* rightmost origin (which should rarely happen), it can cause
		* unbelievable inefficiency on sufficiently degenerate inputs.
		* (If you have the test program, try running test54.d with the
		* "X zoom" option turned on).
		*/
		orgMin = Geom.vertLeq( orgUp, orgLo ) ? orgUp : orgLo;
		if( Geom.vertLeq( orgMin, isect )) {
			isect.s = orgMin.s;
			isect.t = orgMin.t;
		}

		if( Geom.vertEq( isect, orgUp ) || Geom.vertEq( isect, orgLo )) {
			/* Easy case -- intersection at one of the right endpoints */
			Sweep.checkForRightSplice( tess, regUp );
			return false;
		}

		if(    (! Geom.vertEq( dstUp, tess.event )
			&& Geom.edgeSign( dstUp, tess.event, isect ) >= 0)
			|| (! Geom.vertEq( dstLo, tess.event )
			&& Geom.edgeSign( dstLo, tess.event, isect ) <= 0 ))
		{
			/* Very unusual -- the new upper or lower edge would pass on the
			* wrong side of the sweep event, or through it.  This can happen
			* due to very small numerical errors in the intersection calculation.
			*/
			if( dstLo === tess.event ) {
				/* Splice dstLo into eUp, and process the new region(s) */
				tess.mesh.splitEdge( eUp.Sym );
				tess.mesh.splice( eLo.Sym, eUp );
				regUp = Sweep.topLeftRegion( tess, regUp );
	//			if (regUp == NULL) longjmp(tess->env,1);
				eUp = Sweep.regionBelow(regUp).eUp;
				Sweep.finishLeftRegions( tess, Sweep.regionBelow(regUp), regLo );
				Sweep.addRightEdges( tess, regUp, eUp.Oprev, eUp, eUp, true );
				return TRUE;
			}
			if( dstUp === tess.event ) {
				/* Splice dstUp into eLo, and process the new region(s) */
				tess.mesh.splitEdge( eLo.Sym );
				tess.mesh.splice( eUp.Lnext, eLo.Oprev ); 
				regLo = regUp;
				regUp = Sweep.topRightRegion( regUp );
				e = Sweep.regionBelow(regUp).eUp.Rprev;
				regLo.eUp = eLo.Oprev;
				eLo = Sweep.finishLeftRegions( tess, regLo, null );
				Sweep.addRightEdges( tess, regUp, eLo.Onext, eUp.Rprev, e, true );
				return true;
			}
			/* Special case: called from ConnectRightVertex.  If either
			* edge passes on the wrong side of tess->event, split it
			* (and wait for ConnectRightVertex to splice it appropriately).
			*/
			if( Geom.edgeSign( dstUp, tess.event, isect ) >= 0 ) {
				Sweep.regionAbove(regUp).dirty = regUp.dirty = true;
				tess.mesh.splitEdge( eUp.Sym );
				eUp.Org.s = tess.event.s;
				eUp.Org.t = tess.event.t;
			}
			if( Geom.edgeSign( dstLo, tess.event, isect ) <= 0 ) {
				regUp.dirty = regLo.dirty = true;
				tess.mesh.splitEdge( eLo.Sym );
				eLo.Org.s = tess.event.s;
				eLo.Org.t = tess.event.t;
			}
			/* leave the rest for ConnectRightVertex */
			return false;
		}

		/* General case -- split both edges, splice into new vertex.
		* When we do the splice operation, the order of the arguments is
		* arbitrary as far as correctness goes.  However, when the operation
		* creates a new face, the work done is proportional to the size of
		* the new face.  We expect the faces in the processed part of
		* the mesh (ie. eUp->Lface) to be smaller than the faces in the
		* unprocessed original contours (which will be eLo->Oprev->Lface).
		*/
		tess.mesh.splitEdge( eUp.Sym );
		tess.mesh.splitEdge( eLo.Sym );
		tess.mesh.splice( eLo.Oprev, eUp );
		eUp.Org.s = isect.s;
		eUp.Org.t = isect.t;
		eUp.Org.pqHandle = tess.pq.insert( eUp.Org );
		Sweep.getIntersectData( tess, eUp.Org, orgUp, dstUp, orgLo, dstLo );
		Sweep.regionAbove(regUp).dirty = regUp.dirty = regLo.dirty = true;
		return false;
	}

	//static void WalkDirtyRegions( TESStesselator *tess, ActiveRegion *regUp )
	Sweep.walkDirtyRegions = function( tess, regUp ) {
		/*
		* When the upper or lower edge of any region changes, the region is
		* marked "dirty".  This routine walks through all the dirty regions
		* and makes sure that the dictionary invariants are satisfied
		* (see the comments at the beginning of this file).  Of course
		* new dirty regions can be created as we make changes to restore
		* the invariants.
		*/
		var regLo = Sweep.regionBelow(regUp);
		var eUp, eLo;

		for( ;; ) {
			/* Find the lowest dirty region (we walk from the bottom up). */
			while( regLo.dirty ) {
				regUp = regLo;
				regLo = Sweep.regionBelow(regLo);
			}
			if( ! regUp.dirty ) {
				regLo = regUp;
				regUp = Sweep.regionAbove( regUp );
				if( regUp == null || ! regUp.dirty ) {
					/* We've walked all the dirty regions */
					return;
				}
			}
			regUp.dirty = false;
			eUp = regUp.eUp;
			eLo = regLo.eUp;

			if( eUp.Dst !== eLo.Dst ) {
				/* Check that the edge ordering is obeyed at the Dst vertices. */
				if( Sweep.checkForLeftSplice( tess, regUp )) {

					/* If the upper or lower edge was marked fixUpperEdge, then
					* we no longer need it (since these edges are needed only for
					* vertices which otherwise have no right-going edges).
					*/
					if( regLo.fixUpperEdge ) {
						Sweep.deleteRegion( tess, regLo );
						tess.mesh.delete( eLo );
						regLo = Sweep.regionBelow( regUp );
						eLo = regLo.eUp;
					} else if( regUp.fixUpperEdge ) {
						Sweep.deleteRegion( tess, regUp );
						tess.mesh.delete( eUp );
						regUp = Sweep.regionAbove( regLo );
						eUp = regUp.eUp;
					}
				}
			}
			if( eUp.Org !== eLo.Org ) {
				if(    eUp.Dst !== eLo.Dst
					&& ! regUp.fixUpperEdge && ! regLo.fixUpperEdge
					&& (eUp.Dst === tess.event || eLo.Dst === tess.event) )
				{
					/* When all else fails in CheckForIntersect(), it uses tess->event
					* as the intersection location.  To make this possible, it requires
					* that tess->event lie between the upper and lower edges, and also
					* that neither of these is marked fixUpperEdge (since in the worst
					* case it might splice one of these edges into tess->event, and
					* violate the invariant that fixable edges are the only right-going
					* edge from their associated vertex).
					*/
					if( Sweep.checkForIntersect( tess, regUp )) {
						/* WalkDirtyRegions() was called recursively; we're done */
						return;
					}
				} else {
					/* Even though we can't use CheckForIntersect(), the Org vertices
					* may violate the dictionary edge ordering.  Check and correct this.
					*/
					Sweep.checkForRightSplice( tess, regUp );
				}
			}
			if( eUp.Org === eLo.Org && eUp.Dst === eLo.Dst ) {
				/* A degenerate loop consisting of only two edges -- delete it. */
				Sweep.addWinding( eLo, eUp );
				Sweep.deleteRegion( tess, regUp );
				tess.mesh.delete( eUp );
				regUp = Sweep.regionAbove( regLo );
			}
		}
	}


	//static void ConnectRightVertex( TESStesselator *tess, ActiveRegion *regUp, TESShalfEdge *eBottomLeft )
	Sweep.connectRightVertex = function( tess, regUp, eBottomLeft ) {
		/*
		* Purpose: connect a "right" vertex vEvent (one where all edges go left)
		* to the unprocessed portion of the mesh.  Since there are no right-going
		* edges, two regions (one above vEvent and one below) are being merged
		* into one.  "regUp" is the upper of these two regions.
		*
		* There are two reasons for doing this (adding a right-going edge):
		*  - if the two regions being merged are "inside", we must add an edge
		*    to keep them separated (the combined region would not be monotone).
		*  - in any case, we must leave some record of vEvent in the dictionary,
		*    so that we can merge vEvent with features that we have not seen yet.
		*    For example, maybe there is a vertical edge which passes just to
		*    the right of vEvent; we would like to splice vEvent into this edge.
		*
		* However, we don't want to connect vEvent to just any vertex.  We don''t
		* want the new edge to cross any other edges; otherwise we will create
		* intersection vertices even when the input data had no self-intersections.
		* (This is a bad thing; if the user's input data has no intersections,
		* we don't want to generate any false intersections ourselves.)
		*
		* Our eventual goal is to connect vEvent to the leftmost unprocessed
		* vertex of the combined region (the union of regUp and regLo).
		* But because of unseen vertices with all right-going edges, and also
		* new vertices which may be created by edge intersections, we don''t
		* know where that leftmost unprocessed vertex is.  In the meantime, we
		* connect vEvent to the closest vertex of either chain, and mark the region
		* as "fixUpperEdge".  This flag says to delete and reconnect this edge
		* to the next processed vertex on the boundary of the combined region.
		* Quite possibly the vertex we connected to will turn out to be the
		* closest one, in which case we won''t need to make any changes.
		*/
		var eNew;
		var eTopLeft = eBottomLeft.Onext;
		var regLo = Sweep.regionBelow(regUp);
		var eUp = regUp.eUp;
		var eLo = regLo.eUp;
		var degenerate = false;

		if( eUp.Dst !== eLo.Dst ) {
			Sweep.checkForIntersect( tess, regUp );
		}

		/* Possible new degeneracies: upper or lower edge of regUp may pass
		* through vEvent, or may coincide with new intersection vertex
		*/
		if( Geom.vertEq( eUp.Org, tess.event )) {
			tess.mesh.splice( eTopLeft.Oprev, eUp );
			regUp = Sweep.topLeftRegion( tess, regUp );
			eTopLeft = Sweep.regionBelow( regUp ).eUp;
			Sweep.finishLeftRegions( tess, Sweep.regionBelow(regUp), regLo );
			degenerate = true;
		}
		if( Geom.vertEq( eLo.Org, tess.event )) {
			tess.mesh.splice( eBottomLeft, eLo.Oprev );
			eBottomLeft = Sweep.finishLeftRegions( tess, regLo, null );
			degenerate = true;
		}
		if( degenerate ) {
			Sweep.addRightEdges( tess, regUp, eBottomLeft.Onext, eTopLeft, eTopLeft, true );
			return;
		}

		/* Non-degenerate situation -- need to add a temporary, fixable edge.
		* Connect to the closer of eLo->Org, eUp->Org.
		*/
		if( Geom.vertLeq( eLo.Org, eUp.Org )) {
			eNew = eLo.Oprev;
		} else {
			eNew = eUp;
		}
		eNew = tess.mesh.connect( eBottomLeft.Lprev, eNew );

		/* Prevent cleanup, otherwise eNew might disappear before we've even
		* had a chance to mark it as a temporary edge.
		*/
		Sweep.addRightEdges( tess, regUp, eNew, eNew.Onext, eNew.Onext, false );
		eNew.Sym.activeRegion.fixUpperEdge = true;
		Sweep.walkDirtyRegions( tess, regUp );
	}

	/* Because vertices at exactly the same location are merged together
	* before we process the sweep event, some degenerate cases can't occur.
	* However if someone eventually makes the modifications required to
	* merge features which are close together, the cases below marked
	* TOLERANCE_NONZERO will be useful.  They were debugged before the
	* code to merge identical vertices in the main loop was added.
	*/
	//#define TOLERANCE_NONZERO	FALSE

	//static void ConnectLeftDegenerate( TESStesselator *tess, ActiveRegion *regUp, TESSvertex *vEvent )
	Sweep.connectLeftDegenerate = function( tess, regUp, vEvent ) {
		/*
		* The event vertex lies exacty on an already-processed edge or vertex.
		* Adding the new vertex involves splicing it into the already-processed
		* part of the mesh.
		*/
		var e, eTopLeft, eTopRight, eLast;
		var reg;

		e = regUp.eUp;
		if( Geom.vertEq( e.Org, vEvent )) {
			/* e->Org is an unprocessed vertex - just combine them, and wait
			* for e->Org to be pulled from the queue
			*/
			assert( false /*TOLERANCE_NONZERO*/ );
			Sweep.spliceMergeVertices( tess, e, vEvent.anEdge );
			return;
		}

		if( ! Geom.vertEq( e.Dst, vEvent )) {
			/* General case -- splice vEvent into edge e which passes through it */
			tess.mesh.splitEdge( e.Sym );
			if( regUp.fixUpperEdge ) {
				/* This edge was fixable -- delete unused portion of original edge */
				tess.mesh.delete( e.Onext );
				regUp.fixUpperEdge = false;
			}
			tess.mesh.splice( vEvent.anEdge, e );
			Sweep.sweepEvent( tess, vEvent );	/* recurse */
			return;
		}

		/* vEvent coincides with e->Dst, which has already been processed.
		* Splice in the additional right-going edges.
		*/
		assert( false /*TOLERANCE_NONZERO*/ );
		regUp = Sweep.topRightRegion( regUp );
		reg = Sweep.regionBelow( regUp );
		eTopRight = reg.eUp.Sym;
		eTopLeft = eLast = eTopRight.Onext;
		if( reg.fixUpperEdge ) {
			/* Here e->Dst has only a single fixable edge going right.
			* We can delete it since now we have some real right-going edges.
			*/
			assert( eTopLeft !== eTopRight );   /* there are some left edges too */
			Sweep.deleteRegion( tess, reg );
			tess.mesh.delete( eTopRight );
			eTopRight = eTopLeft.Oprev;
		}
		tess.mesh.splice( vEvent.anEdge, eTopRight );
		if( ! Geom.edgeGoesLeft( eTopLeft )) {
			/* e->Dst had no left-going edges -- indicate this to AddRightEdges() */
			eTopLeft = null;
		}
		Sweep.addRightEdges( tess, regUp, eTopRight.Onext, eLast, eTopLeft, true );
	}


	//static void ConnectLeftVertex( TESStesselator *tess, TESSvertex *vEvent )
	Sweep.connectLeftVertex = function( tess, vEvent ) {
		/*
		* Purpose: connect a "left" vertex (one where both edges go right)
		* to the processed portion of the mesh.  Let R be the active region
		* containing vEvent, and let U and L be the upper and lower edge
		* chains of R.  There are two possibilities:
		*
		* - the normal case: split R into two regions, by connecting vEvent to
		*   the rightmost vertex of U or L lying to the left of the sweep line
		*
		* - the degenerate case: if vEvent is close enough to U or L, we
		*   merge vEvent into that edge chain.  The subcases are:
		*	- merging with the rightmost vertex of U or L
		*	- merging with the active edge of U or L
		*	- merging with an already-processed portion of U or L
		*/
		var regUp, regLo, reg;
		var eUp, eLo, eNew;
		var tmp = new ActiveRegion();

		/* assert( vEvent->anEdge->Onext->Onext == vEvent->anEdge ); */

		/* Get a pointer to the active region containing vEvent */
		tmp.eUp = vEvent.anEdge.Sym;
		/* __GL_DICTLISTKEY */ /* tessDictListSearch */
		regUp = tess.dict.search( tmp ).key;
		regLo = Sweep.regionBelow( regUp );
		if( !regLo ) {
			// This may happen if the input polygon is coplanar.
			return;
		}
		eUp = regUp.eUp;
		eLo = regLo.eUp;

		/* Try merging with U or L first */
		if( Geom.edgeSign( eUp.Dst, vEvent, eUp.Org ) === 0.0 ) {
			Sweep.connectLeftDegenerate( tess, regUp, vEvent );
			return;
		}

		/* Connect vEvent to rightmost processed vertex of either chain.
		* e->Dst is the vertex that we will connect to vEvent.
		*/
		reg = Geom.vertLeq( eLo.Dst, eUp.Dst ) ? regUp : regLo;

		if( regUp.inside || reg.fixUpperEdge) {
			if( reg === regUp ) {
				eNew = tess.mesh.connect( vEvent.anEdge.Sym, eUp.Lnext );
			} else {
				var tempHalfEdge = tess.mesh.connect( eLo.Dnext, vEvent.anEdge);
				eNew = tempHalfEdge.Sym;
			}
			if( reg.fixUpperEdge ) {
				Sweep.fixUpperEdge( tess, reg, eNew );
			} else {
				Sweep.computeWinding( tess, Sweep.addRegionBelow( tess, regUp, eNew ));
			}
			Sweep.sweepEvent( tess, vEvent );
		} else {
			/* The new vertex is in a region which does not belong to the polygon.
			* We don''t need to connect this vertex to the rest of the mesh.
			*/
			Sweep.addRightEdges( tess, regUp, vEvent.anEdge, vEvent.anEdge, null, true );
		}
	};


	//static void SweepEvent( TESStesselator *tess, TESSvertex *vEvent )
	Sweep.sweepEvent = function( tess, vEvent ) {
		/*
		* Does everything necessary when the sweep line crosses a vertex.
		* Updates the mesh and the edge dictionary.
		*/

		tess.event = vEvent;		/* for access in EdgeLeq() */
		Sweep.debugEvent( tess );

		/* Check if this vertex is the right endpoint of an edge that is
		* already in the dictionary.  In this case we don't need to waste
		* time searching for the location to insert new edges.
		*/
		var e = vEvent.anEdge;
		while( e.activeRegion === null ) {
			e = e.Onext;
			if( e == vEvent.anEdge ) {
				/* All edges go right -- not incident to any processed edges */
				Sweep.connectLeftVertex( tess, vEvent );
				return;
			}
		}

		/* Processing consists of two phases: first we "finish" all the
		* active regions where both the upper and lower edges terminate
		* at vEvent (ie. vEvent is closing off these regions).
		* We mark these faces "inside" or "outside" the polygon according
		* to their winding number, and delete the edges from the dictionary.
		* This takes care of all the left-going edges from vEvent.
		*/
		var regUp = Sweep.topLeftRegion( tess, e.activeRegion );
		assert( regUp !== null );
	//	if (regUp == NULL) longjmp(tess->env,1);
		var reg = Sweep.regionBelow( regUp );
		var eTopLeft = reg.eUp;
		var eBottomLeft = Sweep.finishLeftRegions( tess, reg, null );

		/* Next we process all the right-going edges from vEvent.  This
		* involves adding the edges to the dictionary, and creating the
		* associated "active regions" which record information about the
		* regions between adjacent dictionary edges.
		*/
		if( eBottomLeft.Onext === eTopLeft ) {
			/* No right-going edges -- add a temporary "fixable" edge */
			Sweep.connectRightVertex( tess, regUp, eBottomLeft );
		} else {
			Sweep.addRightEdges( tess, regUp, eBottomLeft.Onext, eTopLeft, eTopLeft, true );
		}
	};


	/* Make the sentinel coordinates big enough that they will never be
	* merged with real input features.
	*/

	//static void AddSentinel( TESStesselator *tess, TESSreal smin, TESSreal smax, TESSreal t )
	Sweep.addSentinel = function( tess, smin, smax, t ) {
		/*
		* We add two sentinel edges above and below all other edges,
		* to avoid special cases at the top and bottom.
		*/
		var reg = new ActiveRegion();
		var e = tess.mesh.makeEdge();
	//	if (e == NULL) longjmp(tess->env,1);

		e.Org.s = smax;
		e.Org.t = t;
		e.Dst.s = smin;
		e.Dst.t = t;
		tess.event = e.Dst;		/* initialize it */

		reg.eUp = e;
		reg.windingNumber = 0;
		reg.inside = false;
		reg.fixUpperEdge = false;
		reg.sentinel = true;
		reg.dirty = false;
		reg.nodeUp = tess.dict.insert( reg );
	//	if (reg->nodeUp == NULL) longjmp(tess->env,1);
	}


	//static void InitEdgeDict( TESStesselator *tess )
	Sweep.initEdgeDict = function( tess ) {
		/*
		* We maintain an ordering of edge intersections with the sweep line.
		* This order is maintained in a dynamic dictionary.
		*/
		tess.dict = new Dict( tess, Sweep.edgeLeq );
	//	if (tess->dict == NULL) longjmp(tess->env,1);

		var w = (tess.bmax[0] - tess.bmin[0]);
		var h = (tess.bmax[1] - tess.bmin[1]);

		var smin = tess.bmin[0] - w;
		var smax = tess.bmax[0] + w;
		var tmin = tess.bmin[1] - h;
		var tmax = tess.bmax[1] + h;

		Sweep.addSentinel( tess, smin, smax, tmin );
		Sweep.addSentinel( tess, smin, smax, tmax );
	}


	Sweep.doneEdgeDict = function( tess )
	{
		var reg;
		var fixedEdges = 0;

		while( (reg = tess.dict.min().key) !== null ) {
			/*
			* At the end of all processing, the dictionary should contain
			* only the two sentinel edges, plus at most one "fixable" edge
			* created by ConnectRightVertex().
			*/
			if( ! reg.sentinel ) {
				assert( reg.fixUpperEdge );
				assert( ++fixedEdges == 1 );
			}
			assert( reg.windingNumber == 0 );
			Sweep.deleteRegion( tess, reg );
			/*    tessMeshDelete( reg->eUp );*/
		}
	//	dictDeleteDict( &tess->alloc, tess->dict );
	}


	Sweep.removeDegenerateEdges = function( tess ) {
		/*
		* Remove zero-length edges, and contours with fewer than 3 vertices.
		*/
		var e, eNext, eLnext;
		var eHead = tess.mesh.eHead;

		/*LINTED*/
		for( e = eHead.next; e !== eHead; e = eNext ) {
			eNext = e.next;
			eLnext = e.Lnext;

			if( Geom.vertEq( e.Org, e.Dst ) && e.Lnext.Lnext !== e ) {
				/* Zero-length edge, contour has at least 3 edges */
				Sweep.spliceMergeVertices( tess, eLnext, e );	/* deletes e->Org */
				tess.mesh.delete( e ); /* e is a self-loop */
				e = eLnext;
				eLnext = e.Lnext;
			}
			if( eLnext.Lnext === e ) {
				/* Degenerate contour (one or two edges) */
				if( eLnext !== e ) {
					if( eLnext === eNext || eLnext === eNext.Sym ) { eNext = eNext.next; }
					tess.mesh.delete( eLnext );
				}
				if( e === eNext || e === eNext.Sym ) { eNext = eNext.next; }
				tess.mesh.delete( e );
			}
		}
	}

	Sweep.initPriorityQ = function( tess ) {
		/*
		* Insert all vertices into the priority queue which determines the
		* order in which vertices cross the sweep line.
		*/
		var pq;
		var v, vHead;
		var vertexCount = 0;
		
		vHead = tess.mesh.vHead;
		for( v = vHead.next; v !== vHead; v = v.next ) {
			vertexCount++;
		}
		/* Make sure there is enough space for sentinels. */
		vertexCount += 8; //MAX( 8, tess->alloc.extraVertices );
		
		pq = tess.pq = new PriorityQ( vertexCount, Geom.vertLeq );
	//	if (pq == NULL) return 0;

		vHead = tess.mesh.vHead;
		for( v = vHead.next; v !== vHead; v = v.next ) {
			v.pqHandle = pq.insert( v );
	//		if (v.pqHandle == INV_HANDLE)
	//			break;
		}

		if (v !== vHead) {
			return false;
		}

		pq.init();

		return true;
	}


	Sweep.donePriorityQ = function( tess ) {
		tess.pq = null;
	}


	Sweep.removeDegenerateFaces = function( tess, mesh ) {
		/*
		* Delete any degenerate faces with only two edges.  WalkDirtyRegions()
		* will catch almost all of these, but it won't catch degenerate faces
		* produced by splice operations on already-processed edges.
		* The two places this can happen are in FinishLeftRegions(), when
		* we splice in a "temporary" edge produced by ConnectRightVertex(),
		* and in CheckForLeftSplice(), where we splice already-processed
		* edges to ensure that our dictionary invariants are not violated
		* by numerical errors.
		*
		* In both these cases it is *very* dangerous to delete the offending
		* edge at the time, since one of the routines further up the stack
		* will sometimes be keeping a pointer to that edge.
		*/
		var f, fNext;
		var e;

		/*LINTED*/
		for( f = mesh.fHead.next; f !== mesh.fHead; f = fNext ) {
			fNext = f.next;
			e = f.anEdge;
			assert( e.Lnext !== e );

			if( e.Lnext.Lnext === e ) {
				/* A face with only two edges */
				Sweep.addWinding( e.Onext, e );
				tess.mesh.delete( e );
			}
		}
		return true;
	}

	Sweep.computeInterior = function( tess ) {
		/*
		* tessComputeInterior( tess ) computes the planar arrangement specified
		* by the given contours, and further subdivides this arrangement
		* into regions.  Each region is marked "inside" if it belongs
		* to the polygon, according to the rule given by tess->windingRule.
		* Each interior region is guaranteed be monotone.
		*/
		var v, vNext;

		/* Each vertex defines an event for our sweep line.  Start by inserting
		* all the vertices in a priority queue.  Events are processed in
		* lexicographic order, ie.
		*
		*	e1 < e2  iff  e1.x < e2.x || (e1.x == e2.x && e1.y < e2.y)
		*/
		Sweep.removeDegenerateEdges( tess );
		if ( !Sweep.initPriorityQ( tess ) ) return false; /* if error */
		Sweep.initEdgeDict( tess );

		while( (v = tess.pq.extractMin()) !== null ) {
			for( ;; ) {
				vNext = tess.pq.min();
				if( vNext === null || ! Geom.vertEq( vNext, v )) break;

				/* Merge together all vertices at exactly the same location.
				* This is more efficient than processing them one at a time,
				* simplifies the code (see ConnectLeftDegenerate), and is also
				* important for correct handling of certain degenerate cases.
				* For example, suppose there are two identical edges A and B
				* that belong to different contours (so without this code they would
				* be processed by separate sweep events).  Suppose another edge C
				* crosses A and B from above.  When A is processed, we split it
				* at its intersection point with C.  However this also splits C,
				* so when we insert B we may compute a slightly different
				* intersection point.  This might leave two edges with a small
				* gap between them.  This kind of error is especially obvious
				* when using boundary extraction (TESS_BOUNDARY_ONLY).
				*/
				vNext = tess.pq.extractMin();
				Sweep.spliceMergeVertices( tess, v.anEdge, vNext.anEdge );
			}
			Sweep.sweepEvent( tess, v );
		}

		/* Set tess->event for debugging purposes */
		tess.event = tess.dict.min().key.eUp.Org;
		Sweep.debugEvent( tess );
		Sweep.doneEdgeDict( tess );
		Sweep.donePriorityQ( tess );

		if ( !Sweep.removeDegenerateFaces( tess, tess.mesh ) ) return false;
		tess.mesh.check();

		return true;
	}


	function Tesselator() {

		/*** state needed for collecting the input data ***/
		this.mesh = null;		/* stores the input contours, and eventually
							the tessellation itself */

		/*** state needed for projecting onto the sweep plane ***/

		this.normal = [0.0, 0.0, 0.0];	/* user-specified normal (if provided) */
		this.sUnit = [0.0, 0.0, 0.0];	/* unit vector in s-direction (debugging) */
		this.tUnit = [0.0, 0.0, 0.0];	/* unit vector in t-direction (debugging) */

		this.bmin = [0.0, 0.0];
		this.bmax = [0.0, 0.0];

		/*** state needed for the line sweep ***/
		this.windingRule = Tess2.WINDING_ODD;	/* rule for determining polygon interior */

		this.dict = null;		/* edge dictionary for sweep line */
		this.pq = null;		/* priority queue of vertex events */
		this.event = null;		/* current sweep event being processed */

		this.vertexIndexCounter = 0;
		
		this.vertices = [];
		this.vertexIndices = [];
		this.vertexCount = 0;
		this.elements = [];
		this.elementCount = 0;
	};

	Tesselator.prototype = {

		dot_: function(u, v) {
			return (u[0]*v[0] + u[1]*v[1] + u[2]*v[2]);
		},

		normalize_: function( v ) {
			var len = v[0]*v[0] + v[1]*v[1] + v[2]*v[2];
			assert( len > 0.0 );
			len = Math.sqrt( len );
			v[0] /= len;
			v[1] /= len;
			v[2] /= len;
		},

		longAxis_: function( v ) {
			var i = 0;
			if( Math.abs(v[1]) > Math.abs(v[0]) ) { i = 1; }
			if( Math.abs(v[2]) > Math.abs(v[i]) ) { i = 2; }
			return i;
		},

		computeNormal_: function( norm )
		{
			var v, v1, v2;
			var c, tLen2, maxLen2;
			var maxVal = [0,0,0], minVal = [0,0,0], d1 = [0,0,0], d2 = [0,0,0], tNorm = [0,0,0];
			var maxVert = [null,null,null], minVert = [null,null,null];
			var vHead = this.mesh.vHead;
			var i;

			v = vHead.next;
			for( i = 0; i < 3; ++i ) {
				c = v.coords[i];
				minVal[i] = c;
				minVert[i] = v;
				maxVal[i] = c;
				maxVert[i] = v;
			}

			for( v = vHead.next; v !== vHead; v = v.next ) {
				for( i = 0; i < 3; ++i ) {
					c = v.coords[i];
					if( c < minVal[i] ) { minVal[i] = c; minVert[i] = v; }
					if( c > maxVal[i] ) { maxVal[i] = c; maxVert[i] = v; }
				}
			}

			/* Find two vertices separated by at least 1/sqrt(3) of the maximum
			* distance between any two vertices
			*/
			i = 0;
			if( maxVal[1] - minVal[1] > maxVal[0] - minVal[0] ) { i = 1; }
			if( maxVal[2] - minVal[2] > maxVal[i] - minVal[i] ) { i = 2; }
			if( minVal[i] >= maxVal[i] ) {
				/* All vertices are the same -- normal doesn't matter */
				norm[0] = 0; norm[1] = 0; norm[2] = 1;
				return;
			}

			/* Look for a third vertex which forms the triangle with maximum area
			* (Length of normal == twice the triangle area)
			*/
			maxLen2 = 0;
			v1 = minVert[i];
			v2 = maxVert[i];
			d1[0] = v1.coords[0] - v2.coords[0];
			d1[1] = v1.coords[1] - v2.coords[1];
			d1[2] = v1.coords[2] - v2.coords[2];
			for( v = vHead.next; v !== vHead; v = v.next ) {
				d2[0] = v.coords[0] - v2.coords[0];
				d2[1] = v.coords[1] - v2.coords[1];
				d2[2] = v.coords[2] - v2.coords[2];
				tNorm[0] = d1[1]*d2[2] - d1[2]*d2[1];
				tNorm[1] = d1[2]*d2[0] - d1[0]*d2[2];
				tNorm[2] = d1[0]*d2[1] - d1[1]*d2[0];
				tLen2 = tNorm[0]*tNorm[0] + tNorm[1]*tNorm[1] + tNorm[2]*tNorm[2];
				if( tLen2 > maxLen2 ) {
					maxLen2 = tLen2;
					norm[0] = tNorm[0];
					norm[1] = tNorm[1];
					norm[2] = tNorm[2];
				}
			}

			if( maxLen2 <= 0 ) {
				/* All points lie on a single line -- any decent normal will do */
				norm[0] = norm[1] = norm[2] = 0;
				norm[this.longAxis_(d1)] = 1;
			}
		},

		checkOrientation_: function() {
			var area;
			var f, fHead = this.mesh.fHead;
			var v, vHead = this.mesh.vHead;
			var e;

			/* When we compute the normal automatically, we choose the orientation
			* so that the the sum of the signed areas of all contours is non-negative.
			*/
			area = 0;
			for( f = fHead.next; f !== fHead; f = f.next ) {
				e = f.anEdge;
				if( e.winding <= 0 ) continue;
				do {
					area += (e.Org.s - e.Dst.s) * (e.Org.t + e.Dst.t);
					e = e.Lnext;
				} while( e !== f.anEdge );
			}
			if( area < 0 ) {
				/* Reverse the orientation by flipping all the t-coordinates */
				for( v = vHead.next; v !== vHead; v = v.next ) {
					v.t = - v.t;
				}
				this.tUnit[0] = - this.tUnit[0];
				this.tUnit[1] = - this.tUnit[1];
				this.tUnit[2] = - this.tUnit[2];
			}
		},

	/*	#ifdef FOR_TRITE_TEST_PROGRAM
		#include <stdlib.h>
		extern int RandomSweep;
		#define S_UNIT_X	(RandomSweep ? (2*drand48()-1) : 1.0)
		#define S_UNIT_Y	(RandomSweep ? (2*drand48()-1) : 0.0)
		#else
		#if defined(SLANTED_SWEEP) */
		/* The "feature merging" is not intended to be complete.  There are
		* special cases where edges are nearly parallel to the sweep line
		* which are not implemented.  The algorithm should still behave
		* robustly (ie. produce a reasonable tesselation) in the presence
		* of such edges, however it may miss features which could have been
		* merged.  We could minimize this effect by choosing the sweep line
		* direction to be something unusual (ie. not parallel to one of the
		* coordinate axes).
		*/
	/*	#define S_UNIT_X	(TESSreal)0.50941539564955385	// Pre-normalized
		#define S_UNIT_Y	(TESSreal)0.86052074622010633
		#else
		#define S_UNIT_X	(TESSreal)1.0
		#define S_UNIT_Y	(TESSreal)0.0
		#endif
		#endif*/

		/* Determine the polygon normal and project vertices onto the plane
		* of the polygon.
		*/
		projectPolygon_: function() {
			var v, vHead = this.mesh.vHead;
			var norm = [0,0,0];
			var sUnit, tUnit;
			var i, first, computedNormal = false;

			norm[0] = this.normal[0];
			norm[1] = this.normal[1];
			norm[2] = this.normal[2];
			if( norm[0] === 0.0 && norm[1] === 0.0 && norm[2] === 0.0 ) {
				this.computeNormal_( norm );
				computedNormal = true;
			}
			sUnit = this.sUnit;
			tUnit = this.tUnit;
			i = this.longAxis_( norm );

	/*	#if defined(FOR_TRITE_TEST_PROGRAM) || defined(TRUE_PROJECT)
			// Choose the initial sUnit vector to be approximately perpendicular
			// to the normal.
			
			Normalize( norm );

			sUnit[i] = 0;
			sUnit[(i+1)%3] = S_UNIT_X;
			sUnit[(i+2)%3] = S_UNIT_Y;

			// Now make it exactly perpendicular 
			w = Dot( sUnit, norm );
			sUnit[0] -= w * norm[0];
			sUnit[1] -= w * norm[1];
			sUnit[2] -= w * norm[2];
			Normalize( sUnit );

			// Choose tUnit so that (sUnit,tUnit,norm) form a right-handed frame 
			tUnit[0] = norm[1]*sUnit[2] - norm[2]*sUnit[1];
			tUnit[1] = norm[2]*sUnit[0] - norm[0]*sUnit[2];
			tUnit[2] = norm[0]*sUnit[1] - norm[1]*sUnit[0];
			Normalize( tUnit );
		#else*/
			/* Project perpendicular to a coordinate axis -- better numerically */
			sUnit[i] = 0;
			sUnit[(i+1)%3] = 1.0;
			sUnit[(i+2)%3] = 0.0;

			tUnit[i] = 0;
			tUnit[(i+1)%3] = 0.0;
			tUnit[(i+2)%3] = (norm[i] > 0) ? 1.0 : -1.0;
	//	#endif

			/* Project the vertices onto the sweep plane */
			for( v = vHead.next; v !== vHead; v = v.next ) {
				v.s = this.dot_( v.coords, sUnit );
				v.t = this.dot_( v.coords, tUnit );
			}
			if( computedNormal ) {
				this.checkOrientation_();
			}

			/* Compute ST bounds. */
			first = true;
			for( v = vHead.next; v !== vHead; v = v.next ) {
				if (first) {
					this.bmin[0] = this.bmax[0] = v.s;
					this.bmin[1] = this.bmax[1] = v.t;
					first = false;
				} else {
					if (v.s < this.bmin[0]) this.bmin[0] = v.s;
					if (v.s > this.bmax[0]) this.bmax[0] = v.s;
					if (v.t < this.bmin[1]) this.bmin[1] = v.t;
					if (v.t > this.bmax[1]) this.bmax[1] = v.t;
				}
			}
		},

		addWinding_: function(eDst,eSrc) {
			eDst.winding += eSrc.winding;
			eDst.Sym.winding += eSrc.Sym.winding;
		},
		
		/* tessMeshTessellateMonoRegion( face ) tessellates a monotone region
		* (what else would it do??)  The region must consist of a single
		* loop of half-edges (see mesh.h) oriented CCW.  "Monotone" in this
		* case means that any vertical line intersects the interior of the
		* region in a single interval.  
		*
		* Tessellation consists of adding interior edges (actually pairs of
		* half-edges), to split the region into non-overlapping triangles.
		*
		* The basic idea is explained in Preparata and Shamos (which I don''t
		* have handy right now), although their implementation is more
		* complicated than this one.  The are two edge chains, an upper chain
		* and a lower chain.  We process all vertices from both chains in order,
		* from right to left.
		*
		* The algorithm ensures that the following invariant holds after each
		* vertex is processed: the untessellated region consists of two
		* chains, where one chain (say the upper) is a single edge, and
		* the other chain is concave.  The left vertex of the single edge
		* is always to the left of all vertices in the concave chain.
		*
		* Each step consists of adding the rightmost unprocessed vertex to one
		* of the two chains, and forming a fan of triangles from the rightmost
		* of two chain endpoints.  Determining whether we can add each triangle
		* to the fan is a simple orientation test.  By making the fan as large
		* as possible, we restore the invariant (check it yourself).
		*/
	//	int tessMeshTessellateMonoRegion( TESSmesh *mesh, TESSface *face )
		tessellateMonoRegion_: function( mesh, face ) {
			var up, lo;

			/* All edges are oriented CCW around the boundary of the region.
			* First, find the half-edge whose origin vertex is rightmost.
			* Since the sweep goes from left to right, face->anEdge should
			* be close to the edge we want.
			*/
			up = face.anEdge;
			assert( up.Lnext !== up && up.Lnext.Lnext !== up );

			for( ; Geom.vertLeq( up.Dst, up.Org ); up = up.Lprev )
				;
			for( ; Geom.vertLeq( up.Org, up.Dst ); up = up.Lnext )
				;
			lo = up.Lprev;

			while( up.Lnext !== lo ) {
				if( Geom.vertLeq( up.Dst, lo.Org )) {
					/* up->Dst is on the left.  It is safe to form triangles from lo->Org.
					* The EdgeGoesLeft test guarantees progress even when some triangles
					* are CW, given that the upper and lower chains are truly monotone.
					*/
					while( lo.Lnext !== up && (Geom.edgeGoesLeft( lo.Lnext )
						|| Geom.edgeSign( lo.Org, lo.Dst, lo.Lnext.Dst ) <= 0.0 )) {
							var tempHalfEdge = mesh.connect( lo.Lnext, lo );
							//if (tempHalfEdge == NULL) return 0;
							lo = tempHalfEdge.Sym;
					}
					lo = lo.Lprev;
				} else {
					/* lo->Org is on the left.  We can make CCW triangles from up->Dst. */
					while( lo.Lnext != up && (Geom.edgeGoesRight( up.Lprev )
						|| Geom.edgeSign( up.Dst, up.Org, up.Lprev.Org ) >= 0.0 )) {
							var tempHalfEdge = mesh.connect( up, up.Lprev );
							//if (tempHalfEdge == NULL) return 0;
							up = tempHalfEdge.Sym;
					}
					up = up.Lnext;
				}
			}

			/* Now lo->Org == up->Dst == the leftmost vertex.  The remaining region
			* can be tessellated in a fan from this leftmost vertex.
			*/
			assert( lo.Lnext !== up );
			while( lo.Lnext.Lnext !== up ) {
				var tempHalfEdge = mesh.connect( lo.Lnext, lo );
				//if (tempHalfEdge == NULL) return 0;
				lo = tempHalfEdge.Sym;
			}

			return true;
		},


		/* tessMeshTessellateInterior( mesh ) tessellates each region of
		* the mesh which is marked "inside" the polygon.  Each such region
		* must be monotone.
		*/
		//int tessMeshTessellateInterior( TESSmesh *mesh )
		tessellateInterior_: function( mesh ) {
			var f, next;

			/*LINTED*/
			for( f = mesh.fHead.next; f !== mesh.fHead; f = next ) {
				/* Make sure we don''t try to tessellate the new triangles. */
				next = f.next;
				if( f.inside ) {
					if ( !this.tessellateMonoRegion_( mesh, f ) ) return false;
				}
			}

			return true;
		},


		/* tessMeshDiscardExterior( mesh ) zaps (ie. sets to NULL) all faces
		* which are not marked "inside" the polygon.  Since further mesh operations
		* on NULL faces are not allowed, the main purpose is to clean up the
		* mesh so that exterior loops are not represented in the data structure.
		*/
		//void tessMeshDiscardExterior( TESSmesh *mesh )
		discardExterior_: function( mesh ) {
			var f, next;

			/*LINTED*/
			for( f = mesh.fHead.next; f !== mesh.fHead; f = next ) {
				/* Since f will be destroyed, save its next pointer. */
				next = f.next;
				if( ! f.inside ) {
					mesh.zapFace( f );
				}
			}
		},

		/* tessMeshSetWindingNumber( mesh, value, keepOnlyBoundary ) resets the
		* winding numbers on all edges so that regions marked "inside" the
		* polygon have a winding number of "value", and regions outside
		* have a winding number of 0.
		*
		* If keepOnlyBoundary is TRUE, it also deletes all edges which do not
		* separate an interior region from an exterior one.
		*/
	//	int tessMeshSetWindingNumber( TESSmesh *mesh, int value, int keepOnlyBoundary )
		setWindingNumber_: function( mesh, value, keepOnlyBoundary ) {
			var e, eNext;

			for( e = mesh.eHead.next; e !== mesh.eHead; e = eNext ) {
				eNext = e.next;
				if( e.Rface.inside !== e.Lface.inside ) {

					/* This is a boundary edge (one side is interior, one is exterior). */
					e.winding = (e.Lface.inside) ? value : -value;
				} else {

					/* Both regions are interior, or both are exterior. */
					if( ! keepOnlyBoundary ) {
						e.winding = 0;
					} else {
						mesh.delete( e );
					}
				}
			}
		},

		getNeighbourFace_: function(edge)
		{
			if (!edge.Rface)
				return -1;
			if (!edge.Rface.inside)
				return -1;
			return edge.Rface.n;
		},

		outputPolymesh_: function( mesh, elementType, polySize, vertexSize ) {
			var v;
			var f;
			var edge;
			var maxFaceCount = 0;
			var maxVertexCount = 0;
			var faceVerts, i;
			var elements = 0;
			var vert;

			// Assume that the input data is triangles now.
			// Try to merge as many polygons as possible
			if (polySize > 3)
			{
				mesh.mergeConvexFaces( polySize );
			}

			// Mark unused
			for ( v = mesh.vHead.next; v !== mesh.vHead; v = v.next )
				v.n = -1;

			// Create unique IDs for all vertices and faces.
			for ( f = mesh.fHead.next; f != mesh.fHead; f = f.next )
			{
				f.n = -1;
				if( !f.inside ) continue;

				edge = f.anEdge;
				faceVerts = 0;
				do
				{
					v = edge.Org;
					if ( v.n === -1 )
					{
						v.n = maxVertexCount;
						maxVertexCount++;
					}
					faceVerts++;
					edge = edge.Lnext;
				}
				while (edge !== f.anEdge);
				
				assert( faceVerts <= polySize );

				f.n = maxFaceCount;
				++maxFaceCount;
			}

			this.elementCount = maxFaceCount;
			if (elementType == Tess2.CONNECTED_POLYGONS)
				maxFaceCount *= 2;
	/*		tess.elements = (TESSindex*)tess->alloc.memalloc( tess->alloc.userData,
															  sizeof(TESSindex) * maxFaceCount * polySize );
			if (!tess->elements)
			{
				tess->outOfMemory = 1;
				return;
			}*/
			this.elements = [];
			this.elements.length = maxFaceCount * polySize;
			
			this.vertexCount = maxVertexCount;
	/*		tess->vertices = (TESSreal*)tess->alloc.memalloc( tess->alloc.userData,
															 sizeof(TESSreal) * tess->vertexCount * vertexSize );
			if (!tess->vertices)
			{
				tess->outOfMemory = 1;
				return;
			}*/
			this.vertices = [];
			this.vertices.length = maxVertexCount * vertexSize;

	/*		tess->vertexIndices = (TESSindex*)tess->alloc.memalloc( tess->alloc.userData,
																    sizeof(TESSindex) * tess->vertexCount );
			if (!tess->vertexIndices)
			{
				tess->outOfMemory = 1;
				return;
			}*/
			this.vertexIndices = [];
			this.vertexIndices.length = maxVertexCount;

			
			// Output vertices.
			for ( v = mesh.vHead.next; v !== mesh.vHead; v = v.next )
			{
				if ( v.n != -1 )
				{
					// Store coordinate
					var idx = v.n * vertexSize;
					this.vertices[idx+0] = v.coords[0];
					this.vertices[idx+1] = v.coords[1];
					if ( vertexSize > 2 )
						this.vertices[idx+2] = v.coords[2];
					// Store vertex index.
					this.vertexIndices[v.n] = v.idx;
				}
			}

			// Output indices.
			var nel = 0;
			for ( f = mesh.fHead.next; f !== mesh.fHead; f = f.next )
			{
				if ( !f.inside ) continue;
				
				// Store polygon
				edge = f.anEdge;
				faceVerts = 0;
				do
				{
					v = edge.Org;
					this.elements[nel++] = v.n;
					faceVerts++;
					edge = edge.Lnext;
				}
				while (edge !== f.anEdge);
				// Fill unused.
				for (i = faceVerts; i < polySize; ++i)
					this.elements[nel++] = -1;

				// Store polygon connectivity
				if ( elementType == Tess2.CONNECTED_POLYGONS )
				{
					edge = f.anEdge;
					do
					{
						this.elements[nel++] = this.getNeighbourFace_( edge );
						edge = edge.Lnext;
					}
					while (edge !== f.anEdge);
					// Fill unused.
					for (i = faceVerts; i < polySize; ++i)
						this.elements[nel++] = -1;
				}
			}
		},

	//	void OutputContours( TESStesselator *tess, TESSmesh *mesh, int vertexSize )
		outputContours_: function( mesh, vertexSize ) {
			var f;
			var edge;
			var start;
			var verts;
			var elements;
			var vertInds;
			var startVert = 0;
			var vertCount = 0;

			this.vertexCount = 0;
			this.elementCount = 0;

			for ( f = mesh.fHead.next; f !== mesh.fHead; f = f.next )
			{
				if ( !f.inside ) continue;

				start = edge = f.anEdge;
				do
				{
					this.vertexCount++;
					edge = edge.Lnext;
				}
				while ( edge !== start );

				this.elementCount++;
			}

	/*		tess->elements = (TESSindex*)tess->alloc.memalloc( tess->alloc.userData,
															  sizeof(TESSindex) * tess->elementCount * 2 );
			if (!tess->elements)
			{
				tess->outOfMemory = 1;
				return;
			}*/
			this.elements = [];
			this.elements.length = this.elementCount * 2;
			
	/*		tess->vertices = (TESSreal*)tess->alloc.memalloc( tess->alloc.userData,
															  sizeof(TESSreal) * tess->vertexCount * vertexSize );
			if (!tess->vertices)
			{
				tess->outOfMemory = 1;
				return;
			}*/
			this.vertices = [];
			this.vertices.length = this.vertexCount * vertexSize;

	/*		tess->vertexIndices = (TESSindex*)tess->alloc.memalloc( tess->alloc.userData,
																    sizeof(TESSindex) * tess->vertexCount );
			if (!tess->vertexIndices)
			{
				tess->outOfMemory = 1;
				return;
			}*/
			this.vertexIndices = [];
			this.vertexIndices.length = this.vertexCount;

			var nv = 0;
			var nvi = 0;
			var nel = 0;
			startVert = 0;

			for ( f = mesh.fHead.next; f !== mesh.fHead; f = f.next )
			{
				if ( !f.inside ) continue;

				vertCount = 0;
				start = edge = f.anEdge;
				do
				{
					this.vertices[nv++] = edge.Org.coords[0];
					this.vertices[nv++] = edge.Org.coords[1];
					if ( vertexSize > 2 )
						this.vertices[nv++] = edge.Org.coords[2];
					this.vertexIndices[nvi++] = edge.Org.idx;
					vertCount++;
					edge = edge.Lnext;
				}
				while ( edge !== start );

				this.elements[nel++] = startVert;
				this.elements[nel++] = vertCount;

				startVert += vertCount;
			}
		},

		addContour: function( size, vertices )
		{
			var e;
			var i;

			if ( this.mesh === null )
			  	this.mesh = new TESSmesh();
	/*	 	if ( tess->mesh == NULL ) {
				tess->outOfMemory = 1;
				return;
			}*/

			if ( size < 2 )
				size = 2;
			if ( size > 3 )
				size = 3;

			e = null;

			for( i = 0; i < vertices.length; i += size )
			{
				if( e == null ) {
					/* Make a self-loop (one vertex, one edge). */
					e = this.mesh.makeEdge();
	/*				if ( e == NULL ) {
						tess->outOfMemory = 1;
						return;
					}*/
					this.mesh.splice( e, e.Sym );
				} else {
					/* Create a new vertex and edge which immediately follow e
					* in the ordering around the left face.
					*/
					this.mesh.splitEdge( e );
					e = e.Lnext;
				}

				/* The new vertex is now e->Org. */
				e.Org.coords[0] = vertices[i+0];
				e.Org.coords[1] = vertices[i+1];
				if ( size > 2 )
					e.Org.coords[2] = vertices[i+2];
				else
					e.Org.coords[2] = 0.0;
				/* Store the insertion number so that the vertex can be later recognized. */
				e.Org.idx = this.vertexIndexCounter++;

				/* The winding of an edge says how the winding number changes as we
				* cross from the edge''s right face to its left face.  We add the
				* vertices in such an order that a CCW contour will add +1 to
				* the winding number of the region inside the contour.
				*/
				e.winding = 1;
				e.Sym.winding = -1;
			}
		},

	//	int tessTesselate( TESStesselator *tess, int windingRule, int elementType, int polySize, int vertexSize, const TESSreal* normal )
		tesselate: function( windingRule, elementType, polySize, vertexSize, normal ) {
			this.vertices = [];
			this.elements = [];
			this.vertexIndices = [];

			this.vertexIndexCounter = 0;
			
			if (normal)
			{
				this.normal[0] = normal[0];
				this.normal[1] = normal[1];
				this.normal[2] = normal[2];
			}

			this.windingRule = windingRule;

			if (vertexSize < 2)
				vertexSize = 2;
			if (vertexSize > 3)
				vertexSize = 3;

	/*		if (setjmp(tess->env) != 0) { 
				// come back here if out of memory
				return 0;
			}*/

			if (!this.mesh)
			{
				return false;
			}

			/* Determine the polygon normal and project vertices onto the plane
			* of the polygon.
			*/
			this.projectPolygon_();

			/* tessComputeInterior( tess ) computes the planar arrangement specified
			* by the given contours, and further subdivides this arrangement
			* into regions.  Each region is marked "inside" if it belongs
			* to the polygon, according to the rule given by tess->windingRule.
			* Each interior region is guaranteed be monotone.
			*/
			Sweep.computeInterior( this );

			var mesh = this.mesh;

			/* If the user wants only the boundary contours, we throw away all edges
			* except those which separate the interior from the exterior.
			* Otherwise we tessellate all the regions marked "inside".
			*/
			if (elementType == Tess2.BOUNDARY_CONTOURS) {
				this.setWindingNumber_( mesh, 1, true );
			} else {
				this.tessellateInterior_( mesh ); 
			}
	//		if (rc == 0) longjmp(tess->env,1);  /* could've used a label */

			mesh.check();

			if (elementType == Tess2.BOUNDARY_CONTOURS) {
				this.outputContours_( mesh, vertexSize );     /* output contours */
			}
			else
			{
				this.outputPolymesh_( mesh, elementType, polySize, vertexSize );     /* output polygons */
			}

//			tess.mesh = null;

			return true;
		}
	};
},{}],"/projects/blackice/node_modules/unlerp/index.js":[function(require,module,exports){
module.exports = function range(min, max, value) {
  return (value - min) / (max - min)
}
},{}],"/projects/blackice/node_modules/xtend/immutable.js":[function(require,module,exports){
module.exports=require("/projects/blackice/node_modules/three-sdf-text/node_modules/xtend/immutable.js")
},{"/projects/blackice/node_modules/three-sdf-text/node_modules/xtend/immutable.js":"/projects/blackice/node_modules/three-sdf-text/node_modules/xtend/immutable.js"}]},{},["./index.js"])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJpbmRleC5qcyIsImZvbnRzL0V4bzJTZW1pQm9sZC5qc29uIiwibGliL1JpZ1NjZW5lLmpzIiwibGliL1RleHRQYXNzLmpzIiwibGliL2FuaW1hdGUtbGFiZWxzLmpzIiwibGliL2NyZWF0ZS1mb250LmpzIiwibGliL2NyZWF0ZS10ZXh0LXBhc3MuanMiLCJsaWIvZ2V0LXBvbHlnb24uanMiLCJsaWIvZ2V0LXN2Zy5qcyIsImxpYi9yZW5kZXJlci5qcyIsImxpYi9zZXR1cC1lZmZlY3RzLmpzIiwibGliL3NldHVwLXdhdGVyLmpzIiwibGliL3NoYWRlcnMvYmx1ci5qcyIsImxpYi9zaGFkZXJzL2NyZWF0ZS5qcyIsImxpYi9zaGFkZXJzL2xlbnMuanMiLCJsaWIvc2hhZGVycy9wYXNzLmpzIiwibGliL3RleHQtZGF0YS5qcyIsImxpYi90aHJlZS1vcmJpdC1jYW1lcmEvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYXMtbnVtYmVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9idWZmZXIvbm9kZV9tb2R1bGVzL2Jhc2U2NC1qcy9saWIvYjY0LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2J1ZmZlci9ub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9idWZmZXIvbm9kZV9tb2R1bGVzL2lzLWFycmF5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NhbnZhcy1hcHAvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY2FudmFzLWFwcC9ub2RlX21vZHVsZXMvYWRkLWV2ZW50LWxpc3RlbmVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NhbnZhcy1hcHAvbm9kZV9tb2R1bGVzL2RlYm91bmNlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NhbnZhcy1hcHAvbm9kZV9tb2R1bGVzL2RlYm91bmNlL25vZGVfbW9kdWxlcy9kYXRlLW5vdy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jYW52YXMtYXBwL25vZGVfbW9kdWxlcy9pcy13ZWJnbC1jb250ZXh0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NhbnZhcy1hcHAvbm9kZV9tb2R1bGVzL3dlYmdsLWNvbnRleHQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY2xhbXAvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZG9tcmVhZHkvcmVhZHkuanMiLCJub2RlX21vZHVsZXMvZ2wtbWF0NC9pZGVudGl0eS5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXQ0L211bHRpcGx5LmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdDQvc2NhbGUuanMiLCJub2RlX21vZHVsZXMvZ2wtbWF0NC90cmFuc2xhdGUuanMiLCJub2RlX21vZHVsZXMvZ2wtc3ByaXRlLXRleHQvbm9kZV9tb2R1bGVzL2dsLXNwcml0ZS1iYXRjaC9ub2RlX21vZHVsZXMvZ2wtYnVmZmVyL25vZGVfbW9kdWxlcy9uZGFycmF5LW9wcy9uZGFycmF5LW9wcy5qcyIsIm5vZGVfbW9kdWxlcy9nbC1zcHJpdGUtdGV4dC9ub2RlX21vZHVsZXMvZ2wtc3ByaXRlLWJhdGNoL25vZGVfbW9kdWxlcy9nbC1idWZmZXIvbm9kZV9tb2R1bGVzL25kYXJyYXktb3BzL25vZGVfbW9kdWxlcy9jd2lzZS1jb21waWxlci9jb21waWxlci5qcyIsIm5vZGVfbW9kdWxlcy9nbC1zcHJpdGUtdGV4dC9ub2RlX21vZHVsZXMvZ2wtc3ByaXRlLWJhdGNoL25vZGVfbW9kdWxlcy9nbC1idWZmZXIvbm9kZV9tb2R1bGVzL25kYXJyYXktb3BzL25vZGVfbW9kdWxlcy9jd2lzZS1jb21waWxlci9saWIvY29tcGlsZS5qcyIsIm5vZGVfbW9kdWxlcy9nbC1zcHJpdGUtdGV4dC9ub2RlX21vZHVsZXMvZ2wtc3ByaXRlLWJhdGNoL25vZGVfbW9kdWxlcy9nbC1idWZmZXIvbm9kZV9tb2R1bGVzL25kYXJyYXktb3BzL25vZGVfbW9kdWxlcy9jd2lzZS1jb21waWxlci9saWIvdGh1bmsuanMiLCJub2RlX21vZHVsZXMvZ2wtc3ByaXRlLXRleHQvbm9kZV9tb2R1bGVzL2dsLXNwcml0ZS1iYXRjaC9ub2RlX21vZHVsZXMvZ2wtYnVmZmVyL25vZGVfbW9kdWxlcy9uZGFycmF5LW9wcy9ub2RlX21vZHVsZXMvY3dpc2UtY29tcGlsZXIvbm9kZV9tb2R1bGVzL3VuaXEvdW5pcS5qcyIsIm5vZGVfbW9kdWxlcy9nbC1zcHJpdGUtdGV4dC9ub2RlX21vZHVsZXMvZ2wtc3ByaXRlLWJhdGNoL25vZGVfbW9kdWxlcy9nbC1idWZmZXIvbm9kZV9tb2R1bGVzL3R5cGVkYXJyYXktcG9vbC9ub2RlX21vZHVsZXMvYml0LXR3aWRkbGUvdHdpZGRsZS5qcyIsIm5vZGVfbW9kdWxlcy9nbC1zcHJpdGUtdGV4dC9ub2RlX21vZHVsZXMvZ2wtc3ByaXRlLWJhdGNoL25vZGVfbW9kdWxlcy9nbC1idWZmZXIvbm9kZV9tb2R1bGVzL3R5cGVkYXJyYXktcG9vbC9ub2RlX21vZHVsZXMvZHVwL2R1cC5qcyIsIm5vZGVfbW9kdWxlcy9nbC1zcHJpdGUtdGV4dC9ub2RlX21vZHVsZXMvZ2wtc3ByaXRlLWJhdGNoL25vZGVfbW9kdWxlcy9nbC1idWZmZXIvbm9kZV9tb2R1bGVzL3R5cGVkYXJyYXktcG9vbC9wb29sLmpzIiwibm9kZV9tb2R1bGVzL2dsLXNwcml0ZS10ZXh0L25vZGVfbW9kdWxlcy9nbC1zcHJpdGUtYmF0Y2gvbm9kZV9tb2R1bGVzL2dsLWJ1ZmZlci9ub2RlX21vZHVsZXMvd2ViZ2xldy9ub2RlX21vZHVsZXMvd2Vhay1tYXAvd2Vhay1tYXAuanMiLCJub2RlX21vZHVsZXMvZ2wtc3ByaXRlLXRleHQvbm9kZV9tb2R1bGVzL2dsLXNwcml0ZS1iYXRjaC9ub2RlX21vZHVsZXMvZ2wtYnVmZmVyL25vZGVfbW9kdWxlcy93ZWJnbGV3L3dlYmdsZXcuanMiLCJub2RlX21vZHVsZXMvZ2wtc3ByaXRlLXRleHQvbm9kZV9tb2R1bGVzL2dsLXNwcml0ZS1iYXRjaC9ub2RlX21vZHVsZXMvbWl4ZXMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZ2wtc3ByaXRlLXRleHQvbm9kZV9tb2R1bGVzL2dsLXRleHR1cmUyZC9ub2RlX21vZHVsZXMvbmRhcnJheS1vcHMvbmRhcnJheS1vcHMuanMiLCJub2RlX21vZHVsZXMvZ2wtc3ByaXRlLXRleHQvbm9kZV9tb2R1bGVzL2dsLXRleHR1cmUyZC9ub2RlX21vZHVsZXMvdHlwZWRhcnJheS1wb29sL3Bvb2wuanMiLCJub2RlX21vZHVsZXMvZ2wtc3ByaXRlLXRleHQvbm9kZV9tb2R1bGVzL2dsLXRleHR1cmUyZC9ub2RlX21vZHVsZXMvd2ViZ2xldy93ZWJnbGV3LmpzIiwibm9kZV9tb2R1bGVzL2dsLXNwcml0ZS10ZXh0L25vZGVfbW9kdWxlcy9nbC10ZXh0dXJlMmQvdGV4dHVyZS5qcyIsIm5vZGVfbW9kdWxlcy9nbC1zcHJpdGUtdGV4dC9ub2RlX21vZHVsZXMvZ2wtd2hpdGUtdGV4dHVyZS9ub2RlX21vZHVsZXMvbmRhcnJheS9uZGFycmF5LmpzIiwibm9kZV9tb2R1bGVzL2dsLXNwcml0ZS10ZXh0L25vZGVfbW9kdWxlcy9nbC13aGl0ZS10ZXh0dXJlL25vZGVfbW9kdWxlcy9uZGFycmF5L25vZGVfbW9kdWxlcy9pb3RhLWFycmF5L2lvdGEuanMiLCJub2RlX21vZHVsZXMvZ2wtc3ByaXRlLXRleHQvbm9kZV9tb2R1bGVzL2luaGVyaXRzL2luaGVyaXRzX2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvZ2wtc3ByaXRlLXRleHQvbm9kZV9tb2R1bGVzL25kYXJyYXkvbmRhcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9nbC1zcHJpdGUtdGV4dC9ub2RlX21vZHVsZXMveHRlbmQvaW1tdXRhYmxlLmpzIiwibm9kZV9tb2R1bGVzL2dsLXRleHR1cmUyZC90ZXh0dXJlLmpzIiwibm9kZV9tb2R1bGVzL2dsLXZlYzMvc2V0LmpzIiwibm9kZV9tb2R1bGVzL2dsc2xpZnkvYWRhcHRlci5qcyIsIm5vZGVfbW9kdWxlcy9nbHNsaWZ5L2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvZ2xzbGlmeS9ub2RlX21vZHVsZXMvZ2wtc2hhZGVyLWNvcmUvbGliL2NyZWF0ZS1hdHRyaWJ1dGVzLmpzIiwibm9kZV9tb2R1bGVzL2dsc2xpZnkvbm9kZV9tb2R1bGVzL2dsLXNoYWRlci1jb3JlL2xpYi9jcmVhdGUtdW5pZm9ybXMuanMiLCJub2RlX21vZHVsZXMvZ2xzbGlmeS9ub2RlX21vZHVsZXMvZ2wtc2hhZGVyLWNvcmUvbGliL3JlZmxlY3QuanMiLCJub2RlX21vZHVsZXMvZ2xzbGlmeS9ub2RlX21vZHVsZXMvZ2wtc2hhZGVyLWNvcmUvbm9kZV9tb2R1bGVzL2R1cC9kdXAuanMiLCJub2RlX21vZHVsZXMvZ2xzbGlmeS9ub2RlX21vZHVsZXMvZ2wtc2hhZGVyLWNvcmUvc2hhZGVyLWNvcmUuanMiLCJub2RlX21vZHVsZXMvZ2xzbGlmeS9zaW1wbGUtYWRhcHRlci5qcyIsIm5vZGVfbW9kdWxlcy9pbWcvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9taXhlcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9ub3JtYWxpemUtcGF0aC1zY2FsZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9ub3JtYWxpemUtcGF0aC1zY2FsZS9ub2RlX21vZHVsZXMvZ2V0Ym91bmRpbmdib3gvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcGFyc2Utc3ZnLXBhdGgvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcGx1Y2tlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9yYWYuanMvcmFmLmpzIiwibm9kZV9tb2R1bGVzL3NpbXBsaWZ5LXBhdGgvZG91Z2xhcy1wZXVja2VyLmpzIiwibm9kZV9tb2R1bGVzL3NpbXBsaWZ5LXBhdGgvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc2ltcGxpZnktcGF0aC9yYWRpYWwtZGlzdGFuY2UuanMiLCJub2RlX21vZHVsZXMvc21vb3Roc3RlcC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zdmctcGF0aC1jb250b3Vycy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zdmctcGF0aC1jb250b3Vycy9ub2RlX21vZHVsZXMvYWJzLXN2Zy1wYXRoL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3N2Zy1wYXRoLWNvbnRvdXJzL25vZGVfbW9kdWxlcy9hZGFwdGl2ZS1iZXppZXItY3VydmUvZnVuY3Rpb24uanMiLCJub2RlX21vZHVsZXMvc3ZnLXBhdGgtY29udG91cnMvbm9kZV9tb2R1bGVzL2FkYXB0aXZlLWJlemllci1jdXJ2ZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zdmctcGF0aC1jb250b3Vycy9ub2RlX21vZHVsZXMvbm9ybWFsaXplLXN2Zy1wYXRoL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3N2Zy1wYXRoLWNvbnRvdXJzL25vZGVfbW9kdWxlcy92ZWMyLWNvcHkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdGhyZWUtZWZmZWN0Y29tcG9zZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdGhyZWUtZWZmZWN0Y29tcG9zZXIvbGliL2NsZWFybWFza3Bhc3MuanMiLCJub2RlX21vZHVsZXMvdGhyZWUtZWZmZWN0Y29tcG9zZXIvbGliL21hc2twYXNzLmpzIiwibm9kZV9tb2R1bGVzL3RocmVlLWVmZmVjdGNvbXBvc2VyL2xpYi9yZW5kZXJwYXNzLmpzIiwibm9kZV9tb2R1bGVzL3RocmVlLWVmZmVjdGNvbXBvc2VyL2xpYi9zaGFkZXJwYXNzLmpzIiwibm9kZV9tb2R1bGVzL3RocmVlLWVmZmVjdGNvbXBvc2VyL25vZGVfbW9kdWxlcy90aHJlZS1jb3B5c2hhZGVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3RocmVlLWdsc2xpZnkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdGhyZWUtZ2xzbGlmeS90eXBlcy5qcyIsIm5vZGVfbW9kdWxlcy90aHJlZS1zZGYtdGV4dC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy90aHJlZS1zZGYtdGV4dC9saWIvcmVuZGVyZXIuanMiLCJub2RlX21vZHVsZXMvdGhyZWUtc2RmLXRleHQvbGliL3RleHR1cmUtd3JhcC5qcyIsIm5vZGVfbW9kdWxlcy90aHJlZS1zZGYtdGV4dC9ub2RlX21vZHVsZXMvYXMtbnVtYmVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3RocmVlLXNkZi10ZXh0L25vZGVfbW9kdWxlcy9nbC1tYXQ0L2NyZWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy90aHJlZS1zZGYtdGV4dC9ub2RlX21vZHVsZXMvZ2wtbWF0NC9tdWx0aXBseS5qcyIsIm5vZGVfbW9kdWxlcy90aHJlZS1zZGYtdGV4dC9ub2RlX21vZHVsZXMvZ2wtbWF0NC9zY2FsZS5qcyIsIm5vZGVfbW9kdWxlcy90aHJlZS1zZGYtdGV4dC9ub2RlX21vZHVsZXMvZ2wtc2hhZGVyLWNvcmUvc2hhZGVyLWNvcmUuanMiLCJub2RlX21vZHVsZXMvdGhyZWUtc2RmLXRleHQvbm9kZV9tb2R1bGVzL2dsLXNwcml0ZS10ZXh0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3RocmVlLXNkZi10ZXh0L25vZGVfbW9kdWxlcy9nbC1zcHJpdGUtdGV4dC9ub2RlX21vZHVsZXMvZm9udHBhdGgtYm1mb250L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3RocmVlLXNkZi10ZXh0L25vZGVfbW9kdWxlcy9nbC1zcHJpdGUtdGV4dC9ub2RlX21vZHVsZXMvZm9udHBhdGgtc2ltcGxlLXJlbmRlcmVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3RocmVlLXNkZi10ZXh0L25vZGVfbW9kdWxlcy9nbC1zcHJpdGUtdGV4dC9ub2RlX21vZHVsZXMvZm9udHBhdGgtc2ltcGxlLXJlbmRlcmVyL25vZGVfbW9kdWxlcy9mb250cGF0aC1yZW5kZXJlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy90aHJlZS1zZGYtdGV4dC9ub2RlX21vZHVsZXMvZ2wtc3ByaXRlLXRleHQvbm9kZV9tb2R1bGVzL2ZvbnRwYXRoLXNpbXBsZS1yZW5kZXJlci9ub2RlX21vZHVsZXMvZm9udHBhdGgtcmVuZGVyZXIvbm9kZV9tb2R1bGVzL2ZvbnRwYXRoLWdseXBoLWl0ZXJhdG9yL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3RocmVlLXNkZi10ZXh0L25vZGVfbW9kdWxlcy9nbC1zcHJpdGUtdGV4dC9ub2RlX21vZHVsZXMvZm9udHBhdGgtc2ltcGxlLXJlbmRlcmVyL25vZGVfbW9kdWxlcy9mb250cGF0aC1yZW5kZXJlci9ub2RlX21vZHVsZXMvZm9udHBhdGgtdXRpbC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy90aHJlZS1zZGYtdGV4dC9ub2RlX21vZHVsZXMvZ2wtc3ByaXRlLXRleHQvbm9kZV9tb2R1bGVzL2ZvbnRwYXRoLXNpbXBsZS1yZW5kZXJlci9ub2RlX21vZHVsZXMvZm9udHBhdGgtcmVuZGVyZXIvbm9kZV9tb2R1bGVzL2ZvbnRwYXRoLXdvcmR3cmFwL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3RocmVlLXNkZi10ZXh0L25vZGVfbW9kdWxlcy9nbC1zcHJpdGUtdGV4dC9ub2RlX21vZHVsZXMvZ2wtc3ByaXRlLWJhdGNoL2NvbW1vbi5qcyIsIm5vZGVfbW9kdWxlcy90aHJlZS1zZGYtdGV4dC9ub2RlX21vZHVsZXMvZ2wtc3ByaXRlLXRleHQvbm9kZV9tb2R1bGVzL2dsLXNwcml0ZS1iYXRjaC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy90aHJlZS1zZGYtdGV4dC9ub2RlX21vZHVsZXMvZ2wtc3ByaXRlLXRleHQvbm9kZV9tb2R1bGVzL2dsLXNwcml0ZS1iYXRjaC9ub2RlX21vZHVsZXMvZ2wtYWxpYXNlZC12YW8vaW5kZXguanMiLCJub2RlX21vZHVsZXMvdGhyZWUtc2RmLXRleHQvbm9kZV9tb2R1bGVzL2dsLXNwcml0ZS10ZXh0L25vZGVfbW9kdWxlcy9nbC1zcHJpdGUtYmF0Y2gvbm9kZV9tb2R1bGVzL2dsLWFsaWFzZWQtdmFvL2xpYi9kby1iaW5kLmpzIiwibm9kZV9tb2R1bGVzL3RocmVlLXNkZi10ZXh0L25vZGVfbW9kdWxlcy9nbC1zcHJpdGUtdGV4dC9ub2RlX21vZHVsZXMvZ2wtc3ByaXRlLWJhdGNoL25vZGVfbW9kdWxlcy9nbC1hbGlhc2VkLXZhby9saWIvdmFvLWVtdWxhdGVkLmpzIiwibm9kZV9tb2R1bGVzL3RocmVlLXNkZi10ZXh0L25vZGVfbW9kdWxlcy9nbC1zcHJpdGUtdGV4dC9ub2RlX21vZHVsZXMvZ2wtc3ByaXRlLWJhdGNoL25vZGVfbW9kdWxlcy9nbC1idWZmZXIvYnVmZmVyLmpzIiwibm9kZV9tb2R1bGVzL3RocmVlLXNkZi10ZXh0L25vZGVfbW9kdWxlcy9nbC1zcHJpdGUtdGV4dC9ub2RlX21vZHVsZXMvZ2wtc3ByaXRlLWJhdGNoL25vZGVfbW9kdWxlcy9nbC1idWZmZXIvbm9kZV9tb2R1bGVzL25kYXJyYXktb3BzL25kYXJyYXktb3BzLmpzIiwibm9kZV9tb2R1bGVzL3RocmVlLXNkZi10ZXh0L25vZGVfbW9kdWxlcy9nbC1zcHJpdGUtdGV4dC9ub2RlX21vZHVsZXMvZ2wtc3ByaXRlLWJhdGNoL25vZGVfbW9kdWxlcy9nbC1idWZmZXIvbm9kZV9tb2R1bGVzL25kYXJyYXkvbmRhcnJheS5qcyIsIm5vZGVfbW9kdWxlcy90aHJlZS1zZGYtdGV4dC9ub2RlX21vZHVsZXMvZ2wtc3ByaXRlLXRleHQvbm9kZV9tb2R1bGVzL2dsLXNwcml0ZS1iYXRjaC9ub2RlX21vZHVsZXMvZ2wtYnVmZmVyL25vZGVfbW9kdWxlcy9uZGFycmF5L25vZGVfbW9kdWxlcy9pb3RhLWFycmF5L2lvdGEuanMiLCJub2RlX21vZHVsZXMvdGhyZWUtc2RmLXRleHQvbm9kZV9tb2R1bGVzL2dsLXNwcml0ZS10ZXh0L25vZGVfbW9kdWxlcy9nbC1zcHJpdGUtYmF0Y2gvbm9kZV9tb2R1bGVzL2dsLWJ1ZmZlci9ub2RlX21vZHVsZXMvdHlwZWRhcnJheS1wb29sL3Bvb2wuanMiLCJub2RlX21vZHVsZXMvdGhyZWUtc2RmLXRleHQvbm9kZV9tb2R1bGVzL2dsLXNwcml0ZS10ZXh0L25vZGVfbW9kdWxlcy9nbC1zcHJpdGUtYmF0Y2gvbm9kZV9tb2R1bGVzL2dsLWJ1ZmZlci9ub2RlX21vZHVsZXMvd2ViZ2xldy93ZWJnbGV3LmpzIiwibm9kZV9tb2R1bGVzL3RocmVlLXNkZi10ZXh0L25vZGVfbW9kdWxlcy9nbC1zcHJpdGUtdGV4dC9ub2RlX21vZHVsZXMvZ2wtc3ByaXRlLWJhdGNoL25vZGVfbW9kdWxlcy9nbC13aGl0ZS10ZXh0dXJlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3RocmVlLXNkZi10ZXh0L25vZGVfbW9kdWxlcy9nbC1zcHJpdGUtdGV4dC9ub2RlX21vZHVsZXMvZ2wtc3ByaXRlLWJhdGNoL25vZGVfbW9kdWxlcy9nbC13aGl0ZS10ZXh0dXJlL25vZGVfbW9kdWxlcy9uZGFycmF5L25kYXJyYXkuanMiLCJub2RlX21vZHVsZXMvdGhyZWUtc2RmLXRleHQvbm9kZV9tb2R1bGVzL2dsLXNwcml0ZS10ZXh0L25vZGVfbW9kdWxlcy9nbC1zcHJpdGUtYmF0Y2gvbm9kZV9tb2R1bGVzL21peGVzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3RocmVlLXNkZi10ZXh0L25vZGVfbW9kdWxlcy9nbC1zcHJpdGUtdGV4dC9ub2RlX21vZHVsZXMvZ2wtc3ByaXRlLWJhdGNoL25vZGVfbW9kdWxlcy9udW1iZXItdXRpbC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy90aHJlZS1zZGYtdGV4dC9ub2RlX21vZHVsZXMvZ2wtc3ByaXRlLXRleHQvbm9kZV9tb2R1bGVzL2dsLXNwcml0ZS1iYXRjaC9ub2RlX21vZHVsZXMvcHJlbXVsdGlwbGllZC1yZ2JhL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3RocmVlLXNkZi10ZXh0L25vZGVfbW9kdWxlcy9nbC1zcHJpdGUtdGV4dC9ub2RlX21vZHVsZXMvZ2wtc3ByaXRlLWJhdGNoL3BhY2stcmdiYS1mbG9hdC5qcyIsIm5vZGVfbW9kdWxlcy90aHJlZS1zZGYtdGV4dC9ub2RlX21vZHVsZXMvZ2wtc3ByaXRlLXRleHQvbm9kZV9tb2R1bGVzL2luaGVyaXRzL2luaGVyaXRzX2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvdGhyZWUtc2RmLXRleHQvbm9kZV9tb2R1bGVzL2dsLXNwcml0ZS10ZXh0L25vZGVfbW9kdWxlcy90ZXhjb29yZC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy90aHJlZS1zZGYtdGV4dC9ub2RlX21vZHVsZXMvZ2wtdGV4dHVyZTJkL3RleHR1cmUuanMiLCJub2RlX21vZHVsZXMvdGhyZWUtc2RmLXRleHQvbm9kZV9tb2R1bGVzL3h0ZW5kL2ltbXV0YWJsZS5qcyIsIm5vZGVfbW9kdWxlcy90aHJlZS1zaGFkZXItZnhhYS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy90aHJlZS1zaW1wbGljaWFsLWNvbXBsZXgvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdHJpYW5ndWxhdGUtY29udG91cnMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdHJpYW5ndWxhdGUtY29udG91cnMvbm9kZV9tb2R1bGVzL3Rlc3MyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3RyaWFuZ3VsYXRlLWNvbnRvdXJzL25vZGVfbW9kdWxlcy90ZXNzMi9zcmMvdGVzczIuanMiLCJub2RlX21vZHVsZXMvdW5sZXJwL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3h0ZW5kL2ltbXV0YWJsZS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JFQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0hBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3cEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN2NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOVJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7O0FDQUE7O0FDQUE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOWlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOVlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hEQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7O0FDQUE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDck1BOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0SEE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBOztBQ0FBOztBQ0FBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNySkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeE9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUpBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMVZBOztBQ0FBOztBQ0FBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7O0FDQUE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTs7QUNBQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3REQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2gyR0E7QUFDQTtBQUNBOztBQ0ZBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIihmdW5jdGlvbiAoZ2xvYmFsKXtcbnZhciBhcHAgPSByZXF1aXJlKCdjYW52YXMtYXBwJykocmVuZGVyLCB7XG4gICAgY29udGV4dDogJ3dlYmdsJyxcbiAgICBjb250ZXh0QXR0cmlidXRlczogeyBhbnRpYWxpYXM6IGZhbHNlLCBhbHBoYTogZmFsc2UgfSxcbiAgICByZXRpbmE6IHRydWUsXG4gICAgb25SZXNpemU6IGhhbmRsZVJlc2l6ZVxufSlcblxudmFyIFRIUkVFID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cuVEhSRUUgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsLlRIUkVFIDogbnVsbClcbnZhciBSZW5kZXJlciA9IHJlcXVpcmUoJy4vbGliL3JlbmRlcmVyJylcbnZhciBjcmVhdGVGb250ID0gcmVxdWlyZSgnLi9saWIvY3JlYXRlLWZvbnQnKVxuXG5cbnZhciByZW5kZXJlclxuXG5mdW5jdGlvbiByZW5kZXIoZ2wsIHdpZHRoLCBoZWlnaHQsIGR0KSB7XG4gICAgaWYgKHJlbmRlcmVyKVxuICAgICAgICByZW5kZXJlci5kcmF3KGR0KVxufVxuXG5mdW5jdGlvbiBoYW5kbGVSZXNpemUod2lkdGgsIGhlaWdodCkge1xuICAgIGlmIChyZW5kZXJlcilcbiAgICAgICAgcmVuZGVyZXIucmVzaXplKHdpZHRoLCBoZWlnaHQpXG59XG5cbnJlcXVpcmUoJ3JhZi5qcycpXG5yZXF1aXJlKCdkb21yZWFkeScpKGZ1bmN0aW9uKCkge1xuICAgIGRvY3VtZW50LmJvZHkuc3R5bGUubWFyZ2luID0gJzAnXG4gICAgZG9jdW1lbnQuYm9keS5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nXG4gICAgYXBwLmNhbnZhcy5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJ1xuXG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChhcHAuY2FudmFzKVxuXG4gICAgdmFyIGdsID0gYXBwLmNvbnRleHRcbiAgICBjcmVhdGVGb250KGdsLCBmdW5jdGlvbihlcnIsIGZvbnQpIHtcbiAgICAgICAgaWYgKGVycilcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKVxuXG4gICAgICAgIHJlbmRlcmVyID0gUmVuZGVyZXIoe1xuICAgICAgICAgICAgZ2w6IGdsLCBcbiAgICAgICAgICAgIHdpZHRoOiBhcHAud2lkdGgsIFxuICAgICAgICAgICAgaGVpZ2h0OiBhcHAuaGVpZ2h0LFxuICAgICAgICAgICAgZm9udDogZm9udFxuICAgICAgICB9KSBcbiAgICAgICAgYXBwLnN0YXJ0KClcbiAgICB9KVxufSlcblxuXG5cblxuXG5mdW5jdGlvbiBzZXR1cFNtb290aFRleChnbCwgdCkge1xuICAgIHQubWluRmlsdGVyID0gZ2wuTElORUFSX01JUE1BUF9MSU5FQVJcbiAgICB0Lm1hZ0ZpbHRlciA9IGdsLkxJTkVBUlxuXG4gICAgdmFyIGV4dCA9IChnbC5nZXRFeHRlbnNpb24oJ0VYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpYycpIFxuICAgICAgICAgICAgICAgICAgICB8fCBnbC5nZXRFeHRlbnNpb24oXCJNT1pfRVhUX3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljXCIpKTtcbiAgICBpZiAoZXh0KSB7XG4gICAgICAgIHZhciBtYXhBbmlzdHJvcGh5ID0gZ2wuZ2V0UGFyYW1ldGVyKGV4dC5NQVhfVEVYVFVSRV9NQVhfQU5JU09UUk9QWV9FWFQpO1xuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJmKGdsLlRFWFRVUkVfMkQsIGV4dC5URVhUVVJFX01BWF9BTklTT1RST1BZX0VYVCwgTWF0aC5taW4oMTYsIG1heEFuaXN0cm9waHkpKTtcbiAgICB9XG5cbiAgICB0LmdlbmVyYXRlTWlwbWFwKClcbn1cblxuZnVuY3Rpb24gc2V0dXBOZWFyZXN0VGV4KGdsLCB0KSB7XG4gICAgdC5taW5GaWx0ZXIgPSB0Lm1hZ0ZpbHRlciA9IGdsLk5FQVJFU1Rcbn1cbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KSIsIm1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPW1vZHVsZS5leHBvcnRzPXtcInBhZ2VzXCI6W1wiRXhvMlNlbWlCb2xkLnBuZ1wiXSxcImNoYXJzXCI6W3tcImlkXCI6MzIsXCJ4XCI6MCxcInlcIjowLFwid2lkdGhcIjowLFwiaGVpZ2h0XCI6MCxcInhvZmZzZXRcIjowLFwieW9mZnNldFwiOjMzLFwieGFkdmFuY2VcIjo3LFwicGFnZVwiOjAsXCJjaG5sXCI6MH0se1wiaWRcIjo0MSxcInhcIjowLFwieVwiOjAsXCJ3aWR0aFwiOjIwLFwiaGVpZ2h0XCI6NDEsXCJ4b2Zmc2V0XCI6LTQsXCJ5b2Zmc2V0XCI6MyxcInhhZHZhbmNlXCI6MTIsXCJwYWdlXCI6MCxcImNobmxcIjowfSx7XCJpZFwiOjQwLFwieFwiOjIwLFwieVwiOjAsXCJ3aWR0aFwiOjE5LFwiaGVpZ2h0XCI6NDEsXCJ4b2Zmc2V0XCI6LTMsXCJ5b2Zmc2V0XCI6MyxcInhhZHZhbmNlXCI6MTIsXCJwYWdlXCI6MCxcImNobmxcIjowfSx7XCJpZFwiOjEyNCxcInhcIjozOSxcInlcIjowLFwid2lkdGhcIjoxMyxcImhlaWdodFwiOjQwLFwieG9mZnNldFwiOi0yLFwieW9mZnNldFwiOjMsXCJ4YWR2YW5jZVwiOjgsXCJwYWdlXCI6MCxcImNobmxcIjowfSx7XCJpZFwiOjEyNSxcInhcIjo1MixcInlcIjowLFwid2lkdGhcIjoxOCxcImhlaWdodFwiOjQwLFwieG9mZnNldFwiOi0zLFwieW9mZnNldFwiOjQsXCJ4YWR2YW5jZVwiOjExLFwicGFnZVwiOjAsXCJjaG5sXCI6MH0se1wiaWRcIjoxMjMsXCJ4XCI6NzAsXCJ5XCI6MCxcIndpZHRoXCI6MTgsXCJoZWlnaHRcIjo0MCxcInhvZmZzZXRcIjotMyxcInlvZmZzZXRcIjo0LFwieGFkdmFuY2VcIjoxMSxcInBhZ2VcIjowLFwiY2hubFwiOjB9LHtcImlkXCI6MzYsXCJ4XCI6ODgsXCJ5XCI6MCxcIndpZHRoXCI6MjUsXCJoZWlnaHRcIjozOSxcInhvZmZzZXRcIjotMyxcInlvZmZzZXRcIjozLFwieGFkdmFuY2VcIjoxOCxcInBhZ2VcIjowLFwiY2hubFwiOjB9LHtcImlkXCI6OTMsXCJ4XCI6MTEzLFwieVwiOjAsXCJ3aWR0aFwiOjE3LFwiaGVpZ2h0XCI6MzksXCJ4b2Zmc2V0XCI6LTMsXCJ5b2Zmc2V0XCI6NCxcInhhZHZhbmNlXCI6MTEsXCJwYWdlXCI6MCxcImNobmxcIjowfSx7XCJpZFwiOjkxLFwieFwiOjEzMCxcInlcIjowLFwid2lkdGhcIjoxNyxcImhlaWdodFwiOjM5LFwieG9mZnNldFwiOi0yLFwieW9mZnNldFwiOjQsXCJ4YWR2YW5jZVwiOjExLFwicGFnZVwiOjAsXCJjaG5sXCI6MH0se1wiaWRcIjo4MSxcInhcIjoxNDcsXCJ5XCI6MCxcIndpZHRoXCI6MjgsXCJoZWlnaHRcIjozOSxcInhvZmZzZXRcIjotMyxcInlvZmZzZXRcIjo2LFwieGFkdmFuY2VcIjoyMixcInBhZ2VcIjowLFwiY2hubFwiOjB9LHtcImlkXCI6MTA2LFwieFwiOjE3NSxcInlcIjowLFwid2lkdGhcIjoxNixcImhlaWdodFwiOjM4LFwieG9mZnNldFwiOi00LFwieW9mZnNldFwiOjYsXCJ4YWR2YW5jZVwiOjksXCJwYWdlXCI6MCxcImNobmxcIjowfSx7XCJpZFwiOjkyLFwieFwiOjE5MSxcInlcIjowLFwid2lkdGhcIjoyNixcImhlaWdodFwiOjM0LFwieG9mZnNldFwiOi00LFwieW9mZnNldFwiOjYsXCJ4YWR2YW5jZVwiOjE3LFwicGFnZVwiOjAsXCJjaG5sXCI6MH0se1wiaWRcIjo0NyxcInhcIjoyMTcsXCJ5XCI6MCxcIndpZHRoXCI6MjYsXCJoZWlnaHRcIjozNCxcInhvZmZzZXRcIjotNCxcInlvZmZzZXRcIjo2LFwieGFkdmFuY2VcIjoxNyxcInBhZ2VcIjowLFwiY2hubFwiOjB9LHtcImlkXCI6MTAyLFwieFwiOjI0MyxcInlcIjowLFwid2lkdGhcIjoyMyxcImhlaWdodFwiOjMzLFwieG9mZnNldFwiOi00LFwieW9mZnNldFwiOjUsXCJ4YWR2YW5jZVwiOjEzLFwicGFnZVwiOjAsXCJjaG5sXCI6MH0se1wiaWRcIjozOCxcInhcIjoyNjYsXCJ5XCI6MCxcIndpZHRoXCI6MzIsXCJoZWlnaHRcIjozMixcInhvZmZzZXRcIjotMyxcInlvZmZzZXRcIjo2LFwieGFkdmFuY2VcIjoyNSxcInBhZ2VcIjowLFwiY2hubFwiOjB9LHtcImlkXCI6MzUsXCJ4XCI6Mjk4LFwieVwiOjAsXCJ3aWR0aFwiOjMwLFwiaGVpZ2h0XCI6MzIsXCJ4b2Zmc2V0XCI6LTMsXCJ5b2Zmc2V0XCI6NixcInhhZHZhbmNlXCI6MjIsXCJwYWdlXCI6MCxcImNobmxcIjowfSx7XCJpZFwiOjM3LFwieFwiOjMyOCxcInlcIjowLFwid2lkdGhcIjozNixcImhlaWdodFwiOjMyLFwieG9mZnNldFwiOi0zLFwieW9mZnNldFwiOjYsXCJ4YWR2YW5jZVwiOjI5LFwicGFnZVwiOjAsXCJjaG5sXCI6MH0se1wiaWRcIjo2MyxcInhcIjozNjQsXCJ5XCI6MCxcIndpZHRoXCI6MjQsXCJoZWlnaHRcIjozMixcInhvZmZzZXRcIjotMyxcInlvZmZzZXRcIjo2LFwieGFkdmFuY2VcIjoxNixcInBhZ2VcIjowLFwiY2hubFwiOjB9LHtcImlkXCI6MzMsXCJ4XCI6Mzg4LFwieVwiOjAsXCJ3aWR0aFwiOjE0LFwiaGVpZ2h0XCI6MzIsXCJ4b2Zmc2V0XCI6LTIsXCJ5b2Zmc2V0XCI6NixcInhhZHZhbmNlXCI6OSxcInBhZ2VcIjowLFwiY2hubFwiOjB9LHtcImlkXCI6NDgsXCJ4XCI6NDAyLFwieVwiOjAsXCJ3aWR0aFwiOjI2LFwiaGVpZ2h0XCI6MzIsXCJ4b2Zmc2V0XCI6LTMsXCJ5b2Zmc2V0XCI6NixcInhhZHZhbmNlXCI6MjAsXCJwYWdlXCI6MCxcImNobmxcIjowfSx7XCJpZFwiOjU3LFwieFwiOjQyOCxcInlcIjowLFwid2lkdGhcIjoyNSxcImhlaWdodFwiOjMyLFwieG9mZnNldFwiOi0zLFwieW9mZnNldFwiOjYsXCJ4YWR2YW5jZVwiOjE5LFwicGFnZVwiOjAsXCJjaG5sXCI6MH0se1wiaWRcIjo1NixcInhcIjo0NTMsXCJ5XCI6MCxcIndpZHRoXCI6MjYsXCJoZWlnaHRcIjozMixcInhvZmZzZXRcIjotMyxcInlvZmZzZXRcIjo2LFwieGFkdmFuY2VcIjoyMCxcInBhZ2VcIjowLFwiY2hubFwiOjB9LHtcImlkXCI6NTUsXCJ4XCI6NDc5LFwieVwiOjAsXCJ3aWR0aFwiOjI0LFwiaGVpZ2h0XCI6MzIsXCJ4b2Zmc2V0XCI6LTMsXCJ5b2Zmc2V0XCI6NixcInhhZHZhbmNlXCI6MTcsXCJwYWdlXCI6MCxcImNobmxcIjowfSx7XCJpZFwiOjU0LFwieFwiOjAsXCJ5XCI6NDEsXCJ3aWR0aFwiOjI2LFwiaGVpZ2h0XCI6MzIsXCJ4b2Zmc2V0XCI6LTMsXCJ5b2Zmc2V0XCI6NixcInhhZHZhbmNlXCI6MTksXCJwYWdlXCI6MCxcImNobmxcIjowfSx7XCJpZFwiOjUzLFwieFwiOjI2LFwieVwiOjQxLFwid2lkdGhcIjoyNCxcImhlaWdodFwiOjMyLFwieG9mZnNldFwiOi0zLFwieW9mZnNldFwiOjYsXCJ4YWR2YW5jZVwiOjE3LFwicGFnZVwiOjAsXCJjaG5sXCI6MH0se1wiaWRcIjo1MixcInhcIjo1MCxcInlcIjo0MSxcIndpZHRoXCI6MjcsXCJoZWlnaHRcIjozMixcInhvZmZzZXRcIjotMyxcInlvZmZzZXRcIjo2LFwieGFkdmFuY2VcIjoyMCxcInBhZ2VcIjowLFwiY2hubFwiOjB9LHtcImlkXCI6NTEsXCJ4XCI6NzcsXCJ5XCI6NDEsXCJ3aWR0aFwiOjI1LFwiaGVpZ2h0XCI6MzIsXCJ4b2Zmc2V0XCI6LTMsXCJ5b2Zmc2V0XCI6NixcInhhZHZhbmNlXCI6MTgsXCJwYWdlXCI6MCxcImNobmxcIjowfSx7XCJpZFwiOjUwLFwieFwiOjEwMixcInlcIjo0MSxcIndpZHRoXCI6MjUsXCJoZWlnaHRcIjozMixcInhvZmZzZXRcIjotMyxcInlvZmZzZXRcIjo2LFwieGFkdmFuY2VcIjoxOCxcInBhZ2VcIjowLFwiY2hubFwiOjB9LHtcImlkXCI6NDksXCJ4XCI6MTI3LFwieVwiOjQxLFwid2lkdGhcIjoxOSxcImhlaWdodFwiOjMyLFwieG9mZnNldFwiOi00LFwieW9mZnNldFwiOjYsXCJ4YWR2YW5jZVwiOjEzLFwicGFnZVwiOjAsXCJjaG5sXCI6MH0se1wiaWRcIjoxMjEsXCJ4XCI6MTQ2LFwieVwiOjQxLFwid2lkdGhcIjoyNyxcImhlaWdodFwiOjMyLFwieG9mZnNldFwiOi00LFwieW9mZnNldFwiOjEyLFwieGFkdmFuY2VcIjoxNyxcInBhZ2VcIjowLFwiY2hubFwiOjB9LHtcImlkXCI6MTEzLFwieFwiOjE3MyxcInlcIjo0MSxcIndpZHRoXCI6MjUsXCJoZWlnaHRcIjozMixcInhvZmZzZXRcIjotMyxcInlvZmZzZXRcIjoxMixcInhhZHZhbmNlXCI6MTksXCJwYWdlXCI6MCxcImNobmxcIjowfSx7XCJpZFwiOjExMixcInhcIjoxOTgsXCJ5XCI6NDEsXCJ3aWR0aFwiOjI1LFwiaGVpZ2h0XCI6MzIsXCJ4b2Zmc2V0XCI6LTIsXCJ5b2Zmc2V0XCI6MTIsXCJ4YWR2YW5jZVwiOjE5LFwicGFnZVwiOjAsXCJjaG5sXCI6MH0se1wiaWRcIjoxMDgsXCJ4XCI6MjIzLFwieVwiOjQxLFwid2lkdGhcIjoxNyxcImhlaWdodFwiOjMyLFwieG9mZnNldFwiOi0yLFwieW9mZnNldFwiOjYsXCJ4YWR2YW5jZVwiOjEwLFwicGFnZVwiOjAsXCJjaG5sXCI6MH0se1wiaWRcIjoxMDcsXCJ4XCI6MjQwLFwieVwiOjQxLFwid2lkdGhcIjoyNCxcImhlaWdodFwiOjMyLFwieG9mZnNldFwiOi0yLFwieW9mZnNldFwiOjYsXCJ4YWR2YW5jZVwiOjE3LFwicGFnZVwiOjAsXCJjaG5sXCI6MH0se1wiaWRcIjoxMDUsXCJ4XCI6MjY0LFwieVwiOjQxLFwid2lkdGhcIjoxNCxcImhlaWdodFwiOjMyLFwieG9mZnNldFwiOi0yLFwieW9mZnNldFwiOjYsXCJ4YWR2YW5jZVwiOjgsXCJwYWdlXCI6MCxcImNobmxcIjowfSx7XCJpZFwiOjEwNCxcInhcIjoyNzgsXCJ5XCI6NDEsXCJ3aWR0aFwiOjI0LFwiaGVpZ2h0XCI6MzIsXCJ4b2Zmc2V0XCI6LTIsXCJ5b2Zmc2V0XCI6NixcInhhZHZhbmNlXCI6MTksXCJwYWdlXCI6MCxcImNobmxcIjowfSx7XCJpZFwiOjEwMyxcInhcIjozMDIsXCJ5XCI6NDEsXCJ3aWR0aFwiOjI3LFwiaGVpZ2h0XCI6MzIsXCJ4b2Zmc2V0XCI6LTQsXCJ5b2Zmc2V0XCI6MTIsXCJ4YWR2YW5jZVwiOjE4LFwicGFnZVwiOjAsXCJjaG5sXCI6MH0se1wiaWRcIjoxMDAsXCJ4XCI6MzI5LFwieVwiOjQxLFwid2lkdGhcIjoyNSxcImhlaWdodFwiOjMyLFwieG9mZnNldFwiOi0zLFwieW9mZnNldFwiOjYsXCJ4YWR2YW5jZVwiOjE5LFwicGFnZVwiOjAsXCJjaG5sXCI6MH0se1wiaWRcIjo5OCxcInhcIjozNTQsXCJ5XCI6NDEsXCJ3aWR0aFwiOjI1LFwiaGVpZ2h0XCI6MzIsXCJ4b2Zmc2V0XCI6LTIsXCJ5b2Zmc2V0XCI6NixcInhhZHZhbmNlXCI6MTksXCJwYWdlXCI6MCxcImNobmxcIjowfSx7XCJpZFwiOjkwLFwieFwiOjM3OSxcInlcIjo0MSxcIndpZHRoXCI6MjUsXCJoZWlnaHRcIjozMixcInhvZmZzZXRcIjotMyxcInlvZmZzZXRcIjo2LFwieGFkdmFuY2VcIjoxOCxcInBhZ2VcIjowLFwiY2hubFwiOjB9LHtcImlkXCI6ODksXCJ4XCI6NDA0LFwieVwiOjQxLFwid2lkdGhcIjoyOCxcImhlaWdodFwiOjMyLFwieG9mZnNldFwiOi00LFwieW9mZnNldFwiOjYsXCJ4YWR2YW5jZVwiOjE5LFwicGFnZVwiOjAsXCJjaG5sXCI6MH0se1wiaWRcIjo4OCxcInhcIjo0MzIsXCJ5XCI6NDEsXCJ3aWR0aFwiOjI5LFwiaGVpZ2h0XCI6MzIsXCJ4b2Zmc2V0XCI6LTQsXCJ5b2Zmc2V0XCI6NixcInhhZHZhbmNlXCI6MjAsXCJwYWdlXCI6MCxcImNobmxcIjowfSx7XCJpZFwiOjg3LFwieFwiOjQ2MSxcInlcIjo0MSxcIndpZHRoXCI6MzksXCJoZWlnaHRcIjozMixcInhvZmZzZXRcIjotNCxcInlvZmZzZXRcIjo2LFwieGFkdmFuY2VcIjozMSxcInBhZ2VcIjowLFwiY2hubFwiOjB9LHtcImlkXCI6ODYsXCJ4XCI6MCxcInlcIjo3MyxcIndpZHRoXCI6MjksXCJoZWlnaHRcIjozMixcInhvZmZzZXRcIjotNCxcInlvZmZzZXRcIjo2LFwieGFkdmFuY2VcIjoyMCxcInBhZ2VcIjowLFwiY2hubFwiOjB9LHtcImlkXCI6ODUsXCJ4XCI6MjksXCJ5XCI6NzMsXCJ3aWR0aFwiOjI3LFwiaGVpZ2h0XCI6MzIsXCJ4b2Zmc2V0XCI6LTIsXCJ5b2Zmc2V0XCI6NixcInhhZHZhbmNlXCI6MjEsXCJwYWdlXCI6MCxcImNobmxcIjowfSx7XCJpZFwiOjg0LFwieFwiOjU2LFwieVwiOjczLFwid2lkdGhcIjoyOCxcImhlaWdodFwiOjMyLFwieG9mZnNldFwiOi00LFwieW9mZnNldFwiOjYsXCJ4YWR2YW5jZVwiOjE5LFwicGFnZVwiOjAsXCJjaG5sXCI6MH0se1wiaWRcIjo4MyxcInhcIjo4NCxcInlcIjo3MyxcIndpZHRoXCI6MjUsXCJoZWlnaHRcIjozMixcInhvZmZzZXRcIjotMyxcInlvZmZzZXRcIjo2LFwieGFkdmFuY2VcIjoxOCxcInBhZ2VcIjowLFwiY2hubFwiOjB9LHtcImlkXCI6ODIsXCJ4XCI6MTA5LFwieVwiOjczLFwid2lkdGhcIjoyNixcImhlaWdodFwiOjMyLFwieG9mZnNldFwiOi0yLFwieW9mZnNldFwiOjYsXCJ4YWR2YW5jZVwiOjIwLFwicGFnZVwiOjAsXCJjaG5sXCI6MH0se1wiaWRcIjo4MCxcInhcIjoxMzUsXCJ5XCI6NzMsXCJ3aWR0aFwiOjI2LFwiaGVpZ2h0XCI6MzIsXCJ4b2Zmc2V0XCI6LTIsXCJ5b2Zmc2V0XCI6NixcInhhZHZhbmNlXCI6MTksXCJwYWdlXCI6MCxcImNobmxcIjowfSx7XCJpZFwiOjc5LFwieFwiOjE2MSxcInlcIjo3MyxcIndpZHRoXCI6MjgsXCJoZWlnaHRcIjozMixcInhvZmZzZXRcIjotMyxcInlvZmZzZXRcIjo2LFwieGFkdmFuY2VcIjoyMixcInBhZ2VcIjowLFwiY2hubFwiOjB9LHtcImlkXCI6NzgsXCJ4XCI6MTg5LFwieVwiOjczLFwid2lkdGhcIjoyOCxcImhlaWdodFwiOjMyLFwieG9mZnNldFwiOi0yLFwieW9mZnNldFwiOjYsXCJ4YWR2YW5jZVwiOjIzLFwicGFnZVwiOjAsXCJjaG5sXCI6MH0se1wiaWRcIjo3NyxcInhcIjoyMTcsXCJ5XCI6NzMsXCJ3aWR0aFwiOjM0LFwiaGVpZ2h0XCI6MzIsXCJ4b2Zmc2V0XCI6LTIsXCJ5b2Zmc2V0XCI6NixcInhhZHZhbmNlXCI6MjksXCJwYWdlXCI6MCxcImNobmxcIjowfSx7XCJpZFwiOjc2LFwieFwiOjI1MSxcInlcIjo3MyxcIndpZHRoXCI6MjQsXCJoZWlnaHRcIjozMixcInhvZmZzZXRcIjotMixcInlvZmZzZXRcIjo2LFwieGFkdmFuY2VcIjoxNyxcInBhZ2VcIjowLFwiY2hubFwiOjB9LHtcImlkXCI6NzUsXCJ4XCI6Mjc1LFwieVwiOjczLFwid2lkdGhcIjoyNyxcImhlaWdodFwiOjMyLFwieG9mZnNldFwiOi0yLFwieW9mZnNldFwiOjYsXCJ4YWR2YW5jZVwiOjIwLFwicGFnZVwiOjAsXCJjaG5sXCI6MH0se1wiaWRcIjo3NCxcInhcIjozMDIsXCJ5XCI6NzMsXCJ3aWR0aFwiOjE4LFwiaGVpZ2h0XCI6MzIsXCJ4b2Zmc2V0XCI6LTQsXCJ5b2Zmc2V0XCI6NixcInhhZHZhbmNlXCI6MTEsXCJwYWdlXCI6MCxcImNobmxcIjowfSx7XCJpZFwiOjczLFwieFwiOjMyMCxcInlcIjo3MyxcIndpZHRoXCI6MTQsXCJoZWlnaHRcIjozMixcInhvZmZzZXRcIjotMixcInlvZmZzZXRcIjo2LFwieGFkdmFuY2VcIjo5LFwicGFnZVwiOjAsXCJjaG5sXCI6MH0se1wiaWRcIjo3MixcInhcIjozMzQsXCJ5XCI6NzMsXCJ3aWR0aFwiOjI3LFwiaGVpZ2h0XCI6MzIsXCJ4b2Zmc2V0XCI6LTIsXCJ5b2Zmc2V0XCI6NixcInhhZHZhbmNlXCI6MjIsXCJwYWdlXCI6MCxcImNobmxcIjowfSx7XCJpZFwiOjcxLFwieFwiOjM2MSxcInlcIjo3MyxcIndpZHRoXCI6MjcsXCJoZWlnaHRcIjozMixcInhvZmZzZXRcIjotMyxcInlvZmZzZXRcIjo2LFwieGFkdmFuY2VcIjoyMCxcInBhZ2VcIjowLFwiY2hubFwiOjB9LHtcImlkXCI6NzAsXCJ4XCI6Mzg4LFwieVwiOjczLFwid2lkdGhcIjoyNCxcImhlaWdodFwiOjMyLFwieG9mZnNldFwiOi0yLFwieW9mZnNldFwiOjYsXCJ4YWR2YW5jZVwiOjE3LFwicGFnZVwiOjAsXCJjaG5sXCI6MH0se1wiaWRcIjo2OSxcInhcIjo0MTIsXCJ5XCI6NzMsXCJ3aWR0aFwiOjI0LFwiaGVpZ2h0XCI6MzIsXCJ4b2Zmc2V0XCI6LTIsXCJ5b2Zmc2V0XCI6NixcInhhZHZhbmNlXCI6MTgsXCJwYWdlXCI6MCxcImNobmxcIjowfSx7XCJpZFwiOjY4LFwieFwiOjQzNixcInlcIjo3MyxcIndpZHRoXCI6MjcsXCJoZWlnaHRcIjozMixcInhvZmZzZXRcIjotMixcInlvZmZzZXRcIjo2LFwieGFkdmFuY2VcIjoyMSxcInBhZ2VcIjowLFwiY2hubFwiOjB9LHtcImlkXCI6NjcsXCJ4XCI6NDYzLFwieVwiOjczLFwid2lkdGhcIjoyNixcImhlaWdodFwiOjMyLFwieG9mZnNldFwiOi0zLFwieW9mZnNldFwiOjYsXCJ4YWR2YW5jZVwiOjE5LFwicGFnZVwiOjAsXCJjaG5sXCI6MH0se1wiaWRcIjo2NixcInhcIjowLFwieVwiOjEwNSxcIndpZHRoXCI6MjYsXCJoZWlnaHRcIjozMixcInhvZmZzZXRcIjotMixcInlvZmZzZXRcIjo2LFwieGFkdmFuY2VcIjoyMCxcInBhZ2VcIjowLFwiY2hubFwiOjB9LHtcImlkXCI6NjUsXCJ4XCI6MjYsXCJ5XCI6MTA1LFwid2lkdGhcIjozMCxcImhlaWdodFwiOjMyLFwieG9mZnNldFwiOi00LFwieW9mZnNldFwiOjYsXCJ4YWR2YW5jZVwiOjIwLFwicGFnZVwiOjAsXCJjaG5sXCI6MH0se1wiaWRcIjo2NCxcInhcIjo1NixcInlcIjoxMDUsXCJ3aWR0aFwiOjI5LFwiaGVpZ2h0XCI6MzEsXCJ4b2Zmc2V0XCI6LTIsXCJ5b2Zmc2V0XCI6OSxcInhhZHZhbmNlXCI6MjQsXCJwYWdlXCI6MCxcImNobmxcIjowfSx7XCJpZFwiOjExNixcInhcIjo4NSxcInlcIjoxMDUsXCJ3aWR0aFwiOjIyLFwiaGVpZ2h0XCI6MzAsXCJ4b2Zmc2V0XCI6LTQsXCJ5b2Zmc2V0XCI6OCxcInhhZHZhbmNlXCI6MTMsXCJwYWdlXCI6MCxcImNobmxcIjowfSx7XCJpZFwiOjU5LFwieFwiOjEwNyxcInlcIjoxMDUsXCJ3aWR0aFwiOjE0LFwiaGVpZ2h0XCI6MjksXCJ4b2Zmc2V0XCI6LTIsXCJ5b2Zmc2V0XCI6MTQsXCJ4YWR2YW5jZVwiOjgsXCJwYWdlXCI6MCxcImNobmxcIjowfSx7XCJpZFwiOjEyMixcInhcIjoxMjEsXCJ5XCI6MTA1LFwid2lkdGhcIjoyNCxcImhlaWdodFwiOjI2LFwieG9mZnNldFwiOi0zLFwieW9mZnNldFwiOjEyLFwieGFkdmFuY2VcIjoxNyxcInBhZ2VcIjowLFwiY2hubFwiOjB9LHtcImlkXCI6MTIwLFwieFwiOjE0NSxcInlcIjoxMDUsXCJ3aWR0aFwiOjI2LFwiaGVpZ2h0XCI6MjYsXCJ4b2Zmc2V0XCI6LTQsXCJ5b2Zmc2V0XCI6MTIsXCJ4YWR2YW5jZVwiOjE3LFwicGFnZVwiOjAsXCJjaG5sXCI6MH0se1wiaWRcIjoxMTksXCJ4XCI6MTcxLFwieVwiOjEwNSxcIndpZHRoXCI6MzYsXCJoZWlnaHRcIjoyNixcInhvZmZzZXRcIjotNCxcInlvZmZzZXRcIjoxMixcInhhZHZhbmNlXCI6MjcsXCJwYWdlXCI6MCxcImNobmxcIjowfSx7XCJpZFwiOjExOCxcInhcIjoyMDcsXCJ5XCI6MTA1LFwid2lkdGhcIjoyNyxcImhlaWdodFwiOjI2LFwieG9mZnNldFwiOi00LFwieW9mZnNldFwiOjEyLFwieGFkdmFuY2VcIjoxNyxcInBhZ2VcIjowLFwiY2hubFwiOjB9LHtcImlkXCI6MTE3LFwieFwiOjIzNCxcInlcIjoxMDUsXCJ3aWR0aFwiOjI0LFwiaGVpZ2h0XCI6MjYsXCJ4b2Zmc2V0XCI6LTIsXCJ5b2Zmc2V0XCI6MTIsXCJ4YWR2YW5jZVwiOjE5LFwicGFnZVwiOjAsXCJjaG5sXCI6MH0se1wiaWRcIjoxMTUsXCJ4XCI6MjU4LFwieVwiOjEwNSxcIndpZHRoXCI6MjQsXCJoZWlnaHRcIjoyNixcInhvZmZzZXRcIjotMyxcInlvZmZzZXRcIjoxMixcInhhZHZhbmNlXCI6MTcsXCJwYWdlXCI6MCxcImNobmxcIjowfSx7XCJpZFwiOjExNCxcInhcIjoyODIsXCJ5XCI6MTA1LFwid2lkdGhcIjoyMCxcImhlaWdodFwiOjI2LFwieG9mZnNldFwiOi0yLFwieW9mZnNldFwiOjEyLFwieGFkdmFuY2VcIjoxMyxcInBhZ2VcIjowLFwiY2hubFwiOjB9LHtcImlkXCI6MTExLFwieFwiOjMwMixcInlcIjoxMDUsXCJ3aWR0aFwiOjI1LFwiaGVpZ2h0XCI6MjYsXCJ4b2Zmc2V0XCI6LTMsXCJ5b2Zmc2V0XCI6MTIsXCJ4YWR2YW5jZVwiOjE4LFwicGFnZVwiOjAsXCJjaG5sXCI6MH0se1wiaWRcIjoxMTAsXCJ4XCI6MzI3LFwieVwiOjEwNSxcIndpZHRoXCI6MjQsXCJoZWlnaHRcIjoyNixcInhvZmZzZXRcIjotMixcInlvZmZzZXRcIjoxMixcInhhZHZhbmNlXCI6MTksXCJwYWdlXCI6MCxcImNobmxcIjowfSx7XCJpZFwiOjEwOSxcInhcIjozNTEsXCJ5XCI6MTA1LFwid2lkdGhcIjozMyxcImhlaWdodFwiOjI2LFwieG9mZnNldFwiOi0yLFwieW9mZnNldFwiOjEyLFwieGFkdmFuY2VcIjoyOCxcInBhZ2VcIjowLFwiY2hubFwiOjB9LHtcImlkXCI6MTAxLFwieFwiOjM4NCxcInlcIjoxMDUsXCJ3aWR0aFwiOjI1LFwiaGVpZ2h0XCI6MjYsXCJ4b2Zmc2V0XCI6LTMsXCJ5b2Zmc2V0XCI6MTIsXCJ4YWR2YW5jZVwiOjE4LFwicGFnZVwiOjAsXCJjaG5sXCI6MH0se1wiaWRcIjo5OSxcInhcIjo0MDksXCJ5XCI6MTA1LFwid2lkdGhcIjoyMyxcImhlaWdodFwiOjI2LFwieG9mZnNldFwiOi0zLFwieW9mZnNldFwiOjEyLFwieGFkdmFuY2VcIjoxNixcInBhZ2VcIjowLFwiY2hubFwiOjB9LHtcImlkXCI6OTcsXCJ4XCI6NDMyLFwieVwiOjEwNSxcIndpZHRoXCI6MjQsXCJoZWlnaHRcIjoyNixcInhvZmZzZXRcIjotMyxcInlvZmZzZXRcIjoxMixcInhhZHZhbmNlXCI6MTgsXCJwYWdlXCI6MCxcImNobmxcIjowfSx7XCJpZFwiOjQzLFwieFwiOjQ1NixcInlcIjoxMDUsXCJ3aWR0aFwiOjI0LFwiaGVpZ2h0XCI6MjQsXCJ4b2Zmc2V0XCI6LTMsXCJ5b2Zmc2V0XCI6MTEsXCJ4YWR2YW5jZVwiOjE3LFwicGFnZVwiOjAsXCJjaG5sXCI6MH0se1wiaWRcIjo2MixcInhcIjo0ODAsXCJ5XCI6MTA1LFwid2lkdGhcIjoyMyxcImhlaWdodFwiOjI0LFwieG9mZnNldFwiOi0yLFwieW9mZnNldFwiOjEyLFwieGFkdmFuY2VcIjoxNyxcInBhZ2VcIjowLFwiY2hubFwiOjB9LHtcImlkXCI6NjAsXCJ4XCI6MCxcInlcIjoxMzcsXCJ3aWR0aFwiOjIzLFwiaGVpZ2h0XCI6MjQsXCJ4b2Zmc2V0XCI6LTMsXCJ5b2Zmc2V0XCI6MTIsXCJ4YWR2YW5jZVwiOjE3LFwicGFnZVwiOjAsXCJjaG5sXCI6MH0se1wiaWRcIjo1OCxcInhcIjoyMyxcInlcIjoxMzcsXCJ3aWR0aFwiOjE0LFwiaGVpZ2h0XCI6MjQsXCJ4b2Zmc2V0XCI6LTMsXCJ5b2Zmc2V0XCI6MTQsXCJ4YWR2YW5jZVwiOjgsXCJwYWdlXCI6MCxcImNobmxcIjowfSx7XCJpZFwiOjQyLFwieFwiOjM3LFwieVwiOjEzNyxcIndpZHRoXCI6MjEsXCJoZWlnaHRcIjoyMSxcInhvZmZzZXRcIjotMyxcInlvZmZzZXRcIjo2LFwieGFkdmFuY2VcIjoxNCxcInBhZ2VcIjowLFwiY2hubFwiOjB9LHtcImlkXCI6NjEsXCJ4XCI6NTgsXCJ5XCI6MTM3LFwid2lkdGhcIjoyNCxcImhlaWdodFwiOjIwLFwieG9mZnNldFwiOi0yLFwieW9mZnNldFwiOjEzLFwieGFkdmFuY2VcIjoxOSxcInBhZ2VcIjowLFwiY2hubFwiOjB9LHtcImlkXCI6OTQsXCJ4XCI6ODIsXCJ5XCI6MTM3LFwid2lkdGhcIjoyMyxcImhlaWdodFwiOjE5LFwieG9mZnNldFwiOi00LFwieW9mZnNldFwiOjgsXCJ4YWR2YW5jZVwiOjE0LFwicGFnZVwiOjAsXCJjaG5sXCI6MH0se1wiaWRcIjo0NCxcInhcIjoxMDUsXCJ5XCI6MTM3LFwid2lkdGhcIjoxNCxcImhlaWdodFwiOjE5LFwieG9mZnNldFwiOi0zLFwieW9mZnNldFwiOjI0LFwieGFkdmFuY2VcIjo4LFwicGFnZVwiOjAsXCJjaG5sXCI6MH0se1wiaWRcIjozOSxcInhcIjoxMTksXCJ5XCI6MTM3LFwid2lkdGhcIjoxMyxcImhlaWdodFwiOjE3LFwieG9mZnNldFwiOi0zLFwieW9mZnNldFwiOjYsXCJ4YWR2YW5jZVwiOjcsXCJwYWdlXCI6MCxcImNobmxcIjowfSx7XCJpZFwiOjk2LFwieFwiOjEzMixcInlcIjoxMzcsXCJ3aWR0aFwiOjE4LFwiaGVpZ2h0XCI6MTcsXCJ4b2Zmc2V0XCI6LTQsXCJ5b2Zmc2V0XCI6NSxcInhhZHZhbmNlXCI6MTEsXCJwYWdlXCI6MCxcImNobmxcIjowfSx7XCJpZFwiOjM0LFwieFwiOjE1MCxcInlcIjoxMzcsXCJ3aWR0aFwiOjE4LFwiaGVpZ2h0XCI6MTcsXCJ4b2Zmc2V0XCI6LTMsXCJ5b2Zmc2V0XCI6NixcInhhZHZhbmNlXCI6MTIsXCJwYWdlXCI6MCxcImNobmxcIjowfSx7XCJpZFwiOjEyNixcInhcIjoxNjgsXCJ5XCI6MTM3LFwid2lkdGhcIjoyMixcImhlaWdodFwiOjE0LFwieG9mZnNldFwiOi0yLFwieW9mZnNldFwiOjE3LFwieGFkdmFuY2VcIjoxNyxcInBhZ2VcIjowLFwiY2hubFwiOjB9LHtcImlkXCI6NDYsXCJ4XCI6MTkwLFwieVwiOjEzNyxcIndpZHRoXCI6MTQsXCJoZWlnaHRcIjoxNCxcInhvZmZzZXRcIjotMyxcInlvZmZzZXRcIjoyNCxcInhhZHZhbmNlXCI6OCxcInBhZ2VcIjowLFwiY2hubFwiOjB9LHtcImlkXCI6OTUsXCJ4XCI6MjA0LFwieVwiOjEzNyxcIndpZHRoXCI6MjQsXCJoZWlnaHRcIjoxMyxcInhvZmZzZXRcIjotMixcInlvZmZzZXRcIjoyOCxcInhhZHZhbmNlXCI6MTgsXCJwYWdlXCI6MCxcImNobmxcIjowfSx7XCJpZFwiOjQ1LFwieFwiOjIyOCxcInlcIjoxMzcsXCJ3aWR0aFwiOjE5LFwiaGVpZ2h0XCI6MTMsXCJ4b2Zmc2V0XCI6LTIsXCJ5b2Zmc2V0XCI6MTgsXCJ4YWR2YW5jZVwiOjE0LFwicGFnZVwiOjAsXCJjaG5sXCI6MH1dLFwia2VybmluZ3NcIjpbXSxcImluZm9cIjp7XCJmYWNlXCI6XCJFeG8gMiBTZW1pIEJvbGRcIixcInNpemVcIjozMixcImJvbGRcIjowLFwiaXRhbGljXCI6MCxcImNoYXJzZXRcIjpcIlwiLFwidW5pY29kZVwiOjAsXCJzdHJldGNoSFwiOjEwMCxcInNtb290aFwiOjEsXCJhYVwiOjEsXCJwYWRkaW5nXCI6WzQsNCw0LDRdLFwic3BhY2luZ1wiOlstOCwtOF19LFwiY29tbW9uXCI6e1wibGluZUhlaWdodFwiOjQwLFwiYmFzZVwiOjMzLFwic2NhbGVXXCI6NTEyLFwic2NhbGVIXCI6NTEyLFwicGFnZXNcIjoxLFwicGFja2VkXCI6MH19IiwiKGZ1bmN0aW9uIChnbG9iYWwpe1xudmFyIFRIUkVFID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cuVEhSRUUgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsLlRIUkVFIDogbnVsbClcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBtaXhlcyA9IHJlcXVpcmUoJ21peGVzJylcbnZhciBCYXNlID0gVEhSRUUuU2NlbmVcblxudmFyIFlPRkYgPSAyLjVcblxuZnVuY3Rpb24gUmlnU2NlbmUob3B0KSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJpZ1NjZW5lKSlcbiAgICAgICAgcmV0dXJuIG5ldyBSaWdTY2VuZShvcHQpXG4gICAgQmFzZS5jYWxsKHRoaXMpXG4gICAgdGhpcy5mb2cgPSBuZXcgVEhSRUUuRm9nRXhwMiggMHgwYjA1MTYsIDAuMDAwMTUgKTtcblxuXG4gICAgLy8gdmFyIGJveCA9IG5ldyBUSFJFRS5NZXNoKFxuICAgIC8vICAgICBuZXcgVEhSRUUuQm94R2VvbWV0cnkoMjAsIDIwLCAxMCksXG4gICAgLy8gICAgIG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCh7IGNvbG9yOiAweGFhYWFhYSwgd2lyZWZyYW1lOiBmYWxzZSB9KVxuICAgIC8vIClcblxuICAgIC8vIHRoaXMuYWRkKGJveClcblxuXG4gICAgdGhpcy50aW1lID0gMFxuICAgIHRoaXMuY3ViZU1hcCA9IG51bGxcbiAgICB0aGlzLnVwZGF0ZU1hdGVyaWFsKClcblxuICAgIHZhciBsb2FkZXIgPSBuZXcgVEhSRUUuT0JKTVRMTG9hZGVyKClcbiAgICBsb2FkZXIubG9hZCgnbW9kZWwvUHJpcmF6bG9tbmF5YS5vYmonLCAnbW9kZWwvUHJpcmF6bG9tbmF5YS5tdGwnLCBmdW5jdGlvbihvYmplY3QsIG1hdGVyaWFscykge1xuICAgICAgICB2YXIgcyA9IDAuM1xuICAgICAgICBjb25zb2xlLmxvZyhvYmplY3QsIG1hdGVyaWFscylcbiAgICAgICAgb2JqZWN0LnNjYWxlLnNldChzLHMscylcbiAgICAgICAgb2JqZWN0LnBvc2l0aW9uLnkgLT0gWU9GRlxuICAgICAgICB0aGlzLm1lc2ggPSBvYmplY3RcblxuICAgICAgICB0aGlzLm1lc2gudHJhdmVyc2UoZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgICBpZiAob2JqIGluc3RhbmNlb2YgVEhSRUUuTWVzaCkge1xuICAgICAgICAgICAgICAgIG9iai5jYXN0U2hhZG93ID0gdHJ1ZVxuICAgICAgICAgICAgICAgIG9iai5yZWNlaXZlU2hhZG93ID0gdHJ1ZVxuICAgICAgICAgICAgICAgIG9iai5tYXRlcmlhbC5zaGluaW5lc3MgPSAxXG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2cob2JqLm1hdGVyaWFsLnVuaWZvcm1zKVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuXG4gICAgICAgIHRoaXMuYWRkKG9iamVjdClcbiAgICB9LmJpbmQodGhpcykpXG4gICAgXG5cbiAgICAvLyB2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuVG9ydXNLbm90R2VvbWV0cnkoIDEwLCAzLCAxMDAsIDE2ICk7XG4gICAgLy8gdmFyIG1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKCB7IGNvbG9yOiAweGZmZmYwMCB9ICk7XG4gICAgLy8gdmFyIHRvcnVzS25vdCA9IG5ldyBUSFJFRS5NZXNoKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcbiAgICAvLyB0aGlzLmFkZCggdG9ydXNLbm90ICk7XG4gICAgLy8gdG9ydXNLbm90LmNhc3RTaGFkb3cgPSB0cnVlXG4gICAgLy8gdG9ydXNLbm90LnJlY2VpdmVTaGFkb3cgPSB0cnVlXG5cbiAgICB0aGlzLmxpZ2h0cyA9IFtcbiAgICAgICAgWyBuZXcgVEhSRUUuVmVjdG9yMygtMTAsIDIwLCAtMjApLCAxIF0sXG4gICAgICAgIFsgbmV3IFRIUkVFLlZlY3RvcjMoMTUsIDEwLCAxNSksIDAuNSBdXG4gICAgXS5tYXAoZnVuY3Rpb24oYXJncywgaSkge1xuICAgICAgICB2YXIgbGlnaHQgPSBuZXcgVEhSRUUuRGlyZWN0aW9uYWxMaWdodCggMHhkZGY0ZmQsIGFyZ3NbMV0gKVxuICAgICAgICBsaWdodC5wb3NpdGlvbi5jb3B5KGFyZ3NbMF0pXG4gICAgICAgIGxpZ2h0LmNhc3RTaGFkb3cgPSB0cnVlXG4gICAgICAgIGxpZ2h0LnNoYWRvd01hcFdpZHRoID0gMTAyNFxuICAgICAgICBsaWdodC5zaGFkb3dNYXBIZWlnaHQgPSAxMDI0XG4gICAgICAgIGxpZ2h0LnNoYWRvd0NhbWVyYU5lYXIgPSAxXG4gICAgICAgIGxpZ2h0LnNoYWRvd0NhbWVyYUZhciA9IDEwMFxuXG4gICAgICAgIC8vIGxpZ2h0LmhlbHBlciA9IG5ldyBUSFJFRS5EaXJlY3Rpb25hbExpZ2h0SGVscGVyKGxpZ2h0LCA0KVxuICAgICAgICAvLyB0aGlzLmFkZChsaWdodC5oZWxwZXIpXG4gICAgICAgIHRoaXMuYWRkKGxpZ2h0KVxuICAgICAgICByZXR1cm4gbGlnaHRcbiAgICB9LHRoaXMpXG59XG5cbmluaGVyaXRzKFJpZ1NjZW5lLCBCYXNlKVxuXG5taXhlcyhSaWdTY2VuZSwge1xuXG4gICAgdXBkYXRlTWF0ZXJpYWw6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLm1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hMYW1iZXJ0TWF0ZXJpYWwoe1xuICAgICAgICAgICAgY29sb3I6IDB4YWFhYWFhLFxuICAgICAgICAgICAgcmVmbGVjdGl2aXR5OiAwLjQsXG4gICAgICAgICAgICBlbnZNYXA6IHRoaXMuY3ViZU1hcFxuICAgICAgICB9KVxuXG4gICAgfSxcblxuICAgIHVwZGF0ZTogZnVuY3Rpb24oZHQpIHtcbiAgICAgICAgdGhpcy50aW1lICs9IE1hdGgubWluKGR0LCAzMCkvMTAwMFxuICAgICAgICB2YXIgbSA9IHRoaXMubWVzaFxuICAgICAgICBpZiAoIW0pXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgdmFyIGFuaW0gPSBNYXRoLnNpbih0aGlzLnRpbWUpXG5cbiAgICAgICAgLy8gdGhpcy5saWdodHMuZm9yRWFjaChmdW5jdGlvbihsaWdodCkgeyBsaWdodC5oZWxwZXIudXBkYXRlKCkgfSlcbiAgICAgICAgLy8gbS5wb3NpdGlvbi55ID0gWU9GRiArIGFuaW0qMC4yXG4gICAgICAgIC8vIG0ucG9zaXRpb24ueCA9IE1hdGguc2luKHRoaXMudGltZSowLjEpKjAuMDVcbiAgICAgICAgLy8gbS5wb3NpdGlvbi56ID0gTWF0aC5zaW4odGhpcy50aW1lKjAuMikqMC4xXG4gICAgICAgIC8vIG0ucm90YXRpb24ueCA9IGFuaW0qMC4wM1xuICAgICAgICAvLyBtLnJvdGF0aW9uLnkgPSBNYXRoLnNpbih0aGlzLnRpbWUqTWF0aC5jb3ModGhpcy50aW1lKjAuMSkpKjAuMDA1XG4gICAgfVxufSlcblxubW9kdWxlLmV4cG9ydHMgPSBSaWdTY2VuZVxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pIiwiKGZ1bmN0aW9uIChnbG9iYWwpe1xudmFyIFRIUkVFID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cuVEhSRUUgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsLlRIUkVFIDogbnVsbCk7XG52YXIgRWZmZWN0Q29tcG9zZXIgPSByZXF1aXJlKFwidGhyZWUtZWZmZWN0Y29tcG9zZXJcIikoVEhSRUUpO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZShcImluaGVyaXRzXCIpO1xudmFyIEJhc2UgPSBFZmZlY3RDb21wb3Nlci5SZW5kZXJQYXNzO1xudmFyIHBsdWNrZXIgPSByZXF1aXJlKFwicGx1Y2tlclwiKTtcbnZhciBudW1iZXIgPSByZXF1aXJlKFwiYXMtbnVtYmVyXCIpO1xudmFyIFRleHRFbGVtZW50ID0gcmVxdWlyZShcInRocmVlLXNkZi10ZXh0XCIpKFRIUkVFKTtcbnZhciB4dGVuZCA9IHJlcXVpcmUoXCJ4dGVuZFwiKTtcbnZhciBVTklUX1NDQUxFID0gMC4xO1xudmFyIFNDQUxFID0gW1VOSVRfU0NBTEUsIFVOSVRfU0NBTEUsIFVOSVRfU0NBTEVdO1xuXG52YXIgbWF0NCA9IHtcbiAgICBzY2FsZTogcmVxdWlyZShcImdsLW1hdDQvc2NhbGVcIiksXG4gICAgaWRlbnRpdHk6IHJlcXVpcmUoXCJnbC1tYXQ0L2lkZW50aXR5XCIpLFxuICAgIG11bHRpcGx5OiByZXF1aXJlKFwiZ2wtbWF0NC9tdWx0aXBseVwiKSxcbiAgICB0cmFuc2xhdGU6IHJlcXVpcmUoXCJnbC1tYXQ0L3RyYW5zbGF0ZVwiKVxufTtcblxudmFyIHNldFZlYzMgPSByZXF1aXJlKFwiZ2wtdmVjMy9zZXRcIik7XG52YXIgdG1wVmVjMyA9IFswLCAwLCAwXTtcbnZhciBwbHVja1BhbmVscyA9IHBsdWNrZXIoXCJwYW5lbHNcIik7XG52YXIgZ2xzbGlmeSA9IHJlcXVpcmUoXCJnbHNsaWZ5XCIpO1xudmFyIGNyZWF0ZVNERlNoYWRlciA9IHJlcXVpcmUoXCJnbHNsaWZ5L2FkYXB0ZXIuanNcIikoXCJcXG4jZGVmaW5lIEdMU0xJRlkgMVxcblxcbmF0dHJpYnV0ZSB2ZWM0IHBvc2l0aW9uO1xcbmF0dHJpYnV0ZSB2ZWM0IGNvbG9yO1xcbmF0dHJpYnV0ZSB2ZWMyIHRleGNvb3JkMDtcXG51bmlmb3JtIG1hdDQgcHJvamVjdGlvbjtcXG51bmlmb3JtIG1hdDQgdmlldztcXG51bmlmb3JtIG1hdDQgbW9kZWw7XFxudmFyeWluZyB2ZWM0IHZfY29sO1xcbnZhcnlpbmcgdmVjMiB2X3RleDA7XFxudmFyeWluZyBmbG9hdCBhbmltT2Zmc2V0O1xcbnZvaWQgbWFpbigpIHtcXG4gIGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbiAqIHZpZXcgKiBtb2RlbCAqIHBvc2l0aW9uO1xcbiAgdl9jb2wgPSBjb2xvcjtcXG4gIHZfdGV4MCA9IHRleGNvb3JkMDtcXG4gIGdsX1BvaW50U2l6ZSA9IDEuMDtcXG4gIGFuaW1PZmZzZXQgPSBwb3NpdGlvbi54IC8gMTAwLjA7XFxufVwiLCBcIlxcbiNkZWZpbmUgR0xTTElGWSAxXFxuXFxuI2lmZGVmIEdMX0VTXFxuXFxucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuI2VuZGlmXFxuXFxudmFyeWluZyB2ZWM0IHZfY29sO1xcbnZhcnlpbmcgdmVjMiB2X3RleDA7XFxudmFyeWluZyBmbG9hdCBhbmltT2Zmc2V0O1xcbnVuaWZvcm0gc2FtcGxlcjJEIHRleHR1cmUwO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHRleHR1cmUxO1xcbnVuaWZvcm0gZmxvYXQgc21vb3RoaW5nO1xcbnVuaWZvcm0gZmxvYXQgZmFkZTtcXG5jb25zdCB2ZWMyIHNoYWRvd09mZnNldCA9IHZlYzIoLTEuMCAvIDUxMi4wKTtcXG5jb25zdCB2ZWM0IGdsb3dDb2xvciA9IHZlYzQodmVjMygwLjEpLCAxLjApO1xcbmNvbnN0IGZsb2F0IGdsb3dNaW4gPSAwLjQ7XFxuY29uc3QgZmxvYXQgZ2xvd01heCA9IDAuODtcXG52b2lkIG1haW4oKSB7XFxuICBmbG9hdCBhbmltID0gZmFkZSAqIGFuaW1PZmZzZXQ7XFxuICBhbmltID0gY2xhbXAobWl4KGFuaW0sIDEuMCwgZmFkZSAqIGZhZGUpLCAwLjAsIDEuMCk7XFxuICB2ZWM0IHNtb290aENvbG9yID0gdmVjNCgwLjApO1xcbiAgdmVjNCB0ZXhDb2xvciA9IHRleHR1cmUyRCh0ZXh0dXJlMCwgdl90ZXgwKTtcXG4gIGZsb2F0IGRzdCA9IHRleENvbG9yLmE7XFxuICBmbG9hdCBzbW9vdGhBbXQgPSBtaXgoMS41LCBzbW9vdGhpbmcsIGFuaW0pO1xcbiAgZmxvYXQgYWxwaGEgPSBzbW9vdGhzdGVwKDAuNSAtIHNtb290aEFtdCwgMC41ICsgc21vb3RoQW10LCBkc3QpO1xcbiAgdmVjNCBiYXNlID0gdl9jb2wgKiB2ZWM0KGFscGhhKTtcXG4gIGZsb2F0IGdsb3dEc3QgPSB0ZXh0dXJlMkQodGV4dHVyZTAsIHZfdGV4MCArIHNoYWRvd09mZnNldCkuYTtcXG4gIHZlYzQgZ2xvdyA9IGdsb3dDb2xvciAqIHNtb290aHN0ZXAoZ2xvd01pbiwgZ2xvd01heCwgZ2xvd0RzdCk7XFxuICBmbG9hdCBtYXNrID0gMS4wIC0gYWxwaGE7XFxuICBnbF9GcmFnQ29sb3IgPSBtaXgodmVjNCgwLjApLCBiYXNlLCBhbmltKTtcXG4gIGlmKGdsX0ZyYWdDb2xvci5hIDwgMC4xKVxcbiAgICBkaXNjYXJkO1xcbiAgXFxufVwiLCBbe1wibmFtZVwiOlwicHJvamVjdGlvblwiLFwidHlwZVwiOlwibWF0NFwifSx7XCJuYW1lXCI6XCJ2aWV3XCIsXCJ0eXBlXCI6XCJtYXQ0XCJ9LHtcIm5hbWVcIjpcIm1vZGVsXCIsXCJ0eXBlXCI6XCJtYXQ0XCJ9LHtcIm5hbWVcIjpcInRleHR1cmUwXCIsXCJ0eXBlXCI6XCJzYW1wbGVyMkRcIn0se1wibmFtZVwiOlwidGV4dHVyZTFcIixcInR5cGVcIjpcInNhbXBsZXIyRFwifSx7XCJuYW1lXCI6XCJzbW9vdGhpbmdcIixcInR5cGVcIjpcImZsb2F0XCJ9LHtcIm5hbWVcIjpcImZhZGVcIixcInR5cGVcIjpcImZsb2F0XCJ9XSwgW3tcIm5hbWVcIjpcInBvc2l0aW9uXCIsXCJ0eXBlXCI6XCJ2ZWM0XCJ9LHtcIm5hbWVcIjpcImNvbG9yXCIsXCJ0eXBlXCI6XCJ2ZWM0XCJ9LHtcIm5hbWVcIjpcInRleGNvb3JkMFwiLFwidHlwZVwiOlwidmVjMlwifV0pO1xudmFyIHNkZlNoYWRlcjtcblxuZnVuY3Rpb24gVGV4dFBhc3Mob3B0KSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFRleHRQYXNzKSlcbiAgICAgICAgcmV0dXJuIG5ldyBUZXh0UGFzcyhvcHQpO1xuXG4gICAgb3B0ID0gb3B0IHx8IHt9O1xuICAgIHZhciByZW5kZXJlciA9IG9wdC5yZW5kZXJlcjtcbiAgICB2YXIgY2FtZXJhID0gb3B0LmNhbWVyYTtcbiAgICB2YXIgc2NlbmUgPSBvcHQuc2NlbmU7XG4gICAgQmFzZS5jYWxsKHRoaXMsIHNjZW5lLCBjYW1lcmEpO1xuICAgIHZhciBmb250ID0gb3B0LmZvbnQ7XG5cbiAgICBpZiAoIXNkZlNoYWRlcilcbiAgICAgICAgc2RmU2hhZGVyID0gY3JlYXRlU0RGU2hhZGVyKHJlbmRlcmVyLmdldENvbnRleHQoKSk7XG5cbiAgICB0aGlzLmdyb3VwcyA9IChvcHQuZ3JvdXBzIHx8IFtdKS5tYXAoY3JlYXRlR3JvdXBzKHJlbmRlcmVyLCBmb250KSk7XG4gICAgd2luZG93Lmdyb3VwcyA9IHRoaXMuZ3JvdXBzO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVHcm91cHMocmVuZGVyZXIsIGZvbnQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oZ3JvdXAsIGdyb3VwSW5kZXgpIHtcbiAgICAgICAgZ3JvdXAuZWxlbWVudHMgPSBncm91cC5wYW5lbHMubWFwKGZ1bmN0aW9uKHBhbmVsLCBpbmRleCkge1xuICAgICAgICAgICAgdmFyIHNpZGUgPSAoaW5kZXggPT09IDAgPyAxIDogLTEpO1xuXG4gICAgICAgICAgICByZXR1cm4gcGFuZWwubGFiZWxzLm1hcChmdW5jdGlvbihsYWJlbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KGxhYmVsLCBzaWRlLCByZW5kZXJlciwgZm9udCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSkucmVkdWNlKGZ1bmN0aW9uKHByZXYsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBwcmV2LmNvbmNhdChiKTtcbiAgICAgICAgfSwgW10pO1xuXG4gICAgICAgIGdyb3VwLl9vcGFjaXR5ID0gMTtcbiAgICAgICAgZ3JvdXAuZmFkZSA9IDE7XG4gICAgICAgIGdyb3VwLnNob3dpbmcgPSB0cnVlO1xuICAgICAgICBncm91cC5hbmltYXRpbmdPdXQgPSBmYWxzZTtcblxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZ3JvdXAsIFwib3BhY2l0eVwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBncm91cC5fb3BhY2l0eTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICAgICAgZ3JvdXAuX29wYWNpdHkgPSB2YWw7XG5cbiAgICAgICAgICAgICAgICBncm91cC5lbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZS50ZXh0Lm9wYWNpdHkgPSB2YWw7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBncm91cC5wYW5lbHMuZm9yRWFjaChmdW5jdGlvbihwKSB7XG4gICAgICAgICAgICAgICAgICAgIHAuY29udGFpbmVyLnZpc2libGUgPSB2YWwgPiAwLjAxO1xuXG4gICAgICAgICAgICAgICAgICAgIHAuc2hhcGVzLmZvckVhY2goZnVuY3Rpb24oc2hhcGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNoYXBlLm1hdGVyaWFsLm9wYWNpdHkgPSB2YWw7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaGFwZS52aXNpYmxlID0gdmFsID4gMC4wMTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBncm91cDtcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50KGxhYmVsLCBzaWRlLCByZW5kZXJlciwgZm9udCkge1xuICAgIHZhciB0ZXh0T3B0ID0geHRlbmQobGFiZWwsIHtcbiAgICAgICAgZm9udDogZm9udCxcbiAgICAgICAgdGV4dHVyZXM6IGZvbnQudGV4dHVyZXMsXG4gICAgICAgIHNoYWRlcjogc2RmU2hhZGVyXG4gICAgfSk7XG5cbiAgICB2YXIgdGV4dEVsID0gVGV4dEVsZW1lbnQocmVuZGVyZXIsIHRleHRPcHQpO1xuXG4gICAgcmV0dXJuIHh0ZW5kKGxhYmVsLCB7XG4gICAgICAgIHRleHQ6IHRleHRFbCxcbiAgICAgICAgc2lkZTogc2lkZVxuICAgIH0pO1xufVxuXG5mdW5jdGlvbiByZW5kZXJFbGVtZW50KGNhbWVyYSwgZSwgZmFkZSkge1xuICAgIGUub2JqZWN0M2QudXBkYXRlTWF0cml4V29ybGQodHJ1ZSk7XG4gICAgdmFyIHRyYW5zZm9ybSA9IGUudGV4dC50cmFuc2Zvcm07XG4gICAgbWF0NC5pZGVudGl0eSh0cmFuc2Zvcm0pO1xuICAgIG1hdDQuc2NhbGUodHJhbnNmb3JtLCB0cmFuc2Zvcm0sIFNDQUxFKTtcbiAgICBzZXRWZWMzKHRtcFZlYzMsIGUudHJhbnNsYXRpb25bMF0sIGUudHJhbnNsYXRpb25bMV0sIGUudHJhbnNsYXRpb25bMl0pO1xuICAgIG1hdDQudHJhbnNsYXRlKHRyYW5zZm9ybSwgdHJhbnNmb3JtLCB0bXBWZWMzKTtcbiAgICBzZXRWZWMzKHRtcFZlYzMsIGUuc2l6ZSwgZS5zaXplLCBlLnNpemUpO1xuICAgIG1hdDQuc2NhbGUodHJhbnNmb3JtLCB0cmFuc2Zvcm0sIHRtcFZlYzMpO1xuICAgIGUudGV4dC5zaGFkZXIuYmluZCgpO1xuICAgIGUudGV4dC5zaGFkZXIudW5pZm9ybXMuZmFkZSA9IGZhZGU7XG4gICAgZS50ZXh0LmRyYXcoY2FtZXJhLCBlLm9iamVjdDNkKTtcbn1cblxuaW5oZXJpdHMoVGV4dFBhc3MsIEJhc2UpO1xuXG5UZXh0UGFzcy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24ocmVuZGVyZXIsIHdyaXRlQnVmZmVyLCByZWFkQnVmZmVyLCBkZWx0YSkge1xuICAgIEJhc2UucHJvdG90eXBlLnJlbmRlci5jYWxsKHRoaXMsIHJlbmRlcmVyLCB3cml0ZUJ1ZmZlciwgcmVhZEJ1ZmZlciwgZGVsdGEpO1xuICAgIHZhciBjYW1lcmEgPSB0aGlzLmNhbWVyYTtcblxuICAgIHRoaXMuZ3JvdXBzLmZvckVhY2goZnVuY3Rpb24oZykge1xuICAgICAgICBnLmVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgaWYgKCFnLnNob3dpbmcpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgICAgICByZW5kZXJFbGVtZW50KGNhbWVyYSwgZSwgZy5mYWRlKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICByZW5kZXJlci5yZXNldEdMU3RhdGUoKTtcbiAgICByZW5kZXJlci5yZXNldEF0dHJpYnV0ZXMoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVGV4dFBhc3M7XG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSkiLCIoZnVuY3Rpb24gKGdsb2JhbCl7XG52YXIgVHdlZW5NYXggPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdy5Ud2Vlbk1heCA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwuVHdlZW5NYXggOiBudWxsKVxudmFyIGNsYW1wID0gcmVxdWlyZSgnY2xhbXAnKVxudmFyIHNtb290aHN0ZXAgPSByZXF1aXJlKCdzbW9vdGhzdGVwJylcblxudmFyIGxhc3RJbmRleCA9IC0xXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oY29udHJvbGxlciwgbGFiZWxzKSB7XG4gICAgdmFyIGNsb3NlSW5kZXggPSBjbG9zZXN0KGNvbnRyb2xsZXIsIGxhYmVscylcblxuICAgIC8vIGNvbnNvbGUubG9nKGNvbnRyb2xsZXIudGhldGEpXG4gICAgbGFiZWxzLmZvckVhY2goZnVuY3Rpb24obGFiZWwsIGkpIHtcbiAgICAgICAgLy8gc2V0U2hvd2luZyhsYWJlbCwgdHJ1ZSlcbiAgICAgICAgdmFyIHZpc2libGUgPSBpPT09Y2xvc2VJbmRleFxuICAgICAgICBpZiAodmlzaWJsZSAmJiAhbGFiZWwuc2hvd2luZykge1xuICAgICAgICAgICAgYW5pbWF0ZUluRmVhdHVyZShsYWJlbClcbiAgICAgICAgfSBlbHNlIGlmICghdmlzaWJsZSAmJiBsYWJlbC5zaG93aW5nKSB7XG4gICAgICAgICAgICBhbmltYXRlT3V0RmVhdHVyZShsYWJlbClcbiAgICAgICAgfVxuICAgIH0pXG59XG5cbm1vZHVsZS5leHBvcnRzLmhpZGVBbGwgPSBmdW5jdGlvbihmZWF0dXJlcykge1xuICAgIGZlYXR1cmVzLmZvckVhY2goZnVuY3Rpb24oZikge1xuICAgICAgICBzZXRTaG93aW5nKGYsIGZhbHNlKVxuICAgIH0pXG59XG5cbmZ1bmN0aW9uIGRpc3RhbmNlKGNvbnRyb2xsZXIsIGxhYmVsKSB7XG4gICAgLy9zaWduZWQgZGlzdGFuY2VcbiAgICB2YXIgeCA9IC1sYWJlbC50aGV0YSwgXG4gICAgICAgIHkgPSBjb250cm9sbGVyLnRoZXRhXG5cbiAgICB2YXIgYWJkaXN0ID0gTWF0aC5hYnMoeCAtIHkpXG4gICAgcmV0dXJuIE1hdGgubWluKCgyICogTWF0aC5QSSkgLSBhYmRpc3QsIGFiZGlzdClcblxufVxuXG5mdW5jdGlvbiBjbG9zZXN0KGNvbnRyb2xsZXIsIGxhYmVscykge1xuICAgIHZhciBtaW5EaXN0ID0gTnVtYmVyLk1BWF9WQUxVRVxuICAgIHZhciByZXQgPSAtMVxuICAgIGxhYmVscy5mb3JFYWNoKGZ1bmN0aW9uKGxhYmVsLCBpbmRleCkge1xuICAgICAgICB2YXIgZGlzdCA9IGRpc3RhbmNlKGNvbnRyb2xsZXIsIGxhYmVsKVxuICAgICAgICBcbiAgICAgICAgaWYgKGRpc3QgPCBtaW5EaXN0KSB7XG4gICAgICAgICAgICBtaW5EaXN0ID0gZGlzdFxuICAgICAgICAgICAgcmV0ID0gaW5kZXhcbiAgICAgICAgfVxuICAgIH0pXG4gICAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBzZXRTaG93aW5nKGZlYXR1cmUsIHNob3dpbmcpIHtcbiAgICBmZWF0dXJlLnNob3dpbmcgPSBzaG93aW5nXG59XG5cbmZ1bmN0aW9uIGFuaW1hdGVJbkZlYXR1cmUoZmVhdHVyZSkge1xuICAgIGZlYXR1cmUuc2hvd2luZyA9IHRydWVcbiAgICBmZWF0dXJlLmZhZGUgPSAwXG4gICAgVHdlZW5NYXgua2lsbFR3ZWVuc09mKGZlYXR1cmUpXG4gICAgVHdlZW5NYXgudG8oZmVhdHVyZSwgMC41LCB7XG4gICAgICAgIGZhZGU6IDEuMCxcbiAgICAgICAgZWFzZTogXCJlYXNlT3V0UXVhZFwiXG4gICAgfSlcbn1cblxuZnVuY3Rpb24gYW5pbWF0ZU91dEZlYXR1cmUoZmVhdHVyZSkge1xuICAgIGlmIChmZWF0dXJlLmFuaW1hdGluZ091dClcbiAgICAgICAgcmV0dXJuXG5cbiAgICBmZWF0dXJlLmFuaW1hdGluZ091dCA9IHRydWVcbiAgICBUd2Vlbk1heC50byhmZWF0dXJlLCAwLjUsIHtcbiAgICAgICAgZmFkZTogMCxcbiAgICAgICAgZWFzZTogJ2Vhc2VPdXRRdWFkJyxcbiAgICAgICAgb25Db21wbGV0ZTogaGlkZUZlYXR1cmUuYmluZChudWxsLCBmZWF0dXJlKVxuICAgIH0pXG59XG5cbmZ1bmN0aW9uIGhpZGVGZWF0dXJlKGZlYXR1cmUpIHtcbiAgICBmZWF0dXJlLmFuaW1hdGluZ091dCA9IGZhbHNlXG4gICAgZmVhdHVyZS5zaG93aW5nID0gZmFsc2Vcbn1cbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KSIsInZhciBGb250ID0gcmVxdWlyZSgnLi4vZm9udHMvRXhvMlNlbWlCb2xkLmpzb24nKVxudmFyIGZvbnRJbWFnZSA9ICdmb250cy9FeG8yU2VtaUJvbGQucG5nJ1xudmFyIGltZyA9IHJlcXVpcmUoJ2ltZycpXG52YXIgY3JlYXRlVGV4dHVyZSA9IHJlcXVpcmUoJ2dsLXRleHR1cmUyZCcpXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZ2wsIGNiKSB7XG4gICAgaW1nKGZvbnRJbWFnZSwgZnVuY3Rpb24oZXJyLCByZXMpIHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgY2IoZXJyKVxuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBGb250LnRleHR1cmVzID0gW3Jlc10ubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgICAgIHZhciB0ID0gY3JlYXRlVGV4dHVyZShnbCwgaSlcblxuICAgICAgICAgICAgdC5taW5GaWx0ZXIgPSBnbC5MSU5FQVJfTUlQTUFQX0xJTkVBUlxuICAgICAgICAgICAgdC5tYWdGaWx0ZXIgPSBnbC5MSU5FQVJcblxuICAgICAgICAgICAgdmFyIGV4dCA9IChnbC5nZXRFeHRlbnNpb24oJ0VYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpYycpIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHx8IGdsLmdldEV4dGVuc2lvbihcIk1PWl9FWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWNcIikpO1xuICAgICAgICAgICAgaWYgKGV4dCkge1xuICAgICAgICAgICAgICAgIHZhciBtYXhBbmlzdHJvcGh5ID0gZ2wuZ2V0UGFyYW1ldGVyKGV4dC5NQVhfVEVYVFVSRV9NQVhfQU5JU09UUk9QWV9FWFQpO1xuICAgICAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmYoZ2wuVEVYVFVSRV8yRCwgZXh0LlRFWFRVUkVfTUFYX0FOSVNPVFJPUFlfRVhULCBNYXRoLm1pbigxNiwgbWF4QW5pc3Ryb3BoeSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0LmdlbmVyYXRlTWlwbWFwKClcbiAgICAgICAgICAgIHJldHVybiB0XG4gICAgICAgIH0pXG4gICAgICAgIFxuICAgICAgICBjYihudWxsLCBGb250KVxuICAgIH0pXG59IiwiKGZ1bmN0aW9uIChnbG9iYWwpe1xudmFyIFRleHRQYXNzID0gcmVxdWlyZSgnLi9UZXh0UGFzcycpXG52YXIgVEhSRUUgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdy5USFJFRSA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwuVEhSRUUgOiBudWxsKVxudmFyIHh0ZW5kID0gcmVxdWlyZSgneHRlbmQnKVxudmFyIGdldFNWRyA9IHJlcXVpcmUoJy4vZ2V0LXN2ZycpXG52YXIgZ2V0UG9seSA9IHJlcXVpcmUoJy4vZ2V0LXBvbHlnb24nKVxudmFyIENvbXBsZXggPSByZXF1aXJlKCd0aHJlZS1zaW1wbGljaWFsLWNvbXBsZXgnKShUSFJFRSlcblxudmFyIFVOSVRfU0NBTEUgPSAwLjFcblxudmFyIGRhdGEgPSByZXF1aXJlKCcuL3RleHQtZGF0YScpXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob3B0KSB7XG4gICAgdmFyIGdyb3VwcyA9IGNyZWF0ZUdyb3VwcygpXG4gICAgXG4gICAgZ3JvdXBzLmZvckVhY2goZnVuY3Rpb24oZ3JvdXApIHtcbiAgICAgICAgLy8gdmFyIGxlbiA9IDEwMFxuICAgICAgICAvLyB2YXIgZGlyID0gbmV3IFRIUkVFLlZlY3RvcjMoTWF0aC5jb3MoZ3JvdXAudGhldGEpLCAwLCBNYXRoLnNpbihncm91cC50aGV0YSkpXG4gICAgICAgIC8vIHZhciBhcnJvdyA9IG5ldyBUSFJFRS5BcnJvd0hlbHBlcihkaXIsIG5ldyBUSFJFRS5WZWN0b3IzKCksIGxlbilcbiAgICAgICAgLy8gb3B0LnNjZW5lLmFkZChhcnJvdylcblxuICAgICAgICBncm91cC5wYW5lbHMuZm9yRWFjaChmdW5jdGlvbihwYW5lbCkge1xuICAgICAgICAgICAgb3B0LnNjZW5lLmFkZChwYW5lbC5jb250YWluZXIpXG4gICAgICAgIH0pXG4gICAgfSlcblxuICAgIHJldHVybiBUZXh0UGFzcyh4dGVuZChvcHQsIHtcbiAgICAgICAgZ3JvdXBzOiBncm91cHNcbiAgICB9KSlcbn1cblxuZnVuY3Rpb24gY3JlYXRlR3JvdXBzKCkge1xuICAgIHJldHVybiBkYXRhLm1hcChmdW5jdGlvbihncm91cCwgaSwgbGlzdCkge1xuICAgICAgICB2YXIgdGhldGEgPSBpLyhsaXN0Lmxlbmd0aCsxKSAqIE1hdGguUEkgKiAyXG4gICAgICAgIGdyb3VwID0geHRlbmQoZ3JvdXAsIHtcbiAgICAgICAgICAgIHBhbmVsczogZ3JvdXAucGFuZWxzLm1hcChmdW5jdGlvbihwYW5lbCwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlUGFuZWwocGFuZWwsIGluZGV4LCB0aGV0YSlcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgdGhldGE6IHRoZXRhXG4gICAgICAgIH0pXG4gICAgICAgIHJldHVybiBncm91cFxuICAgIH0pXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVBhbmVsKGRhdGEsIGluZGV4LCByb3RhdGlvbikge1xuICAgIHZhciBjb250YWluZXIgPSBuZXcgVEhSRUUuT2JqZWN0M0QoKVxuICAgIHZhciBtaXJyb3IgPSBpbmRleCA9PT0gMVxuXG4gICAgdmFyIHJhZGl1cyA9IDIwXG4gICAgaWYgKG1pcnJvcikge1xuICAgICAgICByb3RhdGlvbiArPSBNYXRoLlBJKjJcbiAgICAgICAgcmFkaXVzICo9IC0xXG4gICAgfVxuXG4gICAgLy9tYWtlIHRleHQgcGVycGVuZGljdWxhciB0byB0aGV0YSByb3RhdGlvblxuICAgIC8vIHJvdGF0aW9uIC09IE1hdGguUEkvMiBcblxuICAgIGNvbnRhaW5lci5wb3NpdGlvbi5zZXQoXG4gICAgICAgIE1hdGguY29zKHJvdGF0aW9uKSAqIHJhZGl1cyxcbiAgICAgICAgMTUsXG4gICAgICAgIE1hdGguc2luKHJvdGF0aW9uKSAqIHJhZGl1c1xuICAgIClcbiAgICBcblxuICAgIC8vIGNvbnRhaW5lci5wb3NpdGlvbi5jb3B5KGRhdGEub3JpZ2luKVxuXG4gICAgdmFyIHBvcyA9IGNvbnRhaW5lci5wb3NpdGlvblxuICAgIHZhciBkaXIgPSBwb3MuY2xvbmUoKS5zdWIobmV3IFRIUkVFLlZlY3RvcjMoMCxwb3MueSwwKSkubm9ybWFsaXplKClcblxuICAgIHZhciByb3RPZmYgPSAwLy9NYXRoLlBJLzEwICogKG1pcnJvciA/IC0xIDogMSlcblxuICAgIHZhciBkeCA9IHBvcy54LFxuICAgICAgICBkeiA9IHBvcy56LFxuICAgICAgICB0aGV0YSA9IC1NYXRoLmF0YW4yKGR6LCBkeCkgLSByb3RPZmZcbiAgICAvLyBjb250YWluZXIucm90YXRpb24ueSA9IHRoZXRhXG4gICAgY29udGFpbmVyLnJvdGF0aW9uLnkgPSB0aGV0YVxuICAgIGNvbnRhaW5lci5yb3RhdGlvbi54ID0gMFxuICAgIFxuICAgIGlmIChtaXJyb3IpIHtcbiAgICAgICAgY29udGFpbmVyLnNjYWxlLnggKj0gLTFcbiAgICB9XG5cbiAgICB2YXIgbGFiZWxzID0gZGF0YS5sYWJlbHMubWFwKGZ1bmN0aW9uKGxhYmVsKSB7XG4gICAgICAgIHZhciBvYmogPSBuZXcgVEhSRUUuT2JqZWN0M0QoKVxuICAgICAgICBjb250YWluZXIuYWRkKG9iailcbiAgICAgICAgaWYgKG1pcnJvcilcbiAgICAgICAgICAgIG9iai5wb3NpdGlvbi54ID0gLWRhdGEud2lkdGh8fDBcbiAgICAgICAgcmV0dXJuIHh0ZW5kKHsgc2l6ZTogMSwgdHJhbnNsYXRpb246IFswLCAwLCAwXSB9LCBsYWJlbCwgeyBcbiAgICAgICAgICAgIG9iamVjdDNkOiBvYmosIFxuICAgICAgICAgICAgLy8gdGhldGE6IHRoZXRhXG4gICAgICAgIH0pXG4gICAgfSlcblxuICAgIHZhciBzaGFwZXMgPSAoZGF0YS5zaGFwZXN8fFtdKS5tYXAoZnVuY3Rpb24oc2hhcGUpIHtcbiAgICAgICAgdmFyIGNvbXBsZXggPSBzaGFwZS5wYXRoID8gZ2V0U1ZHKHNoYXBlLnBhdGgpIDogZ2V0UG9seShzaGFwZS5wb2ludHMpXG4gICAgICAgIHZhciBnZW8gPSBDb21wbGV4KGNvbXBsZXgpXG4gICAgICAgIHZhciBtZXNoID0gbmV3IFRIUkVFLk1lc2goZ2VvLCBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoeyBcbiAgICAgICAgICAgIGNvbG9yOiAweGZmZmZmZixcbiAgICAgICAgICAgIHNpZGU6IFRIUkVFLkRvdWJsZVNpZGUsXG4gICAgICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICAgICAgdHJhbnNwYXJlbnQ6IHRydWVcbiAgICAgICAgfSkpXG4gICAgICAgIFxuICAgICAgICBpZiAoc2hhcGUucG9zaXRpb24pIG1lc2gucG9zaXRpb24uZnJvbUFycmF5KHNoYXBlLnBvc2l0aW9uKVxuICAgICAgICBpZiAoc2hhcGUuc2NhbGUpIG1lc2guc2NhbGUuZnJvbUFycmF5KHNoYXBlLnNjYWxlKVxuXG4gICAgICAgIGNvbnRhaW5lci5hZGQobWVzaClcbiAgICAgICAgcmV0dXJuIG1lc2hcbiAgICB9KVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgbGFiZWxzOiBsYWJlbHMsXG4gICAgICAgIHNoYXBlczogc2hhcGVzLFxuICAgICAgICBjb250YWluZXI6IGNvbnRhaW5lclxuICAgIH1cbn1cbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KSIsInZhciB0cmlhbmd1bGF0ZSA9IHJlcXVpcmUoJ3RyaWFuZ3VsYXRlLWNvbnRvdXJzJylcbnZhciBub3JtYWxpemUgPSByZXF1aXJlKCdub3JtYWxpemUtcGF0aC1zY2FsZScpXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ocG9pbnRzKSB7XG4gICAgcG9pbnRzID0gcG9pbnRzLnNwbGl0KCcgJykubWFwKGZ1bmN0aW9uKHApIHtcbiAgICAgICAgcmV0dXJuIHAuc3BsaXQoJywnKS5tYXAoZnVuY3Rpb24obikge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQobiwgMTApXG4gICAgICAgIH0pXG4gICAgfSlcblxuICAgIHBvaW50cyA9IG5vcm1hbGl6ZShwb2ludHMpXG5cbiAgICB2YXIgdHJpYW5ndWxhdGVkID0gdHJpYW5ndWxhdGUoWyBwb2ludHMgXSlcbiAgICB0cmlhbmd1bGF0ZWQucG9zaXRpb25zID0gdHJpYW5ndWxhdGVkLnBvc2l0aW9ucy5tYXAoZnVuY3Rpb24ocCkge1xuICAgICAgICByZXR1cm4gW3BbMF0sIHBbMV0sIDBdXG4gICAgfSlcbiAgICByZXR1cm4gdHJpYW5ndWxhdGVkXG59IiwidmFyIHBhcnNlID0gcmVxdWlyZSgncGFyc2Utc3ZnLXBhdGgnKVxudmFyIGNvbnRvdXJzID0gcmVxdWlyZSgnc3ZnLXBhdGgtY29udG91cnMnKVxudmFyIHNpbXBsaWZ5ID0gcmVxdWlyZSgnc2ltcGxpZnktcGF0aCcpXG52YXIgdHJpYW5ndWxhdGUgPSByZXF1aXJlKCd0cmlhbmd1bGF0ZS1jb250b3VycycpXG52YXIgbm9ybWFsaXplID0gcmVxdWlyZSgnbm9ybWFsaXplLXBhdGgtc2NhbGUnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGNvbnRlbnRzKSB7XG4gICAgdmFyIHBhcnNlZCA9IHBhcnNlKGNvbnRlbnRzKVxuICAgIGNvbnNvbGUubG9nKHBhcnNlZCwgY29udGVudHMpXG4gICAgLy9nZXQgYSBsaXN0IG9mIHBvbHlsaW5lcy9jb250b3VycyBmcm9tIHN2ZyBjb250ZW50c1xuICAgIHZhciBsaW5lcyA9IGNvbnRvdXJzKHBhcnNlZClcblxuICAgIC8vc2ltcGxpZnkgdGhlIGNvbnRvdXJzIGJlZm9yZSB0cmlhbmd1bGF0aW9uXG4gICAgLy8gbGluZXMgPSBsaW5lcy5tYXAoZnVuY3Rpb24ocGF0aCkge1xuICAgIC8vICAgICByZXR1cm4gc2ltcGxpZnkocGF0aCwgdGhyZXNob2xkKVxuICAgIC8vIH0pXG4gICAgXG4gICAgLy90dXJucyBpbnRvIHRyaWFuZ2xlcywgcmV0dXJucyB7IHBvc2l0aW9ucywgY2VsbHMgfVxuICAgIHZhciBzaGFwZSA9IHRyaWFuZ3VsYXRlKGxpbmVzKVxuXG4gICAgLy9ub3JtYWxpemUoc2hhcGUucG9zaXRpb25zKVxuXG4gICAgc2hhcGUucG9zaXRpb25zID0gc2hhcGUucG9zaXRpb25zLm1hcChmdW5jdGlvbihwKSB7XG4gICAgICAgIHJldHVybiBbcFswXSwgcFsxXSwgMF1cbiAgICB9KVxuICAgIHJldHVybiBzaGFwZVxufSIsIihmdW5jdGlvbiAoZ2xvYmFsKXtcbnZhciBUSFJFRSA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93LlRIUkVFIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbC5USFJFRSA6IG51bGwpXG5cbnZhciBSaWdTY2VuZSA9IHJlcXVpcmUoJy4vUmlnU2NlbmUnKVxudmFyIE9yYml0Q29udHJvbGxlciA9IHJlcXVpcmUoJy4vdGhyZWUtb3JiaXQtY2FtZXJhJykoVEhSRUUpXG52YXIgRWZmZWN0cyA9IHJlcXVpcmUoJy4vc2V0dXAtZWZmZWN0cycpXG5cbnZhciBUd2Vlbk1heCA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93LlR3ZWVuTWF4IDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbC5Ud2Vlbk1heCA6IG51bGwpXG52YXIgYW5pbWF0ZUxhYmVscyA9IHJlcXVpcmUoJy4vYW5pbWF0ZS1sYWJlbHMnKVxudmFyIGhpZGVMYWJlbHMgPSBhbmltYXRlTGFiZWxzLmhpZGVBbGxcblxudmFyIGNsYW1wID0gcmVxdWlyZSgnY2xhbXAnKVxudmFyIHBsdWNrID0gcmVxdWlyZSgncGx1Y2tlcicpXG52YXIgbnVtYmVyID0gcmVxdWlyZSgnYXMtbnVtYmVyJylcbnZhciBzbW9vdGhzdGVwID0gcmVxdWlyZSgnc21vb3Roc3RlcCcpXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob3B0KSB7XG4gICAgb3B0ID0gb3B0fHx7fVxuXG4gICAgdmFyIEZvbnQgPSBvcHQuZm9udFxuXG4gICAgaWYgKCFGb250IHx8ICFGb250LnRleHR1cmVzKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ211c3Qgc3BlY2lmeSBmb250IHdpdGggdGV4dHVyZXMnKVxuXG4gICAgdmFyIHJlbmRlcmVyLFxuICAgICAgICBzY2VuZSxcbiAgICAgICAgY2FtZXJhLFxuICAgICAgICBjb250cm9sbGVyLFxuICAgICAgICBmZWF0dXJlcyxcbiAgICAgICAgd2F0ZXIsXG4gICAgICAgIGVmZmVjdHMsXG4gICAgICAgIGxhYmVscyA9IFtdLFxuICAgICAgICB0aW1lID0gMFxuXG4gICAgaWYgKCFvcHQuZ2wpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbXVzdCBzcGVjaWZ5IEdMIGNvbnRleHQnKVxuXG4gICAgc2V0dXAob3B0LmdsLCBvcHQud2lkdGh8fDAsIG9wdC5oZWlnaHR8fDApXG5cbiAgICBmdW5jdGlvbiBkcmF3KGR0KSB7XG4gICAgICAgIHRpbWUgKz0gIE1hdGgubWluKGR0LCAzMCkgLyAxMDAwXG4gICAgICAgIHJlbmRlcmVyLnJlc2V0QXR0cmlidXRlcygpXG4gICAgICAgIHJlbmRlcmVyLnJlc2V0R0xTdGF0ZSgpXG5cbiAgICAgICAgd2F0ZXIubWF0ZXJpYWwudW5pZm9ybXMudGltZS52YWx1ZSA9IHRpbWUgKiAwLjFcbiAgICAgICAgd2F0ZXIucmVuZGVyKClcblxuICAgICAgICBjb250cm9sbGVyLnVwZGF0ZSgpXG4gICAgICAgIFxuICAgICAgICBzY2VuZS51cGRhdGUoZHQpXG4gICAgICAgIGVmZmVjdHMucmVuZGVyKGR0KVxuXG4gICAgICAgIGFuaW1hdGVMYWJlbHMoY29udHJvbGxlciwgbGFiZWxzKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldHVwKGdsLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHJlbmRlcmVyID0gbmV3IFRIUkVFLldlYkdMUmVuZGVyZXIoeyBcbiAgICAgICAgICAgIGNhbnZhczogZ2wuY2FudmFzLFxuICAgICAgICAgICAgYW50aWFsaWFzOiBmYWxzZSxcbiAgICAgICAgICAgIGFscGhhOiBmYWxzZVxuICAgICAgICB9KVxuICAgICAgICByZW5kZXJlci5zZXRDbGVhckNvbG9yKDB4ZmZmZmZmLCAwKVxuICAgICAgICByZW5kZXJlci5zaGFkb3dNYXBUeXBlID0gVEhSRUUuQmFzaWNTaGFkb3dNYXBcbiAgICAgICAgLy8gcmVuZGVyZXIuc2hhZG93TWFwRW5hYmxlZCA9IHRydWVcblxuICAgICAgICBvcHQuZm92ID0gbnVtYmVyKG9wdC5mb3YsIDUwKVxuICAgICAgICBjYW1lcmEgPSBuZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEob3B0LmZvdiwgd2lkdGgvaGVpZ2h0LCAwLjUsIDIwMDAwKVxuICAgICAgICBjYW1lcmEucG9zaXRpb24ueCA9IC02MFxuICAgICAgICBjYW1lcmEucG9zaXRpb24ueiA9IC00MFxuICAgICAgICBjYW1lcmEucG9zaXRpb24ueSA9IDIwXG4gICAgICAgIGNhbWVyYS5sb29rQXQobmV3IFRIUkVFLlZlY3RvcjMoKSlcblxuICAgICAgICBjb250cm9sbGVyID0gbmV3IE9yYml0Q29udHJvbGxlcihjYW1lcmEpXG4gICAgICAgIGNvbnRyb2xsZXIudXNlclBhbiA9IGZhbHNlXG4gICAgICAgIGNvbnRyb2xsZXIudXNlclBhblNwZWVkID0gMC4wXG4gICAgICAgIGNvbnRyb2xsZXIuem9vbVNwZWVkID0gMC4xXG4gICAgICAgIGNvbnRyb2xsZXIucm90YXRlU3BlZWQgPSAwLjJcbiAgICAgICAgY29udHJvbGxlci5taW5EaXN0YW5jZSA9IDMwXG4gICAgICAgIGNvbnRyb2xsZXIubWF4RGlzdGFuY2UgPSAyMDAuMFxuICAgICAgICBjb250cm9sbGVyLm1heFBvbGFyQW5nbGUgPSA4OCAqIE1hdGguUEkvMTgwXG4gICAgICAgIGNvbnRyb2xsZXIubWluUG9sYXJBbmdsZSA9IDQwICogTWF0aC5QSS8xODBcbiAgICAgICAgY29udHJvbGxlci5jZW50ZXIuc2V0KCAwLCA1LCAwIClcbiAgICAgICAgc2NlbmUgPSBSaWdTY2VuZSgpXG5cbiAgICAgICAgd2F0ZXIgPSByZXF1aXJlKCcuL3NldHVwLXdhdGVyJykocmVuZGVyZXIsIGNhbWVyYSwgc2NlbmUpXG4gICAgICAgIFxuICAgICAgICBzY2VuZS5jdWJlTWFwID0gd2F0ZXIuY3ViZU1hcFxuICAgICAgICBzY2VuZS51cGRhdGVNYXRlcmlhbCgpXG5cbiAgICAgICAgdmFyIHBhc3MgPSByZXF1aXJlKCcuL2NyZWF0ZS10ZXh0LXBhc3MnKSh7XG4gICAgICAgICAgICByZW5kZXJlcjogcmVuZGVyZXIsXG4gICAgICAgICAgICBzY2VuZTogc2NlbmUsXG4gICAgICAgICAgICBjYW1lcmE6IGNhbWVyYSxcbiAgICAgICAgICAgIGZvbnQ6IEZvbnRcbiAgICAgICAgfSlcblxuICAgICAgICBsYWJlbHMgPSBwYXNzLmdyb3Vwc1xuXG4gICAgICAgIGVmZmVjdHMgPSBFZmZlY3RzKHtcbiAgICAgICAgICAgIHJlbmRlcmVyOiByZW5kZXJlcixcbiAgICAgICAgICAgIHNjZW5lOiBzY2VuZSxcbiAgICAgICAgICAgIGNhbWVyYTogY2FtZXJhLFxuICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgYmx1cjogZmFsc2UsXG4gICAgICAgICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgICAgIHJlbmRlclBhc3M6IHBhc3NcbiAgICAgICAgfSlcblxuICAgICAgICBoaWRlTGFiZWxzKGxhYmVscylcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVSZXNpemUod2lkdGgsIGhlaWdodCkge1xuICAgICAgICByZW5kZXJlci5zZXRTaXplKHdpZHRoLCBoZWlnaHQpXG4gICAgICAgIGNhbWVyYS5hc3BlY3QgPSB3aWR0aC9oZWlnaHRcbiAgICAgICAgY2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKVxuXG4gICAgICAgIGVmZmVjdHMucmVzaXplKHdpZHRoLCBoZWlnaHQpXG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgZHJhdzogZHJhdyxcbiAgICAgICAgcmVzaXplOiBoYW5kbGVSZXNpemVcbiAgICB9XG59XG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSkiLCIoZnVuY3Rpb24gKGdsb2JhbCl7XG52YXIgVEhSRUUgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdy5USFJFRSA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwuVEhSRUUgOiBudWxsKVxudmFyIEVmZmVjdENvbXBvc2VyID0gcmVxdWlyZSgndGhyZWUtZWZmZWN0Y29tcG9zZXInKShUSFJFRSlcbnZhciBjcmVhdGVGWEFBID0gcmVxdWlyZSgndGhyZWUtc2hhZGVyLWZ4YWEnKShUSFJFRSlcbnZhciBjcmVhdGVCbHVyID0gcmVxdWlyZSgnLi9zaGFkZXJzL2JsdXInKVxudmFyIGNyZWF0ZUxlbnMgPSByZXF1aXJlKCcuL3NoYWRlcnMvbGVucycpXG52YXIgY3JlYXRlRW1wdHkgPSByZXF1aXJlKCcuL3NoYWRlcnMvcGFzcycpXG4vLyB2YXIgVGV4dFBhc3MgPSByZXF1aXJlKCcuL1RleHRQYXNzJylcblxubW9kdWxlLmV4cG9ydHMgPSBFZmZlY3RzXG5cbmZ1bmN0aW9uIEVmZmVjdHMob3B0KSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEVmZmVjdHMpKSBcbiAgICAgICAgcmV0dXJuIG5ldyBFZmZlY3RzKG9wdClcbiAgICBvcHQgPSBvcHR8fHt9XG5cblxuICAgIHZhciBwYXJhbWV0ZXJzID0geyBcbiAgICAgICAgbWluRmlsdGVyOiBUSFJFRS5MaW5lYXJGaWx0ZXIsIFxuICAgICAgICBtYWdGaWx0ZXI6IFRIUkVFLkxpbmVhckZpbHRlciwgXG4gICAgICAgIGZvcm1hdDogVEhSRUUuUkdCRm9ybWF0LCBcbiAgICAgICAgc3RlbmNpbEJ1ZmZlcjogZmFsc2UgXG4gICAgfVxuICAgIHZhciB3aWR0aCA9IG9wdC53aWR0aFxuICAgIHZhciBoZWlnaHQgPSBvcHQuaGVpZ2h0XG4gICAgdmFyIHJlbmRlclRhcmdldCA9IG5ldyBUSFJFRS5XZWJHTFJlbmRlclRhcmdldCh3aWR0aCwgaGVpZ2h0LCBwYXJhbWV0ZXJzKTtcblxuICAgIHRoaXMuY29tcG9zZXIgPSBuZXcgRWZmZWN0Q29tcG9zZXIob3B0LnJlbmRlcmVyLCByZW5kZXJUYXJnZXQpXG4gICAgdGhpcy5jb21wb3Nlci5hZGRQYXNzKG9wdC5yZW5kZXJQYXNzKVxuICAgIFxuICAgIHRoaXMuc2hhZGVycyA9IFtdXG4gICAgdGhpcy5ub2lzZURlbGF5ID0gMzNcbiAgICB0aGlzLm5vaXNlVGltZSA9IDBcblxuICAgIC8vIHRoaXMuc2hhZGVycy5wdXNoKG5ldyBFZmZlY3RDb21wb3Nlci5TaGFkZXJQYXNzKGNyZWF0ZUVtcHR5KCkpKVxuXG5cbiAgICB2YXIgZnhhYVNoYWRlciA9IG5ldyBFZmZlY3RDb21wb3Nlci5TaGFkZXJQYXNzKGNyZWF0ZUZYQUEoKSlcbiAgICB0aGlzLnNoYWRlcnMucHVzaChmeGFhU2hhZGVyKVxuXG4gICAgaWYgKG9wdC5ibHVyICE9PSBmYWxzZSkge1xuICAgICAgICB2YXIgYmx1ciA9IGNyZWF0ZUJsdXIoKVxuICAgICAgICB2YXIgaXRlcmF0aW9ucyA9IDE7XG4gICAgICAgIGZvciAodmFyIGk9MDsgaTxpdGVyYXRpb25zOyBpKyspIHtcbiAgICAgICAgICAgIHZhciByID0gKGkrMSkqMjtcblxuICAgICAgICAgICAgdmFyIGhvcml6ID0gbmV3IEVmZmVjdENvbXBvc2VyLlNoYWRlclBhc3MoIGJsdXIgKTtcbiAgICAgICAgICAgIGhvcml6LnVuaWZvcm1zLnJhZGl1cy52YWx1ZSA9IHJcbiAgICAgICAgICAgIGhvcml6LnVuaWZvcm1zLnN0cmVuZ3RoLnZhbHVlID0gMVxuICAgICAgICAgICAgaG9yaXoudW5pZm9ybXMuZGlyLnZhbHVlLnNldCgxLDApXG5cbiAgICAgICAgICAgIHZhciB2ZXJ0ID0gbmV3IEVmZmVjdENvbXBvc2VyLlNoYWRlclBhc3MoIGJsdXIgKTtcbiAgICAgICAgICAgIHZlcnQudW5pZm9ybXMucmFkaXVzLnZhbHVlID0gclxuICAgICAgICAgICAgdmVydC51bmlmb3Jtcy5zdHJlbmd0aC52YWx1ZSA9IDFcbiAgICAgICAgICAgIHZlcnQudW5pZm9ybXMuZGlyLnZhbHVlLnNldCgwLDEpXG5cbiAgICAgICAgICAgIHRoaXMuc2hhZGVycy5wdXNoKGhvcml6LCB2ZXJ0KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGxlbnNQYXNzID0gbmV3IEVmZmVjdENvbXBvc2VyLlNoYWRlclBhc3MoY3JlYXRlTGVucygpKVxuICAgIHRoaXMuc2hhZGVycy5wdXNoKGxlbnNQYXNzKVxuXG4gICAgLy9kZWZhdWx0IHZhbHVlcyB0byBhdm9pZCBkaXYgYnkgemVyb1xuICAgIGxlbnNQYXNzLnVuaWZvcm1zLm92ZXJsYXlSZXNvbHV0aW9uLnZhbHVlLnNldCgxLCAxKVxuICAgIGxlbnNQYXNzLnVuaWZvcm1zLnRMb29rdXAudmFsdWUgPSBsb2FkVGV4dHVyZSgnaW1nL2xvb2t1cC5wbmcnLCB7IFxuICAgICAgICBnZW5lcmF0ZU1pcG1hcHM6IGZhbHNlLFxuICAgICAgICBmaWx0ZXI6IFRIUkVFLkxpbmVhckZpbHRlciBcbiAgICB9KVxuICAgIGxlbnNQYXNzLnVuaWZvcm1zLnRPdmVybGF5LnZhbHVlID0gbG9hZFRleHR1cmUoJ2ltZy9kdXN0LmpwZycsIHtcbiAgICAgICAgZ2VuZXJhdGVNaXBtYXBzOiBmYWxzZSxcbiAgICAgICAgZmlsdGVyOiBUSFJFRS5MaW5lYXJGaWx0ZXJcbiAgICB9LCBmdW5jdGlvbihlcnIsIHRleCkge1xuICAgICAgICBsZW5zUGFzcy51bmlmb3Jtcy5vdmVybGF5UmVzb2x1dGlvbi52YWx1ZS5zZXQodGV4LmltYWdlLndpZHRoLCB0ZXguaW1hZ2UuaGVpZ2h0KVxuICAgIH0pXG5cbiAgICB0aGlzLnNoYWRlcnMuZm9yRWFjaChmdW5jdGlvbihwYXNzLCBpLCBzZWxmKSB7XG4gICAgICAgIHRoaXMuY29tcG9zZXIuYWRkUGFzcyhwYXNzKVxuICAgICAgICBpZiAoaSA9PT0gc2VsZi5sZW5ndGgtMSlcbiAgICAgICAgICAgIHBhc3MucmVuZGVyVG9TY3JlZW4gPSB0cnVlXG4gICAgfSwgdGhpcykgIFxuICAgIGlmIChvcHQud2lkdGggJiYgb3B0LmhlaWdodCkgXG4gICAgICAgIHRoaXMucmVzaXplKG9wdC53aWR0aCwgb3B0LmhlaWdodClcbn1cblxuXG5mdW5jdGlvbiBsb2FkVGV4dHVyZShwYXRoLCBvcHQsIGNiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY2IgPSBvcHRcbiAgICAgICAgb3B0ID0ge31cbiAgICB9XG5cbiAgICByZXR1cm4gVEhSRUUuSW1hZ2VVdGlscy5sb2FkVGV4dHVyZShwYXRoLCB1bmRlZmluZWQsIGZ1bmN0aW9uKHRleCkge1xuICAgICAgICBpZiAob3B0LmZpbHRlcikgdGV4Lm1pbkZpbHRlciA9IHRleC5tYWdGaWx0ZXIgPSBvcHQuZmlsdGVyXG4gICAgICAgIGlmIChvcHQud3JhcCkgdGV4LndyYXBTID0gdGV4LndyYXBUID0gb3B0LndyYXBcbiAgICAgICAgdGV4LmdlbmVyYXRlTWlwbWFwcyA9IG9wdC5nZW5lcmF0ZU1pcG1hcHNcbiAgICAgICAgaWYgKHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJykgXG4gICAgICAgICAgICBjYihudWxsLCB0ZXgpXG4gICAgfSlcbn1cblxucmVxdWlyZSgnbWl4ZXMnKShFZmZlY3RzLCB7XG5cbiAgICByZW5kZXI6IGZ1bmN0aW9uKGR0KSB7XG4gICAgICAgIHRoaXMubm9pc2VUaW1lICs9IGR0XG4gICAgICAgIGlmICh0aGlzLm5vaXNlVGltZSA+IHRoaXMubm9pc2VEZWxheSkge1xuICAgICAgICAgICAgdGhpcy5ub2lzZVRpbWUgPSAwXG4gICAgICAgICAgICB0aGlzLnNoYWRlcnMuZm9yRWFjaChmdW5jdGlvbihwYXNzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhc3MudW5pZm9ybXMudGljaylcbiAgICAgICAgICAgICAgICAgICAgcGFzcy51bmlmb3Jtcy50aWNrLnZhbHVlICs9IDAuMDA1XG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jb21wb3Nlci5yZW5kZXIoKVxuICAgIH0sXG5cbiAgICByZXNpemU6IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgd2lkdGggKj0gMlxuICAgICAgICBoZWlnaHQgKj0gMlxuICAgICAgICB0aGlzLmNvbXBvc2VyLnNldFNpemUod2lkdGgsIGhlaWdodClcbiAgICAgICAgdGhpcy5zaGFkZXJzLmZvckVhY2goZnVuY3Rpb24ocGFzcykge1xuICAgICAgICAgICAgdmFyIGRwciA9IDFcbiAgICAgICAgICAgIC8vIHZhciBkcHIgPSAod2luZG93LmRldmljZVBpeGVsUmF0aW98fDEpXG4gICAgICAgICAgICBpZiAocGFzcy51bmlmb3Jtcy5yZXNvbHV0aW9uKVxuICAgICAgICAgICAgICAgIHBhc3MudW5pZm9ybXMucmVzb2x1dGlvbi52YWx1ZS5zZXQod2lkdGgqZHByLCBoZWlnaHQqZHByKVxuICAgICAgICAgICAgXG4gICAgICAgIH0pXG4gICAgfVxufSlcbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KSIsInZhciBjdWJlU2hhZGVyID0ge1xuXG4gICAgdW5pZm9ybXM6IFRIUkVFLlVuaWZvcm1zVXRpbHMubWVyZ2UoIFtcbiAgICAgICAgeyBcInRDdWJlXCI6IHsgdHlwZTogXCJ0XCIsIHZhbHVlOiBudWxsIH0sXG4gICAgICAgIFwidEZsaXBcIjogeyB0eXBlOiBcImZcIiwgdmFsdWU6IC0gMSB9IH0sXG4gICAgICAgIFRIUkVFLlVuaWZvcm1zTGliWyBcImZvZ1wiIF1cbiAgICBdICksXG5cbiAgICB2ZXJ0ZXhTaGFkZXI6IFtcblxuICAgICAgICBcInZhcnlpbmcgdmVjMyB2V29ybGRQb3NpdGlvbjtcIixcblxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleFwiIF0sXG5cbiAgICAgICAgXCJ2b2lkIG1haW4oKSB7XCIsXG5cbiAgICAgICAgXCIgICB2ZWM0IHdvcmxkUG9zaXRpb24gPSBtb2RlbE1hdHJpeCAqIHZlYzQoIHBvc2l0aW9uLCAxLjAgKTtcIixcbiAgICAgICAgXCIgICB2V29ybGRQb3NpdGlvbiA9IHdvcmxkUG9zaXRpb24ueHl6O1wiLFxuXG4gICAgICAgIFwiICAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApO1wiLFxuXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl92ZXJ0ZXhcIiBdLFxuXG4gICAgICAgIFwifVwiXG5cbiAgICBdLmpvaW4oXCJcXG5cIiksXG5cbiAgICBmcmFnbWVudFNoYWRlcjogW1xuXG4gICAgICAgIFwidW5pZm9ybSBzYW1wbGVyQ3ViZSB0Q3ViZTtcIixcbiAgICAgICAgXCJ1bmlmb3JtIGZsb2F0IHRGbGlwO1wiLFxuXG4gICAgICAgIFwidmFyeWluZyB2ZWMzIHZXb3JsZFBvc2l0aW9uO1wiLFxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50XCIgXSxcbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiZm9nX3BhcnNfZnJhZ21lbnRcIiBdLFxuICAgICAgICBcInZvaWQgbWFpbigpIHtcIixcbiAgICAgICAgXCIgICBnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlQ3ViZSggdEN1YmUsIHZlYzMoIHRGbGlwICogdldvcmxkUG9zaXRpb24ueCwgdldvcmxkUG9zaXRpb24ueXogKSApO1wiLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfZnJhZ21lbnRcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiZm9nX2ZyYWdtZW50XCIgXSxcbiAgICAgICAgXCJ9XCJcblxuICAgIF0uam9pbihcIlxcblwiKVxuXG59XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHJlbmRlcmVyLCBjYW1lcmEsIHNjZW5lKSB7XG4gICAgdmFyIGxpZ2h0ID0gbmV3IFRIUkVFLkhlbWlzcGhlcmVMaWdodCgweGJiZTlmZiwgMHgwODA4MjAsIDEpXG4gICAgbGlnaHQucG9zaXRpb24uc2V0KC0xLCAxLCAtMSlcbiAgICBzY2VuZS5hZGQobGlnaHQpXG5cbiAgICB2YXIgd2F0ZXJOb3JtYWxzID0gbmV3IFRIUkVFLkltYWdlVXRpbHMubG9hZFRleHR1cmUoJ2ltZy93YXRlcm5vcm1hbHM1LmpwZycpXG4gICAgd2F0ZXJOb3JtYWxzLndyYXBTID0gd2F0ZXJOb3JtYWxzLndyYXBUID0gVEhSRUUuUmVwZWF0V3JhcHBpbmdcblxuICAgIHZhciB3YXRlciA9IG5ldyBUSFJFRS5XYXRlcihyZW5kZXJlciwgY2FtZXJhLCBzY2VuZSwge1xuICAgICAgICB0ZXh0dXJlV2lkdGg6IDUxMixcbiAgICAgICAgdGV4dHVyZUhlaWdodDogNTEyLFxuICAgICAgICB3YXRlck5vcm1hbHM6IHdhdGVyTm9ybWFscyxcbiAgICAgICAgYWxwaGE6IDAuOSxcbiAgICAgICAgc3VuRGlyZWN0aW9uOiBsaWdodC5wb3NpdGlvbi5jbG9uZSgpLm5vcm1hbGl6ZSgpLFxuICAgICAgICBzdW5Db2xvcjogMHhmZmZmZmYsXG4gICAgICAgIHdhdGVyQ29sb3I6IDB4MDIwZDE1LFxuICAgICAgICBkaXN0b3J0aW9uU2NhbGU6IDgwLjAsXG4gICAgfSlcblxuICAgIHZhciBtaXJyb3JNZXNoID0gbmV3IFRIUkVFLk1lc2goXG4gICAgICAgIG5ldyBUSFJFRS5QbGFuZUJ1ZmZlckdlb21ldHJ5KDUwMDAsIDUwMDApLFxuICAgICAgICB3YXRlci5tYXRlcmlhbFxuICAgIClcblxuICAgIG1pcnJvck1lc2guYWRkKHdhdGVyKVxuICAgIG1pcnJvck1lc2gucm90YXRpb24ueCA9IC1NYXRoLlBJICogMC41XG4gICAgc2NlbmUuYWRkKG1pcnJvck1lc2gpXG5cblxuICAgIC8vIGxvYWQgc2t5Ym94XG5cbiAgICB2YXIgY3ViZU1hcCA9IG5ldyBUSFJFRS5DdWJlVGV4dHVyZShbXSlcbiAgICBjdWJlTWFwLmZvcm1hdCA9IFRIUkVFLlJHQkZvcm1hdFxuICAgIGN1YmVNYXAuZmxpcFkgPSBmYWxzZVxuXG4gICAgdmFyIGxvYWRlciA9IG5ldyBUSFJFRS5JbWFnZUxvYWRlcigpXG4gICAgbG9hZGVyLmxvYWQoJ2ltZy9jbG91ZHlfbmlnaHQyLmpwZycsIGZ1bmN0aW9uKGltYWdlKSB7XG5cbiAgICAgICAgdmFyIGdldFNpZGUgPSBmdW5jdGlvbih4LCB5KSB7XG5cbiAgICAgICAgICAgIHZhciBzaXplID0gMTAyNFxuXG4gICAgICAgICAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJylcbiAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IHNpemVcbiAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSBzaXplXG5cbiAgICAgICAgICAgIHZhciBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJylcbiAgICAgICAgICAgIGNvbnRleHQuZHJhd0ltYWdlKGltYWdlLCAteCAqIHNpemUsIC15ICogc2l6ZSlcblxuICAgICAgICAgICAgcmV0dXJuIGNhbnZhc1xuXG4gICAgICAgIH1cblxuICAgICAgICBjdWJlTWFwLmltYWdlc1swXSA9IGdldFNpZGUoMiwgMSkgLy8gcHhcbiAgICAgICAgY3ViZU1hcC5pbWFnZXNbMV0gPSBnZXRTaWRlKDAsIDEpIC8vIG54XG4gICAgICAgIGN1YmVNYXAuaW1hZ2VzWzJdID0gZ2V0U2lkZSgxLCAwKSAvLyBweVxuICAgICAgICBjdWJlTWFwLmltYWdlc1szXSA9IGdldFNpZGUoMSwgMikgLy8gbnlcbiAgICAgICAgY3ViZU1hcC5pbWFnZXNbNF0gPSBnZXRTaWRlKDEsIDEpIC8vIHB6XG4gICAgICAgIGN1YmVNYXAuaW1hZ2VzWzVdID0gZ2V0U2lkZSgzLCAxKSAvLyBuelxuICAgICAgICBjdWJlTWFwLm5lZWRzVXBkYXRlID0gdHJ1ZVxuXG4gICAgfSlcblxuICAgIGN1YmVTaGFkZXIudW5pZm9ybXMudEN1YmUudmFsdWUgPSBjdWJlTWFwXG5cbiAgICB2YXIgc2t5Qm94TWF0ZXJpYWwgPSBuZXcgVEhSRUUuU2hhZGVyTWF0ZXJpYWwoe1xuICAgICAgICBmcmFnbWVudFNoYWRlcjogY3ViZVNoYWRlci5mcmFnbWVudFNoYWRlcixcbiAgICAgICAgdmVydGV4U2hhZGVyOiBjdWJlU2hhZGVyLnZlcnRleFNoYWRlcixcbiAgICAgICAgdW5pZm9ybXM6IGN1YmVTaGFkZXIudW5pZm9ybXMsXG4gICAgICAgIC8vIGRlcHRoV3JpdGU6IGZhbHNlLFxuICAgICAgICBzaWRlOiBUSFJFRS5CYWNrU2lkZSxcbiAgICAgICAgZm9nOiB0cnVlLFxuICAgIH0pXG5cbiAgICB2YXIgc2t5Qm94ID0gbmV3IFRIUkVFLk1lc2goXG4gICAgICAgIG5ldyBUSFJFRS5Cb3hHZW9tZXRyeSg1MDAwLCA1MDAwLCA1MDAwKSxcbiAgICAgICAgc2t5Qm94TWF0ZXJpYWxcbiAgICApXG4gICAgXG4gICAgd2F0ZXIuY3ViZU1hcCA9IGN1YmVNYXBcblxuICAgIHNjZW5lLmFkZChza3lCb3gpXG4gICAgcmV0dXJuIHdhdGVyXG59IiwidmFyIGdsc2xpZnkgPSByZXF1aXJlKFwiZ2xzbGlmeVwiKTtcbnZhciBzb3VyY2UgPSByZXF1aXJlKFwiZ2xzbGlmeS9zaW1wbGUtYWRhcHRlci5qc1wiKShcIlxcbiNkZWZpbmUgR0xTTElGWSAxXFxuXFxudmFyeWluZyB2ZWMyIHZVdjtcXG52b2lkIG1haW4oKSB7XFxuICB2VXYgPSB1djtcXG4gIGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG1vZGVsVmlld01hdHJpeCAqIHZlYzQocG9zaXRpb24sIDEuMCk7XFxufVwiLCBcIlxcbiNkZWZpbmUgR0xTTElGWSAxXFxuXFxudW5pZm9ybSB2ZWMyIHJlc29sdXRpb247XFxudW5pZm9ybSBmbG9hdCByYWRpdXM7XFxudW5pZm9ybSB2ZWMyIGRpcjtcXG51bmlmb3JtIGZsb2F0IHN0cmVuZ3RoO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHREaWZmdXNlO1xcbnZhcnlpbmcgdmVjMiB2VXY7XFxudmVjNCBhX3hfYmx1cihzYW1wbGVyMkQgdGV4LCB2ZWMyIHV2LCB2ZWMyIGJsdXIsIHZlYzIgZGlyZWN0aW9uKSB7XFxuICB2ZWM0IHN1bSA9IHZlYzQoMC4wKTtcXG4gIHN1bSArPSB0ZXh0dXJlMkQodGV4LCB2ZWMyKHV2LnggLSA0LjAgKiBibHVyLnggKiBkaXJlY3Rpb24ueCwgdXYueSAtIDQuMCAqIGJsdXIueSAqIGRpcmVjdGlvbi55KSkgKiAwLjAxNjIxNjIxNjI7XFxuICBzdW0gKz0gdGV4dHVyZTJEKHRleCwgdmVjMih1di54IC0gMy4wICogYmx1ci54ICogZGlyZWN0aW9uLngsIHV2LnkgLSAzLjAgKiBibHVyLnkgKiBkaXJlY3Rpb24ueSkpICogMC4wNTQwNTQwNTQxO1xcbiAgc3VtICs9IHRleHR1cmUyRCh0ZXgsIHZlYzIodXYueCAtIDIuMCAqIGJsdXIueCAqIGRpcmVjdGlvbi54LCB1di55IC0gMi4wICogYmx1ci55ICogZGlyZWN0aW9uLnkpKSAqIDAuMTIxNjIxNjIxNjtcXG4gIHN1bSArPSB0ZXh0dXJlMkQodGV4LCB2ZWMyKHV2LnggLSAxLjAgKiBibHVyLnggKiBkaXJlY3Rpb24ueCwgdXYueSAtIDEuMCAqIGJsdXIueSAqIGRpcmVjdGlvbi55KSkgKiAwLjE5NDU5NDU5NDY7XFxuICBzdW0gKz0gdGV4dHVyZTJEKHRleCwgdmVjMih1di54LCB1di55KSkgKiAwLjIyNzAyNzAyNzA7XFxuICBzdW0gKz0gdGV4dHVyZTJEKHRleCwgdmVjMih1di54ICsgMS4wICogYmx1ci54ICogZGlyZWN0aW9uLngsIHV2LnkgKyAxLjAgKiBibHVyLnkgKiBkaXJlY3Rpb24ueSkpICogMC4xOTQ1OTQ1OTQ2O1xcbiAgc3VtICs9IHRleHR1cmUyRCh0ZXgsIHZlYzIodXYueCArIDIuMCAqIGJsdXIueCAqIGRpcmVjdGlvbi54LCB1di55ICsgMi4wICogYmx1ci55ICogZGlyZWN0aW9uLnkpKSAqIDAuMTIxNjIxNjIxNjtcXG4gIHN1bSArPSB0ZXh0dXJlMkQodGV4LCB2ZWMyKHV2LnggKyAzLjAgKiBibHVyLnggKiBkaXJlY3Rpb24ueCwgdXYueSArIDMuMCAqIGJsdXIueSAqIGRpcmVjdGlvbi55KSkgKiAwLjA1NDA1NDA1NDE7XFxuICBzdW0gKz0gdGV4dHVyZTJEKHRleCwgdmVjMih1di54ICsgNC4wICogYmx1ci54ICogZGlyZWN0aW9uLngsIHV2LnkgKyA0LjAgKiBibHVyLnkgKiBkaXJlY3Rpb24ueSkpICogMC4wMTYyMTYyMTYyO1xcbiAgcmV0dXJuIHN1bTtcXG59XFxudm9pZCBtYWluKCkge1xcbiAgdmVjMiBibHVyQW10ID0gdmVjMihyYWRpdXMpIC8gcmVzb2x1dGlvbjtcXG4gIHZlYzQgc3VtID0gYV94X2JsdXIodERpZmZ1c2UsIHZVdiwgYmx1ckFtdCwgZGlyKTtcXG4gIHZlYzIgcCA9IChnbF9GcmFnQ29vcmQueHkgLyByZXNvbHV0aW9uLnh5IC0gMC41KTtcXG4gIHAueCAqPSByZXNvbHV0aW9uLnggLyByZXNvbHV0aW9uLnk7XFxuICBmbG9hdCBsZW4gPSBzbW9vdGhzdGVwKDAuNSwgMS4yLCBsZW5ndGgocCkpO1xcbiAgdmVjMyBvcmlnID0gdGV4dHVyZTJEKHREaWZmdXNlLCB2VXYpLnJnYjtcXG4gIGdsX0ZyYWdDb2xvci5yZ2IgPSBtaXgob3JpZywgc3VtLnJnYiwgbGVuICsgMC4xKTtcXG4gIGdsX0ZyYWdDb2xvci5hID0gMS4wO1xcbn1cIiwgW3tcIm5hbWVcIjpcInJlc29sdXRpb25cIixcInR5cGVcIjpcInZlYzJcIn0se1wibmFtZVwiOlwicmFkaXVzXCIsXCJ0eXBlXCI6XCJmbG9hdFwifSx7XCJuYW1lXCI6XCJkaXJcIixcInR5cGVcIjpcInZlYzJcIn0se1wibmFtZVwiOlwic3RyZW5ndGhcIixcInR5cGVcIjpcImZsb2F0XCJ9LHtcIm5hbWVcIjpcInREaWZmdXNlXCIsXCJ0eXBlXCI6XCJzYW1wbGVyMkRcIn1dLCBbXSk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL2NyZWF0ZVwiKShzb3VyY2UpOyIsIihmdW5jdGlvbiAoZ2xvYmFsKXtcbnZhciBUSFJFRSA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93LlRIUkVFIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbC5USFJFRSA6IG51bGwpXG52YXIgdGhyZWVpZnkgPSByZXF1aXJlKCd0aHJlZS1nbHNsaWZ5JykoVEhSRUUpXG52YXIgeHRlbmQgPSByZXF1aXJlKCd4dGVuZCcpIFxuIFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihzb3VyY2UpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24ob3B0KSB7XG4gICAgICAgIHJldHVybiB4dGVuZCh0aHJlZWlmeShzb3VyY2UpLCBvcHQpXG4gICAgfVxufVxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pIiwidmFyIGdsc2xpZnkgPSByZXF1aXJlKFwiZ2xzbGlmeVwiKTtcbnZhciBzb3VyY2UgPSByZXF1aXJlKFwiZ2xzbGlmeS9zaW1wbGUtYWRhcHRlci5qc1wiKShcIlxcbiNkZWZpbmUgR0xTTElGWSAxXFxuXFxudW5pZm9ybSB2ZWMyIG92ZXJsYXlSZXNvbHV0aW9uO1xcbnVuaWZvcm0gdmVjMiByZXNvbHV0aW9uO1xcbnZhcnlpbmcgdmVjMiB2VXY7XFxudmFyeWluZyB2ZWMyIG92ZXJsYXlVVjtcXG52b2lkIG1haW4oKSB7XFxuICB2VXYgPSB1djtcXG4gIGZsb2F0IGFzcGVjdCA9IG92ZXJsYXlSZXNvbHV0aW9uLnggLyBvdmVybGF5UmVzb2x1dGlvbi55O1xcbiAgZmxvYXQgcmF0aW8gPSByZXNvbHV0aW9uLnggLyByZXNvbHV0aW9uLnk7XFxuICBvdmVybGF5VVYgPSB1djtcXG4gIGZsb2F0IHRBc3BlY3QgPSBvdmVybGF5UmVzb2x1dGlvbi54IC8gb3ZlcmxheVJlc29sdXRpb24ueTtcXG4gIGZsb2F0IHBBc3BlY3QgPSByZXNvbHV0aW9uLnggLyByZXNvbHV0aW9uLnk7XFxuICBvdmVybGF5VVYgPSB1djtcXG4gIGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG1vZGVsVmlld01hdHJpeCAqIHZlYzQocG9zaXRpb24sIDEuMCk7XFxufVwiLCBcIlxcbiNkZWZpbmUgR0xTTElGWSAxXFxuXFxudW5pZm9ybSBmbG9hdCB0aWNrO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHREaWZmdXNlO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHRMb29rdXA7XFxudW5pZm9ybSBzYW1wbGVyMkQgdE92ZXJsYXk7XFxudmFyeWluZyB2ZWMyIHZVdjtcXG52YXJ5aW5nIHZlYzIgb3ZlcmxheVVWO1xcbmhpZ2hwIGZsb2F0IGFfeF9yYW5kb20odmVjMiBjbykge1xcbiAgaGlnaHAgZmxvYXQgYSA9IDEyLjk4OTg7XFxuICBoaWdocCBmbG9hdCBiID0gNzguMjMzO1xcbiAgaGlnaHAgZmxvYXQgYyA9IDQzNzU4LjU0NTM7XFxuICBoaWdocCBmbG9hdCBkdCA9IGRvdChjby54eSwgdmVjMihhLCBiKSk7XFxuICBoaWdocCBmbG9hdCBzbiA9IG1vZChkdCwgMy4xNCk7XFxuICByZXR1cm4gZnJhY3Qoc2luKHNuKSAqIGMpO1xcbn1cXG52ZWMzIGJfeF9ibGVuZE92ZXJsYXkodmVjMyBiYXNlLCB2ZWMzIGJsZW5kKSB7XFxuICByZXR1cm4gdmVjMyhiYXNlLnIgPCAwLjUgPyAoMi4wICogYmFzZS5yICogYmxlbmQucikgOiAoMS4wIC0gMi4wICogKDEuMCAtIGJhc2UucikgKiAoMS4wIC0gYmxlbmQucikpLCBiYXNlLmcgPCAwLjUgPyAoMi4wICogYmFzZS5nICogYmxlbmQuZykgOiAoMS4wIC0gMi4wICogKDEuMCAtIGJhc2UuZykgKiAoMS4wIC0gYmxlbmQuZykpLCBiYXNlLmIgPCAwLjUgPyAoMi4wICogYmFzZS5iICogYmxlbmQuYikgOiAoMS4wIC0gMi4wICogKDEuMCAtIGJhc2UuYikgKiAoMS4wIC0gYmxlbmQuYikpKTtcXG59XFxuZmxvYXQgY194X2x1bWEodmVjMyBjb2xvcikge1xcbiAgcmV0dXJuIGRvdChjb2xvciwgdmVjMygwLjI5OSwgMC41ODcsIDAuMTE0KSk7XFxufVxcbmZsb2F0IGNfeF9sdW1hKHZlYzQgY29sb3IpIHtcXG4gIHJldHVybiBkb3QoY29sb3IucmdiLCB2ZWMzKDAuMjk5LCAwLjU4NywgMC4xMTQpKTtcXG59XFxuI2RlZmluZSBMVVRfRkxJUF9ZXFxuXFxudmVjNCBlX3hfbG9va3VwKGluIHZlYzQgdGV4dHVyZUNvbG9yLCBpbiBzYW1wbGVyMkQgbG9va3VwVGFibGUpIHtcXG4gIFxcbiAgI2lmbmRlZiBMVVRfTk9fQ0xBTVBcXG4gIHRleHR1cmVDb2xvciA9IGNsYW1wKHRleHR1cmVDb2xvciwgMC4wLCAxLjApO1xcbiAgI2VuZGlmXFxuICBtZWRpdW1wIGZsb2F0IGJsdWVDb2xvciA9IHRleHR1cmVDb2xvci5iICogNjMuMDtcXG4gIG1lZGl1bXAgdmVjMiBxdWFkMTtcXG4gIHF1YWQxLnkgPSBmbG9vcihmbG9vcihibHVlQ29sb3IpIC8gOC4wKTtcXG4gIHF1YWQxLnggPSBmbG9vcihibHVlQ29sb3IpIC0gKHF1YWQxLnkgKiA4LjApO1xcbiAgbWVkaXVtcCB2ZWMyIHF1YWQyO1xcbiAgcXVhZDIueSA9IGZsb29yKGNlaWwoYmx1ZUNvbG9yKSAvIDguMCk7XFxuICBxdWFkMi54ID0gY2VpbChibHVlQ29sb3IpIC0gKHF1YWQyLnkgKiA4LjApO1xcbiAgaGlnaHAgdmVjMiB0ZXhQb3MxO1xcbiAgdGV4UG9zMS54ID0gKHF1YWQxLnggKiAwLjEyNSkgKyAwLjUgLyA1MTIuMCArICgoMC4xMjUgLSAxLjAgLyA1MTIuMCkgKiB0ZXh0dXJlQ29sb3Iucik7XFxuICB0ZXhQb3MxLnkgPSAocXVhZDEueSAqIDAuMTI1KSArIDAuNSAvIDUxMi4wICsgKCgwLjEyNSAtIDEuMCAvIDUxMi4wKSAqIHRleHR1cmVDb2xvci5nKTtcXG4gICNpZmRlZiBMVVRfRkxJUF9ZXFxuICB0ZXhQb3MxLnkgPSAxLjAgLSB0ZXhQb3MxLnk7XFxuICAjZW5kaWZcXG4gIGhpZ2hwIHZlYzIgdGV4UG9zMjtcXG4gIHRleFBvczIueCA9IChxdWFkMi54ICogMC4xMjUpICsgMC41IC8gNTEyLjAgKyAoKDAuMTI1IC0gMS4wIC8gNTEyLjApICogdGV4dHVyZUNvbG9yLnIpO1xcbiAgdGV4UG9zMi55ID0gKHF1YWQyLnkgKiAwLjEyNSkgKyAwLjUgLyA1MTIuMCArICgoMC4xMjUgLSAxLjAgLyA1MTIuMCkgKiB0ZXh0dXJlQ29sb3IuZyk7XFxuICAjaWZkZWYgTFVUX0ZMSVBfWVxcbiAgdGV4UG9zMi55ID0gMS4wIC0gdGV4UG9zMi55O1xcbiAgI2VuZGlmXFxuICBsb3dwIHZlYzQgbmV3Q29sb3IxID0gdGV4dHVyZTJEKGxvb2t1cFRhYmxlLCB0ZXhQb3MxKTtcXG4gIGxvd3AgdmVjNCBuZXdDb2xvcjIgPSB0ZXh0dXJlMkQobG9va3VwVGFibGUsIHRleFBvczIpO1xcbiAgbG93cCB2ZWM0IG5ld0NvbG9yID0gbWl4KG5ld0NvbG9yMSwgbmV3Q29sb3IyLCBmcmFjdChibHVlQ29sb3IpKTtcXG4gIHJldHVybiBuZXdDb2xvcjtcXG59XFxudm9pZCBtYWluKCkge1xcbiAgdmVjMyB0ZXhDb2xvciA9IHRleHR1cmUyRCh0RGlmZnVzZSwgdlV2KS5yZ2I7XFxuICBmbG9hdCBsdW1pbmFuY2UgPSBjX3hfbHVtYSh0ZXhDb2xvcik7XFxuICBmbG9hdCBub2lzZU1hcCA9IHNtb290aHN0ZXAobHVtaW5hbmNlLCAwLjUsIDAuMCk7XFxuICB2ZWMyIHRVdiA9IHZVdiArIHRpY2s7XFxuICB2ZWMzIG5vaXNlID0gdmVjMyhhX3hfcmFuZG9tKHRVdiksIGFfeF9yYW5kb20odFV2ICogMS41KSwgYV94X3JhbmRvbSh0VXYgKiAwLjUpKTtcXG4gIHZlYzMgbm9pc2VDb2xvciA9IG1peChub2lzZSwgdmVjMygwLjUpLCBub2lzZU1hcCk7XFxuICB2ZWMzIGNvbG9yID0gbWl4KHRleENvbG9yLCBiX3hfYmxlbmRPdmVybGF5KHRleENvbG9yLCBub2lzZSksIDAuMTUpO1xcbiAgdmVjMyBjb3JyZWN0ZWQgPSBlX3hfbG9va3VwKHZlYzQoY29sb3IsIDEuMCksIHRMb29rdXApLnJnYjtcXG4gIGNvbG9yID0gbWl4KGNvbG9yLCBjb3JyZWN0ZWQsIDAuOSk7XFxuICBnbF9GcmFnQ29sb3IgPSB2ZWM0KGNvbG9yLCAxLjApO1xcbiAgdmVjNCBzY3JhdGNoZXMgPSB0ZXh0dXJlMkQodE92ZXJsYXksIG92ZXJsYXlVVik7XFxuICB2ZWMzIHNjcmF0Y2hCbGVuZCA9IGdsX0ZyYWdDb2xvci5yZ2IgKyBzY3JhdGNoZXMucmdiO1xcbiAgZmxvYXQgY2VudGVyID0gc21vb3Roc3RlcCgwLjAsIDAuNiwgbGVuZ3RoKHZVdiAtIDAuNSkpO1xcbiAgZmxvYXQgZGlydE1hcCA9IHNtb290aHN0ZXAoMC4xLCAwLjQsIGx1bWluYW5jZSAqIGNlbnRlcik7XFxuICBnbF9GcmFnQ29sb3IucmdiID0gbWl4KGdsX0ZyYWdDb2xvci5yZ2IsIHNjcmF0Y2hCbGVuZCwgZGlydE1hcCk7XFxufVwiLCBbe1wibmFtZVwiOlwib3ZlcmxheVJlc29sdXRpb25cIixcInR5cGVcIjpcInZlYzJcIn0se1wibmFtZVwiOlwicmVzb2x1dGlvblwiLFwidHlwZVwiOlwidmVjMlwifSx7XCJuYW1lXCI6XCJ0aWNrXCIsXCJ0eXBlXCI6XCJmbG9hdFwifSx7XCJuYW1lXCI6XCJ0RGlmZnVzZVwiLFwidHlwZVwiOlwic2FtcGxlcjJEXCJ9LHtcIm5hbWVcIjpcInRMb29rdXBcIixcInR5cGVcIjpcInNhbXBsZXIyRFwifSx7XCJuYW1lXCI6XCJ0T3ZlcmxheVwiLFwidHlwZVwiOlwic2FtcGxlcjJEXCJ9XSwgW10pO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9jcmVhdGVcIikoc291cmNlKTsiLCJ2YXIgZ2xzbGlmeSA9IHJlcXVpcmUoXCJnbHNsaWZ5XCIpO1xudmFyIHNvdXJjZSA9IHJlcXVpcmUoXCJnbHNsaWZ5L3NpbXBsZS1hZGFwdGVyLmpzXCIpKFwiXFxuI2RlZmluZSBHTFNMSUZZIDFcXG5cXG52YXJ5aW5nIHZlYzIgdlV2O1xcbnZvaWQgbWFpbigpIHtcXG4gIHZVdiA9IHV2O1xcbiAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNChwb3NpdGlvbiwgMS4wKTtcXG59XCIsIFwiXFxuI2RlZmluZSBHTFNMSUZZIDFcXG5cXG51bmlmb3JtIHNhbXBsZXIyRCB0RGlmZnVzZTtcXG52YXJ5aW5nIHZlYzIgdlV2O1xcbnZvaWQgbWFpbigpIHtcXG4gIGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCh0RGlmZnVzZSwgdlV2KTtcXG59XCIsIFt7XCJuYW1lXCI6XCJ0RGlmZnVzZVwiLFwidHlwZVwiOlwic2FtcGxlcjJEXCJ9XSwgW10pO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9jcmVhdGVcIikoc291cmNlKTsiLCIoZnVuY3Rpb24gKGdsb2JhbCl7XG52YXIgVEhSRUUgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdy5USFJFRSA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwuVEhSRUUgOiBudWxsKVxudmFyIGxpbmVIZWlnaHQgPSAyMlxudmFyIGJpZyA9IDAuN1xudmFyIHNtYWxsID0gMC41XG5cbnZhciBwYW5lbFdpZHRoID0gMjBcbm1vZHVsZS5leHBvcnRzID0gW1xuICAgIFxuICAgIHtcbiAgICAgICAgbmFtZTogJ3Rvbm5lcycsXG4gICAgICAgIHBhbmVsczogWyB7XG4gICAgICAgICAgICAvLyBvcmlnaW46IG5ldyBUSFJFRS5WZWN0b3IzKDE4LCAxMCwgMiksXG4gICAgICAgICAgICBsYWJlbHM6IFtcbiAgICAgICAgICAgICAgICB7IHRleHQ6ICdlYWNoIHllYXIgUnVzc2lhIHNwaWxscycsIHNpemU6IHNtYWxsIH0sXG4gICAgICAgICAgICAgICAgeyB0ZXh0OiAnNSBtaWxsaW9uIHRvbm5lcyBvZiBvaWwnLCBzaXplOiBiaWcsIHRyYW5zbGF0aW9uOiBbLTIsIC1saW5lSGVpZ2h0LCAwXSB9LFxuICAgICAgICAgICAgXVxuICAgICAgICB9LCBcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gb3JpZ2luOiBuZXcgVEhSRUUuVmVjdG9yMygtMjAsIDEwLCAyKSxcbiAgICAgICAgICAgIHdpZHRoOiBwYW5lbFdpZHRoLFxuICAgICAgICAgICAgbGFiZWxzOiBbXG4gICAgICAgICAgICAgICAgeyB0ZXh0OiAnZXhwZWN0ZWQgeWVhcmx5IG91dHB1dCcsIHNpemU6IHNtYWxsIH0sXG4gICAgICAgICAgICAgICAgeyB0ZXh0OiAnNi42IG1pbGxpb24gdG9ubmVzIG9mIG9pbCcsIHNpemU6IGJpZywgdHJhbnNsYXRpb246IFswLCAtbGluZUhlaWdodCwgMF0gfSxcbiAgICAgICAgICAgIF1cbiAgICAgICAgfSBcbiAgICAgICAgXVxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiAndG9wJyxcbiAgICAgICAgcGFuZWxzOiBbIHtcbiAgICAgICAgICAgIGxhYmVsczogW1xuICAgICAgICAgICAgICAgIHsgdGV4dDogJ3RlY2hub2xvZ2ljYWxseSBvYnNvbGV0ZScsIHNpemU6IGJpZyB9LFxuICAgICAgICAgICAgICAgIHsgdGV4dDogJ3BoeXNpY2FsbHkgdW5zYWZlJywgc2l6ZTogc21hbGwsIHRyYW5zbGF0aW9uOiBbMCwgLWxpbmVIZWlnaHQsIDBdIH0sXG4gICAgICAgICAgICBdXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIHdpZHRoOiBwYW5lbFdpZHRoLFxuICAgICAgICAgICAgbGFiZWxzOiBbXG4gICAgICAgICAgICAgICAgeyB0ZXh0OiAnMTggeWVhcnMgdG8gY29uc3RydWN0Jywgc2l6ZTogYmlnIH0sXG4gICAgICAgICAgICAgICAgeyB0ZXh0OiAndXNpbmcgc2Vjb25kaGFuZCBtYXRlcmlhbHMnLCBzaXplOiBzbWFsbCwgdHJhbnNsYXRpb246IFswLCAtbGluZUhlaWdodCwgMF0gfSxcbiAgICAgICAgICAgIF1cbiAgICAgICAgfSBdXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6ICduYXR1cmUnLFxuICAgICAgICBwYW5lbHM6IFsge1xuICAgICAgICAgICAgbGFiZWxzOiBbXG4gICAgICAgICAgICAgICAgeyB0ZXh0OiAnMTZocnMgZm9yIG9pbCBzcGlsbCB0byByZWFjaCcsIHNpemU6IGJpZyB9LFxuICAgICAgICAgICAgICAgIHsgdGV4dDogJ25hdHVyZSByZXNlcnZlIDUwa20gYXdheScsIHNpemU6IHNtYWxsLCB0cmFuc2xhdGlvbjogWzAsIC1saW5lSGVpZ2h0LCAwXSB9LFxuICAgICAgICAgICAgXVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICB3aWR0aDogcGFuZWxXaWR0aCxcbiAgICAgICAgICAgIGxhYmVsczogW1xuICAgICAgICAgICAgICAgIHsgdGV4dDogJ2NydWNpYWwgYnJlZWRpbmcgZ3JvdW5kcycsIHNpemU6IGJpZyB9LFxuICAgICAgICAgICAgICAgIHsgdGV4dDogJ2ZvciB3YWxydXMsIHdoYWxlcyAmIHBvbGFyIGJlYXJzJywgc2l6ZTogc21hbGwsIHRyYW5zbGF0aW9uOiBbMCwgLWxpbmVIZWlnaHQsIDBdIH0sXG4gICAgICAgICAgICBdXG4gICAgICAgIH0gXVxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiAncmVzcG9uc2UnLFxuICAgICAgICBwYW5lbHM6IFsge1xuICAgICAgICAgICAgbGFiZWxzOiBbXG4gICAgICAgICAgICAgICAgeyB0ZXh0OiAnbGFyZ2Ugc2NhbGUgc3BpbGwgZXF1aXBtZW50Jywgc2l6ZTogYmlnIH0sXG4gICAgICAgICAgICAgICAgeyB0ZXh0OiAnMTAwMGttICgzIGRheXMgc2FpbGluZykgYXdheScsIHNpemU6IHNtYWxsLCB0cmFuc2xhdGlvbjogWzAsIC1saW5lSGVpZ2h0LCAwXSB9LFxuICAgICAgICAgICAgXVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICB3aWR0aDogcGFuZWxXaWR0aCoxLjUsXG4gICAgICAgICAgICBsYWJlbHM6IFtcbiAgICAgICAgICAgICAgICB7IHRleHQ6ICdwcmV2aW91cyByZXNwb25zZSBwbGFuIGluY2x1ZGVkJywgc2l6ZTogYmlnIH0sXG4gICAgICAgICAgICAgICAgeyB0ZXh0OiAnMTUgYnVja2V0cyBhbmQgMyBheGVzJywgc2l6ZTogc21hbGwsIHRyYW5zbGF0aW9uOiBbMCwgLWxpbmVIZWlnaHQsIDBdIH0sXG4gICAgICAgICAgICBdXG4gICAgICAgIH0gXVxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiAnc3BpbGwnLFxuICAgICAgICBwYW5lbHM6IFsge1xuICAgICAgICAgICAgbGFiZWxzOiBbXG4gICAgICAgICAgICAgICAgeyB0ZXh0OiAnaW1wb3NzaWJsZSB0byBjbGVhbiB1cCcsIHNpemU6IGJpZyB9LFxuICAgICAgICAgICAgICAgIHsgdGV4dDogJ2FuIGFyY3RpYyBvaWwgc3BpbGwnLCBzaXplOiBzbWFsbCwgdHJhbnNsYXRpb246IFswLCAtbGluZUhlaWdodCwgMF0gfSxcbiAgICAgICAgICAgIF1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgd2lkdGg6IHBhbmVsV2lkdGgsXG4gICAgICAgICAgICBsYWJlbHM6IFtcbiAgICAgICAgICAgICAgICB7IHRleHQ6ICdvaWwgc3BpbGxzIGFyZSBpbmV2aXRhYmxlJywgc2l6ZTogYmlnIH0sXG4gICAgICAgICAgICAgICAgeyB0ZXh0OiAncmVzcG9uc2UgcGxhbiBub3QgcHVibGljJywgc2l6ZTogc21hbGwsIHRyYW5zbGF0aW9uOiBbMCwgLWxpbmVIZWlnaHQsIDBdIH0sXG4gICAgICAgICAgICBdXG4gICAgICAgIH0gXVxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiAnd2VhdGhlcicsXG4gICAgICAgIHBhbmVsczogWyB7XG4gICAgICAgICAgICBsYWJlbHM6IFtcbiAgICAgICAgICAgICAgICB7IHRleHQ6ICdhcyBjb2xkIGFzIC01MGMgLyAxMjJmJywgc2l6ZTogYmlnIH0sXG4gICAgICAgICAgICAgICAgeyB0ZXh0OiAnaWNlZCBpbiA4IG1vbnRocyBwZXIgeWVhcicsIHNpemU6IHNtYWxsLCB0cmFuc2xhdGlvbjogWzAsIC1saW5lSGVpZ2h0LCAwXSB9LFxuICAgICAgICAgICAgXVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICB3aWR0aDogcGFuZWxXaWR0aCxcbiAgICAgICAgICAgIGxhYmVsczogW1xuICAgICAgICAgICAgICAgIHsgdGV4dDogJ3BsYWd1ZWQgYnkgYmFkIHdlYXRoZXInLCBzaXplOiBiaWcgfSxcbiAgICAgICAgICAgICAgICB7IHRleHQ6ICd3YXZlcyByZWFjaCB1cCB0byAxMm0nLCBzaXplOiBzbWFsbCwgdHJhbnNsYXRpb246IFswLCAtbGluZUhlaWdodCwgMF0gfSxcbiAgICAgICAgICAgIF1cbiAgICAgICAgfSBdXG4gICAgfSxcbl1cblxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pIiwiKGZ1bmN0aW9uIChnbG9iYWwpe1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIFR3ZWVuTWF4ID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cuVHdlZW5NYXggOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsLlR3ZWVuTWF4IDogbnVsbClcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihUSFJFRSkge1xuICAgIGlmICghVEhSRUUuTU9VU0UpXG4gICAgICAgIFRIUkVFLk1PVVNFID0geyBMRUZUOiAwLCBNSURETEU6IDEsIFJJR0hUOiAyIH07XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIHFpYW8gLyBodHRwczovL2dpdGh1Yi5jb20vcWlhb1xuICAgICAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb21cbiAgICAgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICAgICAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxuICAgICAqIEBhdXRob3IgZXJpY2g2NjYgLyBodHRwOi8vZXJpY2hhaW5lcy5jb21cbiAgICAgKi9cbiAgICAvKmdsb2JhbCBUSFJFRSwgY29uc29sZSAqL1xuXG4gICAgLy8gVGhpcyBzZXQgb2YgY29udHJvbHMgcGVyZm9ybXMgb3JiaXRpbmcsIGRvbGx5aW5nICh6b29taW5nKSwgYW5kIHBhbm5pbmcuIEl0IG1haW50YWluc1xuICAgIC8vIHRoZSBcInVwXCIgZGlyZWN0aW9uIGFzICtZLCB1bmxpa2UgdGhlIFRyYWNrYmFsbENvbnRyb2xzLiBUb3VjaCBvbiB0YWJsZXQgYW5kIHBob25lcyBpc1xuICAgIC8vIHN1cHBvcnRlZC5cbiAgICAvL1xuICAgIC8vICAgIE9yYml0IC0gbGVmdCBtb3VzZSAvIHRvdWNoOiBvbmUgZmluZ2VyIG1vdmVcbiAgICAvLyAgICBab29tIC0gbWlkZGxlIG1vdXNlLCBvciBtb3VzZXdoZWVsIC8gdG91Y2g6IHR3byBmaW5nZXIgc3ByZWFkIG9yIHNxdWlzaFxuICAgIC8vICAgIFBhbiAtIHJpZ2h0IG1vdXNlLCBvciBhcnJvdyBrZXlzIC8gdG91Y2g6IHRocmVlIGZpbnRlciBzd2lwZVxuICAgIC8vXG4gICAgLy8gVGhpcyBpcyBhIGRyb3AtaW4gcmVwbGFjZW1lbnQgZm9yIChtb3N0KSBUcmFja2JhbGxDb250cm9scyB1c2VkIGluIGV4YW1wbGVzLlxuICAgIC8vIFRoYXQgaXMsIGluY2x1ZGUgdGhpcyBqcyBmaWxlIGFuZCB3aGVyZXZlciB5b3Ugc2VlOlxuICAgIC8vICAgICAgY29udHJvbHMgPSBuZXcgVEhSRUUuVHJhY2tiYWxsQ29udHJvbHMoIGNhbWVyYSApO1xuICAgIC8vICAgICAgY29udHJvbHMudGFyZ2V0LnogPSAxNTA7XG4gICAgLy8gU2ltcGxlIHN1YnN0aXR1dGUgXCJPcmJpdENvbnRyb2xzXCIgYW5kIHRoZSBjb250cm9sIHNob3VsZCB3b3JrIGFzLWlzLlxuXG4gICAgZnVuY3Rpb24gT3JiaXRDb250cm9scyggb2JqZWN0LCBkb21FbGVtZW50ICkge1xuXG4gICAgICAgIHRoaXMub2JqZWN0ID0gb2JqZWN0O1xuICAgICAgICB0aGlzLmRvbUVsZW1lbnQgPSAoIGRvbUVsZW1lbnQgIT09IHVuZGVmaW5lZCApID8gZG9tRWxlbWVudCA6IGRvY3VtZW50O1xuXG4gICAgICAgIC8vIEFQSVxuXG4gICAgICAgIC8vIFNldCB0byBmYWxzZSB0byBkaXNhYmxlIHRoaXMgY29udHJvbFxuICAgICAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xuXG4gICAgICAgIC8vIFwidGFyZ2V0XCIgc2V0cyB0aGUgbG9jYXRpb24gb2YgZm9jdXMsIHdoZXJlIHRoZSBjb250cm9sIG9yYml0cyBhcm91bmRcbiAgICAgICAgLy8gYW5kIHdoZXJlIGl0IHBhbnMgd2l0aCByZXNwZWN0IHRvLlxuICAgICAgICB0aGlzLnRhcmdldCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICAgICAgLy8gY2VudGVyIGlzIG9sZCwgZGVwcmVjYXRlZDsgdXNlIFwidGFyZ2V0XCIgaW5zdGVhZFxuICAgICAgICB0aGlzLmNlbnRlciA9IHRoaXMudGFyZ2V0O1xuXG4gICAgICAgIC8vIFRoaXMgb3B0aW9uIGFjdHVhbGx5IGVuYWJsZXMgZG9sbHlpbmcgaW4gYW5kIG91dDsgbGVmdCBhcyBcInpvb21cIiBmb3JcbiAgICAgICAgLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgICAgICAgdGhpcy5ub1pvb20gPSBmYWxzZTtcbiAgICAgICAgdGhpcy56b29tU3BlZWQgPSAxLjA7XG5cbiAgICAgICAgLy8gTGltaXRzIHRvIGhvdyBmYXIgeW91IGNhbiBkb2xseSBpbiBhbmQgb3V0XG4gICAgICAgIHRoaXMubWluRGlzdGFuY2UgPSAwO1xuICAgICAgICB0aGlzLm1heERpc3RhbmNlID0gSW5maW5pdHk7XG5cbiAgICAgICAgLy8gU2V0IHRvIHRydWUgdG8gZGlzYWJsZSB0aGlzIGNvbnRyb2xcbiAgICAgICAgdGhpcy5ub1JvdGF0ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnJvdGF0ZVNwZWVkID0gMS4wO1xuXG4gICAgICAgIC8vIFNldCB0byB0cnVlIHRvIGRpc2FibGUgdGhpcyBjb250cm9sXG4gICAgICAgIHRoaXMubm9QYW4gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5rZXlQYW5TcGVlZCA9IDcuMDsgLy8gcGl4ZWxzIG1vdmVkIHBlciBhcnJvdyBrZXkgcHVzaFxuXG4gICAgICAgIC8vIFNldCB0byB0cnVlIHRvIGF1dG9tYXRpY2FsbHkgcm90YXRlIGFyb3VuZCB0aGUgdGFyZ2V0XG4gICAgICAgIHRoaXMuYXV0b1JvdGF0ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmF1dG9Sb3RhdGVTcGVlZCA9IDIuMDsgLy8gMzAgc2Vjb25kcyBwZXIgcm91bmQgd2hlbiBmcHMgaXMgNjBcblxuICAgICAgICAvLyBIb3cgZmFyIHlvdSBjYW4gb3JiaXQgdmVydGljYWxseSwgdXBwZXIgYW5kIGxvd2VyIGxpbWl0cy5cbiAgICAgICAgLy8gUmFuZ2UgaXMgMCB0byBNYXRoLlBJIHJhZGlhbnMuXG4gICAgICAgIHRoaXMubWluUG9sYXJBbmdsZSA9IDA7IC8vIHJhZGlhbnNcbiAgICAgICAgdGhpcy5tYXhQb2xhckFuZ2xlID0gTWF0aC5QSTsgLy8gcmFkaWFuc1xuXG4gICAgICAgIC8vIFNldCB0byB0cnVlIHRvIGRpc2FibGUgdXNlIG9mIHRoZSBrZXlzXG4gICAgICAgIHRoaXMubm9LZXlzID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5waGkgPSAwXG4gICAgICAgIHRoaXMudGhldGEgPSAwIFxuXG4gICAgICAgIC8vIFRoZSBmb3VyIGFycm93IGtleXNcbiAgICAgICAgdGhpcy5rZXlzID0geyBMRUZUOiAzNywgVVA6IDM4LCBSSUdIVDogMzksIEJPVFRPTTogNDAgfTtcblxuICAgICAgICB0aGlzLmNvbnN0cmFpbkRlbHRhID0geyB4OiAwLCB5OiAwIH07XG5cbiAgICAgICAgLy8vLy8vLy8vLy8vXG4gICAgICAgIC8vIGludGVybmFsc1xuXG4gICAgICAgIHZhciBzY29wZSA9IHRoaXM7XG5cbiAgICAgICAgdmFyIEVQUyA9IDAuMDAwMDAxO1xuXG4gICAgICAgIHZhciByb3RhdGVTdGFydCA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG4gICAgICAgIHZhciByb3RhdGVFbmQgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xuICAgICAgICB2YXIgcm90YXRlRGVsdGEgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xuXG4gICAgICAgIHZhciBwYW5TdGFydCA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG4gICAgICAgIHZhciBwYW5FbmQgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xuICAgICAgICB2YXIgcGFuRGVsdGEgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xuICAgICAgICB2YXIgcGFuT2Zmc2V0ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgICAgICB2YXIgb2Zmc2V0ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgICAgICB2YXIgZG9sbHlTdGFydCA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG4gICAgICAgIHZhciBkb2xseUVuZCA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG4gICAgICAgIHZhciBkb2xseURlbHRhID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcblxuICAgICAgICB2YXIgcGhpRGVsdGEgPSAwO1xuICAgICAgICB2YXIgdGhldGFEZWx0YSA9IDA7XG4gICAgICAgIHZhciBzY2FsZSA9IDE7XG4gICAgICAgIHZhciBwYW4gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgICAgIHZhciBsYXN0UG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgICAgIHZhciBTVEFURSA9IHsgTk9ORSA6IC0xLCBST1RBVEUgOiAwLCBET0xMWSA6IDEsIFBBTiA6IDIsIFRPVUNIX1JPVEFURSA6IDMsIFRPVUNIX0RPTExZIDogNCwgVE9VQ0hfUEFOIDogNSB9O1xuXG4gICAgICAgIHZhciBzdGF0ZSA9IFNUQVRFLk5PTkU7XG5cbiAgICAgICAgLy8gZm9yIHJlc2V0XG5cbiAgICAgICAgdGhpcy50YXJnZXQwID0gdGhpcy50YXJnZXQuY2xvbmUoKTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbjAgPSB0aGlzLm9iamVjdC5wb3NpdGlvbi5jbG9uZSgpO1xuXG4gICAgICAgIC8vIHNvIGNhbWVyYS51cCBpcyB0aGUgb3JiaXQgYXhpc1xuXG4gICAgICAgIHZhciBxdWF0ID0gbmV3IFRIUkVFLlF1YXRlcm5pb24oKS5zZXRGcm9tVW5pdFZlY3RvcnMoIG9iamVjdC51cCwgbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDEsIDAgKSApO1xuICAgICAgICB2YXIgcXVhdEludmVyc2UgPSBxdWF0LmNsb25lKCkuaW52ZXJzZSgpO1xuXG4gICAgICAgIC8vIGV2ZW50c1xuXG4gICAgICAgIHZhciBjaGFuZ2VFdmVudCA9IHsgdHlwZTogJ2NoYW5nZScgfTtcbiAgICAgICAgdmFyIHN0YXJ0RXZlbnQgPSB7IHR5cGU6ICdzdGFydCd9O1xuICAgICAgICB2YXIgZW5kRXZlbnQgPSB7IHR5cGU6ICdlbmQnfTtcblxuICAgICAgICB0aGlzLnJvdGF0ZUxlZnQgPSBmdW5jdGlvbiAoIGFuZ2xlICkge1xuXG4gICAgICAgICAgICBpZiAoIGFuZ2xlID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgICAgICBhbmdsZSA9IGdldEF1dG9Sb3RhdGlvbkFuZ2xlKCk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhldGFEZWx0YSAtPSBhbmdsZTtcblxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMucm90YXRlVXAgPSBmdW5jdGlvbiAoIGFuZ2xlICkge1xuXG4gICAgICAgICAgICBpZiAoIGFuZ2xlID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgICAgICBhbmdsZSA9IGdldEF1dG9Sb3RhdGlvbkFuZ2xlKCk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcGhpRGVsdGEgLT0gYW5nbGU7XG5cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBwYXNzIGluIGRpc3RhbmNlIGluIHdvcmxkIHNwYWNlIHRvIG1vdmUgbGVmdFxuICAgICAgICB0aGlzLnBhbkxlZnQgPSBmdW5jdGlvbiAoIGRpc3RhbmNlICkge1xuXG4gICAgICAgICAgICB2YXIgdGUgPSB0aGlzLm9iamVjdC5tYXRyaXguZWxlbWVudHM7XG5cbiAgICAgICAgICAgIC8vIGdldCBYIGNvbHVtbiBvZiBtYXRyaXhcbiAgICAgICAgICAgIHBhbk9mZnNldC5zZXQoIHRlWyAwIF0sIHRlWyAxIF0sIHRlWyAyIF0gKTtcbiAgICAgICAgICAgIHBhbk9mZnNldC5tdWx0aXBseVNjYWxhciggLSBkaXN0YW5jZSApO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBwYW4uYWRkKCBwYW5PZmZzZXQgKTtcblxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIHBhc3MgaW4gZGlzdGFuY2UgaW4gd29ybGQgc3BhY2UgdG8gbW92ZSB1cFxuICAgICAgICB0aGlzLnBhblVwID0gZnVuY3Rpb24gKCBkaXN0YW5jZSApIHtcblxuICAgICAgICAgICAgdmFyIHRlID0gdGhpcy5vYmplY3QubWF0cml4LmVsZW1lbnRzO1xuXG4gICAgICAgICAgICAvLyBnZXQgWSBjb2x1bW4gb2YgbWF0cml4XG4gICAgICAgICAgICBwYW5PZmZzZXQuc2V0KCB0ZVsgNCBdLCB0ZVsgNSBdLCB0ZVsgNiBdICk7XG4gICAgICAgICAgICBwYW5PZmZzZXQubXVsdGlwbHlTY2FsYXIoIGRpc3RhbmNlICk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHBhbi5hZGQoIHBhbk9mZnNldCApO1xuXG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICAvLyBwYXNzIGluIHgseSBvZiBjaGFuZ2UgZGVzaXJlZCBpbiBwaXhlbCBzcGFjZSxcbiAgICAgICAgLy8gcmlnaHQgYW5kIGRvd24gYXJlIHBvc2l0aXZlXG4gICAgICAgIHRoaXMucGFuID0gZnVuY3Rpb24gKCBkZWx0YVgsIGRlbHRhWSApIHtcblxuICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBzY29wZS5kb21FbGVtZW50ID09PSBkb2N1bWVudCA/IHNjb3BlLmRvbUVsZW1lbnQuYm9keSA6IHNjb3BlLmRvbUVsZW1lbnQ7XG5cbiAgICAgICAgICAgIGlmICggc2NvcGUub2JqZWN0LmZvdiAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgLy8gcGVyc3BlY3RpdmVcbiAgICAgICAgICAgICAgICB2YXIgcG9zaXRpb24gPSBzY29wZS5vYmplY3QucG9zaXRpb247XG4gICAgICAgICAgICAgICAgdmFyIG9mZnNldCA9IHBvc2l0aW9uLmNsb25lKCkuc3ViKCBzY29wZS50YXJnZXQgKTtcbiAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0RGlzdGFuY2UgPSBvZmZzZXQubGVuZ3RoKCk7XG5cbiAgICAgICAgICAgICAgICAvLyBoYWxmIG9mIHRoZSBmb3YgaXMgY2VudGVyIHRvIHRvcCBvZiBzY3JlZW5cbiAgICAgICAgICAgICAgICB0YXJnZXREaXN0YW5jZSAqPSBNYXRoLnRhbiggKCBzY29wZS5vYmplY3QuZm92IC8gMiApICogTWF0aC5QSSAvIDE4MC4wICk7XG5cbiAgICAgICAgICAgICAgICAvLyB3ZSBhY3R1YWxseSBkb24ndCB1c2Ugc2NyZWVuV2lkdGgsIHNpbmNlIHBlcnNwZWN0aXZlIGNhbWVyYSBpcyBmaXhlZCB0byBzY3JlZW4gaGVpZ2h0XG4gICAgICAgICAgICAgICAgc2NvcGUucGFuTGVmdCggMiAqIGRlbHRhWCAqIHRhcmdldERpc3RhbmNlIC8gZWxlbWVudC5jbGllbnRIZWlnaHQgKTtcbiAgICAgICAgICAgICAgICBzY29wZS5wYW5VcCggMiAqIGRlbHRhWSAqIHRhcmdldERpc3RhbmNlIC8gZWxlbWVudC5jbGllbnRIZWlnaHQgKTtcblxuICAgICAgICAgICAgfSBlbHNlIGlmICggc2NvcGUub2JqZWN0LnRvcCAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgLy8gb3J0aG9ncmFwaGljXG4gICAgICAgICAgICAgICAgc2NvcGUucGFuTGVmdCggZGVsdGFYICogKHNjb3BlLm9iamVjdC5yaWdodCAtIHNjb3BlLm9iamVjdC5sZWZ0KSAvIGVsZW1lbnQuY2xpZW50V2lkdGggKTtcbiAgICAgICAgICAgICAgICBzY29wZS5wYW5VcCggZGVsdGFZICogKHNjb3BlLm9iamVjdC50b3AgLSBzY29wZS5vYmplY3QuYm90dG9tKSAvIGVsZW1lbnQuY2xpZW50SGVpZ2h0ICk7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAvLyBjYW1lcmEgbmVpdGhlciBvcnRob2dyYXBoaWMgb3IgcGVyc3BlY3RpdmVcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oICdXQVJOSU5HOiBPcmJpdENvbnRyb2xzLmpzIGVuY291bnRlcmVkIGFuIHVua25vd24gY2FtZXJhIHR5cGUgLSBwYW4gZGlzYWJsZWQuJyApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmRvbGx5SW4gPSBmdW5jdGlvbiAoIGRvbGx5U2NhbGUgKSB7XG5cbiAgICAgICAgICAgIGlmICggZG9sbHlTY2FsZSA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgZG9sbHlTY2FsZSA9IGdldFpvb21TY2FsZSgpO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNjYWxlIC89IGRvbGx5U2NhbGU7XG5cbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmRvbGx5T3V0ID0gZnVuY3Rpb24gKCBkb2xseVNjYWxlICkge1xuXG4gICAgICAgICAgICBpZiAoIGRvbGx5U2NhbGUgPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgIGRvbGx5U2NhbGUgPSBnZXRab29tU2NhbGUoKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzY2FsZSAqPSBkb2xseVNjYWxlO1xuXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIHZhciBwb3NpdGlvbiA9IHRoaXMub2JqZWN0LnBvc2l0aW9uO1xuXG4gICAgICAgICAgICAvLyAvLyByb3RhdGluZyBhY3Jvc3Mgd2hvbGUgc2NyZWVuIGdvZXMgMzYwIGRlZ3JlZXMgYXJvdW5kXG4gICAgICAgICAgICBzY29wZS5yb3RhdGVMZWZ0KCAyICogTWF0aC5QSSAqIHNjb3BlLmNvbnN0cmFpbkRlbHRhLnggLyB3aW5kb3cuaW5uZXJXaWR0aCAqIHNjb3BlLnJvdGF0ZVNwZWVkICk7XG5cbiAgICAgICAgICAgIC8vIC8vIHJvdGF0aW5nIHVwIGFuZCBkb3duIGFsb25nIHdob2xlIHNjcmVlbiBhdHRlbXB0cyB0byBnbyAzNjAsIGJ1dCBsaW1pdGVkIHRvIDE4MFxuICAgICAgICAgICAgc2NvcGUucm90YXRlVXAoIDIgKiBNYXRoLlBJICogc2NvcGUuY29uc3RyYWluRGVsdGEueSAvIHdpbmRvdy5pbm5lckhlaWdodCAqIHNjb3BlLnJvdGF0ZVNwZWVkICk7XG5cbiAgICAgICAgICAgIG9mZnNldC5jb3B5KCBwb3NpdGlvbiApLnN1YiggdGhpcy50YXJnZXQgKTtcblxuICAgICAgICAgICAgLy8gcm90YXRlIG9mZnNldCB0byBcInktYXhpcy1pcy11cFwiIHNwYWNlXG4gICAgICAgICAgICBvZmZzZXQuYXBwbHlRdWF0ZXJuaW9uKCBxdWF0ICk7XG5cbiAgICAgICAgICAgIC8vIGFuZ2xlIGZyb20gei1heGlzIGFyb3VuZCB5LWF4aXNcblxuICAgICAgICAgICAgdmFyIHRoZXRhID0gTWF0aC5hdGFuMiggb2Zmc2V0LngsIG9mZnNldC56ICk7XG5cbiAgICAgICAgICAgIC8vIGFuZ2xlIGZyb20geS1heGlzXG5cbiAgICAgICAgICAgIHZhciBwaGkgPSBNYXRoLmF0YW4yKCBNYXRoLnNxcnQoIG9mZnNldC54ICogb2Zmc2V0LnggKyBvZmZzZXQueiAqIG9mZnNldC56ICksIG9mZnNldC55ICk7XG5cbiAgICAgICAgICAgIGlmICggdGhpcy5hdXRvUm90YXRlICkge1xuXG4gICAgICAgICAgICAgICAgdGhpcy5yb3RhdGVMZWZ0KCBnZXRBdXRvUm90YXRpb25BbmdsZSgpICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhldGEgKz0gdGhldGFEZWx0YTtcbiAgICAgICAgICAgIHBoaSArPSBwaGlEZWx0YTtcblxuICAgICAgICAgICAgLy8gcmVzdHJpY3QgcGhpIHRvIGJlIGJldHdlZW4gZGVzaXJlZCBsaW1pdHNcbiAgICAgICAgICAgIHBoaSA9IE1hdGgubWF4KCB0aGlzLm1pblBvbGFyQW5nbGUsIE1hdGgubWluKCB0aGlzLm1heFBvbGFyQW5nbGUsIHBoaSApICk7XG5cbiAgICAgICAgICAgIC8vIHJlc3RyaWN0IHBoaSB0byBiZSBiZXR3ZWUgRVBTIGFuZCBQSS1FUFNcbiAgICAgICAgICAgIHBoaSA9IE1hdGgubWF4KCBFUFMsIE1hdGgubWluKCBNYXRoLlBJIC0gRVBTLCBwaGkgKSApO1xuXG4gICAgICAgICAgICB2YXIgcmFkaXVzID0gb2Zmc2V0Lmxlbmd0aCgpICogc2NhbGU7XG5cbiAgICAgICAgICAgIC8vIHJlc3RyaWN0IHJhZGl1cyB0byBiZSBiZXR3ZWVuIGRlc2lyZWQgbGltaXRzXG4gICAgICAgICAgICByYWRpdXMgPSBNYXRoLm1heCggdGhpcy5taW5EaXN0YW5jZSwgTWF0aC5taW4oIHRoaXMubWF4RGlzdGFuY2UsIHJhZGl1cyApICk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIG1vdmUgdGFyZ2V0IHRvIHBhbm5lZCBsb2NhdGlvblxuICAgICAgICAgICAgdGhpcy50YXJnZXQuYWRkKCBwYW4gKTtcblxuICAgICAgICAgICAgc2NvcGUucGhpID0gcGhpXG4gICAgICAgICAgICBzY29wZS50aGV0YSA9IHRoZXRhXG5cbiAgICAgICAgICAgIG9mZnNldC54ID0gcmFkaXVzICogTWF0aC5zaW4oIHBoaSApICogTWF0aC5zaW4oIHRoZXRhICk7XG4gICAgICAgICAgICBvZmZzZXQueSA9IHJhZGl1cyAqIE1hdGguY29zKCBwaGkgKTtcbiAgICAgICAgICAgIG9mZnNldC56ID0gcmFkaXVzICogTWF0aC5zaW4oIHBoaSApICogTWF0aC5jb3MoIHRoZXRhICk7XG5cbiAgICAgICAgICAgIC8vIHJvdGF0ZSBvZmZzZXQgYmFjayB0byBcImNhbWVyYS11cC12ZWN0b3ItaXMtdXBcIiBzcGFjZVxuICAgICAgICAgICAgb2Zmc2V0LmFwcGx5UXVhdGVybmlvbiggcXVhdEludmVyc2UgKTtcblxuICAgICAgICAgICAgcG9zaXRpb24uY29weSggdGhpcy50YXJnZXQgKS5hZGQoIG9mZnNldCApO1xuXG4gICAgICAgICAgICB0aGlzLm9iamVjdC5sb29rQXQoIHRoaXMudGFyZ2V0ICk7XG5cbiAgICAgICAgICAgIHRoZXRhRGVsdGEgPSAwO1xuICAgICAgICAgICAgcGhpRGVsdGEgPSAwO1xuICAgICAgICAgICAgc2NhbGUgPSAxO1xuICAgICAgICAgICAgcGFuLnNldCggMCwgMCwgMCApO1xuXG4gICAgICAgICAgICBpZiAoIGxhc3RQb3NpdGlvbi5kaXN0YW5jZVRvU3F1YXJlZCggdGhpcy5vYmplY3QucG9zaXRpb24gKSA+IEVQUyApIHtcblxuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudCggY2hhbmdlRXZlbnQgKTtcblxuICAgICAgICAgICAgICAgIGxhc3RQb3NpdGlvbi5jb3B5KCB0aGlzLm9iamVjdC5wb3NpdGlvbiApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfTtcblxuXG4gICAgICAgIHRoaXMucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIHN0YXRlID0gU1RBVEUuTk9ORTtcblxuICAgICAgICAgICAgdGhpcy50YXJnZXQuY29weSggdGhpcy50YXJnZXQwICk7XG4gICAgICAgICAgICB0aGlzLm9iamVjdC5wb3NpdGlvbi5jb3B5KCB0aGlzLnBvc2l0aW9uMCApO1xuXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuXG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0QXV0b1JvdGF0aW9uQW5nbGUoKSB7XG5cbiAgICAgICAgICAgIHJldHVybiAyICogTWF0aC5QSSAvIDYwIC8gNjAgKiBzY29wZS5hdXRvUm90YXRlU3BlZWQ7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdldFpvb21TY2FsZSgpIHtcblxuICAgICAgICAgICAgcmV0dXJuIE1hdGgucG93KCAwLjk1LCBzY29wZS56b29tU3BlZWQgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gb25Nb3VzZURvd24oIGV2ZW50ICkge1xuXG4gICAgICAgICAgICBpZiAoIHNjb3BlLmVuYWJsZWQgPT09IGZhbHNlICkgcmV0dXJuO1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgICAgaWYgKCBldmVudC5idXR0b24gPT09IDAgKSB7XG4gICAgICAgICAgICAgICAgaWYgKCBzY29wZS5ub1JvdGF0ZSA9PT0gdHJ1ZSApIHJldHVybjtcblxuICAgICAgICAgICAgICAgIHN0YXRlID0gU1RBVEUuUk9UQVRFO1xuXG4gICAgICAgICAgICAgICAgcm90YXRlU3RhcnQuc2V0KCBldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZICk7XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIGV2ZW50LmJ1dHRvbiA9PT0gMSApIHtcbiAgICAgICAgICAgICAgICBpZiAoIHNjb3BlLm5vWm9vbSA9PT0gdHJ1ZSApIHJldHVybjtcblxuICAgICAgICAgICAgICAgIHN0YXRlID0gU1RBVEUuRE9MTFk7XG5cbiAgICAgICAgICAgICAgICBkb2xseVN0YXJ0LnNldCggZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSApO1xuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCBldmVudC5idXR0b24gPT09IDIgKSB7XG4gICAgICAgICAgICAgICAgaWYgKCBzY29wZS5ub1BhbiA9PT0gdHJ1ZSApIHJldHVybjtcblxuICAgICAgICAgICAgICAgIHN0YXRlID0gU1RBVEUuUEFOO1xuXG4gICAgICAgICAgICAgICAgcGFuU3RhcnQuc2V0KCBldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2NvcGUuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCAnbW91c2Vtb3ZlJywgb25Nb3VzZU1vdmUsIGZhbHNlICk7XG4gICAgICAgICAgICBzY29wZS5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoICdtb3VzZXVwJywgb25Nb3VzZVVwLCBmYWxzZSApO1xuICAgICAgICAgICAgc2NvcGUuZGlzcGF0Y2hFdmVudCggc3RhcnRFdmVudCApO1xuXG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBvbk1vdXNlTW92ZSggZXZlbnQgKSB7XG5cbiAgICAgICAgICAgIGlmICggc2NvcGUuZW5hYmxlZCA9PT0gZmFsc2UgKSByZXR1cm47XG5cbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICAgIHZhciBlbGVtZW50ID0gc2NvcGUuZG9tRWxlbWVudCA9PT0gZG9jdW1lbnQgPyBzY29wZS5kb21FbGVtZW50LmJvZHkgOiBzY29wZS5kb21FbGVtZW50O1xuXG4gICAgICAgICAgICBpZiAoIHN0YXRlID09PSBTVEFURS5ST1RBVEUgKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoIHNjb3BlLm5vUm90YXRlID09PSB0cnVlICkgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgcm90YXRlRW5kLnNldCggZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSApO1xuICAgICAgICAgICAgICAgIHJvdGF0ZURlbHRhLnN1YlZlY3RvcnMoIHJvdGF0ZUVuZCwgcm90YXRlU3RhcnQgKTtcblxuICAgICAgICAgICAgICAgIHNjb3BlLmNvbnN0cmFpbkRlbHRhLnggPSByb3RhdGVEZWx0YS54O1xuICAgICAgICAgICAgICAgIHNjb3BlLmNvbnN0cmFpbkRlbHRhLnkgPSByb3RhdGVEZWx0YS55O1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIFR3ZWVuTWF4LmtpbGxUd2VlbnNPZihzY29wZS5jb25zdHJhaW5EZWx0YSk7XG4gICAgICAgICAgICAgICAgVHdlZW5NYXgudG8oc2NvcGUuY29uc3RyYWluRGVsdGEsIDAuNTAsIHtcbiAgICAgICAgICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgICAgICAgICAgeTogMCxcbiAgICAgICAgICAgICAgICAgICAgZWFzZTogJ2Vhc2VPdXRRdWFkJyxcbiAgICAgICAgICAgICAgICAgICAgZGVsYXk6IDAuMFxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgcm90YXRlU3RhcnQuY29weSggcm90YXRlRW5kICk7XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIHN0YXRlID09PSBTVEFURS5ET0xMWSApIHtcblxuICAgICAgICAgICAgICAgIGlmICggc2NvcGUubm9ab29tID09PSB0cnVlICkgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgZG9sbHlFbmQuc2V0KCBldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZICk7XG4gICAgICAgICAgICAgICAgZG9sbHlEZWx0YS5zdWJWZWN0b3JzKCBkb2xseUVuZCwgZG9sbHlTdGFydCApO1xuXG4gICAgICAgICAgICAgICAgaWYgKCBkb2xseURlbHRhLnkgPiAwICkge1xuXG4gICAgICAgICAgICAgICAgICAgIHNjb3BlLmRvbGx5SW4oKTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgc2NvcGUuZG9sbHlPdXQoKTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGRvbGx5U3RhcnQuY29weSggZG9sbHlFbmQgKTtcblxuICAgICAgICAgICAgfSBlbHNlIGlmICggc3RhdGUgPT09IFNUQVRFLlBBTiApIHtcblxuICAgICAgICAgICAgICAgIGlmICggc2NvcGUubm9QYW4gPT09IHRydWUgKSByZXR1cm47XG5cbiAgICAgICAgICAgICAgICBwYW5FbmQuc2V0KCBldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZICk7XG4gICAgICAgICAgICAgICAgcGFuRGVsdGEuc3ViVmVjdG9ycyggcGFuRW5kLCBwYW5TdGFydCApO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHNjb3BlLnBhbiggcGFuRGVsdGEueCwgcGFuRGVsdGEueSApO1xuXG4gICAgICAgICAgICAgICAgcGFuU3RhcnQuY29weSggcGFuRW5kICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2NvcGUudXBkYXRlKCk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIG9uTW91c2VVcCggLyogZXZlbnQgKi8gKSB7XG5cbiAgICAgICAgICAgIGlmICggc2NvcGUuZW5hYmxlZCA9PT0gZmFsc2UgKSByZXR1cm47XG5cbiAgICAgICAgICAgIHNjb3BlLmRvbUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ21vdXNlbW92ZScsIG9uTW91c2VNb3ZlLCBmYWxzZSApO1xuICAgICAgICAgICAgc2NvcGUuZG9tRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCAnbW91c2V1cCcsIG9uTW91c2VVcCwgZmFsc2UgKTtcbiAgICAgICAgICAgIHNjb3BlLmRpc3BhdGNoRXZlbnQoIGVuZEV2ZW50ICk7XG4gICAgICAgICAgICBzdGF0ZSA9IFNUQVRFLk5PTkU7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIG9uTW91c2VXaGVlbCggZXZlbnQgKSB7XG5cbiAgICAgICAgICAgIGlmICggc2NvcGUuZW5hYmxlZCA9PT0gZmFsc2UgfHwgc2NvcGUubm9ab29tID09PSB0cnVlICkgcmV0dXJuO1xuXG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICAgICAgICAgIHZhciBkZWx0YSA9IDA7XG5cbiAgICAgICAgICAgIGlmICggZXZlbnQud2hlZWxEZWx0YSAhPT0gdW5kZWZpbmVkICkgeyAvLyBXZWJLaXQgLyBPcGVyYSAvIEV4cGxvcmVyIDlcblxuICAgICAgICAgICAgICAgIGRlbHRhID0gZXZlbnQud2hlZWxEZWx0YTtcblxuICAgICAgICAgICAgfSBlbHNlIGlmICggZXZlbnQuZGV0YWlsICE9PSB1bmRlZmluZWQgKSB7IC8vIEZpcmVmb3hcblxuICAgICAgICAgICAgICAgIGRlbHRhID0gLSBldmVudC5kZXRhaWw7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCBkZWx0YSA+IDAgKSB7XG5cbiAgICAgICAgICAgICAgICBzY29wZS5kb2xseU91dCgpO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgc2NvcGUuZG9sbHlJbigpO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNjb3BlLnVwZGF0ZSgpO1xuICAgICAgICAgICAgc2NvcGUuZGlzcGF0Y2hFdmVudCggc3RhcnRFdmVudCApO1xuICAgICAgICAgICAgc2NvcGUuZGlzcGF0Y2hFdmVudCggZW5kRXZlbnQgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gb25LZXlEb3duKCBldmVudCApIHtcblxuICAgICAgICAgICAgaWYgKCBzY29wZS5lbmFibGVkID09PSBmYWxzZSB8fCBzY29wZS5ub0tleXMgPT09IHRydWUgfHwgc2NvcGUubm9QYW4gPT09IHRydWUgKSByZXR1cm47XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHN3aXRjaCAoIGV2ZW50LmtleUNvZGUgKSB7XG5cbiAgICAgICAgICAgICAgICBjYXNlIHNjb3BlLmtleXMuVVA6XG4gICAgICAgICAgICAgICAgICAgIHNjb3BlLnBhbiggMCwgc2NvcGUua2V5UGFuU3BlZWQgKTtcbiAgICAgICAgICAgICAgICAgICAgc2NvcGUudXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSBzY29wZS5rZXlzLkJPVFRPTTpcbiAgICAgICAgICAgICAgICAgICAgc2NvcGUucGFuKCAwLCAtIHNjb3BlLmtleVBhblNwZWVkICk7XG4gICAgICAgICAgICAgICAgICAgIHNjb3BlLnVwZGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2Ugc2NvcGUua2V5cy5MRUZUOlxuICAgICAgICAgICAgICAgICAgICBzY29wZS5wYW4oIHNjb3BlLmtleVBhblNwZWVkLCAwICk7XG4gICAgICAgICAgICAgICAgICAgIHNjb3BlLnVwZGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2Ugc2NvcGUua2V5cy5SSUdIVDpcbiAgICAgICAgICAgICAgICAgICAgc2NvcGUucGFuKCAtIHNjb3BlLmtleVBhblNwZWVkLCAwICk7XG4gICAgICAgICAgICAgICAgICAgIHNjb3BlLnVwZGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiB0b3VjaHN0YXJ0KCBldmVudCApIHtcblxuICAgICAgICAgICAgaWYgKCBzY29wZS5lbmFibGVkID09PSBmYWxzZSApIHJldHVybjtcblxuICAgICAgICAgICAgc3dpdGNoICggZXZlbnQudG91Y2hlcy5sZW5ndGggKSB7XG5cbiAgICAgICAgICAgICAgICBjYXNlIDE6IC8vIG9uZS1maW5nZXJlZCB0b3VjaDogcm90YXRlXG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBzY29wZS5ub1JvdGF0ZSA9PT0gdHJ1ZSApIHJldHVybjtcblxuICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IFNUQVRFLlRPVUNIX1JPVEFURTtcblxuICAgICAgICAgICAgICAgICAgICByb3RhdGVTdGFydC5zZXQoIGV2ZW50LnRvdWNoZXNbIDAgXS5wYWdlWCwgZXZlbnQudG91Y2hlc1sgMCBdLnBhZ2VZICk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAyOiAvLyB0d28tZmluZ2VyZWQgdG91Y2g6IGRvbGx5XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBzY29wZS5ub1pvb20gPT09IHRydWUgKSByZXR1cm47XG5cbiAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSBTVEFURS5UT1VDSF9ET0xMWTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgZHggPSBldmVudC50b3VjaGVzWyAwIF0ucGFnZVggLSBldmVudC50b3VjaGVzWyAxIF0ucGFnZVg7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkeSA9IGV2ZW50LnRvdWNoZXNbIDAgXS5wYWdlWSAtIGV2ZW50LnRvdWNoZXNbIDEgXS5wYWdlWTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRpc3RhbmNlID0gTWF0aC5zcXJ0KCBkeCAqIGR4ICsgZHkgKiBkeSApO1xuICAgICAgICAgICAgICAgICAgICBkb2xseVN0YXJ0LnNldCggMCwgZGlzdGFuY2UgKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlIDM6IC8vIHRocmVlLWZpbmdlcmVkIHRvdWNoOiBwYW5cblxuICAgICAgICAgICAgICAgICAgICBpZiAoIHNjb3BlLm5vUGFuID09PSB0cnVlICkgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlID0gU1RBVEUuVE9VQ0hfUEFOO1xuXG4gICAgICAgICAgICAgICAgICAgIHBhblN0YXJ0LnNldCggZXZlbnQudG91Y2hlc1sgMCBdLnBhZ2VYLCBldmVudC50b3VjaGVzWyAwIF0ucGFnZVkgKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlID0gU1RBVEUuTk9ORTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzY29wZS5kaXNwYXRjaEV2ZW50KCBzdGFydEV2ZW50ICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHRvdWNobW92ZSggZXZlbnQgKSB7XG5cbiAgICAgICAgICAgIGlmICggc2NvcGUuZW5hYmxlZCA9PT0gZmFsc2UgKSByZXR1cm47XG5cbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBzY29wZS5kb21FbGVtZW50ID09PSBkb2N1bWVudCA/IHNjb3BlLmRvbUVsZW1lbnQuYm9keSA6IHNjb3BlLmRvbUVsZW1lbnQ7XG5cbiAgICAgICAgICAgIHN3aXRjaCAoIGV2ZW50LnRvdWNoZXMubGVuZ3RoICkge1xuXG4gICAgICAgICAgICAgICAgY2FzZSAxOiAvLyBvbmUtZmluZ2VyZWQgdG91Y2g6IHJvdGF0ZVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICggc2NvcGUubm9Sb3RhdGUgPT09IHRydWUgKSByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIGlmICggc3RhdGUgIT09IFNUQVRFLlRPVUNIX1JPVEFURSApIHJldHVybjtcblxuICAgICAgICAgICAgICAgICAgICByb3RhdGVFbmQuc2V0KCBldmVudC50b3VjaGVzWyAwIF0ucGFnZVgsIGV2ZW50LnRvdWNoZXNbIDAgXS5wYWdlWSApO1xuICAgICAgICAgICAgICAgICAgICByb3RhdGVEZWx0YS5zdWJWZWN0b3JzKCByb3RhdGVFbmQsIHJvdGF0ZVN0YXJ0ICk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gcm90YXRpbmcgYWNyb3NzIHdob2xlIHNjcmVlbiBnb2VzIDM2MCBkZWdyZWVzIGFyb3VuZFxuICAgICAgICAgICAgICAgICAgICBzY29wZS5yb3RhdGVMZWZ0KCAyICogTWF0aC5QSSAqIHJvdGF0ZURlbHRhLnggLyBlbGVtZW50LmNsaWVudFdpZHRoICogc2NvcGUucm90YXRlU3BlZWQgKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gcm90YXRpbmcgdXAgYW5kIGRvd24gYWxvbmcgd2hvbGUgc2NyZWVuIGF0dGVtcHRzIHRvIGdvIDM2MCwgYnV0IGxpbWl0ZWQgdG8gMTgwXG4gICAgICAgICAgICAgICAgICAgIHNjb3BlLnJvdGF0ZVVwKCAyICogTWF0aC5QSSAqIHJvdGF0ZURlbHRhLnkgLyBlbGVtZW50LmNsaWVudEhlaWdodCAqIHNjb3BlLnJvdGF0ZVNwZWVkICk7XG5cbiAgICAgICAgICAgICAgICAgICAgcm90YXRlU3RhcnQuY29weSggcm90YXRlRW5kICk7XG5cbiAgICAgICAgICAgICAgICAgICAgc2NvcGUudXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAyOiAvLyB0d28tZmluZ2VyZWQgdG91Y2g6IGRvbGx5XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBzY29wZS5ub1pvb20gPT09IHRydWUgKSByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIGlmICggc3RhdGUgIT09IFNUQVRFLlRPVUNIX0RPTExZICkgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBkeCA9IGV2ZW50LnRvdWNoZXNbIDAgXS5wYWdlWCAtIGV2ZW50LnRvdWNoZXNbIDEgXS5wYWdlWDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGR5ID0gZXZlbnQudG91Y2hlc1sgMCBdLnBhZ2VZIC0gZXZlbnQudG91Y2hlc1sgMSBdLnBhZ2VZO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGlzdGFuY2UgPSBNYXRoLnNxcnQoIGR4ICogZHggKyBkeSAqIGR5ICk7XG5cbiAgICAgICAgICAgICAgICAgICAgZG9sbHlFbmQuc2V0KCAwLCBkaXN0YW5jZSApO1xuICAgICAgICAgICAgICAgICAgICBkb2xseURlbHRhLnN1YlZlY3RvcnMoIGRvbGx5RW5kLCBkb2xseVN0YXJ0ICk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBkb2xseURlbHRhLnkgPiAwICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBzY29wZS5kb2xseU91dCgpO1xuXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlLmRvbGx5SW4oKTtcblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZG9sbHlTdGFydC5jb3B5KCBkb2xseUVuZCApO1xuXG4gICAgICAgICAgICAgICAgICAgIHNjb3BlLnVwZGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgMzogLy8gdGhyZWUtZmluZ2VyZWQgdG91Y2g6IHBhblxuXG4gICAgICAgICAgICAgICAgICAgIGlmICggc2NvcGUubm9QYW4gPT09IHRydWUgKSByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIGlmICggc3RhdGUgIT09IFNUQVRFLlRPVUNIX1BBTiApIHJldHVybjtcblxuICAgICAgICAgICAgICAgICAgICBwYW5FbmQuc2V0KCBldmVudC50b3VjaGVzWyAwIF0ucGFnZVgsIGV2ZW50LnRvdWNoZXNbIDAgXS5wYWdlWSApO1xuICAgICAgICAgICAgICAgICAgICBwYW5EZWx0YS5zdWJWZWN0b3JzKCBwYW5FbmQsIHBhblN0YXJ0ICk7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBzY29wZS5wYW4oIHBhbkRlbHRhLngsIHBhbkRlbHRhLnkgKTtcblxuICAgICAgICAgICAgICAgICAgICBwYW5TdGFydC5jb3B5KCBwYW5FbmQgKTtcblxuICAgICAgICAgICAgICAgICAgICBzY29wZS51cGRhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlID0gU1RBVEUuTk9ORTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiB0b3VjaGVuZCggLyogZXZlbnQgKi8gKSB7XG5cbiAgICAgICAgICAgIGlmICggc2NvcGUuZW5hYmxlZCA9PT0gZmFsc2UgKSByZXR1cm47XG5cbiAgICAgICAgICAgIHNjb3BlLmRpc3BhdGNoRXZlbnQoIGVuZEV2ZW50ICk7XG4gICAgICAgICAgICBzdGF0ZSA9IFNUQVRFLk5PTkU7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCAnY29udGV4dG1lbnUnLCBmdW5jdGlvbiAoIGV2ZW50ICkgeyBldmVudC5wcmV2ZW50RGVmYXVsdCgpOyB9LCBmYWxzZSApO1xuICAgICAgICB0aGlzLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggJ21vdXNlZG93bicsIG9uTW91c2VEb3duLCBmYWxzZSApO1xuICAgICAgICB0aGlzLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggJ21vdXNld2hlZWwnLCBvbk1vdXNlV2hlZWwsIGZhbHNlICk7XG4gICAgICAgIHRoaXMuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCAnRE9NTW91c2VTY3JvbGwnLCBvbk1vdXNlV2hlZWwsIGZhbHNlICk7IC8vIGZpcmVmb3hcblxuICAgICAgICB0aGlzLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggJ3RvdWNoc3RhcnQnLCB0b3VjaHN0YXJ0LCBmYWxzZSApO1xuICAgICAgICB0aGlzLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggJ3RvdWNoZW5kJywgdG91Y2hlbmQsIGZhbHNlICk7XG4gICAgICAgIHRoaXMuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCAndG91Y2htb3ZlJywgdG91Y2htb3ZlLCBmYWxzZSApO1xuXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCAna2V5ZG93bicsIG9uS2V5RG93biwgZmFsc2UgKTtcblxuICAgICAgICAvLyBmb3JjZSBhbiB1cGRhdGUgYXQgc3RhcnRcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcblxuICAgIH07XG5cbiAgICBpbmhlcml0cyhPcmJpdENvbnRyb2xzLCBUSFJFRS5FdmVudERpc3BhdGNoZXIpXG4gICAgcmV0dXJuIE9yYml0Q29udHJvbHNcbn1cbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KSIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbnVtdHlwZShudW0sIGRlZikge1xuXHRyZXR1cm4gdHlwZW9mIG51bSA9PT0gJ251bWJlcidcblx0XHQ/IG51bSBcblx0XHQ6ICh0eXBlb2YgZGVmID09PSAnbnVtYmVyJyA/IGRlZiA6IDApXG59IiwiLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8ZmVyb3NzQGZlcm9zcy5vcmc+IDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcbnZhciBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzLWFycmF5JylcblxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyIC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cblxudmFyIGtNYXhMZW5ndGggPSAweDNmZmZmZmZmXG5cbi8qKlxuICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFVzZSBPYmplY3QgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gKlxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICpcbiAqIE5vdGU6XG4gKlxuICogLSBJbXBsZW1lbnRhdGlvbiBtdXN0IHN1cHBvcnQgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YCBpbnN0YW5jZXMuXG4gKiAgIEZpcmVmb3ggNC0yOSBsYWNrZWQgc3VwcG9ydCwgZml4ZWQgaW4gRmlyZWZveCAzMCsuXG4gKiAgIFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4LlxuICpcbiAqICAtIENocm9tZSA5LTEwIGlzIG1pc3NpbmcgdGhlIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24uXG4gKlxuICogIC0gSUUxMCBoYXMgYSBicm9rZW4gYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFycmF5cyBvZlxuICogICAgaW5jb3JyZWN0IGxlbmd0aCBpbiBzb21lIHNpdHVhdGlvbnMuXG4gKlxuICogV2UgZGV0ZWN0IHRoZXNlIGJ1Z2d5IGJyb3dzZXJzIGFuZCBzZXQgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYCB0byBgZmFsc2VgIHNvIHRoZXkgd2lsbFxuICogZ2V0IHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24sIHdoaWNoIGlzIHNsb3dlciBidXQgd2lsbCB3b3JrIGNvcnJlY3RseS5cbiAqL1xuQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgPSAoZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIHZhciBidWYgPSBuZXcgQXJyYXlCdWZmZXIoMClcbiAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoYnVmKVxuICAgIGFyci5mb28gPSBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9XG4gICAgcmV0dXJuIDQyID09PSBhcnIuZm9vKCkgJiYgLy8gdHlwZWQgYXJyYXkgaW5zdGFuY2VzIGNhbiBiZSBhdWdtZW50ZWRcbiAgICAgICAgdHlwZW9mIGFyci5zdWJhcnJheSA9PT0gJ2Z1bmN0aW9uJyAmJiAvLyBjaHJvbWUgOS0xMCBsYWNrIGBzdWJhcnJheWBcbiAgICAgICAgbmV3IFVpbnQ4QXJyYXkoMSkuc3ViYXJyYXkoMSwgMSkuYnl0ZUxlbmd0aCA9PT0gMCAvLyBpZTEwIGhhcyBicm9rZW4gYHN1YmFycmF5YFxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn0pKClcblxuLyoqXG4gKiBDbGFzczogQnVmZmVyXG4gKiA9PT09PT09PT09PT09XG4gKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBhcmUgYXVnbWVudGVkXG4gKiB3aXRoIGZ1bmN0aW9uIHByb3BlcnRpZXMgZm9yIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBBUEkgZnVuY3Rpb25zLiBXZSB1c2VcbiAqIGBVaW50OEFycmF5YCBzbyB0aGF0IHNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0IHJldHVybnNcbiAqIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIEJ5IGF1Z21lbnRpbmcgdGhlIGluc3RhbmNlcywgd2UgY2FuIGF2b2lkIG1vZGlmeWluZyB0aGUgYFVpbnQ4QXJyYXlgXG4gKiBwcm90b3R5cGUuXG4gKi9cbmZ1bmN0aW9uIEJ1ZmZlciAoc3ViamVjdCwgZW5jb2RpbmcsIG5vWmVybykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQnVmZmVyKSlcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcihzdWJqZWN0LCBlbmNvZGluZywgbm9aZXJvKVxuXG4gIHZhciB0eXBlID0gdHlwZW9mIHN1YmplY3RcblxuICAvLyBGaW5kIHRoZSBsZW5ndGhcbiAgdmFyIGxlbmd0aFxuICBpZiAodHlwZSA9PT0gJ251bWJlcicpXG4gICAgbGVuZ3RoID0gc3ViamVjdCA+IDAgPyBzdWJqZWN0ID4+PiAwIDogMFxuICBlbHNlIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuICAgIGlmIChlbmNvZGluZyA9PT0gJ2Jhc2U2NCcpXG4gICAgICBzdWJqZWN0ID0gYmFzZTY0Y2xlYW4oc3ViamVjdClcbiAgICBsZW5ndGggPSBCdWZmZXIuYnl0ZUxlbmd0aChzdWJqZWN0LCBlbmNvZGluZylcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnb2JqZWN0JyAmJiBzdWJqZWN0ICE9PSBudWxsKSB7IC8vIGFzc3VtZSBvYmplY3QgaXMgYXJyYXktbGlrZVxuICAgIGlmIChzdWJqZWN0LnR5cGUgPT09ICdCdWZmZXInICYmIGlzQXJyYXkoc3ViamVjdC5kYXRhKSlcbiAgICAgIHN1YmplY3QgPSBzdWJqZWN0LmRhdGFcbiAgICBsZW5ndGggPSArc3ViamVjdC5sZW5ndGggPiAwID8gTWF0aC5mbG9vcigrc3ViamVjdC5sZW5ndGgpIDogMFxuICB9IGVsc2VcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtdXN0IHN0YXJ0IHdpdGggbnVtYmVyLCBidWZmZXIsIGFycmF5IG9yIHN0cmluZycpXG5cbiAgaWYgKHRoaXMubGVuZ3RoID4ga01heExlbmd0aClcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICtcbiAgICAgICdzaXplOiAweCcgKyBrTWF4TGVuZ3RoLnRvU3RyaW5nKDE2KSArICcgYnl0ZXMnKVxuXG4gIHZhciBidWZcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUHJlZmVycmVkOiBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIGJ1ZiA9IEJ1ZmZlci5fYXVnbWVudChuZXcgVWludDhBcnJheShsZW5ndGgpKVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gVEhJUyBpbnN0YW5jZSBvZiBCdWZmZXIgKGNyZWF0ZWQgYnkgYG5ld2ApXG4gICAgYnVmID0gdGhpc1xuICAgIGJ1Zi5sZW5ndGggPSBsZW5ndGhcbiAgICBidWYuX2lzQnVmZmVyID0gdHJ1ZVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmIHR5cGVvZiBzdWJqZWN0LmJ5dGVMZW5ndGggPT09ICdudW1iZXInKSB7XG4gICAgLy8gU3BlZWQgb3B0aW1pemF0aW9uIC0tIHVzZSBzZXQgaWYgd2UncmUgY29weWluZyBmcm9tIGEgdHlwZWQgYXJyYXlcbiAgICBidWYuX3NldChzdWJqZWN0KVxuICB9IGVsc2UgaWYgKGlzQXJyYXlpc2goc3ViamVjdCkpIHtcbiAgICAvLyBUcmVhdCBhcnJheS1pc2ggb2JqZWN0cyBhcyBhIGJ5dGUgYXJyYXlcbiAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKHN1YmplY3QpKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspXG4gICAgICAgIGJ1ZltpXSA9IHN1YmplY3QucmVhZFVJbnQ4KGkpXG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKylcbiAgICAgICAgYnVmW2ldID0gKChzdWJqZWN0W2ldICUgMjU2KSArIDI1NikgJSAyNTZcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICBidWYud3JpdGUoc3ViamVjdCwgMCwgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ251bWJlcicgJiYgIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmICFub1plcm8pIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGJ1ZltpXSA9IDBcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnVmXG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIChiKSB7XG4gIHJldHVybiAhIShiICE9IG51bGwgJiYgYi5faXNCdWZmZXIpXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSlcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgbXVzdCBiZSBCdWZmZXJzJylcblxuICB2YXIgeCA9IGEubGVuZ3RoXG4gIHZhciB5ID0gYi5sZW5ndGhcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuICYmIGFbaV0gPT09IGJbaV07IGkrKykge31cbiAgaWYgKGkgIT09IGxlbikge1xuICAgIHggPSBhW2ldXG4gICAgeSA9IGJbaV1cbiAgfVxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICdyYXcnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gKGxpc3QsIHRvdGFsTGVuZ3RoKSB7XG4gIGlmICghaXNBcnJheShsaXN0KSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVXNhZ2U6IEJ1ZmZlci5jb25jYXQobGlzdFssIGxlbmd0aF0pJylcblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcigwKVxuICB9IGVsc2UgaWYgKGxpc3QubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIGxpc3RbMF1cbiAgfVxuXG4gIHZhciBpXG4gIGlmICh0b3RhbExlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdG90YWxMZW5ndGggPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRvdGFsTGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgdmFyIGJ1ZiA9IG5ldyBCdWZmZXIodG90YWxMZW5ndGgpXG4gIHZhciBwb3MgPSAwXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSBsaXN0W2ldXG4gICAgaXRlbS5jb3B5KGJ1ZiwgcG9zKVxuICAgIHBvcyArPSBpdGVtLmxlbmd0aFxuICB9XG4gIHJldHVybiBidWZcbn1cblxuQnVmZmVyLmJ5dGVMZW5ndGggPSBmdW5jdGlvbiAoc3RyLCBlbmNvZGluZykge1xuICB2YXIgcmV0XG4gIHN0ciA9IHN0ciArICcnXG4gIHN3aXRjaCAoZW5jb2RpbmcgfHwgJ3V0ZjgnKSB7XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAncmF3JzpcbiAgICAgIHJldCA9IHN0ci5sZW5ndGhcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldCA9IHN0ci5sZW5ndGggKiAyXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2hleCc6XG4gICAgICByZXQgPSBzdHIubGVuZ3RoID4+PiAxXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIHJldCA9IHV0ZjhUb0J5dGVzKHN0cikubGVuZ3RoXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICByZXQgPSBiYXNlNjRUb0J5dGVzKHN0cikubGVuZ3RoXG4gICAgICBicmVha1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXQgPSBzdHIubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG4vLyBwcmUtc2V0IGZvciB2YWx1ZXMgdGhhdCBtYXkgZXhpc3QgaW4gdGhlIGZ1dHVyZVxuQnVmZmVyLnByb3RvdHlwZS5sZW5ndGggPSB1bmRlZmluZWRcbkJ1ZmZlci5wcm90b3R5cGUucGFyZW50ID0gdW5kZWZpbmVkXG5cbi8vIHRvU3RyaW5nKGVuY29kaW5nLCBzdGFydD0wLCBlbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcblxuICBzdGFydCA9IHN0YXJ0ID4+PiAwXG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA9PT0gSW5maW5pdHkgPyB0aGlzLmxlbmd0aCA6IGVuZCA+Pj4gMFxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG4gIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmIChlbmQgPD0gc3RhcnQpIHJldHVybiAnJ1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGJpbmFyeVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSlcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKGIpIHtcbiAgaWYoIUJ1ZmZlci5pc0J1ZmZlcihiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdHIgPSAnJ1xuICB2YXIgbWF4ID0gZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFU1xuICBpZiAodGhpcy5sZW5ndGggPiAwKSB7XG4gICAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5tYXRjaCgvLnsyfS9nKS5qb2luKCcgJylcbiAgICBpZiAodGhpcy5sZW5ndGggPiBtYXgpXG4gICAgICBzdHIgKz0gJyAuLi4gJ1xuICB9XG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpXG59XG5cbi8vIGBnZXRgIHdpbGwgYmUgcmVtb3ZlZCBpbiBOb2RlIDAuMTMrXG5CdWZmZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgY29uc29sZS5sb2coJy5nZXQoKSBpcyBkZXByZWNhdGVkLiBBY2Nlc3MgdXNpbmcgYXJyYXkgaW5kZXhlcyBpbnN0ZWFkLicpXG4gIHJldHVybiB0aGlzLnJlYWRVSW50OChvZmZzZXQpXG59XG5cbi8vIGBzZXRgIHdpbGwgYmUgcmVtb3ZlZCBpbiBOb2RlIDAuMTMrXG5CdWZmZXIucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh2LCBvZmZzZXQpIHtcbiAgY29uc29sZS5sb2coJy5zZXQoKSBpcyBkZXByZWNhdGVkLiBBY2Nlc3MgdXNpbmcgYXJyYXkgaW5kZXhlcyBpbnN0ZWFkLicpXG4gIHJldHVybiB0aGlzLndyaXRlVUludDgodiwgb2Zmc2V0KVxufVxuXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgdmFyIHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuXG4gIC8vIG11c3QgYmUgYW4gZXZlbiBudW1iZXIgb2YgZGlnaXRzXG4gIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChzdHJMZW4gJSAyICE9PSAwKSB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZycpXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIHZhciBieXRlID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxuICAgIGlmIChpc05hTihieXRlKSkgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGhleCBzdHJpbmcnKVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IGJ5dGVcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgY2hhcnNXcml0dGVuID0gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxuICByZXR1cm4gY2hhcnNXcml0dGVuXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgY2hhcnNXcml0dGVuID0gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbiAgcmV0dXJuIGNoYXJzV3JpdHRlblxufVxuXG5mdW5jdGlvbiBiaW5hcnlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBhc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgY2hhcnNXcml0dGVuID0gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG4gIHJldHVybiBjaGFyc1dyaXR0ZW5cbn1cblxuZnVuY3Rpb24gdXRmMTZsZVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIGNoYXJzV3JpdHRlbiA9IGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbiAgcmV0dXJuIGNoYXJzV3JpdHRlblxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIFN1cHBvcnQgYm90aCAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpXG4gIC8vIGFuZCB0aGUgbGVnYWN5IChzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBpZiAoIWlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIH0gZWxzZSB7ICAvLyBsZWdhY3lcbiAgICB2YXIgc3dhcCA9IGVuY29kaW5nXG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBvZmZzZXQgPSBsZW5ndGhcbiAgICBsZW5ndGggPSBzd2FwXG4gIH1cblxuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG4gIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nIHx8ICd1dGY4JykudG9Mb3dlckNhc2UoKVxuXG4gIHZhciByZXRcbiAgc3dpdGNoIChlbmNvZGluZykge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgICByZXQgPSBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgICByZXQgPSB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYXNjaWknOlxuICAgICAgcmV0ID0gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdiaW5hcnknOlxuICAgICAgcmV0ID0gYmluYXJ5V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIHJldCA9IGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXQgPSB1dGYxNmxlV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmVzID0gJydcbiAgdmFyIHRtcCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIGlmIChidWZbaV0gPD0gMHg3Rikge1xuICAgICAgcmVzICs9IGRlY29kZVV0ZjhDaGFyKHRtcCkgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgICAgIHRtcCA9ICcnXG4gICAgfSBlbHNlIHtcbiAgICAgIHRtcCArPSAnJScgKyBidWZbaV0udG9TdHJpbmcoMTYpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlcyArIGRlY29kZVV0ZjhDaGFyKHRtcClcbn1cblxuZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBiaW5hcnlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHJldHVybiBhc2NpaVNsaWNlKGJ1Ziwgc3RhcnQsIGVuZClcbn1cblxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxuXG4gIHZhciBvdXQgPSAnJ1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIG91dCArPSB0b0hleChidWZbaV0pXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgdmFyIHJlcyA9ICcnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIGJ5dGVzW2kgKyAxXSAqIDI1NilcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgc3RhcnQgPSB+fnN0YXJ0XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmRcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgKz0gbGVuO1xuICAgIGlmIChzdGFydCA8IDApXG4gICAgICBzdGFydCA9IDBcbiAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikge1xuICAgIHN0YXJ0ID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5cbiAgICBpZiAoZW5kIDwgMClcbiAgICAgIGVuZCA9IDBcbiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcbiAgICBlbmQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydClcbiAgICBlbmQgPSBzdGFydFxuXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHJldHVybiBCdWZmZXIuX2F1Z21lbnQodGhpcy5zdWJhcnJheShzdGFydCwgZW5kKSlcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2xpY2VMZW4gPSBlbmQgLSBzdGFydFxuICAgIHZhciBuZXdCdWYgPSBuZXcgQnVmZmVyKHNsaWNlTGVuLCB1bmRlZmluZWQsIHRydWUpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzbGljZUxlbjsgaSsrKSB7XG4gICAgICBuZXdCdWZbaV0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gICAgcmV0dXJuIG5ld0J1ZlxuICB9XG59XG5cbi8qXG4gKiBOZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGJ1ZmZlciBpc24ndCB0cnlpbmcgdG8gd3JpdGUgb3V0IG9mIGJvdW5kcy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tPZmZzZXQgKG9mZnNldCwgZXh0LCBsZW5ndGgpIHtcbiAgaWYgKChvZmZzZXQgJSAxKSAhPT0gMCB8fCBvZmZzZXQgPCAwKVxuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKVxuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgOCkgfCB0aGlzW29mZnNldCArIDFdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAoKHRoaXNbb2Zmc2V0XSkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpKSArXG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSAqIDB4MTAwMDAwMClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gKiAweDEwMDAwMDApICtcbiAgICAgICgodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICAgdGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgaWYgKCEodGhpc1tvZmZzZXRdICYgMHg4MCkpXG4gICAgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8ICh0aGlzW29mZnNldF0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn1cblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdidWZmZXIgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpXG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsdWUgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICB0aGlzW29mZnNldF0gPSB2YWx1ZVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQxNiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCAyKTsgaSA8IGo7IGkrKykge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSAmICgweGZmIDw8ICg4ICogKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkpKSkgPj4+XG4gICAgICAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSAqIDhcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSB2YWx1ZVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9IHZhbHVlXG4gIH0gZWxzZSBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MzIgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDQpOyBpIDwgajsgaSsrKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlID4+PiAobGl0dGxlRW5kaWFuID8gaSA6IDMgLSBpKSAqIDgpICYgMHhmZlxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0XSA9IHZhbHVlXG4gIH0gZWxzZSBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSB2YWx1ZVxuICB9IGVsc2Ugb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSB2YWx1ZVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9IHZhbHVlXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSB2YWx1ZVxuICB9IGVsc2Ugb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSB2YWx1ZVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIH0gZWxzZSBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gdmFsdWVcbiAgfSBlbHNlIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5mdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbHVlIGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFR5cGVFcnJvcignaW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG9hdCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAodGFyZ2V0LCB0YXJnZXRfc3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHNvdXJjZSA9IHRoaXNcblxuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAoIXRhcmdldF9zdGFydCkgdGFyZ2V0X3N0YXJ0ID0gMFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHNvdXJjZS5sZW5ndGggPT09IDApIHJldHVyblxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgaWYgKGVuZCA8IHN0YXJ0KSB0aHJvdyBuZXcgVHlwZUVycm9yKCdzb3VyY2VFbmQgPCBzb3VyY2VTdGFydCcpXG4gIGlmICh0YXJnZXRfc3RhcnQgPCAwIHx8IHRhcmdldF9zdGFydCA+PSB0YXJnZXQubGVuZ3RoKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHNvdXJjZS5sZW5ndGgpIHRocm93IG5ldyBUeXBlRXJyb3IoJ3NvdXJjZVN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBpZiAoZW5kIDwgMCB8fCBlbmQgPiBzb3VyY2UubGVuZ3RoKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKVxuICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0X3N0YXJ0IDwgZW5kIC0gc3RhcnQpXG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldF9zdGFydCArIHN0YXJ0XG5cbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0XG5cbiAgaWYgKGxlbiA8IDEwMDAgfHwgIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRfc3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRhcmdldC5fc2V0KHRoaXMuc3ViYXJyYXkoc3RhcnQsIHN0YXJ0ICsgbGVuKSwgdGFyZ2V0X3N0YXJ0KVxuICB9XG59XG5cbi8vIGZpbGwodmFsdWUsIHN0YXJ0PTAsIGVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gKHZhbHVlLCBzdGFydCwgZW5kKSB7XG4gIGlmICghdmFsdWUpIHZhbHVlID0gMFxuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQpIGVuZCA9IHRoaXMubGVuZ3RoXG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmQgPCBzdGFydCcpXG5cbiAgLy8gRmlsbCAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm5cbiAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm5cblxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdzdGFydCBvdXQgb2YgYm91bmRzJylcbiAgaWYgKGVuZCA8IDAgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuZCBvdXQgb2YgYm91bmRzJylcblxuICB2YXIgaVxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgIHRoaXNbaV0gPSB2YWx1ZVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgYnl0ZXMgPSB1dGY4VG9CeXRlcyh2YWx1ZS50b1N0cmluZygpKVxuICAgIHZhciBsZW4gPSBieXRlcy5sZW5ndGhcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICB0aGlzW2ldID0gYnl0ZXNbaSAlIGxlbl1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgYEFycmF5QnVmZmVyYCB3aXRoIHRoZSAqY29waWVkKiBtZW1vcnkgb2YgdGhlIGJ1ZmZlciBpbnN0YW5jZS5cbiAqIEFkZGVkIGluIE5vZGUgMC4xMi4gT25seSBhdmFpbGFibGUgaW4gYnJvd3NlcnMgdGhhdCBzdXBwb3J0IEFycmF5QnVmZmVyLlxuICovXG5CdWZmZXIucHJvdG90eXBlLnRvQXJyYXlCdWZmZXIgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAgIHJldHVybiAobmV3IEJ1ZmZlcih0aGlzKSkuYnVmZmVyXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBidWYgPSBuZXcgVWludDhBcnJheSh0aGlzLmxlbmd0aClcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBidWYubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgYnVmW2ldID0gdGhpc1tpXVxuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1Zi5idWZmZXJcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQnVmZmVyLnRvQXJyYXlCdWZmZXIgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXInKVxuICB9XG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxudmFyIEJQID0gQnVmZmVyLnByb3RvdHlwZVxuXG4vKipcbiAqIEF1Z21lbnQgYSBVaW50OEFycmF5ICppbnN0YW5jZSogKG5vdCB0aGUgVWludDhBcnJheSBjbGFzcyEpIHdpdGggQnVmZmVyIG1ldGhvZHNcbiAqL1xuQnVmZmVyLl9hdWdtZW50ID0gZnVuY3Rpb24gKGFycikge1xuICBhcnIuY29uc3RydWN0b3IgPSBCdWZmZXJcbiAgYXJyLl9pc0J1ZmZlciA9IHRydWVcblxuICAvLyBzYXZlIHJlZmVyZW5jZSB0byBvcmlnaW5hbCBVaW50OEFycmF5IGdldC9zZXQgbWV0aG9kcyBiZWZvcmUgb3ZlcndyaXRpbmdcbiAgYXJyLl9nZXQgPSBhcnIuZ2V0XG4gIGFyci5fc2V0ID0gYXJyLnNldFxuXG4gIC8vIGRlcHJlY2F0ZWQsIHdpbGwgYmUgcmVtb3ZlZCBpbiBub2RlIDAuMTMrXG4gIGFyci5nZXQgPSBCUC5nZXRcbiAgYXJyLnNldCA9IEJQLnNldFxuXG4gIGFyci53cml0ZSA9IEJQLndyaXRlXG4gIGFyci50b1N0cmluZyA9IEJQLnRvU3RyaW5nXG4gIGFyci50b0xvY2FsZVN0cmluZyA9IEJQLnRvU3RyaW5nXG4gIGFyci50b0pTT04gPSBCUC50b0pTT05cbiAgYXJyLmVxdWFscyA9IEJQLmVxdWFsc1xuICBhcnIuY29tcGFyZSA9IEJQLmNvbXBhcmVcbiAgYXJyLmNvcHkgPSBCUC5jb3B5XG4gIGFyci5zbGljZSA9IEJQLnNsaWNlXG4gIGFyci5yZWFkVUludDggPSBCUC5yZWFkVUludDhcbiAgYXJyLnJlYWRVSW50MTZMRSA9IEJQLnJlYWRVSW50MTZMRVxuICBhcnIucmVhZFVJbnQxNkJFID0gQlAucmVhZFVJbnQxNkJFXG4gIGFyci5yZWFkVUludDMyTEUgPSBCUC5yZWFkVUludDMyTEVcbiAgYXJyLnJlYWRVSW50MzJCRSA9IEJQLnJlYWRVSW50MzJCRVxuICBhcnIucmVhZEludDggPSBCUC5yZWFkSW50OFxuICBhcnIucmVhZEludDE2TEUgPSBCUC5yZWFkSW50MTZMRVxuICBhcnIucmVhZEludDE2QkUgPSBCUC5yZWFkSW50MTZCRVxuICBhcnIucmVhZEludDMyTEUgPSBCUC5yZWFkSW50MzJMRVxuICBhcnIucmVhZEludDMyQkUgPSBCUC5yZWFkSW50MzJCRVxuICBhcnIucmVhZEZsb2F0TEUgPSBCUC5yZWFkRmxvYXRMRVxuICBhcnIucmVhZEZsb2F0QkUgPSBCUC5yZWFkRmxvYXRCRVxuICBhcnIucmVhZERvdWJsZUxFID0gQlAucmVhZERvdWJsZUxFXG4gIGFyci5yZWFkRG91YmxlQkUgPSBCUC5yZWFkRG91YmxlQkVcbiAgYXJyLndyaXRlVUludDggPSBCUC53cml0ZVVJbnQ4XG4gIGFyci53cml0ZVVJbnQxNkxFID0gQlAud3JpdGVVSW50MTZMRVxuICBhcnIud3JpdGVVSW50MTZCRSA9IEJQLndyaXRlVUludDE2QkVcbiAgYXJyLndyaXRlVUludDMyTEUgPSBCUC53cml0ZVVJbnQzMkxFXG4gIGFyci53cml0ZVVJbnQzMkJFID0gQlAud3JpdGVVSW50MzJCRVxuICBhcnIud3JpdGVJbnQ4ID0gQlAud3JpdGVJbnQ4XG4gIGFyci53cml0ZUludDE2TEUgPSBCUC53cml0ZUludDE2TEVcbiAgYXJyLndyaXRlSW50MTZCRSA9IEJQLndyaXRlSW50MTZCRVxuICBhcnIud3JpdGVJbnQzMkxFID0gQlAud3JpdGVJbnQzMkxFXG4gIGFyci53cml0ZUludDMyQkUgPSBCUC53cml0ZUludDMyQkVcbiAgYXJyLndyaXRlRmxvYXRMRSA9IEJQLndyaXRlRmxvYXRMRVxuICBhcnIud3JpdGVGbG9hdEJFID0gQlAud3JpdGVGbG9hdEJFXG4gIGFyci53cml0ZURvdWJsZUxFID0gQlAud3JpdGVEb3VibGVMRVxuICBhcnIud3JpdGVEb3VibGVCRSA9IEJQLndyaXRlRG91YmxlQkVcbiAgYXJyLmZpbGwgPSBCUC5maWxsXG4gIGFyci5pbnNwZWN0ID0gQlAuaW5zcGVjdFxuICBhcnIudG9BcnJheUJ1ZmZlciA9IEJQLnRvQXJyYXlCdWZmZXJcblxuICByZXR1cm4gYXJyXG59XG5cbnZhciBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXitcXC8wLTlBLXpdL2dcblxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xuICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXFxuIGFuZCBcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgc3RyID0gc3RyaW5ndHJpbShzdHIpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxuICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgd2hpbGUgKHN0ci5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgc3RyID0gc3RyICsgJz0nXG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG5mdW5jdGlvbiBzdHJpbmd0cmltIChzdHIpIHtcbiAgaWYgKHN0ci50cmltKSByZXR1cm4gc3RyLnRyaW0oKVxuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKVxufVxuXG5mdW5jdGlvbiBpc0FycmF5aXNoIChzdWJqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5KHN1YmplY3QpIHx8IEJ1ZmZlci5pc0J1ZmZlcihzdWJqZWN0KSB8fFxuICAgICAgc3ViamVjdCAmJiB0eXBlb2Ygc3ViamVjdCA9PT0gJ29iamVjdCcgJiZcbiAgICAgIHR5cGVvZiBzdWJqZWN0Lmxlbmd0aCA9PT0gJ251bWJlcidcbn1cblxuZnVuY3Rpb24gdG9IZXggKG4pIHtcbiAgaWYgKG4gPCAxNikgcmV0dXJuICcwJyArIG4udG9TdHJpbmcoMTYpXG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KVxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIHZhciBiID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBpZiAoYiA8PSAweDdGKSB7XG4gICAgICBieXRlQXJyYXkucHVzaChiKVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgc3RhcnQgPSBpXG4gICAgICBpZiAoYiA+PSAweEQ4MDAgJiYgYiA8PSAweERGRkYpIGkrK1xuICAgICAgdmFyIGggPSBlbmNvZGVVUklDb21wb25lbnQoc3RyLnNsaWNlKHN0YXJ0LCBpKzEpKS5zdWJzdHIoMSkuc3BsaXQoJyUnKVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBoLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGJ5dGVBcnJheS5wdXNoKHBhcnNlSW50KGhbal0sIDE2KSlcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBjLCBoaSwgbG9cbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoc3RyKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSlcbiAgICAgIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gZGVjb2RlVXRmOENoYXIgKHN0cikge1xuICB0cnkge1xuICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoc3RyKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSgweEZGRkQpIC8vIFVURiA4IGludmFsaWQgY2hhclxuICB9XG59XG4iLCJ2YXIgbG9va3VwID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nO1xuXG47KGZ1bmN0aW9uIChleHBvcnRzKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuICB2YXIgQXJyID0gKHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJylcbiAgICA/IFVpbnQ4QXJyYXlcbiAgICA6IEFycmF5XG5cblx0dmFyIFBMVVMgICA9ICcrJy5jaGFyQ29kZUF0KDApXG5cdHZhciBTTEFTSCAgPSAnLycuY2hhckNvZGVBdCgwKVxuXHR2YXIgTlVNQkVSID0gJzAnLmNoYXJDb2RlQXQoMClcblx0dmFyIExPV0VSICA9ICdhJy5jaGFyQ29kZUF0KDApXG5cdHZhciBVUFBFUiAgPSAnQScuY2hhckNvZGVBdCgwKVxuXG5cdGZ1bmN0aW9uIGRlY29kZSAoZWx0KSB7XG5cdFx0dmFyIGNvZGUgPSBlbHQuY2hhckNvZGVBdCgwKVxuXHRcdGlmIChjb2RlID09PSBQTFVTKVxuXHRcdFx0cmV0dXJuIDYyIC8vICcrJ1xuXHRcdGlmIChjb2RlID09PSBTTEFTSClcblx0XHRcdHJldHVybiA2MyAvLyAnLydcblx0XHRpZiAoY29kZSA8IE5VTUJFUilcblx0XHRcdHJldHVybiAtMSAvL25vIG1hdGNoXG5cdFx0aWYgKGNvZGUgPCBOVU1CRVIgKyAxMClcblx0XHRcdHJldHVybiBjb2RlIC0gTlVNQkVSICsgMjYgKyAyNlxuXHRcdGlmIChjb2RlIDwgVVBQRVIgKyAyNilcblx0XHRcdHJldHVybiBjb2RlIC0gVVBQRVJcblx0XHRpZiAoY29kZSA8IExPV0VSICsgMjYpXG5cdFx0XHRyZXR1cm4gY29kZSAtIExPV0VSICsgMjZcblx0fVxuXG5cdGZ1bmN0aW9uIGI2NFRvQnl0ZUFycmF5IChiNjQpIHtcblx0XHR2YXIgaSwgaiwgbCwgdG1wLCBwbGFjZUhvbGRlcnMsIGFyclxuXG5cdFx0aWYgKGI2NC5sZW5ndGggJSA0ID4gMCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0Jylcblx0XHR9XG5cblx0XHQvLyB0aGUgbnVtYmVyIG9mIGVxdWFsIHNpZ25zIChwbGFjZSBob2xkZXJzKVxuXHRcdC8vIGlmIHRoZXJlIGFyZSB0d28gcGxhY2Vob2xkZXJzLCB0aGFuIHRoZSB0d28gY2hhcmFjdGVycyBiZWZvcmUgaXRcblx0XHQvLyByZXByZXNlbnQgb25lIGJ5dGVcblx0XHQvLyBpZiB0aGVyZSBpcyBvbmx5IG9uZSwgdGhlbiB0aGUgdGhyZWUgY2hhcmFjdGVycyBiZWZvcmUgaXQgcmVwcmVzZW50IDIgYnl0ZXNcblx0XHQvLyB0aGlzIGlzIGp1c3QgYSBjaGVhcCBoYWNrIHRvIG5vdCBkbyBpbmRleE9mIHR3aWNlXG5cdFx0dmFyIGxlbiA9IGI2NC5sZW5ndGhcblx0XHRwbGFjZUhvbGRlcnMgPSAnPScgPT09IGI2NC5jaGFyQXQobGVuIC0gMikgPyAyIDogJz0nID09PSBiNjQuY2hhckF0KGxlbiAtIDEpID8gMSA6IDBcblxuXHRcdC8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuXHRcdGFyciA9IG5ldyBBcnIoYjY0Lmxlbmd0aCAqIDMgLyA0IC0gcGxhY2VIb2xkZXJzKVxuXG5cdFx0Ly8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuXHRcdGwgPSBwbGFjZUhvbGRlcnMgPiAwID8gYjY0Lmxlbmd0aCAtIDQgOiBiNjQubGVuZ3RoXG5cblx0XHR2YXIgTCA9IDBcblxuXHRcdGZ1bmN0aW9uIHB1c2ggKHYpIHtcblx0XHRcdGFycltMKytdID0gdlxuXHRcdH1cblxuXHRcdGZvciAoaSA9IDAsIGogPSAwOyBpIDwgbDsgaSArPSA0LCBqICs9IDMpIHtcblx0XHRcdHRtcCA9IChkZWNvZGUoYjY0LmNoYXJBdChpKSkgPDwgMTgpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAxKSkgPDwgMTIpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAyKSkgPDwgNikgfCBkZWNvZGUoYjY0LmNoYXJBdChpICsgMykpXG5cdFx0XHRwdXNoKCh0bXAgJiAweEZGMDAwMCkgPj4gMTYpXG5cdFx0XHRwdXNoKCh0bXAgJiAweEZGMDApID4+IDgpXG5cdFx0XHRwdXNoKHRtcCAmIDB4RkYpXG5cdFx0fVxuXG5cdFx0aWYgKHBsYWNlSG9sZGVycyA9PT0gMikge1xuXHRcdFx0dG1wID0gKGRlY29kZShiNjQuY2hhckF0KGkpKSA8PCAyKSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMSkpID4+IDQpXG5cdFx0XHRwdXNoKHRtcCAmIDB4RkYpXG5cdFx0fSBlbHNlIGlmIChwbGFjZUhvbGRlcnMgPT09IDEpIHtcblx0XHRcdHRtcCA9IChkZWNvZGUoYjY0LmNoYXJBdChpKSkgPDwgMTApIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAxKSkgPDwgNCkgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDIpKSA+PiAyKVxuXHRcdFx0cHVzaCgodG1wID4+IDgpICYgMHhGRilcblx0XHRcdHB1c2godG1wICYgMHhGRilcblx0XHR9XG5cblx0XHRyZXR1cm4gYXJyXG5cdH1cblxuXHRmdW5jdGlvbiB1aW50OFRvQmFzZTY0ICh1aW50OCkge1xuXHRcdHZhciBpLFxuXHRcdFx0ZXh0cmFCeXRlcyA9IHVpbnQ4Lmxlbmd0aCAlIDMsIC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG5cdFx0XHRvdXRwdXQgPSBcIlwiLFxuXHRcdFx0dGVtcCwgbGVuZ3RoXG5cblx0XHRmdW5jdGlvbiBlbmNvZGUgKG51bSkge1xuXHRcdFx0cmV0dXJuIGxvb2t1cC5jaGFyQXQobnVtKVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XG5cdFx0XHRyZXR1cm4gZW5jb2RlKG51bSA+PiAxOCAmIDB4M0YpICsgZW5jb2RlKG51bSA+PiAxMiAmIDB4M0YpICsgZW5jb2RlKG51bSA+PiA2ICYgMHgzRikgKyBlbmNvZGUobnVtICYgMHgzRilcblx0XHR9XG5cblx0XHQvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG5cdFx0Zm9yIChpID0gMCwgbGVuZ3RoID0gdWludDgubGVuZ3RoIC0gZXh0cmFCeXRlczsgaSA8IGxlbmd0aDsgaSArPSAzKSB7XG5cdFx0XHR0ZW1wID0gKHVpbnQ4W2ldIDw8IDE2KSArICh1aW50OFtpICsgMV0gPDwgOCkgKyAodWludDhbaSArIDJdKVxuXHRcdFx0b3V0cHV0ICs9IHRyaXBsZXRUb0Jhc2U2NCh0ZW1wKVxuXHRcdH1cblxuXHRcdC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcblx0XHRzd2l0Y2ggKGV4dHJhQnl0ZXMpIHtcblx0XHRcdGNhc2UgMTpcblx0XHRcdFx0dGVtcCA9IHVpbnQ4W3VpbnQ4Lmxlbmd0aCAtIDFdXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUodGVtcCA+PiAyKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKCh0ZW1wIDw8IDQpICYgMHgzRilcblx0XHRcdFx0b3V0cHV0ICs9ICc9PSdcblx0XHRcdFx0YnJlYWtcblx0XHRcdGNhc2UgMjpcblx0XHRcdFx0dGVtcCA9ICh1aW50OFt1aW50OC5sZW5ndGggLSAyXSA8PCA4KSArICh1aW50OFt1aW50OC5sZW5ndGggLSAxXSlcblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSh0ZW1wID4+IDEwKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKCh0ZW1wID4+IDQpICYgMHgzRilcblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSgodGVtcCA8PCAyKSAmIDB4M0YpXG5cdFx0XHRcdG91dHB1dCArPSAnPSdcblx0XHRcdFx0YnJlYWtcblx0XHR9XG5cblx0XHRyZXR1cm4gb3V0cHV0XG5cdH1cblxuXHRleHBvcnRzLnRvQnl0ZUFycmF5ID0gYjY0VG9CeXRlQXJyYXlcblx0ZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gdWludDhUb0Jhc2U2NFxufSh0eXBlb2YgZXhwb3J0cyA9PT0gJ3VuZGVmaW5lZCcgPyAodGhpcy5iYXNlNjRqcyA9IHt9KSA6IGV4cG9ydHMpKVxuIiwiZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24oYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSxcbiAgICAgIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDEsXG4gICAgICBlTWF4ID0gKDEgPDwgZUxlbikgLSAxLFxuICAgICAgZUJpYXMgPSBlTWF4ID4+IDEsXG4gICAgICBuQml0cyA9IC03LFxuICAgICAgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwLFxuICAgICAgZCA9IGlzTEUgPyAtMSA6IDEsXG4gICAgICBzID0gYnVmZmVyW29mZnNldCArIGldO1xuXG4gIGkgKz0gZDtcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKTtcbiAgcyA+Pj0gKC1uQml0cyk7XG4gIG5CaXRzICs9IGVMZW47XG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSBlICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpO1xuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpO1xuICBlID4+PSAoLW5CaXRzKTtcbiAgbkJpdHMgKz0gbUxlbjtcbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IG0gKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCk7XG5cbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzO1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSk7XG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKTtcbiAgICBlID0gZSAtIGVCaWFzO1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pO1xufTtcblxuZXhwb3J0cy53cml0ZSA9IGZ1bmN0aW9uKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjLFxuICAgICAgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMSxcbiAgICAgIGVNYXggPSAoMSA8PCBlTGVuKSAtIDEsXG4gICAgICBlQmlhcyA9IGVNYXggPj4gMSxcbiAgICAgIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKSxcbiAgICAgIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKSxcbiAgICAgIGQgPSBpc0xFID8gMSA6IC0xLFxuICAgICAgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMDtcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKTtcblxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMDtcbiAgICBlID0gZU1heDtcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMik7XG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tO1xuICAgICAgYyAqPSAyO1xuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gYztcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrKztcbiAgICAgIGMgLz0gMjtcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwO1xuICAgICAgZSA9IGVNYXg7XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICh2YWx1ZSAqIGMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pO1xuICAgICAgZSA9IGUgKyBlQmlhcztcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pO1xuICAgICAgZSA9IDA7XG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCk7XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbTtcbiAgZUxlbiArPSBtTGVuO1xuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpO1xuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyODtcbn07XG4iLCJcbi8qKlxuICogaXNBcnJheVxuICovXG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxuLyoqXG4gKiB0b1N0cmluZ1xuICovXG5cbnZhciBzdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKipcbiAqIFdoZXRoZXIgb3Igbm90IHRoZSBnaXZlbiBgdmFsYFxuICogaXMgYW4gYXJyYXkuXG4gKlxuICogZXhhbXBsZTpcbiAqXG4gKiAgICAgICAgaXNBcnJheShbXSk7XG4gKiAgICAgICAgLy8gPiB0cnVlXG4gKiAgICAgICAgaXNBcnJheShhcmd1bWVudHMpO1xuICogICAgICAgIC8vID4gZmFsc2VcbiAqICAgICAgICBpc0FycmF5KCcnKTtcbiAqICAgICAgICAvLyA+IGZhbHNlXG4gKlxuICogQHBhcmFtIHttaXhlZH0gdmFsXG4gKiBAcmV0dXJuIHtib29sfVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcnJheSB8fCBmdW5jdGlvbiAodmFsKSB7XG4gIHJldHVybiAhISB2YWwgJiYgJ1tvYmplY3QgQXJyYXldJyA9PSBzdHIuY2FsbCh2YWwpO1xufTtcbiIsInZhciBpc0dMID0gcmVxdWlyZSgnaXMtd2ViZ2wtY29udGV4dCcpO1xudmFyIGdldEdMID0gcmVxdWlyZSgnd2ViZ2wtY29udGV4dCcpO1xudmFyIGRlYm91bmNlID0gcmVxdWlyZSgnZGVib3VuY2UnKTtcbnZhciBhZGRFdmVudCA9IHJlcXVpcmUoJ2FkZC1ldmVudC1saXN0ZW5lcicpO1xuXG5mdW5jdGlvbiBpc0NhbnZhc0NvbnRleHQob2JqKSB7XG4gICAgdmFyIGN0eDJkID0gdHlwZW9mIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCAhPT0gJ3VuZGVmaW5lZCcgJiYgb2JqIGluc3RhbmNlb2YgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEO1xuICAgIHJldHVybiBvYmogJiYgKGN0eDJkIHx8IGlzR0wob2JqKSk7XG59XG5cbmZ1bmN0aW9uIENhbnZhc0FwcChyZW5kZXIsIG9wdGlvbnMpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQ2FudmFzQXBwKSlcbiAgICAgICAgcmV0dXJuIG5ldyBDYW52YXNBcHAocmVuZGVyLCBvcHRpb25zKTtcblxuICAgIC8vYWxsb3cgb3B0aW9ucyB0byBiZSBwYXNzZWQgYXMgZmlyc3QgYXJndW1lbnRcbiAgICBpZiAodHlwZW9mIHJlbmRlciA9PT0gJ29iamVjdCcgJiYgcmVuZGVyKSB7XG4gICAgICAgIG9wdGlvbnMgPSByZW5kZXI7XG4gICAgICAgIHJlbmRlciA9IG51bGw7XG4gICAgfVxuXG4gICAgcmVuZGVyID0gdHlwZW9mIHJlbmRlciA9PT0gJ2Z1bmN0aW9uJyA/IHJlbmRlciA6IG9wdGlvbnMub25SZW5kZXI7XG5cbiAgICBvcHRpb25zID0gb3B0aW9uc3x8e307XG4gICAgb3B0aW9ucy5yZXRpbmEgPSB0eXBlb2Ygb3B0aW9ucy5yZXRpbmEgPT09IFwiYm9vbGVhblwiID8gb3B0aW9ucy5yZXRpbmEgOiB0cnVlO1xuICAgIFxuICAgIHZhciBoYXNXaWR0aCA9IHR5cGVvZiBvcHRpb25zLndpZHRoID09PSBcIm51bWJlclwiLCBcbiAgICAgICAgaGFzSGVpZ2h0ID0gdHlwZW9mIG9wdGlvbnMuaGVpZ2h0ID09PSBcIm51bWJlclwiO1xuXG4gICAgLy9pZiBlaXRoZXIgd2lkdGggb3IgaGVpZ2h0IGlzIHNwZWNpZmllZCwgZG9uJ3QgYXV0by1yZXNpemUgdG8gdGhlIHdpbmRvdy4uLlxuICAgIGlmIChoYXNXaWR0aCB8fCBoYXNIZWlnaHQpIFxuICAgICAgICBvcHRpb25zLmlnbm9yZVJlc2l6ZSA9IHRydWU7XG5cbiAgICBvcHRpb25zLndpZHRoID0gaGFzV2lkdGggPyBvcHRpb25zLndpZHRoIDogd2luZG93LmlubmVyV2lkdGg7XG4gICAgb3B0aW9ucy5oZWlnaHQgPSBoYXNIZWlnaHQgPyBvcHRpb25zLmhlaWdodCA6IHdpbmRvdy5pbm5lckhlaWdodDtcblxuICAgIHZhciBEUFIgPSBvcHRpb25zLnJldGluYSA/ICh3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpb3x8MSkgOiAxOyBcblxuICAgIC8vc2V0dXAgdGhlIGNhbnZhc1xuICAgIHZhciBjYW52YXMsXG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGF0dHJpYnMgPSBvcHRpb25zLmNvbnRleHRBdHRyaWJ1dGVzfHx7fTtcblxuICAgIHRoaXMuaXNXZWJHTCA9IGZhbHNlO1xuXG4gICAgLy9pZiB1c2VyIHByb3ZpZGVkIGEgY29udGV4dCBvYmplY3RcbiAgICBpZiAoaXNDYW52YXNDb250ZXh0KG9wdGlvbnMuY29udGV4dCkpIHtcbiAgICAgICAgY29udGV4dCA9IG9wdGlvbnMuY29udGV4dDtcbiAgICAgICAgY2FudmFzID0gY29udGV4dC5jYW52YXM7XG4gICAgfVxuXG4gICAgLy9vdGhlcndpc2UgYWxsb3cgZm9yIGEgc3RyaW5nIHRvIHNldCBvbmUgdXBcbiAgICBpZiAoIWNhbnZhcylcbiAgICAgICAgY2FudmFzID0gb3B0aW9ucy5jYW52YXMgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcblxuICAgIGNhbnZhcy53aWR0aCA9IG9wdGlvbnMud2lkdGggKiBEUFI7XG4gICAgY2FudmFzLmhlaWdodCA9IG9wdGlvbnMuaGVpZ2h0ICogRFBSO1xuXG4gICAgaWYgKCFjb250ZXh0KSB7XG4gICAgICAgIGlmIChvcHRpb25zLmNvbnRleHQgPT09IFwid2ViZ2xcIiB8fCBvcHRpb25zLmNvbnRleHQgPT09IFwiZXhwZXJpbWVudGFsLXdlYmdsXCIpIHtcbiAgICAgICAgICAgIGNvbnRleHQgPSBnZXRHTCh7IGNhbnZhczogY2FudmFzLCBhdHRyaWJ1dGVzOiBhdHRyaWJzIH0pO1xuICAgICAgICAgICAgaWYgKCFjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgXCJXZWJHTCBDb250ZXh0IE5vdCBTdXBwb3J0ZWQgLS0gdHJ5IGVuYWJsaW5nIGl0IG9yIHVzaW5nIGEgZGlmZmVyZW50IGJyb3dzZXJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChvcHRpb25zLmNvbnRleHR8fFwiMmRcIiwgYXR0cmlicyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmlzV2ViR0wgPSBpc0dMKGNvbnRleHQpO1xuXG4gICAgaWYgKG9wdGlvbnMucmV0aW5hKSB7XG4gICAgICAgIGNhbnZhcy5zdHlsZS53aWR0aCA9IG9wdGlvbnMud2lkdGggKyAncHgnO1xuICAgICAgICBjYW52YXMuc3R5bGUuaGVpZ2h0ID0gb3B0aW9ucy5oZWlnaHQgKyAncHgnO1xuICAgIH1cblxuICAgIHRoaXMucnVubmluZyA9IGZhbHNlO1xuICAgIHRoaXMud2lkdGggPSBvcHRpb25zLndpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gb3B0aW9ucy5oZWlnaHQ7XG4gICAgdGhpcy5jYW52YXMgPSBjYW52YXM7XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICB0aGlzLm9uUmVzaXplID0gb3B0aW9ucy5vblJlc2l6ZTtcbiAgICB0aGlzLl9EUFIgPSBEUFI7XG4gICAgdGhpcy5fcmV0aW5hID0gb3B0aW9ucy5yZXRpbmE7XG4gICAgdGhpcy5fb25jZSA9IG9wdGlvbnMub25jZTtcbiAgICB0aGlzLl9pZ25vcmVSZXNpemUgPSBvcHRpb25zLmlnbm9yZVJlc2l6ZTtcbiAgICB0aGlzLl9sYXN0RnJhbWUgPSBudWxsO1xuICAgIHRoaXMuX3RoZW4gPSBEYXRlLm5vdygpO1xuXG4gICAgLy9GUFMgY291bnRlclxuICAgIHRoaXMuZnBzID0gNjA7XG4gICAgdGhpcy5fZnJhbWVzID0gMDtcbiAgICB0aGlzLl9wcmV2VGltZSA9IHRoaXMuX3RoZW47XG5cbiAgICBpZiAoIXRoaXMuX2lnbm9yZVJlc2l6ZSkge1xuICAgICAgICBvcHRpb25zLnJlc2l6ZURlYm91bmNlID0gdHlwZW9mIG9wdGlvbnMucmVzaXplRGVib3VuY2UgPT09ICdudW1iZXInXG4gICAgICAgICAgICAgICAgICAgID8gb3B0aW9ucy5yZXNpemVEZWJvdW5jZSA6IDUwO1xuICAgICAgICBhZGRFdmVudCh3aW5kb3csIFwicmVzaXplXCIsIGRlYm91bmNlKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5yZXNpemUod2luZG93LmlubmVyV2lkdGgsIHdpbmRvdy5pbm5lckhlaWdodCk7XG4gICAgICAgIH0uYmluZCh0aGlzKSwgb3B0aW9ucy5yZXNpemVEZWJvdW5jZSwgZmFsc2UpKTtcblxuICAgICAgICBhZGRFdmVudCh3aW5kb3csIFwib3JpZW50YXRpb25jaGFuZ2VcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLnJlc2l6ZSh3aW5kb3cuaW5uZXJXaWR0aCwgd2luZG93LmlubmVySGVpZ2h0KTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHJlbmRlciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRoaXMub25SZW5kZXIgPSByZW5kZXIuYmluZCh0aGlzKTsgICBcbiAgICB9IGVsc2Uge1xuICAgICAgICAvL2R1bW15IHJlbmRlciBmdW5jdGlvblxuICAgICAgICB0aGlzLm9uUmVuZGVyID0gZnVuY3Rpb24gKGNvbnRleHQsIHdpZHRoLCBoZWlnaHQsIGR0KSB7IH07XG4gICAgfVxuXG4gICAgdGhpcy5yZW5kZXJPbmNlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICB2YXIgZHQgPSAobm93LXRoaXMuX3RoZW4pO1xuXG4gICAgICAgIHRoaXMuX2ZyYW1lcysrO1xuICAgICAgICBpZiAobm93ID4gdGhpcy5fcHJldlRpbWUgKyAxMDAwKSB7XG4gICAgICAgICAgICB0aGlzLmZwcyA9IE1hdGgucm91bmQoKHRoaXMuX2ZyYW1lcyAqIDEwMDApIC8gKG5vdyAtIHRoaXMuX3ByZXZUaW1lKSk7XG5cbiAgICAgICAgICAgIHRoaXMuX3ByZXZUaW1lID0gbm93O1xuICAgICAgICAgICAgdGhpcy5fZnJhbWVzID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5pc1dlYkdMKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHQuc2F2ZSgpO1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0LnNjYWxlKHRoaXMuX0RQUiwgdGhpcy5fRFBSKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC52aWV3cG9ydCgwLCAwLCB0aGlzLndpZHRoICogdGhpcy5fRFBSLCB0aGlzLmhlaWdodCAqIHRoaXMuX0RQUik7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHRoaXMub25SZW5kZXIodGhpcy5jb250ZXh0LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgZHQpO1xuXG4gICAgICAgIGlmICghdGhpcy5pc1dlYkdMKVxuICAgICAgICAgICAgdGhpcy5jb250ZXh0LnJlc3RvcmUoKTtcblxuICAgICAgICB0aGlzLl90aGVuID0gbm93O1xuICAgIH07XG5cbiAgICB0aGlzLl9yZW5kZXJIYW5kbGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5ydW5uaW5nKSBcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgXG4gICAgICAgIGlmICghdGhpcy5fb25jZSkge1xuICAgICAgICAgICAgdGhpcy5fbGFzdEZyYW1lID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuX3JlbmRlckhhbmRsZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5yZW5kZXJPbmNlKCk7XG4gICAgfS5iaW5kKHRoaXMpO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLm9uUmVhZHkgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBvcHRpb25zLm9uUmVhZHkuY2FsbCh0aGlzLCBjb250ZXh0LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQ2FudmFzQXBwLnByb3RvdHlwZSwgJ3JldGluYUVuYWJsZWQnLCB7XG5cbiAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgdGhpcy5fcmV0aW5hID0gdjtcbiAgICAgICAgdGhpcy5fRFBSID0gdGhpcy5fcmV0aW5hID8gKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvfHwxKSA6IDE7XG4gICAgICAgIHRoaXMucmVzaXplKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICB9LFxuXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JldGluYTtcbiAgICB9XG59KTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KENhbnZhc0FwcC5wcm90b3R5cGUsICdkZXZpY2VXaWR0aCcsIHtcblxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpZHRoICogdGhpcy5fRFBSO1xuICAgIH1cbn0pO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQ2FudmFzQXBwLnByb3RvdHlwZSwgJ2RldmljZUhlaWdodCcsIHtcblxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhlaWdodCAqIHRoaXMuX0RQUjtcbiAgICB9XG59KTtcblxuQ2FudmFzQXBwLnByb3RvdHlwZS5yZXNldEZQUyA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2ZyYW1lcyA9IDA7XG4gICAgdGhpcy5fcHJldlRpbWUgPSBEYXRlLm5vdygpO1xuICAgIHRoaXMuX3RoZW4gPSB0aGlzLl9wcmV2VGltZTtcbiAgICB0aGlzLmZwcyA9IDYwO1xufTtcblxuQ2FudmFzQXBwLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLnJ1bm5pbmcpXG4gICAgICAgIHJldHVybjtcbiAgICBcbiAgICBpZiAodGhpcy5fbGFzdEZyYW1lKSBcbiAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5fbGFzdEZyYW1lKTtcblxuICAgIC8vcmVzZXQgRlBTIGNvdW50ZXJcbiAgICB0aGlzLnJlc2V0RlBTKCk7XG5cbiAgICB0aGlzLnJ1bm5pbmcgPSB0cnVlO1xuICAgIHRoaXMuX2xhc3RGcmFtZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLl9yZW5kZXJIYW5kbGVyKTtcbn07XG5cbkNhbnZhc0FwcC5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9sYXN0RnJhbWUpIHtcbiAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5fbGFzdEZyYW1lKTtcbiAgICAgICAgdGhpcy5fbGFzdEZyYW1lID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5ydW5uaW5nID0gZmFsc2U7XG59O1xuXG5DYW52YXNBcHAucHJvdG90eXBlLnJlc2l6ZSA9IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcbiAgICB2YXIgY2FudmFzID0gdGhpcy5jYW52YXM7XG5cbiAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgY2FudmFzLndpZHRoID0gdGhpcy53aWR0aCAqIHRoaXMuX0RQUjtcbiAgICBjYW52YXMuaGVpZ2h0ID0gdGhpcy5oZWlnaHQgKiB0aGlzLl9EUFI7XG5cbiAgICBpZiAodGhpcy5fcmV0aW5hKSB7XG4gICAgICAgIGNhbnZhcy5zdHlsZS53aWR0aCA9IHRoaXMud2lkdGggKyAncHgnO1xuICAgICAgICBjYW52YXMuc3R5bGUuaGVpZ2h0ID0gdGhpcy5oZWlnaHQgKyAncHgnO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9vbmNlKVxuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5fcmVuZGVySGFuZGxlcik7XG4gICAgaWYgKHR5cGVvZiB0aGlzLm9uUmVzaXplID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIHRoaXMub25SZXNpemUodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDYW52YXNBcHA7IiwiYWRkRXZlbnRMaXN0ZW5lci5yZW1vdmVFdmVudExpc3RlbmVyID0gcmVtb3ZlRXZlbnRMaXN0ZW5lclxuYWRkRXZlbnRMaXN0ZW5lci5hZGRFdmVudExpc3RlbmVyID0gYWRkRXZlbnRMaXN0ZW5lclxuXG5tb2R1bGUuZXhwb3J0cyA9IGFkZEV2ZW50TGlzdGVuZXJcblxudmFyIEV2ZW50cyA9IG51bGxcblxuZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcihlbCwgZXZlbnROYW1lLCBsaXN0ZW5lciwgdXNlQ2FwdHVyZSkge1xuICBFdmVudHMgPSBFdmVudHMgfHwgKFxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIgP1xuICAgIHthZGQ6IHN0ZEF0dGFjaCwgcm06IHN0ZERldGFjaH0gOlxuICAgIHthZGQ6IG9sZElFQXR0YWNoLCBybTogb2xkSUVEZXRhY2h9XG4gIClcbiAgXG4gIHJldHVybiBFdmVudHMuYWRkKGVsLCBldmVudE5hbWUsIGxpc3RlbmVyLCB1c2VDYXB0dXJlKVxufVxuXG5mdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVyKGVsLCBldmVudE5hbWUsIGxpc3RlbmVyLCB1c2VDYXB0dXJlKSB7XG4gIEV2ZW50cyA9IEV2ZW50cyB8fCAoXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lciA/XG4gICAge2FkZDogc3RkQXR0YWNoLCBybTogc3RkRGV0YWNofSA6XG4gICAge2FkZDogb2xkSUVBdHRhY2gsIHJtOiBvbGRJRURldGFjaH1cbiAgKVxuICBcbiAgcmV0dXJuIEV2ZW50cy5ybShlbCwgZXZlbnROYW1lLCBsaXN0ZW5lciwgdXNlQ2FwdHVyZSlcbn1cblxuZnVuY3Rpb24gc3RkQXR0YWNoKGVsLCBldmVudE5hbWUsIGxpc3RlbmVyLCB1c2VDYXB0dXJlKSB7XG4gIGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lciwgdXNlQ2FwdHVyZSlcbn1cblxuZnVuY3Rpb24gc3RkRGV0YWNoKGVsLCBldmVudE5hbWUsIGxpc3RlbmVyLCB1c2VDYXB0dXJlKSB7XG4gIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lciwgdXNlQ2FwdHVyZSlcbn1cblxuZnVuY3Rpb24gb2xkSUVBdHRhY2goZWwsIGV2ZW50TmFtZSwgbGlzdGVuZXIsIHVzZUNhcHR1cmUpIHtcbiAgaWYodXNlQ2FwdHVyZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IHVzZUNhcHR1cmUgaW4gb2xkSUUnKVxuICB9XG5cbiAgZWwuYXR0YWNoRXZlbnQoJ29uJyArIGV2ZW50TmFtZSwgbGlzdGVuZXIpXG59XG5cbmZ1bmN0aW9uIG9sZElFRGV0YWNoKGVsLCBldmVudE5hbWUsIGxpc3RlbmVyLCB1c2VDYXB0dXJlKSB7XG4gIGVsLmRldGFjaEV2ZW50KCdvbicgKyBldmVudE5hbWUsIGxpc3RlbmVyKVxufVxuIiwiXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIG5vdyA9IHJlcXVpcmUoJ2RhdGUtbm93Jyk7XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uLCB0aGF0LCBhcyBsb25nIGFzIGl0IGNvbnRpbnVlcyB0byBiZSBpbnZva2VkLCB3aWxsIG5vdFxuICogYmUgdHJpZ2dlcmVkLiBUaGUgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgaXQgc3RvcHMgYmVpbmcgY2FsbGVkIGZvclxuICogTiBtaWxsaXNlY29uZHMuIElmIGBpbW1lZGlhdGVgIGlzIHBhc3NlZCwgdHJpZ2dlciB0aGUgZnVuY3Rpb24gb24gdGhlXG4gKiBsZWFkaW5nIGVkZ2UsIGluc3RlYWQgb2YgdGhlIHRyYWlsaW5nLlxuICpcbiAqIEBzb3VyY2UgdW5kZXJzY29yZS5qc1xuICogQHNlZSBodHRwOi8vdW5zY3JpcHRhYmxlLmNvbS8yMDA5LzAzLzIwL2RlYm91bmNpbmctamF2YXNjcmlwdC1tZXRob2RzL1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuY3Rpb24gdG8gd3JhcFxuICogQHBhcmFtIHtOdW1iZXJ9IHRpbWVvdXQgaW4gbXMgKGAxMDBgKVxuICogQHBhcmFtIHtCb29sZWFufSB3aGV0aGVyIHRvIGV4ZWN1dGUgYXQgdGhlIGJlZ2lubmluZyAoYGZhbHNlYClcbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkZWJvdW5jZShmdW5jLCB3YWl0LCBpbW1lZGlhdGUpe1xuICB2YXIgdGltZW91dCwgYXJncywgY29udGV4dCwgdGltZXN0YW1wLCByZXN1bHQ7XG4gIGlmIChudWxsID09IHdhaXQpIHdhaXQgPSAxMDA7XG5cbiAgZnVuY3Rpb24gbGF0ZXIoKSB7XG4gICAgdmFyIGxhc3QgPSBub3coKSAtIHRpbWVzdGFtcDtcblxuICAgIGlmIChsYXN0IDwgd2FpdCAmJiBsYXN0ID4gMCkge1xuICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQgLSBsYXN0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICBpZiAoIWltbWVkaWF0ZSkge1xuICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICBpZiAoIXRpbWVvdXQpIGNvbnRleHQgPSBhcmdzID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIGRlYm91bmNlZCgpIHtcbiAgICBjb250ZXh0ID0gdGhpcztcbiAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgIHRpbWVzdGFtcCA9IG5vdygpO1xuICAgIHZhciBjYWxsTm93ID0gaW1tZWRpYXRlICYmICF0aW1lb3V0O1xuICAgIGlmICghdGltZW91dCkgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQpO1xuICAgIGlmIChjYWxsTm93KSB7XG4gICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBEYXRlLm5vdyB8fCBub3dcblxuZnVuY3Rpb24gbm93KCkge1xuICAgIHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihjdHgpIHtcblx0aWYgKCFjdHgpIHJldHVybiBmYWxzZVxuXHR2YXIgZ2wgPSBjdHhcblx0Ly9jb21wYXRpYmlsaXR5IHdpdGggQ2hyb21lIFdlYkdMIEluc3BlY3RvciBBZGRvblxuXHRpZiAodHlwZW9mIGN0eC5yYXdnbCAhPT0gJ3VuZGVmaW5lZCcpXG5cdFx0Z2wgPSBjdHgucmF3Z2xcblx0aWYgKHR5cGVvZiBXZWJHTFJlbmRlcmluZ0NvbnRleHQgIT09ICd1bmRlZmluZWQnICYmIGdsIGluc3RhbmNlb2YgV2ViR0xSZW5kZXJpbmdDb250ZXh0KVxuXHRcdHJldHVybiB0cnVlXG5cdHJldHVybiBmYWxzZVxufSIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob3B0cykge1xuICAgIG9wdHMgPSBvcHRzfHx7fTtcbiAgICB2YXIgY2FudmFzID0gb3B0cy5jYW52YXMgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICBpZiAodHlwZW9mIG9wdHMud2lkdGggPT09IFwibnVtYmVyXCIpXG4gICAgICAgIGNhbnZhcy53aWR0aCA9IG9wdHMud2lkdGg7XG4gICAgaWYgKHR5cGVvZiBvcHRzLmhlaWdodCA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IG9wdHMuaGVpZ2h0O1xuICAgIFxuICAgIHZhciBhdHRyaWJzID0gKG9wdHMuYXR0cmlidXRlcyB8fCBvcHRzLmF0dHJpYnMgfHwge30pO1xuICAgIHRyeSB7XG4gICAgICAgIGdsID0gKGNhbnZhcy5nZXRDb250ZXh0KCd3ZWJnbCcsIGF0dHJpYnMpIHx8IGNhbnZhcy5nZXRDb250ZXh0KCdleHBlcmltZW50YWwtd2ViZ2wnLCBhdHRyaWJzKSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBnbCA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiBnbDtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBjbGFtcFxuXG5mdW5jdGlvbiBjbGFtcCh2YWx1ZSwgbWluLCBtYXgpIHtcbiAgcmV0dXJuIG1pbiA8IG1heFxuICAgID8gKHZhbHVlIDwgbWluID8gbWluIDogdmFsdWUgPiBtYXggPyBtYXggOiB2YWx1ZSlcbiAgICA6ICh2YWx1ZSA8IG1heCA/IG1heCA6IHZhbHVlID4gbWluID8gbWluIDogdmFsdWUpXG59XG4iLCIvKiFcbiAgKiBkb21yZWFkeSAoYykgRHVzdGluIERpYXogMjAxNCAtIExpY2Vuc2UgTUlUXG4gICovXG4hZnVuY3Rpb24gKG5hbWUsIGRlZmluaXRpb24pIHtcblxuICBpZiAodHlwZW9mIG1vZHVsZSAhPSAndW5kZWZpbmVkJykgbW9kdWxlLmV4cG9ydHMgPSBkZWZpbml0aW9uKClcbiAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBkZWZpbmUuYW1kID09ICdvYmplY3QnKSBkZWZpbmUoZGVmaW5pdGlvbilcbiAgZWxzZSB0aGlzW25hbWVdID0gZGVmaW5pdGlvbigpXG5cbn0oJ2RvbXJlYWR5JywgZnVuY3Rpb24gKCkge1xuXG4gIHZhciBmbnMgPSBbXSwgbGlzdGVuZXJcbiAgICAsIGRvYyA9IGRvY3VtZW50XG4gICAgLCBoYWNrID0gZG9jLmRvY3VtZW50RWxlbWVudC5kb1Njcm9sbFxuICAgICwgZG9tQ29udGVudExvYWRlZCA9ICdET01Db250ZW50TG9hZGVkJ1xuICAgICwgbG9hZGVkID0gKGhhY2sgPyAvXmxvYWRlZHxeYy8gOiAvXmxvYWRlZHxeaXxeYy8pLnRlc3QoZG9jLnJlYWR5U3RhdGUpXG5cblxuICBpZiAoIWxvYWRlZClcbiAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoZG9tQ29udGVudExvYWRlZCwgbGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoZG9tQ29udGVudExvYWRlZCwgbGlzdGVuZXIpXG4gICAgbG9hZGVkID0gMVxuICAgIHdoaWxlIChsaXN0ZW5lciA9IGZucy5zaGlmdCgpKSBsaXN0ZW5lcigpXG4gIH0pXG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChmbikge1xuICAgIGxvYWRlZCA/IGZuKCkgOiBmbnMucHVzaChmbilcbiAgfVxuXG59KTtcbiIsIm1vZHVsZS5leHBvcnRzID0gaWRlbnRpdHk7XG5cbi8qKlxuICogU2V0IGEgbWF0NCB0byB0aGUgaWRlbnRpdHkgbWF0cml4XG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZnVuY3Rpb24gaWRlbnRpdHkob3V0KSB7XG4gICAgb3V0WzBdID0gMTtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSAwO1xuICAgIG91dFs1XSA9IDE7XG4gICAgb3V0WzZdID0gMDtcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9IDA7XG4gICAgb3V0WzldID0gMDtcbiAgICBvdXRbMTBdID0gMTtcbiAgICBvdXRbMTFdID0gMDtcbiAgICBvdXRbMTJdID0gMDtcbiAgICBvdXRbMTNdID0gMDtcbiAgICBvdXRbMTRdID0gMDtcbiAgICBvdXRbMTVdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IG11bHRpcGx5O1xuXG4vKipcbiAqIE11bHRpcGxpZXMgdHdvIG1hdDQnc1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7bWF0NH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZnVuY3Rpb24gbXVsdGlwbHkob3V0LCBhLCBiKSB7XG4gICAgdmFyIGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sIGEwMyA9IGFbM10sXG4gICAgICAgIGExMCA9IGFbNF0sIGExMSA9IGFbNV0sIGExMiA9IGFbNl0sIGExMyA9IGFbN10sXG4gICAgICAgIGEyMCA9IGFbOF0sIGEyMSA9IGFbOV0sIGEyMiA9IGFbMTBdLCBhMjMgPSBhWzExXSxcbiAgICAgICAgYTMwID0gYVsxMl0sIGEzMSA9IGFbMTNdLCBhMzIgPSBhWzE0XSwgYTMzID0gYVsxNV07XG5cbiAgICAvLyBDYWNoZSBvbmx5IHRoZSBjdXJyZW50IGxpbmUgb2YgdGhlIHNlY29uZCBtYXRyaXhcbiAgICB2YXIgYjAgID0gYlswXSwgYjEgPSBiWzFdLCBiMiA9IGJbMl0sIGIzID0gYlszXTsgIFxuICAgIG91dFswXSA9IGIwKmEwMCArIGIxKmExMCArIGIyKmEyMCArIGIzKmEzMDtcbiAgICBvdXRbMV0gPSBiMCphMDEgKyBiMSphMTEgKyBiMiphMjEgKyBiMyphMzE7XG4gICAgb3V0WzJdID0gYjAqYTAyICsgYjEqYTEyICsgYjIqYTIyICsgYjMqYTMyO1xuICAgIG91dFszXSA9IGIwKmEwMyArIGIxKmExMyArIGIyKmEyMyArIGIzKmEzMztcblxuICAgIGIwID0gYls0XTsgYjEgPSBiWzVdOyBiMiA9IGJbNl07IGIzID0gYls3XTtcbiAgICBvdXRbNF0gPSBiMCphMDAgKyBiMSphMTAgKyBiMiphMjAgKyBiMyphMzA7XG4gICAgb3V0WzVdID0gYjAqYTAxICsgYjEqYTExICsgYjIqYTIxICsgYjMqYTMxO1xuICAgIG91dFs2XSA9IGIwKmEwMiArIGIxKmExMiArIGIyKmEyMiArIGIzKmEzMjtcbiAgICBvdXRbN10gPSBiMCphMDMgKyBiMSphMTMgKyBiMiphMjMgKyBiMyphMzM7XG5cbiAgICBiMCA9IGJbOF07IGIxID0gYls5XTsgYjIgPSBiWzEwXTsgYjMgPSBiWzExXTtcbiAgICBvdXRbOF0gPSBiMCphMDAgKyBiMSphMTAgKyBiMiphMjAgKyBiMyphMzA7XG4gICAgb3V0WzldID0gYjAqYTAxICsgYjEqYTExICsgYjIqYTIxICsgYjMqYTMxO1xuICAgIG91dFsxMF0gPSBiMCphMDIgKyBiMSphMTIgKyBiMiphMjIgKyBiMyphMzI7XG4gICAgb3V0WzExXSA9IGIwKmEwMyArIGIxKmExMyArIGIyKmEyMyArIGIzKmEzMztcblxuICAgIGIwID0gYlsxMl07IGIxID0gYlsxM107IGIyID0gYlsxNF07IGIzID0gYlsxNV07XG4gICAgb3V0WzEyXSA9IGIwKmEwMCArIGIxKmExMCArIGIyKmEyMCArIGIzKmEzMDtcbiAgICBvdXRbMTNdID0gYjAqYTAxICsgYjEqYTExICsgYjIqYTIxICsgYjMqYTMxO1xuICAgIG91dFsxNF0gPSBiMCphMDIgKyBiMSphMTIgKyBiMiphMjIgKyBiMyphMzI7XG4gICAgb3V0WzE1XSA9IGIwKmEwMyArIGIxKmExMyArIGIyKmEyMyArIGIzKmEzMztcbiAgICByZXR1cm4gb3V0O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IHNjYWxlO1xuXG4vKipcbiAqIFNjYWxlcyB0aGUgbWF0NCBieSB0aGUgZGltZW5zaW9ucyBpbiB0aGUgZ2l2ZW4gdmVjM1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIG1hdHJpeCB0byBzY2FsZVxuICogQHBhcmFtIHt2ZWMzfSB2IHRoZSB2ZWMzIHRvIHNjYWxlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqKi9cbmZ1bmN0aW9uIHNjYWxlKG91dCwgYSwgdikge1xuICAgIHZhciB4ID0gdlswXSwgeSA9IHZbMV0sIHogPSB2WzJdO1xuXG4gICAgb3V0WzBdID0gYVswXSAqIHg7XG4gICAgb3V0WzFdID0gYVsxXSAqIHg7XG4gICAgb3V0WzJdID0gYVsyXSAqIHg7XG4gICAgb3V0WzNdID0gYVszXSAqIHg7XG4gICAgb3V0WzRdID0gYVs0XSAqIHk7XG4gICAgb3V0WzVdID0gYVs1XSAqIHk7XG4gICAgb3V0WzZdID0gYVs2XSAqIHk7XG4gICAgb3V0WzddID0gYVs3XSAqIHk7XG4gICAgb3V0WzhdID0gYVs4XSAqIHo7XG4gICAgb3V0WzldID0gYVs5XSAqIHo7XG4gICAgb3V0WzEwXSA9IGFbMTBdICogejtcbiAgICBvdXRbMTFdID0gYVsxMV0gKiB6O1xuICAgIG91dFsxMl0gPSBhWzEyXTtcbiAgICBvdXRbMTNdID0gYVsxM107XG4gICAgb3V0WzE0XSA9IGFbMTRdO1xuICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgICByZXR1cm4gb3V0O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IHRyYW5zbGF0ZTtcblxuLyoqXG4gKiBUcmFuc2xhdGUgYSBtYXQ0IGJ5IHRoZSBnaXZlbiB2ZWN0b3JcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBtYXRyaXggdG8gdHJhbnNsYXRlXG4gKiBAcGFyYW0ge3ZlYzN9IHYgdmVjdG9yIHRvIHRyYW5zbGF0ZSBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5mdW5jdGlvbiB0cmFuc2xhdGUob3V0LCBhLCB2KSB7XG4gICAgdmFyIHggPSB2WzBdLCB5ID0gdlsxXSwgeiA9IHZbMl0sXG4gICAgICAgIGEwMCwgYTAxLCBhMDIsIGEwMyxcbiAgICAgICAgYTEwLCBhMTEsIGExMiwgYTEzLFxuICAgICAgICBhMjAsIGEyMSwgYTIyLCBhMjM7XG5cbiAgICBpZiAoYSA9PT0gb3V0KSB7XG4gICAgICAgIG91dFsxMl0gPSBhWzBdICogeCArIGFbNF0gKiB5ICsgYVs4XSAqIHogKyBhWzEyXTtcbiAgICAgICAgb3V0WzEzXSA9IGFbMV0gKiB4ICsgYVs1XSAqIHkgKyBhWzldICogeiArIGFbMTNdO1xuICAgICAgICBvdXRbMTRdID0gYVsyXSAqIHggKyBhWzZdICogeSArIGFbMTBdICogeiArIGFbMTRdO1xuICAgICAgICBvdXRbMTVdID0gYVszXSAqIHggKyBhWzddICogeSArIGFbMTFdICogeiArIGFbMTVdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGEwMCA9IGFbMF07IGEwMSA9IGFbMV07IGEwMiA9IGFbMl07IGEwMyA9IGFbM107XG4gICAgICAgIGExMCA9IGFbNF07IGExMSA9IGFbNV07IGExMiA9IGFbNl07IGExMyA9IGFbN107XG4gICAgICAgIGEyMCA9IGFbOF07IGEyMSA9IGFbOV07IGEyMiA9IGFbMTBdOyBhMjMgPSBhWzExXTtcblxuICAgICAgICBvdXRbMF0gPSBhMDA7IG91dFsxXSA9IGEwMTsgb3V0WzJdID0gYTAyOyBvdXRbM10gPSBhMDM7XG4gICAgICAgIG91dFs0XSA9IGExMDsgb3V0WzVdID0gYTExOyBvdXRbNl0gPSBhMTI7IG91dFs3XSA9IGExMztcbiAgICAgICAgb3V0WzhdID0gYTIwOyBvdXRbOV0gPSBhMjE7IG91dFsxMF0gPSBhMjI7IG91dFsxMV0gPSBhMjM7XG5cbiAgICAgICAgb3V0WzEyXSA9IGEwMCAqIHggKyBhMTAgKiB5ICsgYTIwICogeiArIGFbMTJdO1xuICAgICAgICBvdXRbMTNdID0gYTAxICogeCArIGExMSAqIHkgKyBhMjEgKiB6ICsgYVsxM107XG4gICAgICAgIG91dFsxNF0gPSBhMDIgKiB4ICsgYTEyICogeSArIGEyMiAqIHogKyBhWzE0XTtcbiAgICAgICAgb3V0WzE1XSA9IGEwMyAqIHggKyBhMTMgKiB5ICsgYTIzICogeiArIGFbMTVdO1xuICAgIH1cblxuICAgIHJldHVybiBvdXQ7XG59OyIsIlwidXNlIHN0cmljdFwiXG5cbnZhciBjb21waWxlID0gcmVxdWlyZShcImN3aXNlLWNvbXBpbGVyXCIpXG5cbnZhciBFbXB0eVByb2MgPSB7XG4gIGJvZHk6IFwiXCIsXG4gIGFyZ3M6IFtdLFxuICB0aGlzVmFyczogW10sXG4gIGxvY2FsVmFyczogW11cbn1cblxuZnVuY3Rpb24gZml4dXAoeCkge1xuICBpZigheCkge1xuICAgIHJldHVybiBFbXB0eVByb2NcbiAgfVxuICBmb3IodmFyIGk9MDsgaTx4LmFyZ3MubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYSA9IHguYXJnc1tpXVxuICAgIGlmKGkgPT09IDApIHtcbiAgICAgIHguYXJnc1tpXSA9IHtuYW1lOiBhLCBsdmFsdWU6dHJ1ZSwgcnZhbHVlOiAhIXgucnZhbHVlLCBjb3VudDp4LmNvdW50fHwxIH1cbiAgICB9IGVsc2Uge1xuICAgICAgeC5hcmdzW2ldID0ge25hbWU6IGEsIGx2YWx1ZTpmYWxzZSwgcnZhbHVlOnRydWUsIGNvdW50OiAxfVxuICAgIH1cbiAgfVxuICBpZigheC50aGlzVmFycykge1xuICAgIHgudGhpc1ZhcnMgPSBbXVxuICB9XG4gIGlmKCF4LmxvY2FsVmFycykge1xuICAgIHgubG9jYWxWYXJzID0gW11cbiAgfVxuICByZXR1cm4geFxufVxuXG5mdW5jdGlvbiBwY29tcGlsZSh1c2VyX2FyZ3MpIHtcbiAgcmV0dXJuIGNvbXBpbGUoe1xuICAgIGFyZ3M6ICAgICB1c2VyX2FyZ3MuYXJncyxcbiAgICBwcmU6ICAgICAgZml4dXAodXNlcl9hcmdzLnByZSksXG4gICAgYm9keTogICAgIGZpeHVwKHVzZXJfYXJncy5ib2R5KSxcbiAgICBwb3N0OiAgICAgZml4dXAodXNlcl9hcmdzLnByb2MpLFxuICAgIGZ1bmNOYW1lOiB1c2VyX2FyZ3MuZnVuY05hbWVcbiAgfSlcbn1cblxuZnVuY3Rpb24gbWFrZU9wKHVzZXJfYXJncykge1xuICB2YXIgYXJncyA9IFtdXG4gIGZvcih2YXIgaT0wOyBpPHVzZXJfYXJncy5hcmdzLmxlbmd0aDsgKytpKSB7XG4gICAgYXJncy5wdXNoKFwiYVwiK2kpXG4gIH1cbiAgdmFyIHdyYXBwZXIgPSBuZXcgRnVuY3Rpb24oXCJQXCIsIFtcbiAgICBcInJldHVybiBmdW5jdGlvbiBcIiwgdXNlcl9hcmdzLmZ1bmNOYW1lLCBcIl9uZGFycmF5b3BzKFwiLCBhcmdzLmpvaW4oXCIsXCIpLCBcIikge1AoXCIsIGFyZ3Muam9pbihcIixcIiksIFwiKTtyZXR1cm4gYTB9XCJcbiAgXS5qb2luKFwiXCIpKVxuICByZXR1cm4gd3JhcHBlcihwY29tcGlsZSh1c2VyX2FyZ3MpKVxufVxuXG52YXIgYXNzaWduX29wcyA9IHtcbiAgYWRkOiAgXCIrXCIsXG4gIHN1YjogIFwiLVwiLFxuICBtdWw6ICBcIipcIixcbiAgZGl2OiAgXCIvXCIsXG4gIG1vZDogIFwiJVwiLFxuICBiYW5kOiBcIiZcIixcbiAgYm9yOiAgXCJ8XCIsXG4gIGJ4b3I6IFwiXlwiLFxuICBsc2hpZnQ6IFwiPDxcIixcbiAgcnNoaWZ0OiBcIj4+XCIsXG4gIHJyc2hpZnQ6IFwiPj4+XCJcbn1cbjsoZnVuY3Rpb24oKXtcbiAgZm9yKHZhciBpZCBpbiBhc3NpZ25fb3BzKSB7XG4gICAgdmFyIG9wID0gYXNzaWduX29wc1tpZF1cbiAgICBleHBvcnRzW2lkXSA9IG1ha2VPcCh7XG4gICAgICBhcmdzOiBbXCJhcnJheVwiLFwiYXJyYXlcIixcImFycmF5XCJdLFxuICAgICAgYm9keToge2FyZ3M6W1wiYVwiLFwiYlwiLFwiY1wiXSxcbiAgICAgICAgICAgICBib2R5OiBcImE9YlwiK29wK1wiY1wifSxcbiAgICAgIGZ1bmNOYW1lOiBpZFxuICAgIH0pXG4gICAgZXhwb3J0c1tpZCtcImVxXCJdID0gbWFrZU9wKHtcbiAgICAgIGFyZ3M6IFtcImFycmF5XCIsXCJhcnJheVwiXSxcbiAgICAgIGJvZHk6IHthcmdzOltcImFcIixcImJcIl0sXG4gICAgICAgICAgICAgYm9keTpcImFcIitvcCtcIj1iXCJ9LFxuICAgICAgcnZhbHVlOiB0cnVlLFxuICAgICAgZnVuY05hbWU6IGlkK1wiZXFcIlxuICAgIH0pXG4gICAgZXhwb3J0c1tpZCtcInNcIl0gPSBtYWtlT3Aoe1xuICAgICAgYXJnczogW1wiYXJyYXlcIiwgXCJhcnJheVwiLCBcInNjYWxhclwiXSxcbiAgICAgIGJvZHk6IHthcmdzOltcImFcIixcImJcIixcInNcIl0sXG4gICAgICAgICAgICAgYm9keTpcImE9YlwiK29wK1wic1wifSxcbiAgICAgIGZ1bmNOYW1lOiBpZCtcInNcIlxuICAgIH0pXG4gICAgZXhwb3J0c1tpZCtcInNlcVwiXSA9IG1ha2VPcCh7XG4gICAgICBhcmdzOiBbXCJhcnJheVwiLFwic2NhbGFyXCJdLFxuICAgICAgYm9keToge2FyZ3M6W1wiYVwiLFwic1wiXSxcbiAgICAgICAgICAgICBib2R5OlwiYVwiK29wK1wiPXNcIn0sXG4gICAgICBydmFsdWU6IHRydWUsXG4gICAgICBmdW5jTmFtZTogaWQrXCJzZXFcIlxuICAgIH0pXG4gIH1cbn0pKCk7XG5cbnZhciB1bmFyeV9vcHMgPSB7XG4gIG5vdDogXCIhXCIsXG4gIGJub3Q6IFwiflwiLFxuICBuZWc6IFwiLVwiLFxuICByZWNpcDogXCIxLjAvXCJcbn1cbjsoZnVuY3Rpb24oKXtcbiAgZm9yKHZhciBpZCBpbiB1bmFyeV9vcHMpIHtcbiAgICB2YXIgb3AgPSB1bmFyeV9vcHNbaWRdXG4gICAgZXhwb3J0c1tpZF0gPSBtYWtlT3Aoe1xuICAgICAgYXJnczogW1wiYXJyYXlcIiwgXCJhcnJheVwiXSxcbiAgICAgIGJvZHk6IHthcmdzOltcImFcIixcImJcIl0sXG4gICAgICAgICAgICAgYm9keTpcImE9XCIrb3ArXCJiXCJ9LFxuICAgICAgZnVuY05hbWU6IGlkXG4gICAgfSlcbiAgICBleHBvcnRzW2lkK1wiZXFcIl0gPSBtYWtlT3Aoe1xuICAgICAgYXJnczogW1wiYXJyYXlcIl0sXG4gICAgICBib2R5OiB7YXJnczpbXCJhXCJdLFxuICAgICAgICAgICAgIGJvZHk6XCJhPVwiK29wK1wiYVwifSxcbiAgICAgIHJ2YWx1ZTogdHJ1ZSxcbiAgICAgIGNvdW50OiAyLFxuICAgICAgZnVuY05hbWU6IGlkK1wiZXFcIlxuICAgIH0pXG4gIH1cbn0pKCk7XG5cbnZhciBiaW5hcnlfb3BzID0ge1xuICBhbmQ6IFwiJiZcIixcbiAgb3I6IFwifHxcIixcbiAgZXE6IFwiPT09XCIsXG4gIG5lcTogXCIhPT1cIixcbiAgbHQ6IFwiPFwiLFxuICBndDogXCI+XCIsXG4gIGxlcTogXCI8PVwiLFxuICBnZXE6IFwiPj1cIlxufVxuOyhmdW5jdGlvbigpIHtcbiAgZm9yKHZhciBpZCBpbiBiaW5hcnlfb3BzKSB7XG4gICAgdmFyIG9wID0gYmluYXJ5X29wc1tpZF1cbiAgICBleHBvcnRzW2lkXSA9IG1ha2VPcCh7XG4gICAgICBhcmdzOiBbXCJhcnJheVwiLFwiYXJyYXlcIixcImFycmF5XCJdLFxuICAgICAgYm9keToge2FyZ3M6W1wiYVwiLCBcImJcIiwgXCJjXCJdLFxuICAgICAgICAgICAgIGJvZHk6XCJhPWJcIitvcCtcImNcIn0sXG4gICAgICBmdW5jTmFtZTogaWRcbiAgICB9KVxuICAgIGV4cG9ydHNbaWQrXCJzXCJdID0gbWFrZU9wKHtcbiAgICAgIGFyZ3M6IFtcImFycmF5XCIsXCJhcnJheVwiLFwic2NhbGFyXCJdLFxuICAgICAgYm9keToge2FyZ3M6W1wiYVwiLCBcImJcIiwgXCJzXCJdLFxuICAgICAgICAgICAgIGJvZHk6XCJhPWJcIitvcCtcInNcIn0sXG4gICAgICBmdW5jTmFtZTogaWQrXCJzXCJcbiAgICB9KVxuICAgIGV4cG9ydHNbaWQrXCJlcVwiXSA9IG1ha2VPcCh7XG4gICAgICBhcmdzOiBbXCJhcnJheVwiLCBcImFycmF5XCJdLFxuICAgICAgYm9keToge2FyZ3M6W1wiYVwiLCBcImJcIl0sXG4gICAgICAgICAgICAgYm9keTpcImE9YVwiK29wK1wiYlwifSxcbiAgICAgIHJ2YWx1ZTp0cnVlLFxuICAgICAgY291bnQ6MixcbiAgICAgIGZ1bmNOYW1lOiBpZCtcImVxXCJcbiAgICB9KVxuICAgIGV4cG9ydHNbaWQrXCJzZXFcIl0gPSBtYWtlT3Aoe1xuICAgICAgYXJnczogW1wiYXJyYXlcIiwgXCJzY2FsYXJcIl0sXG4gICAgICBib2R5OiB7YXJnczpbXCJhXCIsXCJzXCJdLFxuICAgICAgICAgICAgIGJvZHk6XCJhPWFcIitvcCtcInNcIn0sXG4gICAgICBydmFsdWU6dHJ1ZSxcbiAgICAgIGNvdW50OjIsXG4gICAgICBmdW5jTmFtZTogaWQrXCJzZXFcIlxuICAgIH0pXG4gIH1cbn0pKCk7XG5cbnZhciBtYXRoX3VuYXJ5ID0gW1xuICBcImFic1wiLFxuICBcImFjb3NcIixcbiAgXCJhc2luXCIsXG4gIFwiYXRhblwiLFxuICBcImNlaWxcIixcbiAgXCJjb3NcIixcbiAgXCJleHBcIixcbiAgXCJmbG9vclwiLFxuICBcImxvZ1wiLFxuICBcInJvdW5kXCIsXG4gIFwic2luXCIsXG4gIFwic3FydFwiLFxuICBcInRhblwiXG5dXG47KGZ1bmN0aW9uKCkge1xuICBmb3IodmFyIGk9MDsgaTxtYXRoX3VuYXJ5Lmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGYgPSBtYXRoX3VuYXJ5W2ldXG4gICAgZXhwb3J0c1tmXSA9IG1ha2VPcCh7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtcImFycmF5XCIsIFwiYXJyYXlcIl0sXG4gICAgICAgICAgICAgICAgICAgIHByZToge2FyZ3M6W10sIGJvZHk6XCJ0aGlzX2Y9TWF0aC5cIitmLCB0aGlzVmFyczpbXCJ0aGlzX2ZcIl19LFxuICAgICAgICAgICAgICAgICAgICBib2R5OiB7YXJnczpbXCJhXCIsXCJiXCJdLCBib2R5OlwiYT10aGlzX2YoYilcIiwgdGhpc1ZhcnM6W1widGhpc19mXCJdfSxcbiAgICAgICAgICAgICAgICAgICAgZnVuY05hbWU6IGZcbiAgICAgICAgICAgICAgICAgIH0pXG4gICAgZXhwb3J0c1tmK1wiZXFcIl0gPSBtYWtlT3Aoe1xuICAgICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtcImFycmF5XCJdLFxuICAgICAgICAgICAgICAgICAgICAgIHByZToge2FyZ3M6W10sIGJvZHk6XCJ0aGlzX2Y9TWF0aC5cIitmLCB0aGlzVmFyczpbXCJ0aGlzX2ZcIl19LFxuICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IHthcmdzOiBbXCJhXCJdLCBib2R5OlwiYT10aGlzX2YoYSlcIiwgdGhpc1ZhcnM6W1widGhpc19mXCJdfSxcbiAgICAgICAgICAgICAgICAgICAgICBydmFsdWU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgY291bnQ6IDIsXG4gICAgICAgICAgICAgICAgICAgICAgZnVuY05hbWU6IGYrXCJlcVwiXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gIH1cbn0pKCk7XG5cbnZhciBtYXRoX2NvbW0gPSBbXG4gIFwibWF4XCIsXG4gIFwibWluXCIsXG4gIFwiYXRhbjJcIixcbiAgXCJwb3dcIlxuXVxuOyhmdW5jdGlvbigpe1xuICBmb3IodmFyIGk9MDsgaTxtYXRoX2NvbW0ubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgZj0gbWF0aF9jb21tW2ldXG4gICAgZXhwb3J0c1tmXSA9IG1ha2VPcCh7XG4gICAgICAgICAgICAgICAgICBhcmdzOltcImFycmF5XCIsIFwiYXJyYXlcIiwgXCJhcnJheVwiXSxcbiAgICAgICAgICAgICAgICAgIHByZToge2FyZ3M6W10sIGJvZHk6XCJ0aGlzX2Y9TWF0aC5cIitmLCB0aGlzVmFyczpbXCJ0aGlzX2ZcIl19LFxuICAgICAgICAgICAgICAgICAgYm9keToge2FyZ3M6W1wiYVwiLFwiYlwiLFwiY1wiXSwgYm9keTpcImE9dGhpc19mKGIsYylcIiwgdGhpc1ZhcnM6W1widGhpc19mXCJdfSxcbiAgICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiBmXG4gICAgICAgICAgICAgICAgfSlcbiAgICBleHBvcnRzW2YrXCJzXCJdID0gbWFrZU9wKHtcbiAgICAgICAgICAgICAgICAgIGFyZ3M6W1wiYXJyYXlcIiwgXCJhcnJheVwiLCBcInNjYWxhclwiXSxcbiAgICAgICAgICAgICAgICAgIHByZToge2FyZ3M6W10sIGJvZHk6XCJ0aGlzX2Y9TWF0aC5cIitmLCB0aGlzVmFyczpbXCJ0aGlzX2ZcIl19LFxuICAgICAgICAgICAgICAgICAgYm9keToge2FyZ3M6W1wiYVwiLFwiYlwiLFwiY1wiXSwgYm9keTpcImE9dGhpc19mKGIsYylcIiwgdGhpc1ZhcnM6W1widGhpc19mXCJdfSxcbiAgICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiBmK1wic1wiXG4gICAgICAgICAgICAgICAgICB9KVxuICAgIGV4cG9ydHNbZitcImVxXCJdID0gbWFrZU9wKHsgYXJnczpbXCJhcnJheVwiLCBcImFycmF5XCJdLFxuICAgICAgICAgICAgICAgICAgcHJlOiB7YXJnczpbXSwgYm9keTpcInRoaXNfZj1NYXRoLlwiK2YsIHRoaXNWYXJzOltcInRoaXNfZlwiXX0sXG4gICAgICAgICAgICAgICAgICBib2R5OiB7YXJnczpbXCJhXCIsXCJiXCJdLCBib2R5OlwiYT10aGlzX2YoYSxiKVwiLCB0aGlzVmFyczpbXCJ0aGlzX2ZcIl19LFxuICAgICAgICAgICAgICAgICAgcnZhbHVlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgY291bnQ6IDIsXG4gICAgICAgICAgICAgICAgICBmdW5jTmFtZTogZitcImVxXCJcbiAgICAgICAgICAgICAgICAgIH0pXG4gICAgZXhwb3J0c1tmK1wic2VxXCJdID0gbWFrZU9wKHsgYXJnczpbXCJhcnJheVwiLCBcInNjYWxhclwiXSxcbiAgICAgICAgICAgICAgICAgIHByZToge2FyZ3M6W10sIGJvZHk6XCJ0aGlzX2Y9TWF0aC5cIitmLCB0aGlzVmFyczpbXCJ0aGlzX2ZcIl19LFxuICAgICAgICAgICAgICAgICAgYm9keToge2FyZ3M6W1wiYVwiLFwiYlwiXSwgYm9keTpcImE9dGhpc19mKGEsYilcIiwgdGhpc1ZhcnM6W1widGhpc19mXCJdfSxcbiAgICAgICAgICAgICAgICAgIHJ2YWx1ZTp0cnVlLFxuICAgICAgICAgICAgICAgICAgY291bnQ6MixcbiAgICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiBmK1wic2VxXCJcbiAgICAgICAgICAgICAgICAgIH0pXG4gIH1cbn0pKCk7XG5cbnZhciBtYXRoX25vbmNvbW0gPSBbXG4gIFwiYXRhbjJcIixcbiAgXCJwb3dcIlxuXVxuOyhmdW5jdGlvbigpe1xuICBmb3IodmFyIGk9MDsgaTxtYXRoX25vbmNvbW0ubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgZj0gbWF0aF9ub25jb21tW2ldXG4gICAgZXhwb3J0c1tmK1wib3BcIl0gPSBtYWtlT3Aoe1xuICAgICAgICAgICAgICAgICAgYXJnczpbXCJhcnJheVwiLCBcImFycmF5XCIsIFwiYXJyYXlcIl0sXG4gICAgICAgICAgICAgICAgICBwcmU6IHthcmdzOltdLCBib2R5OlwidGhpc19mPU1hdGguXCIrZiwgdGhpc1ZhcnM6W1widGhpc19mXCJdfSxcbiAgICAgICAgICAgICAgICAgIGJvZHk6IHthcmdzOltcImFcIixcImJcIixcImNcIl0sIGJvZHk6XCJhPXRoaXNfZihjLGIpXCIsIHRoaXNWYXJzOltcInRoaXNfZlwiXX0sXG4gICAgICAgICAgICAgICAgICBmdW5jTmFtZTogZitcIm9wXCJcbiAgICAgICAgICAgICAgICB9KVxuICAgIGV4cG9ydHNbZitcIm9wc1wiXSA9IG1ha2VPcCh7XG4gICAgICAgICAgICAgICAgICBhcmdzOltcImFycmF5XCIsIFwiYXJyYXlcIiwgXCJzY2FsYXJcIl0sXG4gICAgICAgICAgICAgICAgICBwcmU6IHthcmdzOltdLCBib2R5OlwidGhpc19mPU1hdGguXCIrZiwgdGhpc1ZhcnM6W1widGhpc19mXCJdfSxcbiAgICAgICAgICAgICAgICAgIGJvZHk6IHthcmdzOltcImFcIixcImJcIixcImNcIl0sIGJvZHk6XCJhPXRoaXNfZihjLGIpXCIsIHRoaXNWYXJzOltcInRoaXNfZlwiXX0sXG4gICAgICAgICAgICAgICAgICBmdW5jTmFtZTogZitcIm9wc1wiXG4gICAgICAgICAgICAgICAgICB9KVxuICAgIGV4cG9ydHNbZitcIm9wZXFcIl0gPSBtYWtlT3AoeyBhcmdzOltcImFycmF5XCIsIFwiYXJyYXlcIl0sXG4gICAgICAgICAgICAgICAgICBwcmU6IHthcmdzOltdLCBib2R5OlwidGhpc19mPU1hdGguXCIrZiwgdGhpc1ZhcnM6W1widGhpc19mXCJdfSxcbiAgICAgICAgICAgICAgICAgIGJvZHk6IHthcmdzOltcImFcIixcImJcIl0sIGJvZHk6XCJhPXRoaXNfZihiLGEpXCIsIHRoaXNWYXJzOltcInRoaXNfZlwiXX0sXG4gICAgICAgICAgICAgICAgICBydmFsdWU6IHRydWUsXG4gICAgICAgICAgICAgICAgICBjb3VudDogMixcbiAgICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiBmK1wib3BlcVwiXG4gICAgICAgICAgICAgICAgICB9KVxuICAgIGV4cG9ydHNbZitcIm9wc2VxXCJdID0gbWFrZU9wKHsgYXJnczpbXCJhcnJheVwiLCBcInNjYWxhclwiXSxcbiAgICAgICAgICAgICAgICAgIHByZToge2FyZ3M6W10sIGJvZHk6XCJ0aGlzX2Y9TWF0aC5cIitmLCB0aGlzVmFyczpbXCJ0aGlzX2ZcIl19LFxuICAgICAgICAgICAgICAgICAgYm9keToge2FyZ3M6W1wiYVwiLFwiYlwiXSwgYm9keTpcImE9dGhpc19mKGIsYSlcIiwgdGhpc1ZhcnM6W1widGhpc19mXCJdfSxcbiAgICAgICAgICAgICAgICAgIHJ2YWx1ZTp0cnVlLFxuICAgICAgICAgICAgICAgICAgY291bnQ6MixcbiAgICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiBmK1wib3BzZXFcIlxuICAgICAgICAgICAgICAgICAgfSlcbiAgfVxufSkoKTtcblxuZXhwb3J0cy5hbnkgPSBjb21waWxlKHtcbiAgYXJnczpbXCJhcnJheVwiXSxcbiAgcHJlOiBFbXB0eVByb2MsXG4gIGJvZHk6IHthcmdzOlt7bmFtZTpcImFcIiwgbHZhbHVlOmZhbHNlLCBydmFsdWU6dHJ1ZSwgY291bnQ6MX1dLCBib2R5OiBcImlmKGEpe3JldHVybiB0cnVlfVwiLCBsb2NhbFZhcnM6IFtdLCB0aGlzVmFyczogW119LFxuICBwb3N0OiB7YXJnczpbXSwgbG9jYWxWYXJzOltdLCB0aGlzVmFyczpbXSwgYm9keTpcInJldHVybiBmYWxzZVwifSxcbiAgZnVuY05hbWU6IFwiYW55XCJcbn0pXG5cbmV4cG9ydHMuYWxsID0gY29tcGlsZSh7XG4gIGFyZ3M6W1wiYXJyYXlcIl0sXG4gIHByZTogRW1wdHlQcm9jLFxuICBib2R5OiB7YXJnczpbe25hbWU6XCJ4XCIsIGx2YWx1ZTpmYWxzZSwgcnZhbHVlOnRydWUsIGNvdW50OjF9XSwgYm9keTogXCJpZigheCl7cmV0dXJuIGZhbHNlfVwiLCBsb2NhbFZhcnM6IFtdLCB0aGlzVmFyczogW119LFxuICBwb3N0OiB7YXJnczpbXSwgbG9jYWxWYXJzOltdLCB0aGlzVmFyczpbXSwgYm9keTpcInJldHVybiB0cnVlXCJ9LFxuICBmdW5jTmFtZTogXCJhbGxcIlxufSlcblxuZXhwb3J0cy5zdW0gPSBjb21waWxlKHtcbiAgYXJnczpbXCJhcnJheVwiXSxcbiAgcHJlOiB7YXJnczpbXSwgbG9jYWxWYXJzOltdLCB0aGlzVmFyczpbXCJ0aGlzX3NcIl0sIGJvZHk6XCJ0aGlzX3M9MFwifSxcbiAgYm9keToge2FyZ3M6W3tuYW1lOlwiYVwiLCBsdmFsdWU6ZmFsc2UsIHJ2YWx1ZTp0cnVlLCBjb3VudDoxfV0sIGJvZHk6IFwidGhpc19zKz1hXCIsIGxvY2FsVmFyczogW10sIHRoaXNWYXJzOiBbXCJ0aGlzX3NcIl19LFxuICBwb3N0OiB7YXJnczpbXSwgbG9jYWxWYXJzOltdLCB0aGlzVmFyczpbXCJ0aGlzX3NcIl0sIGJvZHk6XCJyZXR1cm4gdGhpc19zXCJ9LFxuICBmdW5jTmFtZTogXCJzdW1cIlxufSlcblxuZXhwb3J0cy5wcm9kID0gY29tcGlsZSh7XG4gIGFyZ3M6W1wiYXJyYXlcIl0sXG4gIHByZToge2FyZ3M6W10sIGxvY2FsVmFyczpbXSwgdGhpc1ZhcnM6W1widGhpc19zXCJdLCBib2R5OlwidGhpc19zPTFcIn0sXG4gIGJvZHk6IHthcmdzOlt7bmFtZTpcImFcIiwgbHZhbHVlOmZhbHNlLCBydmFsdWU6dHJ1ZSwgY291bnQ6MX1dLCBib2R5OiBcInRoaXNfcyo9YVwiLCBsb2NhbFZhcnM6IFtdLCB0aGlzVmFyczogW1widGhpc19zXCJdfSxcbiAgcG9zdDoge2FyZ3M6W10sIGxvY2FsVmFyczpbXSwgdGhpc1ZhcnM6W1widGhpc19zXCJdLCBib2R5OlwicmV0dXJuIHRoaXNfc1wifSxcbiAgZnVuY05hbWU6IFwicHJvZFwiXG59KVxuXG5leHBvcnRzLm5vcm0yc3F1YXJlZCA9IGNvbXBpbGUoe1xuICBhcmdzOltcImFycmF5XCJdLFxuICBwcmU6IHthcmdzOltdLCBsb2NhbFZhcnM6W10sIHRoaXNWYXJzOltcInRoaXNfc1wiXSwgYm9keTpcInRoaXNfcz0wXCJ9LFxuICBib2R5OiB7YXJnczpbe25hbWU6XCJhXCIsIGx2YWx1ZTpmYWxzZSwgcnZhbHVlOnRydWUsIGNvdW50OjJ9XSwgYm9keTogXCJ0aGlzX3MrPWEqYVwiLCBsb2NhbFZhcnM6IFtdLCB0aGlzVmFyczogW1widGhpc19zXCJdfSxcbiAgcG9zdDoge2FyZ3M6W10sIGxvY2FsVmFyczpbXSwgdGhpc1ZhcnM6W1widGhpc19zXCJdLCBib2R5OlwicmV0dXJuIHRoaXNfc1wifSxcbiAgZnVuY05hbWU6IFwibm9ybTJzcXVhcmVkXCJcbn0pXG4gIFxuZXhwb3J0cy5ub3JtMiA9IGNvbXBpbGUoe1xuICBhcmdzOltcImFycmF5XCJdLFxuICBwcmU6IHthcmdzOltdLCBsb2NhbFZhcnM6W10sIHRoaXNWYXJzOltcInRoaXNfc1wiXSwgYm9keTpcInRoaXNfcz0wXCJ9LFxuICBib2R5OiB7YXJnczpbe25hbWU6XCJhXCIsIGx2YWx1ZTpmYWxzZSwgcnZhbHVlOnRydWUsIGNvdW50OjJ9XSwgYm9keTogXCJ0aGlzX3MrPWEqYVwiLCBsb2NhbFZhcnM6IFtdLCB0aGlzVmFyczogW1widGhpc19zXCJdfSxcbiAgcG9zdDoge2FyZ3M6W10sIGxvY2FsVmFyczpbXSwgdGhpc1ZhcnM6W1widGhpc19zXCJdLCBib2R5OlwicmV0dXJuIE1hdGguc3FydCh0aGlzX3MpXCJ9LFxuICBmdW5jTmFtZTogXCJub3JtMlwiXG59KVxuICBcblxuZXhwb3J0cy5ub3JtaW5mID0gY29tcGlsZSh7XG4gIGFyZ3M6W1wiYXJyYXlcIl0sXG4gIHByZToge2FyZ3M6W10sIGxvY2FsVmFyczpbXSwgdGhpc1ZhcnM6W1widGhpc19zXCJdLCBib2R5OlwidGhpc19zPTBcIn0sXG4gIGJvZHk6IHthcmdzOlt7bmFtZTpcImFcIiwgbHZhbHVlOmZhbHNlLCBydmFsdWU6dHJ1ZSwgY291bnQ6NH1dLCBib2R5OlwiaWYoLWE+dGhpc19zKXt0aGlzX3M9LWF9ZWxzZSBpZihhPnRoaXNfcyl7dGhpc19zPWF9XCIsIGxvY2FsVmFyczogW10sIHRoaXNWYXJzOiBbXCJ0aGlzX3NcIl19LFxuICBwb3N0OiB7YXJnczpbXSwgbG9jYWxWYXJzOltdLCB0aGlzVmFyczpbXCJ0aGlzX3NcIl0sIGJvZHk6XCJyZXR1cm4gdGhpc19zXCJ9LFxuICBmdW5jTmFtZTogXCJub3JtaW5mXCJcbn0pXG5cbmV4cG9ydHMubm9ybTEgPSBjb21waWxlKHtcbiAgYXJnczpbXCJhcnJheVwiXSxcbiAgcHJlOiB7YXJnczpbXSwgbG9jYWxWYXJzOltdLCB0aGlzVmFyczpbXCJ0aGlzX3NcIl0sIGJvZHk6XCJ0aGlzX3M9MFwifSxcbiAgYm9keToge2FyZ3M6W3tuYW1lOlwiYVwiLCBsdmFsdWU6ZmFsc2UsIHJ2YWx1ZTp0cnVlLCBjb3VudDozfV0sIGJvZHk6IFwidGhpc19zKz1hPDA/LWE6YVwiLCBsb2NhbFZhcnM6IFtdLCB0aGlzVmFyczogW1widGhpc19zXCJdfSxcbiAgcG9zdDoge2FyZ3M6W10sIGxvY2FsVmFyczpbXSwgdGhpc1ZhcnM6W1widGhpc19zXCJdLCBib2R5OlwicmV0dXJuIHRoaXNfc1wifSxcbiAgZnVuY05hbWU6IFwibm9ybTFcIlxufSlcblxuZXhwb3J0cy5zdXAgPSBjb21waWxlKHtcbiAgYXJnczogWyBcImFycmF5XCIgXSxcbiAgcHJlOlxuICAgeyBib2R5OiBcInRoaXNfaD0tSW5maW5pdHlcIixcbiAgICAgYXJnczogW10sXG4gICAgIHRoaXNWYXJzOiBbIFwidGhpc19oXCIgXSxcbiAgICAgbG9jYWxWYXJzOiBbXSB9LFxuICBib2R5OlxuICAgeyBib2R5OiBcImlmKF9pbmxpbmVfMV9hcmcwXz50aGlzX2gpdGhpc19oPV9pbmxpbmVfMV9hcmcwX1wiLFxuICAgICBhcmdzOiBbe1wibmFtZVwiOlwiX2lubGluZV8xX2FyZzBfXCIsXCJsdmFsdWVcIjpmYWxzZSxcInJ2YWx1ZVwiOnRydWUsXCJjb3VudFwiOjJ9IF0sXG4gICAgIHRoaXNWYXJzOiBbIFwidGhpc19oXCIgXSxcbiAgICAgbG9jYWxWYXJzOiBbXSB9LFxuICBwb3N0OlxuICAgeyBib2R5OiBcInJldHVybiB0aGlzX2hcIixcbiAgICAgYXJnczogW10sXG4gICAgIHRoaXNWYXJzOiBbIFwidGhpc19oXCIgXSxcbiAgICAgbG9jYWxWYXJzOiBbXSB9XG4gfSlcblxuZXhwb3J0cy5pbmYgPSBjb21waWxlKHtcbiAgYXJnczogWyBcImFycmF5XCIgXSxcbiAgcHJlOlxuICAgeyBib2R5OiBcInRoaXNfaD1JbmZpbml0eVwiLFxuICAgICBhcmdzOiBbXSxcbiAgICAgdGhpc1ZhcnM6IFsgXCJ0aGlzX2hcIiBdLFxuICAgICBsb2NhbFZhcnM6IFtdIH0sXG4gIGJvZHk6XG4gICB7IGJvZHk6IFwiaWYoX2lubGluZV8xX2FyZzBfPHRoaXNfaCl0aGlzX2g9X2lubGluZV8xX2FyZzBfXCIsXG4gICAgIGFyZ3M6IFt7XCJuYW1lXCI6XCJfaW5saW5lXzFfYXJnMF9cIixcImx2YWx1ZVwiOmZhbHNlLFwicnZhbHVlXCI6dHJ1ZSxcImNvdW50XCI6Mn0gXSxcbiAgICAgdGhpc1ZhcnM6IFsgXCJ0aGlzX2hcIiBdLFxuICAgICBsb2NhbFZhcnM6IFtdIH0sXG4gIHBvc3Q6XG4gICB7IGJvZHk6IFwicmV0dXJuIHRoaXNfaFwiLFxuICAgICBhcmdzOiBbXSxcbiAgICAgdGhpc1ZhcnM6IFsgXCJ0aGlzX2hcIiBdLFxuICAgICBsb2NhbFZhcnM6IFtdIH1cbiB9KVxuXG5leHBvcnRzLmFyZ21pbiA9IGNvbXBpbGUoe1xuICBhcmdzOltcImluZGV4XCIsXCJhcnJheVwiLFwic2hhcGVcIl0sXG4gIHByZTp7XG4gICAgYm9keTpcInt0aGlzX3Y9SW5maW5pdHk7dGhpc19pPV9pbmxpbmVfMF9hcmcyXy5zbGljZSgwKX1cIixcbiAgICBhcmdzOltcbiAgICAgIHtuYW1lOlwiX2lubGluZV8wX2FyZzBfXCIsbHZhbHVlOmZhbHNlLHJ2YWx1ZTpmYWxzZSxjb3VudDowfSxcbiAgICAgIHtuYW1lOlwiX2lubGluZV8wX2FyZzFfXCIsbHZhbHVlOmZhbHNlLHJ2YWx1ZTpmYWxzZSxjb3VudDowfSxcbiAgICAgIHtuYW1lOlwiX2lubGluZV8wX2FyZzJfXCIsbHZhbHVlOmZhbHNlLHJ2YWx1ZTp0cnVlLGNvdW50OjF9XG4gICAgICBdLFxuICAgIHRoaXNWYXJzOltcInRoaXNfaVwiLFwidGhpc192XCJdLFxuICAgIGxvY2FsVmFyczpbXX0sXG4gIGJvZHk6e1xuICAgIGJvZHk6XCJ7aWYoX2lubGluZV8xX2FyZzFfPHRoaXNfdil7dGhpc192PV9pbmxpbmVfMV9hcmcxXztmb3IodmFyIF9pbmxpbmVfMV9rPTA7X2lubGluZV8xX2s8X2lubGluZV8xX2FyZzBfLmxlbmd0aDsrK19pbmxpbmVfMV9rKXt0aGlzX2lbX2lubGluZV8xX2tdPV9pbmxpbmVfMV9hcmcwX1tfaW5saW5lXzFfa119fX1cIixcbiAgICBhcmdzOltcbiAgICAgIHtuYW1lOlwiX2lubGluZV8xX2FyZzBfXCIsbHZhbHVlOmZhbHNlLHJ2YWx1ZTp0cnVlLGNvdW50OjJ9LFxuICAgICAge25hbWU6XCJfaW5saW5lXzFfYXJnMV9cIixsdmFsdWU6ZmFsc2UscnZhbHVlOnRydWUsY291bnQ6Mn1dLFxuICAgIHRoaXNWYXJzOltcInRoaXNfaVwiLFwidGhpc192XCJdLFxuICAgIGxvY2FsVmFyczpbXCJfaW5saW5lXzFfa1wiXX0sXG4gIHBvc3Q6e1xuICAgIGJvZHk6XCJ7cmV0dXJuIHRoaXNfaX1cIixcbiAgICBhcmdzOltdLFxuICAgIHRoaXNWYXJzOltcInRoaXNfaVwiXSxcbiAgICBsb2NhbFZhcnM6W119XG59KVxuXG5leHBvcnRzLmFyZ21heCA9IGNvbXBpbGUoe1xuICBhcmdzOltcImluZGV4XCIsXCJhcnJheVwiLFwic2hhcGVcIl0sXG4gIHByZTp7XG4gICAgYm9keTpcInt0aGlzX3Y9LUluZmluaXR5O3RoaXNfaT1faW5saW5lXzBfYXJnMl8uc2xpY2UoMCl9XCIsXG4gICAgYXJnczpbXG4gICAgICB7bmFtZTpcIl9pbmxpbmVfMF9hcmcwX1wiLGx2YWx1ZTpmYWxzZSxydmFsdWU6ZmFsc2UsY291bnQ6MH0sXG4gICAgICB7bmFtZTpcIl9pbmxpbmVfMF9hcmcxX1wiLGx2YWx1ZTpmYWxzZSxydmFsdWU6ZmFsc2UsY291bnQ6MH0sXG4gICAgICB7bmFtZTpcIl9pbmxpbmVfMF9hcmcyX1wiLGx2YWx1ZTpmYWxzZSxydmFsdWU6dHJ1ZSxjb3VudDoxfVxuICAgICAgXSxcbiAgICB0aGlzVmFyczpbXCJ0aGlzX2lcIixcInRoaXNfdlwiXSxcbiAgICBsb2NhbFZhcnM6W119LFxuICBib2R5OntcbiAgICBib2R5Olwie2lmKF9pbmxpbmVfMV9hcmcxXz50aGlzX3Ype3RoaXNfdj1faW5saW5lXzFfYXJnMV87Zm9yKHZhciBfaW5saW5lXzFfaz0wO19pbmxpbmVfMV9rPF9pbmxpbmVfMV9hcmcwXy5sZW5ndGg7KytfaW5saW5lXzFfayl7dGhpc19pW19pbmxpbmVfMV9rXT1faW5saW5lXzFfYXJnMF9bX2lubGluZV8xX2tdfX19XCIsXG4gICAgYXJnczpbXG4gICAgICB7bmFtZTpcIl9pbmxpbmVfMV9hcmcwX1wiLGx2YWx1ZTpmYWxzZSxydmFsdWU6dHJ1ZSxjb3VudDoyfSxcbiAgICAgIHtuYW1lOlwiX2lubGluZV8xX2FyZzFfXCIsbHZhbHVlOmZhbHNlLHJ2YWx1ZTp0cnVlLGNvdW50OjJ9XSxcbiAgICB0aGlzVmFyczpbXCJ0aGlzX2lcIixcInRoaXNfdlwiXSxcbiAgICBsb2NhbFZhcnM6W1wiX2lubGluZV8xX2tcIl19LFxuICBwb3N0OntcbiAgICBib2R5Olwie3JldHVybiB0aGlzX2l9XCIsXG4gICAgYXJnczpbXSxcbiAgICB0aGlzVmFyczpbXCJ0aGlzX2lcIl0sXG4gICAgbG9jYWxWYXJzOltdfVxufSkgIFxuXG5leHBvcnRzLnJhbmRvbSA9IG1ha2VPcCh7XG4gIGFyZ3M6IFtcImFycmF5XCJdLFxuICBwcmU6IHthcmdzOltdLCBib2R5OlwidGhpc19mPU1hdGgucmFuZG9tXCIsIHRoaXNWYXJzOltcInRoaXNfZlwiXX0sXG4gIGJvZHk6IHthcmdzOiBbXCJhXCJdLCBib2R5OlwiYT10aGlzX2YoKVwiLCB0aGlzVmFyczpbXCJ0aGlzX2ZcIl19LFxuICBmdW5jTmFtZTogXCJyYW5kb21cIlxufSlcblxuZXhwb3J0cy5hc3NpZ24gPSBtYWtlT3Aoe1xuICBhcmdzOltcImFycmF5XCIsIFwiYXJyYXlcIl0sXG4gIGJvZHk6IHthcmdzOltcImFcIiwgXCJiXCJdLCBib2R5OlwiYT1iXCJ9LFxuICBmdW5jTmFtZTogXCJhc3NpZ25cIiB9KVxuXG5leHBvcnRzLmFzc2lnbnMgPSBtYWtlT3Aoe1xuICBhcmdzOltcImFycmF5XCIsIFwic2NhbGFyXCJdLFxuICBib2R5OiB7YXJnczpbXCJhXCIsIFwiYlwiXSwgYm9keTpcImE9YlwifSxcbiAgZnVuY05hbWU6IFwiYXNzaWduc1wiIH0pXG5cblxuZXhwb3J0cy5lcXVhbHMgPSBjb21waWxlKHtcbiAgYXJnczpbXCJhcnJheVwiLCBcImFycmF5XCJdLFxuICBwcmU6IEVtcHR5UHJvYyxcbiAgYm9keToge2FyZ3M6W3tuYW1lOlwieFwiLCBsdmFsdWU6ZmFsc2UsIHJ2YWx1ZTp0cnVlLCBjb3VudDoxfSxcbiAgICAgICAgICAgICAgIHtuYW1lOlwieVwiLCBsdmFsdWU6ZmFsc2UsIHJ2YWx1ZTp0cnVlLCBjb3VudDoxfV0sIFxuICAgICAgICBib2R5OiBcImlmKHghPT15KXtyZXR1cm4gZmFsc2V9XCIsIFxuICAgICAgICBsb2NhbFZhcnM6IFtdLCBcbiAgICAgICAgdGhpc1ZhcnM6IFtdfSxcbiAgcG9zdDoge2FyZ3M6W10sIGxvY2FsVmFyczpbXSwgdGhpc1ZhcnM6W10sIGJvZHk6XCJyZXR1cm4gdHJ1ZVwifSxcbiAgZnVuY05hbWU6IFwiZXF1YWxzXCJcbn0pXG5cblxuIiwiXCJ1c2Ugc3RyaWN0XCJcblxudmFyIGNyZWF0ZVRodW5rID0gcmVxdWlyZShcIi4vbGliL3RodW5rLmpzXCIpXG5cbmZ1bmN0aW9uIFByb2NlZHVyZSgpIHtcbiAgdGhpcy5hcmdUeXBlcyA9IFtdXG4gIHRoaXMuc2hpbUFyZ3MgPSBbXVxuICB0aGlzLmFycmF5QXJncyA9IFtdXG4gIHRoaXMuc2NhbGFyQXJncyA9IFtdXG4gIHRoaXMub2Zmc2V0QXJncyA9IFtdXG4gIHRoaXMub2Zmc2V0QXJnSW5kZXggPSBbXVxuICB0aGlzLmluZGV4QXJncyA9IFtdXG4gIHRoaXMuc2hhcGVBcmdzID0gW11cbiAgdGhpcy5mdW5jTmFtZSA9IFwiXCJcbiAgdGhpcy5wcmUgPSBudWxsXG4gIHRoaXMuYm9keSA9IG51bGxcbiAgdGhpcy5wb3N0ID0gbnVsbFxuICB0aGlzLmRlYnVnID0gZmFsc2Vcbn1cblxuZnVuY3Rpb24gY29tcGlsZUN3aXNlKHVzZXJfYXJncykge1xuICAvL0NyZWF0ZSBwcm9jZWR1cmVcbiAgdmFyIHByb2MgPSBuZXcgUHJvY2VkdXJlKClcbiAgXG4gIC8vUGFyc2UgYmxvY2tzXG4gIHByb2MucHJlICAgID0gdXNlcl9hcmdzLnByZVxuICBwcm9jLmJvZHkgICA9IHVzZXJfYXJncy5ib2R5XG4gIHByb2MucG9zdCAgID0gdXNlcl9hcmdzLnBvc3RcblxuICAvL1BhcnNlIGFyZ3VtZW50c1xuICB2YXIgcHJvY19hcmdzID0gdXNlcl9hcmdzLmFyZ3Muc2xpY2UoMClcbiAgcHJvYy5hcmdUeXBlcyA9IHByb2NfYXJnc1xuICBmb3IodmFyIGk9MDsgaTxwcm9jX2FyZ3MubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYXJnX3R5cGUgPSBwcm9jX2FyZ3NbaV1cbiAgICBpZihhcmdfdHlwZSA9PT0gXCJhcnJheVwiKSB7XG4gICAgICBwcm9jLmFycmF5QXJncy5wdXNoKGkpXG4gICAgICBwcm9jLnNoaW1BcmdzLnB1c2goXCJhcnJheVwiICsgaSlcbiAgICAgIGlmKGkgPCBwcm9jLnByZS5hcmdzLmxlbmd0aCAmJiBwcm9jLnByZS5hcmdzW2ldLmNvdW50PjApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY3dpc2U6IHByZSgpIGJsb2NrIG1heSBub3QgcmVmZXJlbmNlIGFycmF5IGFyZ3NcIilcbiAgICAgIH1cbiAgICAgIGlmKGkgPCBwcm9jLnBvc3QuYXJncy5sZW5ndGggJiYgcHJvYy5wb3N0LmFyZ3NbaV0uY291bnQ+MCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjd2lzZTogcG9zdCgpIGJsb2NrIG1heSBub3QgcmVmZXJlbmNlIGFycmF5IGFyZ3NcIilcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYoYXJnX3R5cGUgPT09IFwic2NhbGFyXCIpIHtcbiAgICAgIHByb2Muc2NhbGFyQXJncy5wdXNoKGkpXG4gICAgICBwcm9jLnNoaW1BcmdzLnB1c2goXCJzY2FsYXJcIiArIGkpXG4gICAgfSBlbHNlIGlmKGFyZ190eXBlID09PSBcImluZGV4XCIpIHtcbiAgICAgIHByb2MuaW5kZXhBcmdzLnB1c2goaSlcbiAgICAgIGlmKGkgPCBwcm9jLnByZS5hcmdzLmxlbmd0aCAmJiBwcm9jLnByZS5hcmdzW2ldLmNvdW50ID4gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjd2lzZTogcHJlKCkgYmxvY2sgbWF5IG5vdCByZWZlcmVuY2UgYXJyYXkgaW5kZXhcIilcbiAgICAgIH1cbiAgICAgIGlmKGkgPCBwcm9jLmJvZHkuYXJncy5sZW5ndGggJiYgcHJvYy5ib2R5LmFyZ3NbaV0ubHZhbHVlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImN3aXNlOiBib2R5KCkgYmxvY2sgbWF5IG5vdCB3cml0ZSB0byBhcnJheSBpbmRleFwiKVxuICAgICAgfVxuICAgICAgaWYoaSA8IHByb2MucG9zdC5hcmdzLmxlbmd0aCAmJiBwcm9jLnBvc3QuYXJnc1tpXS5jb3VudCA+IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY3dpc2U6IHBvc3QoKSBibG9jayBtYXkgbm90IHJlZmVyZW5jZSBhcnJheSBpbmRleFwiKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZihhcmdfdHlwZSA9PT0gXCJzaGFwZVwiKSB7XG4gICAgICBwcm9jLnNoYXBlQXJncy5wdXNoKGkpXG4gICAgICBpZihpIDwgcHJvYy5wcmUuYXJncy5sZW5ndGggJiYgcHJvYy5wcmUuYXJnc1tpXS5sdmFsdWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY3dpc2U6IHByZSgpIGJsb2NrIG1heSBub3Qgd3JpdGUgdG8gYXJyYXkgc2hhcGVcIilcbiAgICAgIH1cbiAgICAgIGlmKGkgPCBwcm9jLmJvZHkuYXJncy5sZW5ndGggJiYgcHJvYy5ib2R5LmFyZ3NbaV0ubHZhbHVlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImN3aXNlOiBib2R5KCkgYmxvY2sgbWF5IG5vdCB3cml0ZSB0byBhcnJheSBzaGFwZVwiKVxuICAgICAgfVxuICAgICAgaWYoaSA8IHByb2MucG9zdC5hcmdzLmxlbmd0aCAmJiBwcm9jLnBvc3QuYXJnc1tpXS5sdmFsdWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY3dpc2U6IHBvc3QoKSBibG9jayBtYXkgbm90IHdyaXRlIHRvIGFycmF5IHNoYXBlXCIpXG4gICAgICB9XG4gICAgfSBlbHNlIGlmKHR5cGVvZiBhcmdfdHlwZSA9PT0gXCJvYmplY3RcIiAmJiBhcmdfdHlwZS5vZmZzZXQpIHtcbiAgICAgIHByb2MuYXJnVHlwZXNbaV0gPSBcIm9mZnNldFwiXG4gICAgICBwcm9jLm9mZnNldEFyZ3MucHVzaCh7IGFycmF5OiBhcmdfdHlwZS5hcnJheSwgb2Zmc2V0OmFyZ190eXBlLm9mZnNldCB9KVxuICAgICAgcHJvYy5vZmZzZXRBcmdJbmRleC5wdXNoKGkpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImN3aXNlOiBVbmtub3duIGFyZ3VtZW50IHR5cGUgXCIgKyBwcm9jX2FyZ3NbaV0pXG4gICAgfVxuICB9XG4gIFxuICAvL01ha2Ugc3VyZSBhdCBsZWFzdCBvbmUgYXJyYXkgYXJndW1lbnQgd2FzIHNwZWNpZmllZFxuICBpZihwcm9jLmFycmF5QXJncy5sZW5ndGggPD0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImN3aXNlOiBObyBhcnJheSBhcmd1bWVudHMgc3BlY2lmaWVkXCIpXG4gIH1cbiAgXG4gIC8vTWFrZSBzdXJlIGFyZ3VtZW50cyBhcmUgY29ycmVjdFxuICBpZihwcm9jLnByZS5hcmdzLmxlbmd0aCA+IHByb2NfYXJncy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJjd2lzZTogVG9vIG1hbnkgYXJndW1lbnRzIGluIHByZSgpIGJsb2NrXCIpXG4gIH1cbiAgaWYocHJvYy5ib2R5LmFyZ3MubGVuZ3RoID4gcHJvY19hcmdzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImN3aXNlOiBUb28gbWFueSBhcmd1bWVudHMgaW4gYm9keSgpIGJsb2NrXCIpXG4gIH1cbiAgaWYocHJvYy5wb3N0LmFyZ3MubGVuZ3RoID4gcHJvY19hcmdzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImN3aXNlOiBUb28gbWFueSBhcmd1bWVudHMgaW4gcG9zdCgpIGJsb2NrXCIpXG4gIH1cblxuICAvL0NoZWNrIGRlYnVnIGZsYWdcbiAgcHJvYy5kZWJ1ZyA9ICEhdXNlcl9hcmdzLnByaW50Q29kZSB8fCAhIXVzZXJfYXJncy5kZWJ1Z1xuICBcbiAgLy9SZXRyaWV2ZSBuYW1lXG4gIHByb2MuZnVuY05hbWUgPSB1c2VyX2FyZ3MuZnVuY05hbWUgfHwgXCJjd2lzZVwiXG4gIFxuICAvL1JlYWQgaW4gYmxvY2sgc2l6ZVxuICBwcm9jLmJsb2NrU2l6ZSA9IHVzZXJfYXJncy5ibG9ja1NpemUgfHwgNjRcblxuICByZXR1cm4gY3JlYXRlVGh1bmsocHJvYylcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb21waWxlQ3dpc2VcbiIsIlwidXNlIHN0cmljdFwiXG5cbnZhciB1bmlxID0gcmVxdWlyZShcInVuaXFcIilcblxuZnVuY3Rpb24gaW5uZXJGaWxsKG9yZGVyLCBwcm9jLCBib2R5KSB7XG4gIHZhciBkaW1lbnNpb24gPSBvcmRlci5sZW5ndGhcbiAgICAsIG5hcmdzID0gcHJvYy5hcnJheUFyZ3MubGVuZ3RoXG4gICAgLCBoYXNfaW5kZXggPSBwcm9jLmluZGV4QXJncy5sZW5ndGg+MFxuICAgICwgY29kZSA9IFtdXG4gICAgLCB2YXJzID0gW11cbiAgICAsIGlkeD0wLCBwaWR4PTAsIGksIGpcbiAgZm9yKGk9MDsgaTxkaW1lbnNpb247ICsraSkge1xuICAgIHZhcnMucHVzaChbXCJpXCIsaSxcIj0wXCJdLmpvaW4oXCJcIikpXG4gIH1cbiAgLy9Db21wdXRlIHNjYW4gZGVsdGFzXG4gIGZvcihqPTA7IGo8bmFyZ3M7ICsraikge1xuICAgIGZvcihpPTA7IGk8ZGltZW5zaW9uOyArK2kpIHtcbiAgICAgIHBpZHggPSBpZHhcbiAgICAgIGlkeCA9IG9yZGVyW2ldXG4gICAgICBpZihpID09PSAwKSB7XG4gICAgICAgIHZhcnMucHVzaChbXCJkXCIsaixcInNcIixpLFwiPXRcIixqLFwicFwiLGlkeF0uam9pbihcIlwiKSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhcnMucHVzaChbXCJkXCIsaixcInNcIixpLFwiPSh0XCIsaixcInBcIixpZHgsXCItc1wiLHBpZHgsXCIqdFwiLGosXCJwXCIscGlkeCxcIilcIl0uam9pbihcIlwiKSlcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY29kZS5wdXNoKFwidmFyIFwiICsgdmFycy5qb2luKFwiLFwiKSlcbiAgLy9TY2FuIGxvb3BcbiAgZm9yKGk9ZGltZW5zaW9uLTE7IGk+PTA7IC0taSkge1xuICAgIGlkeCA9IG9yZGVyW2ldXG4gICAgY29kZS5wdXNoKFtcImZvcihpXCIsaSxcIj0wO2lcIixpLFwiPHNcIixpZHgsXCI7KytpXCIsaSxcIil7XCJdLmpvaW4oXCJcIikpXG4gIH1cbiAgLy9QdXNoIGJvZHkgb2YgaW5uZXIgbG9vcFxuICBjb2RlLnB1c2goYm9keSlcbiAgLy9BZHZhbmNlIHNjYW4gcG9pbnRlcnNcbiAgZm9yKGk9MDsgaTxkaW1lbnNpb247ICsraSkge1xuICAgIHBpZHggPSBpZHhcbiAgICBpZHggPSBvcmRlcltpXVxuICAgIGZvcihqPTA7IGo8bmFyZ3M7ICsraikge1xuICAgICAgY29kZS5wdXNoKFtcInBcIixqLFwiKz1kXCIsaixcInNcIixpXS5qb2luKFwiXCIpKVxuICAgIH1cbiAgICBpZihoYXNfaW5kZXgpIHtcbiAgICAgIGlmKGkgPiAwKSB7XG4gICAgICAgIGNvZGUucHVzaChbXCJpbmRleFtcIixwaWR4LFwiXS09c1wiLHBpZHhdLmpvaW4oXCJcIikpXG4gICAgICB9XG4gICAgICBjb2RlLnB1c2goW1wiKytpbmRleFtcIixpZHgsXCJdXCJdLmpvaW4oXCJcIikpXG4gICAgfVxuICAgIGNvZGUucHVzaChcIn1cIilcbiAgfVxuICByZXR1cm4gY29kZS5qb2luKFwiXFxuXCIpXG59XG5cbmZ1bmN0aW9uIG91dGVyRmlsbChtYXRjaGVkLCBvcmRlciwgcHJvYywgYm9keSkge1xuICB2YXIgZGltZW5zaW9uID0gb3JkZXIubGVuZ3RoXG4gICAgLCBuYXJncyA9IHByb2MuYXJyYXlBcmdzLmxlbmd0aFxuICAgICwgYmxvY2tTaXplID0gcHJvYy5ibG9ja1NpemVcbiAgICAsIGhhc19pbmRleCA9IHByb2MuaW5kZXhBcmdzLmxlbmd0aCA+IDBcbiAgICAsIGNvZGUgPSBbXVxuICBmb3IodmFyIGk9MDsgaTxuYXJnczsgKytpKSB7XG4gICAgY29kZS5wdXNoKFtcInZhciBvZmZzZXRcIixpLFwiPXBcIixpXS5qb2luKFwiXCIpKVxuICB9XG4gIC8vR2VuZXJhdGUgbWF0Y2hlZCBsb29wc1xuICBmb3IodmFyIGk9bWF0Y2hlZDsgaTxkaW1lbnNpb247ICsraSkge1xuICAgIGNvZGUucHVzaChbXCJmb3IodmFyIGpcIitpK1wiPVNTW1wiLCBvcmRlcltpXSwgXCJdfDA7alwiLCBpLCBcIj4wOyl7XCJdLmpvaW4oXCJcIikpXG4gICAgY29kZS5wdXNoKFtcImlmKGpcIixpLFwiPFwiLGJsb2NrU2l6ZSxcIil7XCJdLmpvaW4oXCJcIikpXG4gICAgY29kZS5wdXNoKFtcInNcIixvcmRlcltpXSxcIj1qXCIsaV0uam9pbihcIlwiKSlcbiAgICBjb2RlLnB1c2goW1wialwiLGksXCI9MFwiXS5qb2luKFwiXCIpKVxuICAgIGNvZGUucHVzaChbXCJ9ZWxzZXtzXCIsb3JkZXJbaV0sXCI9XCIsYmxvY2tTaXplXS5qb2luKFwiXCIpKVxuICAgIGNvZGUucHVzaChbXCJqXCIsaSxcIi09XCIsYmxvY2tTaXplLFwifVwiXS5qb2luKFwiXCIpKVxuICAgIGlmKGhhc19pbmRleCkge1xuICAgICAgY29kZS5wdXNoKFtcImluZGV4W1wiLG9yZGVyW2ldLFwiXT1qXCIsaV0uam9pbihcIlwiKSlcbiAgICB9XG4gIH1cbiAgZm9yKHZhciBpPTA7IGk8bmFyZ3M7ICsraSkge1xuICAgIHZhciBpbmRleFN0ciA9IFtcIm9mZnNldFwiK2ldXG4gICAgZm9yKHZhciBqPW1hdGNoZWQ7IGo8ZGltZW5zaW9uOyArK2opIHtcbiAgICAgIGluZGV4U3RyLnB1c2goW1wialwiLGosXCIqdFwiLGksXCJwXCIsb3JkZXJbal1dLmpvaW4oXCJcIikpXG4gICAgfVxuICAgIGNvZGUucHVzaChbXCJwXCIsaSxcIj0oXCIsaW5kZXhTdHIuam9pbihcIitcIiksXCIpXCJdLmpvaW4oXCJcIikpXG4gIH1cbiAgY29kZS5wdXNoKGlubmVyRmlsbChvcmRlciwgcHJvYywgYm9keSkpXG4gIGZvcih2YXIgaT1tYXRjaGVkOyBpPGRpbWVuc2lvbjsgKytpKSB7XG4gICAgY29kZS5wdXNoKFwifVwiKVxuICB9XG4gIHJldHVybiBjb2RlLmpvaW4oXCJcXG5cIilcbn1cblxuLy9Db3VudCB0aGUgbnVtYmVyIG9mIGNvbXBhdGlibGUgaW5uZXIgb3JkZXJzXG5mdW5jdGlvbiBjb3VudE1hdGNoZXMob3JkZXJzKSB7XG4gIHZhciBtYXRjaGVkID0gMCwgZGltZW5zaW9uID0gb3JkZXJzWzBdLmxlbmd0aFxuICB3aGlsZShtYXRjaGVkIDwgZGltZW5zaW9uKSB7XG4gICAgZm9yKHZhciBqPTE7IGo8b3JkZXJzLmxlbmd0aDsgKytqKSB7XG4gICAgICBpZihvcmRlcnNbal1bbWF0Y2hlZF0gIT09IG9yZGVyc1swXVttYXRjaGVkXSkge1xuICAgICAgICByZXR1cm4gbWF0Y2hlZFxuICAgICAgfVxuICAgIH1cbiAgICArK21hdGNoZWRcbiAgfVxuICByZXR1cm4gbWF0Y2hlZFxufVxuXG4vL1Byb2Nlc3NlcyBhIGJsb2NrIGFjY29yZGluZyB0byB0aGUgZ2l2ZW4gZGF0YSB0eXBlc1xuZnVuY3Rpb24gcHJvY2Vzc0Jsb2NrKGJsb2NrLCBwcm9jLCBkdHlwZXMpIHtcbiAgdmFyIGNvZGUgPSBibG9jay5ib2R5XG4gIHZhciBwcmUgPSBbXVxuICB2YXIgcG9zdCA9IFtdXG4gIGZvcih2YXIgaT0wOyBpPGJsb2NrLmFyZ3MubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgY2FyZyA9IGJsb2NrLmFyZ3NbaV1cbiAgICBpZihjYXJnLmNvdW50IDw9IDApIHtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIHZhciByZSA9IG5ldyBSZWdFeHAoY2FyZy5uYW1lLCBcImdcIilcbiAgICB2YXIgcHRyU3RyID0gXCJcIlxuICAgIHZhciBhcnJOdW0gPSBwcm9jLmFycmF5QXJncy5pbmRleE9mKGkpXG4gICAgc3dpdGNoKHByb2MuYXJnVHlwZXNbaV0pIHtcbiAgICAgIGNhc2UgXCJvZmZzZXRcIjpcbiAgICAgICAgdmFyIG9mZkFyZ0luZGV4ID0gcHJvYy5vZmZzZXRBcmdJbmRleC5pbmRleE9mKGkpXG4gICAgICAgIHZhciBvZmZBcmcgPSBwcm9jLm9mZnNldEFyZ3Nbb2ZmQXJnSW5kZXhdXG4gICAgICAgIGFyck51bSA9IG9mZkFyZy5hcnJheVxuICAgICAgICBwdHJTdHIgPSBcIitxXCIgKyBvZmZBcmdJbmRleFxuICAgICAgY2FzZSBcImFycmF5XCI6XG4gICAgICAgIHB0clN0ciA9IFwicFwiICsgYXJyTnVtICsgcHRyU3RyXG4gICAgICAgIHZhciBsb2NhbFN0ciA9IFwibFwiICsgaVxuICAgICAgICB2YXIgYXJyU3RyID0gXCJhXCIgKyBhcnJOdW1cbiAgICAgICAgaWYoY2FyZy5jb3VudCA9PT0gMSkge1xuICAgICAgICAgIGlmKGR0eXBlc1thcnJOdW1dID09PSBcImdlbmVyaWNcIikge1xuICAgICAgICAgICAgaWYoY2FyZy5sdmFsdWUpIHtcbiAgICAgICAgICAgICAgcHJlLnB1c2goW1widmFyIFwiLCBsb2NhbFN0ciwgXCI9XCIsIGFyclN0ciwgXCIuZ2V0KFwiLCBwdHJTdHIsIFwiKVwiXS5qb2luKFwiXCIpKVxuICAgICAgICAgICAgICBjb2RlID0gY29kZS5yZXBsYWNlKHJlLCBsb2NhbFN0cilcbiAgICAgICAgICAgICAgcG9zdC5wdXNoKFthcnJTdHIsIFwiLnNldChcIiwgcHRyU3RyLCBcIixcIiwgbG9jYWxTdHIsXCIpXCJdLmpvaW4oXCJcIikpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb2RlID0gY29kZS5yZXBsYWNlKHJlLCBbYXJyU3RyLCBcIi5nZXQoXCIsIHB0clN0ciwgXCIpXCJdLmpvaW4oXCJcIikpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvZGUgPSBjb2RlLnJlcGxhY2UocmUsIFthcnJTdHIsIFwiW1wiLCBwdHJTdHIsIFwiXVwiXS5qb2luKFwiXCIpKVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmKGR0eXBlc1thcnJOdW1dID09PSBcImdlbmVyaWNcIikge1xuICAgICAgICAgIHByZS5wdXNoKFtcInZhciBcIiwgbG9jYWxTdHIsIFwiPVwiLCBhcnJTdHIsIFwiLmdldChcIiwgcHRyU3RyLCBcIilcIl0uam9pbihcIlwiKSlcbiAgICAgICAgICBjb2RlID0gY29kZS5yZXBsYWNlKHJlLCBsb2NhbFN0cilcbiAgICAgICAgICBpZihjYXJnLmx2YWx1ZSkge1xuICAgICAgICAgICAgcG9zdC5wdXNoKFthcnJTdHIsIFwiLnNldChcIiwgcHRyU3RyLCBcIixcIiwgbG9jYWxTdHIsXCIpXCJdLmpvaW4oXCJcIikpXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByZS5wdXNoKFtcInZhciBcIiwgbG9jYWxTdHIsIFwiPVwiLCBhcnJTdHIsIFwiW1wiLCBwdHJTdHIsIFwiXVwiXS5qb2luKFwiXCIpKVxuICAgICAgICAgIGNvZGUgPSBjb2RlLnJlcGxhY2UocmUsIGxvY2FsU3RyKVxuICAgICAgICAgIGlmKGNhcmcubHZhbHVlKSB7XG4gICAgICAgICAgICBwb3N0LnB1c2goW2FyclN0ciwgXCJbXCIsIHB0clN0ciwgXCJdPVwiLCBsb2NhbFN0cl0uam9pbihcIlwiKSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIGJyZWFrXG4gICAgICBjYXNlIFwic2NhbGFyXCI6XG4gICAgICAgIGNvZGUgPSBjb2RlLnJlcGxhY2UocmUsIFwiWVwiICsgcHJvYy5zY2FsYXJBcmdzLmluZGV4T2YoaSkpXG4gICAgICBicmVha1xuICAgICAgY2FzZSBcImluZGV4XCI6XG4gICAgICAgIGNvZGUgPSBjb2RlLnJlcGxhY2UocmUsIFwiaW5kZXhcIilcbiAgICAgIGJyZWFrXG4gICAgICBjYXNlIFwic2hhcGVcIjpcbiAgICAgICAgY29kZSA9IGNvZGUucmVwbGFjZShyZSwgXCJzaGFwZVwiKVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFtwcmUuam9pbihcIlxcblwiKSwgY29kZSwgcG9zdC5qb2luKFwiXFxuXCIpXS5qb2luKFwiXFxuXCIpLnRyaW0oKVxufVxuXG5mdW5jdGlvbiB0eXBlU3VtbWFyeShkdHlwZXMpIHtcbiAgdmFyIHN1bW1hcnkgPSBuZXcgQXJyYXkoZHR5cGVzLmxlbmd0aClcbiAgdmFyIGFsbEVxdWFsID0gdHJ1ZVxuICBmb3IodmFyIGk9MDsgaTxkdHlwZXMubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgdCA9IGR0eXBlc1tpXVxuICAgIHZhciBkaWdpdHMgPSB0Lm1hdGNoKC9cXGQrLylcbiAgICBpZighZGlnaXRzKSB7XG4gICAgICBkaWdpdHMgPSBcIlwiXG4gICAgfSBlbHNlIHtcbiAgICAgIGRpZ2l0cyA9IGRpZ2l0c1swXVxuICAgIH1cbiAgICBpZih0LmNoYXJBdCgwKSA9PT0gMCkge1xuICAgICAgc3VtbWFyeVtpXSA9IFwidVwiICsgdC5jaGFyQXQoMSkgKyBkaWdpdHNcbiAgICB9IGVsc2Uge1xuICAgICAgc3VtbWFyeVtpXSA9IHQuY2hhckF0KDApICsgZGlnaXRzXG4gICAgfVxuICAgIGlmKGkgPiAwKSB7XG4gICAgICBhbGxFcXVhbCA9IGFsbEVxdWFsICYmIHN1bW1hcnlbaV0gPT09IHN1bW1hcnlbaS0xXVxuICAgIH1cbiAgfVxuICBpZihhbGxFcXVhbCkge1xuICAgIHJldHVybiBzdW1tYXJ5WzBdXG4gIH1cbiAgcmV0dXJuIHN1bW1hcnkuam9pbihcIlwiKVxufVxuXG4vL0dlbmVyYXRlcyBhIGN3aXNlIG9wZXJhdG9yXG5mdW5jdGlvbiBnZW5lcmF0ZUNXaXNlT3AocHJvYywgdHlwZXNpZykge1xuXG4gIC8vQ29tcHV0ZSBkaW1lbnNpb25cbiAgdmFyIGRpbWVuc2lvbiA9IHR5cGVzaWdbMV0ubGVuZ3RofDBcbiAgdmFyIG9yZGVycyA9IG5ldyBBcnJheShwcm9jLmFycmF5QXJncy5sZW5ndGgpXG4gIHZhciBkdHlwZXMgPSBuZXcgQXJyYXkocHJvYy5hcnJheUFyZ3MubGVuZ3RoKVxuXG4gIC8vRmlyc3QgY3JlYXRlIGFyZ3VtZW50cyBmb3IgcHJvY2VkdXJlXG4gIHZhciBhcmdsaXN0ID0gW1wiU1NcIl1cbiAgdmFyIGNvZGUgPSBbXCIndXNlIHN0cmljdCdcIl1cbiAgdmFyIHZhcnMgPSBbXVxuICBcbiAgZm9yKHZhciBqPTA7IGo8ZGltZW5zaW9uOyArK2opIHtcbiAgICB2YXJzLnB1c2goW1wic1wiLCBqLCBcIj1TU1tcIiwgaiwgXCJdXCJdLmpvaW4oXCJcIikpXG4gIH1cbiAgZm9yKHZhciBpPTA7IGk8cHJvYy5hcnJheUFyZ3MubGVuZ3RoOyArK2kpIHtcbiAgICBhcmdsaXN0LnB1c2goXCJhXCIraSlcbiAgICBhcmdsaXN0LnB1c2goXCJ0XCIraSlcbiAgICBhcmdsaXN0LnB1c2goXCJwXCIraSlcbiAgICBkdHlwZXNbaV0gPSB0eXBlc2lnWzIqaV1cbiAgICBvcmRlcnNbaV0gPSB0eXBlc2lnWzIqaSsxXVxuICAgIFxuICAgIGZvcih2YXIgaj0wOyBqPGRpbWVuc2lvbjsgKytqKSB7XG4gICAgICB2YXJzLnB1c2goW1widFwiLGksXCJwXCIsaixcIj10XCIsaSxcIltcIixqLFwiXVwiXS5qb2luKFwiXCIpKVxuICAgIH1cbiAgfVxuICBmb3IodmFyIGk9MDsgaTxwcm9jLnNjYWxhckFyZ3MubGVuZ3RoOyArK2kpIHtcbiAgICBhcmdsaXN0LnB1c2goXCJZXCIgKyBpKVxuICB9XG4gIGlmKHByb2Muc2hhcGVBcmdzLmxlbmd0aCA+IDApIHtcbiAgICB2YXJzLnB1c2goXCJzaGFwZT1TUy5zbGljZSgwKVwiKVxuICB9XG4gIGlmKHByb2MuaW5kZXhBcmdzLmxlbmd0aCA+IDApIHtcbiAgICB2YXIgemVyb3MgPSBuZXcgQXJyYXkoZGltZW5zaW9uKVxuICAgIGZvcih2YXIgaT0wOyBpPGRpbWVuc2lvbjsgKytpKSB7XG4gICAgICB6ZXJvc1tpXSA9IFwiMFwiXG4gICAgfVxuICAgIHZhcnMucHVzaChbXCJpbmRleD1bXCIsIHplcm9zLmpvaW4oXCIsXCIpLCBcIl1cIl0uam9pbihcIlwiKSlcbiAgfVxuICBmb3IodmFyIGk9MDsgaTxwcm9jLm9mZnNldEFyZ3MubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgb2ZmX2FyZyA9IHByb2Mub2Zmc2V0QXJnc1tpXVxuICAgIHZhciBpbml0X3N0cmluZyA9IFtdXG4gICAgZm9yKHZhciBqPTA7IGo8b2ZmX2FyZy5vZmZzZXQubGVuZ3RoOyArK2opIHtcbiAgICAgIGlmKG9mZl9hcmcub2Zmc2V0W2pdID09PSAwKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9IGVsc2UgaWYob2ZmX2FyZy5vZmZzZXRbal0gPT09IDEpIHtcbiAgICAgICAgaW5pdF9zdHJpbmcucHVzaChbXCJ0XCIsIG9mZl9hcmcuYXJyYXksIFwicFwiLCBqXS5qb2luKFwiXCIpKSAgICAgIFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5pdF9zdHJpbmcucHVzaChbb2ZmX2FyZy5vZmZzZXRbal0sIFwiKnRcIiwgb2ZmX2FyZy5hcnJheSwgXCJwXCIsIGpdLmpvaW4oXCJcIikpXG4gICAgICB9XG4gICAgfVxuICAgIGlmKGluaXRfc3RyaW5nLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdmFycy5wdXNoKFwicVwiICsgaSArIFwiPTBcIilcbiAgICB9IGVsc2Uge1xuICAgICAgdmFycy5wdXNoKFtcInFcIiwgaSwgXCI9XCIsIGluaXRfc3RyaW5nLmpvaW4oXCIrXCIpXS5qb2luKFwiXCIpKVxuICAgIH1cbiAgfVxuXG4gIC8vUHJlcGFyZSB0aGlzIHZhcmlhYmxlc1xuICB2YXIgdGhpc1ZhcnMgPSB1bmlxKFtdLmNvbmNhdChwcm9jLnByZS50aGlzVmFycylcbiAgICAgICAgICAgICAgICAgICAgICAuY29uY2F0KHByb2MuYm9keS50aGlzVmFycylcbiAgICAgICAgICAgICAgICAgICAgICAuY29uY2F0KHByb2MucG9zdC50aGlzVmFycykpXG4gIHZhcnMgPSB2YXJzLmNvbmNhdCh0aGlzVmFycylcbiAgY29kZS5wdXNoKFwidmFyIFwiICsgdmFycy5qb2luKFwiLFwiKSlcbiAgZm9yKHZhciBpPTA7IGk8cHJvYy5hcnJheUFyZ3MubGVuZ3RoOyArK2kpIHtcbiAgICBjb2RlLnB1c2goXCJwXCIraStcInw9MFwiKVxuICB9XG4gIFxuICAvL0lubGluZSBwcmVsdWRlXG4gIGlmKHByb2MucHJlLmJvZHkubGVuZ3RoID4gMykge1xuICAgIGNvZGUucHVzaChwcm9jZXNzQmxvY2socHJvYy5wcmUsIHByb2MsIGR0eXBlcykpXG4gIH1cblxuICAvL1Byb2Nlc3MgYm9keVxuICB2YXIgYm9keSA9IHByb2Nlc3NCbG9jayhwcm9jLmJvZHksIHByb2MsIGR0eXBlcylcbiAgdmFyIG1hdGNoZWQgPSBjb3VudE1hdGNoZXMob3JkZXJzKVxuICBpZihtYXRjaGVkIDwgZGltZW5zaW9uKSB7XG4gICAgY29kZS5wdXNoKG91dGVyRmlsbChtYXRjaGVkLCBvcmRlcnNbMF0sIHByb2MsIGJvZHkpKVxuICB9IGVsc2Uge1xuICAgIGNvZGUucHVzaChpbm5lckZpbGwob3JkZXJzWzBdLCBwcm9jLCBib2R5KSlcbiAgfVxuXG4gIC8vSW5saW5lIGVwaWxvZ1xuICBpZihwcm9jLnBvc3QuYm9keS5sZW5ndGggPiAzKSB7XG4gICAgY29kZS5wdXNoKHByb2Nlc3NCbG9jayhwcm9jLnBvc3QsIHByb2MsIGR0eXBlcykpXG4gIH1cbiAgXG4gIGlmKHByb2MuZGVidWcpIHtcbiAgICBjb25zb2xlLmxvZyhcIkdlbmVyYXRlZCBjd2lzZSByb3V0aW5lIGZvciBcIiwgdHlwZXNpZywgXCI6XFxuXFxuXCIsIGNvZGUuam9pbihcIlxcblwiKSlcbiAgfVxuICBcbiAgdmFyIGxvb3BOYW1lID0gWyhwcm9jLmZ1bmNOYW1lfHxcInVubmFtZWRcIiksIFwiX2N3aXNlX2xvb3BfXCIsIG9yZGVyc1swXS5qb2luKFwic1wiKSxcIm1cIixtYXRjaGVkLHR5cGVTdW1tYXJ5KGR0eXBlcyldLmpvaW4oXCJcIilcbiAgdmFyIGYgPSBuZXcgRnVuY3Rpb24oW1wiZnVuY3Rpb24gXCIsbG9vcE5hbWUsXCIoXCIsIGFyZ2xpc3Quam9pbihcIixcIiksXCIpe1wiLCBjb2RlLmpvaW4oXCJcXG5cIiksXCJ9IHJldHVybiBcIiwgbG9vcE5hbWVdLmpvaW4oXCJcIikpXG4gIHJldHVybiBmKClcbn1cbm1vZHVsZS5leHBvcnRzID0gZ2VuZXJhdGVDV2lzZU9wIiwiXCJ1c2Ugc3RyaWN0XCJcblxudmFyIGNvbXBpbGUgPSByZXF1aXJlKFwiLi9jb21waWxlLmpzXCIpXG5cbmZ1bmN0aW9uIGNyZWF0ZVRodW5rKHByb2MpIHtcbiAgdmFyIGNvZGUgPSBbXCIndXNlIHN0cmljdCdcIiwgXCJ2YXIgQ0FDSEVEPXt9XCJdXG4gIHZhciB2YXJzID0gW11cbiAgdmFyIHRodW5rTmFtZSA9IHByb2MuZnVuY05hbWUgKyBcIl9jd2lzZV90aHVua1wiXG4gIFxuICAvL0J1aWxkIHRodW5rXG4gIGNvZGUucHVzaChbXCJyZXR1cm4gZnVuY3Rpb24gXCIsIHRodW5rTmFtZSwgXCIoXCIsIHByb2Muc2hpbUFyZ3Muam9pbihcIixcIiksIFwiKXtcIl0uam9pbihcIlwiKSlcbiAgdmFyIHR5cGVzaWcgPSBbXVxuICB2YXIgc3RyaW5nX3R5cGVzaWcgPSBbXVxuICB2YXIgcHJvY19hcmdzID0gW1tcImFycmF5XCIscHJvYy5hcnJheUFyZ3NbMF0sXCIuc2hhcGVcIl0uam9pbihcIlwiKV1cbiAgZm9yKHZhciBpPTA7IGk8cHJvYy5hcnJheUFyZ3MubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgaiA9IHByb2MuYXJyYXlBcmdzW2ldXG4gICAgdmFycy5wdXNoKFtcInRcIiwgaiwgXCI9YXJyYXlcIiwgaiwgXCIuZHR5cGUsXCIsXG4gICAgICAgICAgICAgICBcInJcIiwgaiwgXCI9YXJyYXlcIiwgaiwgXCIub3JkZXJcIl0uam9pbihcIlwiKSlcbiAgICB0eXBlc2lnLnB1c2goXCJ0XCIgKyBqKVxuICAgIHR5cGVzaWcucHVzaChcInJcIiArIGopXG4gICAgc3RyaW5nX3R5cGVzaWcucHVzaChcInRcIitqKVxuICAgIHN0cmluZ190eXBlc2lnLnB1c2goXCJyXCIraitcIi5qb2luKClcIilcbiAgICBwcm9jX2FyZ3MucHVzaChcImFycmF5XCIgKyBqICsgXCIuZGF0YVwiKVxuICAgIHByb2NfYXJncy5wdXNoKFwiYXJyYXlcIiArIGogKyBcIi5zdHJpZGVcIilcbiAgICBwcm9jX2FyZ3MucHVzaChcImFycmF5XCIgKyBqICsgXCIub2Zmc2V0fDBcIilcbiAgfVxuICBmb3IodmFyIGk9MDsgaTxwcm9jLnNjYWxhckFyZ3MubGVuZ3RoOyArK2kpIHtcbiAgICBwcm9jX2FyZ3MucHVzaChcInNjYWxhclwiICsgcHJvYy5zY2FsYXJBcmdzW2ldKVxuICB9XG4gIHZhcnMucHVzaChbXCJ0eXBlPVtcIiwgc3RyaW5nX3R5cGVzaWcuam9pbihcIixcIiksIFwiXS5qb2luKClcIl0uam9pbihcIlwiKSlcbiAgdmFycy5wdXNoKFwicHJvYz1DQUNIRURbdHlwZV1cIilcbiAgY29kZS5wdXNoKFwidmFyIFwiICsgdmFycy5qb2luKFwiLFwiKSlcbiAgXG4gIGNvZGUucHVzaChbXCJpZighcHJvYyl7XCIsXG4gICAgICAgICAgICAgXCJDQUNIRURbdHlwZV09cHJvYz1jb21waWxlKFtcIiwgdHlwZXNpZy5qb2luKFwiLFwiKSwgXCJdKX1cIixcbiAgICAgICAgICAgICBcInJldHVybiBwcm9jKFwiLCBwcm9jX2FyZ3Muam9pbihcIixcIiksIFwiKX1cIl0uam9pbihcIlwiKSlcblxuICBpZihwcm9jLmRlYnVnKSB7XG4gICAgY29uc29sZS5sb2coXCJHZW5lcmF0ZWQgdGh1bms6XCIsIGNvZGUuam9pbihcIlxcblwiKSlcbiAgfVxuICBcbiAgLy9Db21waWxlIHRodW5rXG4gIHZhciB0aHVuayA9IG5ldyBGdW5jdGlvbihcImNvbXBpbGVcIiwgY29kZS5qb2luKFwiXFxuXCIpKVxuICByZXR1cm4gdGh1bmsoY29tcGlsZS5iaW5kKHVuZGVmaW5lZCwgcHJvYykpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlVGh1bmtcbiIsIlwidXNlIHN0cmljdFwiXG5cbmZ1bmN0aW9uIHVuaXF1ZV9wcmVkKGxpc3QsIGNvbXBhcmUpIHtcbiAgdmFyIHB0ciA9IDFcbiAgICAsIGxlbiA9IGxpc3QubGVuZ3RoXG4gICAgLCBhPWxpc3RbMF0sIGI9bGlzdFswXVxuICBmb3IodmFyIGk9MTsgaTxsZW47ICsraSkge1xuICAgIGIgPSBhXG4gICAgYSA9IGxpc3RbaV1cbiAgICBpZihjb21wYXJlKGEsIGIpKSB7XG4gICAgICBpZihpID09PSBwdHIpIHtcbiAgICAgICAgcHRyKytcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cbiAgICAgIGxpc3RbcHRyKytdID0gYVxuICAgIH1cbiAgfVxuICBsaXN0Lmxlbmd0aCA9IHB0clxuICByZXR1cm4gbGlzdFxufVxuXG5mdW5jdGlvbiB1bmlxdWVfZXEobGlzdCkge1xuICB2YXIgcHRyID0gMVxuICAgICwgbGVuID0gbGlzdC5sZW5ndGhcbiAgICAsIGE9bGlzdFswXSwgYiA9IGxpc3RbMF1cbiAgZm9yKHZhciBpPTE7IGk8bGVuOyArK2ksIGI9YSkge1xuICAgIGIgPSBhXG4gICAgYSA9IGxpc3RbaV1cbiAgICBpZihhICE9PSBiKSB7XG4gICAgICBpZihpID09PSBwdHIpIHtcbiAgICAgICAgcHRyKytcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cbiAgICAgIGxpc3RbcHRyKytdID0gYVxuICAgIH1cbiAgfVxuICBsaXN0Lmxlbmd0aCA9IHB0clxuICByZXR1cm4gbGlzdFxufVxuXG5mdW5jdGlvbiB1bmlxdWUobGlzdCwgY29tcGFyZSwgc29ydGVkKSB7XG4gIGlmKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGxpc3RcbiAgfVxuICBpZihjb21wYXJlKSB7XG4gICAgaWYoIXNvcnRlZCkge1xuICAgICAgbGlzdC5zb3J0KGNvbXBhcmUpXG4gICAgfVxuICAgIHJldHVybiB1bmlxdWVfcHJlZChsaXN0LCBjb21wYXJlKVxuICB9XG4gIGlmKCFzb3J0ZWQpIHtcbiAgICBsaXN0LnNvcnQoKVxuICB9XG4gIHJldHVybiB1bmlxdWVfZXEobGlzdClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB1bmlxdWVcbiIsIi8qKlxuICogQml0IHR3aWRkbGluZyBoYWNrcyBmb3IgSmF2YVNjcmlwdC5cbiAqXG4gKiBBdXRob3I6IE1pa29sYSBMeXNlbmtvXG4gKlxuICogUG9ydGVkIGZyb20gU3RhbmZvcmQgYml0IHR3aWRkbGluZyBoYWNrIGxpYnJhcnk6XG4gKiAgICBodHRwOi8vZ3JhcGhpY3Muc3RhbmZvcmQuZWR1L35zZWFuZGVyL2JpdGhhY2tzLmh0bWxcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjsgXCJ1c2UgcmVzdHJpY3RcIjtcblxuLy9OdW1iZXIgb2YgYml0cyBpbiBhbiBpbnRlZ2VyXG52YXIgSU5UX0JJVFMgPSAzMjtcblxuLy9Db25zdGFudHNcbmV4cG9ydHMuSU5UX0JJVFMgID0gSU5UX0JJVFM7XG5leHBvcnRzLklOVF9NQVggICA9ICAweDdmZmZmZmZmO1xuZXhwb3J0cy5JTlRfTUlOICAgPSAtMTw8KElOVF9CSVRTLTEpO1xuXG4vL1JldHVybnMgLTEsIDAsICsxIGRlcGVuZGluZyBvbiBzaWduIG9mIHhcbmV4cG9ydHMuc2lnbiA9IGZ1bmN0aW9uKHYpIHtcbiAgcmV0dXJuICh2ID4gMCkgLSAodiA8IDApO1xufVxuXG4vL0NvbXB1dGVzIGFic29sdXRlIHZhbHVlIG9mIGludGVnZXJcbmV4cG9ydHMuYWJzID0gZnVuY3Rpb24odikge1xuICB2YXIgbWFzayA9IHYgPj4gKElOVF9CSVRTLTEpO1xuICByZXR1cm4gKHYgXiBtYXNrKSAtIG1hc2s7XG59XG5cbi8vQ29tcHV0ZXMgbWluaW11bSBvZiBpbnRlZ2VycyB4IGFuZCB5XG5leHBvcnRzLm1pbiA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgcmV0dXJuIHkgXiAoKHggXiB5KSAmIC0oeCA8IHkpKTtcbn1cblxuLy9Db21wdXRlcyBtYXhpbXVtIG9mIGludGVnZXJzIHggYW5kIHlcbmV4cG9ydHMubWF4ID0gZnVuY3Rpb24oeCwgeSkge1xuICByZXR1cm4geCBeICgoeCBeIHkpICYgLSh4IDwgeSkpO1xufVxuXG4vL0NoZWNrcyBpZiBhIG51bWJlciBpcyBhIHBvd2VyIG9mIHR3b1xuZXhwb3J0cy5pc1BvdzIgPSBmdW5jdGlvbih2KSB7XG4gIHJldHVybiAhKHYgJiAodi0xKSkgJiYgKCEhdik7XG59XG5cbi8vQ29tcHV0ZXMgbG9nIGJhc2UgMiBvZiB2XG5leHBvcnRzLmxvZzIgPSBmdW5jdGlvbih2KSB7XG4gIHZhciByLCBzaGlmdDtcbiAgciA9ICAgICAodiA+IDB4RkZGRikgPDwgNDsgdiA+Pj49IHI7XG4gIHNoaWZ0ID0gKHYgPiAweEZGICApIDw8IDM7IHYgPj4+PSBzaGlmdDsgciB8PSBzaGlmdDtcbiAgc2hpZnQgPSAodiA+IDB4RiAgICkgPDwgMjsgdiA+Pj49IHNoaWZ0OyByIHw9IHNoaWZ0O1xuICBzaGlmdCA9ICh2ID4gMHgzICAgKSA8PCAxOyB2ID4+Pj0gc2hpZnQ7IHIgfD0gc2hpZnQ7XG4gIHJldHVybiByIHwgKHYgPj4gMSk7XG59XG5cbi8vQ29tcHV0ZXMgbG9nIGJhc2UgMTAgb2YgdlxuZXhwb3J0cy5sb2cxMCA9IGZ1bmN0aW9uKHYpIHtcbiAgcmV0dXJuICAodiA+PSAxMDAwMDAwMDAwKSA/IDkgOiAodiA+PSAxMDAwMDAwMDApID8gOCA6ICh2ID49IDEwMDAwMDAwKSA/IDcgOlxuICAgICAgICAgICh2ID49IDEwMDAwMDApID8gNiA6ICh2ID49IDEwMDAwMCkgPyA1IDogKHYgPj0gMTAwMDApID8gNCA6XG4gICAgICAgICAgKHYgPj0gMTAwMCkgPyAzIDogKHYgPj0gMTAwKSA/IDIgOiAodiA+PSAxMCkgPyAxIDogMDtcbn1cblxuLy9Db3VudHMgbnVtYmVyIG9mIGJpdHNcbmV4cG9ydHMucG9wQ291bnQgPSBmdW5jdGlvbih2KSB7XG4gIHYgPSB2IC0gKCh2ID4+PiAxKSAmIDB4NTU1NTU1NTUpO1xuICB2ID0gKHYgJiAweDMzMzMzMzMzKSArICgodiA+Pj4gMikgJiAweDMzMzMzMzMzKTtcbiAgcmV0dXJuICgodiArICh2ID4+PiA0KSAmIDB4RjBGMEYwRikgKiAweDEwMTAxMDEpID4+PiAyNDtcbn1cblxuLy9Db3VudHMgbnVtYmVyIG9mIHRyYWlsaW5nIHplcm9zXG5mdW5jdGlvbiBjb3VudFRyYWlsaW5nWmVyb3Modikge1xuICB2YXIgYyA9IDMyO1xuICB2ICY9IC12O1xuICBpZiAodikgYy0tO1xuICBpZiAodiAmIDB4MDAwMEZGRkYpIGMgLT0gMTY7XG4gIGlmICh2ICYgMHgwMEZGMDBGRikgYyAtPSA4O1xuICBpZiAodiAmIDB4MEYwRjBGMEYpIGMgLT0gNDtcbiAgaWYgKHYgJiAweDMzMzMzMzMzKSBjIC09IDI7XG4gIGlmICh2ICYgMHg1NTU1NTU1NSkgYyAtPSAxO1xuICByZXR1cm4gYztcbn1cbmV4cG9ydHMuY291bnRUcmFpbGluZ1plcm9zID0gY291bnRUcmFpbGluZ1plcm9zO1xuXG4vL1JvdW5kcyB0byBuZXh0IHBvd2VyIG9mIDJcbmV4cG9ydHMubmV4dFBvdzIgPSBmdW5jdGlvbih2KSB7XG4gIHYgKz0gdiA9PT0gMDtcbiAgLS12O1xuICB2IHw9IHYgPj4+IDE7XG4gIHYgfD0gdiA+Pj4gMjtcbiAgdiB8PSB2ID4+PiA0O1xuICB2IHw9IHYgPj4+IDg7XG4gIHYgfD0gdiA+Pj4gMTY7XG4gIHJldHVybiB2ICsgMTtcbn1cblxuLy9Sb3VuZHMgZG93biB0byBwcmV2aW91cyBwb3dlciBvZiAyXG5leHBvcnRzLnByZXZQb3cyID0gZnVuY3Rpb24odikge1xuICB2IHw9IHYgPj4+IDE7XG4gIHYgfD0gdiA+Pj4gMjtcbiAgdiB8PSB2ID4+PiA0O1xuICB2IHw9IHYgPj4+IDg7XG4gIHYgfD0gdiA+Pj4gMTY7XG4gIHJldHVybiB2IC0gKHY+Pj4xKTtcbn1cblxuLy9Db21wdXRlcyBwYXJpdHkgb2Ygd29yZFxuZXhwb3J0cy5wYXJpdHkgPSBmdW5jdGlvbih2KSB7XG4gIHYgXj0gdiA+Pj4gMTY7XG4gIHYgXj0gdiA+Pj4gODtcbiAgdiBePSB2ID4+PiA0O1xuICB2ICY9IDB4ZjtcbiAgcmV0dXJuICgweDY5OTYgPj4+IHYpICYgMTtcbn1cblxudmFyIFJFVkVSU0VfVEFCTEUgPSBuZXcgQXJyYXkoMjU2KTtcblxuKGZ1bmN0aW9uKHRhYikge1xuICBmb3IodmFyIGk9MDsgaTwyNTY7ICsraSkge1xuICAgIHZhciB2ID0gaSwgciA9IGksIHMgPSA3O1xuICAgIGZvciAodiA+Pj49IDE7IHY7IHYgPj4+PSAxKSB7XG4gICAgICByIDw8PSAxO1xuICAgICAgciB8PSB2ICYgMTtcbiAgICAgIC0tcztcbiAgICB9XG4gICAgdGFiW2ldID0gKHIgPDwgcykgJiAweGZmO1xuICB9XG59KShSRVZFUlNFX1RBQkxFKTtcblxuLy9SZXZlcnNlIGJpdHMgaW4gYSAzMiBiaXQgd29yZFxuZXhwb3J0cy5yZXZlcnNlID0gZnVuY3Rpb24odikge1xuICByZXR1cm4gIChSRVZFUlNFX1RBQkxFWyB2ICAgICAgICAgJiAweGZmXSA8PCAyNCkgfFxuICAgICAgICAgIChSRVZFUlNFX1RBQkxFWyh2ID4+PiA4KSAgJiAweGZmXSA8PCAxNikgfFxuICAgICAgICAgIChSRVZFUlNFX1RBQkxFWyh2ID4+PiAxNikgJiAweGZmXSA8PCA4KSAgfFxuICAgICAgICAgICBSRVZFUlNFX1RBQkxFWyh2ID4+PiAyNCkgJiAweGZmXTtcbn1cblxuLy9JbnRlcmxlYXZlIGJpdHMgb2YgMiBjb29yZGluYXRlcyB3aXRoIDE2IGJpdHMuICBVc2VmdWwgZm9yIGZhc3QgcXVhZHRyZWUgY29kZXNcbmV4cG9ydHMuaW50ZXJsZWF2ZTIgPSBmdW5jdGlvbih4LCB5KSB7XG4gIHggJj0gMHhGRkZGO1xuICB4ID0gKHggfCAoeCA8PCA4KSkgJiAweDAwRkYwMEZGO1xuICB4ID0gKHggfCAoeCA8PCA0KSkgJiAweDBGMEYwRjBGO1xuICB4ID0gKHggfCAoeCA8PCAyKSkgJiAweDMzMzMzMzMzO1xuICB4ID0gKHggfCAoeCA8PCAxKSkgJiAweDU1NTU1NTU1O1xuXG4gIHkgJj0gMHhGRkZGO1xuICB5ID0gKHkgfCAoeSA8PCA4KSkgJiAweDAwRkYwMEZGO1xuICB5ID0gKHkgfCAoeSA8PCA0KSkgJiAweDBGMEYwRjBGO1xuICB5ID0gKHkgfCAoeSA8PCAyKSkgJiAweDMzMzMzMzMzO1xuICB5ID0gKHkgfCAoeSA8PCAxKSkgJiAweDU1NTU1NTU1O1xuXG4gIHJldHVybiB4IHwgKHkgPDwgMSk7XG59XG5cbi8vRXh0cmFjdHMgdGhlIG50aCBpbnRlcmxlYXZlZCBjb21wb25lbnRcbmV4cG9ydHMuZGVpbnRlcmxlYXZlMiA9IGZ1bmN0aW9uKHYsIG4pIHtcbiAgdiA9ICh2ID4+PiBuKSAmIDB4NTU1NTU1NTU7XG4gIHYgPSAodiB8ICh2ID4+PiAxKSkgICYgMHgzMzMzMzMzMztcbiAgdiA9ICh2IHwgKHYgPj4+IDIpKSAgJiAweDBGMEYwRjBGO1xuICB2ID0gKHYgfCAodiA+Pj4gNCkpICAmIDB4MDBGRjAwRkY7XG4gIHYgPSAodiB8ICh2ID4+PiAxNikpICYgMHgwMDBGRkZGO1xuICByZXR1cm4gKHYgPDwgMTYpID4+IDE2O1xufVxuXG5cbi8vSW50ZXJsZWF2ZSBiaXRzIG9mIDMgY29vcmRpbmF0ZXMsIGVhY2ggd2l0aCAxMCBiaXRzLiAgVXNlZnVsIGZvciBmYXN0IG9jdHJlZSBjb2Rlc1xuZXhwb3J0cy5pbnRlcmxlYXZlMyA9IGZ1bmN0aW9uKHgsIHksIHopIHtcbiAgeCAmPSAweDNGRjtcbiAgeCAgPSAoeCB8ICh4PDwxNikpICYgNDI3ODE5MDMzNTtcbiAgeCAgPSAoeCB8ICh4PDw4KSkgICYgMjUxNzE5Njk1O1xuICB4ICA9ICh4IHwgKHg8PDQpKSAgJiAzMjcyMzU2MDM1O1xuICB4ICA9ICh4IHwgKHg8PDIpKSAgJiAxMjI3MTMzNTEzO1xuXG4gIHkgJj0gMHgzRkY7XG4gIHkgID0gKHkgfCAoeTw8MTYpKSAmIDQyNzgxOTAzMzU7XG4gIHkgID0gKHkgfCAoeTw8OCkpICAmIDI1MTcxOTY5NTtcbiAgeSAgPSAoeSB8ICh5PDw0KSkgICYgMzI3MjM1NjAzNTtcbiAgeSAgPSAoeSB8ICh5PDwyKSkgICYgMTIyNzEzMzUxMztcbiAgeCB8PSAoeSA8PCAxKTtcbiAgXG4gIHogJj0gMHgzRkY7XG4gIHogID0gKHogfCAoejw8MTYpKSAmIDQyNzgxOTAzMzU7XG4gIHogID0gKHogfCAoejw8OCkpICAmIDI1MTcxOTY5NTtcbiAgeiAgPSAoeiB8ICh6PDw0KSkgICYgMzI3MjM1NjAzNTtcbiAgeiAgPSAoeiB8ICh6PDwyKSkgICYgMTIyNzEzMzUxMztcbiAgXG4gIHJldHVybiB4IHwgKHogPDwgMik7XG59XG5cbi8vRXh0cmFjdHMgbnRoIGludGVybGVhdmVkIGNvbXBvbmVudCBvZiBhIDMtdHVwbGVcbmV4cG9ydHMuZGVpbnRlcmxlYXZlMyA9IGZ1bmN0aW9uKHYsIG4pIHtcbiAgdiA9ICh2ID4+PiBuKSAgICAgICAmIDEyMjcxMzM1MTM7XG4gIHYgPSAodiB8ICh2Pj4+MikpICAgJiAzMjcyMzU2MDM1O1xuICB2ID0gKHYgfCAodj4+PjQpKSAgICYgMjUxNzE5Njk1O1xuICB2ID0gKHYgfCAodj4+PjgpKSAgICYgNDI3ODE5MDMzNTtcbiAgdiA9ICh2IHwgKHY+Pj4xNikpICAmIDB4M0ZGO1xuICByZXR1cm4gKHY8PDIyKT4+MjI7XG59XG5cbi8vQ29tcHV0ZXMgbmV4dCBjb21iaW5hdGlvbiBpbiBjb2xleGljb2dyYXBoaWMgb3JkZXIgKHRoaXMgaXMgbWlzdGFrZW5seSBjYWxsZWQgbmV4dFBlcm11dGF0aW9uIG9uIHRoZSBiaXQgdHdpZGRsaW5nIGhhY2tzIHBhZ2UpXG5leHBvcnRzLm5leHRDb21iaW5hdGlvbiA9IGZ1bmN0aW9uKHYpIHtcbiAgdmFyIHQgPSB2IHwgKHYgLSAxKTtcbiAgcmV0dXJuICh0ICsgMSkgfCAoKCh+dCAmIC1+dCkgLSAxKSA+Pj4gKGNvdW50VHJhaWxpbmdaZXJvcyh2KSArIDEpKTtcbn1cblxuIiwiXCJ1c2Ugc3RyaWN0XCJcblxuZnVuY3Rpb24gZHVwZV9hcnJheShjb3VudCwgdmFsdWUsIGkpIHtcbiAgdmFyIGMgPSBjb3VudFtpXXwwXG4gIGlmKGMgPD0gMCkge1xuICAgIHJldHVybiBbXVxuICB9XG4gIHZhciByZXN1bHQgPSBuZXcgQXJyYXkoYyksIGpcbiAgaWYoaSA9PT0gY291bnQubGVuZ3RoLTEpIHtcbiAgICBmb3Ioaj0wOyBqPGM7ICsraikge1xuICAgICAgcmVzdWx0W2pdID0gdmFsdWVcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yKGo9MDsgajxjOyArK2opIHtcbiAgICAgIHJlc3VsdFtqXSA9IGR1cGVfYXJyYXkoY291bnQsIHZhbHVlLCBpKzEpXG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHRcbn1cblxuZnVuY3Rpb24gZHVwZV9udW1iZXIoY291bnQsIHZhbHVlKSB7XG4gIHZhciByZXN1bHQsIGlcbiAgcmVzdWx0ID0gbmV3IEFycmF5KGNvdW50KVxuICBmb3IoaT0wOyBpPGNvdW50OyArK2kpIHtcbiAgICByZXN1bHRbaV0gPSB2YWx1ZVxuICB9XG4gIHJldHVybiByZXN1bHRcbn1cblxuZnVuY3Rpb24gZHVwZShjb3VudCwgdmFsdWUpIHtcbiAgaWYodHlwZW9mIHZhbHVlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdmFsdWUgPSAwXG4gIH1cbiAgc3dpdGNoKHR5cGVvZiBjb3VudCkge1xuICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgIGlmKGNvdW50ID4gMCkge1xuICAgICAgICByZXR1cm4gZHVwZV9udW1iZXIoY291bnR8MCwgdmFsdWUpXG4gICAgICB9XG4gICAgYnJlYWtcbiAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICBpZih0eXBlb2YgKGNvdW50Lmxlbmd0aCkgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgcmV0dXJuIGR1cGVfYXJyYXkoY291bnQsIHZhbHVlLCAwKVxuICAgICAgfVxuICAgIGJyZWFrXG4gIH1cbiAgcmV0dXJuIFtdXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZHVwZSIsIihmdW5jdGlvbiAoZ2xvYmFsLEJ1ZmZlcil7XG4ndXNlIHN0cmljdCdcblxudmFyIGJpdHMgPSByZXF1aXJlKCdiaXQtdHdpZGRsZScpXG52YXIgZHVwID0gcmVxdWlyZSgnZHVwJylcblxuLy9MZWdhY3kgcG9vbCBzdXBwb3J0XG5pZighZ2xvYmFsLl9fVFlQRURBUlJBWV9QT09MKSB7XG4gIGdsb2JhbC5fX1RZUEVEQVJSQVlfUE9PTCA9IHtcbiAgICAgIFVJTlQ4ICAgOiBkdXAoWzMyLCAwXSlcbiAgICAsIFVJTlQxNiAgOiBkdXAoWzMyLCAwXSlcbiAgICAsIFVJTlQzMiAgOiBkdXAoWzMyLCAwXSlcbiAgICAsIElOVDggICAgOiBkdXAoWzMyLCAwXSlcbiAgICAsIElOVDE2ICAgOiBkdXAoWzMyLCAwXSlcbiAgICAsIElOVDMyICAgOiBkdXAoWzMyLCAwXSlcbiAgICAsIEZMT0FUICAgOiBkdXAoWzMyLCAwXSlcbiAgICAsIERPVUJMRSAgOiBkdXAoWzMyLCAwXSlcbiAgICAsIERBVEEgICAgOiBkdXAoWzMyLCAwXSlcbiAgICAsIFVJTlQ4QyAgOiBkdXAoWzMyLCAwXSlcbiAgICAsIEJVRkZFUiAgOiBkdXAoWzMyLCAwXSlcbiAgfVxufVxuXG52YXIgaGFzVWludDhDID0gKHR5cGVvZiBVaW50OENsYW1wZWRBcnJheSkgIT09ICd1bmRlZmluZWQnXG52YXIgUE9PTCA9IGdsb2JhbC5fX1RZUEVEQVJSQVlfUE9PTFxuXG4vL1VwZ3JhZGUgcG9vbFxuaWYoIVBPT0wuVUlOVDhDKSB7XG4gIFBPT0wuVUlOVDhDID0gZHVwKFszMiwgMF0pXG59XG5pZighUE9PTC5CVUZGRVIpIHtcbiAgUE9PTC5CVUZGRVIgPSBkdXAoWzMyLCAwXSlcbn1cblxuLy9OZXcgdGVjaG5pcXVlOiBPbmx5IGFsbG9jYXRlIGZyb20gQXJyYXlCdWZmZXJWaWV3IGFuZCBCdWZmZXJcbnZhciBEQVRBICAgID0gUE9PTC5EQVRBXG4gICwgQlVGRkVSICA9IFBPT0wuQlVGRkVSXG5cbmV4cG9ydHMuZnJlZSA9IGZ1bmN0aW9uIGZyZWUoYXJyYXkpIHtcbiAgaWYoQnVmZmVyLmlzQnVmZmVyKGFycmF5KSkge1xuICAgIEJVRkZFUltiaXRzLmxvZzIoYXJyYXkubGVuZ3RoKV0ucHVzaChhcnJheSlcbiAgfSBlbHNlIHtcbiAgICBpZihPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJyYXkpICE9PSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nKSB7XG4gICAgICBhcnJheSA9IGFycmF5LmJ1ZmZlclxuICAgIH1cbiAgICBpZighYXJyYXkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB2YXIgbiA9IGFycmF5Lmxlbmd0aCB8fCBhcnJheS5ieXRlTGVuZ3RoXG4gICAgdmFyIGxvZ19uID0gYml0cy5sb2cyKG4pfDBcbiAgICBEQVRBW2xvZ19uXS5wdXNoKGFycmF5KVxuICB9XG59XG5cbmZ1bmN0aW9uIGZyZWVBcnJheUJ1ZmZlcihidWZmZXIpIHtcbiAgaWYoIWJ1ZmZlcikge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBuID0gYnVmZmVyLmxlbmd0aCB8fCBidWZmZXIuYnl0ZUxlbmd0aFxuICB2YXIgbG9nX24gPSBiaXRzLmxvZzIobilcbiAgREFUQVtsb2dfbl0ucHVzaChidWZmZXIpXG59XG5cbmZ1bmN0aW9uIGZyZWVUeXBlZEFycmF5KGFycmF5KSB7XG4gIGZyZWVBcnJheUJ1ZmZlcihhcnJheS5idWZmZXIpXG59XG5cbmV4cG9ydHMuZnJlZVVpbnQ4ID1cbmV4cG9ydHMuZnJlZVVpbnQxNiA9XG5leHBvcnRzLmZyZWVVaW50MzIgPVxuZXhwb3J0cy5mcmVlSW50OCA9XG5leHBvcnRzLmZyZWVJbnQxNiA9XG5leHBvcnRzLmZyZWVJbnQzMiA9XG5leHBvcnRzLmZyZWVGbG9hdDMyID0gXG5leHBvcnRzLmZyZWVGbG9hdCA9XG5leHBvcnRzLmZyZWVGbG9hdDY0ID0gXG5leHBvcnRzLmZyZWVEb3VibGUgPSBcbmV4cG9ydHMuZnJlZVVpbnQ4Q2xhbXBlZCA9IFxuZXhwb3J0cy5mcmVlRGF0YVZpZXcgPSBmcmVlVHlwZWRBcnJheVxuXG5leHBvcnRzLmZyZWVBcnJheUJ1ZmZlciA9IGZyZWVBcnJheUJ1ZmZlclxuXG5leHBvcnRzLmZyZWVCdWZmZXIgPSBmdW5jdGlvbiBmcmVlQnVmZmVyKGFycmF5KSB7XG4gIEJVRkZFUltiaXRzLmxvZzIoYXJyYXkubGVuZ3RoKV0ucHVzaChhcnJheSlcbn1cblxuZXhwb3J0cy5tYWxsb2MgPSBmdW5jdGlvbiBtYWxsb2MobiwgZHR5cGUpIHtcbiAgaWYoZHR5cGUgPT09IHVuZGVmaW5lZCB8fCBkdHlwZSA9PT0gJ2FycmF5YnVmZmVyJykge1xuICAgIHJldHVybiBtYWxsb2NBcnJheUJ1ZmZlcihuKVxuICB9IGVsc2Uge1xuICAgIHN3aXRjaChkdHlwZSkge1xuICAgICAgY2FzZSAndWludDgnOlxuICAgICAgICByZXR1cm4gbWFsbG9jVWludDgobilcbiAgICAgIGNhc2UgJ3VpbnQxNic6XG4gICAgICAgIHJldHVybiBtYWxsb2NVaW50MTYobilcbiAgICAgIGNhc2UgJ3VpbnQzMic6XG4gICAgICAgIHJldHVybiBtYWxsb2NVaW50MzIobilcbiAgICAgIGNhc2UgJ2ludDgnOlxuICAgICAgICByZXR1cm4gbWFsbG9jSW50OChuKVxuICAgICAgY2FzZSAnaW50MTYnOlxuICAgICAgICByZXR1cm4gbWFsbG9jSW50MTYobilcbiAgICAgIGNhc2UgJ2ludDMyJzpcbiAgICAgICAgcmV0dXJuIG1hbGxvY0ludDMyKG4pXG4gICAgICBjYXNlICdmbG9hdCc6XG4gICAgICBjYXNlICdmbG9hdDMyJzpcbiAgICAgICAgcmV0dXJuIG1hbGxvY0Zsb2F0KG4pXG4gICAgICBjYXNlICdkb3VibGUnOlxuICAgICAgY2FzZSAnZmxvYXQ2NCc6XG4gICAgICAgIHJldHVybiBtYWxsb2NEb3VibGUobilcbiAgICAgIGNhc2UgJ3VpbnQ4X2NsYW1wZWQnOlxuICAgICAgICByZXR1cm4gbWFsbG9jVWludDhDbGFtcGVkKG4pXG4gICAgICBjYXNlICdidWZmZXInOlxuICAgICAgICByZXR1cm4gbWFsbG9jQnVmZmVyKG4pXG4gICAgICBjYXNlICdkYXRhJzpcbiAgICAgIGNhc2UgJ2RhdGF2aWV3JzpcbiAgICAgICAgcmV0dXJuIG1hbGxvY0RhdGFWaWV3KG4pXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsXG59XG5cbmZ1bmN0aW9uIG1hbGxvY0FycmF5QnVmZmVyKG4pIHtcbiAgdmFyIG4gPSBiaXRzLm5leHRQb3cyKG4pXG4gIHZhciBsb2dfbiA9IGJpdHMubG9nMihuKVxuICB2YXIgZCA9IERBVEFbbG9nX25dXG4gIGlmKGQubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBkLnBvcCgpXG4gIH1cbiAgcmV0dXJuIG5ldyBBcnJheUJ1ZmZlcihuKVxufVxuZXhwb3J0cy5tYWxsb2NBcnJheUJ1ZmZlciA9IG1hbGxvY0FycmF5QnVmZmVyXG5cbmZ1bmN0aW9uIG1hbGxvY1VpbnQ4KG4pIHtcbiAgcmV0dXJuIG5ldyBVaW50OEFycmF5KG1hbGxvY0FycmF5QnVmZmVyKG4pLCAwLCBuKVxufVxuZXhwb3J0cy5tYWxsb2NVaW50OCA9IG1hbGxvY1VpbnQ4XG5cbmZ1bmN0aW9uIG1hbGxvY1VpbnQxNihuKSB7XG4gIHJldHVybiBuZXcgVWludDE2QXJyYXkobWFsbG9jQXJyYXlCdWZmZXIoMipuKSwgMCwgbilcbn1cbmV4cG9ydHMubWFsbG9jVWludDE2ID0gbWFsbG9jVWludDE2XG5cbmZ1bmN0aW9uIG1hbGxvY1VpbnQzMihuKSB7XG4gIHJldHVybiBuZXcgVWludDMyQXJyYXkobWFsbG9jQXJyYXlCdWZmZXIoNCpuKSwgMCwgbilcbn1cbmV4cG9ydHMubWFsbG9jVWludDMyID0gbWFsbG9jVWludDMyXG5cbmZ1bmN0aW9uIG1hbGxvY0ludDgobikge1xuICByZXR1cm4gbmV3IEludDhBcnJheShtYWxsb2NBcnJheUJ1ZmZlcihuKSwgMCwgbilcbn1cbmV4cG9ydHMubWFsbG9jSW50OCA9IG1hbGxvY0ludDhcblxuZnVuY3Rpb24gbWFsbG9jSW50MTYobikge1xuICByZXR1cm4gbmV3IEludDE2QXJyYXkobWFsbG9jQXJyYXlCdWZmZXIoMipuKSwgMCwgbilcbn1cbmV4cG9ydHMubWFsbG9jSW50MTYgPSBtYWxsb2NJbnQxNlxuXG5mdW5jdGlvbiBtYWxsb2NJbnQzMihuKSB7XG4gIHJldHVybiBuZXcgSW50MzJBcnJheShtYWxsb2NBcnJheUJ1ZmZlcig0Km4pLCAwLCBuKVxufVxuZXhwb3J0cy5tYWxsb2NJbnQzMiA9IG1hbGxvY0ludDMyXG5cbmZ1bmN0aW9uIG1hbGxvY0Zsb2F0KG4pIHtcbiAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkobWFsbG9jQXJyYXlCdWZmZXIoNCpuKSwgMCwgbilcbn1cbmV4cG9ydHMubWFsbG9jRmxvYXQzMiA9IGV4cG9ydHMubWFsbG9jRmxvYXQgPSBtYWxsb2NGbG9hdFxuXG5mdW5jdGlvbiBtYWxsb2NEb3VibGUobikge1xuICByZXR1cm4gbmV3IEZsb2F0NjRBcnJheShtYWxsb2NBcnJheUJ1ZmZlcig4Km4pLCAwLCBuKVxufVxuZXhwb3J0cy5tYWxsb2NGbG9hdDY0ID0gZXhwb3J0cy5tYWxsb2NEb3VibGUgPSBtYWxsb2NEb3VibGVcblxuZnVuY3Rpb24gbWFsbG9jVWludDhDbGFtcGVkKG4pIHtcbiAgaWYoaGFzVWludDhDKSB7XG4gICAgcmV0dXJuIG5ldyBVaW50OENsYW1wZWRBcnJheShtYWxsb2NBcnJheUJ1ZmZlcihuKSwgMCwgbilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbWFsbG9jVWludDgobilcbiAgfVxufVxuZXhwb3J0cy5tYWxsb2NVaW50OENsYW1wZWQgPSBtYWxsb2NVaW50OENsYW1wZWRcblxuZnVuY3Rpb24gbWFsbG9jRGF0YVZpZXcobikge1xuICByZXR1cm4gbmV3IERhdGFWaWV3KG1hbGxvY0FycmF5QnVmZmVyKG4pLCAwLCBuKVxufVxuZXhwb3J0cy5tYWxsb2NEYXRhVmlldyA9IG1hbGxvY0RhdGFWaWV3XG5cbmZ1bmN0aW9uIG1hbGxvY0J1ZmZlcihuKSB7XG4gIG4gPSBiaXRzLm5leHRQb3cyKG4pXG4gIHZhciBsb2dfbiA9IGJpdHMubG9nMihuKVxuICB2YXIgY2FjaGUgPSBCVUZGRVJbbG9nX25dXG4gIGlmKGNhY2hlLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gY2FjaGUucG9wKClcbiAgfVxuICByZXR1cm4gbmV3IEJ1ZmZlcihuKVxufVxuZXhwb3J0cy5tYWxsb2NCdWZmZXIgPSBtYWxsb2NCdWZmZXJcblxuZXhwb3J0cy5jbGVhckNhY2hlID0gZnVuY3Rpb24gY2xlYXJDYWNoZSgpIHtcbiAgZm9yKHZhciBpPTA7IGk8MzI7ICsraSkge1xuICAgIFBPT0wuVUlOVDhbaV0ubGVuZ3RoID0gMFxuICAgIFBPT0wuVUlOVDE2W2ldLmxlbmd0aCA9IDBcbiAgICBQT09MLlVJTlQzMltpXS5sZW5ndGggPSAwXG4gICAgUE9PTC5JTlQ4W2ldLmxlbmd0aCA9IDBcbiAgICBQT09MLklOVDE2W2ldLmxlbmd0aCA9IDBcbiAgICBQT09MLklOVDMyW2ldLmxlbmd0aCA9IDBcbiAgICBQT09MLkZMT0FUW2ldLmxlbmd0aCA9IDBcbiAgICBQT09MLkRPVUJMRVtpXS5sZW5ndGggPSAwXG4gICAgUE9PTC5VSU5UOENbaV0ubGVuZ3RoID0gMFxuICAgIERBVEFbaV0ubGVuZ3RoID0gMFxuICAgIEJVRkZFUltpXS5sZW5ndGggPSAwXG4gIH1cbn1cbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyKSIsIi8vIENvcHlyaWdodCAoQykgMjAxMSBHb29nbGUgSW5jLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgSW5zdGFsbCBhIGxlYWt5IFdlYWtNYXAgZW11bGF0aW9uIG9uIHBsYXRmb3JtcyB0aGF0XG4gKiBkb24ndCBwcm92aWRlIGEgYnVpbHQtaW4gb25lLlxuICpcbiAqIDxwPkFzc3VtZXMgdGhhdCBhbiBFUzUgcGxhdGZvcm0gd2hlcmUsIGlmIHtAY29kZSBXZWFrTWFwfSBpc1xuICogYWxyZWFkeSBwcmVzZW50LCB0aGVuIGl0IGNvbmZvcm1zIHRvIHRoZSBhbnRpY2lwYXRlZCBFUzZcbiAqIHNwZWNpZmljYXRpb24uIFRvIHJ1biB0aGlzIGZpbGUgb24gYW4gRVM1IG9yIGFsbW9zdCBFUzVcbiAqIGltcGxlbWVudGF0aW9uIHdoZXJlIHRoZSB7QGNvZGUgV2Vha01hcH0gc3BlY2lmaWNhdGlvbiBkb2VzIG5vdFxuICogcXVpdGUgY29uZm9ybSwgcnVuIDxjb2RlPnJlcGFpckVTNS5qczwvY29kZT4gZmlyc3QuXG4gKlxuICogPHA+RXZlbiB0aG91Z2ggV2Vha01hcE1vZHVsZSBpcyBub3QgZ2xvYmFsLCB0aGUgbGludGVyIHRoaW5rcyBpdFxuICogaXMsIHdoaWNoIGlzIHdoeSBpdCBpcyBpbiB0aGUgb3ZlcnJpZGVzIGxpc3QgYmVsb3cuXG4gKlxuICogPHA+Tk9URTogQmVmb3JlIHVzaW5nIHRoaXMgV2Vha01hcCBlbXVsYXRpb24gaW4gYSBub24tU0VTXG4gKiBlbnZpcm9ubWVudCwgc2VlIHRoZSBub3RlIGJlbG93IGFib3V0IGhpZGRlblJlY29yZC5cbiAqXG4gKiBAYXV0aG9yIE1hcmsgUy4gTWlsbGVyXG4gKiBAcmVxdWlyZXMgY3J5cHRvLCBBcnJheUJ1ZmZlciwgVWludDhBcnJheSwgbmF2aWdhdG9yLCBjb25zb2xlXG4gKiBAb3ZlcnJpZGVzIFdlYWtNYXAsIHNlcywgUHJveHlcbiAqIEBvdmVycmlkZXMgV2Vha01hcE1vZHVsZVxuICovXG5cbi8qKlxuICogVGhpcyB7QGNvZGUgV2Vha01hcH0gZW11bGF0aW9uIGlzIG9ic2VydmFibHkgZXF1aXZhbGVudCB0byB0aGVcbiAqIEVTLUhhcm1vbnkgV2Vha01hcCwgYnV0IHdpdGggbGVha2llciBnYXJiYWdlIGNvbGxlY3Rpb24gcHJvcGVydGllcy5cbiAqXG4gKiA8cD5BcyB3aXRoIHRydWUgV2Vha01hcHMsIGluIHRoaXMgZW11bGF0aW9uLCBhIGtleSBkb2VzIG5vdFxuICogcmV0YWluIG1hcHMgaW5kZXhlZCBieSB0aGF0IGtleSBhbmQgKGNydWNpYWxseSkgYSBtYXAgZG9lcyBub3RcbiAqIHJldGFpbiB0aGUga2V5cyBpdCBpbmRleGVzLiBBIG1hcCBieSBpdHNlbGYgYWxzbyBkb2VzIG5vdCByZXRhaW5cbiAqIHRoZSB2YWx1ZXMgYXNzb2NpYXRlZCB3aXRoIHRoYXQgbWFwLlxuICpcbiAqIDxwPkhvd2V2ZXIsIHRoZSB2YWx1ZXMgYXNzb2NpYXRlZCB3aXRoIGEga2V5IGluIHNvbWUgbWFwIGFyZVxuICogcmV0YWluZWQgc28gbG9uZyBhcyB0aGF0IGtleSBpcyByZXRhaW5lZCBhbmQgdGhvc2UgYXNzb2NpYXRpb25zIGFyZVxuICogbm90IG92ZXJyaWRkZW4uIEZvciBleGFtcGxlLCB3aGVuIHVzZWQgdG8gc3VwcG9ydCBtZW1icmFuZXMsIGFsbFxuICogdmFsdWVzIGV4cG9ydGVkIGZyb20gYSBnaXZlbiBtZW1icmFuZSB3aWxsIGxpdmUgZm9yIHRoZSBsaWZldGltZVxuICogdGhleSB3b3VsZCBoYXZlIGhhZCBpbiB0aGUgYWJzZW5jZSBvZiBhbiBpbnRlcnBvc2VkIG1lbWJyYW5lLiBFdmVuXG4gKiB3aGVuIHRoZSBtZW1icmFuZSBpcyByZXZva2VkLCBhbGwgb2JqZWN0cyB0aGF0IHdvdWxkIGhhdmUgYmVlblxuICogcmVhY2hhYmxlIGluIHRoZSBhYnNlbmNlIG9mIHJldm9jYXRpb24gd2lsbCBzdGlsbCBiZSByZWFjaGFibGUsIGFzXG4gKiBmYXIgYXMgdGhlIEdDIGNhbiB0ZWxsLCBldmVuIHRob3VnaCB0aGV5IHdpbGwgbm8gbG9uZ2VyIGJlIHJlbGV2YW50XG4gKiB0byBvbmdvaW5nIGNvbXB1dGF0aW9uLlxuICpcbiAqIDxwPlRoZSBBUEkgaW1wbGVtZW50ZWQgaGVyZSBpcyBhcHByb3hpbWF0ZWx5IHRoZSBBUEkgYXMgaW1wbGVtZW50ZWRcbiAqIGluIEZGNi4wYTEgYW5kIGFncmVlZCB0byBieSBNYXJrTSwgQW5kcmVhcyBHYWwsIGFuZCBEYXZlIEhlcm1hbixcbiAqIHJhdGhlciB0aGFuIHRoZSBvZmZpYWxseSBhcHByb3ZlZCBwcm9wb3NhbCBwYWdlLiBUT0RPKGVyaWdodHMpOlxuICogdXBncmFkZSB0aGUgZWNtYXNjcmlwdCBXZWFrTWFwIHByb3Bvc2FsIHBhZ2UgdG8gZXhwbGFpbiB0aGlzIEFQSVxuICogY2hhbmdlIGFuZCBwcmVzZW50IHRvIEVjbWFTY3JpcHQgY29tbWl0dGVlIGZvciB0aGVpciBhcHByb3ZhbC5cbiAqXG4gKiA8cD5UaGUgZmlyc3QgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBlbXVsYXRpb24gaGVyZSBhbmQgdGhhdCBpblxuICogRkY2LjBhMSBpcyB0aGUgcHJlc2VuY2Ugb2Ygbm9uIGVudW1lcmFibGUge0Bjb2RlIGdldF9fXywgaGFzX19fLFxuICogc2V0X19fLCBhbmQgZGVsZXRlX19ffSBtZXRob2RzIG9uIFdlYWtNYXAgaW5zdGFuY2VzIHRvIHJlcHJlc2VudFxuICogd2hhdCB3b3VsZCBiZSB0aGUgaGlkZGVuIGludGVybmFsIHByb3BlcnRpZXMgb2YgYSBwcmltaXRpdmVcbiAqIGltcGxlbWVudGF0aW9uLiBXaGVyZWFzIHRoZSBGRjYuMGExIFdlYWtNYXAucHJvdG90eXBlIG1ldGhvZHNcbiAqIHJlcXVpcmUgdGhlaXIge0Bjb2RlIHRoaXN9IHRvIGJlIGEgZ2VudWluZSBXZWFrTWFwIGluc3RhbmNlIChpLmUuLFxuICogYW4gb2JqZWN0IG9mIHtAY29kZSBbW0NsYXNzXV19IFwiV2Vha01hcH0pLCBzaW5jZSB0aGVyZSBpcyBub3RoaW5nXG4gKiB1bmZvcmdlYWJsZSBhYm91dCB0aGUgcHNldWRvLWludGVybmFsIG1ldGhvZCBuYW1lcyB1c2VkIGhlcmUsXG4gKiBub3RoaW5nIHByZXZlbnRzIHRoZXNlIGVtdWxhdGVkIHByb3RvdHlwZSBtZXRob2RzIGZyb20gYmVpbmdcbiAqIGFwcGxpZWQgdG8gbm9uLVdlYWtNYXBzIHdpdGggcHNldWRvLWludGVybmFsIG1ldGhvZHMgb2YgdGhlIHNhbWVcbiAqIG5hbWVzLlxuICpcbiAqIDxwPkFub3RoZXIgZGlmZmVyZW5jZSBpcyB0aGF0IG91ciBlbXVsYXRlZCB7QGNvZGVcbiAqIFdlYWtNYXAucHJvdG90eXBlfSBpcyBub3QgaXRzZWxmIGEgV2Vha01hcC4gQSBwcm9ibGVtIHdpdGggdGhlXG4gKiBjdXJyZW50IEZGNi4wYTEgQVBJIGlzIHRoYXQgV2Vha01hcC5wcm90b3R5cGUgaXMgaXRzZWxmIGEgV2Vha01hcFxuICogcHJvdmlkaW5nIGFtYmllbnQgbXV0YWJpbGl0eSBhbmQgYW4gYW1iaWVudCBjb21tdW5pY2F0aW9uc1xuICogY2hhbm5lbC4gVGh1cywgaWYgYSBXZWFrTWFwIGlzIGFscmVhZHkgcHJlc2VudCBhbmQgaGFzIHRoaXNcbiAqIHByb2JsZW0sIHJlcGFpckVTNS5qcyB3cmFwcyBpdCBpbiBhIHNhZmUgd3JhcHBwZXIgaW4gb3JkZXIgdG9cbiAqIHByZXZlbnQgYWNjZXNzIHRvIHRoaXMgY2hhbm5lbC4gKFNlZVxuICogUEFUQ0hfTVVUQUJMRV9GUk9aRU5fV0VBS01BUF9QUk9UTyBpbiByZXBhaXJFUzUuanMpLlxuICovXG5cbi8qKlxuICogSWYgdGhpcyBpcyBhIGZ1bGwgPGEgaHJlZj1cbiAqIFwiaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2VzLWxhYi93aWtpL1NlY3VyZWFibGVFUzVcIlxuICogPnNlY3VyZWFibGUgRVM1PC9hPiBwbGF0Zm9ybSBhbmQgdGhlIEVTLUhhcm1vbnkge0Bjb2RlIFdlYWtNYXB9IGlzXG4gKiBhYnNlbnQsIGluc3RhbGwgYW4gYXBwcm94aW1hdGUgZW11bGF0aW9uLlxuICpcbiAqIDxwPklmIFdlYWtNYXAgaXMgcHJlc2VudCBidXQgY2Fubm90IHN0b3JlIHNvbWUgb2JqZWN0cywgdXNlIG91ciBhcHByb3hpbWF0ZVxuICogZW11bGF0aW9uIGFzIGEgd3JhcHBlci5cbiAqXG4gKiA8cD5JZiB0aGlzIGlzIGFsbW9zdCBhIHNlY3VyZWFibGUgRVM1IHBsYXRmb3JtLCB0aGVuIFdlYWtNYXAuanNcbiAqIHNob3VsZCBiZSBydW4gYWZ0ZXIgcmVwYWlyRVM1LmpzLlxuICpcbiAqIDxwPlNlZSB7QGNvZGUgV2Vha01hcH0gZm9yIGRvY3VtZW50YXRpb24gb2YgdGhlIGdhcmJhZ2UgY29sbGVjdGlvblxuICogcHJvcGVydGllcyBvZiB0aGlzIFdlYWtNYXAgZW11bGF0aW9uLlxuICovXG4oZnVuY3Rpb24gV2Vha01hcE1vZHVsZSgpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgaWYgKHR5cGVvZiBzZXMgIT09ICd1bmRlZmluZWQnICYmIHNlcy5vayAmJiAhc2VzLm9rKCkpIHtcbiAgICAvLyBhbHJlYWR5IHRvbyBicm9rZW4sIHNvIGdpdmUgdXBcbiAgICByZXR1cm47XG4gIH1cblxuICAvKipcbiAgICogSW4gc29tZSBjYXNlcyAoY3VycmVudCBGaXJlZm94KSwgd2UgbXVzdCBtYWtlIGEgY2hvaWNlIGJldHdlZWVuIGFcbiAgICogV2Vha01hcCB3aGljaCBpcyBjYXBhYmxlIG9mIHVzaW5nIGFsbCB2YXJpZXRpZXMgb2YgaG9zdCBvYmplY3RzIGFzXG4gICAqIGtleXMgYW5kIG9uZSB3aGljaCBpcyBjYXBhYmxlIG9mIHNhZmVseSB1c2luZyBwcm94aWVzIGFzIGtleXMuIFNlZVxuICAgKiBjb21tZW50cyBiZWxvdyBhYm91dCBIb3N0V2Vha01hcCBhbmQgRG91YmxlV2Vha01hcCBmb3IgZGV0YWlscy5cbiAgICpcbiAgICogVGhpcyBmdW5jdGlvbiAod2hpY2ggaXMgYSBnbG9iYWwsIG5vdCBleHBvc2VkIHRvIGd1ZXN0cykgbWFya3MgYVxuICAgKiBXZWFrTWFwIGFzIHBlcm1pdHRlZCB0byBkbyB3aGF0IGlzIG5lY2Vzc2FyeSB0byBpbmRleCBhbGwgaG9zdFxuICAgKiBvYmplY3RzLCBhdCB0aGUgY29zdCBvZiBtYWtpbmcgaXQgdW5zYWZlIGZvciBwcm94aWVzLlxuICAgKlxuICAgKiBEbyBub3QgYXBwbHkgdGhpcyBmdW5jdGlvbiB0byBhbnl0aGluZyB3aGljaCBpcyBub3QgYSBnZW51aW5lXG4gICAqIGZyZXNoIFdlYWtNYXAuXG4gICAqL1xuICBmdW5jdGlvbiB3ZWFrTWFwUGVybWl0SG9zdE9iamVjdHMobWFwKSB7XG4gICAgLy8gaWRlbnRpdHkgb2YgZnVuY3Rpb24gdXNlZCBhcyBhIHNlY3JldCAtLSBnb29kIGVub3VnaCBhbmQgY2hlYXBcbiAgICBpZiAobWFwLnBlcm1pdEhvc3RPYmplY3RzX19fKSB7XG4gICAgICBtYXAucGVybWl0SG9zdE9iamVjdHNfX18od2Vha01hcFBlcm1pdEhvc3RPYmplY3RzKTtcbiAgICB9XG4gIH1cbiAgaWYgKHR5cGVvZiBzZXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgc2VzLndlYWtNYXBQZXJtaXRIb3N0T2JqZWN0cyA9IHdlYWtNYXBQZXJtaXRIb3N0T2JqZWN0cztcbiAgfVxuXG4gIC8vIElFIDExIGhhcyBubyBQcm94eSBidXQgaGFzIGEgYnJva2VuIFdlYWtNYXAgc3VjaCB0aGF0IHdlIG5lZWQgdG8gcGF0Y2hcbiAgLy8gaXQgdXNpbmcgRG91YmxlV2Vha01hcDsgdGhpcyBmbGFnIHRlbGxzIERvdWJsZVdlYWtNYXAgc28uXG4gIHZhciBkb3VibGVXZWFrTWFwQ2hlY2tTaWxlbnRGYWlsdXJlID0gZmFsc2U7XG5cbiAgLy8gQ2hlY2sgaWYgdGhlcmUgaXMgYWxyZWFkeSBhIGdvb2QtZW5vdWdoIFdlYWtNYXAgaW1wbGVtZW50YXRpb24sIGFuZCBpZiBzb1xuICAvLyBleGl0IHdpdGhvdXQgcmVwbGFjaW5nIGl0LlxuICBpZiAodHlwZW9mIFdlYWtNYXAgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgSG9zdFdlYWtNYXAgPSBXZWFrTWFwO1xuICAgIC8vIFRoZXJlIGlzIGEgV2Vha01hcCAtLSBpcyBpdCBnb29kIGVub3VnaD9cbiAgICBpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgL0ZpcmVmb3gvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkpIHtcbiAgICAgIC8vIFdlJ3JlIG5vdyAqYXNzdW1pbmcgbm90KiwgYmVjYXVzZSBhcyBvZiB0aGlzIHdyaXRpbmcgKDIwMTMtMDUtMDYpXG4gICAgICAvLyBGaXJlZm94J3MgV2Vha01hcHMgaGF2ZSBhIG1pc2NlbGxhbnkgb2Ygb2JqZWN0cyB0aGV5IHdvbid0IGFjY2VwdCwgYW5kXG4gICAgICAvLyB3ZSBkb24ndCB3YW50IHRvIG1ha2UgYW4gZXhoYXVzdGl2ZSBsaXN0LCBhbmQgdGVzdGluZyBmb3IganVzdCBvbmVcbiAgICAgIC8vIHdpbGwgYmUgYSBwcm9ibGVtIGlmIHRoYXQgb25lIGlzIGZpeGVkIGFsb25lIChhcyB0aGV5IGRpZCBmb3IgRXZlbnQpLlxuXG4gICAgICAvLyBJZiB0aGVyZSBpcyBhIHBsYXRmb3JtIHRoYXQgd2UgKmNhbiogcmVsaWFibHkgdGVzdCBvbiwgaGVyZSdzIGhvdyB0b1xuICAgICAgLy8gZG8gaXQ6XG4gICAgICAvLyAgdmFyIHByb2JsZW1hdGljID0gLi4uIDtcbiAgICAgIC8vICB2YXIgdGVzdEhvc3RNYXAgPSBuZXcgSG9zdFdlYWtNYXAoKTtcbiAgICAgIC8vICB0cnkge1xuICAgICAgLy8gICAgdGVzdEhvc3RNYXAuc2V0KHByb2JsZW1hdGljLCAxKTsgIC8vIEZpcmVmb3ggMjAgd2lsbCB0aHJvdyBoZXJlXG4gICAgICAvLyAgICBpZiAodGVzdEhvc3RNYXAuZ2V0KHByb2JsZW1hdGljKSA9PT0gMSkge1xuICAgICAgLy8gICAgICByZXR1cm47XG4gICAgICAvLyAgICB9XG4gICAgICAvLyAgfSBjYXRjaCAoZSkge31cblxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJRSAxMSBidWc6IFdlYWtNYXBzIHNpbGVudGx5IGZhaWwgdG8gc3RvcmUgZnJvemVuIG9iamVjdHMuXG4gICAgICB2YXIgdGVzdE1hcCA9IG5ldyBIb3N0V2Vha01hcCgpO1xuICAgICAgdmFyIHRlc3RPYmplY3QgPSBPYmplY3QuZnJlZXplKHt9KTtcbiAgICAgIHRlc3RNYXAuc2V0KHRlc3RPYmplY3QsIDEpO1xuICAgICAgaWYgKHRlc3RNYXAuZ2V0KHRlc3RPYmplY3QpICE9PSAxKSB7XG4gICAgICAgIGRvdWJsZVdlYWtNYXBDaGVja1NpbGVudEZhaWx1cmUgPSB0cnVlO1xuICAgICAgICAvLyBGYWxsIHRocm91Z2ggdG8gaW5zdGFsbGluZyBvdXIgV2Vha01hcC5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gV2Vha01hcDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBob3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuICB2YXIgZ29wbiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xuICB2YXIgZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbiAgdmFyIGlzRXh0ZW5zaWJsZSA9IE9iamVjdC5pc0V4dGVuc2libGU7XG5cbiAgLyoqXG4gICAqIFNlY3VyaXR5IGRlcGVuZHMgb24gSElEREVOX05BTUUgYmVpbmcgYm90aCA8aT51bmd1ZXNzYWJsZTwvaT4gYW5kXG4gICAqIDxpPnVuZGlzY292ZXJhYmxlPC9pPiBieSB1bnRydXN0ZWQgY29kZS5cbiAgICpcbiAgICogPHA+R2l2ZW4gdGhlIGtub3duIHdlYWtuZXNzZXMgb2YgTWF0aC5yYW5kb20oKSBvbiBleGlzdGluZ1xuICAgKiBicm93c2VycywgaXQgZG9lcyBub3QgZ2VuZXJhdGUgdW5ndWVzc2FiaWxpdHkgd2UgY2FuIGJlIGNvbmZpZGVudFxuICAgKiBvZi5cbiAgICpcbiAgICogPHA+SXQgaXMgdGhlIG1vbmtleSBwYXRjaGluZyBsb2dpYyBpbiB0aGlzIGZpbGUgdGhhdCBpcyBpbnRlbmRlZFxuICAgKiB0byBlbnN1cmUgdW5kaXNjb3ZlcmFiaWxpdHkuIFRoZSBiYXNpYyBpZGVhIGlzIHRoYXQgdGhlcmUgYXJlXG4gICAqIHRocmVlIGZ1bmRhbWVudGFsIG1lYW5zIG9mIGRpc2NvdmVyaW5nIHByb3BlcnRpZXMgb2YgYW4gb2JqZWN0OlxuICAgKiBUaGUgZm9yL2luIGxvb3AsIE9iamVjdC5rZXlzKCksIGFuZCBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcygpLFxuICAgKiBhcyB3ZWxsIGFzIHNvbWUgcHJvcG9zZWQgRVM2IGV4dGVuc2lvbnMgdGhhdCBhcHBlYXIgb24gb3VyXG4gICAqIHdoaXRlbGlzdC4gVGhlIGZpcnN0IHR3byBvbmx5IGRpc2NvdmVyIGVudW1lcmFibGUgcHJvcGVydGllcywgYW5kXG4gICAqIHdlIG9ubHkgdXNlIEhJRERFTl9OQU1FIHRvIG5hbWUgYSBub24tZW51bWVyYWJsZSBwcm9wZXJ0eSwgc28gdGhlXG4gICAqIG9ubHkgcmVtYWluaW5nIHRocmVhdCBzaG91bGQgYmUgZ2V0T3duUHJvcGVydHlOYW1lcyBhbmQgc29tZVxuICAgKiBwcm9wb3NlZCBFUzYgZXh0ZW5zaW9ucyB0aGF0IGFwcGVhciBvbiBvdXIgd2hpdGVsaXN0LiBXZSBtb25rZXlcbiAgICogcGF0Y2ggdGhlbSB0byByZW1vdmUgSElEREVOX05BTUUgZnJvbSB0aGUgbGlzdCBvZiBwcm9wZXJ0aWVzIHRoZXlcbiAgICogcmV0dXJucy5cbiAgICpcbiAgICogPHA+VE9ETyhlcmlnaHRzKTogT24gYSBwbGF0Zm9ybSB3aXRoIGJ1aWx0LWluIFByb3hpZXMsIHByb3hpZXNcbiAgICogY291bGQgYmUgdXNlZCB0byB0cmFwIGFuZCB0aGVyZWJ5IGRpc2NvdmVyIHRoZSBISURERU5fTkFNRSwgc28gd2VcbiAgICogbmVlZCB0byBtb25rZXkgcGF0Y2ggUHJveHkuY3JlYXRlLCBQcm94eS5jcmVhdGVGdW5jdGlvbiwgZXRjLCBpblxuICAgKiBvcmRlciB0byB3cmFwIHRoZSBwcm92aWRlZCBoYW5kbGVyIHdpdGggdGhlIHJlYWwgaGFuZGxlciB3aGljaFxuICAgKiBmaWx0ZXJzIG91dCBhbGwgdHJhcHMgdXNpbmcgSElEREVOX05BTUUuXG4gICAqXG4gICAqIDxwPlRPRE8oZXJpZ2h0cyk6IFJldmlzaXQgTWlrZSBTdGF5J3Mgc3VnZ2VzdGlvbiB0aGF0IHdlIHVzZSBhblxuICAgKiBlbmNhcHN1bGF0ZWQgZnVuY3Rpb24gYXQgYSBub3QtbmVjZXNzYXJpbHktc2VjcmV0IG5hbWUsIHdoaWNoXG4gICAqIHVzZXMgdGhlIFN0aWVnbGVyIHNoYXJlZC1zdGF0ZSByaWdodHMgYW1wbGlmaWNhdGlvbiBwYXR0ZXJuIHRvXG4gICAqIHJldmVhbCB0aGUgYXNzb2NpYXRlZCB2YWx1ZSBvbmx5IHRvIHRoZSBXZWFrTWFwIGluIHdoaWNoIHRoaXMga2V5XG4gICAqIGlzIGFzc29jaWF0ZWQgd2l0aCB0aGF0IHZhbHVlLiBTaW5jZSBvbmx5IHRoZSBrZXkgcmV0YWlucyB0aGVcbiAgICogZnVuY3Rpb24sIHRoZSBmdW5jdGlvbiBjYW4gYWxzbyByZW1lbWJlciB0aGUga2V5IHdpdGhvdXQgY2F1c2luZ1xuICAgKiBsZWFrYWdlIG9mIHRoZSBrZXksIHNvIHRoaXMgZG9lc24ndCB2aW9sYXRlIG91ciBnZW5lcmFsIGdjXG4gICAqIGdvYWxzLiBJbiBhZGRpdGlvbiwgYmVjYXVzZSB0aGUgbmFtZSBuZWVkIG5vdCBiZSBhIGd1YXJkZWRcbiAgICogc2VjcmV0LCB3ZSBjb3VsZCBlZmZpY2llbnRseSBoYW5kbGUgY3Jvc3MtZnJhbWUgZnJvemVuIGtleXMuXG4gICAqL1xuICB2YXIgSElEREVOX05BTUVfUFJFRklYID0gJ3dlYWttYXA6JztcbiAgdmFyIEhJRERFTl9OQU1FID0gSElEREVOX05BTUVfUFJFRklYICsgJ2lkZW50OicgKyBNYXRoLnJhbmRvbSgpICsgJ19fXyc7XG5cbiAgaWYgKHR5cGVvZiBjcnlwdG8gIT09ICd1bmRlZmluZWQnICYmXG4gICAgICB0eXBlb2YgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgdHlwZW9mIEFycmF5QnVmZmVyID09PSAnZnVuY3Rpb24nICYmXG4gICAgICB0eXBlb2YgVWludDhBcnJheSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBhYiA9IG5ldyBBcnJheUJ1ZmZlcigyNSk7XG4gICAgdmFyIHU4cyA9IG5ldyBVaW50OEFycmF5KGFiKTtcbiAgICBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKHU4cyk7XG4gICAgSElEREVOX05BTUUgPSBISURERU5fTkFNRV9QUkVGSVggKyAncmFuZDonICtcbiAgICAgIEFycmF5LnByb3RvdHlwZS5tYXAuY2FsbCh1OHMsIGZ1bmN0aW9uKHU4KSB7XG4gICAgICAgIHJldHVybiAodTggJSAzNikudG9TdHJpbmcoMzYpO1xuICAgICAgfSkuam9pbignJykgKyAnX19fJztcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzTm90SGlkZGVuTmFtZShuYW1lKSB7XG4gICAgcmV0dXJuICEoXG4gICAgICAgIG5hbWUuc3Vic3RyKDAsIEhJRERFTl9OQU1FX1BSRUZJWC5sZW5ndGgpID09IEhJRERFTl9OQU1FX1BSRUZJWCAmJlxuICAgICAgICBuYW1lLnN1YnN0cihuYW1lLmxlbmd0aCAtIDMpID09PSAnX19fJyk7XG4gIH1cblxuICAvKipcbiAgICogTW9ua2V5IHBhdGNoIGdldE93blByb3BlcnR5TmFtZXMgdG8gYXZvaWQgcmV2ZWFsaW5nIHRoZVxuICAgKiBISURERU5fTkFNRS5cbiAgICpcbiAgICogPHA+VGhlIEVTNS4xIHNwZWMgcmVxdWlyZXMgZWFjaCBuYW1lIHRvIGFwcGVhciBvbmx5IG9uY2UsIGJ1dCBhc1xuICAgKiBvZiB0aGlzIHdyaXRpbmcsIHRoaXMgcmVxdWlyZW1lbnQgaXMgY29udHJvdmVyc2lhbCBmb3IgRVM2LCBzbyB3ZVxuICAgKiBtYWRlIHRoaXMgY29kZSByb2J1c3QgYWdhaW5zdCB0aGlzIGNhc2UuIElmIHRoZSByZXN1bHRpbmcgZXh0cmFcbiAgICogc2VhcmNoIHR1cm5zIG91dCB0byBiZSBleHBlbnNpdmUsIHdlIGNhbiBwcm9iYWJseSByZWxheCB0aGlzIG9uY2VcbiAgICogRVM2IGlzIGFkZXF1YXRlbHkgc3VwcG9ydGVkIG9uIGFsbCBtYWpvciBicm93c2VycywgaWZmIG5vIGJyb3dzZXJcbiAgICogdmVyc2lvbnMgd2Ugc3VwcG9ydCBhdCB0aGF0IHRpbWUgaGF2ZSByZWxheGVkIHRoaXMgY29uc3RyYWludFxuICAgKiB3aXRob3V0IHByb3ZpZGluZyBidWlsdC1pbiBFUzYgV2Vha01hcHMuXG4gICAqL1xuICBkZWZQcm9wKE9iamVjdCwgJ2dldE93blByb3BlcnR5TmFtZXMnLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZha2VHZXRPd25Qcm9wZXJ0eU5hbWVzKG9iaikge1xuICAgICAgcmV0dXJuIGdvcG4ob2JqKS5maWx0ZXIoaXNOb3RIaWRkZW5OYW1lKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBnZXRQcm9wZXJ0eU5hbWVzIGlzIG5vdCBpbiBFUzUgYnV0IGl0IGlzIHByb3Bvc2VkIGZvciBFUzYgYW5kXG4gICAqIGRvZXMgYXBwZWFyIGluIG91ciB3aGl0ZWxpc3QsIHNvIHdlIG5lZWQgdG8gY2xlYW4gaXQgdG9vLlxuICAgKi9cbiAgaWYgKCdnZXRQcm9wZXJ0eU5hbWVzJyBpbiBPYmplY3QpIHtcbiAgICB2YXIgb3JpZ2luYWxHZXRQcm9wZXJ0eU5hbWVzID0gT2JqZWN0LmdldFByb3BlcnR5TmFtZXM7XG4gICAgZGVmUHJvcChPYmplY3QsICdnZXRQcm9wZXJ0eU5hbWVzJywge1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZha2VHZXRQcm9wZXJ0eU5hbWVzKG9iaikge1xuICAgICAgICByZXR1cm4gb3JpZ2luYWxHZXRQcm9wZXJ0eU5hbWVzKG9iaikuZmlsdGVyKGlzTm90SGlkZGVuTmFtZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogPHA+VG8gdHJlYXQgb2JqZWN0cyBhcyBpZGVudGl0eS1rZXlzIHdpdGggcmVhc29uYWJsZSBlZmZpY2llbmN5XG4gICAqIG9uIEVTNSBieSBpdHNlbGYgKGkuZS4sIHdpdGhvdXQgYW55IG9iamVjdC1rZXllZCBjb2xsZWN0aW9ucyksIHdlXG4gICAqIG5lZWQgdG8gYWRkIGEgaGlkZGVuIHByb3BlcnR5IHRvIHN1Y2gga2V5IG9iamVjdHMgd2hlbiB3ZVxuICAgKiBjYW4uIFRoaXMgcmFpc2VzIHNldmVyYWwgaXNzdWVzOlxuICAgKiA8dWw+XG4gICAqIDxsaT5BcnJhbmdpbmcgdG8gYWRkIHRoaXMgcHJvcGVydHkgdG8gb2JqZWN0cyBiZWZvcmUgd2UgbG9zZSB0aGVcbiAgICogICAgIGNoYW5jZSwgYW5kXG4gICAqIDxsaT5IaWRpbmcgdGhlIGV4aXN0ZW5jZSBvZiB0aGlzIG5ldyBwcm9wZXJ0eSBmcm9tIG1vc3RcbiAgICogICAgIEphdmFTY3JpcHQgY29kZS5cbiAgICogPGxpPlByZXZlbnRpbmcgPGk+Y2VydGlmaWNhdGlvbiB0aGVmdDwvaT4sIHdoZXJlIG9uZSBvYmplY3QgaXNcbiAgICogICAgIGNyZWF0ZWQgZmFsc2VseSBjbGFpbWluZyB0byBiZSB0aGUga2V5IG9mIGFuIGFzc29jaWF0aW9uXG4gICAqICAgICBhY3R1YWxseSBrZXllZCBieSBhbm90aGVyIG9iamVjdC5cbiAgICogPGxpPlByZXZlbnRpbmcgPGk+dmFsdWUgdGhlZnQ8L2k+LCB3aGVyZSB1bnRydXN0ZWQgY29kZSB3aXRoXG4gICAqICAgICBhY2Nlc3MgdG8gYSBrZXkgb2JqZWN0IGJ1dCBub3QgYSB3ZWFrIG1hcCBuZXZlcnRoZWxlc3NcbiAgICogICAgIG9idGFpbnMgYWNjZXNzIHRvIHRoZSB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggdGhhdCBrZXkgaW4gdGhhdFxuICAgKiAgICAgd2VhayBtYXAuXG4gICAqIDwvdWw+XG4gICAqIFdlIGRvIHNvIGJ5XG4gICAqIDx1bD5cbiAgICogPGxpPk1ha2luZyB0aGUgbmFtZSBvZiB0aGUgaGlkZGVuIHByb3BlcnR5IHVuZ3Vlc3NhYmxlLCBzbyBcIltdXCJcbiAgICogICAgIGluZGV4aW5nLCB3aGljaCB3ZSBjYW5ub3QgaW50ZXJjZXB0LCBjYW5ub3QgYmUgdXNlZCB0byBhY2Nlc3NcbiAgICogICAgIGEgcHJvcGVydHkgd2l0aG91dCBrbm93aW5nIHRoZSBuYW1lLlxuICAgKiA8bGk+TWFraW5nIHRoZSBoaWRkZW4gcHJvcGVydHkgbm9uLWVudW1lcmFibGUsIHNvIHdlIG5lZWQgbm90XG4gICAqICAgICB3b3JyeSBhYm91dCBmb3ItaW4gbG9vcHMgb3Ige0Bjb2RlIE9iamVjdC5rZXlzfSxcbiAgICogPGxpPm1vbmtleSBwYXRjaGluZyB0aG9zZSByZWZsZWN0aXZlIG1ldGhvZHMgdGhhdCB3b3VsZFxuICAgKiAgICAgcHJldmVudCBleHRlbnNpb25zLCB0byBhZGQgdGhpcyBoaWRkZW4gcHJvcGVydHkgZmlyc3QsXG4gICAqIDxsaT5tb25rZXkgcGF0Y2hpbmcgdGhvc2UgbWV0aG9kcyB0aGF0IHdvdWxkIHJldmVhbCB0aGlzXG4gICAqICAgICBoaWRkZW4gcHJvcGVydHkuXG4gICAqIDwvdWw+XG4gICAqIFVuZm9ydHVuYXRlbHksIGJlY2F1c2Ugb2Ygc2FtZS1vcmlnaW4gaWZyYW1lcywgd2UgY2Fubm90IHJlbGlhYmx5XG4gICAqIGFkZCB0aGlzIGhpZGRlbiBwcm9wZXJ0eSBiZWZvcmUgYW4gb2JqZWN0IGJlY29tZXNcbiAgICogbm9uLWV4dGVuc2libGUuIEluc3RlYWQsIGlmIHdlIGVuY291bnRlciBhIG5vbi1leHRlbnNpYmxlIG9iamVjdFxuICAgKiB3aXRob3V0IGEgaGlkZGVuIHJlY29yZCB0aGF0IHdlIGNhbiBkZXRlY3QgKHdoZXRoZXIgb3Igbm90IGl0IGhhc1xuICAgKiBhIGhpZGRlbiByZWNvcmQgc3RvcmVkIHVuZGVyIGEgbmFtZSBzZWNyZXQgdG8gdXMpLCB0aGVuIHdlIGp1c3RcbiAgICogdXNlIHRoZSBrZXkgb2JqZWN0IGl0c2VsZiB0byByZXByZXNlbnQgaXRzIGlkZW50aXR5IGluIGEgYnJ1dGVcbiAgICogZm9yY2UgbGVha3kgbWFwIHN0b3JlZCBpbiB0aGUgd2VhayBtYXAsIGxvc2luZyBhbGwgdGhlIGFkdmFudGFnZXNcbiAgICogb2Ygd2Vha25lc3MgZm9yIHRoZXNlLlxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0SGlkZGVuUmVjb3JkKGtleSkge1xuICAgIGlmIChrZXkgIT09IE9iamVjdChrZXkpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdOb3QgYW4gb2JqZWN0OiAnICsga2V5KTtcbiAgICB9XG4gICAgdmFyIGhpZGRlblJlY29yZCA9IGtleVtISURERU5fTkFNRV07XG4gICAgaWYgKGhpZGRlblJlY29yZCAmJiBoaWRkZW5SZWNvcmQua2V5ID09PSBrZXkpIHsgcmV0dXJuIGhpZGRlblJlY29yZDsgfVxuICAgIGlmICghaXNFeHRlbnNpYmxlKGtleSkpIHtcbiAgICAgIC8vIFdlYWsgbWFwIG11c3QgYnJ1dGUgZm9yY2UsIGFzIGV4cGxhaW5lZCBpbiBkb2MtY29tbWVudCBhYm92ZS5cbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuXG4gICAgLy8gVGhlIGhpZGRlblJlY29yZCBhbmQgdGhlIGtleSBwb2ludCBkaXJlY3RseSBhdCBlYWNoIG90aGVyLCB2aWFcbiAgICAvLyB0aGUgXCJrZXlcIiBhbmQgSElEREVOX05BTUUgcHJvcGVydGllcyByZXNwZWN0aXZlbHkuIFRoZSBrZXlcbiAgICAvLyBmaWVsZCBpcyBmb3IgcXVpY2tseSB2ZXJpZnlpbmcgdGhhdCB0aGlzIGhpZGRlbiByZWNvcmQgaXMgYW5cbiAgICAvLyBvd24gcHJvcGVydHksIG5vdCBhIGhpZGRlbiByZWNvcmQgZnJvbSB1cCB0aGUgcHJvdG90eXBlIGNoYWluLlxuICAgIC8vXG4gICAgLy8gTk9URTogQmVjYXVzZSB0aGlzIFdlYWtNYXAgZW11bGF0aW9uIGlzIG1lYW50IG9ubHkgZm9yIHN5c3RlbXMgbGlrZVxuICAgIC8vIFNFUyB3aGVyZSBPYmplY3QucHJvdG90eXBlIGlzIGZyb3plbiB3aXRob3V0IGFueSBudW1lcmljXG4gICAgLy8gcHJvcGVydGllcywgaXQgaXMgb2sgdG8gdXNlIGFuIG9iamVjdCBsaXRlcmFsIGZvciB0aGUgaGlkZGVuUmVjb3JkLlxuICAgIC8vIFRoaXMgaGFzIHR3byBhZHZhbnRhZ2VzOlxuICAgIC8vICogSXQgaXMgbXVjaCBmYXN0ZXIgaW4gYSBwZXJmb3JtYW5jZSBjcml0aWNhbCBwbGFjZVxuICAgIC8vICogSXQgYXZvaWRzIHJlbHlpbmcgb24gT2JqZWN0LmNyZWF0ZShudWxsKSwgd2hpY2ggaGFkIGJlZW5cbiAgICAvLyAgIHByb2JsZW1hdGljIG9uIENocm9tZSAyOC4wLjE0ODAuMC4gU2VlXG4gICAgLy8gICBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2dvb2dsZS1jYWphL2lzc3Vlcy9kZXRhaWw/aWQ9MTY4N1xuICAgIGhpZGRlblJlY29yZCA9IHsga2V5OiBrZXkgfTtcblxuICAgIC8vIFdoZW4gdXNpbmcgdGhpcyBXZWFrTWFwIGVtdWxhdGlvbiBvbiBwbGF0Zm9ybXMgd2hlcmVcbiAgICAvLyBPYmplY3QucHJvdG90eXBlIG1pZ2h0IG5vdCBiZSBmcm96ZW4gYW5kIE9iamVjdC5jcmVhdGUobnVsbCkgaXNcbiAgICAvLyByZWxpYWJsZSwgdXNlIHRoZSBmb2xsb3dpbmcgdHdvIGNvbW1lbnRlZCBvdXQgbGluZXMgaW5zdGVhZC5cbiAgICAvLyBoaWRkZW5SZWNvcmQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIC8vIGhpZGRlblJlY29yZC5rZXkgPSBrZXk7XG5cbiAgICAvLyBQbGVhc2UgY29udGFjdCB1cyBpZiB5b3UgbmVlZCB0aGlzIHRvIHdvcmsgb24gcGxhdGZvcm1zIHdoZXJlXG4gICAgLy8gT2JqZWN0LnByb3RvdHlwZSBtaWdodCBub3QgYmUgZnJvemVuIGFuZFxuICAgIC8vIE9iamVjdC5jcmVhdGUobnVsbCkgbWlnaHQgbm90IGJlIHJlbGlhYmxlLlxuXG4gICAgdHJ5IHtcbiAgICAgIGRlZlByb3Aoa2V5LCBISURERU5fTkFNRSwge1xuICAgICAgICB2YWx1ZTogaGlkZGVuUmVjb3JkLFxuICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBoaWRkZW5SZWNvcmQ7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIFVuZGVyIHNvbWUgY2lyY3Vtc3RhbmNlcywgaXNFeHRlbnNpYmxlIHNlZW1zIHRvIG1pc3JlcG9ydCB3aGV0aGVyXG4gICAgICAvLyB0aGUgSElEREVOX05BTUUgY2FuIGJlIGRlZmluZWQuXG4gICAgICAvLyBUaGUgY2lyY3Vtc3RhbmNlcyBoYXZlIG5vdCBiZWVuIGlzb2xhdGVkLCBidXQgYXQgbGVhc3QgYWZmZWN0XG4gICAgICAvLyBOb2RlLmpzIHYwLjEwLjI2IG9uIFRyYXZpc0NJIC8gTGludXgsIGJ1dCBub3QgdGhlIHNhbWUgdmVyc2lvbiBvZlxuICAgICAgLy8gTm9kZS5qcyBvbiBPUyBYLlxuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTW9ua2V5IHBhdGNoIG9wZXJhdGlvbnMgdGhhdCB3b3VsZCBtYWtlIHRoZWlyIGFyZ3VtZW50XG4gICAqIG5vbi1leHRlbnNpYmxlLlxuICAgKlxuICAgKiA8cD5UaGUgbW9ua2V5IHBhdGNoZWQgdmVyc2lvbnMgdGhyb3cgYSBUeXBlRXJyb3IgaWYgdGhlaXJcbiAgICogYXJndW1lbnQgaXMgbm90IGFuIG9iamVjdCwgc28gaXQgc2hvdWxkIG9ubHkgYmUgZG9uZSB0byBmdW5jdGlvbnNcbiAgICogdGhhdCBzaG91bGQgdGhyb3cgYSBUeXBlRXJyb3IgYW55d2F5IGlmIHRoZWlyIGFyZ3VtZW50IGlzIG5vdCBhblxuICAgKiBvYmplY3QuXG4gICAqL1xuICAoZnVuY3Rpb24oKXtcbiAgICB2YXIgb2xkRnJlZXplID0gT2JqZWN0LmZyZWV6ZTtcbiAgICBkZWZQcm9wKE9iamVjdCwgJ2ZyZWV6ZScsIHtcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBpZGVudGlmeWluZ0ZyZWV6ZShvYmopIHtcbiAgICAgICAgZ2V0SGlkZGVuUmVjb3JkKG9iaik7XG4gICAgICAgIHJldHVybiBvbGRGcmVlemUob2JqKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB2YXIgb2xkU2VhbCA9IE9iamVjdC5zZWFsO1xuICAgIGRlZlByb3AoT2JqZWN0LCAnc2VhbCcsIHtcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBpZGVudGlmeWluZ1NlYWwob2JqKSB7XG4gICAgICAgIGdldEhpZGRlblJlY29yZChvYmopO1xuICAgICAgICByZXR1cm4gb2xkU2VhbChvYmopO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHZhciBvbGRQcmV2ZW50RXh0ZW5zaW9ucyA9IE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucztcbiAgICBkZWZQcm9wKE9iamVjdCwgJ3ByZXZlbnRFeHRlbnNpb25zJywge1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGlkZW50aWZ5aW5nUHJldmVudEV4dGVuc2lvbnMob2JqKSB7XG4gICAgICAgIGdldEhpZGRlblJlY29yZChvYmopO1xuICAgICAgICByZXR1cm4gb2xkUHJldmVudEV4dGVuc2lvbnMob2JqKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSkoKTtcblxuICBmdW5jdGlvbiBjb25zdEZ1bmMoZnVuYykge1xuICAgIGZ1bmMucHJvdG90eXBlID0gbnVsbDtcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZShmdW5jKTtcbiAgfVxuXG4gIHZhciBjYWxsZWRBc0Z1bmN0aW9uV2FybmluZ0RvbmUgPSBmYWxzZTtcbiAgZnVuY3Rpb24gY2FsbGVkQXNGdW5jdGlvbldhcm5pbmcoKSB7XG4gICAgLy8gRnV0dXJlIEVTNiBXZWFrTWFwIGlzIGN1cnJlbnRseSAoMjAxMy0wOS0xMCkgZXhwZWN0ZWQgdG8gcmVqZWN0IFdlYWtNYXAoKVxuICAgIC8vIGJ1dCB3ZSB1c2VkIHRvIHBlcm1pdCBpdCBhbmQgZG8gaXQgb3Vyc2VsdmVzLCBzbyB3YXJuIG9ubHkuXG4gICAgaWYgKCFjYWxsZWRBc0Z1bmN0aW9uV2FybmluZ0RvbmUgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjYWxsZWRBc0Z1bmN0aW9uV2FybmluZ0RvbmUgPSB0cnVlO1xuICAgICAgY29uc29sZS53YXJuKCdXZWFrTWFwIHNob3VsZCBiZSBpbnZva2VkIGFzIG5ldyBXZWFrTWFwKCksIG5vdCAnICtcbiAgICAgICAgICAnV2Vha01hcCgpLiBUaGlzIHdpbGwgYmUgYW4gZXJyb3IgaW4gdGhlIGZ1dHVyZS4nKTtcbiAgICB9XG4gIH1cblxuICB2YXIgbmV4dElkID0gMDtcblxuICB2YXIgT3VyV2Vha01hcCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBPdXJXZWFrTWFwKSkgeyAgLy8gYXBwcm94aW1hdGUgdGVzdCBmb3IgbmV3IC4uLigpXG4gICAgICBjYWxsZWRBc0Z1bmN0aW9uV2FybmluZygpO1xuICAgIH1cblxuICAgIC8vIFdlIGFyZSBjdXJyZW50bHkgKDEyLzI1LzIwMTIpIG5ldmVyIGVuY291bnRlcmluZyBhbnkgcHJlbWF0dXJlbHlcbiAgICAvLyBub24tZXh0ZW5zaWJsZSBrZXlzLlxuICAgIHZhciBrZXlzID0gW107IC8vIGJydXRlIGZvcmNlIGZvciBwcmVtYXR1cmVseSBub24tZXh0ZW5zaWJsZSBrZXlzLlxuICAgIHZhciB2YWx1ZXMgPSBbXTsgLy8gYnJ1dGUgZm9yY2UgZm9yIGNvcnJlc3BvbmRpbmcgdmFsdWVzLlxuICAgIHZhciBpZCA9IG5leHRJZCsrO1xuXG4gICAgZnVuY3Rpb24gZ2V0X19fKGtleSwgb3B0X2RlZmF1bHQpIHtcbiAgICAgIHZhciBpbmRleDtcbiAgICAgIHZhciBoaWRkZW5SZWNvcmQgPSBnZXRIaWRkZW5SZWNvcmQoa2V5KTtcbiAgICAgIGlmIChoaWRkZW5SZWNvcmQpIHtcbiAgICAgICAgcmV0dXJuIGlkIGluIGhpZGRlblJlY29yZCA/IGhpZGRlblJlY29yZFtpZF0gOiBvcHRfZGVmYXVsdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluZGV4ID0ga2V5cy5pbmRleE9mKGtleSk7XG4gICAgICAgIHJldHVybiBpbmRleCA+PSAwID8gdmFsdWVzW2luZGV4XSA6IG9wdF9kZWZhdWx0O1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhc19fXyhrZXkpIHtcbiAgICAgIHZhciBoaWRkZW5SZWNvcmQgPSBnZXRIaWRkZW5SZWNvcmQoa2V5KTtcbiAgICAgIGlmIChoaWRkZW5SZWNvcmQpIHtcbiAgICAgICAgcmV0dXJuIGlkIGluIGhpZGRlblJlY29yZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBrZXlzLmluZGV4T2Yoa2V5KSA+PSAwO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldF9fXyhrZXksIHZhbHVlKSB7XG4gICAgICB2YXIgaW5kZXg7XG4gICAgICB2YXIgaGlkZGVuUmVjb3JkID0gZ2V0SGlkZGVuUmVjb3JkKGtleSk7XG4gICAgICBpZiAoaGlkZGVuUmVjb3JkKSB7XG4gICAgICAgIGhpZGRlblJlY29yZFtpZF0gPSB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluZGV4ID0ga2V5cy5pbmRleE9mKGtleSk7XG4gICAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgICAgdmFsdWVzW2luZGV4XSA9IHZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFNpbmNlIHNvbWUgYnJvd3NlcnMgcHJlZW1wdGl2ZWx5IHRlcm1pbmF0ZSBzbG93IHR1cm5zIGJ1dFxuICAgICAgICAgIC8vIHRoZW4gY29udGludWUgY29tcHV0aW5nIHdpdGggcHJlc3VtYWJseSBjb3JydXB0ZWQgaGVhcFxuICAgICAgICAgIC8vIHN0YXRlLCB3ZSBoZXJlIGRlZmVuc2l2ZWx5IGdldCBrZXlzLmxlbmd0aCBmaXJzdCBhbmQgdGhlblxuICAgICAgICAgIC8vIHVzZSBpdCB0byB1cGRhdGUgYm90aCB0aGUgdmFsdWVzIGFuZCBrZXlzIGFycmF5cywga2VlcGluZ1xuICAgICAgICAgIC8vIHRoZW0gaW4gc3luYy5cbiAgICAgICAgICBpbmRleCA9IGtleXMubGVuZ3RoO1xuICAgICAgICAgIHZhbHVlc1tpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgICAvLyBJZiB3ZSBjcmFzaCBoZXJlLCB2YWx1ZXMgd2lsbCBiZSBvbmUgbG9uZ2VyIHRoYW4ga2V5cy5cbiAgICAgICAgICBrZXlzW2luZGV4XSA9IGtleTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVsZXRlX19fKGtleSkge1xuICAgICAgdmFyIGhpZGRlblJlY29yZCA9IGdldEhpZGRlblJlY29yZChrZXkpO1xuICAgICAgdmFyIGluZGV4LCBsYXN0SW5kZXg7XG4gICAgICBpZiAoaGlkZGVuUmVjb3JkKSB7XG4gICAgICAgIHJldHVybiBpZCBpbiBoaWRkZW5SZWNvcmQgJiYgZGVsZXRlIGhpZGRlblJlY29yZFtpZF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbmRleCA9IGtleXMuaW5kZXhPZihrZXkpO1xuICAgICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNpbmNlIHNvbWUgYnJvd3NlcnMgcHJlZW1wdGl2ZWx5IHRlcm1pbmF0ZSBzbG93IHR1cm5zIGJ1dFxuICAgICAgICAvLyB0aGVuIGNvbnRpbnVlIGNvbXB1dGluZyB3aXRoIHBvdGVudGlhbGx5IGNvcnJ1cHRlZCBoZWFwXG4gICAgICAgIC8vIHN0YXRlLCB3ZSBoZXJlIGRlZmVuc2l2ZWx5IGdldCBrZXlzLmxlbmd0aCBmaXJzdCBhbmQgdGhlbiB1c2VcbiAgICAgICAgLy8gaXQgdG8gdXBkYXRlIGJvdGggdGhlIGtleXMgYW5kIHRoZSB2YWx1ZXMgYXJyYXksIGtlZXBpbmdcbiAgICAgICAgLy8gdGhlbSBpbiBzeW5jLiBXZSB1cGRhdGUgdGhlIHR3byB3aXRoIGFuIG9yZGVyIG9mIGFzc2lnbm1lbnRzLFxuICAgICAgICAvLyBzdWNoIHRoYXQgYW55IHByZWZpeCBvZiB0aGVzZSBhc3NpZ25tZW50cyB3aWxsIHByZXNlcnZlIHRoZVxuICAgICAgICAvLyBrZXkvdmFsdWUgY29ycmVzcG9uZGVuY2UsIGVpdGhlciBiZWZvcmUgb3IgYWZ0ZXIgdGhlIGRlbGV0ZS5cbiAgICAgICAgLy8gTm90ZSB0aGF0IHRoaXMgbmVlZHMgdG8gd29yayBjb3JyZWN0bHkgd2hlbiBpbmRleCA9PT0gbGFzdEluZGV4LlxuICAgICAgICBsYXN0SW5kZXggPSBrZXlzLmxlbmd0aCAtIDE7XG4gICAgICAgIGtleXNbaW5kZXhdID0gdm9pZCAwO1xuICAgICAgICAvLyBJZiB3ZSBjcmFzaCBoZXJlLCB0aGVyZSdzIGEgdm9pZCAwIGluIHRoZSBrZXlzIGFycmF5LCBidXRcbiAgICAgICAgLy8gbm8gb3BlcmF0aW9uIHdpbGwgY2F1c2UgYSBcImtleXMuaW5kZXhPZih2b2lkIDApXCIsIHNpbmNlXG4gICAgICAgIC8vIGdldEhpZGRlblJlY29yZCh2b2lkIDApIHdpbGwgYWx3YXlzIHRocm93IGFuIGVycm9yIGZpcnN0LlxuICAgICAgICB2YWx1ZXNbaW5kZXhdID0gdmFsdWVzW2xhc3RJbmRleF07XG4gICAgICAgIC8vIElmIHdlIGNyYXNoIGhlcmUsIHZhbHVlc1tpbmRleF0gY2Fubm90IGJlIGZvdW5kIGhlcmUsXG4gICAgICAgIC8vIGJlY2F1c2Uga2V5c1tpbmRleF0gaXMgdm9pZCAwLlxuICAgICAgICBrZXlzW2luZGV4XSA9IGtleXNbbGFzdEluZGV4XTtcbiAgICAgICAgLy8gSWYgaW5kZXggPT09IGxhc3RJbmRleCBhbmQgd2UgY3Jhc2ggaGVyZSwgdGhlbiBrZXlzW2luZGV4XVxuICAgICAgICAvLyBpcyBzdGlsbCB2b2lkIDAsIHNpbmNlIHRoZSBhbGlhc2luZyBraWxsZWQgdGhlIHByZXZpb3VzIGtleS5cbiAgICAgICAga2V5cy5sZW5ndGggPSBsYXN0SW5kZXg7XG4gICAgICAgIC8vIElmIHdlIGNyYXNoIGhlcmUsIGtleXMgd2lsbCBiZSBvbmUgc2hvcnRlciB0aGFuIHZhbHVlcy5cbiAgICAgICAgdmFsdWVzLmxlbmd0aCA9IGxhc3RJbmRleDtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIE9iamVjdC5jcmVhdGUoT3VyV2Vha01hcC5wcm90b3R5cGUsIHtcbiAgICAgIGdldF9fXzogICAgeyB2YWx1ZTogY29uc3RGdW5jKGdldF9fXykgfSxcbiAgICAgIGhhc19fXzogICAgeyB2YWx1ZTogY29uc3RGdW5jKGhhc19fXykgfSxcbiAgICAgIHNldF9fXzogICAgeyB2YWx1ZTogY29uc3RGdW5jKHNldF9fXykgfSxcbiAgICAgIGRlbGV0ZV9fXzogeyB2YWx1ZTogY29uc3RGdW5jKGRlbGV0ZV9fXykgfVxuICAgIH0pO1xuICB9O1xuXG4gIE91cldlYWtNYXAucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShPYmplY3QucHJvdG90eXBlLCB7XG4gICAgZ2V0OiB7XG4gICAgICAvKipcbiAgICAgICAqIFJldHVybiB0aGUgdmFsdWUgbW9zdCByZWNlbnRseSBhc3NvY2lhdGVkIHdpdGgga2V5LCBvclxuICAgICAgICogb3B0X2RlZmF1bHQgaWYgbm9uZS5cbiAgICAgICAqL1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldChrZXksIG9wdF9kZWZhdWx0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldF9fXyhrZXksIG9wdF9kZWZhdWx0KTtcbiAgICAgIH0sXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0sXG5cbiAgICBoYXM6IHtcbiAgICAgIC8qKlxuICAgICAgICogSXMgdGhlcmUgYSB2YWx1ZSBhc3NvY2lhdGVkIHdpdGgga2V5IGluIHRoaXMgV2Vha01hcD9cbiAgICAgICAqL1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGhhcyhrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFzX19fKGtleSk7XG4gICAgICB9LFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9LFxuXG4gICAgc2V0OiB7XG4gICAgICAvKipcbiAgICAgICAqIEFzc29jaWF0ZSB2YWx1ZSB3aXRoIGtleSBpbiB0aGlzIFdlYWtNYXAsIG92ZXJ3cml0aW5nIGFueVxuICAgICAgICogcHJldmlvdXMgYXNzb2NpYXRpb24gaWYgcHJlc2VudC5cbiAgICAgICAqL1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldChrZXksIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldF9fXyhrZXksIHZhbHVlKTtcbiAgICAgIH0sXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0sXG5cbiAgICAnZGVsZXRlJzoge1xuICAgICAgLyoqXG4gICAgICAgKiBSZW1vdmUgYW55IGFzc29jaWF0aW9uIGZvciBrZXkgaW4gdGhpcyBXZWFrTWFwLCByZXR1cm5pbmdcbiAgICAgICAqIHdoZXRoZXIgdGhlcmUgd2FzIG9uZS5cbiAgICAgICAqXG4gICAgICAgKiA8cD5Ob3RlIHRoYXQgdGhlIGJvb2xlYW4gcmV0dXJuIGhlcmUgZG9lcyBub3Qgd29yayBsaWtlIHRoZVxuICAgICAgICoge0Bjb2RlIGRlbGV0ZX0gb3BlcmF0b3IuIFRoZSB7QGNvZGUgZGVsZXRlfSBvcGVyYXRvciByZXR1cm5zXG4gICAgICAgKiB3aGV0aGVyIHRoZSBkZWxldGlvbiBzdWNjZWVkcyBhdCBicmluZ2luZyBhYm91dCBhIHN0YXRlIGluXG4gICAgICAgKiB3aGljaCB0aGUgZGVsZXRlZCBwcm9wZXJ0eSBpcyBhYnNlbnQuIFRoZSB7QGNvZGUgZGVsZXRlfVxuICAgICAgICogb3BlcmF0b3IgdGhlcmVmb3JlIHJldHVybnMgdHJ1ZSBpZiB0aGUgcHJvcGVydHkgd2FzIGFscmVhZHlcbiAgICAgICAqIGFic2VudCwgd2hlcmVhcyB0aGlzIHtAY29kZSBkZWxldGV9IG1ldGhvZCByZXR1cm5zIGZhbHNlIGlmXG4gICAgICAgKiB0aGUgYXNzb2NpYXRpb24gd2FzIGFscmVhZHkgYWJzZW50LlxuICAgICAgICovXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWxldGVfX18oa2V5KTtcbiAgICAgIH0sXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG5cbiAgaWYgKHR5cGVvZiBIb3N0V2Vha01hcCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIChmdW5jdGlvbigpIHtcbiAgICAgIC8vIElmIHdlIGdvdCBoZXJlLCB0aGVuIHRoZSBwbGF0Zm9ybSBoYXMgYSBXZWFrTWFwIGJ1dCB3ZSBhcmUgY29uY2VybmVkXG4gICAgICAvLyB0aGF0IGl0IG1heSByZWZ1c2UgdG8gc3RvcmUgc29tZSBrZXkgdHlwZXMuIFRoZXJlZm9yZSwgbWFrZSBhIG1hcFxuICAgICAgLy8gaW1wbGVtZW50YXRpb24gd2hpY2ggbWFrZXMgdXNlIG9mIGJvdGggYXMgcG9zc2libGUuXG5cbiAgICAgIC8vIEluIHRoaXMgbW9kZSB3ZSBhcmUgYWx3YXlzIHVzaW5nIGRvdWJsZSBtYXBzLCBzbyB3ZSBhcmUgbm90IHByb3h5LXNhZmUuXG4gICAgICAvLyBUaGlzIGNvbWJpbmF0aW9uIGRvZXMgbm90IG9jY3VyIGluIGFueSBrbm93biBicm93c2VyLCBidXQgd2UgaGFkIGJlc3RcbiAgICAgIC8vIGJlIHNhZmUuXG4gICAgICBpZiAoZG91YmxlV2Vha01hcENoZWNrU2lsZW50RmFpbHVyZSAmJiB0eXBlb2YgUHJveHkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIFByb3h5ID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBEb3VibGVXZWFrTWFwKCkge1xuICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgT3VyV2Vha01hcCkpIHsgIC8vIGFwcHJveGltYXRlIHRlc3QgZm9yIG5ldyAuLi4oKVxuICAgICAgICAgIGNhbGxlZEFzRnVuY3Rpb25XYXJuaW5nKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBQcmVmZXJhYmxlLCB0cnVseSB3ZWFrIG1hcC5cbiAgICAgICAgdmFyIGhtYXAgPSBuZXcgSG9zdFdlYWtNYXAoKTtcblxuICAgICAgICAvLyBPdXIgaGlkZGVuLXByb3BlcnR5LWJhc2VkIHBzZXVkby13ZWFrLW1hcC4gTGF6aWx5IGluaXRpYWxpemVkIGluIHRoZVxuICAgICAgICAvLyAnc2V0JyBpbXBsZW1lbnRhdGlvbjsgdGh1cyB3ZSBjYW4gYXZvaWQgcGVyZm9ybWluZyBleHRyYSBsb29rdXBzIGlmXG4gICAgICAgIC8vIHdlIGtub3cgYWxsIGVudHJpZXMgYWN0dWFsbHkgc3RvcmVkIGFyZSBlbnRlcmVkIGluICdobWFwJy5cbiAgICAgICAgdmFyIG9tYXAgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgLy8gSGlkZGVuLXByb3BlcnR5IG1hcHMgYXJlIG5vdCBjb21wYXRpYmxlIHdpdGggcHJveGllcyBiZWNhdXNlIHByb3hpZXNcbiAgICAgICAgLy8gY2FuIG9ic2VydmUgdGhlIGhpZGRlbiBuYW1lIGFuZCBlaXRoZXIgYWNjaWRlbnRhbGx5IGV4cG9zZSBpdCBvciBmYWlsXG4gICAgICAgIC8vIHRvIGFsbG93IHRoZSBoaWRkZW4gcHJvcGVydHkgdG8gYmUgc2V0LiBUaGVyZWZvcmUsIHdlIGRvIG5vdCBhbGxvd1xuICAgICAgICAvLyBhcmJpdHJhcnkgV2Vha01hcHMgdG8gc3dpdGNoIHRvIHVzaW5nIGhpZGRlbiBwcm9wZXJ0aWVzLCBidXQgb25seVxuICAgICAgICAvLyB0aG9zZSB3aGljaCBuZWVkIHRoZSBhYmlsaXR5LCBhbmQgdW5wcml2aWxlZ2VkIGNvZGUgaXMgbm90IGFsbG93ZWRcbiAgICAgICAgLy8gdG8gc2V0IHRoZSBmbGFnLlxuICAgICAgICAvL1xuICAgICAgICAvLyAoRXhjZXB0IGluIGRvdWJsZVdlYWtNYXBDaGVja1NpbGVudEZhaWx1cmUgbW9kZSBpbiB3aGljaCBjYXNlIHdlXG4gICAgICAgIC8vIGRpc2FibGUgcHJveGllcy4pXG4gICAgICAgIHZhciBlbmFibGVTd2l0Y2hpbmcgPSBmYWxzZTtcblxuICAgICAgICBmdW5jdGlvbiBkZ2V0KGtleSwgb3B0X2RlZmF1bHQpIHtcbiAgICAgICAgICBpZiAob21hcCkge1xuICAgICAgICAgICAgcmV0dXJuIGhtYXAuaGFzKGtleSkgPyBobWFwLmdldChrZXkpXG4gICAgICAgICAgICAgICAgOiBvbWFwLmdldF9fXyhrZXksIG9wdF9kZWZhdWx0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGhtYXAuZ2V0KGtleSwgb3B0X2RlZmF1bHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGRoYXMoa2V5KSB7XG4gICAgICAgICAgcmV0dXJuIGhtYXAuaGFzKGtleSkgfHwgKG9tYXAgPyBvbWFwLmhhc19fXyhrZXkpIDogZmFsc2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRzZXQ7XG4gICAgICAgIGlmIChkb3VibGVXZWFrTWFwQ2hlY2tTaWxlbnRGYWlsdXJlKSB7XG4gICAgICAgICAgZHNldCA9IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIGhtYXAuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgaWYgKCFobWFwLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICAgIGlmICghb21hcCkgeyBvbWFwID0gbmV3IE91cldlYWtNYXAoKTsgfVxuICAgICAgICAgICAgICBvbWFwLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZHNldCA9IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChlbmFibGVTd2l0Y2hpbmcpIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBobWFwLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGlmICghb21hcCkgeyBvbWFwID0gbmV3IE91cldlYWtNYXAoKTsgfVxuICAgICAgICAgICAgICAgIG9tYXAuc2V0X19fKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBobWFwLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBkZGVsZXRlKGtleSkge1xuICAgICAgICAgIHZhciByZXN1bHQgPSAhIWhtYXBbJ2RlbGV0ZSddKGtleSk7XG4gICAgICAgICAgaWYgKG9tYXApIHsgcmV0dXJuIG9tYXAuZGVsZXRlX19fKGtleSkgfHwgcmVzdWx0OyB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBPYmplY3QuY3JlYXRlKE91cldlYWtNYXAucHJvdG90eXBlLCB7XG4gICAgICAgICAgZ2V0X19fOiAgICB7IHZhbHVlOiBjb25zdEZ1bmMoZGdldCkgfSxcbiAgICAgICAgICBoYXNfX186ICAgIHsgdmFsdWU6IGNvbnN0RnVuYyhkaGFzKSB9LFxuICAgICAgICAgIHNldF9fXzogICAgeyB2YWx1ZTogY29uc3RGdW5jKGRzZXQpIH0sXG4gICAgICAgICAgZGVsZXRlX19fOiB7IHZhbHVlOiBjb25zdEZ1bmMoZGRlbGV0ZSkgfSxcbiAgICAgICAgICBwZXJtaXRIb3N0T2JqZWN0c19fXzogeyB2YWx1ZTogY29uc3RGdW5jKGZ1bmN0aW9uKHRva2VuKSB7XG4gICAgICAgICAgICBpZiAodG9rZW4gPT09IHdlYWtNYXBQZXJtaXRIb3N0T2JqZWN0cykge1xuICAgICAgICAgICAgICBlbmFibGVTd2l0Y2hpbmcgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdib2d1cyBjYWxsIHRvIHBlcm1pdEhvc3RPYmplY3RzX19fJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSl9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgRG91YmxlV2Vha01hcC5wcm90b3R5cGUgPSBPdXJXZWFrTWFwLnByb3RvdHlwZTtcbiAgICAgIG1vZHVsZS5leHBvcnRzID0gRG91YmxlV2Vha01hcDtcblxuICAgICAgLy8gZGVmaW5lIC5jb25zdHJ1Y3RvciB0byBoaWRlIE91cldlYWtNYXAgY3RvclxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdlYWtNYXAucHJvdG90eXBlLCAnY29uc3RydWN0b3InLCB7XG4gICAgICAgIHZhbHVlOiBXZWFrTWFwLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSwgIC8vIGFzIGRlZmF1bHQgLmNvbnN0cnVjdG9yIGlzXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgIH0pKCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gVGhlcmUgaXMgbm8gaG9zdCBXZWFrTWFwLCBzbyB3ZSBtdXN0IHVzZSB0aGUgZW11bGF0aW9uLlxuXG4gICAgLy8gRW11bGF0ZWQgV2Vha01hcHMgYXJlIGluY29tcGF0aWJsZSB3aXRoIG5hdGl2ZSBwcm94aWVzIChiZWNhdXNlIHByb3hpZXNcbiAgICAvLyBjYW4gb2JzZXJ2ZSB0aGUgaGlkZGVuIG5hbWUpLCBzbyB3ZSBtdXN0IGRpc2FibGUgUHJveHkgdXNhZ2UgKGluXG4gICAgLy8gQXJyYXlMaWtlIGFuZCBEb21hZG8sIGN1cnJlbnRseSkuXG4gICAgaWYgKHR5cGVvZiBQcm94eSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIFByb3h5ID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gT3VyV2Vha01hcDtcbiAgfVxufSkoKTtcbiIsIid1c2Ugc3RyaWN0J1xuXG52YXIgd2Vha01hcCA9IHR5cGVvZiBXZWFrTWFwID09PSAndW5kZWZpbmVkJyA/IHJlcXVpcmUoJ3dlYWstbWFwJykgOiBXZWFrTWFwXG5cbnZhciBXZWJHTEVXU3RydWN0ID0gbmV3IHdlYWtNYXAoKVxuXG5mdW5jdGlvbiBiYXNlTmFtZShleHRfbmFtZSkge1xuICByZXR1cm4gZXh0X25hbWUucmVwbGFjZSgvXltBLVpdK18vLCAnJylcbn1cblxuZnVuY3Rpb24gaW5pdFdlYkdMRVcoZ2wpIHtcbiAgdmFyIHN0cnVjdCA9IFdlYkdMRVdTdHJ1Y3QuZ2V0KGdsKVxuICBpZihzdHJ1Y3QpIHtcbiAgICByZXR1cm4gc3RydWN0XG4gIH1cbiAgdmFyIGV4dGVuc2lvbnMgPSB7fVxuICB2YXIgc3VwcG9ydGVkID0gZ2wuZ2V0U3VwcG9ydGVkRXh0ZW5zaW9ucygpXG4gIGZvcih2YXIgaT0wOyBpPHN1cHBvcnRlZC5sZW5ndGg7ICsraSkge1xuICAgIHZhciBleHROYW1lID0gc3VwcG9ydGVkW2ldXG5cbiAgICAvL1NraXAgTU9aXyBleHRlbnNpb25zXG4gICAgaWYoZXh0TmFtZS5pbmRleE9mKCdNT1pfJykgPT09IDApIHtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIHZhciBleHQgPSBnbC5nZXRFeHRlbnNpb24oc3VwcG9ydGVkW2ldKVxuICAgIGlmKCFleHQpIHtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIHdoaWxlKHRydWUpIHtcbiAgICAgIGV4dGVuc2lvbnNbZXh0TmFtZV0gPSBleHRcbiAgICAgIHZhciBiYXNlID0gYmFzZU5hbWUoZXh0TmFtZSlcbiAgICAgIGlmKGJhc2UgPT09IGV4dE5hbWUpIHtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGV4dE5hbWUgPSBiYXNlXG4gICAgfVxuICB9XG4gIFdlYkdMRVdTdHJ1Y3Quc2V0KGdsLCBleHRlbnNpb25zKVxuICByZXR1cm4gZXh0ZW5zaW9uc1xufVxubW9kdWxlLmV4cG9ydHMgPSBpbml0V2ViR0xFVyIsInZhciB4dGVuZCA9IHJlcXVpcmUoJ3h0ZW5kJylcblxudmFyIGRlZmF1bHRzID0ge1xuXHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRjb25maWd1cmFibGU6IHRydWVcbn1cblxuZnVuY3Rpb24gbWl4KG9iaiwgZW50cmllcykge1xuXHRmb3IgKHZhciBrIGluIGVudHJpZXMpIHtcblx0XHRpZiAoIWVudHJpZXMuaGFzT3duUHJvcGVydHkoaykpXG5cdFx0XHRjb250aW51ZVxuXHRcdHZhciBmID0gZW50cmllc1trXVxuXHRcdGlmICh0eXBlb2YgZiA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0b2JqW2tdID0gZlxuXHRcdH0gZWxzZSBpZiAoZiAmJiB0eXBlb2YgZiA9PT0gJ29iamVjdCcpIHtcblx0XHRcdHZhciBkZWYgPSB4dGVuZChkZWZhdWx0cywgZilcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGssIGRlZik7XG5cdFx0fVxuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbWl4ZXMoY3RvciwgZW50cmllcykge1xuXHRtaXgoY3Rvci5wcm90b3R5cGUsIGVudHJpZXMpXG59XG5cbm1vZHVsZS5leHBvcnRzLm1peCA9IG1peCIsIm1vZHVsZS5leHBvcnRzPXJlcXVpcmUoXCIvcHJvamVjdHMvYmxhY2tpY2Uvbm9kZV9tb2R1bGVzL2dsLXNwcml0ZS10ZXh0L25vZGVfbW9kdWxlcy9nbC1zcHJpdGUtYmF0Y2gvbm9kZV9tb2R1bGVzL2dsLWJ1ZmZlci9ub2RlX21vZHVsZXMvbmRhcnJheS1vcHMvbmRhcnJheS1vcHMuanNcIikiLCJtb2R1bGUuZXhwb3J0cz1yZXF1aXJlKFwiL3Byb2plY3RzL2JsYWNraWNlL25vZGVfbW9kdWxlcy9nbC1zcHJpdGUtdGV4dC9ub2RlX21vZHVsZXMvZ2wtc3ByaXRlLWJhdGNoL25vZGVfbW9kdWxlcy9nbC1idWZmZXIvbm9kZV9tb2R1bGVzL3R5cGVkYXJyYXktcG9vbC9wb29sLmpzXCIpIiwibW9kdWxlLmV4cG9ydHM9cmVxdWlyZShcIi9wcm9qZWN0cy9ibGFja2ljZS9ub2RlX21vZHVsZXMvZ2wtc3ByaXRlLXRleHQvbm9kZV9tb2R1bGVzL2dsLXNwcml0ZS1iYXRjaC9ub2RlX21vZHVsZXMvZ2wtYnVmZmVyL25vZGVfbW9kdWxlcy93ZWJnbGV3L3dlYmdsZXcuanNcIikiLCIndXNlIHN0cmljdCdcblxudmFyIG5kYXJyYXkgPSByZXF1aXJlKCduZGFycmF5JylcbnZhciBvcHMgICAgID0gcmVxdWlyZSgnbmRhcnJheS1vcHMnKVxudmFyIHBvb2wgICAgPSByZXF1aXJlKCd0eXBlZGFycmF5LXBvb2wnKVxudmFyIHdlYmdsZXcgPSByZXF1aXJlKCd3ZWJnbGV3JylcblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVUZXh0dXJlMkRcblxudmFyIGxpbmVhclR5cGVzID0gbnVsbFxudmFyIGZpbHRlclR5cGVzID0gbnVsbFxudmFyIHdyYXBUeXBlcyAgID0gbnVsbFxuXG5mdW5jdGlvbiBsYXp5SW5pdExpbmVhclR5cGVzKGdsKSB7XG4gIGxpbmVhclR5cGVzID0gW1xuICAgIGdsLkxJTkVBUixcbiAgICBnbC5ORUFSRVNUX01JUE1BUF9MSU5FQVIsXG4gICAgZ2wuTElORUFSX01JUE1BUF9ORUFSRVNULFxuICAgIGdsLkxJTkVBUl9NSVBNQVBfTkVBUkVTVFxuICBdXG4gIGZpbHRlclR5cGVzID0gW1xuICAgIGdsLk5FQVJFU1QsXG4gICAgZ2wuTElORUFSLFxuICAgIGdsLk5FQVJFU1RfTUlQTUFQX05FQVJFU1QsXG4gICAgZ2wuTkVBUkVTVF9NSVBNQVBfTElORUFSLFxuICAgIGdsLkxJTkVBUl9NSVBNQVBfTkVBUkVTVCxcbiAgICBnbC5MSU5FQVJfTUlQTUFQX0xJTkVBUlxuICBdXG4gIHdyYXBUeXBlcyA9IFtcbiAgICBnbC5SRVBFQVQsXG4gICAgZ2wuQ0xBTVBfVE9fRURHRSxcbiAgICBnbC5NSVJST1JFRF9SRVBFQVRcbiAgXVxufVxuXG52YXIgY29udmVydEZsb2F0VG9VaW50OCA9IGZ1bmN0aW9uKG91dCwgaW5wKSB7XG4gIG9wcy5tdWxzKG91dCwgaW5wLCAyNTUuMClcbn1cblxuZnVuY3Rpb24gcmVzaGFwZVRleHR1cmUodGV4LCB3LCBoKSB7XG4gIHZhciBnbCA9IHRleC5nbFxuICB2YXIgbWF4U2l6ZSA9IGdsLmdldFBhcmFtZXRlcihnbC5NQVhfVEVYVFVSRV9TSVpFKVxuICBpZih3IDwgMCB8fCB3ID4gbWF4U2l6ZSB8fCBoIDwgMCB8fCBoID4gbWF4U2l6ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignZ2wtdGV4dHVyZTJkOiBJbnZhbGlkIHRleHR1cmUgc2l6ZScpXG4gIH1cbiAgdGV4Ll9zaGFwZSA9IFt3LCBoXVxuICB0ZXguYmluZCgpXG4gIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgdGV4LmZvcm1hdCwgdywgaCwgMCwgdGV4LmZvcm1hdCwgdGV4LnR5cGUsIG51bGwpXG4gIHRleC5fbWlwTGV2ZWxzID0gWzBdXG4gIHJldHVybiB0ZXhcbn1cblxuZnVuY3Rpb24gVGV4dHVyZTJEKGdsLCBoYW5kbGUsIHdpZHRoLCBoZWlnaHQsIGZvcm1hdCwgdHlwZSkge1xuICB0aGlzLmdsID0gZ2xcbiAgdGhpcy5oYW5kbGUgPSBoYW5kbGVcbiAgdGhpcy5mb3JtYXQgPSBmb3JtYXRcbiAgdGhpcy50eXBlID0gdHlwZVxuICB0aGlzLl9zaGFwZSA9IFt3aWR0aCwgaGVpZ2h0XVxuICB0aGlzLl9taXBMZXZlbHMgPSBbMF1cbiAgdGhpcy5fbWFnRmlsdGVyID0gZ2wuTkVBUkVTVFxuICB0aGlzLl9taW5GaWx0ZXIgPSBnbC5ORUFSRVNUXG4gIHRoaXMuX3dyYXBTID0gZ2wuQ0xBTVBfVE9fRURHRVxuICB0aGlzLl93cmFwVCA9IGdsLkNMQU1QX1RPX0VER0VcbiAgdGhpcy5fYW5pc29TYW1wbGVzID0gMVxuXG4gIHZhciBwYXJlbnQgPSB0aGlzXG4gIHZhciB3cmFwVmVjdG9yID0gW3RoaXMuX3dyYXBTLCB0aGlzLl93cmFwVF1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMod3JhcFZlY3RvciwgW1xuICAgIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBwYXJlbnQuX3dyYXBTXG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbih2KSB7XG4gICAgICAgIHJldHVybiBwYXJlbnQud3JhcFMgPSB2XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gcGFyZW50Ll93cmFwVFxuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24odikge1xuICAgICAgICByZXR1cm4gcGFyZW50LndyYXBUID0gdlxuICAgICAgfVxuICAgIH1cbiAgXSlcbiAgdGhpcy5fd3JhcFZlY3RvciA9IHdyYXBWZWN0b3JcblxuICB2YXIgc2hhcGVWZWN0b3IgPSBbdGhpcy5fc2hhcGVbMF0sIHRoaXMuX3NoYXBlWzFdXVxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhzaGFwZVZlY3RvciwgW1xuICAgIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBwYXJlbnQuX3NoYXBlWzBdXG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbih2KSB7XG4gICAgICAgIHJldHVybiBwYXJlbnQud2lkdGggPSB2XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gcGFyZW50Ll9zaGFwZVsxXVxuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24odikge1xuICAgICAgICByZXR1cm4gcGFyZW50LmhlaWdodCA9IHZcbiAgICAgIH1cbiAgICB9XG4gIF0pXG4gIHRoaXMuX3NoYXBlVmVjdG9yID0gc2hhcGVWZWN0b3Jcbn1cblxudmFyIHByb3RvID0gVGV4dHVyZTJELnByb3RvdHlwZVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhwcm90bywge1xuICBtaW5GaWx0ZXI6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX21pbkZpbHRlclxuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbih2KSB7XG4gICAgICB0aGlzLmJpbmQoKVxuICAgICAgdmFyIGdsID0gdGhpcy5nbFxuICAgICAgaWYodGhpcy50eXBlID09PSBnbC5GTE9BVCAmJiBsaW5lYXJUeXBlcy5pbmRleE9mKHYpID49IDApIHtcbiAgICAgICAgaWYoIXdlYmdsZXcoZ2wpLnRleHR1cmVfZmxvYXRfbGluZWFyKSB7XG4gICAgICAgICAgdiA9IGdsLk5FQVJFU1RcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYoZmlsdGVyVHlwZXMuaW5kZXhPZih2KSA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdnbC10ZXh0dXJlMmQ6IFVua25vd24gZmlsdGVyIG1vZGUgJyArIHYpXG4gICAgICB9XG4gICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgdilcbiAgICAgIHJldHVybiB0aGlzLl9taW5GaWx0ZXIgPSB2XG4gICAgfVxuICB9LFxuICBtYWdGaWx0ZXI6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX21hZ0ZpbHRlclxuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbih2KSB7XG4gICAgICB0aGlzLmJpbmQoKVxuICAgICAgdmFyIGdsID0gdGhpcy5nbFxuICAgICAgaWYodGhpcy50eXBlID09PSBnbC5GTE9BVCAmJiBsaW5lYXJUeXBlcy5pbmRleE9mKHYpID49IDApIHtcbiAgICAgICAgaWYoIXdlYmdsZXcoZ2wpLnRleHR1cmVfZmxvYXRfbGluZWFyKSB7XG4gICAgICAgICAgdiA9IGdsLk5FQVJFU1RcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYoZmlsdGVyVHlwZXMuaW5kZXhPZih2KSA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdnbC10ZXh0dXJlMmQ6IFVua25vd24gZmlsdGVyIG1vZGUgJyArIHYpXG4gICAgICB9XG4gICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgdilcbiAgICAgIHJldHVybiB0aGlzLl9tYWdGaWx0ZXIgPSB2XG4gICAgfVxuICB9LFxuICBtaXBTYW1wbGVzOiB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9hbmlzb1NhbXBsZXNcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24oaSkge1xuICAgICAgdmFyIHBzYW1wbGVzID0gdGhpcy5fYW5pc29TYW1wbGVzXG4gICAgICB0aGlzLl9hbmlzb1NhbXBsZXMgPSBNYXRoLm1heChpLCAxKXwwXG4gICAgICBpZihwc2FtcGxlcyAhPT0gdGhpcy5fYW5pc29TYW1wbGVzKSB7XG4gICAgICAgIHZhciBleHQgPSB3ZWJnbGV3KHRoaXMuZ2wpLkVYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpY1xuICAgICAgICBpZihleHQpIHtcbiAgICAgICAgICB0aGlzLmdsLnRleFBhcmFtZXRlcmYodGhpcy5nbC5URVhUVVJFXzJELCBleHQuVEVYVFVSRV9NQVhfQU5JU09UUk9QWV9FWFQsIHRoaXMuX2FuaXNvU2FtcGxlcylcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX2FuaXNvU2FtcGxlc1xuICAgIH1cbiAgfSxcbiAgd3JhcFM6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3dyYXBTXG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcbiAgICAgIHRoaXMuYmluZCgpXG4gICAgICBpZih3cmFwVHlwZXMuaW5kZXhPZih2KSA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdnbC10ZXh0dXJlMmQ6IFVua25vd24gd3JhcCBtb2RlICcgKyB2KVxuICAgICAgfVxuICAgICAgdGhpcy5nbC50ZXhQYXJhbWV0ZXJpKHRoaXMuZ2wuVEVYVFVSRV8yRCwgdGhpcy5nbC5URVhUVVJFX1dSQVBfUywgdilcbiAgICAgIHJldHVybiB0aGlzLl93cmFwUyA9IHZcbiAgICB9XG4gIH0sXG4gIHdyYXBUOiB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl93cmFwVFxuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbih2KSB7XG4gICAgICB0aGlzLmJpbmQoKVxuICAgICAgaWYod3JhcFR5cGVzLmluZGV4T2YodikgPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZ2wtdGV4dHVyZTJkOiBVbmtub3duIHdyYXAgbW9kZSAnICsgdilcbiAgICAgIH1cbiAgICAgIHRoaXMuZ2wudGV4UGFyYW1ldGVyaSh0aGlzLmdsLlRFWFRVUkVfMkQsIHRoaXMuZ2wuVEVYVFVSRV9XUkFQX1QsIHYpXG4gICAgICByZXR1cm4gdGhpcy5fd3JhcFQgPSB2XG4gICAgfVxuICB9LFxuICB3cmFwOiB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl93cmFwVmVjdG9yXG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcbiAgICAgIGlmKCFBcnJheS5pc0FycmF5KHYpKSB7XG4gICAgICAgIHYgPSBbdix2XVxuICAgICAgfVxuICAgICAgaWYodi5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdnbC10ZXh0dXJlMmQ6IE11c3Qgc3BlY2lmeSB3cmFwIG1vZGUgZm9yIHJvd3MgYW5kIGNvbHVtbnMnKVxuICAgICAgfVxuICAgICAgZm9yKHZhciBpPTA7IGk8MjsgKytpKSB7XG4gICAgICAgIGlmKHdyYXBUeXBlcy5pbmRleE9mKHZbaV0pIDwgMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZ2wtdGV4dHVyZTJkOiBVbmtub3duIHdyYXAgbW9kZSAnICsgdilcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5fd3JhcFMgPSB2WzBdXG4gICAgICB0aGlzLl93cmFwVCA9IHZbMV1cblxuICAgICAgdmFyIGdsID0gdGhpcy5nbFxuICAgICAgdGhpcy5iaW5kKClcbiAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIHRoaXMuX3dyYXBTKVxuICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgdGhpcy5fd3JhcFQpXG5cbiAgICAgIHJldHVybiB2XG4gICAgfVxuICB9LFxuICBzaGFwZToge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc2hhcGVWZWN0b3JcbiAgICB9LCBcbiAgICBzZXQ6IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmKCFBcnJheS5pc0FycmF5KHgpKSB7XG4gICAgICAgIHggPSBbeHwwLHh8MF1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmKHgubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdnbC10ZXh0dXJlMmQ6IEludmFsaWQgdGV4dHVyZSBzaGFwZScpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlc2hhcGVUZXh0dXJlKHRoaXMsIHhbMF18MCwgeFsxXXwwKVxuICAgICAgcmV0dXJuIFt4WzBdfDAsIHhbMV18MF1cbiAgICB9XG4gIH0sXG4gIHdpZHRoOiB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zaGFwZVswXVxuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbih3KSB7XG4gICAgICB3ID0gd3wwXG4gICAgICByZXNoYXBlVGV4dHVyZSh0aGlzLCB3LCB0aGlzLl9zaGFwZVsxXSlcbiAgICAgIHJldHVybiB3XG4gICAgfVxuICB9LFxuICBoZWlnaHQ6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3NoYXBlWzFdXG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKGgpIHtcbiAgICAgIGggPSBofDBcbiAgICAgIHJlc2hhcGVUZXh0dXJlKHRoaXMsIHRoaXMuX3NoYXBlWzBdLCBoKVxuICAgICAgcmV0dXJuIGhcbiAgICB9XG4gIH1cbn0pXG5cbnByb3RvLmJpbmQgPSBmdW5jdGlvbih1bml0KSB7XG4gIHZhciBnbCA9IHRoaXMuZ2xcbiAgaWYodW5pdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCArICh1bml0fDApKVxuICB9XG4gIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMuaGFuZGxlKVxuICBpZih1bml0ICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gKHVuaXR8MClcbiAgfVxuICByZXR1cm4gZ2wuZ2V0UGFyYW1ldGVyKGdsLkFDVElWRV9URVhUVVJFKSAtIGdsLlRFWFRVUkUwXG59XG5cbnByb3RvLmRpc3Bvc2UgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5nbC5kZWxldGVUZXh0dXJlKHRoaXMuaGFuZGxlKVxufVxuXG5wcm90by5nZW5lcmF0ZU1pcG1hcCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmJpbmQoKVxuICB0aGlzLmdsLmdlbmVyYXRlTWlwbWFwKHRoaXMuZ2wuVEVYVFVSRV8yRClcbiAgXG4gIC8vVXBkYXRlIG1pcCBsZXZlbHNcbiAgdmFyIGwgPSBNYXRoLm1pbih0aGlzLl9zaGFwZVswXSwgdGhpcy5fc2hhcGVbMV0pXG4gIGZvcih2YXIgaT0wOyBsPjA7ICsraSwgbD4+Pj0xKSB7XG4gICAgaWYodGhpcy5fbWlwTGV2ZWxzLmluZGV4T2YoaSkgPCAwKSB7XG4gICAgICB0aGlzLl9taXBMZXZlbHMucHVzaChpKVxuICAgIH1cbiAgfVxufVxuXG5wcm90by5zZXRQaXhlbHMgPSBmdW5jdGlvbihkYXRhLCB4X29mZiwgeV9vZmYsIG1pcF9sZXZlbCkge1xuICB2YXIgZ2wgPSB0aGlzLmdsXG4gIHRoaXMuYmluZCgpXG4gIGlmKEFycmF5LmlzQXJyYXkoeF9vZmYpKSB7XG4gICAgbWlwX2xldmVsID0geV9vZmZcbiAgICB5X29mZiA9IHhfb2ZmWzFdfDBcbiAgICB4X29mZiA9IHhfb2ZmWzBdfDBcbiAgfSBlbHNlIHtcbiAgICB4X29mZiA9IHhfb2ZmIHx8IDBcbiAgICB5X29mZiA9IHlfb2ZmIHx8IDBcbiAgfVxuICBtaXBfbGV2ZWwgPSBtaXBfbGV2ZWwgfHwgMFxuICBpZihkYXRhIGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnQgfHxcbiAgICAgZGF0YSBpbnN0YW5jZW9mIEltYWdlRGF0YSB8fFxuICAgICBkYXRhIGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudCB8fFxuICAgICBkYXRhIGluc3RhbmNlb2YgSFRNTFZpZGVvRWxlbWVudCkge1xuICAgIHZhciBuZWVkc01pcCA9IHRoaXMuX21pcExldmVscy5pbmRleE9mKG1pcF9sZXZlbCkgPCAwXG4gICAgaWYobmVlZHNNaXApIHtcbiAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgdGhpcy5mb3JtYXQsIHRoaXMuZm9ybWF0LCB0aGlzLnR5cGUsIGRhdGEpXG4gICAgICB0aGlzLl9taXBMZXZlbHMucHVzaChtaXBfbGV2ZWwpXG4gICAgfSBlbHNlIHtcbiAgICAgIGdsLnRleFN1YkltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgbWlwX2xldmVsLCB4X29mZiwgeV9vZmYsIHRoaXMuZm9ybWF0LCB0aGlzLnR5cGUsIGRhdGEpXG4gICAgfVxuICB9IGVsc2UgaWYoZGF0YS5zaGFwZSAmJiBkYXRhLnN0cmlkZSAmJiBkYXRhLmRhdGEpIHtcbiAgICBpZihkYXRhLnNoYXBlLmxlbmd0aCA8IDIgfHxcbiAgICAgICB4X29mZiArIGRhdGEuc2hhcGVbMV0gPiB0aGlzLl9zaGFwZVsxXT4+Pm1pcF9sZXZlbCB8fFxuICAgICAgIHlfb2ZmICsgZGF0YS5zaGFwZVswXSA+IHRoaXMuX3NoYXBlWzBdPj4+bWlwX2xldmVsIHx8XG4gICAgICAgeF9vZmYgPCAwIHx8XG4gICAgICAgeV9vZmYgPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dsLXRleHR1cmUyZDogVGV4dHVyZSBkaW1lbnNpb25zIGFyZSBvdXQgb2YgYm91bmRzJylcbiAgICB9XG4gICAgdGV4U3ViSW1hZ2VBcnJheShnbCwgeF9vZmYsIHlfb2ZmLCBtaXBfbGV2ZWwsIHRoaXMuZm9ybWF0LCB0aGlzLnR5cGUsIHRoaXMuX21pcExldmVscywgZGF0YSlcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2dsLXRleHR1cmUyZDogVW5zdXBwb3J0ZWQgZGF0YSB0eXBlJylcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIGlzUGFja2VkKHNoYXBlLCBzdHJpZGUpIHtcbiAgaWYoc2hhcGUubGVuZ3RoID09PSAzKSB7XG4gICAgcmV0dXJuICAoc3RyaWRlWzJdID09PSAxKSAmJiBcbiAgICAgICAgICAgIChzdHJpZGVbMV0gPT09IHNoYXBlWzBdKnNoYXBlWzJdKSAmJlxuICAgICAgICAgICAgKHN0cmlkZVswXSA9PT0gc2hhcGVbMl0pXG4gIH1cbiAgcmV0dXJuICAoc3RyaWRlWzBdID09PSAxKSAmJiBcbiAgICAgICAgICAoc3RyaWRlWzFdID09PSBzaGFwZVswXSlcbn1cblxuZnVuY3Rpb24gdGV4U3ViSW1hZ2VBcnJheShnbCwgeF9vZmYsIHlfb2ZmLCBtaXBfbGV2ZWwsIGNmb3JtYXQsIGN0eXBlLCBtaXBMZXZlbHMsIGFycmF5KSB7XG4gIHZhciBkdHlwZSA9IGFycmF5LmR0eXBlXG4gIHZhciBzaGFwZSA9IGFycmF5LnNoYXBlLnNsaWNlKClcbiAgaWYoc2hhcGUubGVuZ3RoIDwgMiB8fCBzaGFwZS5sZW5ndGggPiAzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdnbC10ZXh0dXJlMmQ6IEludmFsaWQgbmRhcnJheSwgbXVzdCBiZSAyZCBvciAzZCcpXG4gIH1cbiAgdmFyIHR5cGUgPSAwLCBmb3JtYXQgPSAwXG4gIHZhciBwYWNrZWQgPSBpc1BhY2tlZChzaGFwZSwgYXJyYXkuc3RyaWRlLnNsaWNlKCkpXG4gIGlmKGR0eXBlID09PSAnZmxvYXQzMicpIHtcbiAgICB0eXBlID0gZ2wuRkxPQVRcbiAgfSBlbHNlIGlmKGR0eXBlID09PSAnZmxvYXQ2NCcpIHtcbiAgICB0eXBlID0gZ2wuRkxPQVRcbiAgICBwYWNrZWQgPSBmYWxzZVxuICAgIGR0eXBlID0gJ2Zsb2F0MzInXG4gIH0gZWxzZSBpZihkdHlwZSA9PT0gJ3VpbnQ4Jykge1xuICAgIHR5cGUgPSBnbC5VTlNJR05FRF9CWVRFXG4gIH0gZWxzZSB7XG4gICAgdHlwZSA9IGdsLlVOU0lHTkVEX0JZVEVcbiAgICBwYWNrZWQgPSBmYWxzZVxuICAgIGR0eXBlID0gJ3VpbnQ4J1xuICB9XG4gIHZhciBjaGFubmVscyA9IDFcbiAgaWYoc2hhcGUubGVuZ3RoID09PSAyKSB7XG4gICAgZm9ybWF0ID0gZ2wuTFVNSU5BTkNFXG4gICAgc2hhcGUgPSBbc2hhcGVbMF0sIHNoYXBlWzFdLCAxXVxuICAgIGFycmF5ID0gbmRhcnJheShhcnJheS5kYXRhLCBzaGFwZSwgW2FycmF5LnN0cmlkZVswXSwgYXJyYXkuc3RyaWRlWzFdLCAxXSwgYXJyYXkub2Zmc2V0KVxuICB9IGVsc2UgaWYoc2hhcGUubGVuZ3RoID09PSAzKSB7XG4gICAgaWYoc2hhcGVbMl0gPT09IDEpIHtcbiAgICAgIGZvcm1hdCA9IGdsLkFMUEhBXG4gICAgfSBlbHNlIGlmKHNoYXBlWzJdID09PSAyKSB7XG4gICAgICBmb3JtYXQgPSBnbC5MVU1JTkFOQ0VfQUxQSEFcbiAgICB9IGVsc2UgaWYoc2hhcGVbMl0gPT09IDMpIHtcbiAgICAgIGZvcm1hdCA9IGdsLlJHQlxuICAgIH0gZWxzZSBpZihzaGFwZVsyXSA9PT0gNCkge1xuICAgICAgZm9ybWF0ID0gZ2wuUkdCQVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dsLXRleHR1cmUyZDogSW52YWxpZCBzaGFwZSBmb3IgcGl4ZWwgY29vcmRzJylcbiAgICB9XG4gICAgY2hhbm5lbHMgPSBzaGFwZVsyXVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignZ2wtdGV4dHVyZTJkOiBJbnZhbGlkIHNoYXBlIGZvciB0ZXh0dXJlJylcbiAgfVxuICAvL0ZvciAxLWNoYW5uZWwgdGV4dHVyZXMgYWxsb3cgY29udmVyc2lvbiBiZXR3ZWVuIGZvcm1hdHNcbiAgaWYoKGZvcm1hdCAgPT09IGdsLkxVTUlOQU5DRSB8fCBmb3JtYXQgID09PSBnbC5BTFBIQSkgJiZcbiAgICAgKGNmb3JtYXQgPT09IGdsLkxVTUlOQU5DRSB8fCBjZm9ybWF0ID09PSBnbC5BTFBIQSkpIHtcbiAgICBmb3JtYXQgPSBjZm9ybWF0XG4gIH1cbiAgaWYoZm9ybWF0ICE9PSBjZm9ybWF0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdnbC10ZXh0dXJlMmQ6IEluY29tcGF0aWJsZSB0ZXh0dXJlIGZvcm1hdCBmb3Igc2V0UGl4ZWxzJylcbiAgfVxuICB2YXIgc2l6ZSA9IGFycmF5LnNpemVcbiAgdmFyIG5lZWRzTWlwID0gbWlwTGV2ZWxzLmluZGV4T2YobWlwX2xldmVsKSA8IDBcbiAgaWYobmVlZHNNaXApIHtcbiAgICBtaXBMZXZlbHMucHVzaChtaXBfbGV2ZWwpXG4gIH1cbiAgaWYodHlwZSA9PT0gY3R5cGUgJiYgcGFja2VkKSB7XG4gICAgLy9BcnJheSBkYXRhIHR5cGVzIGFyZSBjb21wYXRpYmxlLCBjYW4gZGlyZWN0bHkgY29weSBpbnRvIHRleHR1cmVcbiAgICBpZihhcnJheS5vZmZzZXQgPT09IDAgJiYgYXJyYXkuZGF0YS5sZW5ndGggPT09IHNpemUpIHtcbiAgICAgIGlmKG5lZWRzTWlwKSB7XG4gICAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgbWlwX2xldmVsLCBjZm9ybWF0LCBzaGFwZVswXSwgc2hhcGVbMV0sIDAsIGNmb3JtYXQsIGN0eXBlLCBhcnJheS5kYXRhKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ2wudGV4U3ViSW1hZ2UyRChnbC5URVhUVVJFXzJELCBtaXBfbGV2ZWwsIHhfb2ZmLCB5X29mZiwgc2hhcGVbMF0sIHNoYXBlWzFdLCBjZm9ybWF0LCBjdHlwZSwgYXJyYXkuZGF0YSlcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYobmVlZHNNaXApIHtcbiAgICAgICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCBtaXBfbGV2ZWwsIGNmb3JtYXQsIHNoYXBlWzBdLCBzaGFwZVsxXSwgMCwgY2Zvcm1hdCwgY3R5cGUsIGFycmF5LmRhdGEuc3ViYXJyYXkoYXJyYXkub2Zmc2V0LCBhcnJheS5vZmZzZXQrc2l6ZSkpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBnbC50ZXhTdWJJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIG1pcF9sZXZlbCwgeF9vZmYsIHlfb2ZmLCBzaGFwZVswXSwgc2hhcGVbMV0sIGNmb3JtYXQsIGN0eXBlLCBhcnJheS5kYXRhLnN1YmFycmF5KGFycmF5Lm9mZnNldCwgYXJyYXkub2Zmc2V0K3NpemUpKVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvL05lZWQgdG8gZG8gdHlwZSBjb252ZXJzaW9uIHRvIHBhY2sgZGF0YSBpbnRvIGJ1ZmZlclxuICAgIHZhciBwYWNrX2J1ZmZlclxuICAgIGlmKGN0eXBlID09PSBnbC5GTE9BVCkge1xuICAgICAgcGFja19idWZmZXIgPSBwb29sLm1hbGxvY0Zsb2F0MzIoc2l6ZSlcbiAgICB9IGVsc2Uge1xuICAgICAgcGFja19idWZmZXIgPSBwb29sLm1hbGxvY1VpbnQ4KHNpemUpXG4gICAgfVxuICAgIHZhciBwYWNrX3ZpZXcgPSBuZGFycmF5KHBhY2tfYnVmZmVyLCBzaGFwZSwgW3NoYXBlWzJdLCBzaGFwZVsyXSpzaGFwZVswXSwgMV0pXG4gICAgaWYodHlwZSA9PT0gZ2wuRkxPQVQgJiYgY3R5cGUgPT09IGdsLlVOU0lHTkVEX0JZVEUpIHtcbiAgICAgIGNvbnZlcnRGbG9hdFRvVWludDgocGFja192aWV3LCBhcnJheSlcbiAgICB9IGVsc2Uge1xuICAgICAgb3BzLmFzc2lnbihwYWNrX3ZpZXcsIGFycmF5KVxuICAgIH1cbiAgICBpZihuZWVkc01pcCkge1xuICAgICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCBtaXBfbGV2ZWwsIGNmb3JtYXQsIHNoYXBlWzBdLCBzaGFwZVsxXSwgMCwgY2Zvcm1hdCwgY3R5cGUsIHBhY2tfYnVmZmVyLnN1YmFycmF5KDAsIHNpemUpKVxuICAgIH0gZWxzZSB7XG4gICAgICBnbC50ZXhTdWJJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIG1pcF9sZXZlbCwgeF9vZmYsIHlfb2ZmLCBzaGFwZVswXSwgc2hhcGVbMV0sIGNmb3JtYXQsIGN0eXBlLCBwYWNrX2J1ZmZlci5zdWJhcnJheSgwLCBzaXplKSlcbiAgICB9XG4gICAgaWYoY3R5cGUgPT09IGdsLkZMT0FUKSB7XG4gICAgICBwb29sLmZyZWVGbG9hdDMyKHBhY2tfYnVmZmVyKVxuICAgIH0gZWxzZSB7XG4gICAgICBwb29sLmZyZWVVaW50OChwYWNrX2J1ZmZlcilcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdFRleHR1cmUoZ2wpIHtcbiAgdmFyIHRleCA9IGdsLmNyZWF0ZVRleHR1cmUoKVxuICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXgpXG4gIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5ORUFSRVNUKVxuICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTkVBUkVTVClcbiAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSlcbiAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSlcbiAgcmV0dXJuIHRleFxufVxuXG5mdW5jdGlvbiBjcmVhdGVUZXh0dXJlU2hhcGUoZ2wsIHdpZHRoLCBoZWlnaHQsIGZvcm1hdCwgdHlwZSkge1xuICB2YXIgbWF4VGV4dHVyZVNpemUgPSBnbC5nZXRQYXJhbWV0ZXIoZ2wuTUFYX1RFWFRVUkVfU0laRSlcbiAgaWYod2lkdGggPCAwIHx8IHdpZHRoID4gbWF4VGV4dHVyZVNpemUgfHwgaGVpZ2h0IDwgMCB8fCBoZWlnaHQgID4gbWF4VGV4dHVyZVNpemUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2dsLXRleHR1cmUyZDogSW52YWxpZCB0ZXh0dXJlIHNoYXBlJylcbiAgfVxuICBpZih0eXBlID09PSBnbC5GTE9BVCAmJiAhd2ViZ2xldyhnbCkudGV4dHVyZV9mbG9hdCkge1xuICAgIHRocm93IG5ldyBFcnJvcignZ2wtdGV4dHVyZTJkOiBGbG9hdGluZyBwb2ludCB0ZXh0dXJlcyBub3Qgc3VwcG9ydGVkIG9uIHRoaXMgcGxhdGZvcm0nKVxuICB9XG4gIHZhciB0ZXggPSBpbml0VGV4dHVyZShnbClcbiAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBmb3JtYXQsIHdpZHRoLCBoZWlnaHQsIDAsIGZvcm1hdCwgdHlwZSwgbnVsbClcbiAgcmV0dXJuIG5ldyBUZXh0dXJlMkQoZ2wsIHRleCwgd2lkdGgsIGhlaWdodCwgZm9ybWF0LCB0eXBlKVxufVxuXG5mdW5jdGlvbiBjcmVhdGVUZXh0dXJlRE9NKGdsLCBlbGVtZW50LCBmb3JtYXQsIHR5cGUpIHtcbiAgdmFyIHRleCA9IGluaXRUZXh0dXJlKGdsKVxuICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGZvcm1hdCwgZm9ybWF0LCB0eXBlLCBlbGVtZW50KVxuICByZXR1cm4gbmV3IFRleHR1cmUyRChnbCwgdGV4LCBlbGVtZW50LndpZHRofDAsIGVsZW1lbnQuaGVpZ2h0fDAsIGZvcm1hdCwgdHlwZSlcbn1cblxuLy9DcmVhdGVzIGEgdGV4dHVyZSBmcm9tIGFuIG5kYXJyYXlcbmZ1bmN0aW9uIGNyZWF0ZVRleHR1cmVBcnJheShnbCwgYXJyYXkpIHtcbiAgdmFyIGR0eXBlID0gYXJyYXkuZHR5cGVcbiAgdmFyIHNoYXBlID0gYXJyYXkuc2hhcGUuc2xpY2UoKVxuICB2YXIgbWF4U2l6ZSA9IGdsLmdldFBhcmFtZXRlcihnbC5NQVhfVEVYVFVSRV9TSVpFKVxuICBpZihzaGFwZVswXSA8IDAgfHwgc2hhcGVbMF0gPiBtYXhTaXplIHx8IHNoYXBlWzFdIDwgMCB8fCBzaGFwZVsxXSA+IG1heFNpemUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2dsLXRleHR1cmUyZDogSW52YWxpZCB0ZXh0dXJlIHNpemUnKVxuICB9XG4gIHZhciBwYWNrZWQgPSBpc1BhY2tlZChzaGFwZSwgYXJyYXkuc3RyaWRlLnNsaWNlKCkpXG4gIHZhciB0eXBlID0gMFxuICBpZihkdHlwZSA9PT0gJ2Zsb2F0MzInKSB7XG4gICAgdHlwZSA9IGdsLkZMT0FUXG4gIH0gZWxzZSBpZihkdHlwZSA9PT0gJ2Zsb2F0NjQnKSB7XG4gICAgdHlwZSA9IGdsLkZMT0FUXG4gICAgcGFja2VkID0gZmFsc2VcbiAgICBkdHlwZSA9ICdmbG9hdDMyJ1xuICB9IGVsc2UgaWYoZHR5cGUgPT09ICd1aW50OCcpIHtcbiAgICB0eXBlID0gZ2wuVU5TSUdORURfQllURVxuICB9IGVsc2Uge1xuICAgIHR5cGUgPSBnbC5VTlNJR05FRF9CWVRFXG4gICAgcGFja2VkID0gZmFsc2VcbiAgICBkdHlwZSA9ICd1aW50OCdcbiAgfVxuICB2YXIgZm9ybWF0ID0gMFxuICBpZihzaGFwZS5sZW5ndGggPT09IDIpIHtcbiAgICBmb3JtYXQgPSBnbC5MVU1JTkFOQ0VcbiAgICBzaGFwZSA9IFtzaGFwZVswXSwgc2hhcGVbMV0sIDFdXG4gICAgYXJyYXkgPSBuZGFycmF5KGFycmF5LmRhdGEsIHNoYXBlLCBbYXJyYXkuc3RyaWRlWzBdLCBhcnJheS5zdHJpZGVbMV0sIDFdLCBhcnJheS5vZmZzZXQpXG4gIH0gZWxzZSBpZihzaGFwZS5sZW5ndGggPT09IDMpIHtcbiAgICBpZihzaGFwZVsyXSA9PT0gMSkge1xuICAgICAgZm9ybWF0ID0gZ2wuQUxQSEFcbiAgICB9IGVsc2UgaWYoc2hhcGVbMl0gPT09IDIpIHtcbiAgICAgIGZvcm1hdCA9IGdsLkxVTUlOQU5DRV9BTFBIQVxuICAgIH0gZWxzZSBpZihzaGFwZVsyXSA9PT0gMykge1xuICAgICAgZm9ybWF0ID0gZ2wuUkdCXG4gICAgfSBlbHNlIGlmKHNoYXBlWzJdID09PSA0KSB7XG4gICAgICBmb3JtYXQgPSBnbC5SR0JBXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZ2wtdGV4dHVyZTJkOiBJbnZhbGlkIHNoYXBlIGZvciBwaXhlbCBjb29yZHMnKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2dsLXRleHR1cmUyZDogSW52YWxpZCBzaGFwZSBmb3IgdGV4dHVyZScpXG4gIH1cbiAgaWYodHlwZSA9PT0gZ2wuRkxPQVQgJiYgIXdlYmdsZXcoZ2wpLnRleHR1cmVfZmxvYXQpIHtcbiAgICB0eXBlID0gZ2wuVU5TSUdORURfQllURVxuICAgIHBhY2tlZCA9IGZhbHNlXG4gIH1cbiAgdmFyIGJ1ZmZlciwgYnVmX3N0b3JlXG4gIHZhciBzaXplID0gYXJyYXkuc2l6ZVxuICBpZighcGFja2VkKSB7XG4gICAgdmFyIHN0cmlkZSA9IFtzaGFwZVsyXSwgc2hhcGVbMl0qc2hhcGVbMF0sIDFdXG4gICAgYnVmX3N0b3JlID0gcG9vbC5tYWxsb2Moc2l6ZSwgZHR5cGUpXG4gICAgdmFyIGJ1Zl9hcnJheSA9IG5kYXJyYXkoYnVmX3N0b3JlLCBzaGFwZSwgc3RyaWRlLCAwKVxuICAgIGlmKChkdHlwZSA9PT0gJ2Zsb2F0MzInIHx8IGR0eXBlID09PSAnZmxvYXQ2NCcpICYmIHR5cGUgPT09IGdsLlVOU0lHTkVEX0JZVEUpIHtcbiAgICAgIGNvbnZlcnRGbG9hdFRvVWludDgoYnVmX2FycmF5LCBhcnJheSlcbiAgICB9IGVsc2Uge1xuICAgICAgb3BzLmFzc2lnbihidWZfYXJyYXksIGFycmF5KVxuICAgIH1cbiAgICBidWZmZXIgPSBidWZfc3RvcmUuc3ViYXJyYXkoMCwgc2l6ZSlcbiAgfSBlbHNlIGlmIChhcnJheS5vZmZzZXQgPT09IDAgJiYgYXJyYXkuZGF0YS5sZW5ndGggPT09IHNpemUpIHtcbiAgICBidWZmZXIgPSBhcnJheS5kYXRhXG4gIH0gZWxzZSB7XG4gICAgYnVmZmVyID0gYXJyYXkuZGF0YS5zdWJhcnJheShhcnJheS5vZmZzZXQsIGFycmF5Lm9mZnNldCArIHNpemUpXG4gIH1cbiAgdmFyIHRleCA9IGluaXRUZXh0dXJlKGdsKVxuICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGZvcm1hdCwgc2hhcGVbMF0sIHNoYXBlWzFdLCAwLCBmb3JtYXQsIHR5cGUsIGJ1ZmZlcilcbiAgaWYoIXBhY2tlZCkge1xuICAgIHBvb2wuZnJlZShidWZfc3RvcmUpXG4gIH1cbiAgcmV0dXJuIG5ldyBUZXh0dXJlMkQoZ2wsIHRleCwgc2hhcGVbMF0sIHNoYXBlWzFdLCBmb3JtYXQsIHR5cGUpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVRleHR1cmUyRChnbCkge1xuICBpZihhcmd1bWVudHMubGVuZ3RoIDw9IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2dsLXRleHR1cmUyZDogTWlzc2luZyBhcmd1bWVudHMgZm9yIHRleHR1cmUyZCBjb25zdHJ1Y3RvcicpXG4gIH1cbiAgaWYoIWxpbmVhclR5cGVzKSB7XG4gICAgbGF6eUluaXRMaW5lYXJUeXBlcyhnbClcbiAgfVxuICBpZih0eXBlb2YgYXJndW1lbnRzWzFdID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiBjcmVhdGVUZXh0dXJlU2hhcGUoZ2wsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdLCBhcmd1bWVudHNbM118fGdsLlJHQkEsIGFyZ3VtZW50c1s0XXx8Z2wuVU5TSUdORURfQllURSlcbiAgfVxuICBpZihBcnJheS5pc0FycmF5KGFyZ3VtZW50c1sxXSkpIHtcbiAgICByZXR1cm4gY3JlYXRlVGV4dHVyZVNoYXBlKGdsLCBhcmd1bWVudHNbMV1bMF18MCwgYXJndW1lbnRzWzFdWzFdfDAsIGFyZ3VtZW50c1syXXx8Z2wuUkdCQSwgYXJndW1lbnRzWzNdfHxnbC5VTlNJR05FRF9CWVRFKVxuICB9XG4gIGlmKHR5cGVvZiBhcmd1bWVudHNbMV0gPT09ICdvYmplY3QnKSB7XG4gICAgdmFyIG9iaiA9IGFyZ3VtZW50c1sxXVxuICAgIGlmKG9iaiBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50IHx8XG4gICAgICAgb2JqIGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudCB8fFxuICAgICAgIG9iaiBpbnN0YW5jZW9mIEhUTUxWaWRlb0VsZW1lbnQgfHxcbiAgICAgICBvYmogaW5zdGFuY2VvZiBJbWFnZURhdGEpIHtcbiAgICAgIHJldHVybiBjcmVhdGVUZXh0dXJlRE9NKGdsLCBvYmosIGFyZ3VtZW50c1syXXx8Z2wuUkdCQSwgYXJndW1lbnRzWzNdfHxnbC5VTlNJR05FRF9CWVRFKVxuICAgIH0gZWxzZSBpZihvYmouc2hhcGUgJiYgb2JqLmRhdGEgJiYgb2JqLnN0cmlkZSkge1xuICAgICAgcmV0dXJuIGNyZWF0ZVRleHR1cmVBcnJheShnbCwgb2JqKVxuICAgIH1cbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoJ2dsLXRleHR1cmUyZDogSW52YWxpZCBhcmd1bWVudHMgZm9yIHRleHR1cmUyZCBjb25zdHJ1Y3RvcicpXG59XG4iLCIoZnVuY3Rpb24gKEJ1ZmZlcil7XG52YXIgaW90YSA9IHJlcXVpcmUoXCJpb3RhLWFycmF5XCIpXG5cbnZhciBhcnJheU1ldGhvZHMgPSBbXG4gIFwiY29uY2F0XCIsXG4gIFwiam9pblwiLFxuICBcInNsaWNlXCIsXG4gIFwidG9TdHJpbmdcIixcbiAgXCJpbmRleE9mXCIsXG4gIFwibGFzdEluZGV4T2ZcIixcbiAgXCJmb3JFYWNoXCIsXG4gIFwiZXZlcnlcIixcbiAgXCJzb21lXCIsXG4gIFwiZmlsdGVyXCIsXG4gIFwibWFwXCIsXG4gIFwicmVkdWNlXCIsXG4gIFwicmVkdWNlUmlnaHRcIlxuXVxuXG52YXIgaGFzVHlwZWRBcnJheXMgID0gKCh0eXBlb2YgRmxvYXQ2NEFycmF5KSAhPT0gXCJ1bmRlZmluZWRcIilcbnZhciBoYXNCdWZmZXIgICAgICAgPSAoKHR5cGVvZiBCdWZmZXIpICE9PSBcInVuZGVmaW5lZFwiKVxuXG5mdW5jdGlvbiBjb21wYXJlMXN0KGEsIGIpIHtcbiAgcmV0dXJuIGFbMF0gLSBiWzBdXG59XG5cbmZ1bmN0aW9uIG9yZGVyKCkge1xuICB2YXIgc3RyaWRlID0gdGhpcy5zdHJpZGVcbiAgdmFyIHRlcm1zID0gbmV3IEFycmF5KHN0cmlkZS5sZW5ndGgpXG4gIHZhciBpXG4gIGZvcihpPTA7IGk8dGVybXMubGVuZ3RoOyArK2kpIHtcbiAgICB0ZXJtc1tpXSA9IFtNYXRoLmFicyhzdHJpZGVbaV0pLCBpXVxuICB9XG4gIHRlcm1zLnNvcnQoY29tcGFyZTFzdClcbiAgdmFyIHJlc3VsdCA9IG5ldyBBcnJheSh0ZXJtcy5sZW5ndGgpXG4gIGZvcihpPTA7IGk8cmVzdWx0Lmxlbmd0aDsgKytpKSB7XG4gICAgcmVzdWx0W2ldID0gdGVybXNbaV1bMV1cbiAgfVxuICByZXR1cm4gcmVzdWx0XG59XG5cbmZ1bmN0aW9uIGNvbXBpbGVDb25zdHJ1Y3RvcihkdHlwZSwgZGltZW5zaW9uKSB7XG4gIHZhciBjbGFzc05hbWUgPSBbXCJWaWV3XCIsIGRpbWVuc2lvbiwgXCJkXCIsIGR0eXBlXS5qb2luKFwiXCIpXG4gIGlmKGRpbWVuc2lvbiA8IDApIHtcbiAgICBjbGFzc05hbWUgPSBcIlZpZXdfTmlsXCIgKyBkdHlwZVxuICB9XG4gIHZhciB1c2VHZXR0ZXJzID0gKGR0eXBlID09PSBcImdlbmVyaWNcIilcbiAgXG4gIGlmKGRpbWVuc2lvbiA9PT0gLTEpIHtcbiAgICAvL1NwZWNpYWwgY2FzZSBmb3IgdHJpdmlhbCBhcnJheXNcbiAgICB2YXIgY29kZSA9IFxuICAgICAgXCJmdW5jdGlvbiBcIitjbGFzc05hbWUrXCIoYSl7dGhpcy5kYXRhPWE7fTtcXFxudmFyIHByb3RvPVwiK2NsYXNzTmFtZStcIi5wcm90b3R5cGU7XFxcbnByb3RvLmR0eXBlPSdcIitkdHlwZStcIic7XFxcbnByb3RvLmluZGV4PWZ1bmN0aW9uKCl7cmV0dXJuIC0xfTtcXFxucHJvdG8uc2l6ZT0wO1xcXG5wcm90by5kaW1lbnNpb249LTE7XFxcbnByb3RvLnNoYXBlPXByb3RvLnN0cmlkZT1wcm90by5vcmRlcj1bXTtcXFxucHJvdG8ubG89cHJvdG8uaGk9cHJvdG8udHJhbnNwb3NlPXByb3RvLnN0ZXA9XFxcbmZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBcIitjbGFzc05hbWUrXCIodGhpcy5kYXRhKTt9O1xcXG5wcm90by5nZXQ9cHJvdG8uc2V0PWZ1bmN0aW9uKCl7fTtcXFxucHJvdG8ucGljaz1mdW5jdGlvbigpe3JldHVybiBudWxsfTtcXFxucmV0dXJuIGZ1bmN0aW9uIGNvbnN0cnVjdF9cIitjbGFzc05hbWUrXCIoYSl7cmV0dXJuIG5ldyBcIitjbGFzc05hbWUrXCIoYSk7fVwiXG4gICAgdmFyIHByb2NlZHVyZSA9IG5ldyBGdW5jdGlvbihjb2RlKVxuICAgIHJldHVybiBwcm9jZWR1cmUoKVxuICB9IGVsc2UgaWYoZGltZW5zaW9uID09PSAwKSB7XG4gICAgLy9TcGVjaWFsIGNhc2UgZm9yIDBkIGFycmF5c1xuICAgIHZhciBjb2RlID1cbiAgICAgIFwiZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiKGEsZCkge1xcXG50aGlzLmRhdGEgPSBhO1xcXG50aGlzLm9mZnNldCA9IGRcXFxufTtcXFxudmFyIHByb3RvPVwiK2NsYXNzTmFtZStcIi5wcm90b3R5cGU7XFxcbnByb3RvLmR0eXBlPSdcIitkdHlwZStcIic7XFxcbnByb3RvLmluZGV4PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMub2Zmc2V0fTtcXFxucHJvdG8uZGltZW5zaW9uPTA7XFxcbnByb3RvLnNpemU9MTtcXFxucHJvdG8uc2hhcGU9XFxcbnByb3RvLnN0cmlkZT1cXFxucHJvdG8ub3JkZXI9W107XFxcbnByb3RvLmxvPVxcXG5wcm90by5oaT1cXFxucHJvdG8udHJhbnNwb3NlPVxcXG5wcm90by5zdGVwPWZ1bmN0aW9uIFwiK2NsYXNzTmFtZStcIl9jb3B5KCkge1xcXG5yZXR1cm4gbmV3IFwiK2NsYXNzTmFtZStcIih0aGlzLmRhdGEsdGhpcy5vZmZzZXQpXFxcbn07XFxcbnByb3RvLnBpY2s9ZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiX3BpY2soKXtcXFxucmV0dXJuIFRyaXZpYWxBcnJheSh0aGlzLmRhdGEpO1xcXG59O1xcXG5wcm90by52YWx1ZU9mPXByb3RvLmdldD1mdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfZ2V0KCl7XFxcbnJldHVybiBcIisodXNlR2V0dGVycyA/IFwidGhpcy5kYXRhLmdldCh0aGlzLm9mZnNldClcIiA6IFwidGhpcy5kYXRhW3RoaXMub2Zmc2V0XVwiKStcblwifTtcXFxucHJvdG8uc2V0PWZ1bmN0aW9uIFwiK2NsYXNzTmFtZStcIl9zZXQodil7XFxcbnJldHVybiBcIisodXNlR2V0dGVycyA/IFwidGhpcy5kYXRhLnNldCh0aGlzLm9mZnNldCx2KVwiIDogXCJ0aGlzLmRhdGFbdGhpcy5vZmZzZXRdPXZcIikrXCJcXFxufTtcXFxucmV0dXJuIGZ1bmN0aW9uIGNvbnN0cnVjdF9cIitjbGFzc05hbWUrXCIoYSxiLGMsZCl7cmV0dXJuIG5ldyBcIitjbGFzc05hbWUrXCIoYSxkKX1cIlxuICAgIHZhciBwcm9jZWR1cmUgPSBuZXcgRnVuY3Rpb24oXCJUcml2aWFsQXJyYXlcIiwgY29kZSlcbiAgICByZXR1cm4gcHJvY2VkdXJlKENBQ0hFRF9DT05TVFJVQ1RPUlNbZHR5cGVdWzBdKVxuICB9XG5cbiAgdmFyIGNvZGUgPSBbXCIndXNlIHN0cmljdCdcIl1cbiAgICBcbiAgLy9DcmVhdGUgY29uc3RydWN0b3IgZm9yIHZpZXdcbiAgdmFyIGluZGljZXMgPSBpb3RhKGRpbWVuc2lvbilcbiAgdmFyIGFyZ3MgPSBpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7IHJldHVybiBcImlcIitpIH0pXG4gIHZhciBpbmRleF9zdHIgPSBcInRoaXMub2Zmc2V0K1wiICsgaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkge1xuICAgICAgICByZXR1cm4gXCJ0aGlzLl9zdHJpZGVcIiArIGkgKyBcIippXCIgKyBpXG4gICAgICB9KS5qb2luKFwiK1wiKVxuICBjb2RlLnB1c2goXCJmdW5jdGlvbiBcIitjbGFzc05hbWUrXCIoYSxcIitcbiAgICBpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gXCJiXCIraVxuICAgIH0pLmpvaW4oXCIsXCIpICsgXCIsXCIgK1xuICAgIGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBcImNcIitpXG4gICAgfSkuam9pbihcIixcIikgKyBcIixkKXt0aGlzLmRhdGE9YVwiKVxuICBmb3IodmFyIGk9MDsgaTxkaW1lbnNpb247ICsraSkge1xuICAgIGNvZGUucHVzaChcInRoaXMuX3NoYXBlXCIraStcIj1iXCIraStcInwwXCIpXG4gIH1cbiAgZm9yKHZhciBpPTA7IGk8ZGltZW5zaW9uOyArK2kpIHtcbiAgICBjb2RlLnB1c2goXCJ0aGlzLl9zdHJpZGVcIitpK1wiPWNcIitpK1wifDBcIilcbiAgfVxuICBjb2RlLnB1c2goXCJ0aGlzLm9mZnNldD1kfDB9XCIsXG4gICAgXCJ2YXIgcHJvdG89XCIrY2xhc3NOYW1lK1wiLnByb3RvdHlwZVwiLFxuICAgIFwicHJvdG8uZHR5cGU9J1wiK2R0eXBlK1wiJ1wiLFxuICAgIFwicHJvdG8uZGltZW5zaW9uPVwiK2RpbWVuc2lvbilcbiAgXG4gIC8vdmlldy5zdHJpZGUgYW5kIHZpZXcuc2hhcGVcbiAgdmFyIHN0cmlkZUNsYXNzTmFtZSA9IFwiVlN0cmlkZVwiICsgZGltZW5zaW9uICsgXCJkXCIgKyBkdHlwZVxuICB2YXIgc2hhcGVDbGFzc05hbWUgPSBcIlZTaGFwZVwiICsgZGltZW5zaW9uICsgXCJkXCIgKyBkdHlwZVxuICB2YXIgcHJvcHMgPSB7XCJzdHJpZGVcIjpzdHJpZGVDbGFzc05hbWUsIFwic2hhcGVcIjpzaGFwZUNsYXNzTmFtZX1cbiAgZm9yKHZhciBwcm9wIGluIHByb3BzKSB7XG4gICAgdmFyIGFycmF5TmFtZSA9IHByb3BzW3Byb3BdXG4gICAgY29kZS5wdXNoKFxuICAgICAgXCJmdW5jdGlvbiBcIiArIGFycmF5TmFtZSArIFwiKHYpIHt0aGlzLl92PXZ9IHZhciBhcHJvdG89XCIgKyBhcnJheU5hbWUgKyBcIi5wcm90b3R5cGVcIixcbiAgICAgIFwiYXByb3RvLmxlbmd0aD1cIitkaW1lbnNpb24pXG4gICAgXG4gICAgdmFyIGFycmF5X2VsZW1lbnRzID0gW11cbiAgICBmb3IodmFyIGk9MDsgaTxkaW1lbnNpb247ICsraSkge1xuICAgICAgYXJyYXlfZWxlbWVudHMucHVzaChbXCJ0aGlzLl92Ll9cIiwgcHJvcCwgaV0uam9pbihcIlwiKSlcbiAgICB9XG4gICAgY29kZS5wdXNoKFxuICAgICAgXCJhcHJvdG8udG9KU09OPWZ1bmN0aW9uIFwiICsgYXJyYXlOYW1lICsgXCJfdG9KU09OKCl7cmV0dXJuIFtcIiArIGFycmF5X2VsZW1lbnRzLmpvaW4oXCIsXCIpICsgXCJdfVwiLFxuICAgICAgXCJhcHJvdG8udmFsdWVPZj1hcHJvdG8udG9TdHJpbmc9ZnVuY3Rpb24gXCIgKyBhcnJheU5hbWUgKyBcIl90b1N0cmluZygpe3JldHVybiBbXCIgKyBhcnJheV9lbGVtZW50cy5qb2luKFwiLFwiKSArIFwiXS5qb2luKCl9XCIpXG4gICAgXG4gICAgZm9yKHZhciBpPTA7IGk8ZGltZW5zaW9uOyArK2kpIHtcbiAgICAgIGNvZGUucHVzaChcIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShhcHJvdG8sXCIraStcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3YuX1wiK3Byb3AraStcIn0sc2V0OmZ1bmN0aW9uKHYpe3JldHVybiB0aGlzLl92Ll9cIitwcm9wK2krXCI9dnwwfSxlbnVtZXJhYmxlOnRydWV9KVwiKVxuICAgIH1cbiAgICBmb3IodmFyIGk9MDsgaTxhcnJheU1ldGhvZHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGlmKGFycmF5TWV0aG9kc1tpXSBpbiBBcnJheS5wcm90b3R5cGUpIHtcbiAgICAgICAgY29kZS5wdXNoKFwiYXByb3RvLlwiK2FycmF5TWV0aG9kc1tpXStcIj1BcnJheS5wcm90b3R5cGUuXCIrYXJyYXlNZXRob2RzW2ldKVxuICAgICAgfVxuICAgIH1cbiAgICBjb2RlLnB1c2goW1wiT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvLCdcIixwcm9wLFwiJyx7Z2V0OmZ1bmN0aW9uIFwiLCBhcnJheU5hbWUsIFwiX2dldCgpe3JldHVybiBuZXcgXCIsIGFycmF5TmFtZSwgXCIodGhpcyl9LHNldDogZnVuY3Rpb24gXCIsIGFycmF5TmFtZSwgXCJfc2V0KHYpe1wiXS5qb2luKFwiXCIpKVxuICAgIGZvcih2YXIgaT0wOyBpPGRpbWVuc2lvbjsgKytpKSB7XG4gICAgICBjb2RlLnB1c2goXCJ0aGlzLl9cIitwcm9wK2krXCI9dltcIitpK1wiXXwwXCIpXG4gICAgfVxuICAgIGNvZGUucHVzaChcInJldHVybiB2fX0pXCIpXG4gIH1cbiAgXG4gIC8vdmlldy5zaXplOlxuICBjb2RlLnB1c2goXCJPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG8sJ3NpemUnLHtnZXQ6ZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiX3NpemUoKXtcXFxucmV0dXJuIFwiK2luZGljZXMubWFwKGZ1bmN0aW9uKGkpIHsgcmV0dXJuIFwidGhpcy5fc2hhcGVcIitpIH0pLmpvaW4oXCIqXCIpLFxuXCJ9fSlcIilcblxuICAvL3ZpZXcub3JkZXI6XG4gIGlmKGRpbWVuc2lvbiA9PT0gMSkge1xuICAgIGNvZGUucHVzaChcInByb3RvLm9yZGVyPVswXVwiKVxuICB9IGVsc2Uge1xuICAgIGNvZGUucHVzaChcIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90bywnb3JkZXInLHtnZXQ6XCIpXG4gICAgaWYoZGltZW5zaW9uIDwgNCkge1xuICAgICAgY29kZS5wdXNoKFwiZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiX29yZGVyKCl7XCIpXG4gICAgICBpZihkaW1lbnNpb24gPT09IDIpIHtcbiAgICAgICAgY29kZS5wdXNoKFwicmV0dXJuIChNYXRoLmFicyh0aGlzLl9zdHJpZGUwKT5NYXRoLmFicyh0aGlzLl9zdHJpZGUxKSk/WzEsMF06WzAsMV19fSlcIilcbiAgICAgIH0gZWxzZSBpZihkaW1lbnNpb24gPT09IDMpIHtcbiAgICAgICAgY29kZS5wdXNoKFxuXCJ2YXIgczA9TWF0aC5hYnModGhpcy5fc3RyaWRlMCksczE9TWF0aC5hYnModGhpcy5fc3RyaWRlMSksczI9TWF0aC5hYnModGhpcy5fc3RyaWRlMik7XFxcbmlmKHMwPnMxKXtcXFxuaWYoczE+czIpe1xcXG5yZXR1cm4gWzIsMSwwXTtcXFxufWVsc2UgaWYoczA+czIpe1xcXG5yZXR1cm4gWzEsMiwwXTtcXFxufWVsc2V7XFxcbnJldHVybiBbMSwwLDJdO1xcXG59XFxcbn1lbHNlIGlmKHMwPnMyKXtcXFxucmV0dXJuIFsyLDAsMV07XFxcbn1lbHNlIGlmKHMyPnMxKXtcXFxucmV0dXJuIFswLDEsMl07XFxcbn1lbHNle1xcXG5yZXR1cm4gWzAsMiwxXTtcXFxufX19KVwiKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb2RlLnB1c2goXCJPUkRFUn0pXCIpXG4gICAgfVxuICB9XG4gIFxuICAvL3ZpZXcuc2V0KGkwLCAuLi4sIHYpOlxuICBjb2RlLnB1c2goXG5cInByb3RvLnNldD1mdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfc2V0KFwiK2FyZ3Muam9pbihcIixcIikrXCIsdil7XCIpXG4gIGlmKHVzZUdldHRlcnMpIHtcbiAgICBjb2RlLnB1c2goXCJyZXR1cm4gdGhpcy5kYXRhLnNldChcIitpbmRleF9zdHIrXCIsdil9XCIpXG4gIH0gZWxzZSB7XG4gICAgY29kZS5wdXNoKFwicmV0dXJuIHRoaXMuZGF0YVtcIitpbmRleF9zdHIrXCJdPXZ9XCIpXG4gIH1cbiAgXG4gIC8vdmlldy5nZXQoaTAsIC4uLik6XG4gIGNvZGUucHVzaChcInByb3RvLmdldD1mdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfZ2V0KFwiK2FyZ3Muam9pbihcIixcIikrXCIpe1wiKVxuICBpZih1c2VHZXR0ZXJzKSB7XG4gICAgY29kZS5wdXNoKFwicmV0dXJuIHRoaXMuZGF0YS5nZXQoXCIraW5kZXhfc3RyK1wiKX1cIilcbiAgfSBlbHNlIHtcbiAgICBjb2RlLnB1c2goXCJyZXR1cm4gdGhpcy5kYXRhW1wiK2luZGV4X3N0citcIl19XCIpXG4gIH1cbiAgXG4gIC8vdmlldy5pbmRleDpcbiAgY29kZS5wdXNoKFxuICAgIFwicHJvdG8uaW5kZXg9ZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiX2luZGV4KFwiLCBhcmdzLmpvaW4oKSwgXCIpe3JldHVybiBcIitpbmRleF9zdHIrXCJ9XCIpXG5cbiAgLy92aWV3LmhpKCk6XG4gIGNvZGUucHVzaChcInByb3RvLmhpPWZ1bmN0aW9uIFwiK2NsYXNzTmFtZStcIl9oaShcIithcmdzLmpvaW4oXCIsXCIpK1wiKXtyZXR1cm4gbmV3IFwiK2NsYXNzTmFtZStcIih0aGlzLmRhdGEsXCIrXG4gICAgaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIFtcIih0eXBlb2YgaVwiLGksXCIhPT0nbnVtYmVyJ3x8aVwiLGksXCI8MCk/dGhpcy5fc2hhcGVcIiwgaSwgXCI6aVwiLCBpLFwifDBcIl0uam9pbihcIlwiKVxuICAgIH0pLmpvaW4oXCIsXCIpK1wiLFwiK1xuICAgIGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBcInRoaXMuX3N0cmlkZVwiK2lcbiAgICB9KS5qb2luKFwiLFwiKStcIix0aGlzLm9mZnNldCl9XCIpXG4gIFxuICAvL3ZpZXcubG8oKTpcbiAgdmFyIGFfdmFycyA9IGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHsgcmV0dXJuIFwiYVwiK2krXCI9dGhpcy5fc2hhcGVcIitpIH0pXG4gIHZhciBjX3ZhcnMgPSBpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7IHJldHVybiBcImNcIitpK1wiPXRoaXMuX3N0cmlkZVwiK2kgfSlcbiAgY29kZS5wdXNoKFwicHJvdG8ubG89ZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiX2xvKFwiK2FyZ3Muam9pbihcIixcIikrXCIpe3ZhciBiPXRoaXMub2Zmc2V0LGQ9MCxcIithX3ZhcnMuam9pbihcIixcIikrXCIsXCIrY192YXJzLmpvaW4oXCIsXCIpKVxuICBmb3IodmFyIGk9MDsgaTxkaW1lbnNpb247ICsraSkge1xuICAgIGNvZGUucHVzaChcblwiaWYodHlwZW9mIGlcIitpK1wiPT09J251bWJlcicmJmlcIitpK1wiPj0wKXtcXFxuZD1pXCIraStcInwwO1xcXG5iKz1jXCIraStcIipkO1xcXG5hXCIraStcIi09ZH1cIilcbiAgfVxuICBjb2RlLnB1c2goXCJyZXR1cm4gbmV3IFwiK2NsYXNzTmFtZStcIih0aGlzLmRhdGEsXCIrXG4gICAgaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIFwiYVwiK2lcbiAgICB9KS5qb2luKFwiLFwiKStcIixcIitcbiAgICBpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gXCJjXCIraVxuICAgIH0pLmpvaW4oXCIsXCIpK1wiLGIpfVwiKVxuICBcbiAgLy92aWV3LnN0ZXAoKTpcbiAgY29kZS5wdXNoKFwicHJvdG8uc3RlcD1mdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfc3RlcChcIithcmdzLmpvaW4oXCIsXCIpK1wiKXt2YXIgXCIrXG4gICAgaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIFwiYVwiK2krXCI9dGhpcy5fc2hhcGVcIitpXG4gICAgfSkuam9pbihcIixcIikrXCIsXCIrXG4gICAgaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIFwiYlwiK2krXCI9dGhpcy5fc3RyaWRlXCIraVxuICAgIH0pLmpvaW4oXCIsXCIpK1wiLGM9dGhpcy5vZmZzZXQsZD0wLGNlaWw9TWF0aC5jZWlsXCIpXG4gIGZvcih2YXIgaT0wOyBpPGRpbWVuc2lvbjsgKytpKSB7XG4gICAgY29kZS5wdXNoKFxuXCJpZih0eXBlb2YgaVwiK2krXCI9PT0nbnVtYmVyJyl7XFxcbmQ9aVwiK2krXCJ8MDtcXFxuaWYoZDwwKXtcXFxuYys9YlwiK2krXCIqKGFcIitpK1wiLTEpO1xcXG5hXCIraStcIj1jZWlsKC1hXCIraStcIi9kKVxcXG59ZWxzZXtcXFxuYVwiK2krXCI9Y2VpbChhXCIraStcIi9kKVxcXG59XFxcbmJcIitpK1wiKj1kXFxcbn1cIilcbiAgfVxuICBjb2RlLnB1c2goXCJyZXR1cm4gbmV3IFwiK2NsYXNzTmFtZStcIih0aGlzLmRhdGEsXCIrXG4gICAgaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIFwiYVwiICsgaVxuICAgIH0pLmpvaW4oXCIsXCIpK1wiLFwiK1xuICAgIGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBcImJcIiArIGlcbiAgICB9KS5qb2luKFwiLFwiKStcIixjKX1cIilcbiAgXG4gIC8vdmlldy50cmFuc3Bvc2UoKTpcbiAgdmFyIHRTaGFwZSA9IG5ldyBBcnJheShkaW1lbnNpb24pXG4gIHZhciB0U3RyaWRlID0gbmV3IEFycmF5KGRpbWVuc2lvbilcbiAgZm9yKHZhciBpPTA7IGk8ZGltZW5zaW9uOyArK2kpIHtcbiAgICB0U2hhcGVbaV0gPSBcImFbaVwiK2krXCJdXCJcbiAgICB0U3RyaWRlW2ldID0gXCJiW2lcIitpK1wiXVwiXG4gIH1cbiAgY29kZS5wdXNoKFwicHJvdG8udHJhbnNwb3NlPWZ1bmN0aW9uIFwiK2NsYXNzTmFtZStcIl90cmFuc3Bvc2UoXCIrYXJncytcIil7XCIrXG4gICAgYXJncy5tYXAoZnVuY3Rpb24obixpZHgpIHsgcmV0dXJuIG4gKyBcIj0oXCIgKyBuICsgXCI9PT11bmRlZmluZWQ/XCIgKyBpZHggKyBcIjpcIiArIG4gKyBcInwwKVwifSkuam9pbihcIjtcIiksXG4gICAgXCJ2YXIgYT10aGlzLnNoYXBlLGI9dGhpcy5zdHJpZGU7cmV0dXJuIG5ldyBcIitjbGFzc05hbWUrXCIodGhpcy5kYXRhLFwiK3RTaGFwZS5qb2luKFwiLFwiKStcIixcIit0U3RyaWRlLmpvaW4oXCIsXCIpK1wiLHRoaXMub2Zmc2V0KX1cIilcbiAgXG4gIC8vdmlldy5waWNrKCk6XG4gIGNvZGUucHVzaChcInByb3RvLnBpY2s9ZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiX3BpY2soXCIrYXJncytcIil7dmFyIGE9W10sYj1bXSxjPXRoaXMub2Zmc2V0XCIpXG4gIGZvcih2YXIgaT0wOyBpPGRpbWVuc2lvbjsgKytpKSB7XG4gICAgY29kZS5wdXNoKFwiaWYodHlwZW9mIGlcIitpK1wiPT09J251bWJlcicmJmlcIitpK1wiPj0wKXtjPShjK3RoaXMuX3N0cmlkZVwiK2krXCIqaVwiK2krXCIpfDB9ZWxzZXthLnB1c2godGhpcy5fc2hhcGVcIitpK1wiKTtiLnB1c2godGhpcy5fc3RyaWRlXCIraStcIil9XCIpXG4gIH1cbiAgY29kZS5wdXNoKFwidmFyIGN0b3I9Q1RPUl9MSVNUW2EubGVuZ3RoKzFdO3JldHVybiBjdG9yKHRoaXMuZGF0YSxhLGIsYyl9XCIpXG4gICAgXG4gIC8vQWRkIHJldHVybiBzdGF0ZW1lbnRcbiAgY29kZS5wdXNoKFwicmV0dXJuIGZ1bmN0aW9uIGNvbnN0cnVjdF9cIitjbGFzc05hbWUrXCIoZGF0YSxzaGFwZSxzdHJpZGUsb2Zmc2V0KXtyZXR1cm4gbmV3IFwiK2NsYXNzTmFtZStcIihkYXRhLFwiK1xuICAgIGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBcInNoYXBlW1wiK2krXCJdXCJcbiAgICB9KS5qb2luKFwiLFwiKStcIixcIitcbiAgICBpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gXCJzdHJpZGVbXCIraStcIl1cIlxuICAgIH0pLmpvaW4oXCIsXCIpK1wiLG9mZnNldCl9XCIpXG5cbiAgLy9Db21waWxlIHByb2NlZHVyZVxuICB2YXIgcHJvY2VkdXJlID0gbmV3IEZ1bmN0aW9uKFwiQ1RPUl9MSVNUXCIsIFwiT1JERVJcIiwgY29kZS5qb2luKFwiXFxuXCIpKVxuICByZXR1cm4gcHJvY2VkdXJlKENBQ0hFRF9DT05TVFJVQ1RPUlNbZHR5cGVdLCBvcmRlcilcbn1cblxuZnVuY3Rpb24gYXJyYXlEVHlwZShkYXRhKSB7XG4gIGlmKGhhc0J1ZmZlcikge1xuICAgIGlmKEJ1ZmZlci5pc0J1ZmZlcihkYXRhKSkge1xuICAgICAgcmV0dXJuIFwiYnVmZmVyXCJcbiAgICB9XG4gIH1cbiAgaWYoaGFzVHlwZWRBcnJheXMpIHtcbiAgICBzd2l0Y2goT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGRhdGEpKSB7XG4gICAgICBjYXNlIFwiW29iamVjdCBGbG9hdDY0QXJyYXldXCI6XG4gICAgICAgIHJldHVybiBcImZsb2F0NjRcIlxuICAgICAgY2FzZSBcIltvYmplY3QgRmxvYXQzMkFycmF5XVwiOlxuICAgICAgICByZXR1cm4gXCJmbG9hdDMyXCJcbiAgICAgIGNhc2UgXCJbb2JqZWN0IEludDhBcnJheV1cIjpcbiAgICAgICAgcmV0dXJuIFwiaW50OFwiXG4gICAgICBjYXNlIFwiW29iamVjdCBJbnQxNkFycmF5XVwiOlxuICAgICAgICByZXR1cm4gXCJpbnQxNlwiXG4gICAgICBjYXNlIFwiW29iamVjdCBJbnQzMkFycmF5XVwiOlxuICAgICAgICByZXR1cm4gXCJpbnQzMlwiXG4gICAgICBjYXNlIFwiW29iamVjdCBVaW50OEFycmF5XVwiOlxuICAgICAgICByZXR1cm4gXCJ1aW50OFwiXG4gICAgICBjYXNlIFwiW29iamVjdCBVaW50MTZBcnJheV1cIjpcbiAgICAgICAgcmV0dXJuIFwidWludDE2XCJcbiAgICAgIGNhc2UgXCJbb2JqZWN0IFVpbnQzMkFycmF5XVwiOlxuICAgICAgICByZXR1cm4gXCJ1aW50MzJcIlxuICAgICAgY2FzZSBcIltvYmplY3QgVWludDhDbGFtcGVkQXJyYXldXCI6XG4gICAgICAgIHJldHVybiBcInVpbnQ4X2NsYW1wZWRcIlxuICAgIH1cbiAgfVxuICBpZihBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgcmV0dXJuIFwiYXJyYXlcIlxuICB9XG4gIHJldHVybiBcImdlbmVyaWNcIlxufVxuXG52YXIgQ0FDSEVEX0NPTlNUUlVDVE9SUyA9IHtcbiAgXCJmbG9hdDMyXCI6W10sXG4gIFwiZmxvYXQ2NFwiOltdLFxuICBcImludDhcIjpbXSxcbiAgXCJpbnQxNlwiOltdLFxuICBcImludDMyXCI6W10sXG4gIFwidWludDhcIjpbXSxcbiAgXCJ1aW50MTZcIjpbXSxcbiAgXCJ1aW50MzJcIjpbXSxcbiAgXCJhcnJheVwiOltdLFxuICBcInVpbnQ4X2NsYW1wZWRcIjpbXSxcbiAgXCJidWZmZXJcIjpbXSxcbiAgXCJnZW5lcmljXCI6W11cbn1cblxuOyhmdW5jdGlvbigpIHtcbiAgZm9yKHZhciBpZCBpbiBDQUNIRURfQ09OU1RSVUNUT1JTKSB7XG4gICAgQ0FDSEVEX0NPTlNUUlVDVE9SU1tpZF0ucHVzaChjb21waWxlQ29uc3RydWN0b3IoaWQsIC0xKSlcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIHdyYXBwZWROREFycmF5Q3RvcihkYXRhLCBzaGFwZSwgc3RyaWRlLCBvZmZzZXQpIHtcbiAgaWYoZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIGN0b3IgPSBDQUNIRURfQ09OU1RSVUNUT1JTLmFycmF5WzBdXG4gICAgcmV0dXJuIGN0b3IoW10pXG4gIH0gZWxzZSBpZih0eXBlb2YgZGF0YSA9PT0gXCJudW1iZXJcIikge1xuICAgIGRhdGEgPSBbZGF0YV1cbiAgfVxuICBpZihzaGFwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc2hhcGUgPSBbIGRhdGEubGVuZ3RoIF1cbiAgfVxuICB2YXIgZCA9IHNoYXBlLmxlbmd0aFxuICBpZihzdHJpZGUgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0cmlkZSA9IG5ldyBBcnJheShkKVxuICAgIGZvcih2YXIgaT1kLTEsIHN6PTE7IGk+PTA7IC0taSkge1xuICAgICAgc3RyaWRlW2ldID0gc3pcbiAgICAgIHN6ICo9IHNoYXBlW2ldXG4gICAgfVxuICB9XG4gIGlmKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgb2Zmc2V0ID0gMFxuICAgIGZvcih2YXIgaT0wOyBpPGQ7ICsraSkge1xuICAgICAgaWYoc3RyaWRlW2ldIDwgMCkge1xuICAgICAgICBvZmZzZXQgLT0gKHNoYXBlW2ldLTEpKnN0cmlkZVtpXVxuICAgICAgfVxuICAgIH1cbiAgfVxuICB2YXIgZHR5cGUgPSBhcnJheURUeXBlKGRhdGEpXG4gIHZhciBjdG9yX2xpc3QgPSBDQUNIRURfQ09OU1RSVUNUT1JTW2R0eXBlXVxuICB3aGlsZShjdG9yX2xpc3QubGVuZ3RoIDw9IGQrMSkge1xuICAgIGN0b3JfbGlzdC5wdXNoKGNvbXBpbGVDb25zdHJ1Y3RvcihkdHlwZSwgY3Rvcl9saXN0Lmxlbmd0aC0xKSlcbiAgfVxuICB2YXIgY3RvciA9IGN0b3JfbGlzdFtkKzFdXG4gIHJldHVybiBjdG9yKGRhdGEsIHNoYXBlLCBzdHJpZGUsIG9mZnNldClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB3cmFwcGVkTkRBcnJheUN0b3Jcbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcikiLCJcInVzZSBzdHJpY3RcIlxuXG5mdW5jdGlvbiBpb3RhKG4pIHtcbiAgdmFyIHJlc3VsdCA9IG5ldyBBcnJheShuKVxuICBmb3IodmFyIGk9MDsgaTxuOyArK2kpIHtcbiAgICByZXN1bHRbaV0gPSBpXG4gIH1cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlvdGEiLCJpZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgLy8gaW1wbGVtZW50YXRpb24gZnJvbSBzdGFuZGFyZCBub2RlLmpzICd1dGlsJyBtb2R1bGVcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLCB7XG4gICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICB2YWx1ZTogY3RvcixcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbn0gZWxzZSB7XG4gIC8vIG9sZCBzY2hvb2wgc2hpbSBmb3Igb2xkIGJyb3dzZXJzXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fVxuICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGVcbiAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpXG4gICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yXG4gIH1cbn1cbiIsIm1vZHVsZS5leHBvcnRzPXJlcXVpcmUoXCIvcHJvamVjdHMvYmxhY2tpY2Uvbm9kZV9tb2R1bGVzL2dsLXNwcml0ZS10ZXh0L25vZGVfbW9kdWxlcy9nbC13aGl0ZS10ZXh0dXJlL25vZGVfbW9kdWxlcy9uZGFycmF5L25kYXJyYXkuanNcIikiLCJtb2R1bGUuZXhwb3J0cyA9IGV4dGVuZFxuXG5mdW5jdGlvbiBleHRlbmQoKSB7XG4gICAgdmFyIHRhcmdldCA9IHt9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldXG5cbiAgICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICAgICAgaWYgKHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldFxufVxuIiwibW9kdWxlLmV4cG9ydHM9cmVxdWlyZShcIi9wcm9qZWN0cy9ibGFja2ljZS9ub2RlX21vZHVsZXMvZ2wtc3ByaXRlLXRleHQvbm9kZV9tb2R1bGVzL2dsLXRleHR1cmUyZC90ZXh0dXJlLmpzXCIpIiwibW9kdWxlLmV4cG9ydHMgPSBzZXQ7XG5cbi8qKlxuICogU2V0IHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMyB0byB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHogWiBjb21wb25lbnRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gc2V0KG91dCwgeCwgeSwgeikge1xuICAgIG91dFswXSA9IHhcbiAgICBvdXRbMV0gPSB5XG4gICAgb3V0WzJdID0gelxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IHByb2dyYW1pZnlcblxudmFyIHNoYWRlciA9IHJlcXVpcmUoJ2dsLXNoYWRlci1jb3JlJylcblxuZnVuY3Rpb24gcHJvZ3JhbWlmeSh2ZXJ0ZXgsIGZyYWdtZW50LCB1bmlmb3JtcywgYXR0cmlidXRlcykge1xuICByZXR1cm4gZnVuY3Rpb24oZ2wpIHtcbiAgICByZXR1cm4gc2hhZGVyKGdsLCB2ZXJ0ZXgsIGZyYWdtZW50LCB1bmlmb3JtcywgYXR0cmlidXRlcylcbiAgfVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBub29wXG5cbmZ1bmN0aW9uIG5vb3AoKSB7XG4gIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdZb3Ugc2hvdWxkIGJ1bmRsZSB5b3VyIGNvZGUgJyArXG4gICAgICAndXNpbmcgYGdsc2xpZnlgIGFzIGEgdHJhbnNmb3JtLidcbiAgKVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlQXR0cmlidXRlV3JhcHBlclxuXG4vL1NoYWRlciBhdHRyaWJ1dGUgY2xhc3NcbmZ1bmN0aW9uIFNoYWRlckF0dHJpYnV0ZShnbCwgcHJvZ3JhbSwgbG9jYXRpb24sIGRpbWVuc2lvbiwgbmFtZSwgY29uc3RGdW5jLCByZWxpbmspIHtcbiAgdGhpcy5fZ2wgPSBnbFxuICB0aGlzLl9wcm9ncmFtID0gcHJvZ3JhbVxuICB0aGlzLl9sb2NhdGlvbiA9IGxvY2F0aW9uXG4gIHRoaXMuX2RpbWVuc2lvbiA9IGRpbWVuc2lvblxuICB0aGlzLl9uYW1lID0gbmFtZVxuICB0aGlzLl9jb25zdEZ1bmMgPSBjb25zdEZ1bmNcbiAgdGhpcy5fcmVsaW5rID0gcmVsaW5rXG59XG5cbnZhciBwcm90byA9IFNoYWRlckF0dHJpYnV0ZS5wcm90b3R5cGVcblxucHJvdG8ucG9pbnRlciA9IGZ1bmN0aW9uIHNldEF0dHJpYlBvaW50ZXIodHlwZSwgbm9ybWFsaXplZCwgc3RyaWRlLCBvZmZzZXQpIHtcbiAgdmFyIGdsID0gdGhpcy5fZ2xcbiAgZ2wudmVydGV4QXR0cmliUG9pbnRlcih0aGlzLl9sb2NhdGlvbiwgdGhpcy5fZGltZW5zaW9uLCB0eXBlfHxnbC5GTE9BVCwgISFub3JtYWxpemVkLCBzdHJpZGV8fDAsIG9mZnNldHx8MClcbiAgdGhpcy5fZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkodGhpcy5fbG9jYXRpb24pXG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90bywgJ2xvY2F0aW9uJywge1xuICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9sb2NhdGlvblxuICB9XG4gICwgc2V0OiBmdW5jdGlvbih2KSB7XG4gICAgaWYodiAhPT0gdGhpcy5fbG9jYXRpb24pIHtcbiAgICAgIHRoaXMuX2xvY2F0aW9uID0gdlxuICAgICAgdGhpcy5fZ2wuYmluZEF0dHJpYkxvY2F0aW9uKHRoaXMuX3Byb2dyYW0sIHYsIHRoaXMuX25hbWUpXG4gICAgICB0aGlzLl9nbC5saW5rUHJvZ3JhbSh0aGlzLl9wcm9ncmFtKVxuICAgICAgdGhpcy5fcmVsaW5rKClcbiAgICB9XG4gIH1cbn0pXG5cblxuLy9BZGRzIGEgdmVjdG9yIGF0dHJpYnV0ZSB0byBvYmpcbmZ1bmN0aW9uIGFkZFZlY3RvckF0dHJpYnV0ZShnbCwgcHJvZ3JhbSwgbG9jYXRpb24sIGRpbWVuc2lvbiwgb2JqLCBuYW1lLCBkb0xpbmspIHtcbiAgdmFyIGNvbnN0RnVuY0FyZ3MgPSBbICdnbCcsICd2JyBdXG4gIHZhciB2YXJOYW1lcyA9IFtdXG4gIGZvcih2YXIgaT0wOyBpPGRpbWVuc2lvbjsgKytpKSB7XG4gICAgY29uc3RGdW5jQXJncy5wdXNoKCd4JytpKVxuICAgIHZhck5hbWVzLnB1c2goJ3gnK2kpXG4gIH1cbiAgY29uc3RGdW5jQXJncy5wdXNoKFtcbiAgICAnaWYoeDAubGVuZ3RoPT09dm9pZCAwKXtyZXR1cm4gZ2wudmVydGV4QXR0cmliJywgZGltZW5zaW9uLCAnZih2LCcsIHZhck5hbWVzLmpvaW4oKSwgJyl9ZWxzZXtyZXR1cm4gZ2wudmVydGV4QXR0cmliJywgZGltZW5zaW9uLCAnZnYodix4MCl9J1xuICBdLmpvaW4oJycpKVxuICB2YXIgY29uc3RGdW5jID0gRnVuY3Rpb24uYXBwbHkodW5kZWZpbmVkLCBjb25zdEZ1bmNBcmdzKVxuICB2YXIgYXR0ciA9IG5ldyBTaGFkZXJBdHRyaWJ1dGUoZ2wsIHByb2dyYW0sIGxvY2F0aW9uLCBkaW1lbnNpb24sIG5hbWUsIGNvbnN0RnVuYywgZG9MaW5rKVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBuYW1lLCB7XG4gICAgc2V0OiBmdW5jdGlvbih4KSB7XG4gICAgICBnbC5kaXNhYmxlVmVydGV4QXR0cmliQXJyYXkoYXR0ci5fbG9jYXRpb24pXG4gICAgICBjb25zdEZ1bmMoZ2wsIGF0dHIuX2xvY2F0aW9uLCB4KVxuICAgICAgcmV0dXJuIHhcbiAgICB9XG4gICAgLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGF0dHJcbiAgICB9XG4gICAgLCBlbnVtZXJhYmxlOiB0cnVlXG4gIH0pXG59XG5cbi8vQ3JlYXRlIHNoaW1zIGZvciBhdHRyaWJ1dGVzXG5mdW5jdGlvbiBjcmVhdGVBdHRyaWJ1dGVXcmFwcGVyKGdsLCBwcm9ncmFtLCBhdHRyaWJ1dGVzLCBkb0xpbmspIHtcbiAgdmFyIG9iaiA9IHt9XG4gIGZvcih2YXIgaT0wLCBuPWF0dHJpYnV0ZXMubGVuZ3RoOyBpPG47ICsraSkge1xuICAgIHZhciBhID0gYXR0cmlidXRlc1tpXVxuICAgIHZhciBuYW1lID0gYS5uYW1lXG4gICAgdmFyIHR5cGUgPSBhLnR5cGVcbiAgICB2YXIgbG9jYXRpb24gPSBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCBuYW1lKVxuICAgIFxuICAgIHN3aXRjaCh0eXBlKSB7XG4gICAgICBjYXNlICdib29sJzpcbiAgICAgIGNhc2UgJ2ludCc6XG4gICAgICBjYXNlICdmbG9hdCc6XG4gICAgICAgIGFkZFZlY3RvckF0dHJpYnV0ZShnbCwgcHJvZ3JhbSwgbG9jYXRpb24sIDEsIG9iaiwgbmFtZSwgZG9MaW5rKVxuICAgICAgYnJlYWtcbiAgICAgIFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYodHlwZS5pbmRleE9mKCd2ZWMnKSA+PSAwKSB7XG4gICAgICAgICAgdmFyIGQgPSB0eXBlLmNoYXJDb2RlQXQodHlwZS5sZW5ndGgtMSkgLSA0OFxuICAgICAgICAgIGlmKGQgPCAyIHx8IGQgPiA0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dsLXNoYWRlcjogSW52YWxpZCBkYXRhIHR5cGUgZm9yIGF0dHJpYnV0ZSAnICsgbmFtZSArICc6ICcgKyB0eXBlKVxuICAgICAgICAgIH1cbiAgICAgICAgICBhZGRWZWN0b3JBdHRyaWJ1dGUoZ2wsIHByb2dyYW0sIGxvY2F0aW9uLCBkLCBvYmosIG5hbWUsIGRvTGluaylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dsLXNoYWRlcjogVW5rbm93biBkYXRhIHR5cGUgZm9yIGF0dHJpYnV0ZSAnICsgbmFtZSArICc6ICcgKyB0eXBlKVxuICAgICAgICB9XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuICByZXR1cm4gb2JqXG59IiwiJ3VzZSBzdHJpY3QnXG5cbnZhciBkdXAgPSByZXF1aXJlKCdkdXAnKVxudmFyIGNvYWxsZXNjZVVuaWZvcm1zID0gcmVxdWlyZSgnLi9yZWZsZWN0JylcblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVVbmlmb3JtV3JhcHBlclxuXG4vL0JpbmRzIGEgZnVuY3Rpb24gYW5kIHJldHVybnMgYSB2YWx1ZVxuZnVuY3Rpb24gaWRlbnRpdHkoeCkge1xuICB2YXIgYyA9IG5ldyBGdW5jdGlvbigneScsICdyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4geX0nKVxuICByZXR1cm4gYyh4KVxufVxuXG4vL0NyZWF0ZSBzaGltcyBmb3IgdW5pZm9ybXNcbmZ1bmN0aW9uIGNyZWF0ZVVuaWZvcm1XcmFwcGVyKGdsLCBwcm9ncmFtLCB1bmlmb3JtcywgbG9jYXRpb25zKSB7XG5cbiAgZnVuY3Rpb24gbWFrZUdldHRlcihpbmRleCkge1xuICAgIHZhciBwcm9jID0gbmV3IEZ1bmN0aW9uKCdnbCcsICdwcm9nJywgJ2xvY2F0aW9ucycsIFxuICAgICAgJ3JldHVybiBmdW5jdGlvbigpe3JldHVybiBnbC5nZXRVbmlmb3JtKHByb2csbG9jYXRpb25zWycgKyBpbmRleCArICddKX0nKSBcbiAgICByZXR1cm4gcHJvYyhnbCwgcHJvZ3JhbSwgbG9jYXRpb25zKVxuICB9XG5cbiAgZnVuY3Rpb24gbWFrZVByb3BTZXR0ZXIocGF0aCwgaW5kZXgsIHR5cGUpIHtcbiAgICBzd2l0Y2godHlwZSkge1xuICAgICAgY2FzZSAnYm9vbCc6XG4gICAgICBjYXNlICdpbnQnOlxuICAgICAgY2FzZSAnc2FtcGxlcjJEJzpcbiAgICAgIGNhc2UgJ3NhbXBsZXJDdWJlJzpcbiAgICAgICAgcmV0dXJuICdnbC51bmlmb3JtMWkobG9jYXRpb25zWycgKyBpbmRleCArICddLG9iaicgKyBwYXRoICsgJyknXG4gICAgICBjYXNlICdmbG9hdCc6XG4gICAgICAgIHJldHVybiAnZ2wudW5pZm9ybTFmKGxvY2F0aW9uc1snICsgaW5kZXggKyAnXSxvYmonICsgcGF0aCArICcpJ1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdmFyIHZpZHggPSB0eXBlLmluZGV4T2YoJ3ZlYycpXG4gICAgICAgIGlmKDAgPD0gdmlkeCAmJiB2aWR4IDw9IDEgJiYgdHlwZS5sZW5ndGggPT09IDQgKyB2aWR4KSB7XG4gICAgICAgICAgdmFyIGQgPSB0eXBlLmNoYXJDb2RlQXQodHlwZS5sZW5ndGgtMSkgLSA0OFxuICAgICAgICAgIGlmKGQgPCAyIHx8IGQgPiA0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dsLXNoYWRlcjogSW52YWxpZCBkYXRhIHR5cGUnKVxuICAgICAgICAgIH1cbiAgICAgICAgICBzd2l0Y2godHlwZS5jaGFyQXQoMCkpIHtcbiAgICAgICAgICAgIGNhc2UgJ2InOlxuICAgICAgICAgICAgY2FzZSAnaSc6XG4gICAgICAgICAgICAgIHJldHVybiAnZ2wudW5pZm9ybScgKyBkICsgJ2l2KGxvY2F0aW9uc1snICsgaW5kZXggKyAnXSxvYmonICsgcGF0aCArICcpJ1xuICAgICAgICAgICAgY2FzZSAndic6XG4gICAgICAgICAgICAgIHJldHVybiAnZ2wudW5pZm9ybScgKyBkICsgJ2Z2KGxvY2F0aW9uc1snICsgaW5kZXggKyAnXSxvYmonICsgcGF0aCArICcpJ1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdnbC1zaGFkZXI6IFVucmVjb2duaXplZCBkYXRhIHR5cGUgZm9yIHZlY3RvciAnICsgbmFtZSArICc6ICcgKyB0eXBlKVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmKHR5cGUuaW5kZXhPZignbWF0JykgPT09IDAgJiYgdHlwZS5sZW5ndGggPT09IDQpIHtcbiAgICAgICAgICB2YXIgZCA9IHR5cGUuY2hhckNvZGVBdCh0eXBlLmxlbmd0aC0xKSAtIDQ4XG4gICAgICAgICAgaWYoZCA8IDIgfHwgZCA+IDQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZ2wtc2hhZGVyOiBJbnZhbGlkIHVuaWZvcm0gZGltZW5zaW9uIHR5cGUgZm9yIG1hdHJpeCAnICsgbmFtZSArICc6ICcgKyB0eXBlKVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gJ2dsLnVuaWZvcm1NYXRyaXgnICsgZCArICdmdihsb2NhdGlvbnNbJyArIGluZGV4ICsgJ10sZmFsc2Usb2JqJyArIHBhdGggKyAnKSdcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dsLXNoYWRlcjogVW5rbm93biB1bmlmb3JtIGRhdGEgdHlwZSBmb3IgJyArIG5hbWUgKyAnOiAnICsgdHlwZSlcbiAgICAgICAgfVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBlbnVtZXJhdGVJbmRpY2VzKHByZWZpeCwgdHlwZSkge1xuICAgIGlmKHR5cGVvZiB0eXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIFsgW3ByZWZpeCwgdHlwZV0gXVxuICAgIH1cbiAgICB2YXIgaW5kaWNlcyA9IFtdXG4gICAgZm9yKHZhciBpZCBpbiB0eXBlKSB7XG4gICAgICB2YXIgcHJvcCA9IHR5cGVbaWRdXG4gICAgICB2YXIgdHByZWZpeCA9IHByZWZpeFxuICAgICAgaWYocGFyc2VJbnQoaWQpICsgJycgPT09IGlkKSB7XG4gICAgICAgIHRwcmVmaXggKz0gJ1snICsgaWQgKyAnXSdcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRwcmVmaXggKz0gJy4nICsgaWRcbiAgICAgIH1cbiAgICAgIGlmKHR5cGVvZiBwcm9wID09PSAnb2JqZWN0Jykge1xuICAgICAgICBpbmRpY2VzLnB1c2guYXBwbHkoaW5kaWNlcywgZW51bWVyYXRlSW5kaWNlcyh0cHJlZml4LCBwcm9wKSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluZGljZXMucHVzaChbdHByZWZpeCwgcHJvcF0pXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpbmRpY2VzXG4gIH1cblxuICBmdW5jdGlvbiBtYWtlU2V0dGVyKHR5cGUpIHtcbiAgICB2YXIgY29kZSA9IFsgJ3JldHVybiBmdW5jdGlvbiB1cGRhdGVQcm9wZXJ0eShvYmopeycgXVxuICAgIHZhciBpbmRpY2VzID0gZW51bWVyYXRlSW5kaWNlcygnJywgdHlwZSlcbiAgICBmb3IodmFyIGk9MDsgaTxpbmRpY2VzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgaXRlbSA9IGluZGljZXNbaV1cbiAgICAgIHZhciBwYXRoID0gaXRlbVswXVxuICAgICAgdmFyIGlkeCAgPSBpdGVtWzFdXG4gICAgICBpZihsb2NhdGlvbnNbaWR4XSkge1xuICAgICAgICBjb2RlLnB1c2gobWFrZVByb3BTZXR0ZXIocGF0aCwgaWR4LCB1bmlmb3Jtc1tpZHhdLnR5cGUpKVxuICAgICAgfVxuICAgIH1cbiAgICBjb2RlLnB1c2goJ3JldHVybiBvYmp9JylcbiAgICB2YXIgcHJvYyA9IG5ldyBGdW5jdGlvbignZ2wnLCAncHJvZycsICdsb2NhdGlvbnMnLCBjb2RlLmpvaW4oJ1xcbicpKVxuICAgIHJldHVybiBwcm9jKGdsLCBwcm9ncmFtLCBsb2NhdGlvbnMpXG4gIH1cblxuICBmdW5jdGlvbiBkZWZhdWx0VmFsdWUodHlwZSkge1xuICAgIHN3aXRjaCh0eXBlKSB7XG4gICAgICBjYXNlICdib29sJzpcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICBjYXNlICdpbnQnOlxuICAgICAgY2FzZSAnc2FtcGxlcjJEJzpcbiAgICAgIGNhc2UgJ3NhbXBsZXJDdWJlJzpcbiAgICAgICAgcmV0dXJuIDBcbiAgICAgIGNhc2UgJ2Zsb2F0JzpcbiAgICAgICAgcmV0dXJuIDAuMFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdmFyIHZpZHggPSB0eXBlLmluZGV4T2YoJ3ZlYycpXG4gICAgICAgIGlmKDAgPD0gdmlkeCAmJiB2aWR4IDw9IDEgJiYgdHlwZS5sZW5ndGggPT09IDQgKyB2aWR4KSB7XG4gICAgICAgICAgdmFyIGQgPSB0eXBlLmNoYXJDb2RlQXQodHlwZS5sZW5ndGgtMSkgLSA0OFxuICAgICAgICAgIGlmKGQgPCAyIHx8IGQgPiA0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dsLXNoYWRlcjogSW52YWxpZCBkYXRhIHR5cGUnKVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZih0eXBlLmNoYXJBdCgwKSA9PT0gJ2InKSB7XG4gICAgICAgICAgICByZXR1cm4gZHVwKGQsIGZhbHNlKVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZHVwKGQpXG4gICAgICAgIH0gZWxzZSBpZih0eXBlLmluZGV4T2YoJ21hdCcpID09PSAwICYmIHR5cGUubGVuZ3RoID09PSA0KSB7XG4gICAgICAgICAgdmFyIGQgPSB0eXBlLmNoYXJDb2RlQXQodHlwZS5sZW5ndGgtMSkgLSA0OFxuICAgICAgICAgIGlmKGQgPCAyIHx8IGQgPiA0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dsLXNoYWRlcjogSW52YWxpZCB1bmlmb3JtIGRpbWVuc2lvbiB0eXBlIGZvciBtYXRyaXggJyArIG5hbWUgKyAnOiAnICsgdHlwZSlcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGR1cChbZCxkXSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dsLXNoYWRlcjogVW5rbm93biB1bmlmb3JtIGRhdGEgdHlwZSBmb3IgJyArIG5hbWUgKyAnOiAnICsgdHlwZSlcbiAgICAgICAgfVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzdG9yZVByb3BlcnR5KG9iaiwgcHJvcCwgdHlwZSkge1xuICAgIGlmKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgdmFyIGNoaWxkID0gcHJvY2Vzc09iamVjdCh0eXBlKVxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgcHJvcCwge1xuICAgICAgICBnZXQ6IGlkZW50aXR5KGNoaWxkKSxcbiAgICAgICAgc2V0OiBtYWtlU2V0dGVyKHR5cGUpLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlXG4gICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICBpZihsb2NhdGlvbnNbdHlwZV0pIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgcHJvcCwge1xuICAgICAgICAgIGdldDogbWFrZUdldHRlcih0eXBlKSxcbiAgICAgICAgICBzZXQ6IG1ha2VTZXR0ZXIodHlwZSksXG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvYmpbcHJvcF0gPSBkZWZhdWx0VmFsdWUodW5pZm9ybXNbdHlwZV0udHlwZSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwcm9jZXNzT2JqZWN0KG9iaikge1xuICAgIHZhciByZXN1bHRcbiAgICBpZihBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgIHJlc3VsdCA9IG5ldyBBcnJheShvYmoubGVuZ3RoKVxuICAgICAgZm9yKHZhciBpPTA7IGk8b2JqLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHN0b3JlUHJvcGVydHkocmVzdWx0LCBpLCBvYmpbaV0pXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IHt9XG4gICAgICBmb3IodmFyIGlkIGluIG9iaikge1xuICAgICAgICBzdG9yZVByb3BlcnR5KHJlc3VsdCwgaWQsIG9ialtpZF0pXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIC8vUmV0dXJuIGRhdGFcbiAgdmFyIGNvYWxsZXNjZWQgPSBjb2FsbGVzY2VVbmlmb3Jtcyh1bmlmb3JtcywgdHJ1ZSlcbiAgcmV0dXJuIHtcbiAgICBnZXQ6IGlkZW50aXR5KHByb2Nlc3NPYmplY3QoY29hbGxlc2NlZCkpLFxuICAgIHNldDogbWFrZVNldHRlcihjb2FsbGVzY2VkKSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9XG59XG4iLCIndXNlIHN0cmljdCdcblxubW9kdWxlLmV4cG9ydHMgPSBtYWtlUmVmbGVjdFR5cGVzXG5cbi8vQ29uc3RydWN0IHR5cGUgaW5mbyBmb3IgcmVmbGVjdGlvbi5cbi8vXG4vLyBUaGlzIGl0ZXJhdGVzIG92ZXIgdGhlIGZsYXR0ZW5lZCBsaXN0IG9mIHVuaWZvcm0gdHlwZSB2YWx1ZXMgYW5kIHNtYXNoZXMgdGhlbSBpbnRvIGEgSlNPTiBvYmplY3QuXG4vL1xuLy8gVGhlIGxlYXZlcyBvZiB0aGUgcmVzdWx0aW5nIG9iamVjdCBhcmUgZWl0aGVyIGluZGljZXMgb3IgdHlwZSBzdHJpbmdzIHJlcHJlc2VudGluZyBwcmltaXRpdmUgZ2xzbGlmeSB0eXBlc1xuZnVuY3Rpb24gbWFrZVJlZmxlY3RUeXBlcyh1bmlmb3JtcywgdXNlSW5kZXgpIHtcbiAgdmFyIG9iaiA9IHt9XG4gIGZvcih2YXIgaT0wOyBpPHVuaWZvcm1zLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIG4gPSB1bmlmb3Jtc1tpXS5uYW1lXG4gICAgdmFyIHBhcnRzID0gbi5zcGxpdChcIi5cIilcbiAgICB2YXIgbyA9IG9ialxuICAgIGZvcih2YXIgaj0wOyBqPHBhcnRzLmxlbmd0aDsgKytqKSB7XG4gICAgICB2YXIgeCA9IHBhcnRzW2pdLnNwbGl0KFwiW1wiKVxuICAgICAgaWYoeC5sZW5ndGggPiAxKSB7XG4gICAgICAgIGlmKCEoeFswXSBpbiBvKSkge1xuICAgICAgICAgIG9beFswXV0gPSBbXVxuICAgICAgICB9XG4gICAgICAgIG8gPSBvW3hbMF1dXG4gICAgICAgIGZvcih2YXIgaz0xOyBrPHgubGVuZ3RoOyArK2spIHtcbiAgICAgICAgICB2YXIgeSA9IHBhcnNlSW50KHhba10pXG4gICAgICAgICAgaWYoazx4Lmxlbmd0aC0xIHx8IGo8cGFydHMubGVuZ3RoLTEpIHtcbiAgICAgICAgICAgIGlmKCEoeSBpbiBvKSkge1xuICAgICAgICAgICAgICBpZihrIDwgeC5sZW5ndGgtMSkge1xuICAgICAgICAgICAgICAgIG9beV0gPSBbXVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG9beV0gPSB7fVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvID0gb1t5XVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZih1c2VJbmRleCkge1xuICAgICAgICAgICAgICBvW3ldID0gaVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgb1t5XSA9IHVuaWZvcm1zW2ldLnR5cGVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZihqIDwgcGFydHMubGVuZ3RoLTEpIHtcbiAgICAgICAgaWYoISh4WzBdIGluIG8pKSB7XG4gICAgICAgICAgb1t4WzBdXSA9IHt9XG4gICAgICAgIH1cbiAgICAgICAgbyA9IG9beFswXV1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmKHVzZUluZGV4KSB7XG4gICAgICAgICAgb1t4WzBdXSA9IGlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvW3hbMF1dID0gdW5pZm9ybXNbaV0udHlwZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBvYmpcbn0iLCJtb2R1bGUuZXhwb3J0cz1yZXF1aXJlKFwiL3Byb2plY3RzL2JsYWNraWNlL25vZGVfbW9kdWxlcy9nbC1zcHJpdGUtdGV4dC9ub2RlX21vZHVsZXMvZ2wtc3ByaXRlLWJhdGNoL25vZGVfbW9kdWxlcy9nbC1idWZmZXIvbm9kZV9tb2R1bGVzL3R5cGVkYXJyYXktcG9vbC9ub2RlX21vZHVsZXMvZHVwL2R1cC5qc1wiKSIsIid1c2Ugc3RyaWN0J1xuXG52YXIgY3JlYXRlVW5pZm9ybVdyYXBwZXIgPSByZXF1aXJlKCcuL2xpYi9jcmVhdGUtdW5pZm9ybXMnKVxudmFyIGNyZWF0ZUF0dHJpYnV0ZVdyYXBwZXIgPSByZXF1aXJlKCcuL2xpYi9jcmVhdGUtYXR0cmlidXRlcycpXG52YXIgbWFrZVJlZmxlY3QgPSByZXF1aXJlKCcuL2xpYi9yZWZsZWN0JylcblxuLy9TaGFkZXIgb2JqZWN0XG5mdW5jdGlvbiBTaGFkZXIoZ2wsIHByb2csIHZlcnRTaGFkZXIsIGZyYWdTaGFkZXIpIHtcbiAgdGhpcy5nbCA9IGdsXG4gIHRoaXMuaGFuZGxlID0gcHJvZ1xuICB0aGlzLmF0dHJpYnV0ZXMgPSBudWxsXG4gIHRoaXMudW5pZm9ybXMgPSBudWxsXG4gIHRoaXMudHlwZXMgPSBudWxsXG4gIHRoaXMudmVydGV4U2hhZGVyID0gdmVydFNoYWRlclxuICB0aGlzLmZyYWdtZW50U2hhZGVyID0gZnJhZ1NoYWRlclxufVxuXG4vL0JpbmRzIHRoZSBzaGFkZXJcblNoYWRlci5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmdsLnVzZVByb2dyYW0odGhpcy5oYW5kbGUpXG59XG5cbi8vRGVzdHJveSBzaGFkZXIsIHJlbGVhc2UgcmVzb3VyY2VzXG5TaGFkZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGdsID0gdGhpcy5nbFxuICBnbC5kZWxldGVTaGFkZXIodGhpcy52ZXJ0ZXhTaGFkZXIpXG4gIGdsLmRlbGV0ZVNoYWRlcih0aGlzLmZyYWdtZW50U2hhZGVyKVxuICBnbC5kZWxldGVQcm9ncmFtKHRoaXMuaGFuZGxlKVxufVxuXG5TaGFkZXIucHJvdG90eXBlLnVwZGF0ZUV4cG9ydHMgPSBmdW5jdGlvbih1bmlmb3JtcywgYXR0cmlidXRlcykge1xuICB2YXIgbG9jYXRpb25zID0gbmV3IEFycmF5KHVuaWZvcm1zLmxlbmd0aClcbiAgdmFyIHByb2dyYW0gPSB0aGlzLmhhbmRsZVxuICB2YXIgZ2wgPSB0aGlzLmdsXG5cbiAgdmFyIGRvTGluayA9IHJlbGlua1VuaWZvcm1zLmJpbmQodm9pZCAwLFxuICAgIGdsLFxuICAgIHByb2dyYW0sXG4gICAgbG9jYXRpb25zLFxuICAgIHVuaWZvcm1zXG4gIClcbiAgZG9MaW5rKClcblxuICB0aGlzLnR5cGVzID0ge1xuICAgIHVuaWZvcm1zOiBtYWtlUmVmbGVjdCh1bmlmb3JtcyksXG4gICAgYXR0cmlidXRlczogbWFrZVJlZmxlY3QoYXR0cmlidXRlcylcbiAgfVxuXG4gIHRoaXMuYXR0cmlidXRlcyA9IGNyZWF0ZUF0dHJpYnV0ZVdyYXBwZXIoXG4gICAgZ2wsXG4gICAgcHJvZ3JhbSxcbiAgICBhdHRyaWJ1dGVzLFxuICAgIGRvTGlua1xuICApXG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICd1bmlmb3JtcycsIGNyZWF0ZVVuaWZvcm1XcmFwcGVyKFxuICAgIGdsLFxuICAgIHByb2dyYW0sXG4gICAgdW5pZm9ybXMsXG4gICAgbG9jYXRpb25zXG4gICkpXG59XG5cbi8vUmVsaW5rcyBhbGwgdW5pZm9ybXNcbmZ1bmN0aW9uIHJlbGlua1VuaWZvcm1zKGdsLCBwcm9ncmFtLCBsb2NhdGlvbnMsIHVuaWZvcm1zKSB7XG4gIGZvcih2YXIgaT0wOyBpPHVuaWZvcm1zLmxlbmd0aDsgKytpKSB7XG4gICAgbG9jYXRpb25zW2ldID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIHVuaWZvcm1zW2ldLm5hbWUpXG4gIH1cbn1cblxuLy9Db21waWxlcyBhbmQgbGlua3MgYSBzaGFkZXIgcHJvZ3JhbSB3aXRoIHRoZSBnaXZlbiBhdHRyaWJ1dGUgYW5kIHZlcnRleCBsaXN0XG5mdW5jdGlvbiBjcmVhdGVTaGFkZXIoXG4gICAgZ2xcbiAgLCB2ZXJ0U291cmNlXG4gICwgZnJhZ1NvdXJjZVxuICAsIHVuaWZvcm1zXG4gICwgYXR0cmlidXRlcykge1xuICBcbiAgLy9Db21waWxlIHZlcnRleCBzaGFkZXJcbiAgdmFyIHZlcnRTaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIoZ2wuVkVSVEVYX1NIQURFUilcbiAgZ2wuc2hhZGVyU291cmNlKHZlcnRTaGFkZXIsIHZlcnRTb3VyY2UpXG4gIGdsLmNvbXBpbGVTaGFkZXIodmVydFNoYWRlcilcbiAgaWYoIWdsLmdldFNoYWRlclBhcmFtZXRlcih2ZXJ0U2hhZGVyLCBnbC5DT01QSUxFX1NUQVRVUykpIHtcbiAgICB2YXIgZXJyTG9nID0gZ2wuZ2V0U2hhZGVySW5mb0xvZyh2ZXJ0U2hhZGVyKVxuICAgIGNvbnNvbGUuZXJyb3IoJ2dsLXNoYWRlcjogRXJyb3IgY29tcGxpbmcgdmVydGV4IHNoYWRlcjonLCBlcnJMb2cpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdnbC1zaGFkZXI6IEVycm9yIGNvbXBpbGluZyB2ZXJ0ZXggc2hhZGVyOicgKyBlcnJMb2cpXG4gIH1cbiAgXG4gIC8vQ29tcGlsZSBmcmFnbWVudCBzaGFkZXJcbiAgdmFyIGZyYWdTaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIoZ2wuRlJBR01FTlRfU0hBREVSKVxuICBnbC5zaGFkZXJTb3VyY2UoZnJhZ1NoYWRlciwgZnJhZ1NvdXJjZSlcbiAgZ2wuY29tcGlsZVNoYWRlcihmcmFnU2hhZGVyKVxuICBpZighZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKGZyYWdTaGFkZXIsIGdsLkNPTVBJTEVfU1RBVFVTKSkge1xuICAgIHZhciBlcnJMb2cgPSBnbC5nZXRTaGFkZXJJbmZvTG9nKGZyYWdTaGFkZXIpXG4gICAgY29uc29sZS5lcnJvcignZ2wtc2hhZGVyOiBFcnJvciBjb21waWxpbmcgZnJhZ21lbnQgc2hhZGVyOicsIGVyckxvZylcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2dsLXNoYWRlcjogRXJyb3IgY29tcGlsaW5nIGZyYWdtZW50IHNoYWRlcjonICsgZXJyTG9nKVxuICB9XG4gIFxuICAvL0xpbmsgcHJvZ3JhbVxuICB2YXIgcHJvZ3JhbSA9IGdsLmNyZWF0ZVByb2dyYW0oKVxuICBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgZnJhZ1NoYWRlcilcbiAgZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIHZlcnRTaGFkZXIpXG5cbiAgLy9PcHRpb25hbCBkZWZhdWx0IGF0dHJpdWJ0ZSBsb2NhdGlvbnNcbiAgYXR0cmlidXRlcy5mb3JFYWNoKGZ1bmN0aW9uKGEpIHtcbiAgICBpZiAodHlwZW9mIGEubG9jYXRpb24gPT09ICdudW1iZXInKSBcbiAgICAgIGdsLmJpbmRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCBhLmxvY2F0aW9uLCBhLm5hbWUpXG4gIH0pXG5cbiAgZ2wubGlua1Byb2dyYW0ocHJvZ3JhbSlcbiAgaWYoIWdsLmdldFByb2dyYW1QYXJhbWV0ZXIocHJvZ3JhbSwgZ2wuTElOS19TVEFUVVMpKSB7XG4gICAgdmFyIGVyckxvZyA9IGdsLmdldFByb2dyYW1JbmZvTG9nKHByb2dyYW0pXG4gICAgY29uc29sZS5lcnJvcignZ2wtc2hhZGVyOiBFcnJvciBsaW5raW5nIHNoYWRlciBwcm9ncmFtOicsIGVyckxvZylcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2dsLXNoYWRlcjogRXJyb3IgbGlua2luZyBzaGFkZXIgcHJvZ3JhbTonICsgZXJyTG9nKVxuICB9XG4gIFxuICAvL1JldHVybiBmaW5hbCBsaW5rZWQgc2hhZGVyIG9iamVjdFxuICB2YXIgc2hhZGVyID0gbmV3IFNoYWRlcihcbiAgICBnbCxcbiAgICBwcm9ncmFtLFxuICAgIHZlcnRTaGFkZXIsXG4gICAgZnJhZ1NoYWRlclxuICApXG4gIHNoYWRlci51cGRhdGVFeHBvcnRzKHVuaWZvcm1zLCBhdHRyaWJ1dGVzKVxuXG4gIHJldHVybiBzaGFkZXJcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVTaGFkZXJcbiIsIm1vZHVsZS5leHBvcnRzID0gcHJvZ3JhbWlmeVxuXG5mdW5jdGlvbiBwcm9ncmFtaWZ5KHZlcnRleCwgZnJhZ21lbnQsIHVuaWZvcm1zLCBhdHRyaWJ1dGVzKSB7XG4gIHJldHVybiB7XG4gICAgdmVydGV4OiB2ZXJ0ZXgsIFxuICAgIGZyYWdtZW50OiBmcmFnbWVudCxcbiAgICB1bmlmb3JtczogdW5pZm9ybXMsIFxuICAgIGF0dHJpYnV0ZXM6IGF0dHJpYnV0ZXNcbiAgfTtcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gaW1nO1xuXG5mdW5jdGlvbiBpbWcgKHNyYywgb3B0LCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIG9wdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gb3B0XG4gICAgb3B0ID0gbnVsbFxuICB9XG5cblxuICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcbiAgdmFyIGxvY2tlZDtcblxuICBlbC5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGxvY2tlZCkgcmV0dXJuO1xuICAgIGxvY2tlZCA9IHRydWU7XG5cbiAgICBjYWxsYmFjayAmJiBjYWxsYmFjayh1bmRlZmluZWQsIGVsKTtcbiAgfTtcblxuICBlbC5vbmVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgIGlmIChsb2NrZWQpIHJldHVybjtcbiAgICBsb2NrZWQgPSB0cnVlO1xuXG4gICAgY2FsbGJhY2sgJiYgY2FsbGJhY2sobmV3IEVycm9yKCdVbmFibGUgdG8gbG9hZCBcIicgKyBzcmMgKyAnXCInKSwgZWwpO1xuICB9O1xuICBcbiAgaWYgKG9wdCAmJiBvcHQuY3Jvc3NPcmlnaW4pXG4gICAgZWwuY3Jvc3NPcmlnaW4gPSBvcHQuY3Jvc3NPcmlnaW47XG5cbiAgZWwuc3JjID0gc3JjO1xuXG4gIHJldHVybiBlbDtcbn1cbiIsIm1vZHVsZS5leHBvcnRzPXJlcXVpcmUoXCIvcHJvamVjdHMvYmxhY2tpY2Uvbm9kZV9tb2R1bGVzL2dsLXNwcml0ZS10ZXh0L25vZGVfbW9kdWxlcy9pbmhlcml0cy9pbmhlcml0c19icm93c2VyLmpzXCIpIiwibW9kdWxlLmV4cG9ydHM9cmVxdWlyZShcIi9wcm9qZWN0cy9ibGFja2ljZS9ub2RlX21vZHVsZXMvZ2wtc3ByaXRlLXRleHQvbm9kZV9tb2R1bGVzL2dsLXNwcml0ZS1iYXRjaC9ub2RlX21vZHVsZXMvbWl4ZXMvaW5kZXguanNcIikiLCJ2YXIgYm91bmRzID0gcmVxdWlyZSgnZ2V0Ym91bmRpbmdib3gnKVxudmFyIHVubGVycCA9IHJlcXVpcmUoJ3VubGVycCcpXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbm9ybWFsaXplKHBhdGgsIGJveCkge1xuICAgIHZhciBiXG4gICAgaWYgKGJveCAmJiB0eXBlb2YgYm94ID09PSAnb2JqZWN0Jykge1xuICAgICAgICBiID0gYm94XG4gICAgfSBlbHNlXG4gICAgICAgIGIgPSBib3VuZHMocGF0aClcblxuICAgIC8vVE9ETzogaG1tLCBkb2Vzbid0IHJlYWxseSBoYW5kbGUgZGl2IGJ5IHplcm9cbiAgICAvL2luIGFueSBzYW5lIG1hbm5lclxuXG4gICAgdmFyIHcgPSAoYi5tYXhYLWIubWluWCksXG4gICAgICAgIGggPSAoYi5tYXhZLWIubWluWSlcblxuICAgIHZhciBhc3BlY3RYID0gdz5oID8gMSA6IGgvdyxcbiAgICAgICAgYXNwZWN0WSA9IHc+aCA/IHcvaCA6IDFcblxuICAgIHJldHVybiBwYXRoLm1hcChmdW5jdGlvbihwKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICByYW5nZShiLm1pblgsIGIubWF4WCwgcFswXSkqMS9hc3BlY3RYLFxuICAgICAgICAgICAgcmFuZ2UoYi5taW5ZLCBiLm1heFksIHBbMV0pKjEvYXNwZWN0WVxuICAgICAgICBdXG4gICAgfSlcbn1cblxuZnVuY3Rpb24gcmFuZ2UobWluLCBtYXgsIHZhbHVlKSB7XG4gICAgcmV0dXJuICgobWF4LW1pbj09PTApID8gMCA6IHVubGVycChtaW4sIG1heCwgdmFsdWUpKSoyLTFcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCBwYXRoLCBib3gsIHhLZXksIHlLZXkgKSB7XG4gICAgeEtleSA9IHR5cGVvZiB4S2V5ID09PSAnc3RyaW5nJyA/IHhLZXkgOiAwO1xuICAgIHlLZXkgPSB0eXBlb2YgeUtleSA9PT0gJ3N0cmluZycgPyB5S2V5IDogMTtcbiAgICBpZiAoIWJveCB8fCB0eXBlb2YgYm94ID09PSAnbnVtYmVyJylcbiAgICAgICAgYm94ID0ge307XG5cbiAgICBib3gubWluWCA9IEluZmluaXR5O1xuICAgIGJveC5taW5ZID0gSW5maW5pdHk7XG4gICAgYm94Lm1heFggPSAtSW5maW5pdHk7XG4gICAgYm94Lm1heFkgPSAtSW5maW5pdHk7XG5cbiAgICBmb3IgKHZhciBpPTA7IGk8cGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgeCA9IHBhdGhbaV1bIHhLZXkgXSxcbiAgICAgICAgICAgIHkgPSBwYXRoW2ldWyB5S2V5IF07XG4gICAgICAgIGJveC5taW5YID0gTWF0aC5taW4oIGJveC5taW5YLCB4ICk7XG4gICAgICAgIGJveC5taW5ZID0gTWF0aC5taW4oIGJveC5taW5ZLCB5ICk7XG4gICAgICAgIGJveC5tYXhYID0gTWF0aC5tYXgoIGJveC5tYXhYLCB4ICk7XG4gICAgICAgIGJveC5tYXhZID0gTWF0aC5tYXgoIGJveC5tYXhZLCB5ICk7XG4gICAgfVxuICAgIFxuICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkgXG4gICAgICAgIGJveC5taW5YID0gYm94Lm1heFggPSBib3gubWluWSA9IGJveC5tYXhZID0gMFxuICAgIHJldHVybiBib3g7XG59OyIsIlxubW9kdWxlLmV4cG9ydHMgPSBwYXJzZVxuXG4vKipcbiAqIGV4cGVjdGVkIGFyZ3VtZW50IGxlbmd0aHNcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cblxudmFyIGxlbmd0aCA9IHthOiA3LCBjOiA2LCBoOiAxLCBsOiAyLCBtOiAyLCBxOiA0LCBzOiA0LCB0OiAyLCB2OiAxLCB6OiAwfVxuXG4vKipcbiAqIHNlZ21lbnQgcGF0dGVyblxuICogQHR5cGUge1JlZ0V4cH1cbiAqL1xuXG52YXIgc2VnbWVudCA9IC8oW2FzdHZ6cW1obGNdKShbXmFzdHZ6cW1obGNdKikvaWdcblxuLyoqXG4gKiBwYXJzZSBhbiBzdmcgcGF0aCBkYXRhIHN0cmluZy4gR2VuZXJhdGVzIGFuIEFycmF5XG4gKiBvZiBjb21tYW5kcyB3aGVyZSBlYWNoIGNvbW1hbmQgaXMgYW4gQXJyYXkgb2YgdGhlXG4gKiBmb3JtIGBbY29tbWFuZCwgYXJnMSwgYXJnMiwgLi4uXWBcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cblxuZnVuY3Rpb24gcGFyc2UocGF0aCkge1xuXHR2YXIgZGF0YSA9IFtdXG5cdHBhdGgucmVwbGFjZShzZWdtZW50LCBmdW5jdGlvbihfLCBjb21tYW5kLCBhcmdzKXtcblx0XHR2YXIgdHlwZSA9IGNvbW1hbmQudG9Mb3dlckNhc2UoKVxuXHRcdGFyZ3MgPSBwYXJzZVZhbHVlcyhhcmdzKVxuXG5cdFx0Ly8gb3ZlcmxvYWRlZCBtb3ZlVG9cblx0XHRpZiAodHlwZSA9PSAnbScgJiYgYXJncy5sZW5ndGggPiAyKSB7XG5cdFx0XHRkYXRhLnB1c2goW2NvbW1hbmRdLmNvbmNhdChhcmdzLnNwbGljZSgwLCAyKSkpXG5cdFx0XHR0eXBlID0gJ2wnXG5cdFx0XHRjb21tYW5kID0gY29tbWFuZCA9PSAnbScgPyAnbCcgOiAnTCdcblx0XHR9XG5cblx0XHR3aGlsZSAodHJ1ZSkge1xuXHRcdFx0aWYgKGFyZ3MubGVuZ3RoID09IGxlbmd0aFt0eXBlXSkge1xuXHRcdFx0XHRhcmdzLnVuc2hpZnQoY29tbWFuZClcblx0XHRcdFx0cmV0dXJuIGRhdGEucHVzaChhcmdzKVxuXHRcdFx0fVxuXHRcdFx0aWYgKGFyZ3MubGVuZ3RoIDwgbGVuZ3RoW3R5cGVdKSB0aHJvdyBuZXcgRXJyb3IoJ21hbGZvcm1lZCBwYXRoIGRhdGEnKVxuXHRcdFx0ZGF0YS5wdXNoKFtjb21tYW5kXS5jb25jYXQoYXJncy5zcGxpY2UoMCwgbGVuZ3RoW3R5cGVdKSkpXG5cdFx0fVxuXHR9KVxuXHRyZXR1cm4gZGF0YVxufVxuXG5mdW5jdGlvbiBwYXJzZVZhbHVlcyhhcmdzKXtcblx0YXJncyA9IGFyZ3MubWF0Y2goLy0/Wy4wLTldKyg/OmVbLStdP1xcZCspPy9pZylcblx0cmV0dXJuIGFyZ3MgPyBhcmdzLm1hcChOdW1iZXIpIDogW11cbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gcGx1Y2tlclxuXG5mdW5jdGlvbiBwbHVja2VyKHBhdGgsIG9iamVjdCkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+PSAyXG4gICAgPyBwbHVjayhwYXRoKShvYmplY3QpXG4gICAgOiBwbHVjayhwYXRoKVxufVxuXG5mdW5jdGlvbiBwbHVjayhwYXRoKSB7XG4gIHBhdGggPSB0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZydcbiAgICA/IFN0cmluZyhwYXRoKS50cmltKCkuc3BsaXQoJy4nKVxuICAgIDogcGF0aFxuXG4gIGlmIChwYXRoLmxlbmd0aCA8IDIpIHtcbiAgICBwYXRoID0gcGF0aFswXVxuICAgIHJldHVybiBwbHVja1NpbmdsZVxuICB9IGVsc2Uge1xuICAgIHZhciBsID0gcGF0aC5sZW5ndGhcbiAgICByZXR1cm4gcGx1Y2tQYXRoXG4gIH1cblxuICBmdW5jdGlvbiBwbHVja1NpbmdsZShvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0W3BhdGhdXG4gIH1cblxuICBmdW5jdGlvbiBwbHVja1BhdGgob2JqZWN0KSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmICh0eXBlb2Ygb2JqZWN0ID09PSAndW5kZWZpbmVkJykgYnJlYWtcblxuICAgICAgb2JqZWN0ID0gb2JqZWN0W3BhdGhbaV1dXG4gICAgfVxuXG4gICAgcmV0dXJuIG9iamVjdFxuICB9XG59XG4iLCIvKlxyXG4gKiByYWYuanNcclxuICogaHR0cHM6Ly9naXRodWIuY29tL25ncnltYW4vcmFmLmpzXHJcbiAqXHJcbiAqIG9yaWdpbmFsIHJlcXVlc3RBbmltYXRpb25GcmFtZSBwb2x5ZmlsbCBieSBFcmlrIE3DtmxsZXJcclxuICogaW5zcGlyZWQgZnJvbSBwYXVsX2lyaXNoIGdpc3QgYW5kIHBvc3RcclxuICpcclxuICogQ29weXJpZ2h0IChjKSAyMDEzIG5ncnltYW5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxyXG4gKi9cclxuXHJcbihmdW5jdGlvbih3aW5kb3cpIHtcclxuXHR2YXIgbGFzdFRpbWUgPSAwLFxyXG5cdFx0dmVuZG9ycyA9IFsnd2Via2l0JywgJ21veiddLFxyXG5cdFx0cmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSxcclxuXHRcdGNhbmNlbEFuaW1hdGlvbkZyYW1lID0gd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lLFxyXG5cdFx0aSA9IHZlbmRvcnMubGVuZ3RoO1xyXG5cclxuXHQvLyB0cnkgdG8gdW4tcHJlZml4IGV4aXN0aW5nIHJhZlxyXG5cdHdoaWxlICgtLWkgPj0gMCAmJiAhcmVxdWVzdEFuaW1hdGlvbkZyYW1lKSB7XHJcblx0XHRyZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSB3aW5kb3dbdmVuZG9yc1tpXSArICdSZXF1ZXN0QW5pbWF0aW9uRnJhbWUnXTtcclxuXHRcdGNhbmNlbEFuaW1hdGlvbkZyYW1lID0gd2luZG93W3ZlbmRvcnNbaV0gKyAnQ2FuY2VsQW5pbWF0aW9uRnJhbWUnXTtcclxuXHR9XHJcblxyXG5cdC8vIHBvbHlmaWxsIHdpdGggc2V0VGltZW91dCBmYWxsYmFja1xyXG5cdC8vIGhlYXZpbHkgaW5zcGlyZWQgZnJvbSBAZGFyaXVzIGdpc3QgbW9kOiBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9wYXVsaXJpc2gvMTU3OTY3MSNjb21tZW50LTgzNzk0NVxyXG5cdGlmICghcmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8ICFjYW5jZWxBbmltYXRpb25GcmFtZSkge1xyXG5cdFx0cmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcclxuXHRcdFx0dmFyIG5vdyA9ICtuZXcgRGF0ZSgpLCBuZXh0VGltZSA9IE1hdGgubWF4KGxhc3RUaW1lICsgMTYsIG5vdyk7XHJcblx0XHRcdHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdGNhbGxiYWNrKGxhc3RUaW1lID0gbmV4dFRpbWUpO1xyXG5cdFx0XHR9LCBuZXh0VGltZSAtIG5vdyk7XHJcblx0XHR9O1xyXG5cclxuXHRcdGNhbmNlbEFuaW1hdGlvbkZyYW1lID0gY2xlYXJUaW1lb3V0O1xyXG5cdH1cclxuXHJcblx0Ly8gZXhwb3J0IHRvIHdpbmRvd1xyXG5cdHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XHJcblx0d2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lID0gY2FuY2VsQW5pbWF0aW9uRnJhbWU7XHJcbn0od2luZG93KSk7XHJcbiIsIi8vIHNxdWFyZSBkaXN0YW5jZSBmcm9tIGEgcG9pbnQgdG8gYSBzZWdtZW50XG5mdW5jdGlvbiBnZXRTcVNlZ0Rpc3QocCwgcDEsIHAyKSB7XG4gICAgdmFyIHggPSBwMVswXSxcbiAgICAgICAgeSA9IHAxWzFdLFxuICAgICAgICBkeCA9IHAyWzBdIC0geCxcbiAgICAgICAgZHkgPSBwMlsxXSAtIHk7XG5cbiAgICBpZiAoZHggIT09IDAgfHwgZHkgIT09IDApIHtcblxuICAgICAgICB2YXIgdCA9ICgocFswXSAtIHgpICogZHggKyAocFsxXSAtIHkpICogZHkpIC8gKGR4ICogZHggKyBkeSAqIGR5KTtcblxuICAgICAgICBpZiAodCA+IDEpIHtcbiAgICAgICAgICAgIHggPSBwMlswXTtcbiAgICAgICAgICAgIHkgPSBwMlsxXTtcblxuICAgICAgICB9IGVsc2UgaWYgKHQgPiAwKSB7XG4gICAgICAgICAgICB4ICs9IGR4ICogdDtcbiAgICAgICAgICAgIHkgKz0gZHkgKiB0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZHggPSBwWzBdIC0geDtcbiAgICBkeSA9IHBbMV0gLSB5O1xuXG4gICAgcmV0dXJuIGR4ICogZHggKyBkeSAqIGR5O1xufVxuXG4vLyBzaW1wbGlmaWNhdGlvbiB1c2luZyBvcHRpbWl6ZWQgRG91Z2xhcy1QZXVja2VyIGFsZ29yaXRobSB3aXRoIHJlY3Vyc2lvbiBlbGltaW5hdGlvblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzaW1wbGlmeURvdWdsYXNQZXVja2VyKHBvaW50cywgdG9sZXJhbmNlKSB7XG4gICAgaWYgKHBvaW50cy5sZW5ndGg8PTEpXG4gICAgICAgIHJldHVybiBwb2ludHM7XG4gICAgdG9sZXJhbmNlID0gdHlwZW9mIHRvbGVyYW5jZSA9PT0gJ251bWJlcicgPyB0b2xlcmFuY2UgOiAxO1xuICAgIHZhciBzcVRvbGVyYW5jZSA9IHRvbGVyYW5jZSAqIHRvbGVyYW5jZTtcblxuICAgIHZhciBsZW4gPSBwb2ludHMubGVuZ3RoLFxuICAgICAgICBNYXJrZXJBcnJheSA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyA/IFVpbnQ4QXJyYXkgOiBBcnJheSxcbiAgICAgICAgbWFya2VycyA9IG5ldyBNYXJrZXJBcnJheShsZW4pLFxuICAgICAgICBmaXJzdCA9IDAsXG4gICAgICAgIGxhc3QgPSBsZW4gLSAxLFxuICAgICAgICBzdGFjayA9IFtdLFxuICAgICAgICBuZXdQb2ludHMgPSBbXSxcbiAgICAgICAgaSwgbWF4U3FEaXN0LCBzcURpc3QsIGluZGV4O1xuXG4gICAgbWFya2Vyc1tmaXJzdF0gPSBtYXJrZXJzW2xhc3RdID0gMTtcblxuICAgIHdoaWxlIChsYXN0KSB7XG5cbiAgICAgICAgbWF4U3FEaXN0ID0gMDtcblxuICAgICAgICBmb3IgKGkgPSBmaXJzdCArIDE7IGkgPCBsYXN0OyBpKyspIHtcbiAgICAgICAgICAgIHNxRGlzdCA9IGdldFNxU2VnRGlzdChwb2ludHNbaV0sIHBvaW50c1tmaXJzdF0sIHBvaW50c1tsYXN0XSk7XG5cbiAgICAgICAgICAgIGlmIChzcURpc3QgPiBtYXhTcURpc3QpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgbWF4U3FEaXN0ID0gc3FEaXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1heFNxRGlzdCA+IHNxVG9sZXJhbmNlKSB7XG4gICAgICAgICAgICBtYXJrZXJzW2luZGV4XSA9IDE7XG4gICAgICAgICAgICBzdGFjay5wdXNoKGZpcnN0LCBpbmRleCwgaW5kZXgsIGxhc3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGFzdCA9IHN0YWNrLnBvcCgpO1xuICAgICAgICBmaXJzdCA9IHN0YWNrLnBvcCgpO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAobWFya2Vyc1tpXSkgbmV3UG9pbnRzLnB1c2gocG9pbnRzW2ldKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3UG9pbnRzO1xufSIsInZhciBzaW1wbGlmeVJhZGlhbERpc3QgPSByZXF1aXJlKCcuL3JhZGlhbC1kaXN0YW5jZScpXG52YXIgc2ltcGxpZnlEb3VnbGFzUGV1Y2tlciA9IHJlcXVpcmUoJy4vZG91Z2xhcy1wZXVja2VyJylcblxuLy9zaW1wbGlmaWVzIHVzaW5nIGJvdGggYWxnb3JpdGhtc1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzaW1wbGlmeShwb2ludHMsIHRvbGVyYW5jZSkge1xuICAgIHBvaW50cyA9IHNpbXBsaWZ5UmFkaWFsRGlzdChwb2ludHMsIHRvbGVyYW5jZSk7XG4gICAgcG9pbnRzID0gc2ltcGxpZnlEb3VnbGFzUGV1Y2tlcihwb2ludHMsIHRvbGVyYW5jZSk7XG4gICAgcmV0dXJuIHBvaW50cztcbn1cblxubW9kdWxlLmV4cG9ydHMucmFkaWFsRGlzdGFuY2UgPSBzaW1wbGlmeVJhZGlhbERpc3Q7XG5tb2R1bGUuZXhwb3J0cy5kb3VnbGFzUGV1Y2tlciA9IHNpbXBsaWZ5RG91Z2xhc1BldWNrZXI7IiwiZnVuY3Rpb24gZ2V0U3FEaXN0KHAxLCBwMikge1xuICAgIHZhciBkeCA9IHAxWzBdIC0gcDJbMF0sXG4gICAgICAgIGR5ID0gcDFbMV0gLSBwMlsxXTtcblxuICAgIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcbn1cblxuLy8gYmFzaWMgZGlzdGFuY2UtYmFzZWQgc2ltcGxpZmljYXRpb25cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc2ltcGxpZnlSYWRpYWxEaXN0KHBvaW50cywgdG9sZXJhbmNlKSB7XG4gICAgaWYgKHBvaW50cy5sZW5ndGg8PTEpXG4gICAgICAgIHJldHVybiBwb2ludHM7XG4gICAgdG9sZXJhbmNlID0gdHlwZW9mIHRvbGVyYW5jZSA9PT0gJ251bWJlcicgPyB0b2xlcmFuY2UgOiAxO1xuICAgIHZhciBzcVRvbGVyYW5jZSA9IHRvbGVyYW5jZSAqIHRvbGVyYW5jZTtcbiAgICBcbiAgICB2YXIgcHJldlBvaW50ID0gcG9pbnRzWzBdLFxuICAgICAgICBuZXdQb2ludHMgPSBbcHJldlBvaW50XSxcbiAgICAgICAgcG9pbnQ7XG5cbiAgICBmb3IgKHZhciBpID0gMSwgbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHBvaW50ID0gcG9pbnRzW2ldO1xuXG4gICAgICAgIGlmIChnZXRTcURpc3QocG9pbnQsIHByZXZQb2ludCkgPiBzcVRvbGVyYW5jZSkge1xuICAgICAgICAgICAgbmV3UG9pbnRzLnB1c2gocG9pbnQpO1xuICAgICAgICAgICAgcHJldlBvaW50ID0gcG9pbnQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocHJldlBvaW50ICE9PSBwb2ludCkgbmV3UG9pbnRzLnB1c2gocG9pbnQpO1xuXG4gICAgcmV0dXJuIG5ld1BvaW50cztcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNtb290aHN0ZXAgKG1pbiwgbWF4LCB2YWx1ZSkge1xuICB2YXIgeCA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsICh2YWx1ZS1taW4pLyhtYXgtbWluKSkpO1xuICByZXR1cm4geCp4KigzIC0gMip4KTtcbn07XG4iLCJ2YXIgYmV6aWVyID0gcmVxdWlyZSgnYWRhcHRpdmUtYmV6aWVyLWN1cnZlJylcbnZhciBhYnMgPSByZXF1aXJlKCdhYnMtc3ZnLXBhdGgnKVxudmFyIG5vcm0gPSByZXF1aXJlKCdub3JtYWxpemUtc3ZnLXBhdGgnKVxudmFyIGNvcHkgPSByZXF1aXJlKCd2ZWMyLWNvcHknKVxuXG5mdW5jdGlvbiBzZXQob3V0LCB4LCB5KSB7XG4gICAgb3V0WzBdID0geFxuICAgIG91dFsxXSA9IHlcbiAgICByZXR1cm4gb3V0XG59XG5cbnZhciB0bXAxID0gWzAsMF0sXG4gICAgdG1wMiA9IFswLDBdLFxuICAgIHRtcDMgPSBbMCwwXVxuXG5mdW5jdGlvbiBiZXppZXJUbyhwb2ludHMsIHNjYWxlLCBzdGFydCwgc2VnKSB7XG4gICAgYmV6aWVyKHN0YXJ0LCBcbiAgICAgICAgc2V0KHRtcDEsIHNlZ1sxXSwgc2VnWzJdKSwgXG4gICAgICAgIHNldCh0bXAyLCBzZWdbM10sIHNlZ1s0XSksXG4gICAgICAgIHNldCh0bXAzLCBzZWdbNV0sIHNlZ1s2XSksIHNjYWxlLCBwb2ludHMpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY29udG91cnMoc3ZnLCBzY2FsZSkge1xuICAgIHZhciBwYXRocyA9IFtdXG5cbiAgICB2YXIgcG9pbnRzID0gW11cbiAgICB2YXIgcGVuID0gWzAsIDBdXG4gICAgbm9ybShhYnMoc3ZnKSkuZm9yRWFjaChmdW5jdGlvbihzZWdtZW50LCBpLCBzZWxmKSB7XG4gICAgICAgIGlmIChzZWdtZW50WzBdID09PSAnTScpIHtcbiAgICAgICAgICAgIGNvcHkocGVuLCBzZWdtZW50LnNsaWNlKDEpKVxuICAgICAgICAgICAgaWYgKHBvaW50cy5sZW5ndGg+MCkge1xuICAgICAgICAgICAgICAgIHBhdGhzLnB1c2gocG9pbnRzKVxuICAgICAgICAgICAgICAgIHBvaW50cyA9IFtdXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb2ludHMucHVzaChwZW4pXG4gICAgICAgIH0gZWxzZSBpZiAoc2VnbWVudFswXSA9PT0gJ0MnKSB7XG4gICAgICAgICAgICBiZXppZXJUbyhwb2ludHMsIHNjYWxlLCBwZW4sIHNlZ21lbnQpXG4gICAgICAgICAgICBzZXQocGVuLCBzZWdtZW50WzVdLCBzZWdtZW50WzZdKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbGxlZ2FsIHR5cGUgaW4gU1ZHOiAnK3NlZ21lbnRbMF0pXG4gICAgICAgIH1cbiAgICB9KVxuICAgIGlmIChwb2ludHMubGVuZ3RoPjApXG4gICAgICAgIHBhdGhzLnB1c2gocG9pbnRzKVxuICAgIHJldHVybiBwYXRoc1xufSIsIlxubW9kdWxlLmV4cG9ydHMgPSBhYnNvbHV0aXplXG5cbi8qKlxuICogcmVkZWZpbmUgYHBhdGhgIHdpdGggYWJzb2x1dGUgY29vcmRpbmF0ZXNcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBwYXRoXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuXG5mdW5jdGlvbiBhYnNvbHV0aXplKHBhdGgpe1xuXHR2YXIgc3RhcnRYID0gMFxuXHR2YXIgc3RhcnRZID0gMFxuXHR2YXIgeCA9IDBcblx0dmFyIHkgPSAwXG5cblx0cmV0dXJuIHBhdGgubWFwKGZ1bmN0aW9uKHNlZyl7XG5cdFx0c2VnID0gc2VnLnNsaWNlKClcblx0XHR2YXIgdHlwZSA9IHNlZ1swXVxuXHRcdHZhciBjb21tYW5kID0gdHlwZS50b1VwcGVyQ2FzZSgpXG5cblx0XHQvLyBpcyByZWxhdGl2ZVxuXHRcdGlmICh0eXBlICE9IGNvbW1hbmQpIHtcblx0XHRcdHNlZ1swXSA9IGNvbW1hbmRcblx0XHRcdHN3aXRjaCAodHlwZSkge1xuXHRcdFx0XHRjYXNlICdhJzpcblx0XHRcdFx0XHRzZWdbNl0gKz0geFxuXHRcdFx0XHRcdHNlZ1s3XSArPSB5XG5cdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0Y2FzZSAndic6XG5cdFx0XHRcdFx0c2VnWzFdICs9IHlcblx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHRjYXNlICdoJzpcblx0XHRcdFx0XHRzZWdbMV0gKz0geFxuXHRcdFx0XHRcdGJyZWFrXG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDE7IGkgPCBzZWcubGVuZ3RoOykge1xuXHRcdFx0XHRcdFx0c2VnW2krK10gKz0geFxuXHRcdFx0XHRcdFx0c2VnW2krK10gKz0geVxuXHRcdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyB1cGRhdGUgY3Vyc29yIHN0YXRlXG5cdFx0c3dpdGNoIChjb21tYW5kKSB7XG5cdFx0XHRjYXNlICdaJzpcblx0XHRcdFx0eCA9IHN0YXJ0WFxuXHRcdFx0XHR5ID0gc3RhcnRZXG5cdFx0XHRcdGJyZWFrXG5cdFx0XHRjYXNlICdIJzpcblx0XHRcdFx0eCA9IHNlZ1sxXVxuXHRcdFx0XHRicmVha1xuXHRcdFx0Y2FzZSAnVic6XG5cdFx0XHRcdHkgPSBzZWdbMV1cblx0XHRcdFx0YnJlYWtcblx0XHRcdGNhc2UgJ00nOlxuXHRcdFx0XHR4ID0gc3RhcnRYID0gc2VnWzFdXG5cdFx0XHRcdHkgPSBzdGFydFkgPSBzZWdbMl1cblx0XHRcdFx0YnJlYWtcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdHggPSBzZWdbc2VnLmxlbmd0aCAtIDJdXG5cdFx0XHRcdHkgPSBzZWdbc2VnLmxlbmd0aCAtIDFdXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHNlZ1xuXHR9KVxufVxuIiwiZnVuY3Rpb24gY2xvbmUocG9pbnQpIHsgLy9UT0RPOiB1c2UgZ2wtdmVjMiBmb3IgdGhpc1xuICAgIHJldHVybiBbcG9pbnRbMF0sIHBvaW50WzFdXVxufVxuXG5mdW5jdGlvbiB2ZWMyKHgsIHkpIHtcbiAgICByZXR1cm4gW3gsIHldXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY3JlYXRlQmV6aWVyQnVpbGRlcihvcHQpIHtcbiAgICBvcHQgPSBvcHR8fHt9XG5cbiAgICB2YXIgUkVDVVJTSU9OX0xJTUlUID0gdHlwZW9mIG9wdC5yZWN1cnNpb24gPT09ICdudW1iZXInID8gb3B0LnJlY3Vyc2lvbiA6IDhcbiAgICB2YXIgRkxUX0VQU0lMT04gPSB0eXBlb2Ygb3B0LmVwc2lsb24gPT09ICdudW1iZXInID8gb3B0LmVwc2lsb24gOiAxLjE5MjA5MjkwZS03XG4gICAgdmFyIFBBVEhfRElTVEFOQ0VfRVBTSUxPTiA9IHR5cGVvZiBvcHQucGF0aEVwc2lsb24gPT09ICdudW1iZXInID8gb3B0LnBhdGhFcHNpbG9uIDogMS4wXG5cbiAgICB2YXIgY3VydmVfYW5nbGVfdG9sZXJhbmNlX2Vwc2lsb24gPSB0eXBlb2Ygb3B0LmFuZ2xlRXBzaWxvbiA9PT0gJ251bWJlcicgPyBvcHQuYW5nbGVFcHNpbG9uIDogMC4wMVxuICAgIHZhciBtX2FuZ2xlX3RvbGVyYW5jZSA9IG9wdC5hbmdsZVRvbGVyYW5jZSB8fCAwXG4gICAgdmFyIG1fY3VzcF9saW1pdCA9IG9wdC5jdXNwTGltaXQgfHwgMFxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGJlemllckN1cnZlKHN0YXJ0LCBjMSwgYzIsIGVuZCwgc2NhbGUsIHBvaW50cykge1xuICAgICAgICBpZiAoIXBvaW50cylcbiAgICAgICAgICAgIHBvaW50cyA9IFtdXG5cbiAgICAgICAgc2NhbGUgPSB0eXBlb2Ygc2NhbGUgPT09ICdudW1iZXInID8gc2NhbGUgOiAxLjBcbiAgICAgICAgdmFyIGRpc3RhbmNlVG9sZXJhbmNlID0gUEFUSF9ESVNUQU5DRV9FUFNJTE9OIC8gc2NhbGVcbiAgICAgICAgZGlzdGFuY2VUb2xlcmFuY2UgKj0gZGlzdGFuY2VUb2xlcmFuY2VcbiAgICAgICAgYmVnaW4oc3RhcnQsIGMxLCBjMiwgZW5kLCBwb2ludHMsIGRpc3RhbmNlVG9sZXJhbmNlKVxuICAgICAgICByZXR1cm4gcG9pbnRzXG4gICAgfVxuXG5cbiAgICAvLy8vLy8gQmFzZWQgb246XG4gICAgLy8vLy8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wZWxzb24vYW50aWdyYWluL2Jsb2IvbWFzdGVyL2FnZy0yLjQvc3JjL2FnZ19jdXJ2ZXMuY3BwXG5cbiAgICBmdW5jdGlvbiBiZWdpbihzdGFydCwgYzEsIGMyLCBlbmQsIHBvaW50cywgZGlzdGFuY2VUb2xlcmFuY2UpIHtcbiAgICAgICAgcG9pbnRzLnB1c2goY2xvbmUoc3RhcnQpKVxuICAgICAgICB2YXIgeDEgPSBzdGFydFswXSxcbiAgICAgICAgICAgIHkxID0gc3RhcnRbMV0sXG4gICAgICAgICAgICB4MiA9IGMxWzBdLFxuICAgICAgICAgICAgeTIgPSBjMVsxXSxcbiAgICAgICAgICAgIHgzID0gYzJbMF0sXG4gICAgICAgICAgICB5MyA9IGMyWzFdLFxuICAgICAgICAgICAgeDQgPSBlbmRbMF0sXG4gICAgICAgICAgICB5NCA9IGVuZFsxXVxuICAgICAgICByZWN1cnNpdmUoeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgeDQsIHk0LCBwb2ludHMsIGRpc3RhbmNlVG9sZXJhbmNlLCAwKVxuICAgICAgICBwb2ludHMucHVzaChjbG9uZShlbmQpKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlY3Vyc2l2ZSh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCB4NCwgeTQsIHBvaW50cywgZGlzdGFuY2VUb2xlcmFuY2UsIGxldmVsKSB7XG4gICAgICAgIGlmKGxldmVsID4gUkVDVVJTSU9OX0xJTUlUKSBcbiAgICAgICAgICAgIHJldHVyblxuXG4gICAgICAgIHZhciBwaSA9IE1hdGguUElcblxuICAgICAgICAvLyBDYWxjdWxhdGUgYWxsIHRoZSBtaWQtcG9pbnRzIG9mIHRoZSBsaW5lIHNlZ21lbnRzXG4gICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICB2YXIgeDEyICAgPSAoeDEgKyB4MikgLyAyXG4gICAgICAgIHZhciB5MTIgICA9ICh5MSArIHkyKSAvIDJcbiAgICAgICAgdmFyIHgyMyAgID0gKHgyICsgeDMpIC8gMlxuICAgICAgICB2YXIgeTIzICAgPSAoeTIgKyB5MykgLyAyXG4gICAgICAgIHZhciB4MzQgICA9ICh4MyArIHg0KSAvIDJcbiAgICAgICAgdmFyIHkzNCAgID0gKHkzICsgeTQpIC8gMlxuICAgICAgICB2YXIgeDEyMyAgPSAoeDEyICsgeDIzKSAvIDJcbiAgICAgICAgdmFyIHkxMjMgID0gKHkxMiArIHkyMykgLyAyXG4gICAgICAgIHZhciB4MjM0ICA9ICh4MjMgKyB4MzQpIC8gMlxuICAgICAgICB2YXIgeTIzNCAgPSAoeTIzICsgeTM0KSAvIDJcbiAgICAgICAgdmFyIHgxMjM0ID0gKHgxMjMgKyB4MjM0KSAvIDJcbiAgICAgICAgdmFyIHkxMjM0ID0gKHkxMjMgKyB5MjM0KSAvIDJcblxuICAgICAgICBpZihsZXZlbCA+IDApIHsgLy8gRW5mb3JjZSBzdWJkaXZpc2lvbiBmaXJzdCB0aW1lXG4gICAgICAgICAgICAvLyBUcnkgdG8gYXBwcm94aW1hdGUgdGhlIGZ1bGwgY3ViaWMgY3VydmUgYnkgYSBzaW5nbGUgc3RyYWlnaHQgbGluZVxuICAgICAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgIHZhciBkeCA9IHg0LXgxXG4gICAgICAgICAgICB2YXIgZHkgPSB5NC15MVxuXG4gICAgICAgICAgICB2YXIgZDIgPSBNYXRoLmFicygoeDIgLSB4NCkgKiBkeSAtICh5MiAtIHk0KSAqIGR4KVxuICAgICAgICAgICAgdmFyIGQzID0gTWF0aC5hYnMoKHgzIC0geDQpICogZHkgLSAoeTMgLSB5NCkgKiBkeClcblxuICAgICAgICAgICAgdmFyIGRhMSwgZGEyXG5cbiAgICAgICAgICAgIGlmKGQyID4gRkxUX0VQU0lMT04gJiYgZDMgPiBGTFRfRVBTSUxPTikge1xuICAgICAgICAgICAgICAgIC8vIFJlZ3VsYXIgY2FyZVxuICAgICAgICAgICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgICAgICBpZigoZDIgKyBkMykqKGQyICsgZDMpIDw9IGRpc3RhbmNlVG9sZXJhbmNlICogKGR4KmR4ICsgZHkqZHkpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBjdXJ2YXR1cmUgZG9lc24ndCBleGNlZWQgdGhlIGRpc3RhbmNlVG9sZXJhbmNlIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIHRlbmQgdG8gZmluaXNoIHN1YmRpdmlzaW9ucy5cbiAgICAgICAgICAgICAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgICAgICAgICAgICAgIGlmKG1fYW5nbGVfdG9sZXJhbmNlIDwgY3VydmVfYW5nbGVfdG9sZXJhbmNlX2Vwc2lsb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKHZlYzIoeDEyMzQsIHkxMjM0KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQW5nbGUgJiBDdXNwIENvbmRpdGlvblxuICAgICAgICAgICAgICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGEyMyA9IE1hdGguYXRhbjIoeTMgLSB5MiwgeDMgLSB4MilcbiAgICAgICAgICAgICAgICAgICAgZGExID0gTWF0aC5hYnMoYTIzIC0gTWF0aC5hdGFuMih5MiAtIHkxLCB4MiAtIHgxKSlcbiAgICAgICAgICAgICAgICAgICAgZGEyID0gTWF0aC5hYnMoTWF0aC5hdGFuMih5NCAtIHkzLCB4NCAtIHgzKSAtIGEyMylcbiAgICAgICAgICAgICAgICAgICAgaWYoZGExID49IHBpKSBkYTEgPSAyKnBpIC0gZGExXG4gICAgICAgICAgICAgICAgICAgIGlmKGRhMiA+PSBwaSkgZGEyID0gMipwaSAtIGRhMlxuXG4gICAgICAgICAgICAgICAgICAgIGlmKGRhMSArIGRhMiA8IG1fYW5nbGVfdG9sZXJhbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGaW5hbGx5IHdlIGNhbiBzdG9wIHRoZSByZWN1cnNpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2godmVjMih4MTIzNCwgeTEyMzQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZihtX2N1c3BfbGltaXQgIT09IDAuMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYoZGExID4gbV9jdXNwX2xpbWl0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2godmVjMih4MiwgeTIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihkYTIgPiBtX2N1c3BfbGltaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaCh2ZWMyKHgzLCB5MykpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZihkMiA+IEZMVF9FUFNJTE9OKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHAxLHAzLHA0IGFyZSBjb2xsaW5lYXIsIHAyIGlzIGNvbnNpZGVyYWJsZVxuICAgICAgICAgICAgICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgICAgICAgICAgaWYoZDIgKiBkMiA8PSBkaXN0YW5jZVRvbGVyYW5jZSAqIChkeCpkeCArIGR5KmR5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYobV9hbmdsZV90b2xlcmFuY2UgPCBjdXJ2ZV9hbmdsZV90b2xlcmFuY2VfZXBzaWxvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKHZlYzIoeDEyMzQsIHkxMjM0KSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQW5nbGUgQ29uZGl0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgICAgICAgICAgICAgIGRhMSA9IE1hdGguYWJzKE1hdGguYXRhbjIoeTMgLSB5MiwgeDMgLSB4MikgLSBNYXRoLmF0YW4yKHkyIC0geTEsIHgyIC0geDEpKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoZGExID49IHBpKSBkYTEgPSAyKnBpIC0gZGExXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGRhMSA8IG1fYW5nbGVfdG9sZXJhbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2godmVjMih4MiwgeTIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKHZlYzIoeDMsIHkzKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYobV9jdXNwX2xpbWl0ICE9PSAwLjApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihkYTEgPiBtX2N1c3BfbGltaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2godmVjMih4MiwgeTIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZihkMyA+IEZMVF9FUFNJTE9OKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHAxLHAyLHA0IGFyZSBjb2xsaW5lYXIsIHAzIGlzIGNvbnNpZGVyYWJsZVxuICAgICAgICAgICAgICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgICAgICAgICAgaWYoZDMgKiBkMyA8PSBkaXN0YW5jZVRvbGVyYW5jZSAqIChkeCpkeCArIGR5KmR5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYobV9hbmdsZV90b2xlcmFuY2UgPCBjdXJ2ZV9hbmdsZV90b2xlcmFuY2VfZXBzaWxvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKHZlYzIoeDEyMzQsIHkxMjM0KSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQW5nbGUgQ29uZGl0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgICAgICAgICAgICAgIGRhMSA9IE1hdGguYWJzKE1hdGguYXRhbjIoeTQgLSB5MywgeDQgLSB4MykgLSBNYXRoLmF0YW4yKHkzIC0geTIsIHgzIC0geDIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoZGExID49IHBpKSBkYTEgPSAyKnBpIC0gZGExXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGRhMSA8IG1fYW5nbGVfdG9sZXJhbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2godmVjMih4MiwgeTIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKHZlYzIoeDMsIHkzKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYobV9jdXNwX2xpbWl0ICE9PSAwLjApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihkYTEgPiBtX2N1c3BfbGltaXQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaCh2ZWMyKHgzLCB5MykpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ29sbGluZWFyIGNhc2VcbiAgICAgICAgICAgICAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgICAgICAgICBkeCA9IHgxMjM0IC0gKHgxICsgeDQpIC8gMlxuICAgICAgICAgICAgICAgICAgICBkeSA9IHkxMjM0IC0gKHkxICsgeTQpIC8gMlxuICAgICAgICAgICAgICAgICAgICBpZihkeCpkeCArIGR5KmR5IDw9IGRpc3RhbmNlVG9sZXJhbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaCh2ZWMyKHgxMjM0LCB5MTIzNCkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENvbnRpbnVlIHN1YmRpdmlzaW9uXG4gICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICByZWN1cnNpdmUoeDEsIHkxLCB4MTIsIHkxMiwgeDEyMywgeTEyMywgeDEyMzQsIHkxMjM0LCBwb2ludHMsIGRpc3RhbmNlVG9sZXJhbmNlLCBsZXZlbCArIDEpIFxuICAgICAgICByZWN1cnNpdmUoeDEyMzQsIHkxMjM0LCB4MjM0LCB5MjM0LCB4MzQsIHkzNCwgeDQsIHk0LCBwb2ludHMsIGRpc3RhbmNlVG9sZXJhbmNlLCBsZXZlbCArIDEpIFxuICAgIH1cbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9mdW5jdGlvbicpKCkiLCJcbnZhciDPgCA9IE1hdGguUElcbnZhciBfMTIwID0gcmFkaWFucygxMjApXG5cbm1vZHVsZS5leHBvcnRzID0gbm9ybWFsaXplXG5cbi8qKlxuICogZGVzY3JpYmUgYHBhdGhgIGluIHRlcm1zIG9mIGN1YmljIGLDqXppZXIgXG4gKiBjdXJ2ZXMgYW5kIG1vdmUgY29tbWFuZHNcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBwYXRoXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuXG5mdW5jdGlvbiBub3JtYWxpemUocGF0aCl7XG5cdC8vIGluaXQgc3RhdGVcblx0dmFyIHByZXZcblx0dmFyIHJlc3VsdCA9IFtdXG5cdHZhciBiZXppZXJYID0gMFxuXHR2YXIgYmV6aWVyWSA9IDBcblx0dmFyIHN0YXJ0WCA9IDBcblx0dmFyIHN0YXJ0WSA9IDBcblx0dmFyIHF1YWRYID0gbnVsbFxuXHR2YXIgcXVhZFkgPSBudWxsXG5cdHZhciB4ID0gMFxuXHR2YXIgeSA9IDBcblxuXHRmb3IgKHZhciBpID0gMCwgbGVuID0gcGF0aC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdHZhciBzZWcgPSBwYXRoW2ldXG5cdFx0dmFyIGNvbW1hbmQgPSBzZWdbMF1cblx0XHRzd2l0Y2ggKGNvbW1hbmQpIHtcblx0XHRcdGNhc2UgJ00nOlxuXHRcdFx0XHRzdGFydFggPSBzZWdbMV1cblx0XHRcdFx0c3RhcnRZID0gc2VnWzJdXG5cdFx0XHRcdGJyZWFrXG5cdFx0XHRjYXNlICdBJzpcblx0XHRcdFx0c2VnID0gYXJjKHgsIHksc2VnWzFdLHNlZ1syXSxyYWRpYW5zKHNlZ1szXSksc2VnWzRdLHNlZ1s1XSxzZWdbNl0sc2VnWzddKVxuXHRcdFx0XHQvLyBzcGxpdCBtdWx0aSBwYXJ0XG5cdFx0XHRcdHNlZy51bnNoaWZ0KCdDJylcblx0XHRcdFx0aWYgKHNlZy5sZW5ndGggPiA3KSB7XG5cdFx0XHRcdFx0cmVzdWx0LnB1c2goc2VnLnNwbGljZSgwLCA3KSlcblx0XHRcdFx0XHRzZWcudW5zaGlmdCgnQycpXG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWtcblx0XHRcdGNhc2UgJ1MnOlxuXHRcdFx0XHQvLyBkZWZhdWx0IGNvbnRyb2wgcG9pbnRcblx0XHRcdFx0dmFyIGN4ID0geFxuXHRcdFx0XHR2YXIgY3kgPSB5XG5cdFx0XHRcdGlmIChwcmV2ID09ICdDJyB8fCBwcmV2ID09ICdTJykge1xuXHRcdFx0XHRcdGN4ICs9IGN4IC0gYmV6aWVyWCAvLyByZWZsZWN0IHRoZSBwcmV2aW91cyBjb21tYW5kJ3MgY29udHJvbFxuXHRcdFx0XHRcdGN5ICs9IGN5IC0gYmV6aWVyWSAvLyBwb2ludCByZWxhdGl2ZSB0byB0aGUgY3VycmVudCBwb2ludFxuXHRcdFx0XHR9XG5cdFx0XHRcdHNlZyA9IFsnQycsIGN4LCBjeSwgc2VnWzFdLCBzZWdbMl0sIHNlZ1szXSwgc2VnWzRdXVxuXHRcdFx0XHRicmVha1xuXHRcdFx0Y2FzZSAnVCc6XG5cdFx0XHRcdGlmIChwcmV2ID09ICdRJyB8fCBwcmV2ID09ICdUJykge1xuXHRcdFx0XHRcdHF1YWRYID0geCAqIDIgLSBxdWFkWCAvLyBhcyB3aXRoICdTJyByZWZsZWN0IHByZXZpb3VzIGNvbnRyb2wgcG9pbnRcblx0XHRcdFx0XHRxdWFkWSA9IHkgKiAyIC0gcXVhZFlcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRxdWFkWCA9IHhcblx0XHRcdFx0XHRxdWFkWSA9IHlcblx0XHRcdFx0fVxuXHRcdFx0XHRzZWcgPSBxdWFkcmF0aWMoeCwgeSwgcXVhZFgsIHF1YWRZLCBzZWdbMV0sIHNlZ1syXSlcblx0XHRcdFx0YnJlYWtcblx0XHRcdGNhc2UgJ1EnOlxuXHRcdFx0XHRxdWFkWCA9IHNlZ1sxXVxuXHRcdFx0XHRxdWFkWSA9IHNlZ1syXVxuXHRcdFx0XHRzZWcgPSBxdWFkcmF0aWMoeCwgeSwgc2VnWzFdLCBzZWdbMl0sIHNlZ1szXSwgc2VnWzRdKVxuXHRcdFx0XHRicmVha1xuXHRcdFx0Y2FzZSAnTCc6XG5cdFx0XHRcdHNlZyA9IGxpbmUoeCwgeSwgc2VnWzFdLCBzZWdbMl0pXG5cdFx0XHRcdGJyZWFrXG5cdFx0XHRjYXNlICdIJzpcblx0XHRcdFx0c2VnID0gbGluZSh4LCB5LCBzZWdbMV0sIHkpXG5cdFx0XHRcdGJyZWFrXG5cdFx0XHRjYXNlICdWJzpcblx0XHRcdFx0c2VnID0gbGluZSh4LCB5LCB4LCBzZWdbMV0pXG5cdFx0XHRcdGJyZWFrXG5cdFx0XHRjYXNlICdaJzpcblx0XHRcdFx0c2VnID0gbGluZSh4LCB5LCBzdGFydFgsIHN0YXJ0WSlcblx0XHRcdFx0YnJlYWtcblx0XHR9XG5cblx0XHQvLyB1cGRhdGUgc3RhdGVcblx0XHRwcmV2ID0gY29tbWFuZFxuXHRcdHggPSBzZWdbc2VnLmxlbmd0aCAtIDJdXG5cdFx0eSA9IHNlZ1tzZWcubGVuZ3RoIC0gMV1cblx0XHRpZiAoc2VnLmxlbmd0aCA+IDQpIHtcblx0XHRcdGJlemllclggPSBzZWdbc2VnLmxlbmd0aCAtIDRdXG5cdFx0XHRiZXppZXJZID0gc2VnW3NlZy5sZW5ndGggLSAzXVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRiZXppZXJYID0geFxuXHRcdFx0YmV6aWVyWSA9IHlcblx0XHR9XG5cdFx0cmVzdWx0LnB1c2goc2VnKVxuXHR9XG5cblx0cmV0dXJuIHJlc3VsdFxufVxuXG5mdW5jdGlvbiBsaW5lKHgxLCB5MSwgeDIsIHkyKXtcblx0cmV0dXJuIFsnQycsIHgxLCB5MSwgeDIsIHkyLCB4MiwgeTJdXG59XG5cbmZ1bmN0aW9uIHF1YWRyYXRpYyh4MSwgeTEsIGN4LCBjeSwgeDIsIHkyKXtcblx0cmV0dXJuIFtcblx0XHQnQycsXG5cdFx0eDEvMyArICgyLzMpICogY3gsXG5cdFx0eTEvMyArICgyLzMpICogY3ksXG5cdFx0eDIvMyArICgyLzMpICogY3gsXG5cdFx0eTIvMyArICgyLzMpICogY3ksXG5cdFx0eDIsXG5cdFx0eTJcblx0XVxufVxuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIHJpcHBlZCBmcm9tIFxuLy8gZ2l0aHViLmNvbS9EbWl0cnlCYXJhbm92c2tpeS9yYXBoYWVsL2Jsb2IvNGQ5N2Q0L3JhcGhhZWwuanMjTDIyMTYtTDIzMDQgXG4vLyB3aGljaCByZWZlcmVuY2VzIHczLm9yZy9UUi9TVkcxMS9pbXBsbm90ZS5odG1sI0FyY0ltcGxlbWVudGF0aW9uTm90ZXNcbi8vIFRPRE86IG1ha2UgaXQgaHVtYW4gcmVhZGFibGVcblxuZnVuY3Rpb24gYXJjKHgxLCB5MSwgcngsIHJ5LCBhbmdsZSwgbGFyZ2VfYXJjX2ZsYWcsIHN3ZWVwX2ZsYWcsIHgyLCB5MiwgcmVjdXJzaXZlKSB7XG5cdGlmICghcmVjdXJzaXZlKSB7XG5cdFx0dmFyIHh5ID0gcm90YXRlKHgxLCB5MSwgLWFuZ2xlKVxuXHRcdHgxID0geHkueFxuXHRcdHkxID0geHkueVxuXHRcdHh5ID0gcm90YXRlKHgyLCB5MiwgLWFuZ2xlKVxuXHRcdHgyID0geHkueFxuXHRcdHkyID0geHkueVxuXHRcdHZhciB4ID0gKHgxIC0geDIpIC8gMlxuXHRcdHZhciB5ID0gKHkxIC0geTIpIC8gMlxuXHRcdHZhciBoID0gKHggKiB4KSAvIChyeCAqIHJ4KSArICh5ICogeSkgLyAocnkgKiByeSlcblx0XHRpZiAoaCA+IDEpIHtcblx0XHRcdGggPSBNYXRoLnNxcnQoaClcblx0XHRcdHJ4ID0gaCAqIHJ4XG5cdFx0XHRyeSA9IGggKiByeVxuXHRcdH1cblx0XHR2YXIgcngyID0gcnggKiByeFxuXHRcdHZhciByeTIgPSByeSAqIHJ5XG5cdFx0dmFyIGsgPSAobGFyZ2VfYXJjX2ZsYWcgPT0gc3dlZXBfZmxhZyA/IC0xIDogMSlcblx0XHRcdCogTWF0aC5zcXJ0KE1hdGguYWJzKChyeDIgKiByeTIgLSByeDIgKiB5ICogeSAtIHJ5MiAqIHggKiB4KSAvIChyeDIgKiB5ICogeSArIHJ5MiAqIHggKiB4KSkpXG5cdFx0aWYgKGsgPT0gSW5maW5pdHkpIGsgPSAxIC8vIG5ldXRyYWxpemVcblx0XHR2YXIgY3ggPSBrICogcnggKiB5IC8gcnkgKyAoeDEgKyB4MikgLyAyXG5cdFx0dmFyIGN5ID0gayAqIC1yeSAqIHggLyByeCArICh5MSArIHkyKSAvIDJcblx0XHR2YXIgZjEgPSBNYXRoLmFzaW4oKCh5MSAtIGN5KSAvIHJ5KS50b0ZpeGVkKDkpKVxuXHRcdHZhciBmMiA9IE1hdGguYXNpbigoKHkyIC0gY3kpIC8gcnkpLnRvRml4ZWQoOSkpXG5cblx0XHRmMSA9IHgxIDwgY3ggPyDPgCAtIGYxIDogZjFcblx0XHRmMiA9IHgyIDwgY3ggPyDPgCAtIGYyIDogZjJcblx0XHRpZiAoZjEgPCAwKSBmMSA9IM+AICogMiArIGYxXG5cdFx0aWYgKGYyIDwgMCkgZjIgPSDPgCAqIDIgKyBmMlxuXHRcdGlmIChzd2VlcF9mbGFnICYmIGYxID4gZjIpIGYxID0gZjEgLSDPgCAqIDJcblx0XHRpZiAoIXN3ZWVwX2ZsYWcgJiYgZjIgPiBmMSkgZjIgPSBmMiAtIM+AICogMlxuXHR9IGVsc2Uge1xuXHRcdGYxID0gcmVjdXJzaXZlWzBdXG5cdFx0ZjIgPSByZWN1cnNpdmVbMV1cblx0XHRjeCA9IHJlY3Vyc2l2ZVsyXVxuXHRcdGN5ID0gcmVjdXJzaXZlWzNdXG5cdH1cblx0Ly8gZ3JlYXRlciB0aGFuIDEyMCBkZWdyZWVzIHJlcXVpcmVzIG11bHRpcGxlIHNlZ21lbnRzXG5cdGlmIChNYXRoLmFicyhmMiAtIGYxKSA+IF8xMjApIHtcblx0XHR2YXIgZjJvbGQgPSBmMlxuXHRcdHZhciB4Mm9sZCA9IHgyXG5cdFx0dmFyIHkyb2xkID0geTJcblx0XHRmMiA9IGYxICsgXzEyMCAqIChzd2VlcF9mbGFnICYmIGYyID4gZjEgPyAxIDogLTEpXG5cdFx0eDIgPSBjeCArIHJ4ICogTWF0aC5jb3MoZjIpXG5cdFx0eTIgPSBjeSArIHJ5ICogTWF0aC5zaW4oZjIpXG5cdFx0dmFyIHJlcyA9IGFyYyh4MiwgeTIsIHJ4LCByeSwgYW5nbGUsIDAsIHN3ZWVwX2ZsYWcsIHgyb2xkLCB5Mm9sZCwgW2YyLCBmMm9sZCwgY3gsIGN5XSlcblx0fVxuXHR2YXIgdCA9IE1hdGgudGFuKChmMiAtIGYxKSAvIDQpXG5cdHZhciBoeCA9IDQgLyAzICogcnggKiB0XG5cdHZhciBoeSA9IDQgLyAzICogcnkgKiB0XG5cdHZhciBjdXJ2ZSA9IFtcblx0XHQyICogeDEgLSAoeDEgKyBoeCAqIE1hdGguc2luKGYxKSksXG5cdFx0MiAqIHkxIC0gKHkxIC0gaHkgKiBNYXRoLmNvcyhmMSkpLFxuXHRcdHgyICsgaHggKiBNYXRoLnNpbihmMiksXG5cdFx0eTIgLSBoeSAqIE1hdGguY29zKGYyKSxcblx0XHR4Mixcblx0XHR5MlxuXHRdXG5cdGlmIChyZWN1cnNpdmUpIHJldHVybiBjdXJ2ZVxuXHRpZiAocmVzKSBjdXJ2ZSA9IGN1cnZlLmNvbmNhdChyZXMpXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgY3VydmUubGVuZ3RoOykge1xuXHRcdHZhciByb3QgPSByb3RhdGUoY3VydmVbaV0sIGN1cnZlW2krMV0sIGFuZ2xlKVxuXHRcdGN1cnZlW2krK10gPSByb3QueFxuXHRcdGN1cnZlW2krK10gPSByb3QueVxuXHR9XG5cdHJldHVybiBjdXJ2ZVxufVxuXG5mdW5jdGlvbiByb3RhdGUoeCwgeSwgcmFkKXtcblx0cmV0dXJuIHtcblx0XHR4OiB4ICogTWF0aC5jb3MocmFkKSAtIHkgKiBNYXRoLnNpbihyYWQpLFxuXHRcdHk6IHggKiBNYXRoLnNpbihyYWQpICsgeSAqIE1hdGguY29zKHJhZClcblx0fVxufVxuXG5mdW5jdGlvbiByYWRpYW5zKGRlZ3Jlc3Mpe1xuXHRyZXR1cm4gZGVncmVzcyAqICjPgCAvIDE4MClcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdmVjMkNvcHkob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gYVswXVxuICAgIG91dFsxXSA9IGFbMV1cbiAgICByZXR1cm4gb3V0XG59IiwiLyoqXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oVEhSRUUpIHtcbiAgdmFyIENvcHlTaGFkZXIgPSBFZmZlY3RDb21wb3Nlci5Db3B5U2hhZGVyID0gcmVxdWlyZSgndGhyZWUtY29weXNoYWRlcicpXG4gICAgLCBSZW5kZXJQYXNzID0gRWZmZWN0Q29tcG9zZXIuUmVuZGVyUGFzcyA9IHJlcXVpcmUoJy4vbGliL3JlbmRlcnBhc3MnKShUSFJFRSlcbiAgICAsIFNoYWRlclBhc3MgPSBFZmZlY3RDb21wb3Nlci5TaGFkZXJQYXNzID0gcmVxdWlyZSgnLi9saWIvc2hhZGVycGFzcycpKFRIUkVFLCBFZmZlY3RDb21wb3NlcilcbiAgICAsIE1hc2tQYXNzID0gRWZmZWN0Q29tcG9zZXIuTWFza1Bhc3MgPSByZXF1aXJlKCcuL2xpYi9tYXNrcGFzcycpKFRIUkVFKVxuICAgICwgQ2xlYXJNYXNrUGFzcyA9IEVmZmVjdENvbXBvc2VyLkNsZWFyTWFza1Bhc3MgPSByZXF1aXJlKCcuL2xpYi9jbGVhcm1hc2twYXNzJykoVEhSRUUpXG5cbiAgZnVuY3Rpb24gRWZmZWN0Q29tcG9zZXIoIHJlbmRlcmVyLCByZW5kZXJUYXJnZXQgKSB7XG4gICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuXG4gICAgaWYgKCByZW5kZXJUYXJnZXQgPT09IHVuZGVmaW5lZCApIHtcbiAgICAgIHZhciB3aWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoIHx8IDE7XG4gICAgICB2YXIgaGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0IHx8IDE7XG4gICAgICB2YXIgcGFyYW1ldGVycyA9IHsgbWluRmlsdGVyOiBUSFJFRS5MaW5lYXJGaWx0ZXIsIG1hZ0ZpbHRlcjogVEhSRUUuTGluZWFyRmlsdGVyLCBmb3JtYXQ6IFRIUkVFLlJHQkZvcm1hdCwgc3RlbmNpbEJ1ZmZlcjogZmFsc2UgfTtcblxuICAgICAgcmVuZGVyVGFyZ2V0ID0gbmV3IFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0KCB3aWR0aCwgaGVpZ2h0LCBwYXJhbWV0ZXJzICk7XG4gICAgfVxuXG4gICAgdGhpcy5yZW5kZXJUYXJnZXQxID0gcmVuZGVyVGFyZ2V0O1xuICAgIHRoaXMucmVuZGVyVGFyZ2V0MiA9IHJlbmRlclRhcmdldC5jbG9uZSgpO1xuXG4gICAgdGhpcy53cml0ZUJ1ZmZlciA9IHRoaXMucmVuZGVyVGFyZ2V0MTtcbiAgICB0aGlzLnJlYWRCdWZmZXIgPSB0aGlzLnJlbmRlclRhcmdldDI7XG5cbiAgICB0aGlzLnBhc3NlcyA9IFtdO1xuXG4gICAgdGhpcy5jb3B5UGFzcyA9IG5ldyBTaGFkZXJQYXNzKCBDb3B5U2hhZGVyICk7XG4gIH07XG5cbiAgRWZmZWN0Q29tcG9zZXIucHJvdG90eXBlID0ge1xuICAgIHN3YXBCdWZmZXJzOiBmdW5jdGlvbigpIHtcblxuICAgICAgdmFyIHRtcCA9IHRoaXMucmVhZEJ1ZmZlcjtcbiAgICAgIHRoaXMucmVhZEJ1ZmZlciA9IHRoaXMud3JpdGVCdWZmZXI7XG4gICAgICB0aGlzLndyaXRlQnVmZmVyID0gdG1wO1xuXG4gICAgfSxcblxuICAgIGFkZFBhc3M6IGZ1bmN0aW9uICggcGFzcyApIHtcblxuICAgICAgdGhpcy5wYXNzZXMucHVzaCggcGFzcyApO1xuXG4gICAgfSxcblxuICAgIGluc2VydFBhc3M6IGZ1bmN0aW9uICggcGFzcywgaW5kZXggKSB7XG5cbiAgICAgIHRoaXMucGFzc2VzLnNwbGljZSggaW5kZXgsIDAsIHBhc3MgKTtcblxuICAgIH0sXG5cbiAgICByZW5kZXI6IGZ1bmN0aW9uICggZGVsdGEgKSB7XG5cbiAgICAgIHRoaXMud3JpdGVCdWZmZXIgPSB0aGlzLnJlbmRlclRhcmdldDE7XG4gICAgICB0aGlzLnJlYWRCdWZmZXIgPSB0aGlzLnJlbmRlclRhcmdldDI7XG5cbiAgICAgIHZhciBtYXNrQWN0aXZlID0gZmFsc2U7XG5cbiAgICAgIHZhciBwYXNzLCBpLCBpbCA9IHRoaXMucGFzc2VzLmxlbmd0aDtcblxuICAgICAgZm9yICggaSA9IDA7IGkgPCBpbDsgaSArKyApIHtcblxuICAgICAgICBwYXNzID0gdGhpcy5wYXNzZXNbIGkgXTtcblxuICAgICAgICBpZiAoICFwYXNzLmVuYWJsZWQgKSBjb250aW51ZTtcblxuICAgICAgICBwYXNzLnJlbmRlciggdGhpcy5yZW5kZXJlciwgdGhpcy53cml0ZUJ1ZmZlciwgdGhpcy5yZWFkQnVmZmVyLCBkZWx0YSwgbWFza0FjdGl2ZSApO1xuXG4gICAgICAgIGlmICggcGFzcy5uZWVkc1N3YXAgKSB7XG5cbiAgICAgICAgICBpZiAoIG1hc2tBY3RpdmUgKSB7XG5cbiAgICAgICAgICAgIHZhciBjb250ZXh0ID0gdGhpcy5yZW5kZXJlci5jb250ZXh0O1xuXG4gICAgICAgICAgICBjb250ZXh0LnN0ZW5jaWxGdW5jKCBjb250ZXh0Lk5PVEVRVUFMLCAxLCAweGZmZmZmZmZmICk7XG5cbiAgICAgICAgICAgIHRoaXMuY29weVBhc3MucmVuZGVyKCB0aGlzLnJlbmRlcmVyLCB0aGlzLndyaXRlQnVmZmVyLCB0aGlzLnJlYWRCdWZmZXIsIGRlbHRhICk7XG5cbiAgICAgICAgICAgIGNvbnRleHQuc3RlbmNpbEZ1bmMoIGNvbnRleHQuRVFVQUwsIDEsIDB4ZmZmZmZmZmYgKTtcblxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuc3dhcEJ1ZmZlcnMoKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBwYXNzIGluc3RhbmNlb2YgTWFza1Bhc3MgKSB7XG5cbiAgICAgICAgICBtYXNrQWN0aXZlID0gdHJ1ZTtcblxuICAgICAgICB9IGVsc2UgaWYgKCBwYXNzIGluc3RhbmNlb2YgQ2xlYXJNYXNrUGFzcyApIHtcblxuICAgICAgICAgIG1hc2tBY3RpdmUgPSBmYWxzZTtcblxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgIH0sXG5cbiAgICByZXNldDogZnVuY3Rpb24gKCByZW5kZXJUYXJnZXQgKSB7XG5cbiAgICAgIGlmICggcmVuZGVyVGFyZ2V0ID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgcmVuZGVyVGFyZ2V0ID0gdGhpcy5yZW5kZXJUYXJnZXQxLmNsb25lKCk7XG5cbiAgICAgICAgcmVuZGVyVGFyZ2V0LndpZHRoID0gd2luZG93LmlubmVyV2lkdGg7XG4gICAgICAgIHJlbmRlclRhcmdldC5oZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG5cbiAgICAgIH1cblxuICAgICAgdGhpcy5yZW5kZXJUYXJnZXQxID0gcmVuZGVyVGFyZ2V0O1xuICAgICAgdGhpcy5yZW5kZXJUYXJnZXQyID0gcmVuZGVyVGFyZ2V0LmNsb25lKCk7XG5cbiAgICAgIHRoaXMud3JpdGVCdWZmZXIgPSB0aGlzLnJlbmRlclRhcmdldDE7XG4gICAgICB0aGlzLnJlYWRCdWZmZXIgPSB0aGlzLnJlbmRlclRhcmdldDI7XG5cbiAgICB9LFxuXG4gICAgc2V0U2l6ZTogZnVuY3Rpb24gKCB3aWR0aCwgaGVpZ2h0ICkge1xuXG4gICAgICB2YXIgcmVuZGVyVGFyZ2V0ID0gdGhpcy5yZW5kZXJUYXJnZXQxLmNsb25lKCk7XG5cbiAgICAgIHJlbmRlclRhcmdldC53aWR0aCA9IHdpZHRoO1xuICAgICAgcmVuZGVyVGFyZ2V0LmhlaWdodCA9IGhlaWdodDtcblxuICAgICAgdGhpcy5yZXNldCggcmVuZGVyVGFyZ2V0ICk7XG5cbiAgICB9XG5cbiAgfTtcblxuICAvLyBzaGFyZWQgb3J0aG8gY2FtZXJhXG5cbiAgRWZmZWN0Q29tcG9zZXIuY2FtZXJhID0gbmV3IFRIUkVFLk9ydGhvZ3JhcGhpY0NhbWVyYSggLTEsIDEsIDEsIC0xLCAwLCAxICk7XG5cbiAgRWZmZWN0Q29tcG9zZXIucXVhZCA9IG5ldyBUSFJFRS5NZXNoKCBuZXcgVEhSRUUuUGxhbmVHZW9tZXRyeSggMiwgMiApLCBudWxsICk7XG5cbiAgRWZmZWN0Q29tcG9zZXIuc2NlbmUgPSBuZXcgVEhSRUUuU2NlbmUoKTtcbiAgRWZmZWN0Q29tcG9zZXIuc2NlbmUuYWRkKCBFZmZlY3RDb21wb3Nlci5xdWFkICk7XG5cbiAgcmV0dXJuIEVmZmVjdENvbXBvc2VyXG59OyIsIi8qKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFRIUkVFKSB7XG4gIGZ1bmN0aW9uIENsZWFyTWFza1Bhc3MoKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIENsZWFyTWFza1Bhc3MpKSByZXR1cm4gbmV3IENsZWFyTWFza1Bhc3Moc2NlbmUsIGNhbWVyYSk7XG4gICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcbiAgfTtcblxuICBDbGVhck1hc2tQYXNzLnByb3RvdHlwZSA9IHtcbiAgICByZW5kZXI6IGZ1bmN0aW9uICggcmVuZGVyZXIsIHdyaXRlQnVmZmVyLCByZWFkQnVmZmVyLCBkZWx0YSApIHtcbiAgICAgIHZhciBjb250ZXh0ID0gcmVuZGVyZXIuY29udGV4dDtcbiAgICAgIGNvbnRleHQuZGlzYWJsZSggY29udGV4dC5TVEVOQ0lMX1RFU1QgKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIENsZWFyTWFza1Bhc3Ncbn07IiwiLyoqXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oVEhSRUUpIHtcbiAgZnVuY3Rpb24gTWFza1Bhc3MoIHNjZW5lLCBjYW1lcmEgKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE1hc2tQYXNzKSkgcmV0dXJuIG5ldyBNYXNrUGFzcyhzY2VuZSwgY2FtZXJhKTtcblxuICAgIHRoaXMuc2NlbmUgPSBzY2VuZTtcbiAgICB0aGlzLmNhbWVyYSA9IGNhbWVyYTtcblxuICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG4gICAgdGhpcy5jbGVhciA9IHRydWU7XG4gICAgdGhpcy5uZWVkc1N3YXAgPSBmYWxzZTtcblxuICAgIHRoaXMuaW52ZXJzZSA9IGZhbHNlO1xuICB9O1xuXG4gIE1hc2tQYXNzLnByb3RvdHlwZSA9IHtcblxuICAgIHJlbmRlcjogZnVuY3Rpb24gKCByZW5kZXJlciwgd3JpdGVCdWZmZXIsIHJlYWRCdWZmZXIsIGRlbHRhICkge1xuXG4gICAgICB2YXIgY29udGV4dCA9IHJlbmRlcmVyLmNvbnRleHQ7XG5cbiAgICAgIC8vIGRvbid0IHVwZGF0ZSBjb2xvciBvciBkZXB0aFxuXG4gICAgICBjb250ZXh0LmNvbG9yTWFzayggZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UgKTtcbiAgICAgIGNvbnRleHQuZGVwdGhNYXNrKCBmYWxzZSApO1xuXG4gICAgICAvLyBzZXQgdXAgc3RlbmNpbFxuXG4gICAgICB2YXIgd3JpdGVWYWx1ZSwgY2xlYXJWYWx1ZTtcblxuICAgICAgaWYgKCB0aGlzLmludmVyc2UgKSB7XG5cbiAgICAgICAgd3JpdGVWYWx1ZSA9IDA7XG4gICAgICAgIGNsZWFyVmFsdWUgPSAxO1xuXG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIHdyaXRlVmFsdWUgPSAxO1xuICAgICAgICBjbGVhclZhbHVlID0gMDtcblxuICAgICAgfVxuXG4gICAgICBjb250ZXh0LmVuYWJsZSggY29udGV4dC5TVEVOQ0lMX1RFU1QgKTtcbiAgICAgIGNvbnRleHQuc3RlbmNpbE9wKCBjb250ZXh0LlJFUExBQ0UsIGNvbnRleHQuUkVQTEFDRSwgY29udGV4dC5SRVBMQUNFICk7XG4gICAgICBjb250ZXh0LnN0ZW5jaWxGdW5jKCBjb250ZXh0LkFMV0FZUywgd3JpdGVWYWx1ZSwgMHhmZmZmZmZmZiApO1xuICAgICAgY29udGV4dC5jbGVhclN0ZW5jaWwoIGNsZWFyVmFsdWUgKTtcblxuICAgICAgLy8gZHJhdyBpbnRvIHRoZSBzdGVuY2lsIGJ1ZmZlclxuXG4gICAgICByZW5kZXJlci5yZW5kZXIoIHRoaXMuc2NlbmUsIHRoaXMuY2FtZXJhLCByZWFkQnVmZmVyLCB0aGlzLmNsZWFyICk7XG4gICAgICByZW5kZXJlci5yZW5kZXIoIHRoaXMuc2NlbmUsIHRoaXMuY2FtZXJhLCB3cml0ZUJ1ZmZlciwgdGhpcy5jbGVhciApO1xuXG4gICAgICAvLyByZS1lbmFibGUgdXBkYXRlIG9mIGNvbG9yIGFuZCBkZXB0aFxuXG4gICAgICBjb250ZXh0LmNvbG9yTWFzayggdHJ1ZSwgdHJ1ZSwgdHJ1ZSwgdHJ1ZSApO1xuICAgICAgY29udGV4dC5kZXB0aE1hc2soIHRydWUgKTtcblxuICAgICAgLy8gb25seSByZW5kZXIgd2hlcmUgc3RlbmNpbCBpcyBzZXQgdG8gMVxuXG4gICAgICBjb250ZXh0LnN0ZW5jaWxGdW5jKCBjb250ZXh0LkVRVUFMLCAxLCAweGZmZmZmZmZmICk7ICAvLyBkcmF3IGlmID09IDFcbiAgICAgIGNvbnRleHQuc3RlbmNpbE9wKCBjb250ZXh0LktFRVAsIGNvbnRleHQuS0VFUCwgY29udGV4dC5LRUVQICk7XG5cbiAgICB9XG5cbiAgfTtcblxuICByZXR1cm4gTWFza1Bhc3Ncbn07XG4iLCIvKipcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihUSFJFRSkge1xuICBmdW5jdGlvbiBSZW5kZXJQYXNzKCBzY2VuZSwgY2FtZXJhLCBvdmVycmlkZU1hdGVyaWFsLCBjbGVhckNvbG9yLCBjbGVhckFscGhhICkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZW5kZXJQYXNzKSkgcmV0dXJuIG5ldyBSZW5kZXJQYXNzKHNjZW5lLCBjYW1lcmEsIG92ZXJyaWRlTWF0ZXJpYWwsIGNsZWFyQ29sb3IsIGNsZWFyQWxwaGEpO1xuXG4gICAgdGhpcy5zY2VuZSA9IHNjZW5lO1xuICAgIHRoaXMuY2FtZXJhID0gY2FtZXJhO1xuXG4gICAgdGhpcy5vdmVycmlkZU1hdGVyaWFsID0gb3ZlcnJpZGVNYXRlcmlhbDtcblxuICAgIHRoaXMuY2xlYXJDb2xvciA9IGNsZWFyQ29sb3I7XG4gICAgdGhpcy5jbGVhckFscGhhID0gKCBjbGVhckFscGhhICE9PSB1bmRlZmluZWQgKSA/IGNsZWFyQWxwaGEgOiAxO1xuXG4gICAgdGhpcy5vbGRDbGVhckNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKCk7XG4gICAgdGhpcy5vbGRDbGVhckFscGhhID0gMTtcblxuICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG4gICAgdGhpcy5jbGVhciA9IHRydWU7XG4gICAgdGhpcy5uZWVkc1N3YXAgPSBmYWxzZTtcblxuICB9O1xuXG4gIFJlbmRlclBhc3MucHJvdG90eXBlID0ge1xuXG4gICAgcmVuZGVyOiBmdW5jdGlvbiAoIHJlbmRlcmVyLCB3cml0ZUJ1ZmZlciwgcmVhZEJ1ZmZlciwgZGVsdGEgKSB7XG5cbiAgICAgIHRoaXMuc2NlbmUub3ZlcnJpZGVNYXRlcmlhbCA9IHRoaXMub3ZlcnJpZGVNYXRlcmlhbDtcblxuICAgICAgaWYgKCB0aGlzLmNsZWFyQ29sb3IgKSB7XG5cbiAgICAgICAgdGhpcy5vbGRDbGVhckNvbG9yLmNvcHkoIHJlbmRlcmVyLmdldENsZWFyQ29sb3IoKSApO1xuICAgICAgICB0aGlzLm9sZENsZWFyQWxwaGEgPSByZW5kZXJlci5nZXRDbGVhckFscGhhKCk7XG5cbiAgICAgICAgcmVuZGVyZXIuc2V0Q2xlYXJDb2xvciggdGhpcy5jbGVhckNvbG9yLCB0aGlzLmNsZWFyQWxwaGEgKTtcblxuICAgICAgfVxuXG4gICAgICByZW5kZXJlci5yZW5kZXIoIHRoaXMuc2NlbmUsIHRoaXMuY2FtZXJhLCByZWFkQnVmZmVyLCB0aGlzLmNsZWFyICk7XG5cbiAgICAgIGlmICggdGhpcy5jbGVhckNvbG9yICkge1xuXG4gICAgICAgIHJlbmRlcmVyLnNldENsZWFyQ29sb3IoIHRoaXMub2xkQ2xlYXJDb2xvciwgdGhpcy5vbGRDbGVhckFscGhhICk7XG5cbiAgICAgIH1cblxuICAgICAgdGhpcy5zY2VuZS5vdmVycmlkZU1hdGVyaWFsID0gbnVsbDtcblxuICAgIH1cblxuICB9O1xuXG4gIHJldHVybiBSZW5kZXJQYXNzO1xuXG59O1xuIiwiLyoqXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oVEhSRUUsIEVmZmVjdENvbXBvc2VyKSB7XG4gIGZ1bmN0aW9uIFNoYWRlclBhc3MoIHNoYWRlciwgdGV4dHVyZUlEICkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTaGFkZXJQYXNzKSkgcmV0dXJuIG5ldyBTaGFkZXJQYXNzKHNoYWRlciwgdGV4dHVyZUlEKTtcblxuICAgIHRoaXMudGV4dHVyZUlEID0gKCB0ZXh0dXJlSUQgIT09IHVuZGVmaW5lZCApID8gdGV4dHVyZUlEIDogXCJ0RGlmZnVzZVwiO1xuXG4gICAgdGhpcy51bmlmb3JtcyA9IFRIUkVFLlVuaWZvcm1zVXRpbHMuY2xvbmUoIHNoYWRlci51bmlmb3JtcyApO1xuXG4gICAgdGhpcy5tYXRlcmlhbCA9IG5ldyBUSFJFRS5TaGFkZXJNYXRlcmlhbCgge1xuXG4gICAgICB1bmlmb3JtczogdGhpcy51bmlmb3JtcyxcbiAgICAgIHZlcnRleFNoYWRlcjogc2hhZGVyLnZlcnRleFNoYWRlcixcbiAgICAgIGZyYWdtZW50U2hhZGVyOiBzaGFkZXIuZnJhZ21lbnRTaGFkZXJcblxuICAgIH0gKTtcblxuICAgIHRoaXMucmVuZGVyVG9TY3JlZW4gPSBmYWxzZTtcblxuICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG4gICAgdGhpcy5uZWVkc1N3YXAgPSB0cnVlO1xuICAgIHRoaXMuY2xlYXIgPSBmYWxzZTtcblxuICB9O1xuXG4gIFNoYWRlclBhc3MucHJvdG90eXBlID0ge1xuXG4gICAgcmVuZGVyOiBmdW5jdGlvbiAoIHJlbmRlcmVyLCB3cml0ZUJ1ZmZlciwgcmVhZEJ1ZmZlciwgZGVsdGEgKSB7XG5cbiAgICAgIGlmICggdGhpcy51bmlmb3Jtc1sgdGhpcy50ZXh0dXJlSUQgXSApIHtcblxuICAgICAgICB0aGlzLnVuaWZvcm1zWyB0aGlzLnRleHR1cmVJRCBdLnZhbHVlID0gcmVhZEJ1ZmZlcjtcblxuICAgICAgfVxuXG4gICAgICBFZmZlY3RDb21wb3Nlci5xdWFkLm1hdGVyaWFsID0gdGhpcy5tYXRlcmlhbDtcblxuICAgICAgaWYgKCB0aGlzLnJlbmRlclRvU2NyZWVuICkge1xuXG4gICAgICAgIHJlbmRlcmVyLnJlbmRlciggRWZmZWN0Q29tcG9zZXIuc2NlbmUsIEVmZmVjdENvbXBvc2VyLmNhbWVyYSApO1xuXG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIHJlbmRlcmVyLnJlbmRlciggRWZmZWN0Q29tcG9zZXIuc2NlbmUsIEVmZmVjdENvbXBvc2VyLmNhbWVyYSwgd3JpdGVCdWZmZXIsIHRoaXMuY2xlYXIgKTtcblxuICAgICAgfVxuXG4gICAgfVxuXG4gIH07XG5cbiAgcmV0dXJuIFNoYWRlclBhc3M7XG5cbn07IiwiLyoqXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICpcbiAqIEZ1bGwtc2NyZWVuIHRleHR1cmVkIHF1YWQgc2hhZGVyXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHVuaWZvcm1zOiB7XG4gICAgXCJ0RGlmZnVzZVwiOiB7IHR5cGU6IFwidFwiLCB2YWx1ZTogbnVsbCB9LFxuICAgIFwib3BhY2l0eVwiOiAgeyB0eXBlOiBcImZcIiwgdmFsdWU6IDEuMCB9XG4gIH0sXG4gIHZlcnRleFNoYWRlcjogW1xuICAgIFwidmFyeWluZyB2ZWMyIHZVdjtcIixcblxuICAgIFwidm9pZCBtYWluKCkge1wiLFxuXG4gICAgICBcInZVdiA9IHV2O1wiLFxuICAgICAgXCJnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XCIsXG5cbiAgICBcIn1cIlxuICBdLmpvaW4oXCJcXG5cIiksXG4gIGZyYWdtZW50U2hhZGVyOiBbXG4gICAgXCJ1bmlmb3JtIGZsb2F0IG9wYWNpdHk7XCIsXG5cbiAgICBcInVuaWZvcm0gc2FtcGxlcjJEIHREaWZmdXNlO1wiLFxuXG4gICAgXCJ2YXJ5aW5nIHZlYzIgdlV2O1wiLFxuXG4gICAgXCJ2b2lkIG1haW4oKSB7XCIsXG5cbiAgICAgIFwidmVjNCB0ZXhlbCA9IHRleHR1cmUyRCggdERpZmZ1c2UsIHZVdiApO1wiLFxuICAgICAgXCJnbF9GcmFnQ29sb3IgPSBvcGFjaXR5ICogdGV4ZWw7XCIsXG5cbiAgICBcIn1cIlxuICBdLmpvaW4oXCJcXG5cIilcbn07XG4iLCJ2YXIgY3JlYXRlVHlwZXMgPSByZXF1aXJlKCcuL3R5cGVzJylcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFRIUkVFKSB7XG5cbiAgICB2YXIgdHlwZXMgPSBjcmVhdGVUeXBlcyhUSFJFRSkgXG5cbiAgICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlKGdsU2hhZGVyLCBvcHRzKSB7XG4gICAgICAgIG9wdHMgPSBvcHRzfHx7fVxuXG4gICAgICAgIGlmICh0eXBlb2Ygb3B0cy5jb2xvcnMgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgb3B0cy5jb2xvcnMgPSBbb3B0cy5jb2xvcnNdXG4gICAgICAgIFxuICAgICAgICB2YXIgdFVuaWZvcm1zID0gdHlwZXMoIGdsU2hhZGVyLnVuaWZvcm1zLCBvcHRzLmNvbG9ycyApXG4gICAgICAgIHZhciB0QXR0cmlicyA9IHR5cGVzKCBnbFNoYWRlci5hdHRyaWJ1dGVzLCBvcHRzLmNvbG9ycyApXG4gICAgICAgICAgICBcbiAgICAgICAgLy9jbGVhciB0aGUgYXR0cmlidXRlIGFycmF5c1xuICAgICAgICBmb3IgKHZhciBrIGluIHRBdHRyaWJzKSB7XG4gICAgICAgICAgICB0QXR0cmlic1trXS52YWx1ZSA9IFtdXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmVydGV4U2hhZGVyOiBnbFNoYWRlci52ZXJ0ZXgsXG4gICAgICAgICAgICBmcmFnbWVudFNoYWRlcjogZ2xTaGFkZXIuZnJhZ21lbnQsXG4gICAgICAgICAgICB1bmlmb3JtczogdFVuaWZvcm1zLFxuICAgICAgICAgICAgYXR0cmlidXRlczogdEF0dHJpYnNcbiAgICAgICAgfVxuICAgIH1cbn0iLCJ2YXIgdHlwZU1hcCA9IHtcbiAgICAnaW50JzogJ2knLFxuICAgICdmbG9hdCc6ICdmJyxcbiAgICAnaXZlYzInOiAnaTInLFxuICAgICdpdmVjMyc6ICdpMycsXG4gICAgJ2l2ZWM0JzogJ2k0JyxcbiAgICAndmVjMic6ICd2MicsXG4gICAgJ3ZlYzMnOiAndjMnLFxuICAgICd2ZWM0JzogJ3Y0JyxcbiAgICAnbWF0NCc6ICdtNCcsXG4gICAgJ21hdDMnOiAnbTMnLFxuICAgICdzYW1wbGVyMkQnOiAndCcsXG4gICAgJ3NhbXBsZXJDdWJlJzogJ3QnXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZShUSFJFRSkge1xuICAgIGZ1bmN0aW9uIG5ld0luc3RhbmNlKHR5cGUsIGlzQXJyYXkpIHtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdmbG9hdCc6IFxuICAgICAgICAgICAgY2FzZSAnaW50JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gMFxuICAgICAgICAgICAgY2FzZSAndmVjMic6XG4gICAgICAgICAgICBjYXNlICdpdmVjMic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBUSFJFRS5WZWN0b3IyKClcbiAgICAgICAgICAgIGNhc2UgJ3ZlYzMnOlxuICAgICAgICAgICAgY2FzZSAnaXZlYzMnOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVEhSRUUuVmVjdG9yMygpXG4gICAgICAgICAgICBjYXNlICd2ZWM0JzpcbiAgICAgICAgICAgIGNhc2UgJ2l2ZWM0JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFRIUkVFLlZlY3RvcjQoKVxuICAgICAgICAgICAgY2FzZSAnbWF0NCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBUSFJFRS5NYXRyaXg0KClcbiAgICAgICAgICAgIGNhc2UgJ21hdDMnOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVEhSRUUuTWF0cml4MygpXG4gICAgICAgICAgICBjYXNlICdzYW1wbGVyQ3ViZSc6XG4gICAgICAgICAgICBjYXNlICdzYW1wbGVyMkQnOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVEhSRUUuVGV4dHVyZSgpXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlZmF1bHRWYWx1ZSh0eXBlLCBpc0FycmF5LCBhcnJheUxlbikge1xuICAgICAgICBpZiAoaXNBcnJheSkge1xuICAgICAgICAgICAgLy9UaHJlZUpTIGZsYXR0ZW5zIGl2ZWMzIHR5cGVcbiAgICAgICAgICAgIC8vKHdlIGRvbid0IHN1cHBvcnQgJ2Z2JyB0eXBlKVxuICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdpdmVjMycpXG4gICAgICAgICAgICAgICAgYXJyYXlMZW4gKj0gM1xuICAgICAgICAgICAgdmFyIGFyID0gbmV3IEFycmF5KGFycmF5TGVuKVxuICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpPGFyLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIGFyW2ldID0gbmV3SW5zdGFuY2UodHlwZSwgaXNBcnJheSlcbiAgICAgICAgICAgIHJldHVybiBhclxuICAgICAgICB9ICBcbiAgICAgICAgcmV0dXJuIG5ld0luc3RhbmNlKHR5cGUpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0VHlwZSh0eXBlLCBpc0FycmF5KSB7XG4gICAgICAgIGlmICghaXNBcnJheSlcbiAgICAgICAgICAgIHJldHVybiB0eXBlTWFwW3R5cGVdXG5cbiAgICAgICAgaWYgKHR5cGUgPT09ICdpbnQnKVxuICAgICAgICAgICAgcmV0dXJuICdpdjEnXG4gICAgICAgIGVsc2UgaWYgKHR5cGUgPT09ICdmbG9hdCcpXG4gICAgICAgICAgICByZXR1cm4gJ2Z2MSdcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIHR5cGVNYXBbdHlwZV0rJ3YnXG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIHNldHVwVW5pZm9ybXMoZ2xVbmlmb3JtcywgY29sb3JOYW1lcykge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoY29sb3JOYW1lcykpXG4gICAgICAgICAgICBjb2xvck5hbWVzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKVxuXG4gICAgICAgIHZhciByZXN1bHQgPSB7fVxuICAgICAgICB2YXIgYXJyYXlzID0ge31cblxuICAgICAgICAvL21hcCB1bmlmb3JtIHR5cGVzXG4gICAgICAgIGdsVW5pZm9ybXMuZm9yRWFjaChmdW5jdGlvbih1bmlmb3JtKSB7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IHVuaWZvcm0ubmFtZVxuICAgICAgICAgICAgdmFyIGlzQXJyYXkgPSAvKC4rKVxcW1swLTldK1xcXS8uZXhlYyhuYW1lKVxuXG4gICAgICAgICAgICAvL3NwZWNpYWwgY2FzZTogY29sb3JzLi4uXG4gICAgICAgICAgICBpZiAoY29sb3JOYW1lcyAmJiBjb2xvck5hbWVzLmluZGV4T2YobmFtZSkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzQXJyYXkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFycmF5IG9mIGNvbG9yIHVuaWZvcm1zIG5vdCBzdXBwb3J0ZWRcIilcbiAgICAgICAgICAgICAgICBpZiAodW5pZm9ybS50eXBlICE9PSAndmVjMycpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRocmVlSlMgZXhwZWN0cyB2ZWMzIGZvciBDb2xvciB1bmlmb3Jtc1wiKSBcbiAgICAgICAgICAgICAgICByZXN1bHRbbmFtZV0gPSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdjJyxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG5ldyBUSFJFRS5Db2xvcigpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaXNBcnJheSkge1xuICAgICAgICAgICAgICAgIG5hbWUgPSBpc0FycmF5WzFdXG4gICAgICAgICAgICAgICAgaWYgKG5hbWUgaW4gYXJyYXlzKSBcbiAgICAgICAgICAgICAgICAgICAgYXJyYXlzW25hbWVdLmNvdW50KysgXG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBhcnJheXNbbmFtZV0gPSB7IGNvdW50OiAxLCB0eXBlOiB1bmlmb3JtLnR5cGUgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0W25hbWVdID0geyBcbiAgICAgICAgICAgICAgICB0eXBlOiBnZXRUeXBlKHVuaWZvcm0udHlwZSwgaXNBcnJheSksIFxuICAgICAgICAgICAgICAgIHZhbHVlOiBpc0FycmF5ID8gbnVsbCA6IGRlZmF1bHRWYWx1ZSh1bmlmb3JtLnR5cGUpIFxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuXG4gICAgICAgIC8vbm93IGNsZWFuIHVwIGFueSBhcnJheSB2YWx1ZXNcbiAgICAgICAgZm9yICh2YXIgayBpbiByZXN1bHQpIHtcbiAgICAgICAgICAgIHZhciB1ID0gcmVzdWx0W2tdXG4gICAgICAgICAgICBpZiAoayBpbiBhcnJheXMpIHsgLy9pcyBhbiBhcnJheVxuICAgICAgICAgICAgICAgIHZhciBhID0gYXJyYXlzW2tdXG4gICAgICAgICAgICAgICAgdS52YWx1ZSA9IGRlZmF1bHRWYWx1ZShhLnR5cGUsIHRydWUsIGEuY291bnQpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGUiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL3JlbmRlcmVyJykiLCJ2YXIgY3JlYXRlVGV4dCA9IHJlcXVpcmUoJ2dsLXNwcml0ZS10ZXh0JylcbnZhciBtYXQ0ID0ge1xuICAgIGNyZWF0ZTogcmVxdWlyZSgnZ2wtbWF0NC9jcmVhdGUnKSxcbiAgICBzY2FsZTogcmVxdWlyZSgnZ2wtbWF0NC9zY2FsZScpLFxuICAgIG11bHRpcGx5OiByZXF1aXJlKCdnbC1tYXQ0L211bHRpcGx5Jylcbn1cblxudmFyIG1vZGVsVHJhbnNmb3JtID0gbWF0NC5jcmVhdGUoKVxudmFyIGZsaXAgPSBtYXQ0LmNyZWF0ZSgpXG5tYXQ0LnNjYWxlKGZsaXAsIGZsaXAsIFsxLCAtMSwgMV0pXG5cbnZhciBXcmFwVGV4dHVyZSA9IHJlcXVpcmUoJy4vdGV4dHVyZS13cmFwJylcbnZhciBudW1iZXIgPSByZXF1aXJlKCdhcy1udW1iZXInKVxudmFyIHh0ZW5kID0gcmVxdWlyZSgneHRlbmQnKVxuXG52YXIgY3JlYXRlU2hhZGVyID0gcmVxdWlyZSgnZ2wtc2hhZGVyLWNvcmUnKVxudmFyIHZlcnRleCA9ICdhdHRyaWJ1dGUgdmVjNCBwb3NpdGlvbjtcXG5hdHRyaWJ1dGUgdmVjNCBjb2xvcjtcXG5hdHRyaWJ1dGUgdmVjMiB0ZXhjb29yZDA7XFxuXFxudW5pZm9ybSBtYXQ0IHByb2plY3Rpb247XFxudW5pZm9ybSBtYXQ0IHZpZXc7XFxudW5pZm9ybSBtYXQ0IG1vZGVsO1xcblxcbnZhcnlpbmcgdmVjNCB2X2NvbDtcXG52YXJ5aW5nIHZlYzIgdl90ZXgwO1xcblxcbnZvaWQgbWFpbigpIHtcXG4gZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uICogdmlldyAqIG1vZGVsICogcG9zaXRpb247XFxuIHZfY29sID0gY29sb3I7XFxuIHZfdGV4MCA9IHRleGNvb3JkMDtcXG4gZ2xfUG9pbnRTaXplID0gMS4wO1xcbn0nXG52YXIgZnJhZ21lbnQgPSAnI2lmZGVmIEdMX0VTXFxucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuI2VuZGlmXFxuXFxudmFyeWluZyB2ZWM0IHZfY29sO1xcbnZhcnlpbmcgdmVjMiB2X3RleDA7XFxudW5pZm9ybSBzYW1wbGVyMkQgdGV4dHVyZTA7XFxuXFxudW5pZm9ybSBmbG9hdCBzbW9vdGhpbmc7XFxuLy8gPSAxLjAvMzIuMDtcXG5cXG4vLyBkcm9wIHNoYWRvdyBjb21wdXRlZCBpbiBmcmFnbWVudCBzaGFkZXJcXG52b2lkIG1haW4oKSB7XFxuIHZlYzQgdGV4Q29sb3IgPSB0ZXh0dXJlMkQodGV4dHVyZTAsIHZfdGV4MCk7XFxuXFxuIGZsb2F0IGRzdCA9IHRleENvbG9yLmE7XFxuIGZsb2F0IGFscGhhID0gc21vb3Roc3RlcCgwLjUgLSBzbW9vdGhpbmcsIDAuNSArIHNtb290aGluZywgZHN0KTtcXG4gdmVjNCBiYXNlID0gdl9jb2wgKiB2ZWM0KGFscGhhKTtcXG5cXG4gZ2xfRnJhZ0NvbG9yID0gYmFzZTtcXG4gaWYgKGdsX0ZyYWdDb2xvci5hPDAuMSlcXG4gZGlzY2FyZDtcXG59J1xuXG52YXIgdW5pZm9ybXMgPSBbXG4gICAgICAgIHsgdHlwZTogJ2Zsb2F0JywgbmFtZTogJ3Ntb290aGluZycgfSxcbiAgICAgICAgeyB0eXBlOiAnc2FtcGxlcjJEJywgbmFtZTogJ3RleHR1cmUwJyB9LFxuICAgICAgICB7IHR5cGU6ICdtYXQ0JywgbmFtZTogJ3Byb2plY3Rpb24nIH0sXG4gICAgICAgIHsgdHlwZTogJ21hdDQnLCBuYW1lOiAndmlldycgfSxcbiAgICAgICAgeyB0eXBlOiAnbWF0NCcsIG5hbWU6ICdtb2RlbCcgfSAgICAgICAgXG4gICAgXSxcbiAgICBhdHRyaWJ1dGVzID0gW1xuICAgICAgICB7IHR5cGU6ICd2ZWM0JywgbmFtZTogJ3Bvc2l0aW9uJyB9LFxuICAgICAgICB7IHR5cGU6ICd2ZWM0JywgbmFtZTogJ2NvbG9yJyB9LFxuICAgICAgICB7IHR5cGU6ICd2ZWMyJywgbmFtZTogJ3RleGNvb3JkMCcgfVxuICAgIF1cblxuXG5cbmZ1bmN0aW9uIGNvcHlDb2xvcihvdXQsIGNvbG9yLCBvcGFjaXR5KSB7XG4gICAgb3V0WzBdID0gY29sb3IuclxuICAgIG91dFsxXSA9IGNvbG9yLmcgXG4gICAgb3V0WzJdID0gY29sb3IuYiBcbiAgICBvdXRbM10gPSBvcGFjaXR5XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oVEhSRUUpIHtcbiAgICB2YXIgc2hhcmVkU2hhZGVyXG5cbiAgICBmdW5jdGlvbiBUZXh0UmVuZGVyZXIocmVuZGVyZXIsIG9wdCkge1xuICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVGV4dFJlbmRlcmVyKSlcbiAgICAgICAgICAgIHJldHVybiBuZXcgVGV4dFJlbmRlcmVyKHJlbmRlcmVyLCBvcHQpXG4gICAgICAgIG9wdD1vcHR8fHt9XG5cbiAgICAgICAgdmFyIGdsID0gcmVuZGVyZXIuZ2V0Q29udGV4dCgpXG4gICAgICAgIHRoaXMuZ2wgPSBnbFxuICAgICAgICB0aGlzLmNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKClcbiAgICAgICAgaWYgKG9wdC5jb2xvciAhPT0gbnVsbCAmJiB0eXBlb2Ygb3B0LmNvbG9yICE9PSAndW5kZWZpbmVkJylcbiAgICAgICAgICAgIHRoaXMuY29sb3Iuc2V0KG9wdC5jb2xvcilcbiAgICAgICAgdGhpcy5vcGFjaXR5ID0gbnVtYmVyKG9wdC5vcGFjaXR5LCAxLjApXG5cbiAgICAgICAgLy9pZiBubyB0ZXh0dXJlcyBhcmUgZ2l2ZW4sIHByZXN1bWUgdGhleSBhcmUgYmFzZTY0IHBhY2tlZFxuICAgICAgICAvL2ludG8gdGhlIEZvbnQgb2JqZWN0IChsaWtlIHdpdGggYm1mb250LWxhdG8pXG4gICAgICAgIHZhciB0ZXh0T3B0cyA9IHh0ZW5kKG9wdClcbiAgICAgICAgaWYgKHRleHRPcHRzLnRleHR1cmVzKSB7XG4gICAgICAgICAgICB0ZXh0T3B0cy50ZXh0dXJlcyA9IHRleHRPcHRzLnRleHR1cmVzLm1hcChmdW5jdGlvbih0ZXgpIHtcbiAgICAgICAgICAgICAgICAvLyByZXR1cm4gcmVxdWlyZSgnZ2wtdGV4dHVyZTJkJykoZ2wsIHRleC5pbWFnZSlcbiAgICAgICAgICAgICAgICBpZiAodGV4IGluc3RhbmNlb2YgVEhSRUUuVGV4dHVyZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFdyYXBUZXh0dXJlKHJlbmRlcmVyLCB0ZXgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRleFxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gY3JlYXRlVGV4dChnbCwgdGV4dE9wdHMpXG4gICAgICAgIHRoaXMudHJhbnNmb3JtID0gbWF0NC5jcmVhdGUoKVxuXG4gICAgICAgIGlmICghc2hhcmVkU2hhZGVyICYmICFvcHQuc2hhZGVyKVxuICAgICAgICAgICAgc2hhcmVkU2hhZGVyID0gY3JlYXRlU2hhZGVyKGdsLCB2ZXJ0ZXgsIGZyYWdtZW50LCB1bmlmb3JtcywgYXR0cmlidXRlcylcbiAgICAgICAgdGhpcy5zaGFkZXIgPSBvcHQuc2hhZGVyIHx8IHNoYXJlZFNoYWRlclxuICAgICAgICB0aGlzLnNoYWRlci5iaW5kKClcblxuICAgICAgICB0aGlzLnBhZGRpbmcgPSBudW1iZXIob3B0LnBhZGRpbmcsIDApXG5cbiAgICAgICAgdmFyIHMgPSBudW1iZXIob3B0LnNtb290aGluZywgMS4wLzMyLjApXG4gICAgICAgIHRoaXMuc2hhZGVyLnVuaWZvcm1zLnNtb290aGluZyA9IHNcbiAgICAgICAgdGhpcy5zaGFkZXIudW5pZm9ybXMudGV4dHVyZTAgPSAwXG4gICAgfVxuXG4gICAgVGV4dFJlbmRlcmVyLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24oY2FtZXJhLCBvYmplY3QpIHtcbiAgICAgICAgdmFyIGdsID0gdGhpcy5nbFxuXG4gICAgICAgIGlmICghb2JqZWN0LnZpc2libGUpXG4gICAgICAgICAgICByZXR1cm5cblxuICAgICAgICBpZiAoIXRoaXMuZWxlbWVudC50ZXh0dXJlcyB8fCB0aGlzLmVsZW1lbnQudGV4dHVyZXMubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuXG5cbiAgICAgICAgZ2wuZW5hYmxlKGdsLkJMRU5EKVxuICAgICAgICAvLyBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIG51bGwpXG5cbiAgICAgICAgZ2wuZW5hYmxlKGdsLkRFUFRIX1RFU1QpXG4gICAgICAgIGdsLmRlcHRoRnVuYyhnbC5MRVFVQUwpXG5cbiAgICAgICAgLy8gZ2wuZnJvbnRGYWNlKCBnbC5DQ1cgKSAgICBcbiAgICAgICAgZ2wuZW5hYmxlKGdsLkNVTExfRkFDRSlcbiAgICAgICAgLy8gZ2wuY3VsbEZhY2UoIGdsLkZST05UIClcbiAgICAgICAgZ2wuY29sb3JNYXNrKHRydWUsIHRydWUsIHRydWUsIHRydWUpXG4gICAgICAgIGdsLmRpc2FibGUoZ2wuU1RFTkNJTF9URVNUKVxuICAgICAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwKVxuICAgICAgICBnbC5kZXB0aE1hc2sodHJ1ZSlcbiAgICAgICAgZ2wuYmxlbmRGdW5jKGdsLlNSQ19BTFBIQSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSlcblxuICAgICAgICB0aGlzLnNoYWRlci5iaW5kKClcbiAgICAgICAgdGhpcy5lbGVtZW50LnRleHR1cmVzWzBdLmJpbmQoMClcblxuICAgICAgICAvLyBnbC5jb2xvck1hc2sodHJ1ZSwgdHJ1ZSwgdHJ1ZSwgdHJ1ZSlcblxuICAgICAgICBnbC5jdWxsRmFjZShnbC5GUk9OVClcblxuICAgICAgICBtYXQ0Lm11bHRpcGx5KG1vZGVsVHJhbnNmb3JtLCBvYmplY3QubWF0cml4V29ybGQuZWxlbWVudHMsIHRoaXMudHJhbnNmb3JtKVxuICAgICAgICBtYXQ0Lm11bHRpcGx5KG1vZGVsVHJhbnNmb3JtLCBtb2RlbFRyYW5zZm9ybSwgZmxpcClcblxuICAgICAgICB0aGlzLnNoYWRlci5iaW5kKClcbiAgICAgICAgdGhpcy5zaGFkZXIudW5pZm9ybXMucHJvamVjdGlvbiA9IGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4LmVsZW1lbnRzXG4gICAgICAgIHRoaXMuc2hhZGVyLnVuaWZvcm1zLnZpZXcgPSBjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlLmVsZW1lbnRzXG4gICAgICAgIHRoaXMuc2hhZGVyLnVuaWZvcm1zLm1vZGVsID0gbW9kZWxUcmFuc2Zvcm1cbiAgICAgICAgICAgIFxuICAgICAgICBjb3B5Q29sb3IodGhpcy5lbGVtZW50LmJhdGNoLmNvbG9yLCB0aGlzLmNvbG9yLCB0aGlzLm9wYWNpdHkpXG4gICAgICAgIHRoaXMuZWxlbWVudC5kcmF3KHRoaXMuc2hhZGVyLCB0aGlzLnBhZGRpbmcsIHRoaXMucGFkZGluZylcblxuICAgICAgICBnbC5jdWxsRmFjZSggZ2wuQkFDSyApXG4gICAgfVxuXG5cbiAgICByZXR1cm4gVGV4dFJlbmRlcmVyXG59IiwiLy8gaW4gdGltZSB0aGlzIHdpbGwgYmUgcmVwbGFjZWQgd2l0aCBhIHNvbHV0aW9uXG4vLyB0aGF0IGJldHRlciBzdXBwb3J0ZWQgVGhyZWVKUyBUZXh0dXJlIG9iamVjdHNcblxuXG5mdW5jdGlvbiBUZXh0dXJlV3JhcChyZW5kZXJlciwgdGV4KSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFRleHR1cmVXcmFwKSlcbiAgICAgICAgcmV0dXJuIG5ldyBUZXh0dXJlV3JhcChyZW5kZXJlciwgdGV4KVxuICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlclxuICAgIHRoaXMudGV4dHVyZSA9IHRleFxuICAgIHRoaXMuX3NoYXBlID0gWzAsIDBdXG59XG5cblRleHR1cmVXcmFwLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24odW5pdCkge1xuICAgIHVwZGF0ZVNpemUodGhpcy5fc2hhcGUsIHRoaXMudGV4dHVyZSlcblxuXG4gICAgdmFyIGdsID0gdGhpcy5yZW5kZXJlci5nZXRDb250ZXh0KClcbiAgICB0aGlzLnJlbmRlcmVyLnNldFRleHR1cmUodGhpcy50ZXh0dXJlLCB1bml0fDApXG4gICAgXG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy50ZXh0dXJlLl9fd2ViZ2xUZXh0dXJlKVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVGV4dHVyZVdyYXAucHJvdG90eXBlLCBcInNoYXBlXCIsIHtcblxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHVwZGF0ZVNpemUodGhpcy5fc2hhcGUsIHRoaXMudGV4dHVyZSlcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NoYXBlXG4gICAgfVxufSlcblxuZnVuY3Rpb24gdXBkYXRlU2l6ZShzaGFwZSwgdGV4dHVyZSkge1xuICAgIHNoYXBlWzBdID0gKHRleHR1cmUuaW1hZ2UgJiYgdGV4dHVyZS5pbWFnZS53aWR0aCkgIHwwXG4gICAgc2hhcGVbMV0gPSAodGV4dHVyZS5pbWFnZSAmJiB0ZXh0dXJlLmltYWdlLmhlaWdodCkgfDBcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBUZXh0dXJlV3JhcCIsIm1vZHVsZS5leHBvcnRzPXJlcXVpcmUoXCIvcHJvamVjdHMvYmxhY2tpY2Uvbm9kZV9tb2R1bGVzL2FzLW51bWJlci9pbmRleC5qc1wiKSIsIm1vZHVsZS5leHBvcnRzID0gY3JlYXRlO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgaWRlbnRpdHkgbWF0NFxuICpcbiAqIEByZXR1cm5zIHttYXQ0fSBhIG5ldyA0eDQgbWF0cml4XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgICB2YXIgb3V0ID0gbmV3IEZsb2F0MzJBcnJheSgxNik7XG4gICAgb3V0WzBdID0gMTtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSAwO1xuICAgIG91dFs1XSA9IDE7XG4gICAgb3V0WzZdID0gMDtcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9IDA7XG4gICAgb3V0WzldID0gMDtcbiAgICBvdXRbMTBdID0gMTtcbiAgICBvdXRbMTFdID0gMDtcbiAgICBvdXRbMTJdID0gMDtcbiAgICBvdXRbMTNdID0gMDtcbiAgICBvdXRbMTRdID0gMDtcbiAgICBvdXRbMTVdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufTsiLCJtb2R1bGUuZXhwb3J0cz1yZXF1aXJlKFwiL3Byb2plY3RzL2JsYWNraWNlL25vZGVfbW9kdWxlcy9nbC1tYXQ0L211bHRpcGx5LmpzXCIpIiwibW9kdWxlLmV4cG9ydHM9cmVxdWlyZShcIi9wcm9qZWN0cy9ibGFja2ljZS9ub2RlX21vZHVsZXMvZ2wtbWF0NC9zY2FsZS5qc1wiKSIsIm1vZHVsZS5leHBvcnRzPXJlcXVpcmUoXCIvcHJvamVjdHMvYmxhY2tpY2Uvbm9kZV9tb2R1bGVzL2dsc2xpZnkvbm9kZV9tb2R1bGVzL2dsLXNoYWRlci1jb3JlL3NoYWRlci1jb3JlLmpzXCIpIiwidmFyIEJhc2UgPSByZXF1aXJlKCdmb250cGF0aC1zaW1wbGUtcmVuZGVyZXInKVxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIGJtZm9udDJmb250cGF0aCA9IHJlcXVpcmUoJ2ZvbnRwYXRoLWJtZm9udCcpXG52YXIgdGV4Y29vcmQgPSByZXF1aXJlKCd0ZXhjb29yZCcpXG52YXIgeHRlbmQgPSByZXF1aXJlKCd4dGVuZCcpXG52YXIgY3JlYXRlVGV4dHVyZSA9IHJlcXVpcmUoJ2dsLXRleHR1cmUyZCcpXG5cbnZhciBCYXRjaCA9IHJlcXVpcmUoJ2dsLXNwcml0ZS1iYXRjaCcpXG5cbnZhciB0bXBQb3MgPSBbMCwgMF0sXG4gICAgdG1wU2hhcGUgPSBbMCwgMF0sXG4gICAgdG1wMSA9IFswLCAwXSxcbiAgICB0bXAyID0gWzAsIDBdXG52YXIgREVGQVVMVF9URVhDT09SRCA9IFswLCAwLCAxLCAxXVxudmFyIG1heEluaXRpYWxDYXBhY2l0eSA9IDUwMFxuXG5mdW5jdGlvbiB0ZXhjb29yZEdseXBoKGdseXBoLCBhdGxhcywgb3V0KSB7XG4gICAgdG1wMVswXSA9IGdseXBoLnhcbiAgICB0bXAxWzFdID0gZ2x5cGgueVxuICAgIHRtcDJbMF0gPSBnbHlwaC53aWR0aFxuICAgIHRtcDJbMV0gPSBnbHlwaC5oZWlnaHRcbiAgICByZXR1cm4gdGV4Y29vcmQodG1wMSwgdG1wMiwgYXRsYXMsIG91dClcbn1cblxuZnVuY3Rpb24gVGV4dFJlbmRlcmVyKGdsLCBvcHQpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVGV4dFJlbmRlcmVyKSlcbiAgICAgICAgcmV0dXJuIG5ldyBUZXh0UmVuZGVyZXIoZ2wsIG9wdClcbiAgICBvcHQgPSBvcHR8fHt9XG5cbiAgICBpZiAoIW9wdC5mb250KSBcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtdXN0IHNwZWNpZnkgYm1mb250IGF0IGNyZWF0aW9uIHRpbWUnKVxuXG4gICAgLy9pZiB0aGUgZm9udCBoYXMgSW1hZ2UvbmRhcnJheSBhcnJheVxuICAgIGlmICghb3B0LnRleHR1cmVzICYmIEFycmF5LmlzQXJyYXkob3B0LmZvbnQuaW1hZ2VzKSkge1xuICAgICAgICBvcHQudGV4dHVyZXMgPSBvcHQuZm9udC5pbWFnZXMubWFwKGZ1bmN0aW9uKGltZykge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVRleHR1cmUoZ2wsIGltZylcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICBvcHQuZm9udCA9IGJtZm9udDJmb250cGF0aChvcHQuZm9udClcblxuICAgIEJhc2UuY2FsbCh0aGlzLCBvcHQpXG5cbiAgICB0aGlzLnRleHR1cmVzID0gb3B0LnRleHR1cmVzIHx8IFtdXG4gICAgdGhpcy5nbCA9IGdsXG4gICAgaWYgKCFnbClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibXVzdCBzcGVjaWZ5IGdsIGNvbnRleHRcIilcbiAgICBcbiAgICAvL2Fzc3VtZSB0ZXh0IHdpbGwgYmUgdXNlZCBkeW5hbWljYWxseSBcbiAgICBpZiAodHlwZW9mIG9wdC5keW5hbWljICE9PSAnYm9vbGVhbicpXG4gICAgICAgIG9wdC5keW5hbWljID0gdHJ1ZVxuXG4gICAgdmFyIGJhdGNoID0gb3B0LmJhdGNoXG4gICAgaWYgKCFiYXRjaClcbiAgICAgICAgdGhpcy5kZWZhdWx0QmF0Y2ggPSBCYXRjaChnbCwgb3B0KVxuICAgIHRoaXMuYmF0Y2ggPSBiYXRjaCB8fCB0aGlzLmRlZmF1bHRCYXRjaFxuXG4gICAgaWYgKHR5cGVvZiBvcHQud3JhcFdpZHRoICE9PSAnbnVtYmVyJylcbiAgICAgICAgdGhpcy5sYXlvdXQoKVxufVxuXG5pbmhlcml0cyhUZXh0UmVuZGVyZXIsIEJhc2UpXG5cblRleHRSZW5kZXJlci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uKHRleHR1cmVzKSB7XG4gICAgaWYgKHRoaXMuZGVmYXVsdEJhdGNoKVxuICAgICAgICB0aGlzLmRlZmF1bHRCYXRjaC5kaXNwb3NlKClcbiAgICBpZiAodGV4dHVyZXMpIHtcbiAgICAgICAgdGhpcy50ZXh0dXJlcy5mb3JFYWNoKGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdC5kaXNwb3NlID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgICAgIHQuZGlzcG9zZSgpXG4gICAgICAgIH0pXG4gICAgfVxuICAgIHJldHVybiB0aGlzXG59XG5cblRleHRSZW5kZXJlci5wcm90b3R5cGUudW5jYWNoZSA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2NhY2hlID0gZmFsc2VcbiAgICB0aGlzLmJhdGNoLmNsZWFyKClcbiAgICByZXR1cm4gdGhpc1xufVxuXG5UZXh0UmVuZGVyZXIucHJvdG90eXBlLmNhY2hlID0gZnVuY3Rpb24oeCwgeSwgc3RhcnQsIGVuZCkge1xuICAgIC8vIGlmICh0aGlzLnVuZGVybGluZSB8fCB0aGlzLmZvbnQucGFnZXMubGVuZ3RoID4gMSlcbiAgICAvLyAgICAgdGhyb3cgbmV3IEVycm9yKCdjdXJyZW50bHkgY2FjaGVkIHRleHQgZG9lcyBub3Qgc3VwcG9ydCB1bmRlcmxpbmVzIG9yIG11bHRpcGxlIHRleHR1cmUgcGFnZXMnKVxuICAgIFxuICAgIHRoaXMuX2NhY2hlID0gdHJ1ZVxuICAgIHRoaXMuYmF0Y2guZW5zdXJlQ2FwYWNpdHkodGhpcy50ZXh0Lmxlbmd0aClcbiAgICB0aGlzLmJhdGNoLmNsZWFyKClcbiAgICB0aGlzLl9idWlsZCh4LCB5LCBzdGFydCwgZW5kKVxuICAgIHJldHVybiB0aGlzXG59XG5cblRleHRSZW5kZXJlci5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uKHNoYWRlciwgeCwgeSwgc3RhcnQsIGVuZCkge1xuICAgIHZhciBiYXRjaCA9IHRoaXMuYmF0Y2hcbiAgICBiYXRjaC5iaW5kKHNoYWRlcilcblxuICAgIC8vaWYgd2UncmUgZHJhd2luZyBkeW5hbWljYWxseVxuICAgIGlmICghdGhpcy5fY2FjaGUpIHtcbiAgICAgICAgYmF0Y2guY2xlYXIoKVxuICAgICAgICB0aGlzLl9idWlsZCh4LCB5LCBzdGFydCwgZW5kKVxuICAgIH1cbiAgICBcbiAgICBiYXRjaC5kcmF3KClcbiAgICBiYXRjaC51bmJpbmQoKVxuICAgIHJldHVybiB0aGlzXG59XG5cblRleHRSZW5kZXJlci5wcm90b3R5cGUuX2J1aWxkID0gZnVuY3Rpb24oeCwgeSwgc3RhcnQsIGVuZCkge1xuICAgIHZhciByZXN1bHQgPSB0aGlzLnJlbmRlcih4LCB5LCBzdGFydCwgZW5kKVxuXG4gICAgdmFyIGJhdGNoID0gdGhpcy5iYXRjaFxuICAgIHZhciBpID0gMFxuICAgIFxuICAgIC8vdW5kZXJsaW5lcyBjdXJyZW50bHkgbm90IHN1cHBvcnRlZCB3aXRoIGNhY2hlKClcbiAgICBpZiAoIXRoaXMuX2NhY2hlKSB7XG4gICAgICAgIGJhdGNoLnRleGNvb3JkID0gREVGQVVMVF9URVhDT09SRFxuICAgICAgICBiYXRjaC50ZXh0dXJlID0gbnVsbFxuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCByZXN1bHQudW5kZXJsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHVuZGVybGluZSA9IHJlc3VsdC51bmRlcmxpbmVzW2ldXG4gICAgICAgICAgICBiYXRjaC5wb3NpdGlvbiA9IHVuZGVybGluZS5wb3NpdGlvblxuICAgICAgICAgICAgYmF0Y2guc2hhcGUgPSB1bmRlcmxpbmUuc2l6ZVxuICAgICAgICAgICAgYmF0Y2gucHVzaCgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvL25vdyBkcmF3IG91ciBnbHlwaHMgaW50byB0aGUgYmF0Y2guLi5cbiAgICBmb3IgKGkgPSAwOyBpIDwgcmVzdWx0LmdseXBocy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZyA9IHJlc3VsdC5nbHlwaHNbaV1cbiAgICAgICAgdGhpcy5fZHJhd0dseXBoKGJhdGNoLCBnKVxuICAgIH1cbn1cblxuVGV4dFJlbmRlcmVyLnByb3RvdHlwZS5fZHJhd0dseXBoID0gZnVuY3Rpb24oYmF0Y2gsIGRhdGEpIHtcbiAgICAvLy4uLiB3ZSBjb3VsZCBzb3J0IHRoZXNlIGJ5IHRleHR1cmUgcGFnZSB0byByZWR1Y2UgZHJhd3NcbiAgICB2YXIgZ2x5cGggPSBkYXRhLmdseXBoXG4gICAgdmFyIGltZyA9IHRoaXMudGV4dHVyZXNbZ2x5cGgucGFnZV1cbiAgICB0bXBQb3NbMF0gPSBkYXRhLnBvc2l0aW9uWzBdK2dseXBoLmhieFxuICAgIHRtcFBvc1sxXSA9IGRhdGEucG9zaXRpb25bMV0rZ2x5cGguaGJ5IC0gdGhpcy5mb250LmRlc2NlbmRlclxuICAgIHRtcFNoYXBlWzBdID0gZ2x5cGgud2lkdGggKiBkYXRhLnNjYWxlWzBdXG4gICAgdG1wU2hhcGVbMV0gPSBnbHlwaC5oZWlnaHQgKiBkYXRhLnNjYWxlWzFdXG4gICAgXG4gICAgYmF0Y2gudGV4dHVyZSA9IGltZ1xuICAgIHRleGNvb3JkR2x5cGgoZ2x5cGgsIGltZyAmJiBpbWcuc2hhcGUsIGJhdGNoLnRleGNvb3JkKVxuICAgIGJhdGNoLnBvc2l0aW9uID0gdG1wUG9zXG4gICAgYmF0Y2guc2hhcGUgPSB0bXBTaGFwZVxuICAgIGJhdGNoLnB1c2goKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFRleHRSZW5kZXJlciIsImZ1bmN0aW9uIGdseXBoKGRhdGEpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBwYWdlOiBkYXRhLnBhZ2UsXG4gICAgICAgIGhieDogZGF0YS54b2Zmc2V0LFxuICAgICAgICBoYnk6IGRhdGEueW9mZnNldCxcbiAgICAgICAgd2lkdGg6IGRhdGEud2lkdGgsXG4gICAgICAgIGhlaWdodDogZGF0YS5oZWlnaHQsXG4gICAgICAgIHhvZmY6IGRhdGEueGFkdmFuY2UsXG4gICAgICAgIHg6IGRhdGEueCxcbiAgICAgICAgeTogZGF0YS55XG4gICAgfVxufVxuXG5mdW5jdGlvbiBnbHlwaHMoY2hhcnMpIHtcbiAgICB2YXIgb3V0ID0ge31cbiAgICBjaGFycy5mb3JFYWNoKGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgb3V0W1N0cmluZy5mcm9tQ2hhckNvZGUoYy5pZCldID0gZ2x5cGgoYylcbiAgICB9KVxuICAgIHJldHVybiBvdXRcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihibWZvbnQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBwYWdlczogYm1mb250LnBhZ2VzLFxuICAgICAgICByZXNvbHV0aW9uOiA3MixcbiAgICAgICAgc2l6ZTogYm1mb250LmluZm8uc2l6ZSxcbiAgICAgICAgdW5pdHNfcGVyX0VNOiAxLFxuICAgICAgICBiaXRtYXA6IHRydWUsXG4gICAgICAgIGZhbWlseV9uYW1lOiBibWZvbnQuaW5mby5mYWNlLFxuICAgICAgICBoZWlnaHQ6IGJtZm9udC5jb21tb24ubGluZUhlaWdodCxcbiAgICAgICAgZGVzY2VuZGVyOiBibWZvbnQuY29tbW9uLmJhc2UsXG4gICAgICAgIGFzY2VuZGVyOiBibWZvbnQuY29tbW9uLmJhc2UsXG4gICAgICAgIGdseXBoczogZ2x5cGhzKGJtZm9udC5jaGFycyksXG4gICAgICAgIGtlcm5pbmc6IGJtZm9udC5rZXJuaW5ncy5tYXAoZnVuY3Rpb24oaykge1xuICAgICAgICAgICAgcmV0dXJuIFtTdHJpbmcuZnJvbUNoYXJDb2RlKGsuZmlyc3QpLFN0cmluZy5mcm9tQ2hhckNvZGUoay5zZWNvbmQpLGsuYW1vdW50XVxuICAgICAgICB9KVxuICAgIH1cbn0iLCJ2YXIgQmFzZSA9IHJlcXVpcmUoJ2ZvbnRwYXRoLXJlbmRlcmVyJylcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcblxuLy9UT0RPOiBFdmVudHVhbGx5IGxvdHMgb2YgdGhpcyBjb2RlIHdpbGwganVzdCByZXBsYWNlIGZvbnRwYXRoLXJlbmRlcmVyLi4uXG5cbmZ1bmN0aW9uIEZvbnRwYXRoUmVuZGVyZXIob3B0aW9ucykge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBGb250cGF0aFJlbmRlcmVyKSlcbiAgICAgICAgcmV0dXJuIG5ldyBGb250cGF0aFJlbmRlcmVyKG9wdGlvbnMpXG4gICAgQmFzZS5jYWxsKHRoaXMsIG9wdGlvbnMpXG5cbiAgICB0aGlzLmRhdGEgPSB7XG4gICAgICAgIGdseXBoczogW10sXG4gICAgICAgIHVuZGVybGluZXM6IFtdXG4gICAgfVxufVxuXG5pbmhlcml0cyhGb250cGF0aFJlbmRlcmVyLCBCYXNlKVxuXG5Gb250cGF0aFJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJHbHlwaCA9IGZ1bmN0aW9uKGksIGdseXBoLCBzY2FsZSwgeCwgeSkge1xuICAgIHRoaXMuZGF0YS5nbHlwaHMucHVzaChuZXcgR2x5cGgoaSwgZ2x5cGgsIFxuICAgICAgICAgICAgICAgIHRoaXMudGV4dC5jaGFyQ29kZUF0KGkpLCBcbiAgICAgICAgICAgICAgICBbIHNjYWxlLCB0aGlzLmZvbnQuYml0bWFwID8gc2NhbGUgOiAtc2NhbGUgXSxcbiAgICAgICAgICAgICAgICBbIHgsIHkgXSkpXG59XG5cbkZvbnRwYXRoUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlclVuZGVybGluZSA9IGZ1bmN0aW9uKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICB0aGlzLmRhdGEudW5kZXJsaW5lcy5wdXNoKG5ldyBVbmRlcmxpbmUoXG4gICAgICAgIFsgeCwgeSBdLFxuICAgICAgICBbIHdpZHRoLCBoZWlnaHQgXVxuICAgICkpXG59XG5cbkZvbnRwYXRoUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKHgsIHksIHN0YXJ0LCBlbmQpIHtcbiAgICAvL25ldyBkYXRhIGZvciByZXN1bHRcbiAgICB0aGlzLmRhdGEuZ2x5cGhzLmxlbmd0aCA9IDBcbiAgICB0aGlzLmRhdGEudW5kZXJsaW5lcy5sZW5ndGggPSAwXG4gICAgQmFzZS5wcm90b3R5cGUucmVuZGVyLmNhbGwodGhpcywgeCwgeSwgc3RhcnQsIGVuZClcbiAgICByZXR1cm4gdGhpcy5kYXRhXG59XG5cbmZ1bmN0aW9uIEdseXBoKGluZGV4LCBnbHlwaCwgY2hhckNvZGUsIHNjYWxlLCBwb3NpdGlvbikge1xuICAgIHRoaXMuZ2x5cGggPSBnbHlwaFxuICAgIHRoaXMuaW5kZXggPSBpbmRleFxuICAgIHRoaXMuY2hhckNvZGUgPSBjaGFyQ29kZVxuICAgIHRoaXMucG9zaXRpb24gPSBwb3NpdGlvblxuICAgIHRoaXMuc2NhbGUgPSBzY2FsZVxufVxuXG5mdW5jdGlvbiBVbmRlcmxpbmUocG9zaXRpb24sIHNpemUpIHtcbiAgICB0aGlzLnBvc2l0aW9uID0gcG9zaXRpb25cbiAgICB0aGlzLnNpemUgPSBzaXplXG59XG5cbm1vZHVsZS5leHBvcnRzID0gRm9udHBhdGhSZW5kZXJlciIsInZhciBHbHlwaEl0ZXJhdG9yID0gcmVxdWlyZSgnZm9udHBhdGgtZ2x5cGgtaXRlcmF0b3InKTtcbnZhciBXb3JkV3JhcCA9IHJlcXVpcmUoJ2ZvbnRwYXRoLXdvcmR3cmFwJyk7XG5cbnZhciB0bXBCb3VuZHMgPSB7IHg6IDAsIHk6IDAsIHdpZHRoOiAwLCBoZWlnaHQ6IDAsIGdseXBoczogMCB9O1xuXG5mdW5jdGlvbiBUZXh0UmVuZGVyZXIob3B0aW9ucykge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBUZXh0UmVuZGVyZXIpKVxuICAgICAgICByZXR1cm4gbmV3IFRleHRSZW5kZXJlcihvcHRpb25zKTtcbiAgICBvcHRpb25zID0gb3B0aW9uc3x8e31cblxuICAgIHRoaXMuaXRlcmF0b3IgPSBuZXcgR2x5cGhJdGVyYXRvcihvcHRpb25zLmZvbnQsIG9wdGlvbnMuZm9udFNpemUpO1xuICAgIHRoaXMud29yZHdyYXAgPSBuZXcgV29yZFdyYXAoKTtcblxuICAgIHRoaXMuYWxpZ24gPSAnbGVmdCc7XG4gICAgdGhpcy51bmRlcmxpbmUgPSBmYWxzZTtcblxuICAgIHRoaXMudW5kZXJsaW5lVGhpY2tuZXNzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMudW5kZXJsaW5lUG9zaXRpb24gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fdGV4dCA9IFwiXCI7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuYWxpZ24gPT09ICdzdHJpbmcnKVxuICAgICAgICB0aGlzLmFsaWduID0gb3B0aW9ucy5hbGlnbjtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMudW5kZXJsaW5lID09PSAnYm9vbGVhbicpXG4gICAgICAgIHRoaXMudW5kZXJsaW5lID0gb3B0aW9ucy51bmRlcmxpbmU7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnVuZGVybGluZVRoaWNrbmVzcyA9PT0gJ251bWJlcicpXG4gICAgICAgIHRoaXMudW5kZXJsaW5lVGhpY2tuZXNzID0gb3B0aW9ucy51bmRlcmxpbmVUaGlja25lc3M7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnVuZGVybGluZVBvc2l0aW9uID09PSAnbnVtYmVyJylcbiAgICAgICAgdGhpcy51bmRlcmxpbmVQb3NpdGlvbiA9IG9wdGlvbnMudW5kZXJsaW5lUG9zaXRpb247XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnRleHQgPT09ICdzdHJpbmcnKVxuICAgICAgICB0aGlzLnRleHQgPSBvcHRpb25zLnRleHQ7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmxpbmVIZWlnaHQgPT09ICdudW1iZXInKVxuICAgICAgICB0aGlzLmxpbmVIZWlnaHQgPSBvcHRpb25zLmxpbmVIZWlnaHQ7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmxldHRlclNwYWNpbmcgPT09ICdudW1iZXInKVxuICAgICAgICB0aGlzLmxldHRlclNwYWNpbmcgPSBvcHRpb25zLmxldHRlclNwYWNpbmc7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLndyYXBNb2RlID09PSAnc3RyaW5nJylcbiAgICAgICAgdGhpcy53b3Jkd3JhcC5tb2RlID0gb3B0aW9ucy53cmFwTW9kZTtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMud3JhcFdpZHRoID09PSAnbnVtYmVyJylcbiAgICAgICAgdGhpcy5sYXlvdXQob3B0aW9ucy53cmFwV2lkdGgpO1xufVxuXG4vL0ludGVybmFsbHkgd2Ugd2lsbCB1c2UgaW50ZWdlcnMgdG8gYXZvaWQgc3RyaW5nIGNvbXBhcmlzb24gZm9yIGVhY2ggZ2x5cGhcbnZhciBMRUZUX0FMSUdOID0gMCwgQ0VOVEVSX0FMSUdOID0gMSwgUklHSFRfQUxJR04gPSAyO1xudmFyIEFMSUdOX0FSUkFZID0gW1xuICAgICdsZWZ0JywgXG4gICAgJ2NlbnRlcicsIFxuICAgICdyaWdodCdcbl07XG4gICAgXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhUZXh0UmVuZGVyZXIucHJvdG90eXBlLCB7XG4gICAgLyoqXG4gICAgICogSWYgdGhlIG5ldyBmb250IGRpZmZlcnMgZnJvbSB0aGUgbGFzdCwgdGhlIHRleHQgbGF5b3V0IGlzIGNsZWFyZWRcbiAgICAgKiBhbmQgcGxhY2VkIG9udG8gYSBzaW5nbGUgbGluZS4gVXNlcnMgbXVzdCBtYW51YWxseSByZS1sYXlvdXQgdGhlIHRleHQgXG4gICAgICogZm9yIHdvcmQgd3JhcHBpbmcuXG4gICAgICovXG4gICAgXCJmb250XCI6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZXJhdG9yLmZvbnQ7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICB2YXIgb2xkRm9udCA9IHRoaXMuaXRlcmF0b3IuZm9udDtcbiAgICAgICAgICAgIHRoaXMuaXRlcmF0b3IuZm9udCA9IHZhbDtcbiAgICAgICAgICAgIGlmIChvbGRGb250ICE9PSB0aGlzLml0ZXJhdG9yLmZvbnQpXG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhckxheW91dCgpO1xuICAgICAgICB9LFxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJZiB0aGUgbmV3IGZvbnQgc2l6ZSBkaWZmZXJzIGZyb20gdGhlIGxhc3QsIHRoZSB0ZXh0IGxheW91dCBpcyBjbGVhcmVkXG4gICAgICogYW5kIHBsYWNlZCBvbnRvIGEgc2luZ2xlIGxpbmUuIFVzZXJzIG11c3QgbWFudWFsbHkgcmUtbGF5b3V0IHRoZSB0ZXh0IFxuICAgICAqIGZvciB3b3JkIHdyYXBwaW5nLlxuICAgICAqL1xuICAgIFwiZm9udFNpemVcIjoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXRlcmF0b3IuZm9udFNpemU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICB2YXIgb2xkU2l6ZSA9IHRoaXMuaXRlcmF0b3IuZm9udFNpemU7XG5cbiAgICAgICAgICAgIHRoaXMuaXRlcmF0b3IuZm9udFNpemUgPSB2YWw7XG5cbiAgICAgICAgICAgIGlmIChvbGRTaXplICE9PSB0aGlzLml0ZXJhdG9yLmZvbnRTaXplKVxuICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJMYXlvdXQoKTtcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIFwibGluZUhlaWdodFwiOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pdGVyYXRvci5saW5lSGVpZ2h0O1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICAgICAgdGhpcy5pdGVyYXRvci5saW5lSGVpZ2h0ID0gdmFsO1xuICAgICAgICB9LFxuICAgIH0sXG4gICAgXCJsZXR0ZXJTcGFjaW5nXCI6IHtcbiAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pdGVyYXRvci5sZXR0ZXJTcGFjaW5nO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICAgICAgdGhpcy5pdGVyYXRvci5sZXR0ZXJTcGFjaW5nID0gdmFsO1xuICAgICAgICB9LFxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJZiB0aGUgbmV3IHRleHQgaXMgZGlmZmVyZW50IGZyb20gdGhlIGxhc3QsIHRoZSBsYXlvdXQgKGkuZS4gd29yZC13cmFwcGluZylcbiAgICAgKiBpcyBjbGVhcmVkIGFuZCB0aGUgcmVzdWx0IGlzIGEgc2luZ2xlIGxpbmUgb2YgdGV4dCAoc2ltaWxhciB0byBIVE1MNSBjYW52YXMgdGV4dFxuICAgICAqIHJlbmRlcmluZykuXG4gICAgICogXG4gICAgICogVGhlIHRleHQgdGhlbiBuZWVkcyB0byBiZSByZS13b3Jkd3JhcHBlZCB3aXRoIGEgY2FsbCB0byBgbGF5b3V0KClgLlxuICAgICAqL1xuICAgIFwidGV4dFwiOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdGV4dDtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgICAgICAgIHRleHQgPSB0ZXh0fHxcIlwiO1xuXG4gICAgICAgICAgICB2YXIgb2xkID0gdGhpcy5fdGV4dDtcbiAgICAgICAgICAgIHRoaXMuX3RleHQgPSB0ZXh0O1xuICAgICAgICAgICAgdGhpcy53b3Jkd3JhcC50ZXh0ID0gdGhpcy50ZXh0O1xuXG4gICAgICAgICAgICBpZiAodGhpcy5fdGV4dCAhPT0gb2xkKSBcbiAgICAgICAgICAgICAgICB0aGlzLmNsZWFyTGF5b3V0KCk7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuLyoqXG4gKiBDbGVhcnMgdGhlIHRleHQgbGF5b3V0IGFuZCB3b3JkLXdyYXBwaW5nLCBwbGFjaW5nIGFsbCBvZiBpdCBvbiBhIHNpbmdsZSBsaW5lLlxuICovXG5UZXh0UmVuZGVyZXIucHJvdG90eXBlLmNsZWFyTGF5b3V0ID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy53b3Jkd3JhcC50ZXh0ID0gdGhpcy50ZXh0O1xuICAgIHRoaXMud29yZHdyYXAuZW1wdHkoKTtcblxuICAgIGlmICh0aGlzLml0ZXJhdG9yLmZvbnQpIC8vZm9udCBtaWdodCBub3QgaGF2ZSBiZWVuIHBhc3NlZCBhdCBjb25zdHJ1Y3RvclxuICAgICAgICB0aGlzLndvcmR3cmFwLmNsZWFyTGF5b3V0KHRoaXMuaXRlcmF0b3IpO1xufTtcblxuLyoqXG4gKiBDYWxscyB0aGUgd29yZCB3cmFwcGVyIHRvIGxheW91dCB0aGUgY3VycmVudCB0ZXh0IHN0cmluZyxcbiAqIGJhc2VkIG9uIHRoZSB3cmFwIHdpZHRoIGFuZCBhbnkgY3VycmVudCB3b3Jkd3JhcHBpbmcgb3B0aW9ucy5cbiAqXG4gKiBUaGlzIGlzIGNhbGxlZCB3aGVuIHRoZSB0ZXh0IGlzIGNoYW5nZWQuIFxuICogXG4gKiBAcmV0dXJuIHtbdHlwZV19IFtkZXNjcmlwdGlvbl1cbiAqL1xuVGV4dFJlbmRlcmVyLnByb3RvdHlwZS5sYXlvdXQgPSBmdW5jdGlvbih3cmFwV2lkdGgpIHtcbiAgICB0aGlzLndvcmR3cmFwLnRleHQgPSB0aGlzLnRleHQ7XG4gICAgdGhpcy53b3Jkd3JhcC5lbXB0eSgpO1xuICAgIHRoaXMud29yZHdyYXAubGF5b3V0KHRoaXMuaXRlcmF0b3IsIHdyYXBXaWR0aCk7XG59O1xuXG4vKipcbiAqIFwiUmVuZGVyc1wiIHRoaXMgZ2x5cGggYXQgdGhlIGdpdmVuIGxvY2F0aW9uLiBUaGlzIG1heSBpbnZvbHZlIGZpbGxpbmdcbiAqIGEgVkJPIHdpdGggdmVydGV4IGRhdGEsIG9yIGl0IG1heSBiZSBhIGRpcmVjdCBjYWxsIHRvIGRyYXcgYSBiaXRtYXAgZ2x5cGhcbiAqIG9yIHNoYXBlIG91dGxpbmUuXG4gKiBAcmV0dXJuIHtbdHlwZV19IFtkZXNjcmlwdGlvbl1cbiAqL1xuVGV4dFJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJHbHlwaCA9IGZ1bmN0aW9uKCkge1xuXG59O1xuXG5UZXh0UmVuZGVyZXIucHJvdG90eXBlLnJlbmRlclVuZGVybGluZSA9IGZ1bmN0aW9uKCkge1xuXG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGJvdW5kcyBvZiB0aGUgY3VycmVudCB0ZXh0IGxheW91dC4gXG4gKlxuICogVGhlIGhlaWdodCBkb2VzIG5vdCBleHRlbmQgcGFzdCB0aGUgYmFzZWxpbmUgb2YgdGhlXG4gKiBsYXN0IGxpbmU7IHVubGVzcyBgaW5jbHVkZVVuZGVybGluZWAgaXMgdHJ1ZSwgaW4gd2hpY2hcbiAqIGNhc2UgdGhlIHVuZGVybGluZSdzIHBvc2l0aW9uIGFuZCBoZWlnaHQgaXMgaW5jbHVkZWRcbiAqIGluIHRoZSBjYWxjdWxhdGlvbi4gXG4gKlxuICogVGhlIGJvdW5kaW5nIHkgcG9zaXRpb24gaXMgb2Zmc2V0IHNvIHRoYXQgdGhlIGJveCBoYXMgYW4gdXBwZXItbGVmdFxuICogb3JpZ2luLCBmb3IgcGFyaXR5IHdpdGggSFRNTDUgY2FudmFzIHJlbmRlcmluZy5cbiAqIFxuICogQHBhcmFtIHtCb29sZWFufSBpbmNsdWRlVW5kZXJsaW5lIHdoZXRoZXIgdG8gaW5jbHVkZSB0aGUgdW5kZXJsaW5lIGluIHRoZSBjYWxjdWxhdGlvbiwgZGVmYXVsdCBmYWxzZVxuICogQHBhcmFtIHtPYmplY3R9IG91dCBhbiBvcHRpb25hbCB7d2lkdGgsIGhlaWdodH0gb2JqZWN0IGZvciByZS11c2VcbiAqIEByZXR1cm4ge09iamVjdH0gYSBzaXplIHdpdGggeyB3aWR0aCwgaGVpZ2h0IH0gcHJvcGVydGllc1xuICovXG5UZXh0UmVuZGVyZXIucHJvdG90eXBlLmdldEJvdW5kcyA9IGZ1bmN0aW9uIChpbmNsdWRlVW5kZXJsaW5lLCBvdXQpIHtcbiAgICBpZiAoIW91dClcbiAgICAgICAgb3V0ID0geyB4OiAwLCB5OiAwLCB3aWR0aDogMCwgaGVpZ2h0OiAwIH07XG5cbiAgICB2YXIgd29yZHdyYXBwZXIgPSB0aGlzLndvcmR3cmFwO1xuICAgIHZhciBpdHIgPSB0aGlzLml0ZXJhdG9yO1xuXG4gICAgLy90aWdodGVuIHRoZSBib3VuZGluZyBib3ggYXJvdW5kIHRoZSBmaXJzdCBsaW5lLi5cbiAgICB2YXIgZmlyc3RMaW5lSGVpZ2h0ID0gMDtcbiAgICBpZiAod29yZHdyYXBwZXIubGluZXMubGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgZmlyc3RMaW5lID0gd29yZHdyYXBwZXIubGluZXNbMF07XG4gICAgICAgIGl0ci5nZXRCb3VuZHModGhpcy50ZXh0LCBmaXJzdExpbmUuc3RhcnQsIGZpcnN0TGluZS5lbmQsIHVuZGVmaW5lZCwgdG1wQm91bmRzKTtcbiAgICAgICAgZmlyc3RMaW5lSGVpZ2h0ID0gdG1wQm91bmRzLmhlaWdodDtcbiAgICB9XG5cbiAgICBvdXQud2lkdGggPSB3b3Jkd3JhcHBlci5nZXRNYXhMaW5lV2lkdGgoKTsgICBcbiAgICBvdXQuaGVpZ2h0ID0gTWF0aC5tYXgoMCwgd29yZHdyYXBwZXIubGluZXMubGVuZ3RoLTEpICogaXRyLmdldExpbmVHYXAoKSArIGZpcnN0TGluZUhlaWdodDtcblxuICAgIG91dC54ID0gMDtcbiAgICBvdXQueSA9IC1vdXQuaGVpZ2h0O1xuXG4gICAgaWYgKGluY2x1ZGVVbmRlcmxpbmUpIHtcbiAgICAgICAgdmFyIHVuZGVybGluZUhlaWdodCA9IHRoaXMuY29tcHV0ZVVuZGVybGluZUhlaWdodCgpO1xuICAgICAgICB2YXIgdW5kZXJsaW5lUG9zaXRpb24gPSB0aGlzLmNvbXB1dGVVbmRlcmxpbmVQb3NpdGlvbigpO1xuICAgICAgICB2YXIgdW5kZXJsaW5lT2ZmID0gdW5kZXJsaW5lUG9zaXRpb24rdW5kZXJsaW5lSGVpZ2h0LzI7XG4gICAgICAgIG91dC5oZWlnaHQgKz0gdW5kZXJsaW5lT2ZmO1xuICAgIH1cblxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBzY2FsZWQgdW5kZXJsaW5lIGhlaWdodCBhcyBwaXhlbHMsIGJhc2VkIG9uIFxuICogdGhlIGV4cGxpY2l0IGB1bmRlcmxpbmVIZWlnaHRgIChpbiBwaXhlbHMpLiBJZiBgdW5kZXJsaW5lSGVpZ2h0YCBpc1xuICogdW5kZWZpbmVkIG9yIG51bGwsIGl0IHdpbGwgdHJ5IHRvIHVzZSB0aGUgZm9udCdzIG5vbi16ZXJvIHVuZGVybGluZSBoZWlnaHQsIFxuICogb3RoZXJ3aXNlIGRlZmF1bHQgdG8gMS84IG9mIHRoZSBmb250J3MgRU0gc3F1YXJlLlxuICogXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IHRoZSBwaXhlbCBoZWlnaHQgb2YgdGhlIHVuZGVybGluZSBcbiAqL1xuVGV4dFJlbmRlcmVyLnByb3RvdHlwZS5jb21wdXRlVW5kZXJsaW5lSGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBmb250ID0gdGhpcy5mb250O1xuICAgIHZhciBzY2FsZSA9IHRoaXMuaXRlcmF0b3IuZm9udFNjYWxlO1xuICAgIGlmICh0aGlzLnVuZGVybGluZVRoaWNrbmVzcz09PTB8fHRoaXMudW5kZXJsaW5lVGhpY2tuZXNzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVuZGVybGluZVRoaWNrbmVzczsgXG4gICAgfSBlbHNlIGlmIChmb250LnVuZGVybGluZV90aGlja25lc3MpIHtcbiAgICAgICAgcmV0dXJuIGZvbnQudW5kZXJsaW5lX3RoaWNrbmVzcyAqIHNjYWxlOyBcbiAgICB9IGVsc2UgaWYgKGZvbnQuYml0bWFwKVxuICAgICAgICByZXR1cm4gZm9udC5zaXplLzg7XG4gICAgZWxzZVxuICAgICAgICByZXR1cm4gKGZvbnQudW5pdHNfcGVyX0VNLzgpKnNjYWxlO1xufTtcblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgc2NhbGVkIHVuZGVybGluZSBoZWlnaHQgYXMgcGl4ZWxzLCBiYXNlZCBvbiBcbiAqIHRoZSBleHBsaWNpdCBgdW5kZXJsaW5lUG9zaXRpb25gIChpbiBwaXhlbHMpLiBJZiBgdW5kZXJsaW5lUG9zaXRpb25gIGlzXG4gKiB1bmRlZmluZWQgb3IgbnVsbCwgaXQgd2lsbCB0cnkgdG8gdXNlIHRoZSBmb250J3Mgbm9uLXplcm8gdW5kZXJsaW5lIHBvc2l0aW9uLCBcbiAqIG90aGVyd2lzZSBkZWZhdWx0IHRvIDEvNCBvZiB0aGUgZm9udCdzIEVNIHNxdWFyZS5cbiAqXG4gKiBUaGlzIGlzIHRoZSBZIG9mZnNldCBmcm9tIHRoZSB0ZXh0IGJhc2VsaW5lIHRvIHRoZSBjZW50ZXIgb2YgdGhlIHVuZGVybGluZSBcbiAqIGJhciwgaW4gcGl4ZWxzLiBJdCBpcyBnZW5lcmFsbHkgYSBwb3NpdGl2ZSB2YWx1ZS5cbiAqIFxuICogQHJldHVybiB7TnVtYmVyfSB0aGUgcGl4ZWwgcG9zaXRpb24gb2YgdGhlIHVuZGVybGluZSBcbiAqL1xuVGV4dFJlbmRlcmVyLnByb3RvdHlwZS5jb21wdXRlVW5kZXJsaW5lUG9zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGZvbnQgPSB0aGlzLmZvbnQ7XG4gICAgdmFyIHNjYWxlID0gdGhpcy5pdGVyYXRvci5mb250U2NhbGU7XG4gICAgICAgIFxuICAgIGlmICh0aGlzLnVuZGVybGluZVBvc2l0aW9uPT09MHx8dGhpcy51bmRlcmxpbmVQb3NpdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy51bmRlcmxpbmVQb3NpdGlvbjsgXG4gICAgfSBlbHNlIGlmIChmb250LnVuZGVybGluZV9wb3NpdGlvbikge1xuICAgICAgICByZXR1cm4gLWZvbnQudW5kZXJsaW5lX3Bvc2l0aW9uICogc2NhbGU7IFxuICAgIH0gZWxzZSBpZiAoZm9udC5iaXRtYXApIHtcbiAgICAgICAgcmV0dXJuIGZvbnQuc2l6ZS80O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAoZm9udC51bml0c19wZXJfRU0vNCkqc2NhbGU7XG4gICAgfVxufTtcblxuLyoqXG4gKiBHZXRzIHRoZSBkZXNjZW50IG9mIHRoZSBjdXJyZW50IGZvbnQgKGFzc3VtZXMgaXRzIHNpemUgXG4gKiBpcyBhbHJlYWR5IHNldCkuIFRoaXMgaXMgYW4gYWJzb2x1dGUgKHBvc2l0aXZlKSB2YWx1ZS5cbiAqIFxuICogQHJldHVybiB7W3R5cGVdfSBbZGVzY3JpcHRpb25dXG4gKi9cblRleHRSZW5kZXJlci5wcm90b3R5cGUuZ2V0RGVzY2VuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBNYXRoLmFicyh0aGlzLml0ZXJhdG9yLmZvbnRTY2FsZSAqIHRoaXMuaXRlcmF0b3IuZm9udC5kZXNjZW5kZXIpO1xufTtcblxuLyoqXG4gKiBHZXRzIHRoZSBkZXNjZW50IG9mIHRoZSBjdXJyZW50IGZvbnQgKGFzc3VtZXMgaXRzIHNpemUgXG4gKiBpcyBhbHJlYWR5IHNldCkuIFRoaXMgaXMgYW4gYWJzb2x1dGUgKHBvc2l0aXZlKSB2YWx1ZS5cbiAqIFxuICogQHJldHVybiB7W3R5cGVdfSBbZGVzY3JpcHRpb25dXG4gKi9cblRleHRSZW5kZXJlci5wcm90b3R5cGUuZ2V0QXNjZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIE1hdGguYWJzKHRoaXMuaXRlcmF0b3IuZm9udFNjYWxlICogdGhpcy5pdGVyYXRvci5mb250LmFzY2VuZGVyKTtcbn07XG5cbi8vU2lnbmFscyBmb3Igc3ViY2xhc3NlcyB0byBvcHRpb25hbGx5IGltcGxtZWVudFxuLy9UaGlzIG1heSBiZSB1c2VmdWwgdG8gc3RvcC9zdGFydCBwYXRocyB3aXRoIGRpZmZlcmVudCBmaWxsc1xuVGV4dFJlbmRlcmVyLnByb3RvdHlwZS5vbkJlZ2luID0gZnVuY3Rpb24oKSB7IH1cblRleHRSZW5kZXJlci5wcm90b3R5cGUub25FbmQgPSBmdW5jdGlvbigpIHsgfVxuVGV4dFJlbmRlcmVyLnByb3RvdHlwZS5vbkJlZ2luTGluZSA9IGZ1bmN0aW9uKGxpbmVJbmRleCkgeyB9XG5UZXh0UmVuZGVyZXIucHJvdG90eXBlLm9uRW5kTGluZSA9IGZ1bmN0aW9uKGxpbmVJbmRleCkgeyB9XG5cbi8qKlxuICogUmVuZGVycyB0aGUgY3VycmVudCB0ZXh0IGxheW91dCwgd2hlcmUgbG93ZXItbGVmdCBpcyBcbiAqIHRoZSBvcmlnaW4uIE11bHRpcGxlIGxpbmVzIHdpbGwgYmUgcG9zaXRpb25lZCBhYm92ZSB0aGVcbiAqIG9yaWdpbi5cbiAqL1xuVGV4dFJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoeCwgeSwgc3RhcnQsIGVuZCkge1xuICAgIHggPSB4fHwwO1xuICAgIHkgPSB5fHwwO1xuXG4gICAgdmFyIHRleHQgPSB0aGlzLnRleHQ7XG4gICAgdmFyIHdvcmR3cmFwcGVyID0gdGhpcy53b3Jkd3JhcDtcblxuICAgIC8vaWYgd2UgaGF2ZSBub3RoaW5nIHRvIGRyYXdcbiAgICBpZiAoIXRleHQgfHwgd29yZHdyYXBwZXIubGluZXMubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm47XG5cbiAgICAvL2RlZmF1bHQgc3RhcnQvZW5kIHBhcmFtc1xuICAgIHN0YXJ0ID0gc3RhcnR8fDA7XG4gICAgZW5kID0gdHlwZW9mIGVuZCA9PT0gXCJudW1iZXJcIiA/IGVuZCA6IHRleHQubGVuZ3RoO1xuXG4gICAgdmFyIGl0ciA9IHRoaXMuaXRlcmF0b3I7XG4gICAgdmFyIHNjYWxlID0gaXRyLmZvbnRTY2FsZTtcbiAgICB2YXIgZm9udCA9IGl0ci5mb250O1xuICAgIHZhciB1bmRlcmxpbmUgPSB0aGlzLnVuZGVybGluZTtcblxuICAgIC8vdXNlZCBmb3IgYWxpZ25tZW50Li4uXG4gICAgdmFyIG1heExpbmVXaWR0aCA9IHdvcmR3cmFwcGVyLmdldE1heExpbmVXaWR0aCgpO1xuICAgIFxuICAgIHkgLT0gTWF0aC5tYXgoMCwgd29yZHdyYXBwZXIubGluZXMubGVuZ3RoLTEpICogaXRyLmdldExpbmVHYXAoKTtcblxuXG4gICAgLy91c2UgbnVtYmVycyB0byBhdm9pZCBzdHIgY29tcGFyZSBmb3IgZWFjaCBnbHlwaFxuICAgIHZhciBhbGlnblR5cGUgPSBBTElHTl9BUlJBWS5pbmRleE9mKHRoaXMuYWxpZ258fFwiXCIpO1xuICAgIGlmIChhbGlnblR5cGU9PT0tMSlcbiAgICAgICAgYWxpZ25UeXBlID0gTEVGVF9BTElHTjtcblxuICAgIHZhciB1bmRlcmxpbmVYID0gMDtcbiAgICB2YXIgdW5kZXJsaW5lU3RhcnRYID0gMDtcbiAgICB2YXIgdW5kZXJsaW5lWSA9IDA7XG4gICAgdmFyIHVuZGVybGluZVdpZHRoID0gMDtcblxuICAgIHZhciB1bmRlcmxpbmVTdGFydGVkID0gZmFsc2U7XG5cbiAgICAvL1RyeSB0byB1c2UgdXNlci1zcGVjaWZpZWQgdW5kZXJsaW5lIHNldHRpbmdzLCBvdGhlcndpc2UgdXNlIHRoZSBmb250IGlmIHBvc3NpYmxlLFxuICAgIC8vb3RoZXJ3aXNlIGp1c3QgdXNlIGEgcm91Z2ggZGVmYXVsdCBiYXNlZCBvbiBFTSBzcXVhcmUuICAgIFxuICAgIHZhciB1bmRlcmxpbmVQb3MgPSB0aGlzLmNvbXB1dGVVbmRlcmxpbmVQb3NpdGlvbigpO1xuICAgIHZhciB1bmRlcmxpbmVIZWlnaHQgPSB0aGlzLmNvbXB1dGVVbmRlcmxpbmVIZWlnaHQoKTtcblxuICAgIHRoaXMub25CZWdpbigpO1xuICAgIFxuICAgIC8vc2V0IHRoZSBvcmlnaW4gYW5kIHBlbiBwb3NpdGlvblxuICAgIGl0ci5iZWdpbih4LCB5KTtcbiAgICBmb3IgKHZhciBrPTA7IGs8d29yZHdyYXBwZXIubGluZXMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgdmFyIGxpbmUgPSB3b3Jkd3JhcHBlci5saW5lc1trXTtcbiAgICAgICAgdW5kZXJsaW5lU3RhcnRlZCA9IGZhbHNlO1xuXG4gICAgICAgIHZhciBsYXN0QWR2YW5jZSA9IDA7XG5cbiAgICAgICAgdmFyIGxpbmVYID0gaXRyLnBlbi54O1xuICAgICAgICB2YXIgbGluZVkgPSBpdHIucGVuLnk7XG5cbiAgICAgICAgdGhpcy5vbkJlZ2luTGluZShrKTtcblxuICAgICAgICAvL1RPRE86IHVzZSBtdWx0aXBsZSBOb2RlcyBpbnNpZGUgYSBzaW5nbGUgbGluZVxuICAgICAgICAvL2Egbm9kZSB3aWxsIGhhdmUgYXR0cmlidXRlcyBsaWtlIGZvbnQsIHNpemUsIGNvbG9yLCBcbiAgICAgICAgLy9sZXR0ZXItc3BhY2luZywgdW5kZXJsaW5lLCBldGMuXG4gICAgICAgIC8vVGhpcyB3aWxsIGFmZmVjdCB0aGUgbGluZSBoZWlnaHQsIGFzIGl0IHdpbGwgaGF2ZSB0byBiZSB0aGUgbWF4IG9mIGFsbCBub2Rlcy5cblxuICAgICAgICBmb3IgKHZhciBpPWxpbmUuc3RhcnQ7IGk8bGluZS5lbmQ7IGkrKykge1xuICAgICAgICAgICAgdmFyIGNociA9IHRleHQuY2hhckF0KGkpO1xuXG4gICAgICAgICAgICAvL1N0ZXAgdGhlIGl0ZXJhdG9yLCBtb3ZpbmcgZm9yd2FyZCBiYXNlZCBvbiBrZXJuaW5nIGZyb20gbGFzdCBjaGFyXG4gICAgICAgICAgICB2YXIgZ2x5cGggPSBpdHIuc3RlcCh0ZXh0LCBpKTtcblxuICAgICAgICAgICAgaWYgKCFnbHlwaClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAgICAgLy93aXRoaW4gZGVzaXJlZCByYW5nZVxuICAgICAgICAgICAgaWYgKGkgPj0gc3RhcnQgJiYgaSA8IGVuZCkge1xuICAgICAgICAgICAgICAgIHZhciB0eCA9IGl0ci5wZW4ueDtcbiAgICAgICAgICAgICAgICB2YXIgdHkgPSBpdHIucGVuLnk7XG5cbiAgICAgICAgICAgICAgICBpZiAoYWxpZ25UeXBlID09PSBDRU5URVJfQUxJR04pIHtcbiAgICAgICAgICAgICAgICAgICAgdHggKz0gKG1heExpbmVXaWR0aC1saW5lLndpZHRoKS8yO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYWxpZ25UeXBlID09PSBSSUdIVF9BTElHTikge1xuICAgICAgICAgICAgICAgICAgICB0eCArPSAobWF4TGluZVdpZHRoLWxpbmUud2lkdGgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghdW5kZXJsaW5lU3RhcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICB1bmRlcmxpbmVYID0gdHg7XG4gICAgICAgICAgICAgICAgICAgIHVuZGVybGluZVN0YXJ0WCA9IHR4O1xuICAgICAgICAgICAgICAgICAgICB1bmRlcmxpbmVZID0gdHkgKyB1bmRlcmxpbmVQb3M7XG4gICAgICAgICAgICAgICAgICAgIHVuZGVybGluZVdpZHRoID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdW5kZXJsaW5lU3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdW5kZXJsaW5lV2lkdGggPSB0eCAtIHVuZGVybGluZVN0YXJ0WDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlckdseXBoKGksIGdseXBoLCBzY2FsZSwgdHgsIHR5KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9BZHZhbmNlIHRoZSBpdGVyYXRvciB0byB0aGUgbmV4dCBnbHlwaCBpbiB0aGUgc3RyaW5nXG4gICAgICAgICAgICB2YXIgbmV3QWR2YW5jZSA9IGl0ci5hZHZhbmNlKGdseXBoKTtcblxuICAgICAgICAgICAgaWYgKGkgPj0gc3RhcnQgJiYgaSA8IGVuZClcbiAgICAgICAgICAgICAgICBsYXN0QWR2YW5jZSA9IG5ld0FkdmFuY2U7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm9uRW5kTGluZShrKTtcblxuICAgICAgICBpZiAodW5kZXJsaW5lKSB7XG4gICAgICAgICAgICB1bmRlcmxpbmVXaWR0aCArPSBsYXN0QWR2YW5jZTtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyVW5kZXJsaW5lKHVuZGVybGluZVgsIHVuZGVybGluZVktdW5kZXJsaW5lSGVpZ2h0LzIsIHVuZGVybGluZVdpZHRoLCB1bmRlcmxpbmVIZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvL1N0ZXBzIGRvd24gYSBsaW5lLi4uXG4gICAgICAgIGlmIChrIDwgd29yZHdyYXBwZXIubGluZXMubGVuZ3RoLTEpIHtcbiAgICAgICAgICAgIGl0ci5hZHZhbmNlTGluZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy9maW5pc2ggdGhlIGl0ZXJhdG9yLi4uXG4gICAgaXRyLmVuZCgpO1xuICAgIHRoaXMub25FbmQoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVGV4dFJlbmRlcmVyOyIsInZhciB1dGlsID0gcmVxdWlyZSgnZm9udHBhdGgtdXRpbCcpO1xuXG52YXIgREVGQVVMVF9UQUJfV0lEVEggPSA0O1xuXG5mdW5jdGlvbiBHbHlwaEl0ZXJhdG9yKGZvbnQsIGZvbnRTaXplKSB7XG4gICAgdGhpcy5fZm9udFNpemUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fZm9udFNjYWxlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2ZvbnQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5mb250U2NhbGUgPSAxLjA7XG4gICAgdGhpcy5rZXJuaW5nID0gdHJ1ZTtcbiAgICB0aGlzLmxldHRlclNwYWNpbmcgPSAwO1xuICAgIHRoaXMubGluZUhlaWdodCA9IHVuZGVmaW5lZDtcbiAgICBcbiAgICB0aGlzLmZvbnRTaXplID0gdHlwZW9mIGZvbnRTaXplID09PSAnbnVtYmVyJ1xuICAgICAgICAgICAgPyBmb250U2l6ZVxuICAgICAgICAgICAgOiAoZm9udCA/IGZvbnQuc2l6ZSA6IHVuZGVmaW5lZCk7XG4gICAgdGhpcy5mb250ID0gZm9udDtcblxuICAgIC8vTnVtYmVyIG9mIHNwYWNlcyBmb3IgYSB0YWIgY2hhcmFjdGVyXG4gICAgdGhpcy50YWJXaWR0aCA9IERFRkFVTFRfVEFCX1dJRFRIO1xuICAgIHRoaXMuX3RhYkdseXBoID0gbnVsbDtcblxuICAgIHRoaXMub3JpZ2luID0geyB4OiAwLCB5OiAwIH07XG4gICAgdGhpcy5wZW4gPSB7IHg6IDAsIHk6IDAgfTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEdseXBoSXRlcmF0b3IucHJvdG90eXBlLCBcImZvbnRcIiwge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9mb250O1xuICAgIH0sXG5cbiAgICBzZXQ6IGZ1bmN0aW9uKGZvbnQpIHtcbiAgICAgICAgdGhpcy5fZm9udCA9IGZvbnQ7XG5cbiAgICAgICAgLy9EZXRlcm1pbmUgdGhlIG5ldyBzY2FsaW5nIGZhY3Rvci4uLlxuICAgICAgICBpZiAoZm9udCkge1xuICAgICAgICAgICAgdGhpcy5mb250U2NhbGUgPSB1dGlsLmdldFB4U2NhbGUoZm9udCwgdGhpcy5mb250U2l6ZSk7XG5cbiAgICAgICAgICAgIC8vVXBkYXRlcyB0aGUgdGFiIGdseXBoXG4gICAgICAgICAgICB0aGlzLnRhYldpZHRoID0gdGhpcy5fdGFiV2lkdGg7XG4gICAgICAgIH1cbiAgICB9LFxufSk7XG5cbi8vVGhlcmUgbWlnaHQgYmUgYSBiZXR0ZXIgd2F5IG9mIGhhbmRsaW5nIHRhYiB3aWR0aCB1c2luZyBGcmVlVHlwZSA/IFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEdseXBoSXRlcmF0b3IucHJvdG90eXBlLCBcInRhYldpZHRoXCIsIHtcblxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90YWJXaWR0aDtcbiAgICB9LFxuXG4gICAgc2V0OiBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgdGhpcy5fdGFiV2lkdGggPSB2YWw9PT0wIHx8IHZhbCA/IHZhbCA6IERFRkFVTFRfVEFCX1dJRFRIO1xuICAgICAgICB0aGlzLl90YWJHbHlwaCA9IHt9O1xuXG4gICAgICAgIHZhciBzcGFjZUdseXBoID0gdGhpcy5mb250ID8gdGhpcy5mb250LmdseXBoc1tcIiBcIl0gOiBudWxsO1xuICAgICAgICBpZiAoc3BhY2VHbHlwaCkge1xuICAgICAgICAgICAgdGhpcy5fdGFiR2x5cGggPSB7fTtcbiAgICAgICAgICAgIGZvciAodmFyIGsgaW4gc3BhY2VHbHlwaCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3RhYkdseXBoW2tdID0gc3BhY2VHbHlwaFtrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl90YWJHbHlwaC54b2ZmKVxuICAgICAgICAgICAgICAgIHRoaXMuX3RhYkdseXBoLnhvZmYgKj0gdGhpcy5fdGFiV2lkdGg7XG4gICAgICAgIH1cbiAgICB9LFxufSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShHbHlwaEl0ZXJhdG9yLnByb3RvdHlwZSwgXCJmb250U2l6ZVwiLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLl9mb250U2l6ZSAhPT0gJ251bWJlcicpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mb250LmJpdG1hcCBcbiAgICAgICAgICAgICAgICA/IHRoaXMuZm9udC5zaXplIFxuICAgICAgICAgICAgICAgIDogdXRpbC5wb2ludFRvUGl4ZWwodGhpcy5mb250LnNpemUpXG4gICAgICAgIHJldHVybiB0aGlzLl9mb250U2l6ZTtcbiAgICB9LFxuXG4gICAgc2V0OiBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgdGhpcy5fZm9udFNpemUgPSB2YWw7XG5cbiAgICAgICAgLy9JZiB0aGUgZm9udCBpcyBhbHJlYWR5IHNldCwgZGV0ZXJtaW5lIHRoZSBuZXcgc2NhbGluZyBmYWN0b3JcbiAgICAgICAgaWYgKHRoaXMuX2ZvbnQpIHtcbiAgICAgICAgICAgIHRoaXMuZm9udFNjYWxlID0gdXRpbC5nZXRQeFNjYWxlKHRoaXMuX2ZvbnQsIHRoaXMuX2ZvbnRTaXplKTtcbiAgICAgICAgfVxuICAgIH0sXG59KTtcblxuR2x5cGhJdGVyYXRvci5wcm90b3R5cGUuZ2V0S2VybmluZyA9IGZ1bmN0aW9uKGxlZnQsIHJpZ2h0KSB7XG4gICAgdmFyIGZvbnQgPSB0aGlzLmZvbnQ7XG5cbiAgICBpZiAoIWZvbnQgfHwgIWZvbnQua2VybmluZylcbiAgICAgICAgcmV0dXJuIDA7XG5cbiAgICB2YXIgdGFibGUgPSB0aGlzLmtlcm5pbmdUYWJsZTtcblxuICAgIGZvciAodmFyIGk9MDsgaTxmb250Lmtlcm5pbmcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGsgPSBmb250Lmtlcm5pbmdbaV07XG4gICAgICAgIGlmIChrWzBdID09PSBsZWZ0ICYmIGtbMV0gPT09IHJpZ2h0KSBcbiAgICAgICAgICAgIHJldHVybiBrWzJdO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbn07XG5cbkdseXBoSXRlcmF0b3IucHJvdG90eXBlLmJlZ2luID0gZnVuY3Rpb24oeCwgeSkge1xuICAgIHRoaXMub3JpZ2luLnggPSB4fHwwO1xuICAgIHRoaXMub3JpZ2luLnkgPSB5fHwwO1xuXG4gICAgdGhpcy5wZW4ueCA9IHRoaXMub3JpZ2luLng7XG4gICAgdGhpcy5wZW4ueSA9IHRoaXMub3JpZ2luLnk7XG59O1xuXG5HbHlwaEl0ZXJhdG9yLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbigpIHtcbiAgICAvLy4uIG1haW5seSBmb3IgY29uc2lzdGVuY3kgd2l0aCBiZWdpbigpXG4gICAgLy9NaWdodCBiZSB1c2VmdWwgbGF0ZXIgb25cbn07XG5cbkdseXBoSXRlcmF0b3IucHJvdG90eXBlLmdldExpbmVHYXAgPSBmdW5jdGlvbigpIHtcbiAgICAvL0xpbmUgaGVpZ2h0IGhhbmRsaW5nIGlzIGEgbWVzcyBpbiBicm93c2Vycy5cbiAgICAvL01heWJlIHRoZSBiZXN0IHNvbHV0aW9uIGlzIHRvIGVuY291cmFnZSB1c2VycyB0byBcbiAgICAvL3NwZWNpZnkgcGl4ZWwgbGluZSBoZWlnaHRzIGlmIHRoZXkgd2FudCB0byBtYXRjaCBicm93c2VyIHN0YW5kYXJkcyxcbiAgICAvL290aGVyd2lzZSBpdCdzIHVucmVhc29uYWJsZSB0byBleHBlY3QgdGhlIGxpbmUgZ2FwcyB0byBsaW5lIHVwIGV4YWN0bHlcbiAgICAvL2Fjcm9zcyBhbGwgYnJvd3NlcnMuIEV4YW1wbGUgb2YgdGhlIGRpc2FzdGVyOlxuICAgIC8vaHR0cDovL2xpc3RzLnczLm9yZy9BcmNoaXZlcy9QdWJsaWMvd3d3LXN0eWxlLzIwMDhKYW4vMDQxMy5odG1sXG5cbiAgICAvL0ZvciByZWZlcmVuY2UsIHNvbWUgYmFzZWxpbmUtdG8tYmFzZWxpbmUgY2FsY3VsYXRpb25zOlxuICAgIC8vaHR0cDovL3d3dy5taWNyb3NvZnQuY29tL3R5cG9ncmFwaHkvb3RzcGVjL3JlY29tLmh0bVxuICAgIC8vZnJlZXR5cGUub3JnL2ZyZWV0eXBlMi9kb2NzL3JlZmVyZW5jZS9mdDItYmFzZV9pbnRlcmZhY2UuaHRtbFxuICAgIC8vaHR0cDovL3d3dy5mcmVldHlwZS5vcmcvZnJlZXR5cGUyL2RvY3MvZ2x5cGhzL2dseXBocy0zLmh0bWxcblxuICAgIC8vVW5mb3J0dW5hdGVseSBub25lIG9mIHRoZXNlIGFyZSBwcm9kdWNpbmcgbGluZS1oZWlnaHRzIHRoYXQgYXZvaWQgb3ZlcmxhcHBpbmdcbiAgICAvL29yIHJlc2VtYmxlIGJyb3dzZXIgcmVuZGVyaW5nIGluIGFueSB3YXkuIFxuXG4gICAgLy8gSWYgQ1NTIHVzZXMgMWVtIG9yIDEsIHRoZSBicm93c2VyIG9mZnNldHMgdGhlIGxpbmUgYnkgdGhlIFxuICAgIC8vIGZvbnQncyBwaXhlbCBzaXplLiBJZiBhbiBleGFjdCBwaXhlbCBsaW5lLWhlaWdodCBpcyBzcGVjaWZpZWQsXG4gICAgLy8gdGhlIGJyb3dzZXIgd2lsbCB1c2UgdGhhdCArIGEgY29tcHV0ZWQgXCJsaW5lZ2FwLlwiIFxuICAgIC8vIElmICdhdXRvJyBpcyBzcGVjaWZpZWQgZm9yIGxpbmUtaGVpZ2h0LCB0aGUgY2FsY3VsYXRpb25zIHNlZW1cbiAgICAvLyBtdWNoIG1vcmUgY29tcGxleCBhbmQgYnJvd3Nlci9wbGF0Zm9ybSBkZXBlbmRlbnQgKG5vdCBpbmNsdWRlZCBoZXJlKS5cbiAgICBcbiAgICB2YXIgZm9udCA9IHRoaXMuZm9udCxcbiAgICAgICAgc2NhbGUgPSB0aGlzLmZvbnRTY2FsZTtcbiAgICB2YXIgZ2FwID0gKGZvbnQuaGVpZ2h0IC0gZm9udC5hc2NlbmRlciArIE1hdGguYWJzKGZvbnQuZGVzY2VuZGVyKSkgKiBzY2FsZTsgICAgXG4gICAgdmFyIGxpbmVIZWlnaHQgPSB0aGlzLmxpbmVIZWlnaHQ7XG4gICAgXG4gICAgbGluZUhlaWdodCA9IChsaW5lSGVpZ2h0PT09MHx8bGluZUhlaWdodCkgXG4gICAgICAgICAgICA/IChsaW5lSGVpZ2h0ICsgZ2FwKVxuICAgICAgICAgICAgOiB0aGlzLmZvbnRTaXplO1xuICAgIHJldHVybiBsaW5lSGVpZ2h0O1xufTtcblxuR2x5cGhJdGVyYXRvci5wcm90b3R5cGUudHJhbnNsYXRlID0gZnVuY3Rpb24oeCwgeSkge1xuICAgIHRoaXMub3JpZ2luLnggKz0geHx8MDtcbiAgICB0aGlzLm9yaWdpbi55ICs9IHl8fDA7XG5cbiAgICB0aGlzLnBlbi54ICs9IHh8fDA7XG4gICAgdGhpcy5wZW4ueSArPSB5fHwwO1xufTtcblxuR2x5cGhJdGVyYXRvci5wcm90b3R5cGUuc3RlcCA9IGZ1bmN0aW9uKHRleHQsIGluZGV4KSB7XG4gICAgdmFyIHNjYWxlID0gdGhpcy5mb250U2NhbGUsXG4gICAgICAgIGZvbnQgPSB0aGlzLl9mb250O1xuXG4gICAgdmFyIGNociA9IHRleHQuY2hhckF0KGluZGV4KTsgXG5cbiAgICBpZiAoY2hyID09PSAnXFx0JyAmJiB0aGlzLl90YWJHbHlwaCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGFiR2x5cGg7XG4gICAgfVxuXG4gICAgLy9Ta2lwIG1pc3NpbmcgY2hhcmFjdGVycy4uLlxuICAgIGlmICghKGNociBpbiBmb250LmdseXBocykpXG4gICAgICAgIHJldHVybjtcbiAgICBcbiAgICB2YXIgZ2x5cGggPSBmb250LmdseXBoc1tjaHJdO1xuXG4gICAgLy9JZiB3ZSBoYXZlIGEgY2hhciB0byB0aGUgbGVmdCwgZGV0ZXJtaW5lIGl0cyBrZXJuaW5nXG4gICAgaWYgKGluZGV4ID4gMCAmJiB0aGlzLmtlcm5pbmcpIHtcbiAgICAgICAgdmFyIGtlcm4gPSB0aGlzLmdldEtlcm5pbmcodGV4dC5jaGFyQXQoaW5kZXgtMSksIGNocik7XG4gICAgICAgIHRoaXMucGVuLnggKz0gKGtlcm4qc2NhbGUpO1xuICAgIH1cblxuICAgIHJldHVybiBnbHlwaDtcbn07XG5cbkdseXBoSXRlcmF0b3IucHJvdG90eXBlLmFkdmFuY2VMaW5lID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5wZW4ueSArPSB0aGlzLmdldExpbmVHYXAoKTtcbiAgICB0aGlzLnBlbi54ID0gdGhpcy5vcmlnaW4ueDtcbn07XG5cbi8qKlxuICogQ2FsbGVkIGFmdGVyIHN0ZXAuIFxuICovXG5HbHlwaEl0ZXJhdG9yLnByb3RvdHlwZS5hZHZhbmNlID0gZnVuY3Rpb24oZ2x5cGgpIHtcbiAgICB2YXIgYWR2YW5jZSA9IChnbHlwaC54b2ZmICogdGhpcy5mb250U2NhbGUpO1xuICAgIC8vIEFkdmFuY2UgdG8gbmV4dCBwZW4gcG9zaXRpb25cbiAgICB0aGlzLnBlbi54ICs9IGFkdmFuY2UgKyB0aGlzLmxldHRlclNwYWNpbmc7XG4gICAgcmV0dXJuIGFkdmFuY2U7XG59O1xuXG4vKipcbiAqIFRoaXMgaXMgYSB1dGlsaXR5IGZ1bmN0aW9uIHRoYXQgcHJvdmlkZXMgdGhlIGJvdW5kcyBvZiB0aGUgZ2l2ZW5cbiAqIHRleHQgKGZyb20gc3RhcnQgYW5kIGVuZCBwb3NpdGlvbnMpIGFzIGlmIHRoZXkgd2VyZSBsYWlkIG91dCBob3Jpem9udGFsbHksXG4gKiBsZWZ0IHRvIHJpZ2h0LlxuICpcbiAqIEZvciBjb252ZW5pZW5jZSwgdGhpcyB3aWxsIG5vdCBhbHRlciB0aGUgY3VycmVudCBwZW4gYW5kIG9yaWdpbiBwb3NpdGlvbnMuXG4gKiBUaGlzIHdheSBpdCBjYW4gYmUgdXRpbGl6ZWQgaW5zaWRlIGEgZ2x5cGggaXRlcmF0aW9uIChpLmUuIGZvciByZW5kZXJpbmcpLlxuICpcbiAqIElmIGBhdmFpbGFibGVXaWR0aGAgaXMgc3BlY2lmaWVkLCB0aGlzIHdpbGwgYnJlYWsgYmVmb3JlIHJlYWNoaW5nIHRoZSBzcGVjaWZpZWRcbiAqIHBpeGVsIHdpZHRoLCB0byBlbnN1cmUgdGhhdCBhbGwgZ2x5cGhzIHdpbGwgZml0IGluc2lkZSB0aGUgYm91bmRzLiBcbiAqXG4gKiBUaGUgcmV0dXJuIG9iamVjdCBhbHNvIGluY2x1ZGVzIGEgYGdseXBoc2AgcHJvcGVydHksIHdoaWNoIGlzIHRoZSBudW1iZXIgb2YgZ2x5cGhzXG4gKiB0aGF0IGFyZSB2aXNpYmxlIHdpdGhpbiB0aGUgcmV0dXJuZWQgYm91bmRzLiBcbiAqXG4gKiBJZiBgb3V0YCBpcyBzcGVjaWZpZWQgKGFuIG9iamVjdCB3aXRoIHgsIHksIHdpZHRoLCBoZWlnaHQsIGFuZCBnbHlwaCBwcm9wZXJ0aWVzKSxcbiAqIGl0IHdpbGwgYmUgcmUtdXNlZC4gT3RoZXJ3aXNlIGEgbmV3IG9iamVjdCBpcyBjcmVhdGVkLlxuICogXG4gKiBAcGFyYW0ge1N0cmluZ30gdGV4dCB0aGUgdGV4dCB0byBjaGVja1xuICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0IHRoZSBzdGFydCBwb3NpdGlvbiwgZGVmYXVsdHMgdG8gMFxuICogQHBhcmFtIHtOdW1iZXJ9IGVuZCB0aGUgZW5kIHBvc2l0aW9uLCBleGNsdXNpdmUsIGRlZmF1bHRzIHRvIHRleHQgbGVuZ3RoXG4gKiBAcGFyYW0ge051bWJlcn0gYXZhaWxhYmxlV2lkdGggdGhlIHdpZHRoIGJlZm9yZSBzdG9wcGluZyB0aGUgYm91bmQgY2hlY2tcbiAqIEBwYXJhbSB7T2JqZWN0fSBvdXQgYW4gb2JqZWN0IHRvIHJlLXVzZSBmb3IgdGhlIHJldHVybiB2YWx1ZVxuICogQHJldHVybiB7T2JqZWN0fSB0aGUgYm91bmRzIGFuZCBnbHlwaCBjb3VudCB7eCx5LHdpZHRoLGhlaWdodCxnbHlwaHN9XG4gKi9cbkdseXBoSXRlcmF0b3IucHJvdG90eXBlLmdldEJvdW5kcyA9IGZ1bmN0aW9uKHRleHQsIHN0YXJ0LCBlbmQsIGF2YWlsYWJsZVdpZHRoLCBvdXQpIHtcbiAgICBpZiAoIW91dClcbiAgICAgICAgb3V0ID0geyB4OjAsIHk6MCwgd2lkdGg6IDAsIGhlaWdodDogMCwgZ2x5cGhzOiAwIH07XG5cbiAgICB2YXIgY2hlY2tXaWR0aCA9IGF2YWlsYWJsZVdpZHRoPT09MHx8YXZhaWxhYmxlV2lkdGg7XG5cbiAgICBzdGFydCA9IHN0YXJ0fHwwO1xuICAgIGVuZCA9IGVuZD09PTB8fGVuZCA/IGVuZCA6IHRleHQubGVuZ3RoO1xuXG4gICAgdmFyIG1heEhlaWdodCA9IDA7XG5cbiAgICBvdXQueCA9IDA7XG4gICAgb3V0LnkgPSAwO1xuICAgIG91dC5nbHlwaHMgPSAwO1xuXG4gICAgdmFyIG9sZFBlblggPSB0aGlzLnBlbi54LFxuICAgICAgICBvbGRQZW5ZID0gdGhpcy5wZW4ueSxcbiAgICAgICAgb2xkT3JpZ2luWCA9IHRoaXMub3JpZ2luLngsXG4gICAgICAgIG9sZE9yaWdpblkgPSB0aGlzLm9yaWdpbi55O1xuXG5cbiAgICB2YXIgZm9udCA9IHRoaXMuZm9udDtcbiAgICB0aGlzLmJlZ2luKCk7XG4gICAgZm9yICh2YXIgaT1zdGFydDsgaTxlbmQ7IGkrKykge1xuICAgICAgICB2YXIgY2hyID0gdGV4dC5jaGFyQXQoaSk7XG5cbiAgICAgICAgLy9zdGVwIHRoZSBpdGVyYXRvclxuICAgICAgICB2YXIgZ2x5cGggPSB0aGlzLnN0ZXAodGV4dCwgaSk7XG5cbiAgICAgICAgLy9pZiB0aGUgZ2x5cGggaXMgdmFsaWQsIHdlIGNhbiBhZHZhbmNlIHBhc3QgaXQgYW5kIGNhbGN1bGF0ZSBuZXcgaGVpZ2h0XG4gICAgICAgIGlmIChnbHlwaCkge1xuICAgICAgICAgICAgdmFyIGhlaWdodCA9IChnbHlwaC5oZWlnaHQpKnRoaXMuZm9udFNjYWxlO1xuXG4gICAgICAgICAgICBvdXQueSA9IE1hdGgubWF4KG91dC55LCB0aGlzLmZvbnRTY2FsZSooZ2x5cGguaGVpZ2h0LWdseXBoLmhieSkpO1xuXG4gICAgICAgICAgICBtYXhIZWlnaHQgPSBNYXRoLm1heChtYXhIZWlnaHQsIGhlaWdodCk7XG4gICAgICAgICAgICB2YXIgbGFzdEFkdmFuY2UgPSB0aGlzLmFkdmFuY2UoZ2x5cGgpO1xuXG4gICAgICAgICAgICAvL2lmIHdlJ3JlIHBhc3QgdGhlIGF2YWlsYWJsZSB3aWR0aFxuICAgICAgICAgICAgdmFyIG5ld1dpZHRoID0gdGhpcy5wZW4ueCAtIHRoaXMub3JpZ2luLng7XG4gICAgICAgICAgICBpZiAoY2hlY2tXaWR0aCAmJiAobmV3V2lkdGggLSBhdmFpbGFibGVXaWR0aCA+IDAuMDAxKSkge1xuICAgICAgICAgICAgICAgIHRoaXMucGVuLnggLT0gbGFzdEFkdmFuY2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG91dC5nbHlwaHMrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmVuZCgpO1xuXG4gICAgb3V0LndpZHRoID0gdGhpcy5wZW4ueCAtIHRoaXMub3JpZ2luLng7XG4gICAgb3V0LmhlaWdodCA9IG1heEhlaWdodDtcblxuICAgIHRoaXMucGVuLnggPSBvbGRQZW5YO1xuICAgIHRoaXMucGVuLnkgPSBvbGRQZW5ZO1xuICAgIHRoaXMub3JpZ2luLnggPSBvbGRPcmlnaW5YO1xuICAgIHRoaXMub3JpZ2luLnkgPSBvbGRPcmlnaW5ZO1xuXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gR2x5cGhJdGVyYXRvcjsiLCIvLyBtb2R1bGUuZXhwb3J0cy5wb2ludHNUb1BpeGVscyA9IGZ1bmN0aW9uKHBvaW50U2l6ZSwgcmVzb2x1dGlvbikge1xuLy8gXHRyZXNvbHV0aW9uID0gdHlwZW9mIHJlc29sdXRpb24gPT09IFwibnVtYmVyXCIgPyByZXNvbHV0aW9uIDogNzI7XG4vLyBcdHJldHVybiBwb2ludFNpemUgKiByZXNvbHV0aW9uIC8gNzI7XG4vLyB9O1xuXG4vLyBtb2R1bGUuZXhwb3J0cy5jb29yZFRvUGl4ZWwgPSBmdW5jdGlvbihjb29yZCwgcGl4ZWxTaXplLCBlbVNpemUpIHtcbi8vIFx0ZW1TaXplID0gdHlwZW9mIGVtU2l6ZSA9PT0gXCJudW1iZXJcIiA/IGVtU2l6ZSA6IDIwNDg7XG4vLyBcdHJldHVybiBjb29yZCAqIHBpeGVsU2l6ZSAvIGVtU2l6ZTtcbi8vIH07XG5cbi8qKlxuICogQ29udmVydHMgYSBwdCBzaXplIHRvIHB4IHNpemUsIG5hbWVseSB1c2VmdWwgZm9yIG1hdGNoaW5nXG4gKiBzaXplIHdpdGggQ1NTIHN0eWxlcy4gSWYgbm8gRFBJIGlzIHNwZWNpZmllZCwgOTYgaXMgYXNzdW1lZFxuICogKGFzIGl0IGxlYWRzIHRvIGNvcnJlY3QgcmVuZGVyaW5nIGluIGFsbCBicm93c2VycykuXG4gKiBcbiAqIEBwYXJhbSAge051bWJlcn0gZm9udFNpemUgdGhlIGRlc2lyZWQgZm9udCBzaXplIGluIHBvaW50c1xuICogQHBhcmFtICB7TnVtYmVyfSBkcGkgICAgICB0aGUgZXhwZWN0ZWQgRFBJLCBnZW5lcmFsbHkgOTYgZm9yIGJyb3dzZXJzXG4gKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgICAgIHRoZSByb3VuZGVkIHBpeGVsIGZvbnQgc2l6ZVxuICovXG5tb2R1bGUuZXhwb3J0cy5wb2ludFRvUGl4ZWwgPSBmdW5jdGlvbihmb250U2l6ZSwgZHBpKSB7XG4gICAgZHBpID0gZHBpfHxkcGk9PT0wID8gZHBpIDogOTY7XG4gICAgZm9udFNpemUgPSBmb250U2l6ZSAqIGRwaSAvIDcyO1xuICAgIHJldHVybiBNYXRoLnJvdW5kKGZvbnRTaXplKTtcbn07XG5cbi8qKlxuICogRm9yIHRoZSBnaXZlbiBmb250IGFuZCAocGl4ZWwpIGZvbnQgc2l6ZSwgdGhpcyBtZXRob2QgcmV0dXJucyB0aGVcbiAqIHNjYWxlIHRoYXQgd2lsbCBuZWVkIHRvIGJlIGFwcGxpZWQgdG8gRU0gdW5pdHMgKGkuZS4gZm9udCBwYXRocykgXG4gKiB0byBoYXZlIHRoZSBmb250IHJlbmRlciBhdCB0aGUgZXhwZWN0ZWQgc2l6ZSAoaS5lLiB0byBtYXRjaCB0aGUgYnJvd3NlcikuXG4gKlxuICogSWYgbm8gZm9udCBzaXplIGlzIHNwZWNpZmllZCwgd2Ugd2lsbCB1c2UgdGhlIGRlZmF1bHQgZm9udCBzaXplICh3aGljaCBpcyBpbiBwb2ludHMpXG4gKiBhbmQgY29udmVydCBpdCB0byBwaXhlbHMuIFxuICogXG4gKiBAcGFyYW0gIHtGb250fSBmb250ICAgICBhIGZvbnQgb2JqZWN0IGZyb20gdGhlIGZvbnRwYXRoIHRvb2xcbiAqIEBwYXJhbSAge051bWJlcn0gZm9udFNpemUgdGhlIGRlc2lyZWQgZm9udCBzaXplLCBkZWZhdWx0cyB0byB0aGUgZm9udCdzIGRlZmF1bHQgc2l6ZVxuICogQHJldHVybiB7TnVtYmVyfSByZXR1cm5zIHRoZSBzY2FsZSBmb3IgdGhpcyBmb250IHNpemUgICAgICAgICBcbiAqL1xubW9kdWxlLmV4cG9ydHMuZ2V0UHhTY2FsZSA9IGZ1bmN0aW9uKGZvbnQsIGZvbnRTaXplKSB7XG4gICAgaWYgKGZvbnQuYml0bWFwKVxuICAgICAgICByZXR1cm4gMS4wO1xuXG4gICAgLy9JZiBubyBmb250U2l6ZSBpcyBzcGVjaWZpZWQsIGl0IHdpbGwganVzdCBmYWxsIGJhY2sgdG8gdXNpbmcgdGhlIGZvbnQncyBvd24gc2l6ZSB3aXRoIDk2IERQSS5cbiAgICBmb250U2l6ZSA9IHR5cGVvZiBmb250U2l6ZSA9PT0gXCJudW1iZXJcIiA/IGZvbnRTaXplIDogdGhpcy5wb2ludFRvUGl4ZWwoZm9udC5zaXplKTtcblxuICAgIC8vVGFrZXMgaW4gYSBmb250IHNpemUgaW4gUElYRUxTIGFuZCBnaXZlcyB1cyB0aGUgZXhwZWN0ZWQgc2NhbGluZyBmYWN0b3JcbiAgICB2YXIgc3ogPSBmb250LnVuaXRzX3Blcl9FTS82NDtcbiAgICBzeiA9IChzei9mb250LnNpemUgKiBmb250U2l6ZSk7XG5cbiAgICByZXR1cm4gKChmb250LnJlc29sdXRpb24gKiAxLzcyICogc3opIC8gZm9udC51bml0c19wZXJfRU0pO1xufTtcblxuLyoqXG4gKiBGb3IgdGhlIGdpdmVuIGZvbnQgYW5kIChwb2ludCkgZm9udCBzaXplLCB0aGlzIG1ldGhvZCByZXR1cm5zIHRoZVxuICogc2NhbGUgdGhhdCB3aWxsIG5lZWQgdG8gYmUgYXBwbGllZCB0byBFTSB1bml0cyAoaS5lLiBmb250IHBhdGhzKSBcbiAqIHRvIGhhdmUgdGhlIGZvbnQgcmVuZGVyIGF0IHRoZSBleHBlY3RlZCBzaXplIChpLmUuIHRvIG1hdGNoIHRoZSBicm93c2VyKS5cbiAqIFxuICogSWYgbm8gZm9udCBzaXplIGlzIHNwZWNpZmllZCwgd2Ugd2lsbCB1c2UgdGhlIGRlZmF1bHQgZm9udCBzaXplLlxuICogXG4gKiBAcGFyYW0gIHtGb250fSBmb250ICAgICAgIGEgZm9udCBvYmplY3QgZnJvbSB0aGUgZm9udHBhdGggdG9vbFxuICogQHBhcmFtICB7TnVtYmVyfSBmb250U2l6ZSB0aGUgZGVzaXJlZCBmb250IHNpemUsIGRlZmF1bHRzIHRvIHRoZSBmb250J3MgZGVmYXVsdCBzaXplXG4gKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgICAgIHRoZSBzY2FsZSBmb3IgdGhpcyBmb250IHNpemVcbiAqL1xubW9kdWxlLmV4cG9ydHMuZ2V0UHRTY2FsZSA9IGZ1bmN0aW9uKGZvbnQsIGZvbnRTaXplKSB7XG4gICAgZm9udFNpemUgPSB0eXBlb2YgZm9udFNpemUgPT09IFwibnVtYmVyXCIgPyBmb250U2l6ZSA6IGZvbnQuc2l6ZTtcbiAgICBmb250U2l6ZSA9IHRoaXMucG9pbnRUb1BpeGVsKGZvbnRTaXplKTtcbiAgICByZXR1cm4gdGhpcy5nZXRQeFNjYWxlKGZvbnQsIGZvbnRTaXplKTtcbn07XG4iLCJ2YXIgdG1wQm91bmRzID0geyB4OiAwLCB5OiAwLCB3aWR0aDogMCwgaGVpZ2h0OiAwLCBnbHlwaHM6IDAgfTtcblxuZnVuY3Rpb24gaXNXaGl0ZXNwYWNlKGNocikge1xuXHRyZXR1cm4gY2hyPT09JyAnXG5cdFx0fHwgY2hyPT09J1xcbidcblx0XHR8fCBjaHI9PT0nXFxyJ1xuXHRcdHx8IGNocj09PSdcXHQnO1xufVxuXG5mdW5jdGlvbiBpZHhPZih0ZXh0LCBjaHIsIHN0YXJ0LCBlbmQpIHtcblx0dmFyIGlkeCA9IHRleHQuaW5kZXhPZihjaHIsIHN0YXJ0KTtcblx0aWYgKGlkeCA9PT0gLTEgfHwgaWR4ID4gZW5kKVxuXHRcdHJldHVybiBlbmQ7XG5cdHJldHVybiBpZHg7XG59XG5cbmZ1bmN0aW9uIFdvcmRXcmFwKHRleHQpIHtcblx0LyoqXG5cdCAqIFRoZSB0ZXh0IGJlaW5nIG9wZXJhdGVkIG9uLlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdGV4dFxuXHQgKi9cblx0dGhpcy50ZXh0ID0gdGV4dHx8XCJcIjtcblxuXHQvKipcblx0ICogQW4gYXJyYXkgb2YgbGluZXMgcmVwcmVzZW50aW5nIHRoZSBzdGF0ZSBvZiB0aGlzIHdvcmQgd3JhcHBlci5cblx0ICogQHBhcmFtIHtBcnJheX0gbGluZXNcblx0ICovXG5cdHRoaXMubGluZXMgPSBbXTtcblxuXHQvKiogXG5cdCAqIFRoZSBuZXdsaW5lIGNoYXJhY3RlciB0byBicmVhayBvbiwgZGVmYXVsdCAnXFxuJ1xuXHQgKiBAcGFyYW0ge1N0cmluZ30gbmV3bGluZVxuXHQgKi9cblx0dGhpcy5uZXdsaW5lID0gJ1xcbic7XG5cblx0LyoqXG5cdCAqIFdoZXRoZXIgdG8gY2xpcCBub24tYnJlYWtpbmcgdGV4dCAobm93cmFwIGFuZCBwcmUpXG5cdCAqIGlmIHRoZSB3cmFwV2lkdGggaXMgdG9vIHNtYWxsLiBcblx0ICogIFxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGNsaXBcblx0ICovXG5cdHRoaXMuY2xpcCA9IGZhbHNlO1xuXG5cdC8qKlxuXHQgKiBUaGUgbW9kZSBmb3Igd29yZHdyYXBwaW5nOiAncHJlJywgJ25vcm1hbCcsIG9yICdub3dyYXAnLlxuXHQgKlxuXHQgKiBZb3UgY2FuIGFsc28gdXNlIHRoZSBgUFJFYCwgYE5PUk1BTGAsIGFuZCBgTk9XUkFQYCBjb25zdGFudHNcblx0ICogaW4gYFdvcmRXcmFwLk1vZGVgLlxuXHQgKiBcblx0ICogQHBhcmFtIHtTdHJpbmd9IG1vZGVcblx0ICovXG5cdHRoaXMubW9kZSA9IFdvcmRXcmFwLk1vZGUuTk9STUFMO1xufVxuXG5Xb3JkV3JhcC5Nb2RlID0ge1xuXHRQUkU6ICdwcmUnLCAgICAgICAvL3doaXRlc3BhY2UgaXNuJ3QgY29sbGFwc2VkXG5cdE5PUk1BTDogJ25vcm1hbCcsIC8vd2hpdGVzcGFjZSBpcyBjb2xsYXBzZWRcblx0Tk9XUkFQOiAnbm93cmFwJyAgLy9vbmx5IGJyZWFrIG9uICdcXG4nXG59O1xuXG4vKipcbiAqIENsZWFycyBhbnkgbXVsdGktbGluZSBsYXlvdXQgYnkgcGxhY2luZyBhbGwgdGhlIHRleHQgaW4gYSBzaW5nbGUgTGluZSBvYmplY3QuXG4gKiBcbiAqIEBwYXJhbSB7R2x5cGhJdGVyYXRvcn0gaXRlcmF0b3IgdGhlIGl0ZXJhdG9yIHRvIHVzZSBcbiAqIEBtZXRob2QgIGNsZWFyTGF5b3V0XG4gKi9cbldvcmRXcmFwLnByb3RvdHlwZS5jbGVhckxheW91dCA9IGZ1bmN0aW9uKGl0ZXJhdG9yKSB7XG5cdHRoaXMubGluZXMubGVuZ3RoID0gMDtcblx0XG5cdGlmICh0aGlzLnRleHQubGVuZ3RoID4gMCkge1xuXHRcdGl0ZXJhdG9yLmdldEJvdW5kcyh0aGlzLnRleHQsIDAsIHRoaXMudGV4dC5sZW5ndGgsIHVuZGVmaW5lZCwgdG1wQm91bmRzKTtcblx0XHRcblx0XHR2YXIgbGluZSA9IG5ldyBXb3JkV3JhcC5MaW5lKDAsIHRoaXMudGV4dC5sZW5ndGgsIHRtcEJvdW5kcy53aWR0aCk7XG5cdFx0dGhpcy5saW5lcy5wdXNoKGxpbmUpO1xuXHR9XG59O1xuXG4vKipcbiAqIFJlc2V0cyB0aGUgd29yZCB3cmFwcGVyIGJ5IGVtcHR5aW5nIGFsbCBjdXJyZW50IGxpbmVzLlxuICogQG1ldGhvZCAgZW1wdHlcbiAqL1xuV29yZFdyYXAucHJvdG90eXBlLmVtcHR5ID0gZnVuY3Rpb24oKSB7XG5cdHRoaXMubGluZXMubGVuZ3RoID0gMDtcbn07XG5cbi8qKlxuICogV29yZC13cmFwcyB0aGUgZ2l2ZW4gdGV4dCBpbnRvIG11bHRpcGxlIGxpbmVzLlxuICogQHBhcmFtICB7W3R5cGVdfSBpdGVyYXRvciBbZGVzY3JpcHRpb25dXG4gKiBAcGFyYW0gIHtbdHlwZV19IHdpZHRoICAgIFtkZXNjcmlwdGlvbl1cbiAqIEBwYXJhbSAge1t0eXBlXX0gc3RhcnQgICAgW2Rlc2NyaXB0aW9uXVxuICogQHBhcmFtICB7W3R5cGVdfSBlbmQgICAgICBbZGVzY3JpcHRpb25dXG4gKiBAcmV0dXJuIHtbdHlwZV19ICAgICAgICAgIFtkZXNjcmlwdGlvbl1cbiAqL1xuV29yZFdyYXAucHJvdG90eXBlLmxheW91dCA9IGZ1bmN0aW9uKGl0ZXJhdG9yLCB3cmFwV2lkdGgsIHN0YXJ0LCBlbmQpIHtcblx0dmFyIHRleHQgPSB0aGlzLnRleHQ7XG5cblx0dmFyIGxpbmVzID0gdGhpcy5saW5lcztcblxuXHRzdGFydCA9IE1hdGgubWF4KDAsIHN0YXJ0fHwwKTtcblx0ZW5kID0gKGVuZD09PTB8fGVuZCkgPyBlbmQgOiB0ZXh0Lmxlbmd0aDtcblxuXHRpdGVyYXRvci5iZWdpbigpO1xuXG5cdC8vZGVmYXVsdCB3cmFwIHdpZHRoLi4uXG5cdHdyYXBXaWR0aCA9ICh3cmFwV2lkdGg9PT0wIHx8IHdyYXBXaWR0aCkgPyB3cmFwV2lkdGggOiBOdW1iZXIuTUFYX1ZBTFVFO1xuXG5cdC8vPHByZT4gbW9kZSBqdXN0IHVzZXMgYSBzaW1wbGUgYWxnb3JpdGhtLi4uXG5cdGlmICh0aGlzLm1vZGUgPT09IFdvcmRXcmFwLk1vZGUuUFJFKSB7XG5cdFx0dmFyIGxpbmVTdGFydCA9IHN0YXJ0O1xuXHRcdGZvciAodmFyIGk9c3RhcnQ7IGk8ZW5kOyBpKyspIHtcblx0XHRcdHZhciBjaHIgPSB0ZXh0LmNoYXJBdChpKTtcblxuXHRcdFx0Ly9JZiB3ZSd2ZSByZWFjaGVkIGEgbmV3bGluZSwgdGhlbiBzdGVwIGRvd24gYSBsaW5lXG5cdFx0XHQvL09yIGlmIHdlJ3ZlIHJlYWNoZWQgdGhlIEVPRlxuXHRcdFx0aWYgKCBjaHIgPT09IHRoaXMubmV3bGluZSB8fCBpPT09ZW5kLTEpIHtcblx0XHRcdFx0dmFyIGF2YWlsYWJsZVdpZHRoID0gdGhpcy5jbGlwID8gd3JhcFdpZHRoIDogdW5kZWZpbmVkO1xuXHRcdFx0XHRpdGVyYXRvci5nZXRCb3VuZHModGV4dCwgbGluZVN0YXJ0LCBpKzEsIGF2YWlsYWJsZVdpZHRoLCB0bXBCb3VuZHMpO1xuXHRcdFx0XHRsaW5lcy5wdXNoKCBuZXcgV29yZFdyYXAuTGluZShsaW5lU3RhcnQsIGxpbmVTdGFydCt0bXBCb3VuZHMuZ2x5cGhzLCB0bXBCb3VuZHMud2lkdGgpICk7XG5cdFx0XHRcdGxpbmVTdGFydCA9IGkrMTtcblx0XHRcdH1cblx0XHR9XG5cdH0gXG5cdC8vJ25vcm1hbCcgbW9kZSB1c2VzIExpYkdEWCdzIHdvcmQgd3JhcHBpbmcgYWxnb3JpdGhtOlxuXHQvL2h0dHBzOi8vZ2l0aHViLmNvbS9saWJnZHgvbGliZ2R4L2Jsb2IvbWFzdGVyL2dkeC9zcmMvY29tL2JhZGxvZ2ljL2dkeC9ncmFwaGljcy9nMmQvQml0bWFwRm9udENhY2hlLmphdmFcblx0ZWxzZSB7XG5cdFx0Ly9pZiAnbm93cmFwJyBpcyBzcGVjaWZpZWQsIHdlIG9ubHkgd3JhcCBvbiBuZXdsaW5lIGNoYXJzXG5cdFx0XG5cdFx0dmFyIHRlc3RXaWR0aCA9IHdyYXBXaWR0aDtcblx0XHRpZiAodGhpcy5tb2RlID09PSBXb3JkV3JhcC5Nb2RlLk5PV1JBUCkge1xuXHRcdFx0dGVzdFdpZHRoID0gTnVtYmVyLk1BWF9WQUxVRTtcblx0XHR9XG5cblx0XHR3aGlsZSAoc3RhcnQgPCBlbmQpIHtcblx0XHRcdC8vZ2V0IG5leHQgbmV3bGluZSBwb3NpdGlvblxuXHRcdFx0dmFyIG5ld0xpbmUgPSBpZHhPZih0ZXh0LCB0aGlzLm5ld2xpbmUsIHN0YXJ0LCBlbmQpO1xuXG5cdFx0XHQvL2VhdCB3aGl0ZXNwYWNlIGF0IHN0YXJ0IG9mIGxpbmVcblx0XHRcdHdoaWxlIChzdGFydCA8IG5ld0xpbmUpIHtcblx0XHRcdFx0aWYgKCFpc1doaXRlc3BhY2UoIHRleHQuY2hhckF0KHN0YXJ0KSApKVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRzdGFydCsrO1xuXHRcdFx0fVxuXG5cdFx0XHQvL2RldGVybWluZSB2aXNpYmxlICMgb2YgZ2x5cGhzIGZvciB0aGUgYXZhaWxhYmxlIHdpZHRoXG5cdFx0XHRpdGVyYXRvci5nZXRCb3VuZHModGV4dCwgc3RhcnQsIG5ld0xpbmUsIHRlc3RXaWR0aCwgdG1wQm91bmRzKVxuXG5cdFx0XHR2YXIgbGluZUVuZCA9IHN0YXJ0ICsgdG1wQm91bmRzLmdseXBocztcblx0XHRcdHZhciBuZXh0U3RhcnQgPSBsaW5lRW5kICsgdGhpcy5uZXdsaW5lLmxlbmd0aDtcblxuXHRcdFx0Ly9pZiB3ZSBoYWQgdG8gY3V0IHRoZSBsaW5lIGJlZm9yZSB0aGUgbmV4dCBuZXdsaW5lLi4uXG5cdFx0XHRpZiAobGluZUVuZCA8IG5ld0xpbmUpIHtcblx0XHRcdFx0Ly9maW5kIGNoYXIgdG8gYnJlYWsgb25cblx0XHRcdFx0d2hpbGUgKGxpbmVFbmQgPiBzdGFydCkge1xuXHRcdFx0XHRcdGlmIChpc1doaXRlc3BhY2UodGV4dC5jaGFyQXQobGluZUVuZCkpKVxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0bGluZUVuZC0tO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChsaW5lRW5kID09PSBzdGFydCkge1xuXHRcdFx0XHRcdGlmIChuZXh0U3RhcnQgPiBzdGFydCArIHRoaXMubmV3bGluZS5sZW5ndGgpIG5leHRTdGFydC0tO1xuXHRcdFx0XHRcdGxpbmVFbmQgPSBuZXh0U3RhcnQ7IC8vIElmIG5vIGNoYXJhY3RlcnMgdG8gYnJlYWssIHNob3cgYWxsLlxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdG5leHRTdGFydCA9IGxpbmVFbmQ7XG5cdFx0XHRcdFx0Ly9lYXQgd2hpdGVzcGFjZSBhdCBlbmQgb2YgbGluZVxuXHRcdFx0XHRcdHdoaWxlIChsaW5lRW5kID4gc3RhcnQpIHtcblx0XHRcdFx0XHRcdGlmICghaXNXaGl0ZXNwYWNlKHRleHQuY2hhckF0KGxpbmVFbmQgLSB0aGlzLm5ld2xpbmUubGVuZ3RoKSkpXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0bGluZUVuZC0tO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAobGluZUVuZCA+IHN0YXJ0KSB7XG5cdFx0XHRcdC8vdG8gY2xpcCwgdXNlIHRoZSBvcmlnaW5hbCB3cmFwIHdpZHRoICh1bmFsdGVyZWQgYnkgbW9kZSlcblx0XHRcdFx0dmFyIGF2YWlsYWJsZVdpZHRoID0gdGhpcy5jbGlwID8gd3JhcFdpZHRoIDogdW5kZWZpbmVkO1xuXHRcdFx0XHRpdGVyYXRvci5nZXRCb3VuZHModGV4dCwgc3RhcnQsIGxpbmVFbmQsIGF2YWlsYWJsZVdpZHRoLCB0bXBCb3VuZHMpO1xuXHRcdFx0XHR2YXIgbGluZVdpZHRoID0gdG1wQm91bmRzLndpZHRoO1xuXG5cdFx0XHRcdHZhciByTGluZUVuZCA9IHRoaXMuY2xpcCA/IHN0YXJ0K3RtcEJvdW5kcy5nbHlwaHMgOiBsaW5lRW5kO1xuXHRcdFx0XHRsaW5lcy5wdXNoKCBuZXcgV29yZFdyYXAuTGluZShzdGFydCwgckxpbmVFbmQsIGxpbmVXaWR0aCkgKTtcblx0XHRcdH1cblx0XHRcdHN0YXJ0ID0gbmV4dFN0YXJ0O1xuXG5cdFx0fVxuXHR9XG5cblx0aXRlcmF0b3IuZW5kKCk7XG59O1xuXG4vKipcbiAqIEEgY29udmVuaWVuY2UgbWV0aG9kIHRvIHJldHVybiB0aGUgbWF4aW11bSB3aWR0aCBvZiBhbGwgY3VycmVudCBsaW5lcy5cbiAqIFRoaXMgaXMgdXNlZnVsIGZvciBhbGlnbmluZyBibG9ja3Mgb2YgdGV4dC5cbiAqXG4gKiBAbWV0aG9kICBnZXRNYXhMaW5lV2lkdGhcbiAqIEByZXR1cm4ge051bWJlcn0gdGhlIG1heGltdW0gd2lkdGggb2YgYWxsIGxpbmVzXG4gKi9cbldvcmRXcmFwLnByb3RvdHlwZS5nZXRNYXhMaW5lV2lkdGggPSBmdW5jdGlvbigpIHtcblx0dmFyIG1heFdpZHRoID0gMDtcblx0Zm9yICh2YXIgaT0wOyBpPHRoaXMubGluZXMubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgbGluZSA9IHRoaXMubGluZXNbaV07XG5cdFx0bWF4V2lkdGggPSBNYXRoLm1heChsaW5lLndpZHRoLCBtYXhXaWR0aCk7XG5cdH1cblx0cmV0dXJuIG1heFdpZHRoO1xufTtcblxuLyoqXG4gKiBUaGUgTGluZSBvYmplY3QgaG9sZHMgdGhlIHN0YXJ0IGFuZCBlbmQgaW5kaWNlcyBpbnRvIHRoZSBzdHJpbmcsXG4gKiBhbmQgdGhlIHdpZHRoIGFzIGNvbXB1dGVkIGJ5IEdseXBoSXRlcmF0b3IuXG4gKiBcbiAqIEBjbGFzcyAgV29yZFdyYXAuTGluZVxuICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0IHRoZSBzdGFydCBpbmRleCwgaW5jbHVzaXZlXG4gKiBAcGFyYW0ge051bWJlcn0gZW5kICAgdGhlIGVuZCBpbmRleCwgZXhjbHVzaXZlXG4gKiBAcGFyYW0ge051bWJlcn0gd2lkdGggdGhlIGNvbXB1dGVkIHdpZHRoIG9mIHRoaXMgbGluZVxuICovXG5Xb3JkV3JhcC5MaW5lID0gZnVuY3Rpb24oc3RhcnQsIGVuZCwgd2lkdGgpIHtcblx0dGhpcy5zdGFydCA9IHN0YXJ0O1xuXHR0aGlzLmVuZCA9IGVuZDtcblx0dGhpcy53aWR0aCA9IHdpZHRoO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBXb3JkV3JhcDsiLCJ2YXIgY3JlYXRlVkFPID0gcmVxdWlyZSgnZ2wtYWxpYXNlZC12YW8nKSAvL1RPRE86IGltcHJvdmUgdGhpcyB3aXRoIGdsLXZhb1xudmFyIGNyZWF0ZUJ1ZmZlciA9IHJlcXVpcmUoJ2dsLWJ1ZmZlcicpXG5cbm1vZHVsZS5leHBvcnRzLmZsb2F0c1BlclZlcnRleCA9IDVcblxuZnVuY3Rpb24gY3JlYXRlSW5kaWNlcyhjYXBhY2l0eSkge1xuICAgIHZhciBudW1JbmRpY2VzID0gY2FwYWNpdHkgKiA2XG4gICAgdmFyIGluZGljZXMgPSBuZXcgVWludDE2QXJyYXkobnVtSW5kaWNlcylcblxuICAgIGZvciAodmFyIGkgPSAwLCBqID0gMDsgaSA8IG51bUluZGljZXM7IGkgKz0gNiwgaiArPSA0KSB7XG4gICAgICAgIGluZGljZXNbaSArIDBdID0gaiArIDBcbiAgICAgICAgaW5kaWNlc1tpICsgMV0gPSBqICsgMVxuICAgICAgICBpbmRpY2VzW2kgKyAyXSA9IGogKyAyXG4gICAgICAgIGluZGljZXNbaSArIDNdID0gaiArIDBcbiAgICAgICAgaW5kaWNlc1tpICsgNF0gPSBqICsgMlxuICAgICAgICBpbmRpY2VzW2kgKyA1XSA9IGogKyAzXG4gICAgfVxuICAgIHJldHVybiBpbmRpY2VzXG59XG5cbm1vZHVsZS5leHBvcnRzLm1peGlucyA9IHtcblxuICAgIGNyZWF0ZTogZnVuY3Rpb24gY3JlYXRlKG9wdCkge1xuICAgICAgICBvcHQgPSBvcHR8fHt9XG4gICAgICAgIHRoaXMuY2xlYXIoKVxuXG4gICAgICAgIC8vZGlzcG9zZSBiZWZvcmUgYnVpbGRpbmcuLi5cbiAgICAgICAgaWYgKHRoaXMudmFvKVxuICAgICAgICAgICAgdGhpcy5kaXNwb3NlKClcblxuICAgICAgICB2YXIgY2FwYWNpdHkgPSB0eXBlb2Ygb3B0LmNhcGFjaXR5ID09PSAnbnVtYmVyJyA/IG9wdC5jYXBhY2l0eSA6IDEwMFxuXG4gICAgICAgIC8vIDY1NTM1IGlzIG1heCBpbmRleCwgc28gNjU1MzUgLyA2ID0gMTA5MjIuXG4gICAgICAgIGlmIChjYXBhY2l0eSA+IDEwOTIyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgaGF2ZSBtb3JlIHRoYW4gMTA5MjIgcXVhZHMgcGVyIGJhdGNoOiBcIiArIGNhcGFjaXR5KVxuXG4gICAgICAgIHRoaXMuX2NhcGFjaXR5ID0gY2FwYWNpdHlcblxuICAgICAgICAvL3RoZSB0b3RhbCBudW1iZXIgb2YgZmxvYXRzIGluIG91ciBiYXRjaFxuICAgICAgICB2YXIgbnVtVmVydHMgPSBjYXBhY2l0eSAqIDQgKiBtb2R1bGUuZXhwb3J0cy5mbG9hdHNQZXJWZXJ0ZXhcblxuICAgICAgICB0aGlzLnZlcnRpY2VzID0gbmV3IEZsb2F0MzJBcnJheShudW1WZXJ0cylcbiAgICAgICAgdGhpcy5pbmRpY2VzID0gY3JlYXRlSW5kaWNlcyhjYXBhY2l0eSlcblxuICAgICAgICB2YXIgZ2wgPSB0aGlzLmdsXG4gICAgICAgIHZhciB1c2FnZSA9IG9wdC5keW5hbWljID8gZ2wuRFlOQU1JQ19EUkFXIDogZ2wuU1RBVElDX0RSQVdcbiAgICAgICAgdGhpcy52ZXJ0ZXhCdWZmZXIgPSBjcmVhdGVCdWZmZXIoZ2wsIHRoaXMudmVydGljZXMsIGdsLkFSUkFZX0JVRkZFUiwgdXNhZ2UpXG4gICAgICAgIHRoaXMuaW5kZXhCdWZmZXIgPSBjcmVhdGVCdWZmZXIoZ2wsIHRoaXMuaW5kaWNlcywgZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGdsLlNUQVRJQ19EUkFXKVxuXG4gICAgICAgIHZhciBzdHJpZGUgPSA1ICogNFxuICAgICAgICB0aGlzLnZhbyA9IGNyZWF0ZVZBTyhnbCwgW3sgLy9wb3NpdGlvbiBYWVxuICAgICAgICAgICAgbmFtZTogJ3Bvc2l0aW9uJyxcbiAgICAgICAgICAgIGJ1ZmZlcjogdGhpcy52ZXJ0ZXhCdWZmZXIsXG4gICAgICAgICAgICBzaXplOiAyLFxuICAgICAgICAgICAgc3RyaWRlOiBzdHJpZGVcbiAgICAgICAgfSwgeyAvL3RleGNvb3JkIFVWXG4gICAgICAgICAgICBuYW1lOiAndGV4Y29vcmQwJyxcbiAgICAgICAgICAgIGJ1ZmZlcjogdGhpcy52ZXJ0ZXhCdWZmZXIsXG4gICAgICAgICAgICBzaXplOiAyLFxuICAgICAgICAgICAgb2Zmc2V0OiAyICogNCxcbiAgICAgICAgICAgIHN0cmlkZTogc3RyaWRlXG4gICAgICAgIH0sIHsgLy9jb2xvciAocGFja2VkKSBDXG4gICAgICAgICAgICBuYW1lOiAnY29sb3InLFxuICAgICAgICAgICAgYnVmZmVyOiB0aGlzLnZlcnRleEJ1ZmZlcixcbiAgICAgICAgICAgIHNpemU6IDQsXG4gICAgICAgICAgICBzdHJpZGU6IHN0cmlkZSxcbiAgICAgICAgICAgIG9mZnNldDogNCAqIDQsXG4gICAgICAgICAgICB0eXBlOiBnbC5VTlNJR05FRF9CWVRFLFxuICAgICAgICAgICAgbm9ybWFsaXplZDogdHJ1ZVxuICAgICAgICB9XSwgdGhpcy5pbmRleEJ1ZmZlcilcbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICB9LFxuXG4gICAgZW5zdXJlQ2FwYWNpdHk6IGZ1bmN0aW9uKGNhcGFjaXR5KSB7XG4gICAgICAgIGlmICh0aGlzLmNhcGFjaXR5IDwgY2FwYWNpdHkpXG4gICAgICAgICAgICB0aGlzLmNyZWF0ZSh7IGNhcGFjaXR5OiBjYXBhY2l0eSB9KVxuICAgICAgICByZXR1cm4gdGhpc1xuICAgIH1cbn0iLCJ2YXIgY29sb3JUb0Zsb2F0ID0gcmVxdWlyZSgnLi9wYWNrLXJnYmEtZmxvYXQnKVxudmFyIG1peGVzID0gcmVxdWlyZSgnbWl4ZXMnKVxudmFyIHByZW11bHQgPSByZXF1aXJlKCdwcmVtdWx0aXBsaWVkLXJnYmEnKVxudmFyIFdoaXRlVGV4ID0gcmVxdWlyZSgnZ2wtd2hpdGUtdGV4dHVyZScpXG5cbnZhciB2ZXJ0TnVtRmxvYXRzID0gcmVxdWlyZSgnLi9jb21tb24nKS5mbG9hdHNQZXJWZXJ0ZXhcblxuLy9UZW1wb3JhcnkgYXJyYXlzIHRvIGF2b2lkIEdDIHRocmFzaGluZ1xudmFyIHBvc2l0aW9uID0gWzAsIDBdLFxuICAgIHNoYXBlID0gWzAsIDBdLFxuICAgIHRleGNvb3JkID0gWzAsIDAsIDAsIDBdLFxuICAgIGNvbG9yID0gWzAsIDAsIDAsIDBdXG5cbnZhciB0bXA0ID0gWzAsIDAsIDAsIDBdLFxuICAgIHJvdE9yaWdpbiA9IFswLCAwXSxcbiAgICB0bXAyID0gWzAsIDBdXG5cbmZ1bmN0aW9uIFNwcml0ZUJhdGNoKGdsLCBvcHQpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU3ByaXRlQmF0Y2gpKVxuICAgICAgICByZXR1cm4gbmV3IFNwcml0ZUJhdGNoKGdsLCBvcHQpXG4gICAgaWYgKCFnbClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibXVzdCBzcGVjaWZ5IGdsIGNvbnRleHRcIilcbiAgICB0aGlzLmdsID0gZ2xcbiAgICBvcHQgPSBvcHQgfHwge31cbiAgICBcbiAgICB0aGlzLl9ib3VuZCA9IGZhbHNlXG4gICAgdGhpcy5pZHggPSAwXG5cbiAgICAvL25vIHRyYW5zZm9ybSBtZWFucyBpZGVudGl0eVxuICAgIHRoaXMudHJhbnNmb3JtID0gbnVsbFxuXG4gICAgLy93aGl0ZSB0ZXh0dXJlIGlzIGFraW4gdG8gXCJubyB0ZXh0dXJlXCIgKHdpdGhvdXQgc3dpdGNoaW5nIHNoYWRlcnMpXG4gICAgdGhpcy5fZGVmYXVsdFRleHR1cmUgPSBvcHQuZGVmYXVsdFRleHR1cmUgfHwgV2hpdGVUZXgoZ2wpXG4gICAgdGhpcy5fb3duc0RlZmF1bHQgPSAhb3B0LmRlZmF1bHRUZXh0dXJlXG4gICAgdGhpcy5fbGFzdFRleHR1cmUgPSB0aGlzLl9kZWZhdWx0VGV4dHVyZVxuICAgIHRoaXMuX3RleHR1cmUgPSB0aGlzLl9kZWZhdWx0VGV4dHVyZVxuICAgIHRoaXMudGV4dHVyZSA9IG51bGxcblxuICAgIHRoaXMubW9kZSA9IHR5cGVvZiBvcHQubW9kZSA9PT0gJ251bWJlcicgPyBvcHQubW9kZSA6IGdsLlRSSUFOR0xFU1xuICAgIHRoaXMucHJlbXVsdGlwbGllZCA9IG9wdC5wcmVtdWx0aXBsaWVkIHx8IGZhbHNlXG5cbiAgICB0aGlzLl9kaXJ0eSA9IHRydWVcbiAgICB0aGlzLmNyZWF0ZShvcHQpXG5cbiAgICAvL3NldCBkZWZhdWx0IGF0dHJpYnV0ZXNcbiAgICB0aGlzLmRlZmF1bHRzKClcbn1cblxuLy9taXggaW4gY3JlYXRlKCkgYW5kIGVuc3VyZUNhcGFjaXR5KCkgZnVuY3Rpb25zXG5taXhlcyhTcHJpdGVCYXRjaCwgcmVxdWlyZSgnLi9jb21tb24nKS5taXhpbnMpXG5cbm1peGVzKFNwcml0ZUJhdGNoLCB7XG5cbiAgICBjYXBhY2l0eToge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NhcGFjaXR5XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgdGV4dHVyZToge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RleHR1cmVcbiAgICAgICAgfSxcblxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHRleCkge1xuICAgICAgICAgICAgdGhpcy5fdGV4dHVyZSA9IHRleCB8fCB0aGlzLl9kZWZhdWx0VGV4dHVyZVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIGRpc3Bvc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy52ZXJ0ZXhCdWZmZXIpXG4gICAgICAgICAgICB0aGlzLnZlcnRleEJ1ZmZlci5kaXNwb3NlKClcbiAgICAgICAgaWYgKHRoaXMuaW5kZXhCdWZmZXIpXG4gICAgICAgICAgICB0aGlzLmluZGV4QnVmZmVyLmRpc3Bvc2UoKVxuICAgICAgICBpZiAodGhpcy52YW8pXG4gICAgICAgICAgICB0aGlzLnZhby5kaXNwb3NlKClcbiAgICAgICAgaWYgKHRoaXMuX293bnNEZWZhdWx0KVxuICAgICAgICAgICAgdGhpcy5fZGVmYXVsdFRleHR1cmUuZGlzcG9zZSgpXG4gICAgfSxcblxuICAgIGNsZWFyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5pZHggPSAwXG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgfSxcblxuICAgIGJpbmQ6IGZ1bmN0aW9uKHNoYWRlcikge1xuICAgICAgICBzaGFkZXIuYmluZCgpXG4gICAgICAgIHRoaXMudmFvLmJpbmQoc2hhZGVyKVxuICAgICAgICB0aGlzLl9ib3VuZCA9IHRydWVcbiAgICB9LFxuXG4gICAgdW5iaW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy52YW8udW5iaW5kKClcbiAgICAgICAgdGhpcy5fYm91bmQgPSBmYWxzZVxuICAgIH0sXG5cbiAgICBkZWZhdWx0czogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMucG9zaXRpb24gPSBjb3B5Mihwb3NpdGlvbiwgMCwgMClcbiAgICAgICAgdGhpcy50ZXhjb29yZCA9IGNvcHk0KHRleGNvb3JkLCAwLCAwLCAxLCAxKVxuICAgICAgICB0aGlzLmNvbG9yID0gY29weTQoY29sb3IsIDEsIDEsIDEsIDEpXG4gICAgICAgIHRoaXMuc2hhcGUgPSBjb3B5MihzaGFwZSwgMCwgMClcbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICB9LFxuXG4gICAgcHVzaDogZnVuY3Rpb24oc3ByaXRlKSB7XG4gICAgICAgIC8vaWYgd2UgYXJlIGRlZmluaW5nIGF0dHJpYnV0ZXMgb24gdGhlIGZseVxuICAgICAgICBpZiAoc3ByaXRlKSB7XG4gICAgICAgICAgICB0aGlzLnRleHR1cmUgPSBzcHJpdGUudGV4dHVyZVxuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbiA9IHNwcml0ZS5wb3NpdGlvbiB8fCBjb3B5Mihwb3NpdGlvbiwgMCwgMClcbiAgICAgICAgICAgIHRoaXMudGV4Y29vcmQgPSBzcHJpdGUudGV4Y29vcmQgfHwgY29weTQodGV4Y29vcmQsIDAsIDAsIDEsIDEpXG4gICAgICAgICAgICB0aGlzLmNvbG9yID0gc3ByaXRlLmNvbG9yIHx8IGNvcHk0KGNvbG9yLCAxLCAxLCAxLCAxKVxuICAgICAgICAgICAgdGhpcy5zaGFwZSA9IHNwcml0ZS5zaGFwZSB8fCBjb3B5MihzaGFwZSwgMCwgMClcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnRleHR1cmUgIT09IHRoaXMuX2xhc3RUZXh0dXJlKSB7XG4gICAgICAgICAgICAvL25ldyB0ZXh0dXJlLCBmbHVzaCBwcmV2aW91cyBkYXRhXG4gICAgICAgICAgICBpZiAodGhpcy5fYm91bmQpXG4gICAgICAgICAgICAgICAgdGhpcy5mbHVzaCgpXG4gICAgICAgICAgICB0aGlzLl9sYXN0VGV4dHVyZSA9IHRoaXMudGV4dHVyZVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaWR4ID09PSB0aGlzLnZlcnRpY2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgLy9pZiB3ZSBBUkVOJ1QgYm91bmQsIHdlIG5lZWQgdG8gc3RvcCBwdXNoaW5nIHZlcnRleCBkYXRhIVxuICAgICAgICAgICAgaWYgKCF0aGlzLl9ib3VuZClcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1xuXG4gICAgICAgICAgICAvL2lmIHdlIEFSRSBib3VuZCwgd2UgY2FuIGZsdXNoIHRoZSBiYXRjaCBhbmQgY29udGludWUgZHJhd2luZ1xuICAgICAgICAgICAgdGhpcy5mbHVzaCgpXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9kaXJ0eSA9IHRydWVcblxuICAgICAgICAvL2dldCBSR0JBIGNvbXBvbmVudHMgYW5kIHBhY2sgaW50byBhIHNpbmdsZSBmbG9hdFxuICAgICAgICB2YXIgY29sb3JSR0JBID0gdGhpcy5wcmVtdWx0aXBsaWVkID8gcHJlbXVsdCh0aGlzLmNvbG9yLCB0bXA0KSA6IHRoaXMuY29sb3JcbiAgICAgICAgdmFyIGMgPSBjb2xvclRvRmxvYXQoY29sb3JSR0JBKVxuXG4gICAgICAgIHZhciB1MSA9IHRoaXMudGV4Y29vcmRbMF0sXG4gICAgICAgICAgICB2MSA9IHRoaXMudGV4Y29vcmRbMV0sXG4gICAgICAgICAgICB1MiA9IHRoaXMudGV4Y29vcmRbMl0sXG4gICAgICAgICAgICB2MiA9IHRoaXMudGV4Y29vcmRbM11cblxuICAgICAgICB2YXIgeCA9IHRoaXMucG9zaXRpb25bMF0sXG4gICAgICAgICAgICB5ID0gdGhpcy5wb3NpdGlvblsxXSxcbiAgICAgICAgICAgIHdpZHRoID0gdGhpcy5zaGFwZVswXSxcbiAgICAgICAgICAgIGhlaWdodCA9IHRoaXMuc2hhcGVbMV1cblxuICAgICAgICB0aGlzLl92ZXJ0KHgsIHksIHUxLCB2MSwgYylcbiAgICAgICAgdGhpcy5fdmVydCh4K3dpZHRoLCB5LCB1MiwgdjEsIGMpXG4gICAgICAgIHRoaXMuX3ZlcnQoeCt3aWR0aCwgeStoZWlnaHQsIHUyLCB2MiwgYylcbiAgICAgICAgdGhpcy5fdmVydCh4LCB5K2hlaWdodCwgdTEsIHYyLCBjKVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICB9LFxuXG4gICAgX3ZlcnQ6IGZ1bmN0aW9uKHgxLCB5MSwgdTEsIHYxLCBjKSB7XG4gICAgICAgIHZhciBpZHggPSB0aGlzLmlkeCxcbiAgICAgICAgICAgIHZlcnRzID0gdGhpcy52ZXJ0aWNlcyxcbiAgICAgICAgICAgIHRyYW5zZm9ybSA9IHRoaXMudHJhbnNmb3JtXG5cbiAgICAgICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgICAgICAgdmFyIHggPSB4MSwgeSA9IHkxXG4gICAgICAgICAgICB4MSA9IHRyYW5zZm9ybVswXSAqIHggKyB0cmFuc2Zvcm1bNF0gKiB5ICsgdHJhbnNmb3JtWzEyXVxuICAgICAgICAgICAgeTEgPSB0cmFuc2Zvcm1bMV0gKiB4ICsgdHJhbnNmb3JtWzVdICogeSArIHRyYW5zZm9ybVsxM11cbiAgICAgICAgfVxuXG4gICAgICAgIC8veHlcbiAgICAgICAgdmVydHNbaWR4KytdID0geDFcbiAgICAgICAgdmVydHNbaWR4KytdID0geTFcbiAgICAgICAgLy91dlxuICAgICAgICB2ZXJ0c1tpZHgrK10gPSB1MVxuICAgICAgICB2ZXJ0c1tpZHgrK10gPSB2MVxuICAgICAgICAvL2NvbG9yXG4gICAgICAgIHZlcnRzW2lkeCsrXSA9IGNcbiAgICAgICAgdGhpcy5pZHggPSBpZHhcbiAgICB9LFxuXG4gICAgZmx1c2g6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmRyYXcoKVxuICAgICAgICByZXR1cm4gdGhpcy5jbGVhcigpXG4gICAgfSxcblxuICAgIGRyYXc6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvL0lmIHdlJ3ZlIHJlYWNoZWQgYSBuZXcgdGV4dHVyZSBvciBjYXBhY2l0eVxuICAgICAgICAvL3doaWxlIG5vdCBib3VuZCwgdGhlbiB3ZSB3aWxsIGp1c3QgY2xlYXIgdGhlIGJhdGNoXG4gICAgICAgIC8vdG8gemVybyBhbmQgZHJhdyBub3RoaW5nXG4gICAgICAgIGlmICh0aGlzLmlkeCA9PT0gMCB8fCAhdGhpcy5fYm91bmQpXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xuXG4gICAgICAgIHZhciBnbCA9IHRoaXMuZ2xcbiAgICAgICAgXG4gICAgICAgIGlmICh0aGlzLl9kaXJ0eSkge1xuICAgICAgICAgICAgdmFyIHZpZXcgPSB0aGlzLnZlcnRpY2VzLnN1YmFycmF5KDAsIHRoaXMuaWR4KVxuICAgICAgICAgICAgdGhpcy52ZXJ0ZXhCdWZmZXIudXBkYXRlKHZpZXcsIDApXG4gICAgICAgICAgICB0aGlzLl9kaXJ0eSA9IGZhbHNlXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fbGFzdFRleHR1cmUpXG4gICAgICAgICAgICB0aGlzLl9sYXN0VGV4dHVyZS5iaW5kKClcbiAgICAgICAgdGhpcy5fbGFzdFRleHR1cmUgPSB0aGlzLnRleHR1cmVcblxuICAgICAgICB2YXIgc3ByaXRlcyA9ICh0aGlzLmlkeCAvICh2ZXJ0TnVtRmxvYXRzICogNCkpXG4gICAgICAgIGlmIChzcHJpdGVzID4gMClcbiAgICAgICAgICAgIHRoaXMudmFvLmRyYXcodGhpcy5tb2RlLCBzcHJpdGVzICogNiwgMClcbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICB9LFxufSlcblxubW9kdWxlLmV4cG9ydHMgPSBTcHJpdGVCYXRjaFxuXG4vL1RPRE86IHdpbGwgdXNlIG1vZHVsYXIgZ2wtbWF0cml4IGZvciB0aGVzZS4uLlxuZnVuY3Rpb24gY29weTIob3V0LCB4LCB5KSB7XG4gICAgb3V0WzBdID0geFxuICAgIG91dFsxXSA9IHlcbiAgICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIGNvcHk0KG91dCwgeCwgeSwgeiwgdykge1xuICAgIG91dFswXSA9IHhcbiAgICBvdXRbMV0gPSB5XG4gICAgb3V0WzJdID0gelxuICAgIG91dFszXSA9IHdcbiAgICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIGNvcHlWZWMyKG91dCwgdmVjKSB7XG4gICAgcmV0dXJuIGNvcHkyKG91dCwgdmVjWzBdLCB2ZWNbMV0pXG59XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybU1hdDQob3V0LCBhLCBtKSB7XG4gICAgdmFyIHggPSBhWzBdLCBcbiAgICAgICAgeSA9IGFbMV1cbiAgICBvdXRbMF0gPSBtWzBdICogeCArIG1bNF0gKiB5ICsgbVsxMl1cbiAgICBvdXRbMV0gPSBtWzFdICogeCArIG1bNV0gKiB5ICsgbVsxM11cbiAgICByZXR1cm4gb3V0XG59IiwidmFyIGNyZWF0ZVZBT0VtdWxhdGVkID0gcmVxdWlyZShcIi4vbGliL3Zhby1lbXVsYXRlZC5qc1wiKVxuXG5mdW5jdGlvbiBjcmVhdGVWQU8oZ2wsIGF0dHJpYnV0ZXMsIGVsZW1lbnRzLCBlbGVtZW50c1R5cGUpIHtcbiAgdmFyIHZhbyA9IGNyZWF0ZVZBT0VtdWxhdGVkKGdsKVxuICB2YW8udXBkYXRlKGF0dHJpYnV0ZXMsIGVsZW1lbnRzLCBlbGVtZW50c1R5cGUpXG4gIHJldHVybiB2YW9cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVWQU8iLCJmdW5jdGlvbiBnZXRBdHRyaWJ1dGVMb2NhdGlvbihuYW1lLCBzaGFkZXIpIHtcbiAgICBpZiAoIW5hbWUpXG4gICAgICAgIHJldHVybiBudWxsXG4gICAgdmFyIGF0dHIgPSBzaGFkZXIuYXR0cmlidXRlc1xuICAgIGlmIChhdHRyW25hbWVdKSBcbiAgICAgICAgcmV0dXJuIGF0dHJbbmFtZV0ubG9jYXRpb25cbiAgICByZXR1cm4gbnVsbFxufVxuXG52YXIgbmF0dHJpYnMgPSBudWxsXG52YXIgYm91bmQgPSBudWxsXG5cbmZ1bmN0aW9uIGRvQmluZChnbCwgZWxlbWVudHMsIGF0dHJpYnV0ZXMsIHNoYWRlcikge1xuICAgIGlmIChlbGVtZW50cykge1xuICAgICAgICBlbGVtZW50cy5iaW5kKClcbiAgICB9IGVsc2Uge1xuICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBudWxsKVxuICAgIH1cbiAgICBpZiAobmF0dHJpYnMgPT09IG51bGwpIHtcbiAgICAgIG5hdHRyaWJzID0gZ2wuZ2V0UGFyYW1ldGVyKGdsLk1BWF9WRVJURVhfQVRUUklCUykgfCAwXG4gICAgICBib3VuZCA9IG5ldyBBcnJheShuYXR0cmlicylcbiAgICB9XG5cbiAgICBpZiAoYXR0cmlidXRlcykge1xuICAgICAgICBpZiAoYXR0cmlidXRlcy5sZW5ndGggPiBuYXR0cmlicykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZ2wtdmFvOiBUb28gbWFueSB2ZXJ0ZXggYXR0cmlidXRlc1wiKVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxhc3RCb3VuZCA9IG51bGxcblxuICAgICAgICBmb3IgKGk9MDsgaTxuYXR0cmliczsgaSsrKVxuICAgICAgICAgIGJvdW5kW2ldID0gZmFsc2VcblxuICAgICAgICAvL25vdyBiaW5kIGFsaWFzZWQgYXR0cmlidXRlc1xuICAgICAgICBmb3IgKGk9MDsgaTxhdHRyaWJ1dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYXR0cmliID0gYXR0cmlidXRlc1tpXVxuICAgICAgICAgICAgdmFyIGxvYyA9IGdldEF0dHJpYnV0ZUxvY2F0aW9uKGF0dHJpYi5uYW1lLCBzaGFkZXIpXG4gICAgICAgICAgICBpZiAobG9jID09PSBudWxsKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgICAgIGJvdW5kW2xvY10gPSB0cnVlXG5cbiAgICAgICAgICAgIGlmKGF0dHJpYi5idWZmZXIpIHtcbiAgICAgICAgICAgICAgdmFyIGJ1ZmZlciA9IGF0dHJpYi5idWZmZXJcbiAgICAgICAgICAgICAgdmFyIHNpemUgPSBhdHRyaWIuc2l6ZSB8fCA0XG4gICAgICAgICAgICAgIHZhciB0eXBlID0gYXR0cmliLnR5cGUgfHwgZ2wuRkxPQVRcbiAgICAgICAgICAgICAgdmFyIG5vcm1hbGl6ZWQgPSAhIWF0dHJpYi5ub3JtYWxpemVkXG4gICAgICAgICAgICAgIHZhciBzdHJpZGUgPSBhdHRyaWIuc3RyaWRlIHx8IDBcbiAgICAgICAgICAgICAgdmFyIG9mZnNldCA9IGF0dHJpYi5vZmZzZXQgfHwgMFxuICAgICAgICAgICAgICBpZiAobGFzdEJvdW5kICE9PSBidWZmZXIpIHtcbiAgICAgICAgICAgICAgICBidWZmZXIuYmluZCgpXG4gICAgICAgICAgICAgICAgbGFzdEJvdW5kID0gYnVmZmVyXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkobG9jKVxuICAgICAgICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGxvYywgc2l6ZSwgdHlwZSwgbm9ybWFsaXplZCwgc3RyaWRlLCBvZmZzZXQpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZih0eXBlb2YgYXR0cmliID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgZ2wudmVydGV4QXR0cmliMWYobG9jLCBhdHRyaWIpXG4gICAgICAgICAgICAgIH0gZWxzZSBpZihhdHRyaWIubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgZ2wudmVydGV4QXR0cmliMWYobG9jLCBhdHRyaWJbMF0pXG4gICAgICAgICAgICAgIH0gZWxzZSBpZihhdHRyaWIubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgICAgZ2wudmVydGV4QXR0cmliMmYobG9jLCBhdHRyaWJbMF0sIGF0dHJpYlsxXSlcbiAgICAgICAgICAgICAgfSBlbHNlIGlmKGF0dHJpYi5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgICAgICAgICBnbC52ZXJ0ZXhBdHRyaWIzZihsb2MsIGF0dHJpYlswXSwgYXR0cmliWzFdLCBhdHRyaWJbMl0pXG4gICAgICAgICAgICAgIH0gZWxzZSBpZihhdHRyaWIubGVuZ3RoID09PSA0KSB7XG4gICAgICAgICAgICAgICAgZ2wudmVydGV4QXR0cmliNGYobG9jLCBhdHRyaWJbMF0sIGF0dHJpYlsxXSwgYXR0cmliWzJdLCBhdHRyaWJbM10pXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZ2wtdmFvOiBJbnZhbGlkIHZlcnRleCBhdHRyaWJ1dGVcIilcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBnbC5kaXNhYmxlVmVydGV4QXR0cmliQXJyYXkobG9jKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGZvciAoaT0wOyBpPG5hdHRyaWJzOyBpKyspIHtcbiAgICAgICAgICBpZiAoIWJvdW5kW2ldKVxuICAgICAgICAgICAgZ2wuZGlzYWJsZVZlcnRleEF0dHJpYkFycmF5KGkpXG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIG51bGwpXG4gICAgICBmb3IodmFyIGk9MDsgaTxuYXR0cmliczsgKytpKSB7XG4gICAgICAgIGdsLmRpc2FibGVWZXJ0ZXhBdHRyaWJBcnJheShpKVxuICAgICAgfVxuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBkb0JpbmQiLCJ2YXIgYmluZEF0dHJpYnMgPSByZXF1aXJlKFwiLi9kby1iaW5kLmpzXCIpXG5cbmZ1bmN0aW9uIFZBT0VtdWxhdGVkKGdsKSB7XG4gIHRoaXMuZ2wgPSBnbFxuICB0aGlzLl9lbGVtZW50cyA9IG51bGxcbiAgdGhpcy5fYXR0cmlidXRlcyA9IG51bGxcbiAgdGhpcy5fZWxlbWVudHNUeXBlID0gZ2wuVU5TSUdORURfU0hPUlRcbn1cblxuVkFPRW11bGF0ZWQucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbihzaGFkZXIpIHtcbiAgaWYgKCFzaGFkZXIpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdtdXN0IGFzc29jaWF0ZSBzaGFkZXIgd2l0aCB2ZXJ0ZXggYXJyYXknKVxuICBiaW5kQXR0cmlicyh0aGlzLmdsLCB0aGlzLl9lbGVtZW50cywgdGhpcy5fYXR0cmlidXRlcywgc2hhZGVyKVxufVxuXG5WQU9FbXVsYXRlZC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oYXR0cmlidXRlcywgZWxlbWVudHMsIGVsZW1lbnRzVHlwZSkge1xuICB0aGlzLl9lbGVtZW50cyA9IGVsZW1lbnRzXG4gIHRoaXMuX2F0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzXG4gIHRoaXMuX2VsZW1lbnRzVHlwZSA9IGVsZW1lbnRzVHlwZSB8fCB0aGlzLmdsLlVOU0lHTkVEX1NIT1JUXG59XG5cblZBT0VtdWxhdGVkLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24oKSB7IH1cblZBT0VtdWxhdGVkLnByb3RvdHlwZS51bmJpbmQgPSBmdW5jdGlvbigpIHtcbiAgYmluZEF0dHJpYnModGhpcy5nbClcbn1cblxuVkFPRW11bGF0ZWQucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbihtb2RlLCBjb3VudCwgb2Zmc2V0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8fCAwXG4gIHZhciBnbCA9IHRoaXMuZ2xcbiAgaWYodGhpcy5fZWxlbWVudHMpIHtcbiAgICBnbC5kcmF3RWxlbWVudHMobW9kZSwgY291bnQsIHRoaXMuX2VsZW1lbnRzVHlwZSwgb2Zmc2V0KVxuICB9IGVsc2Uge1xuICAgIGdsLmRyYXdBcnJheXMobW9kZSwgb2Zmc2V0LCBjb3VudClcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVWQU9FbXVsYXRlZChnbCkge1xuICByZXR1cm4gbmV3IFZBT0VtdWxhdGVkKGdsKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZVZBT0VtdWxhdGVkIiwiXCJ1c2Ugc3RyaWN0XCJcblxudmFyIHBvb2wgPSByZXF1aXJlKFwidHlwZWRhcnJheS1wb29sXCIpXG52YXIgb3BzID0gcmVxdWlyZShcIm5kYXJyYXktb3BzXCIpXG52YXIgbmRhcnJheSA9IHJlcXVpcmUoXCJuZGFycmF5XCIpXG52YXIgd2ViZ2xldyA9IHJlcXVpcmUoXCJ3ZWJnbGV3XCIpXG5cbnZhciBTVVBQT1JURURfVFlQRVMgPSBbXG4gIFwidWludDhcIixcbiAgXCJ1aW50OF9jbGFtcGVkXCIsXG4gIFwidWludDE2XCIsXG4gIFwidWludDMyXCIsXG4gIFwiaW50OFwiLFxuICBcImludDE2XCIsXG4gIFwiaW50MzJcIixcbiAgXCJmbG9hdDMyXCIgXVxuXG5mdW5jdGlvbiBHTEJ1ZmZlcihnbCwgdHlwZSwgaGFuZGxlLCBsZW5ndGgsIHVzYWdlKSB7XG4gIHRoaXMuZ2wgPSBnbFxuICB0aGlzLnR5cGUgPSB0eXBlXG4gIHRoaXMuaGFuZGxlID0gaGFuZGxlXG4gIHRoaXMubGVuZ3RoID0gbGVuZ3RoXG4gIHRoaXMudXNhZ2UgPSB1c2FnZVxufVxuXG52YXIgcHJvdG8gPSBHTEJ1ZmZlci5wcm90b3R5cGVcblxucHJvdG8uYmluZCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmdsLmJpbmRCdWZmZXIodGhpcy50eXBlLCB0aGlzLmhhbmRsZSlcbn1cblxucHJvdG8udW5iaW5kID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZ2wuYmluZEJ1ZmZlcih0aGlzLnR5cGUsIG51bGwpXG59XG5cbnByb3RvLmRpc3Bvc2UgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5nbC5kZWxldGVCdWZmZXIodGhpcy5oYW5kbGUpXG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVR5cGVBcnJheShnbCwgdHlwZSwgbGVuLCB1c2FnZSwgZGF0YSwgb2Zmc2V0KSB7XG4gIHZhciBkYXRhTGVuID0gZGF0YS5sZW5ndGggKiBkYXRhLkJZVEVTX1BFUl9FTEVNRU5UIFxuICBpZihvZmZzZXQgPCAwKSB7XG4gICAgZ2wuYnVmZmVyRGF0YSh0eXBlLCBkYXRhLCB1c2FnZSlcbiAgICByZXR1cm4gZGF0YUxlblxuICB9XG4gIGlmKGRhdGFMZW4gKyBvZmZzZXQgPiBsZW4pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJnbC1idWZmZXI6IElmIHJlc2l6aW5nIGJ1ZmZlciwgbXVzdCBub3Qgc3BlY2lmeSBvZmZzZXRcIilcbiAgfVxuICBnbC5idWZmZXJTdWJEYXRhKHR5cGUsIG9mZnNldCwgZGF0YSlcbiAgcmV0dXJuIGxlblxufVxuXG5mdW5jdGlvbiBtYWtlU2NyYXRjaFR5cGVBcnJheShhcnJheSwgZHR5cGUpIHtcbiAgdmFyIHJlcyA9IHBvb2wubWFsbG9jKGFycmF5Lmxlbmd0aCwgZHR5cGUpXG4gIHZhciBuID0gYXJyYXkubGVuZ3RoXG4gIGZvcih2YXIgaT0wOyBpPG47ICsraSkge1xuICAgIHJlc1tpXSA9IGFycmF5W2ldXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBpc1BhY2tlZChzaGFwZSwgc3RyaWRlKSB7XG4gIHZhciBuID0gMVxuICBmb3IodmFyIGk9c3RyaWRlLmxlbmd0aC0xOyBpPj0wOyAtLWkpIHtcbiAgICBpZihzdHJpZGVbaV0gIT09IG4pIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICBuICo9IHNoYXBlW2ldXG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxucHJvdG8udXBkYXRlID0gZnVuY3Rpb24oYXJyYXksIG9mZnNldCkge1xuICBpZih0eXBlb2Ygb2Zmc2V0ICE9PSBcIm51bWJlclwiKSB7XG4gICAgb2Zmc2V0ID0gLTFcbiAgfVxuICB0aGlzLmJpbmQoKVxuICBpZih0eXBlb2YgYXJyYXkgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIGFycmF5LnNoYXBlICE9PSBcInVuZGVmaW5lZFwiKSB7IC8vbmRhcnJheVxuICAgIHZhciBkdHlwZSA9IGFycmF5LmR0eXBlXG4gICAgaWYoU1VQUE9SVEVEX1RZUEVTLmluZGV4T2YoZHR5cGUpIDwgMCkge1xuICAgICAgZHR5cGUgPSBcImZsb2F0MzJcIlxuICAgIH1cbiAgICBpZih0aGlzLnR5cGUgPT09IHRoaXMuZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIpIHtcbiAgICAgIHZhciB3Z2wgPSB3ZWJnbGV3KHRoaXMuZ2wpXG4gICAgICB2YXIgZXh0ID0gd2dsLk9FU19lbGVtZW50X2luZGV4X3VpbnRcbiAgICAgIGlmKGV4dCAmJiBkdHlwZSAhPT0gXCJ1aW50MTZcIikge1xuICAgICAgICBkdHlwZSA9IFwidWludDMyXCJcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGR0eXBlID0gXCJ1aW50MTZcIlxuICAgICAgfVxuICAgIH1cbiAgICBpZihkdHlwZSA9PT0gYXJyYXkuZHR5cGUgJiYgaXNQYWNrZWQoYXJyYXkuc2hhcGUsIGFycmF5LnN0cmlkZSkpIHtcbiAgICAgIGlmKGFycmF5Lm9mZnNldCA9PT0gMCAmJiBhcnJheS5kYXRhLmxlbmd0aCA9PT0gYXJyYXkuc2hhcGVbMF0pIHtcbiAgICAgICAgdGhpcy5sZW5ndGggPSB1cGRhdGVUeXBlQXJyYXkodGhpcy5nbCwgdGhpcy50eXBlLCB0aGlzLmxlbmd0aCwgdGhpcy51c2FnZSwgYXJyYXkuZGF0YSwgb2Zmc2V0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5sZW5ndGggPSB1cGRhdGVUeXBlQXJyYXkodGhpcy5nbCwgdGhpcy50eXBlLCB0aGlzLmxlbmd0aCwgdGhpcy51c2FnZSwgYXJyYXkuZGF0YS5zdWJhcnJheShhcnJheS5vZmZzZXQsIGFycmF5LnNoYXBlWzBdKSwgb2Zmc2V0KVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgdG1wID0gcG9vbC5tYWxsb2MoYXJyYXkuc2l6ZSwgZHR5cGUpXG4gICAgICB2YXIgbmR0ID0gbmRhcnJheSh0bXAsIGFycmF5LnNoYXBlKVxuICAgICAgb3BzLmFzc2lnbihuZHQsIGFycmF5KVxuICAgICAgaWYob2Zmc2V0IDwgMCkge1xuICAgICAgICB0aGlzLmxlbmd0aCA9IHVwZGF0ZVR5cGVBcnJheSh0aGlzLmdsLCB0aGlzLnR5cGUsIHRoaXMubGVuZ3RoLCB0aGlzLnVzYWdlLCB0bXAsIG9mZnNldCkgIFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5sZW5ndGggPSB1cGRhdGVUeXBlQXJyYXkodGhpcy5nbCwgdGhpcy50eXBlLCB0aGlzLmxlbmd0aCwgdGhpcy51c2FnZSwgdG1wLnN1YmFycmF5KDAsIGFycmF5LnNpemUpLCBvZmZzZXQpICBcbiAgICAgIH1cbiAgICAgIHBvb2wuZnJlZSh0bXApXG4gICAgfVxuICB9IGVsc2UgaWYoQXJyYXkuaXNBcnJheShhcnJheSkpIHsgLy9WYW5pbGxhIGFycmF5XG4gICAgdmFyIHRcbiAgICBpZih0aGlzLnR5cGUgPT09IHRoaXMuZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIpIHtcbiAgICAgIHQgPSBtYWtlU2NyYXRjaFR5cGVBcnJheShhcnJheSwgXCJ1aW50MTZcIilcbiAgICB9IGVsc2Uge1xuICAgICAgdCA9IG1ha2VTY3JhdGNoVHlwZUFycmF5KGFycmF5LCBcImZsb2F0MzJcIilcbiAgICB9XG4gICAgaWYob2Zmc2V0IDwgMCkge1xuICAgICAgdGhpcy5sZW5ndGggPSB1cGRhdGVUeXBlQXJyYXkodGhpcy5nbCwgdGhpcy50eXBlLCB0aGlzLmxlbmd0aCwgdGhpcy51c2FnZSwgdCwgb2Zmc2V0KVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmxlbmd0aCA9IHVwZGF0ZVR5cGVBcnJheSh0aGlzLmdsLCB0aGlzLnR5cGUsIHRoaXMubGVuZ3RoLCB0aGlzLnVzYWdlLCB0LnN1YmFycmF5KDAsIGFycmF5Lmxlbmd0aCksIG9mZnNldClcbiAgICB9XG4gICAgcG9vbC5mcmVlKHQpXG4gIH0gZWxzZSBpZih0eXBlb2YgYXJyYXkgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIGFycmF5Lmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyAvL1R5cGVkIGFycmF5XG4gICAgdGhpcy5sZW5ndGggPSB1cGRhdGVUeXBlQXJyYXkodGhpcy5nbCwgdGhpcy50eXBlLCB0aGlzLmxlbmd0aCwgdGhpcy51c2FnZSwgYXJyYXksIG9mZnNldClcbiAgfSBlbHNlIGlmKHR5cGVvZiBhcnJheSA9PT0gXCJudW1iZXJcIiB8fCBhcnJheSA9PT0gdW5kZWZpbmVkKSB7IC8vTnVtYmVyL2RlZmF1bHRcbiAgICBpZihvZmZzZXQgPj0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZ2wtYnVmZmVyOiBDYW5ub3Qgc3BlY2lmeSBvZmZzZXQgd2hlbiByZXNpemluZyBidWZmZXJcIilcbiAgICB9XG4gICAgYXJyYXkgPSBhcnJheSB8IDBcbiAgICBpZihhcnJheSA8PSAwKSB7XG4gICAgICBhcnJheSA9IDFcbiAgICB9XG4gICAgdGhpcy5nbC5idWZmZXJEYXRhKHRoaXMudHlwZSwgYXJyYXl8MCwgdGhpcy51c2FnZSlcbiAgICB0aGlzLmxlbmd0aCA9IGFycmF5XG4gIH0gZWxzZSB7IC8vRXJyb3IsIGNhc2Ugc2hvdWxkIG5vdCBoYXBwZW5cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJnbC1idWZmZXI6IEludmFsaWQgZGF0YSB0eXBlXCIpXG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlQnVmZmVyKGdsLCBkYXRhLCB0eXBlLCB1c2FnZSkge1xuICB3ZWJnbGV3KGdsKVxuICB0eXBlID0gdHlwZSB8fCBnbC5BUlJBWV9CVUZGRVJcbiAgdXNhZ2UgPSB1c2FnZSB8fCBnbC5EWU5BTUlDX0RSQVdcbiAgaWYodHlwZSAhPT0gZ2wuQVJSQVlfQlVGRkVSICYmIHR5cGUgIT09IGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZ2wtYnVmZmVyOiBJbnZhbGlkIHR5cGUgZm9yIHdlYmdsIGJ1ZmZlciwgbXVzdCBiZSBlaXRoZXIgZ2wuQVJSQVlfQlVGRkVSIG9yIGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSXCIpXG4gIH1cbiAgaWYodXNhZ2UgIT09IGdsLkRZTkFNSUNfRFJBVyAmJiB1c2FnZSAhPT0gZ2wuU1RBVElDX0RSQVcgJiYgdXNhZ2UgIT09IGdsLlNUUkVBTV9EUkFXKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZ2wtYnVmZmVyOiBJbnZhbGlkIHVzYWdlIGZvciBidWZmZXIsIG11c3QgYmUgZWl0aGVyIGdsLkRZTkFNSUNfRFJBVywgZ2wuU1RBVElDX0RSQVcgb3IgZ2wuU1RSRUFNX0RSQVdcIilcbiAgfVxuICB2YXIgaGFuZGxlID0gZ2wuY3JlYXRlQnVmZmVyKClcbiAgdmFyIHJlc3VsdCA9IG5ldyBHTEJ1ZmZlcihnbCwgdHlwZSwgaGFuZGxlLCAwLCB1c2FnZSlcbiAgcmVzdWx0LnVwZGF0ZShkYXRhKVxuICByZXR1cm4gcmVzdWx0XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlQnVmZmVyIiwibW9kdWxlLmV4cG9ydHM9cmVxdWlyZShcIi9wcm9qZWN0cy9ibGFja2ljZS9ub2RlX21vZHVsZXMvZ2wtc3ByaXRlLXRleHQvbm9kZV9tb2R1bGVzL2dsLXRleHR1cmUyZC9ub2RlX21vZHVsZXMvbmRhcnJheS1vcHMvbmRhcnJheS1vcHMuanNcIikiLCIoZnVuY3Rpb24gKEJ1ZmZlcil7XG52YXIgaW90YSA9IHJlcXVpcmUoXCJpb3RhLWFycmF5XCIpXG5cbnZhciBoYXNUeXBlZEFycmF5cyAgPSAoKHR5cGVvZiBGbG9hdDY0QXJyYXkpICE9PSBcInVuZGVmaW5lZFwiKVxudmFyIGhhc0J1ZmZlciAgICAgICA9ICgodHlwZW9mIEJ1ZmZlcikgIT09IFwidW5kZWZpbmVkXCIpXG5cbmZ1bmN0aW9uIGNvbXBhcmUxc3QoYSwgYikge1xuICByZXR1cm4gYVswXSAtIGJbMF1cbn1cblxuZnVuY3Rpb24gb3JkZXIoKSB7XG4gIHZhciBzdHJpZGUgPSB0aGlzLnN0cmlkZVxuICB2YXIgdGVybXMgPSBuZXcgQXJyYXkoc3RyaWRlLmxlbmd0aClcbiAgdmFyIGlcbiAgZm9yKGk9MDsgaTx0ZXJtcy5sZW5ndGg7ICsraSkge1xuICAgIHRlcm1zW2ldID0gW01hdGguYWJzKHN0cmlkZVtpXSksIGldXG4gIH1cbiAgdGVybXMuc29ydChjb21wYXJlMXN0KVxuICB2YXIgcmVzdWx0ID0gbmV3IEFycmF5KHRlcm1zLmxlbmd0aClcbiAgZm9yKGk9MDsgaTxyZXN1bHQubGVuZ3RoOyArK2kpIHtcbiAgICByZXN1bHRbaV0gPSB0ZXJtc1tpXVsxXVxuICB9XG4gIHJldHVybiByZXN1bHRcbn1cblxuZnVuY3Rpb24gY29tcGlsZUNvbnN0cnVjdG9yKGR0eXBlLCBkaW1lbnNpb24pIHtcbiAgdmFyIGNsYXNzTmFtZSA9IFtcIlZpZXdcIiwgZGltZW5zaW9uLCBcImRcIiwgZHR5cGVdLmpvaW4oXCJcIilcbiAgaWYoZGltZW5zaW9uIDwgMCkge1xuICAgIGNsYXNzTmFtZSA9IFwiVmlld19OaWxcIiArIGR0eXBlXG4gIH1cbiAgdmFyIHVzZUdldHRlcnMgPSAoZHR5cGUgPT09IFwiZ2VuZXJpY1wiKVxuICBcbiAgaWYoZGltZW5zaW9uID09PSAtMSkge1xuICAgIC8vU3BlY2lhbCBjYXNlIGZvciB0cml2aWFsIGFycmF5c1xuICAgIHZhciBjb2RlID0gXG4gICAgICBcImZ1bmN0aW9uIFwiK2NsYXNzTmFtZStcIihhKXt0aGlzLmRhdGE9YTt9O1xcXG52YXIgcHJvdG89XCIrY2xhc3NOYW1lK1wiLnByb3RvdHlwZTtcXFxucHJvdG8uZHR5cGU9J1wiK2R0eXBlK1wiJztcXFxucHJvdG8uaW5kZXg9ZnVuY3Rpb24oKXtyZXR1cm4gLTF9O1xcXG5wcm90by5zaXplPTA7XFxcbnByb3RvLmRpbWVuc2lvbj0tMTtcXFxucHJvdG8uc2hhcGU9cHJvdG8uc3RyaWRlPXByb3RvLm9yZGVyPVtdO1xcXG5wcm90by5sbz1wcm90by5oaT1wcm90by50cmFuc3Bvc2U9cHJvdG8uc3RlcD1cXFxuZnVuY3Rpb24oKXtyZXR1cm4gbmV3IFwiK2NsYXNzTmFtZStcIih0aGlzLmRhdGEpO307XFxcbnByb3RvLmdldD1wcm90by5zZXQ9ZnVuY3Rpb24oKXt9O1xcXG5wcm90by5waWNrPWZ1bmN0aW9uKCl7cmV0dXJuIG51bGx9O1xcXG5yZXR1cm4gZnVuY3Rpb24gY29uc3RydWN0X1wiK2NsYXNzTmFtZStcIihhKXtyZXR1cm4gbmV3IFwiK2NsYXNzTmFtZStcIihhKTt9XCJcbiAgICB2YXIgcHJvY2VkdXJlID0gbmV3IEZ1bmN0aW9uKGNvZGUpXG4gICAgcmV0dXJuIHByb2NlZHVyZSgpXG4gIH0gZWxzZSBpZihkaW1lbnNpb24gPT09IDApIHtcbiAgICAvL1NwZWNpYWwgY2FzZSBmb3IgMGQgYXJyYXlzXG4gICAgdmFyIGNvZGUgPVxuICAgICAgXCJmdW5jdGlvbiBcIitjbGFzc05hbWUrXCIoYSxkKSB7XFxcbnRoaXMuZGF0YSA9IGE7XFxcbnRoaXMub2Zmc2V0ID0gZFxcXG59O1xcXG52YXIgcHJvdG89XCIrY2xhc3NOYW1lK1wiLnByb3RvdHlwZTtcXFxucHJvdG8uZHR5cGU9J1wiK2R0eXBlK1wiJztcXFxucHJvdG8uaW5kZXg9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5vZmZzZXR9O1xcXG5wcm90by5kaW1lbnNpb249MDtcXFxucHJvdG8uc2l6ZT0xO1xcXG5wcm90by5zaGFwZT1cXFxucHJvdG8uc3RyaWRlPVxcXG5wcm90by5vcmRlcj1bXTtcXFxucHJvdG8ubG89XFxcbnByb3RvLmhpPVxcXG5wcm90by50cmFuc3Bvc2U9XFxcbnByb3RvLnN0ZXA9ZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiX2NvcHkoKSB7XFxcbnJldHVybiBuZXcgXCIrY2xhc3NOYW1lK1wiKHRoaXMuZGF0YSx0aGlzLm9mZnNldClcXFxufTtcXFxucHJvdG8ucGljaz1mdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfcGljaygpe1xcXG5yZXR1cm4gVHJpdmlhbEFycmF5KHRoaXMuZGF0YSk7XFxcbn07XFxcbnByb3RvLnZhbHVlT2Y9cHJvdG8uZ2V0PWZ1bmN0aW9uIFwiK2NsYXNzTmFtZStcIl9nZXQoKXtcXFxucmV0dXJuIFwiKyh1c2VHZXR0ZXJzID8gXCJ0aGlzLmRhdGEuZ2V0KHRoaXMub2Zmc2V0KVwiIDogXCJ0aGlzLmRhdGFbdGhpcy5vZmZzZXRdXCIpK1xuXCJ9O1xcXG5wcm90by5zZXQ9ZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiX3NldCh2KXtcXFxucmV0dXJuIFwiKyh1c2VHZXR0ZXJzID8gXCJ0aGlzLmRhdGEuc2V0KHRoaXMub2Zmc2V0LHYpXCIgOiBcInRoaXMuZGF0YVt0aGlzLm9mZnNldF09dlwiKStcIlxcXG59O1xcXG5yZXR1cm4gZnVuY3Rpb24gY29uc3RydWN0X1wiK2NsYXNzTmFtZStcIihhLGIsYyxkKXtyZXR1cm4gbmV3IFwiK2NsYXNzTmFtZStcIihhLGQpfVwiXG4gICAgdmFyIHByb2NlZHVyZSA9IG5ldyBGdW5jdGlvbihcIlRyaXZpYWxBcnJheVwiLCBjb2RlKVxuICAgIHJldHVybiBwcm9jZWR1cmUoQ0FDSEVEX0NPTlNUUlVDVE9SU1tkdHlwZV1bMF0pXG4gIH1cblxuICB2YXIgY29kZSA9IFtcIid1c2Ugc3RyaWN0J1wiXVxuICAgIFxuICAvL0NyZWF0ZSBjb25zdHJ1Y3RvciBmb3Igdmlld1xuICB2YXIgaW5kaWNlcyA9IGlvdGEoZGltZW5zaW9uKVxuICB2YXIgYXJncyA9IGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHsgcmV0dXJuIFwiaVwiK2kgfSlcbiAgdmFyIGluZGV4X3N0ciA9IFwidGhpcy5vZmZzZXQrXCIgKyBpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7XG4gICAgICAgIHJldHVybiBcInRoaXMuc3RyaWRlW1wiICsgaSArIFwiXSppXCIgKyBpXG4gICAgICB9KS5qb2luKFwiK1wiKVxuICB2YXIgc2hhcGVBcmcgPSBpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gXCJiXCIraVxuICAgIH0pLmpvaW4oXCIsXCIpXG4gIHZhciBzdHJpZGVBcmcgPSBpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gXCJjXCIraVxuICAgIH0pLmpvaW4oXCIsXCIpXG4gIGNvZGUucHVzaChcbiAgICBcImZ1bmN0aW9uIFwiK2NsYXNzTmFtZStcIihhLFwiICsgc2hhcGVBcmcgKyBcIixcIiArIHN0cmlkZUFyZyArIFwiLGQpe3RoaXMuZGF0YT1hXCIsXG4gICAgICBcInRoaXMuc2hhcGU9W1wiICsgc2hhcGVBcmcgKyBcIl1cIixcbiAgICAgIFwidGhpcy5zdHJpZGU9W1wiICsgc3RyaWRlQXJnICsgXCJdXCIsXG4gICAgICBcInRoaXMub2Zmc2V0PWR8MH1cIixcbiAgICBcInZhciBwcm90bz1cIitjbGFzc05hbWUrXCIucHJvdG90eXBlXCIsXG4gICAgXCJwcm90by5kdHlwZT0nXCIrZHR5cGUrXCInXCIsXG4gICAgXCJwcm90by5kaW1lbnNpb249XCIrZGltZW5zaW9uKVxuICBcbiAgLy92aWV3LnNpemU6XG4gIGNvZGUucHVzaChcIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90bywnc2l6ZScse2dldDpmdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfc2l6ZSgpe1xcXG5yZXR1cm4gXCIraW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkgeyByZXR1cm4gXCJ0aGlzLnNoYXBlW1wiK2krXCJdXCIgfSkuam9pbihcIipcIiksXG5cIn19KVwiKVxuXG4gIC8vdmlldy5vcmRlcjpcbiAgaWYoZGltZW5zaW9uID09PSAxKSB7XG4gICAgY29kZS5wdXNoKFwicHJvdG8ub3JkZXI9WzBdXCIpXG4gIH0gZWxzZSB7XG4gICAgY29kZS5wdXNoKFwiT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvLCdvcmRlcicse2dldDpcIilcbiAgICBpZihkaW1lbnNpb24gPCA0KSB7XG4gICAgICBjb2RlLnB1c2goXCJmdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfb3JkZXIoKXtcIilcbiAgICAgIGlmKGRpbWVuc2lvbiA9PT0gMikge1xuICAgICAgICBjb2RlLnB1c2goXCJyZXR1cm4gKE1hdGguYWJzKHRoaXMuc3RyaWRlWzBdKT5NYXRoLmFicyh0aGlzLnN0cmlkZVsxXSkpP1sxLDBdOlswLDFdfX0pXCIpXG4gICAgICB9IGVsc2UgaWYoZGltZW5zaW9uID09PSAzKSB7XG4gICAgICAgIGNvZGUucHVzaChcblwidmFyIHMwPU1hdGguYWJzKHRoaXMuc3RyaWRlWzBdKSxzMT1NYXRoLmFicyh0aGlzLnN0cmlkZVsxXSksczI9TWF0aC5hYnModGhpcy5zdHJpZGVbMl0pO1xcXG5pZihzMD5zMSl7XFxcbmlmKHMxPnMyKXtcXFxucmV0dXJuIFsyLDEsMF07XFxcbn1lbHNlIGlmKHMwPnMyKXtcXFxucmV0dXJuIFsxLDIsMF07XFxcbn1lbHNle1xcXG5yZXR1cm4gWzEsMCwyXTtcXFxufVxcXG59ZWxzZSBpZihzMD5zMil7XFxcbnJldHVybiBbMiwwLDFdO1xcXG59ZWxzZSBpZihzMj5zMSl7XFxcbnJldHVybiBbMCwxLDJdO1xcXG59ZWxzZXtcXFxucmV0dXJuIFswLDIsMV07XFxcbn19fSlcIilcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29kZS5wdXNoKFwiT1JERVJ9KVwiKVxuICAgIH1cbiAgfVxuICBcbiAgLy92aWV3LnNldChpMCwgLi4uLCB2KTpcbiAgY29kZS5wdXNoKFxuXCJwcm90by5zZXQ9ZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiX3NldChcIithcmdzLmpvaW4oXCIsXCIpK1wiLHYpe1wiKVxuICBpZih1c2VHZXR0ZXJzKSB7XG4gICAgY29kZS5wdXNoKFwicmV0dXJuIHRoaXMuZGF0YS5zZXQoXCIraW5kZXhfc3RyK1wiLHYpfVwiKVxuICB9IGVsc2Uge1xuICAgIGNvZGUucHVzaChcInJldHVybiB0aGlzLmRhdGFbXCIraW5kZXhfc3RyK1wiXT12fVwiKVxuICB9XG4gIFxuICAvL3ZpZXcuZ2V0KGkwLCAuLi4pOlxuICBjb2RlLnB1c2goXCJwcm90by5nZXQ9ZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiX2dldChcIithcmdzLmpvaW4oXCIsXCIpK1wiKXtcIilcbiAgaWYodXNlR2V0dGVycykge1xuICAgIGNvZGUucHVzaChcInJldHVybiB0aGlzLmRhdGEuZ2V0KFwiK2luZGV4X3N0citcIil9XCIpXG4gIH0gZWxzZSB7XG4gICAgY29kZS5wdXNoKFwicmV0dXJuIHRoaXMuZGF0YVtcIitpbmRleF9zdHIrXCJdfVwiKVxuICB9XG4gIFxuICAvL3ZpZXcuaW5kZXg6XG4gIGNvZGUucHVzaChcbiAgICBcInByb3RvLmluZGV4PWZ1bmN0aW9uIFwiK2NsYXNzTmFtZStcIl9pbmRleChcIiwgYXJncy5qb2luKCksIFwiKXtyZXR1cm4gXCIraW5kZXhfc3RyK1wifVwiKVxuXG4gIC8vdmlldy5oaSgpOlxuICBjb2RlLnB1c2goXCJwcm90by5oaT1mdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfaGkoXCIrYXJncy5qb2luKFwiLFwiKStcIil7cmV0dXJuIG5ldyBcIitjbGFzc05hbWUrXCIodGhpcy5kYXRhLFwiK1xuICAgIGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBbXCIodHlwZW9mIGlcIixpLFwiIT09J251bWJlcid8fGlcIixpLFwiPDApP3RoaXMuc2hhcGVbXCIsIGksIFwiXTppXCIsIGksXCJ8MFwiXS5qb2luKFwiXCIpXG4gICAgfSkuam9pbihcIixcIikrXCIsXCIrXG4gICAgaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIFwidGhpcy5zdHJpZGVbXCIraSArIFwiXVwiXG4gICAgfSkuam9pbihcIixcIikrXCIsdGhpcy5vZmZzZXQpfVwiKVxuICBcbiAgLy92aWV3LmxvKCk6XG4gIHZhciBhX3ZhcnMgPSBpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7IHJldHVybiBcImFcIitpK1wiPXRoaXMuc2hhcGVbXCIraStcIl1cIiB9KVxuICB2YXIgY192YXJzID0gaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkgeyByZXR1cm4gXCJjXCIraStcIj10aGlzLnN0cmlkZVtcIitpK1wiXVwiIH0pXG4gIGNvZGUucHVzaChcInByb3RvLmxvPWZ1bmN0aW9uIFwiK2NsYXNzTmFtZStcIl9sbyhcIithcmdzLmpvaW4oXCIsXCIpK1wiKXt2YXIgYj10aGlzLm9mZnNldCxkPTAsXCIrYV92YXJzLmpvaW4oXCIsXCIpK1wiLFwiK2NfdmFycy5qb2luKFwiLFwiKSlcbiAgZm9yKHZhciBpPTA7IGk8ZGltZW5zaW9uOyArK2kpIHtcbiAgICBjb2RlLnB1c2goXG5cImlmKHR5cGVvZiBpXCIraStcIj09PSdudW1iZXInJiZpXCIraStcIj49MCl7XFxcbmQ9aVwiK2krXCJ8MDtcXFxuYis9Y1wiK2krXCIqZDtcXFxuYVwiK2krXCItPWR9XCIpXG4gIH1cbiAgY29kZS5wdXNoKFwicmV0dXJuIG5ldyBcIitjbGFzc05hbWUrXCIodGhpcy5kYXRhLFwiK1xuICAgIGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBcImFcIitpXG4gICAgfSkuam9pbihcIixcIikrXCIsXCIrXG4gICAgaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIFwiY1wiK2lcbiAgICB9KS5qb2luKFwiLFwiKStcIixiKX1cIilcbiAgXG4gIC8vdmlldy5zdGVwKCk6XG4gIGNvZGUucHVzaChcInByb3RvLnN0ZXA9ZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiX3N0ZXAoXCIrYXJncy5qb2luKFwiLFwiKStcIil7dmFyIFwiK1xuICAgIGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBcImFcIitpK1wiPXRoaXMuc2hhcGVbXCIraStcIl1cIlxuICAgIH0pLmpvaW4oXCIsXCIpK1wiLFwiK1xuICAgIGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBcImJcIitpK1wiPXRoaXMuc3RyaWRlW1wiK2krXCJdXCJcbiAgICB9KS5qb2luKFwiLFwiKStcIixjPXRoaXMub2Zmc2V0LGQ9MCxjZWlsPU1hdGguY2VpbFwiKVxuICBmb3IodmFyIGk9MDsgaTxkaW1lbnNpb247ICsraSkge1xuICAgIGNvZGUucHVzaChcblwiaWYodHlwZW9mIGlcIitpK1wiPT09J251bWJlcicpe1xcXG5kPWlcIitpK1wifDA7XFxcbmlmKGQ8MCl7XFxcbmMrPWJcIitpK1wiKihhXCIraStcIi0xKTtcXFxuYVwiK2krXCI9Y2VpbCgtYVwiK2krXCIvZClcXFxufWVsc2V7XFxcbmFcIitpK1wiPWNlaWwoYVwiK2krXCIvZClcXFxufVxcXG5iXCIraStcIio9ZFxcXG59XCIpXG4gIH1cbiAgY29kZS5wdXNoKFwicmV0dXJuIG5ldyBcIitjbGFzc05hbWUrXCIodGhpcy5kYXRhLFwiK1xuICAgIGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBcImFcIiArIGlcbiAgICB9KS5qb2luKFwiLFwiKStcIixcIitcbiAgICBpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gXCJiXCIgKyBpXG4gICAgfSkuam9pbihcIixcIikrXCIsYyl9XCIpXG4gIFxuICAvL3ZpZXcudHJhbnNwb3NlKCk6XG4gIHZhciB0U2hhcGUgPSBuZXcgQXJyYXkoZGltZW5zaW9uKVxuICB2YXIgdFN0cmlkZSA9IG5ldyBBcnJheShkaW1lbnNpb24pXG4gIGZvcih2YXIgaT0wOyBpPGRpbWVuc2lvbjsgKytpKSB7XG4gICAgdFNoYXBlW2ldID0gXCJhW2lcIitpK1wiXVwiXG4gICAgdFN0cmlkZVtpXSA9IFwiYltpXCIraStcIl1cIlxuICB9XG4gIGNvZGUucHVzaChcInByb3RvLnRyYW5zcG9zZT1mdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfdHJhbnNwb3NlKFwiK2FyZ3MrXCIpe1wiK1xuICAgIGFyZ3MubWFwKGZ1bmN0aW9uKG4saWR4KSB7IHJldHVybiBuICsgXCI9KFwiICsgbiArIFwiPT09dW5kZWZpbmVkP1wiICsgaWR4ICsgXCI6XCIgKyBuICsgXCJ8MClcIn0pLmpvaW4oXCI7XCIpLFxuICAgIFwidmFyIGE9dGhpcy5zaGFwZSxiPXRoaXMuc3RyaWRlO3JldHVybiBuZXcgXCIrY2xhc3NOYW1lK1wiKHRoaXMuZGF0YSxcIit0U2hhcGUuam9pbihcIixcIikrXCIsXCIrdFN0cmlkZS5qb2luKFwiLFwiKStcIix0aGlzLm9mZnNldCl9XCIpXG4gIFxuICAvL3ZpZXcucGljaygpOlxuICBjb2RlLnB1c2goXCJwcm90by5waWNrPWZ1bmN0aW9uIFwiK2NsYXNzTmFtZStcIl9waWNrKFwiK2FyZ3MrXCIpe3ZhciBhPVtdLGI9W10sYz10aGlzLm9mZnNldFwiKVxuICBmb3IodmFyIGk9MDsgaTxkaW1lbnNpb247ICsraSkge1xuICAgIGNvZGUucHVzaChcImlmKHR5cGVvZiBpXCIraStcIj09PSdudW1iZXInJiZpXCIraStcIj49MCl7Yz0oYyt0aGlzLnN0cmlkZVtcIitpK1wiXSppXCIraStcIil8MH1lbHNle2EucHVzaCh0aGlzLnNoYXBlW1wiK2krXCJdKTtiLnB1c2godGhpcy5zdHJpZGVbXCIraStcIl0pfVwiKVxuICB9XG4gIGNvZGUucHVzaChcInZhciBjdG9yPUNUT1JfTElTVFthLmxlbmd0aCsxXTtyZXR1cm4gY3Rvcih0aGlzLmRhdGEsYSxiLGMpfVwiKVxuICAgIFxuICAvL0FkZCByZXR1cm4gc3RhdGVtZW50XG4gIGNvZGUucHVzaChcInJldHVybiBmdW5jdGlvbiBjb25zdHJ1Y3RfXCIrY2xhc3NOYW1lK1wiKGRhdGEsc2hhcGUsc3RyaWRlLG9mZnNldCl7cmV0dXJuIG5ldyBcIitjbGFzc05hbWUrXCIoZGF0YSxcIitcbiAgICBpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gXCJzaGFwZVtcIitpK1wiXVwiXG4gICAgfSkuam9pbihcIixcIikrXCIsXCIrXG4gICAgaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIFwic3RyaWRlW1wiK2krXCJdXCJcbiAgICB9KS5qb2luKFwiLFwiKStcIixvZmZzZXQpfVwiKVxuXG4gIC8vQ29tcGlsZSBwcm9jZWR1cmVcbiAgdmFyIHByb2NlZHVyZSA9IG5ldyBGdW5jdGlvbihcIkNUT1JfTElTVFwiLCBcIk9SREVSXCIsIGNvZGUuam9pbihcIlxcblwiKSlcbiAgcmV0dXJuIHByb2NlZHVyZShDQUNIRURfQ09OU1RSVUNUT1JTW2R0eXBlXSwgb3JkZXIpXG59XG5cbmZ1bmN0aW9uIGFycmF5RFR5cGUoZGF0YSkge1xuICBpZihoYXNCdWZmZXIpIHtcbiAgICBpZihCdWZmZXIuaXNCdWZmZXIoZGF0YSkpIHtcbiAgICAgIHJldHVybiBcImJ1ZmZlclwiXG4gICAgfVxuICB9XG4gIGlmKGhhc1R5cGVkQXJyYXlzKSB7XG4gICAgc3dpdGNoKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChkYXRhKSkge1xuICAgICAgY2FzZSBcIltvYmplY3QgRmxvYXQ2NEFycmF5XVwiOlxuICAgICAgICByZXR1cm4gXCJmbG9hdDY0XCJcbiAgICAgIGNhc2UgXCJbb2JqZWN0IEZsb2F0MzJBcnJheV1cIjpcbiAgICAgICAgcmV0dXJuIFwiZmxvYXQzMlwiXG4gICAgICBjYXNlIFwiW29iamVjdCBJbnQ4QXJyYXldXCI6XG4gICAgICAgIHJldHVybiBcImludDhcIlxuICAgICAgY2FzZSBcIltvYmplY3QgSW50MTZBcnJheV1cIjpcbiAgICAgICAgcmV0dXJuIFwiaW50MTZcIlxuICAgICAgY2FzZSBcIltvYmplY3QgSW50MzJBcnJheV1cIjpcbiAgICAgICAgcmV0dXJuIFwiaW50MzJcIlxuICAgICAgY2FzZSBcIltvYmplY3QgVWludDhBcnJheV1cIjpcbiAgICAgICAgcmV0dXJuIFwidWludDhcIlxuICAgICAgY2FzZSBcIltvYmplY3QgVWludDE2QXJyYXldXCI6XG4gICAgICAgIHJldHVybiBcInVpbnQxNlwiXG4gICAgICBjYXNlIFwiW29iamVjdCBVaW50MzJBcnJheV1cIjpcbiAgICAgICAgcmV0dXJuIFwidWludDMyXCJcbiAgICAgIGNhc2UgXCJbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XVwiOlxuICAgICAgICByZXR1cm4gXCJ1aW50OF9jbGFtcGVkXCJcbiAgICB9XG4gIH1cbiAgaWYoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgIHJldHVybiBcImFycmF5XCJcbiAgfVxuICByZXR1cm4gXCJnZW5lcmljXCJcbn1cblxudmFyIENBQ0hFRF9DT05TVFJVQ1RPUlMgPSB7XG4gIFwiZmxvYXQzMlwiOltdLFxuICBcImZsb2F0NjRcIjpbXSxcbiAgXCJpbnQ4XCI6W10sXG4gIFwiaW50MTZcIjpbXSxcbiAgXCJpbnQzMlwiOltdLFxuICBcInVpbnQ4XCI6W10sXG4gIFwidWludDE2XCI6W10sXG4gIFwidWludDMyXCI6W10sXG4gIFwiYXJyYXlcIjpbXSxcbiAgXCJ1aW50OF9jbGFtcGVkXCI6W10sXG4gIFwiYnVmZmVyXCI6W10sXG4gIFwiZ2VuZXJpY1wiOltdXG59XG5cbjsoZnVuY3Rpb24oKSB7XG4gIGZvcih2YXIgaWQgaW4gQ0FDSEVEX0NPTlNUUlVDVE9SUykge1xuICAgIENBQ0hFRF9DT05TVFJVQ1RPUlNbaWRdLnB1c2goY29tcGlsZUNvbnN0cnVjdG9yKGlkLCAtMSkpXG4gIH1cbn0pO1xuXG5mdW5jdGlvbiB3cmFwcGVkTkRBcnJheUN0b3IoZGF0YSwgc2hhcGUsIHN0cmlkZSwgb2Zmc2V0KSB7XG4gIGlmKGRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBjdG9yID0gQ0FDSEVEX0NPTlNUUlVDVE9SUy5hcnJheVswXVxuICAgIHJldHVybiBjdG9yKFtdKVxuICB9IGVsc2UgaWYodHlwZW9mIGRhdGEgPT09IFwibnVtYmVyXCIpIHtcbiAgICBkYXRhID0gW2RhdGFdXG4gIH1cbiAgaWYoc2hhcGUgPT09IHVuZGVmaW5lZCkge1xuICAgIHNoYXBlID0gWyBkYXRhLmxlbmd0aCBdXG4gIH1cbiAgdmFyIGQgPSBzaGFwZS5sZW5ndGhcbiAgaWYoc3RyaWRlID09PSB1bmRlZmluZWQpIHtcbiAgICBzdHJpZGUgPSBuZXcgQXJyYXkoZClcbiAgICBmb3IodmFyIGk9ZC0xLCBzej0xOyBpPj0wOyAtLWkpIHtcbiAgICAgIHN0cmlkZVtpXSA9IHN6XG4gICAgICBzeiAqPSBzaGFwZVtpXVxuICAgIH1cbiAgfVxuICBpZihvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIG9mZnNldCA9IDBcbiAgICBmb3IodmFyIGk9MDsgaTxkOyArK2kpIHtcbiAgICAgIGlmKHN0cmlkZVtpXSA8IDApIHtcbiAgICAgICAgb2Zmc2V0IC09IChzaGFwZVtpXS0xKSpzdHJpZGVbaV1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdmFyIGR0eXBlID0gYXJyYXlEVHlwZShkYXRhKVxuICB2YXIgY3Rvcl9saXN0ID0gQ0FDSEVEX0NPTlNUUlVDVE9SU1tkdHlwZV1cbiAgd2hpbGUoY3Rvcl9saXN0Lmxlbmd0aCA8PSBkKzEpIHtcbiAgICBjdG9yX2xpc3QucHVzaChjb21waWxlQ29uc3RydWN0b3IoZHR5cGUsIGN0b3JfbGlzdC5sZW5ndGgtMSkpXG4gIH1cbiAgdmFyIGN0b3IgPSBjdG9yX2xpc3RbZCsxXVxuICByZXR1cm4gY3RvcihkYXRhLCBzaGFwZSwgc3RyaWRlLCBvZmZzZXQpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gd3JhcHBlZE5EQXJyYXlDdG9yXG59KS5jYWxsKHRoaXMscmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIpIiwibW9kdWxlLmV4cG9ydHM9cmVxdWlyZShcIi9wcm9qZWN0cy9ibGFja2ljZS9ub2RlX21vZHVsZXMvZ2wtc3ByaXRlLXRleHQvbm9kZV9tb2R1bGVzL2dsLXdoaXRlLXRleHR1cmUvbm9kZV9tb2R1bGVzL25kYXJyYXkvbm9kZV9tb2R1bGVzL2lvdGEtYXJyYXkvaW90YS5qc1wiKSIsIm1vZHVsZS5leHBvcnRzPXJlcXVpcmUoXCIvcHJvamVjdHMvYmxhY2tpY2Uvbm9kZV9tb2R1bGVzL2dsLXNwcml0ZS10ZXh0L25vZGVfbW9kdWxlcy9nbC10ZXh0dXJlMmQvbm9kZV9tb2R1bGVzL3R5cGVkYXJyYXktcG9vbC9wb29sLmpzXCIpIiwibW9kdWxlLmV4cG9ydHM9cmVxdWlyZShcIi9wcm9qZWN0cy9ibGFja2ljZS9ub2RlX21vZHVsZXMvZ2wtc3ByaXRlLXRleHQvbm9kZV9tb2R1bGVzL2dsLXRleHR1cmUyZC9ub2RlX21vZHVsZXMvd2ViZ2xldy93ZWJnbGV3LmpzXCIpIiwidmFyIGNyZWF0ZSA9IHJlcXVpcmUoJ2dsLXRleHR1cmUyZCcpXG52YXIgbmRhcnJheSA9IHJlcXVpcmUoJ25kYXJyYXknKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGdsKSB7XG4gICAgLy9maWxsIGFuIGFycmF5IHdpdGggMHhmZlxuICAgIHZhciBkYXRhID0gQXJyYXkuYXBwbHkobnVsbCwgbmV3IEFycmF5KDE2KSlcbiAgICAgICAgICAgIC5tYXAoTnVtYmVyLnByb3RvdHlwZS52YWx1ZU9mLCAweEZGKTtcbiAgICAvL2NyZWF0ZSBhIDJEIG5kYXJyYXlcbiAgICB2YXIgYXJyYXkgPSBuZGFycmF5KG5ldyBVaW50OEFycmF5KGRhdGEpLCBbMiwgMiwgNF0pXG4gICAgcmV0dXJuIGNyZWF0ZShnbCwgYXJyYXkpXG59IiwibW9kdWxlLmV4cG9ydHM9cmVxdWlyZShcIi9wcm9qZWN0cy9ibGFja2ljZS9ub2RlX21vZHVsZXMvdGhyZWUtc2RmLXRleHQvbm9kZV9tb2R1bGVzL2dsLXNwcml0ZS10ZXh0L25vZGVfbW9kdWxlcy9nbC1zcHJpdGUtYmF0Y2gvbm9kZV9tb2R1bGVzL2dsLWJ1ZmZlci9ub2RlX21vZHVsZXMvbmRhcnJheS9uZGFycmF5LmpzXCIpIiwibW9kdWxlLmV4cG9ydHM9cmVxdWlyZShcIi9wcm9qZWN0cy9ibGFja2ljZS9ub2RlX21vZHVsZXMvbWl4ZXMvaW5kZXguanNcIikiLCJ2YXIgaW50OCA9IG5ldyBJbnQ4QXJyYXkoNCk7XG52YXIgaW50MzIgPSBuZXcgSW50MzJBcnJheShpbnQ4LmJ1ZmZlciwgMCwgMSk7XG52YXIgZmxvYXQzMiA9IG5ldyBGbG9hdDMyQXJyYXkoaW50OC5idWZmZXIsIDAsIDEpO1xuXG4vKipcbiAqIEEgc2luZ2xldG9uIGZvciBudW1iZXIgdXRpbGl0aWVzLiBcbiAqIEBjbGFzcyBOdW1iZXJVdGlsXG4gKi9cbnZhciBOdW1iZXJVdGlsID0gZnVuY3Rpb24oKSB7XG5cbn07XG5cblxuLyoqXG4gKiBSZXR1cm5zIGEgZmxvYXQgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIGludCBiaXRzLiBBcnJheUJ1ZmZlclxuICogaXMgdXNlZCBmb3IgdGhlIGNvbnZlcnNpb24uXG4gKlxuICogQG1ldGhvZCAgaW50Qml0c1RvRmxvYXRcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSAge051bWJlcn0gaSB0aGUgaW50IHRvIGNhc3RcbiAqIEByZXR1cm4ge051bWJlcn0gICB0aGUgZmxvYXRcbiAqL1xuTnVtYmVyVXRpbC5pbnRCaXRzVG9GbG9hdCA9IGZ1bmN0aW9uKGkpIHtcblx0aW50MzJbMF0gPSBpO1xuXHRyZXR1cm4gZmxvYXQzMlswXTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgaW50IGJpdHMgZnJvbSB0aGUgZ2l2ZW4gZmxvYXQuIEFycmF5QnVmZmVyIGlzIHVzZWRcbiAqIGZvciB0aGUgY29udmVyc2lvbi5cbiAqXG4gKiBAbWV0aG9kICBmbG9hdFRvSW50Qml0c1xuICogQHN0YXRpY1xuICogQHBhcmFtICB7TnVtYmVyfSBmIHRoZSBmbG9hdCB0byBjYXN0XG4gKiBAcmV0dXJuIHtOdW1iZXJ9ICAgdGhlIGludCBiaXRzXG4gKi9cbk51bWJlclV0aWwuZmxvYXRUb0ludEJpdHMgPSBmdW5jdGlvbihmKSB7XG5cdGZsb2F0MzJbMF0gPSBmO1xuXHRyZXR1cm4gaW50MzJbMF07XG59O1xuXG4vKipcbiAqIEVuY29kZXMgQUJHUiBpbnQgYXMgYSBmbG9hdCwgd2l0aCBzbGlnaHQgcHJlY2lzaW9uIGxvc3MuXG4gKlxuICogQG1ldGhvZCAgaW50VG9GbG9hdENvbG9yXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgYW4gQUJHUiBwYWNrZWQgaW50ZWdlclxuICovXG5OdW1iZXJVdGlsLmludFRvRmxvYXRDb2xvciA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdHJldHVybiBOdW1iZXJVdGlsLmludEJpdHNUb0Zsb2F0KCB2YWx1ZSAmIDB4ZmVmZmZmZmYgKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIGZsb2F0IGVuY29kZWQgQUJHUiB2YWx1ZSBmcm9tIHRoZSBnaXZlbiBSR0JBXG4gKiBieXRlcyAoMCAtIDI1NSkuIFVzZWZ1bCBmb3Igc2F2aW5nIGJhbmR3aWR0aCBpbiB2ZXJ0ZXggZGF0YS5cbiAqXG4gKiBAbWV0aG9kICBjb2xvclRvRmxvYXRcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSB7TnVtYmVyfSByIHRoZSBSZWQgYnl0ZSAoMCAtIDI1NSlcbiAqIEBwYXJhbSB7TnVtYmVyfSBnIHRoZSBHcmVlbiBieXRlICgwIC0gMjU1KVxuICogQHBhcmFtIHtOdW1iZXJ9IGIgdGhlIEJsdWUgYnl0ZSAoMCAtIDI1NSlcbiAqIEBwYXJhbSB7TnVtYmVyfSBhIHRoZSBBbHBoYSBieXRlICgwIC0gMjU1KVxuICogQHJldHVybiB7RmxvYXQzMn0gIGEgRmxvYXQzMiBvZiB0aGUgUkdCQSBjb2xvclxuICovXG5OdW1iZXJVdGlsLmNvbG9yVG9GbG9hdCA9IGZ1bmN0aW9uKHIsIGcsIGIsIGEpIHtcblx0dmFyIGJpdHMgPSAoYSA8PCAyNCB8IGIgPDwgMTYgfCBnIDw8IDggfCByKTtcblx0cmV0dXJuIE51bWJlclV0aWwuaW50VG9GbG9hdENvbG9yKGJpdHMpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIG51bWJlciBpcyBhIHBvd2VyLW9mLXR3by5cbiAqXG4gKiBAbWV0aG9kICBpc1Bvd2VyT2ZUd29cbiAqIEBwYXJhbSAge051bWJlcn0gIG4gdGhlIG51bWJlciB0byB0ZXN0XG4gKiBAcmV0dXJuIHtCb29sZWFufSAgIHRydWUgaWYgcG93ZXItb2YtdHdvXG4gKi9cbk51bWJlclV0aWwuaXNQb3dlck9mVHdvID0gZnVuY3Rpb24obikge1xuXHRyZXR1cm4gKG4gJiAobiAtIDEpKSA9PT0gMDtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbmV4dCBoaWdoZXN0IHBvd2VyLW9mLXR3byBmcm9tIHRoZSBzcGVjaWZpZWQgbnVtYmVyLiBcbiAqIFxuICogQHBhcmFtICB7TnVtYmVyfSBuIHRoZSBudW1iZXIgdG8gdGVzdFxuICogQHJldHVybiB7TnVtYmVyfSAgIHRoZSBuZXh0IGhpZ2hlc3QgcG93ZXIgb2YgdHdvXG4gKi9cbk51bWJlclV0aWwubmV4dFBvd2VyT2ZUd28gPSBmdW5jdGlvbihuKSB7XG5cdG4tLTtcblx0biB8PSBuID4+IDE7XG5cdG4gfD0gbiA+PiAyO1xuXHRuIHw9IG4gPj4gNDtcblx0biB8PSBuID4+IDg7XG5cdG4gfD0gbiA+PiAxNjtcblx0cmV0dXJuIG4rMTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTnVtYmVyVXRpbDsiLCJmdW5jdGlvbiBwcmVtdWx0aXBseShyZ2JhLCBvdXQpIHtcblx0aWYgKCFvdXQgfHwgdHlwZW9mIG91dCA9PT0gJ251bWJlcicpXG5cdFx0b3V0ID0gWzAsMCwwLDBdXG5cdG91dFswXSA9IHJnYmFbMF0gKiByZ2JhWzNdXG5cdG91dFsxXSA9IHJnYmFbMV0gKiByZ2JhWzNdXG5cdG91dFsyXSA9IHJnYmFbMl0gKiByZ2JhWzNdXG5cdG91dFszXSA9IHJnYmFbM11cblx0cmV0dXJuIG91dFxufVxubW9kdWxlLmV4cG9ydHMgPSBwcmVtdWx0aXBseSIsInZhciBwYWNrQ29sb3IgPSByZXF1aXJlKCdudW1iZXItdXRpbCcpLmNvbG9yVG9GbG9hdFxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNvbG9yVG9GbG9hdChyZ2JhKSB7XG4gICAgcmV0dXJuIHBhY2tDb2xvcihcbiAgICAgICAgfn4ocmdiYVswXSAqIDI1NSksXG4gICAgICAgIH5+KHJnYmFbMV0gKiAyNTUpLFxuICAgICAgICB+fihyZ2JhWzJdICogMjU1KSxcbiAgICAgICAgfn4ocmdiYVszXSAqIDI1NSlcbiAgICApXG59IiwibW9kdWxlLmV4cG9ydHM9cmVxdWlyZShcIi9wcm9qZWN0cy9ibGFja2ljZS9ub2RlX21vZHVsZXMvaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qc1wiKSIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdGV4Y29vcmQocG9zaXRpb24sIHNoYXBlLCB0ZXhTaGFwZSwgb3V0KSB7XG4gICAgaWYgKCFvdXQpXG4gICAgICAgIG91dCA9IFswLCAwLCAxLCAxXVxuXG4gICAgcG9zaXRpb24gPSBwb3NpdGlvbiB8fCBbMCwgMF1cbiAgICBzaGFwZSA9IHNoYXBlIHx8IFsxLCAxXVxuXG4gICAgdGV4U2hhcGUgPSB0ZXhTaGFwZSB8fCBzaGFwZVxuXG4gICAgdmFyIGludldpZHRoID0gMSAvIHRleFNoYXBlWzBdXG4gICAgdmFyIGludkhlaWdodCA9IDEgLyB0ZXhTaGFwZVsxXVxuICAgIHZhciB4ID0gcG9zaXRpb25bMF0sXG4gICAgICAgIHkgPSBwb3NpdGlvblsxXSxcbiAgICAgICAgdyA9IHNoYXBlWzBdLFxuICAgICAgICBoID0gc2hhcGVbMV1cblxuICAgIG91dFswXSA9IHggKiBpbnZXaWR0aFxuICAgIG91dFsxXSA9IHkgKiBpbnZIZWlnaHRcbiAgICBvdXRbMl0gPSAoeCArIHcpICogaW52V2lkdGhcbiAgICBvdXRbM10gPSAoeSArIGgpICogaW52SGVpZ2h0XG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzPXJlcXVpcmUoXCIvcHJvamVjdHMvYmxhY2tpY2Uvbm9kZV9tb2R1bGVzL2dsLXRleHR1cmUyZC90ZXh0dXJlLmpzXCIpIiwibW9kdWxlLmV4cG9ydHM9cmVxdWlyZShcIi9wcm9qZWN0cy9ibGFja2ljZS9ub2RlX21vZHVsZXMvZ2wtc3ByaXRlLXRleHQvbm9kZV9tb2R1bGVzL3h0ZW5kL2ltbXV0YWJsZS5qc1wiKSIsInZhciBnbHNsaWZ5ID0gcmVxdWlyZShcImdsc2xpZnlcIik7XG52YXIgdGhyZWVpZnkgPSByZXF1aXJlKFwidGhyZWUtZ2xzbGlmeVwiKTtcbnZhciBzb3VyY2UgPSByZXF1aXJlKFwiZ2xzbGlmeS9zaW1wbGUtYWRhcHRlci5qc1wiKShcIlxcbiNkZWZpbmUgR0xTTElGWSAxXFxuXFxudmFyeWluZyB2ZWMyIHZVdjtcXG52YXJ5aW5nIHZlYzIgdl9yZ2JOVztcXG52YXJ5aW5nIHZlYzIgdl9yZ2JORTtcXG52YXJ5aW5nIHZlYzIgdl9yZ2JTVztcXG52YXJ5aW5nIHZlYzIgdl9yZ2JTRTtcXG52YXJ5aW5nIHZlYzIgdl9yZ2JNO1xcbnVuaWZvcm0gdmVjMiByZXNvbHV0aW9uO1xcbnZvaWQgYV94X3RleGNvb3Jkcyh2ZWMyIGZyYWdDb29yZCwgdmVjMiByZXNvbHV0aW9uLCBvdXQgdmVjMiB2X3JnYk5XLCBvdXQgdmVjMiB2X3JnYk5FLCBvdXQgdmVjMiB2X3JnYlNXLCBvdXQgdmVjMiB2X3JnYlNFLCBvdXQgdmVjMiB2X3JnYk0pIHtcXG4gIHZlYzIgaW52ZXJzZVZQID0gMS4wIC8gcmVzb2x1dGlvbi54eTtcXG4gIHZfcmdiTlcgPSAoZnJhZ0Nvb3JkICsgdmVjMigtMS4wLCAtMS4wKSkgKiBpbnZlcnNlVlA7XFxuICB2X3JnYk5FID0gKGZyYWdDb29yZCArIHZlYzIoMS4wLCAtMS4wKSkgKiBpbnZlcnNlVlA7XFxuICB2X3JnYlNXID0gKGZyYWdDb29yZCArIHZlYzIoLTEuMCwgMS4wKSkgKiBpbnZlcnNlVlA7XFxuICB2X3JnYlNFID0gKGZyYWdDb29yZCArIHZlYzIoMS4wLCAxLjApKSAqIGludmVyc2VWUDtcXG4gIHZfcmdiTSA9IHZlYzIoZnJhZ0Nvb3JkICogaW52ZXJzZVZQKTtcXG59XFxudm9pZCBtYWluKCkge1xcbiAgdlV2ID0gdXY7XFxuICB2ZWMyIGZyYWdDb29yZCA9IHV2ICogcmVzb2x1dGlvbjtcXG4gIGFfeF90ZXhjb29yZHMoZnJhZ0Nvb3JkLCByZXNvbHV0aW9uLCB2X3JnYk5XLCB2X3JnYk5FLCB2X3JnYlNXLCB2X3JnYlNFLCB2X3JnYk0pO1xcbiAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNChwb3NpdGlvbiwgMS4wKTtcXG59XCIsIFwiXFxuI2RlZmluZSBHTFNMSUZZIDFcXG5cXG52YXJ5aW5nIHZlYzIgdlV2O1xcbnZhcnlpbmcgdmVjMiB2X3JnYk5XO1xcbnZhcnlpbmcgdmVjMiB2X3JnYk5FO1xcbnZhcnlpbmcgdmVjMiB2X3JnYlNXO1xcbnZhcnlpbmcgdmVjMiB2X3JnYlNFO1xcbnZhcnlpbmcgdmVjMiB2X3JnYk07XFxudW5pZm9ybSB2ZWMyIHJlc29sdXRpb247XFxudW5pZm9ybSBzYW1wbGVyMkQgdERpZmZ1c2U7XFxuI2lmbmRlZiBGWEFBX1JFRFVDRV9NSU5cXG5cXG4jZGVmaW5lIEZYQUFfUkVEVUNFX01JTiAgICgxLjAvIDEyOC4wKVxcblxcbiNlbmRpZlxcblxcbiNpZm5kZWYgRlhBQV9SRURVQ0VfTVVMXFxuXFxuI2RlZmluZSBGWEFBX1JFRFVDRV9NVUwgICAoMS4wIC8gOC4wKVxcblxcbiNlbmRpZlxcblxcbiNpZm5kZWYgRlhBQV9TUEFOX01BWFxcblxcbiNkZWZpbmUgRlhBQV9TUEFOX01BWCAgICAgOC4wXFxuXFxuI2VuZGlmXFxuXFxudmVjNCBhX3hfZnhhYShzYW1wbGVyMkQgdGV4LCB2ZWMyIGZyYWdDb29yZCwgdmVjMiByZXNvbHV0aW9uLCB2ZWMyIHZfcmdiTlcsIHZlYzIgdl9yZ2JORSwgdmVjMiB2X3JnYlNXLCB2ZWMyIHZfcmdiU0UsIHZlYzIgdl9yZ2JNKSB7XFxuICB2ZWM0IGNvbG9yO1xcbiAgbWVkaXVtcCB2ZWMyIGludmVyc2VWUCA9IHZlYzIoMS4wIC8gcmVzb2x1dGlvbi54LCAxLjAgLyByZXNvbHV0aW9uLnkpO1xcbiAgdmVjMyByZ2JOVyA9IHRleHR1cmUyRCh0ZXgsIHZfcmdiTlcpLnh5ejtcXG4gIHZlYzMgcmdiTkUgPSB0ZXh0dXJlMkQodGV4LCB2X3JnYk5FKS54eXo7XFxuICB2ZWMzIHJnYlNXID0gdGV4dHVyZTJEKHRleCwgdl9yZ2JTVykueHl6O1xcbiAgdmVjMyByZ2JTRSA9IHRleHR1cmUyRCh0ZXgsIHZfcmdiU0UpLnh5ejtcXG4gIHZlYzQgdGV4Q29sb3IgPSB0ZXh0dXJlMkQodGV4LCB2X3JnYk0pO1xcbiAgdmVjMyByZ2JNID0gdGV4Q29sb3IueHl6O1xcbiAgdmVjMyBsdW1hID0gdmVjMygwLjI5OSwgMC41ODcsIDAuMTE0KTtcXG4gIGZsb2F0IGx1bWFOVyA9IGRvdChyZ2JOVywgbHVtYSk7XFxuICBmbG9hdCBsdW1hTkUgPSBkb3QocmdiTkUsIGx1bWEpO1xcbiAgZmxvYXQgbHVtYVNXID0gZG90KHJnYlNXLCBsdW1hKTtcXG4gIGZsb2F0IGx1bWFTRSA9IGRvdChyZ2JTRSwgbHVtYSk7XFxuICBmbG9hdCBsdW1hTSA9IGRvdChyZ2JNLCBsdW1hKTtcXG4gIGZsb2F0IGx1bWFNaW4gPSBtaW4obHVtYU0sIG1pbihtaW4obHVtYU5XLCBsdW1hTkUpLCBtaW4obHVtYVNXLCBsdW1hU0UpKSk7XFxuICBmbG9hdCBsdW1hTWF4ID0gbWF4KGx1bWFNLCBtYXgobWF4KGx1bWFOVywgbHVtYU5FKSwgbWF4KGx1bWFTVywgbHVtYVNFKSkpO1xcbiAgbWVkaXVtcCB2ZWMyIGRpcjtcXG4gIGRpci54ID0gLSgobHVtYU5XICsgbHVtYU5FKSAtIChsdW1hU1cgKyBsdW1hU0UpKTtcXG4gIGRpci55ID0gKChsdW1hTlcgKyBsdW1hU1cpIC0gKGx1bWFORSArIGx1bWFTRSkpO1xcbiAgZmxvYXQgZGlyUmVkdWNlID0gbWF4KChsdW1hTlcgKyBsdW1hTkUgKyBsdW1hU1cgKyBsdW1hU0UpICogKDAuMjUgKiBGWEFBX1JFRFVDRV9NVUwpLCBGWEFBX1JFRFVDRV9NSU4pO1xcbiAgZmxvYXQgcmNwRGlyTWluID0gMS4wIC8gKG1pbihhYnMoZGlyLngpLCBhYnMoZGlyLnkpKSArIGRpclJlZHVjZSk7XFxuICBkaXIgPSBtaW4odmVjMihGWEFBX1NQQU5fTUFYLCBGWEFBX1NQQU5fTUFYKSwgbWF4KHZlYzIoLUZYQUFfU1BBTl9NQVgsIC1GWEFBX1NQQU5fTUFYKSwgZGlyICogcmNwRGlyTWluKSkgKiBpbnZlcnNlVlA7XFxuICB2ZWMzIHJnYkEgPSAwLjUgKiAodGV4dHVyZTJEKHRleCwgZnJhZ0Nvb3JkICogaW52ZXJzZVZQICsgZGlyICogKDEuMCAvIDMuMCAtIDAuNSkpLnh5eiArIHRleHR1cmUyRCh0ZXgsIGZyYWdDb29yZCAqIGludmVyc2VWUCArIGRpciAqICgyLjAgLyAzLjAgLSAwLjUpKS54eXopO1xcbiAgdmVjMyByZ2JCID0gcmdiQSAqIDAuNSArIDAuMjUgKiAodGV4dHVyZTJEKHRleCwgZnJhZ0Nvb3JkICogaW52ZXJzZVZQICsgZGlyICogLTAuNSkueHl6ICsgdGV4dHVyZTJEKHRleCwgZnJhZ0Nvb3JkICogaW52ZXJzZVZQICsgZGlyICogMC41KS54eXopO1xcbiAgZmxvYXQgbHVtYUIgPSBkb3QocmdiQiwgbHVtYSk7XFxuICBpZigobHVtYUIgPCBsdW1hTWluKSB8fCAobHVtYUIgPiBsdW1hTWF4KSlcXG4gICAgY29sb3IgPSB2ZWM0KHJnYkEsIHRleENvbG9yLmEpO1xcbiAgZWxzZVxcbiAgICBjb2xvciA9IHZlYzQocmdiQiwgdGV4Q29sb3IuYSk7XFxuICByZXR1cm4gY29sb3I7XFxufVxcbnZvaWQgbWFpbigpIHtcXG4gIHZlYzIgZnJhZ0Nvb3JkID0gdlV2ICogcmVzb2x1dGlvbjtcXG4gIGdsX0ZyYWdDb2xvciA9IGFfeF9meGFhKHREaWZmdXNlLCBmcmFnQ29vcmQsIHJlc29sdXRpb24sIHZfcmdiTlcsIHZfcmdiTkUsIHZfcmdiU1csIHZfcmdiU0UsIHZfcmdiTSk7XFxufVwiLCBbe1wibmFtZVwiOlwicmVzb2x1dGlvblwiLFwidHlwZVwiOlwidmVjMlwifSx7XCJuYW1lXCI6XCJyZXNvbHV0aW9uXCIsXCJ0eXBlXCI6XCJ2ZWMyXCJ9LHtcIm5hbWVcIjpcInREaWZmdXNlXCIsXCJ0eXBlXCI6XCJzYW1wbGVyMkRcIn1dLCBbXSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oVEhSRUUpIHtcbiAgICB2YXIgY3JlYXRlU2hhZGVyID0gdGhyZWVpZnkoVEhSRUUpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlU2hhZGVyKHNvdXJjZSk7XG4gICAgfTtcbn07IiwidmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFRIUkVFKSB7XG5cbiAgICBmdW5jdGlvbiBDb21wbGV4KG1lc2gpIHtcbiAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIENvbXBsZXgpKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb21wbGV4KG1lc2gpXG4gICAgICAgIFRIUkVFLkdlb21ldHJ5LmNhbGwodGhpcylcbiAgICAgICAgdGhpcy5keW5hbWljID0gdHJ1ZVxuXG4gICAgICAgIGlmIChtZXNoKVxuICAgICAgICAgICAgdGhpcy51cGRhdGUobWVzaClcbiAgICB9XG5cbiAgICBpbmhlcml0cyhDb21wbGV4LCBUSFJFRS5HZW9tZXRyeSlcblxuICAgIC8vbWF5IGV4cG9zZSB0aGVzZSBpbiBuZXh0IHZlcnNpb25cbiAgICBDb21wbGV4LnByb3RvdHlwZS5fdXBkYXRlUG9zaXRpb25zID0gZnVuY3Rpb24ocG9zaXRpb25zKSB7XG4gICAgICAgIGZvciAodmFyIGk9MDsgaTxwb3NpdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBwb3MgPSBwb3NpdGlvbnNbaV1cbiAgICAgICAgICAgIGlmIChpID4gdGhpcy52ZXJ0aWNlcy5sZW5ndGgtMSlcbiAgICAgICAgICAgICAgICB0aGlzLnZlcnRpY2VzLnB1c2gobmV3IFRIUkVFLlZlY3RvcjMoKS5mcm9tQXJyYXkocG9zKSlcbiAgICAgICAgICAgIGVsc2UgXG4gICAgICAgICAgICAgICAgdGhpcy52ZXJ0aWNlc1tpXS5mcm9tQXJyYXkocG9zKVxuICAgICAgICB9XG4gICAgICAgIHRoaXMudmVydGljZXMubGVuZ3RoID0gcG9zaXRpb25zLmxlbmd0aFxuICAgICAgICB0aGlzLnZlcnRpY2VzTmVlZFVwZGF0ZSA9IHRydWVcbiAgICB9XG5cbiAgICBDb21wbGV4LnByb3RvdHlwZS5fdXBkYXRlQ2VsbHMgPSBmdW5jdGlvbihjZWxscykge1xuICAgICAgICBmb3IgKHZhciBpPTA7IGk8Y2VsbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBmYWNlID0gY2VsbHNbaV1cbiAgICAgICAgICAgIGlmIChpID4gdGhpcy5mYWNlcy5sZW5ndGgtMSlcbiAgICAgICAgICAgICAgICB0aGlzLmZhY2VzLnB1c2gobmV3IFRIUkVFLkZhY2UzKGZhY2VbMF0sIGZhY2VbMV0sIGZhY2VbMl0pKVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHRmID0gdGhpcy5mYWNlc1tpXVxuICAgICAgICAgICAgICAgIHRmLmEgPSBmYWNlWzBdXG4gICAgICAgICAgICAgICAgdGYuYiA9IGZhY2VbMV1cbiAgICAgICAgICAgICAgICB0Zi5jID0gZmFjZVsyXVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5mYWNlcy5sZW5ndGggPSBjZWxscy5sZW5ndGhcbiAgICAgICAgdGhpcy5lbGVtZW50c05lZWRVcGRhdGUgPSB0cnVlXG4gICAgfVxuXG4gICAgQ29tcGxleC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24obWVzaCkge1xuICAgICAgICB0aGlzLl91cGRhdGVQb3NpdGlvbnMobWVzaC5wb3NpdGlvbnMpXG4gICAgICAgIHRoaXMuX3VwZGF0ZUNlbGxzKG1lc2guY2VsbHMpXG4gICAgfVxuXG4gICAgcmV0dXJuIENvbXBsZXhcbn0iLCJ2YXIgVGVzczIgPSByZXF1aXJlKCd0ZXNzMicpXG52YXIgeHRlbmQgPSByZXF1aXJlKCd4dGVuZCcpXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oY29udG91cnMsIG9wdCkge1xuICAgIG9wdCA9IG9wdHx8e31cbiAgICBjb250b3VycyA9IGNvbnRvdXJzLmZpbHRlcihmdW5jdGlvbihjKSB7XG4gICAgICAgIHJldHVybiBjLmxlbmd0aD4wXG4gICAgfSlcbiAgICBcbiAgICBpZiAoY29udG91cnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiB7IFxuICAgICAgICAgICAgcG9zaXRpb25zOiBbXSxcbiAgICAgICAgICAgIGNlbGxzOiBbXVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvcHQudmVydGV4U2l6ZSAhPT0gJ251bWJlcicpXG4gICAgICAgIG9wdC52ZXJ0ZXhTaXplID0gY29udG91cnNbMF1bMF0ubGVuZ3RoXG5cbiAgICAvL2ZsYXR0ZW4gZm9yIHRlc3MyLmpzXG4gICAgY29udG91cnMgPSBjb250b3Vycy5tYXAoZnVuY3Rpb24oYykge1xuICAgICAgICByZXR1cm4gYy5yZWR1Y2UoZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGEuY29uY2F0KGIpXG4gICAgICAgIH0pXG4gICAgfSlcblxuICAgIC8vIFRlc3NlbGF0ZVxuICAgIHZhciByZXMgPSBUZXNzMi50ZXNzZWxhdGUoeHRlbmQoe1xuICAgICAgICBjb250b3VyczogY29udG91cnMsXG4gICAgICAgIHdpbmRpbmdSdWxlOiBUZXNzMi5XSU5ESU5HX09ERCxcbiAgICAgICAgZWxlbWVudFR5cGU6IFRlc3MyLlBPTFlHT05TLFxuICAgICAgICBwb2x5U2l6ZTogMyxcbiAgICAgICAgdmVydGV4U2l6ZTogMlxuICAgIH0sIG9wdCkpXG5cbiAgICB2YXIgcG9zaXRpb25zID0gW11cbiAgICBmb3IgKHZhciBpPTA7IGk8cmVzLnZlcnRpY2VzLmxlbmd0aDsgaSs9b3B0LnZlcnRleFNpemUpIHtcbiAgICAgICAgdmFyIHBvcyA9IHJlcy52ZXJ0aWNlcy5zbGljZShpLCBpK29wdC52ZXJ0ZXhTaXplKVxuICAgICAgICBwb3NpdGlvbnMucHVzaChwb3MpXG4gICAgfVxuICAgIFxuICAgIHZhciBjZWxscyA9IFtdXG4gICAgZm9yIChpPTA7IGk8cmVzLmVsZW1lbnRzLmxlbmd0aDsgaSs9Mykge1xuICAgICAgICB2YXIgYSA9IHJlcy5lbGVtZW50c1tpXSxcbiAgICAgICAgICAgIGIgPSByZXMuZWxlbWVudHNbaSsxXSxcbiAgICAgICAgICAgIGMgPSByZXMuZWxlbWVudHNbaSsyXVxuICAgICAgICBjZWxscy5wdXNoKFthLCBiLCBjXSlcbiAgICB9XG5cbiAgICAvL3JldHVybiBhIHNpbXBsaWNpYWwgY29tcGxleFxuICAgIHJldHVybiB7XG4gICAgICAgIHBvc2l0aW9uczogcG9zaXRpb25zLFxuICAgICAgICBjZWxsczogY2VsbHNcbiAgICB9XG59IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3NyYy90ZXNzMicpOyIsIi8qXG4qKiBTR0kgRlJFRSBTT0ZUV0FSRSBMSUNFTlNFIEIgKFZlcnNpb24gMi4wLCBTZXB0LiAxOCwgMjAwOCkgXG4qKiBDb3B5cmlnaHQgKEMpIFtkYXRlcyBvZiBmaXJzdCBwdWJsaWNhdGlvbl0gU2lsaWNvbiBHcmFwaGljcywgSW5jLlxuKiogQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbioqXG4qKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4qKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4qKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4qKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllc1xuKiogb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuKiogc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4qKiBcbioqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGluY2x1ZGluZyB0aGUgZGF0ZXMgb2YgZmlyc3QgcHVibGljYXRpb24gYW5kIGVpdGhlciB0aGlzXG4qKiBwZXJtaXNzaW9uIG5vdGljZSBvciBhIHJlZmVyZW5jZSB0byBodHRwOi8vb3NzLnNnaS5jb20vcHJvamVjdHMvRnJlZUIvIHNoYWxsIGJlXG4qKiBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS4gXG4qKlxuKiogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUiBJTVBMSUVELFxuKiogSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEFcbioqIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBTSUxJQ09OIEdSQVBISUNTLCBJTkMuXG4qKiBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULFxuKiogVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRVxuKiogT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuKiogXG4qKiBFeGNlcHQgYXMgY29udGFpbmVkIGluIHRoaXMgbm90aWNlLCB0aGUgbmFtZSBvZiBTaWxpY29uIEdyYXBoaWNzLCBJbmMuIHNoYWxsIG5vdFxuKiogYmUgdXNlZCBpbiBhZHZlcnRpc2luZyBvciBvdGhlcndpc2UgdG8gcHJvbW90ZSB0aGUgc2FsZSwgdXNlIG9yIG90aGVyIGRlYWxpbmdzIGluXG4qKiB0aGlzIFNvZnR3YXJlIHdpdGhvdXQgcHJpb3Igd3JpdHRlbiBhdXRob3JpemF0aW9uIGZyb20gU2lsaWNvbiBHcmFwaGljcywgSW5jLlxuKi9cbi8qXG4qKiBBdXRob3I6IE1pa2tvIE1vbm9uZW4sIEF1ZyAyMDEzLlxuKiogVGhlIGNvZGUgaXMgYmFzZWQgb24gR0xVIGxpYnRlc3MgYnkgRXJpYyBWZWFjaCwgSnVseSAxOTk0XG4qL1xuXG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdC8qIFB1YmxpYyBBUEkgKi9cblxuXHR2YXIgVGVzczIgPSB7fTtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IFRlc3MyO1xuXHRcblx0VGVzczIuV0lORElOR19PREQgPSAwO1xuXHRUZXNzMi5XSU5ESU5HX05PTlpFUk8gPSAxO1xuXHRUZXNzMi5XSU5ESU5HX1BPU0lUSVZFID0gMjtcblx0VGVzczIuV0lORElOR19ORUdBVElWRSA9IDM7XG5cdFRlc3MyLldJTkRJTkdfQUJTX0dFUV9UV08gPSA0O1xuXG5cdFRlc3MyLlBPTFlHT05TID0gMDtcblx0VGVzczIuQ09OTkVDVEVEX1BPTFlHT05TID0gMTtcblx0VGVzczIuQk9VTkRBUllfQ09OVE9VUlMgPSAyO1xuXG5cdFRlc3MyLnRlc3NlbGF0ZSA9IGZ1bmN0aW9uKG9wdHMpIHtcblx0XHR2YXIgZGVidWcgPSAgb3B0cy5kZWJ1ZyB8fCBmYWxzZTtcblx0XHR2YXIgdGVzcyA9IG5ldyBUZXNzZWxhdG9yKCk7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBvcHRzLmNvbnRvdXJzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR0ZXNzLmFkZENvbnRvdXIob3B0cy52ZXJ0ZXhTaXplIHx8IDIsIG9wdHMuY29udG91cnNbaV0pO1xuXHRcdH1cblx0XHR0ZXNzLnRlc3NlbGF0ZShvcHRzLndpbmRpbmdSdWxlIHx8IFRlc3MyLldJTkRJTkdfT0RELFxuXHRcdFx0XHRcdCAgIG9wdHMuZWxlbWVudFR5cGUgfHwgVGVzczIuUE9MWUdPTlMsXG5cdFx0XHRcdFx0ICAgb3B0cy5wb2x5U2l6ZSB8fCAzLFxuXHRcdFx0XHRcdCAgIG9wdHMudmVydGV4U2l6ZSB8fCAyLFxuXHRcdFx0XHRcdCAgIG9wdHMubm9ybWFsIHx8IFswLDAsMV0pO1xuXHRcdHJldHVybiB7XG5cdFx0XHR2ZXJ0aWNlczogdGVzcy52ZXJ0aWNlcyxcblx0XHRcdHZlcnRleEluZGljZXM6IHRlc3MudmVydGV4SW5kaWNlcyxcblx0XHRcdHZlcnRleENvdW50OiB0ZXNzLnZlcnRleENvdW50LFxuXHRcdFx0ZWxlbWVudHM6IHRlc3MuZWxlbWVudHMsXG5cdFx0XHRlbGVtZW50Q291bnQ6IHRlc3MuZWxlbWVudENvdW50LFxuXHRcdFx0bWVzaDogZGVidWcgPyB0ZXNzLm1lc2ggOiB1bmRlZmluZWRcblx0XHR9O1xuXHR9O1xuXG5cdC8qIEludGVybmFsICovXG5cblx0dmFyIGFzc2VydCA9IGZ1bmN0aW9uKGNvbmQpIHtcblx0XHRpZiAoIWNvbmQpIHtcblx0XHRcdHRocm93IFwiQXNzZXJ0aW9uIEZhaWxlZCFcIjtcblx0XHR9XG5cdH1cblxuXHQvKiBUaGUgbWVzaCBzdHJ1Y3R1cmUgaXMgc2ltaWxhciBpbiBzcGlyaXQsIG5vdGF0aW9uLCBhbmQgb3BlcmF0aW9uc1xuXHQqIHRvIHRoZSBcInF1YWQtZWRnZVwiIHN0cnVjdHVyZSAoc2VlIEwuIEd1aWJhcyBhbmQgSi4gU3RvbGZpLCBQcmltaXRpdmVzXG5cdCogZm9yIHRoZSBtYW5pcHVsYXRpb24gb2YgZ2VuZXJhbCBzdWJkaXZpc2lvbnMgYW5kIHRoZSBjb21wdXRhdGlvbiBvZlxuXHQqIFZvcm9ub2kgZGlhZ3JhbXMsIEFDTSBUcmFuc2FjdGlvbnMgb24gR3JhcGhpY3MsIDQoMik6NzQtMTIzLCBBcHJpbCAxOTg1KS5cblx0KiBGb3IgYSBzaW1wbGlmaWVkIGRlc2NyaXB0aW9uLCBzZWUgdGhlIGNvdXJzZSBub3RlcyBmb3IgQ1MzNDhhLFxuXHQqIFwiTWF0aGVtYXRpY2FsIEZvdW5kYXRpb25zIG9mIENvbXB1dGVyIEdyYXBoaWNzXCIsIGF2YWlsYWJsZSBhdCB0aGVcblx0KiBTdGFuZm9yZCBib29rc3RvcmUgKGFuZCB0YXVnaHQgZHVyaW5nIHRoZSBmYWxsIHF1YXJ0ZXIpLlxuXHQqIFRoZSBpbXBsZW1lbnRhdGlvbiBhbHNvIGJvcnJvd3MgYSB0aW55IHN1YnNldCBvZiB0aGUgZ3JhcGgtYmFzZWQgYXBwcm9hY2hcblx0KiB1c2UgaW4gTWFudHlsYSdzIEdlb21ldHJpYyBXb3JrIEJlbmNoIChzZWUgTS4gTWFudHlsYSwgQW4gSW50cm9kdWN0aW9uXG5cdCogdG8gU29sZCBNb2RlbGluZywgQ29tcHV0ZXIgU2NpZW5jZSBQcmVzcywgUm9ja3ZpbGxlLCBNYXJ5bGFuZCwgMTk4OCkuXG5cdCpcblx0KiBUaGUgZnVuZGFtZW50YWwgZGF0YSBzdHJ1Y3R1cmUgaXMgdGhlIFwiaGFsZi1lZGdlXCIuICBUd28gaGFsZi1lZGdlc1xuXHQqIGdvIHRvZ2V0aGVyIHRvIG1ha2UgYW4gZWRnZSwgYnV0IHRoZXkgcG9pbnQgaW4gb3Bwb3NpdGUgZGlyZWN0aW9ucy5cblx0KiBFYWNoIGhhbGYtZWRnZSBoYXMgYSBwb2ludGVyIHRvIGl0cyBtYXRlICh0aGUgXCJzeW1tZXRyaWNcIiBoYWxmLWVkZ2UgU3ltKSxcblx0KiBpdHMgb3JpZ2luIHZlcnRleCAoT3JnKSwgdGhlIGZhY2Ugb24gaXRzIGxlZnQgc2lkZSAoTGZhY2UpLCBhbmQgdGhlXG5cdCogYWRqYWNlbnQgaGFsZi1lZGdlcyBpbiB0aGUgQ0NXIGRpcmVjdGlvbiBhcm91bmQgdGhlIG9yaWdpbiB2ZXJ0ZXhcblx0KiAoT25leHQpIGFuZCBhcm91bmQgdGhlIGxlZnQgZmFjZSAoTG5leHQpLiAgVGhlcmUgaXMgYWxzbyBhIFwibmV4dFwiXG5cdCogcG9pbnRlciBmb3IgdGhlIGdsb2JhbCBlZGdlIGxpc3QgKHNlZSBiZWxvdykuXG5cdCpcblx0KiBUaGUgbm90YXRpb24gdXNlZCBmb3IgbWVzaCBuYXZpZ2F0aW9uOlxuXHQqICBTeW0gICA9IHRoZSBtYXRlIG9mIGEgaGFsZi1lZGdlIChzYW1lIGVkZ2UsIGJ1dCBvcHBvc2l0ZSBkaXJlY3Rpb24pXG5cdCogIE9uZXh0ID0gZWRnZSBDQ1cgYXJvdW5kIG9yaWdpbiB2ZXJ0ZXggKGtlZXAgc2FtZSBvcmlnaW4pXG5cdCogIERuZXh0ID0gZWRnZSBDQ1cgYXJvdW5kIGRlc3RpbmF0aW9uIHZlcnRleCAoa2VlcCBzYW1lIGRlc3QpXG5cdCogIExuZXh0ID0gZWRnZSBDQ1cgYXJvdW5kIGxlZnQgZmFjZSAoZGVzdCBiZWNvbWVzIG5ldyBvcmlnaW4pXG5cdCogIFJuZXh0ID0gZWRnZSBDQ1cgYXJvdW5kIHJpZ2h0IGZhY2UgKG9yaWdpbiBiZWNvbWVzIG5ldyBkZXN0KVxuXHQqXG5cdCogXCJwcmV2XCIgbWVhbnMgdG8gc3Vic3RpdHV0ZSBDVyBmb3IgQ0NXIGluIHRoZSBkZWZpbml0aW9ucyBhYm92ZS5cblx0KlxuXHQqIFRoZSBtZXNoIGtlZXBzIGdsb2JhbCBsaXN0cyBvZiBhbGwgdmVydGljZXMsIGZhY2VzLCBhbmQgZWRnZXMsXG5cdCogc3RvcmVkIGFzIGRvdWJseS1saW5rZWQgY2lyY3VsYXIgbGlzdHMgd2l0aCBhIGR1bW15IGhlYWRlciBub2RlLlxuXHQqIFRoZSBtZXNoIHN0b3JlcyBwb2ludGVycyB0byB0aGVzZSBkdW1teSBoZWFkZXJzICh2SGVhZCwgZkhlYWQsIGVIZWFkKS5cblx0KlxuXHQqIFRoZSBjaXJjdWxhciBlZGdlIGxpc3QgaXMgc3BlY2lhbDsgc2luY2UgaGFsZi1lZGdlcyBhbHdheXMgb2NjdXJcblx0KiBpbiBwYWlycyAoZSBhbmQgZS0+U3ltKSwgZWFjaCBoYWxmLWVkZ2Ugc3RvcmVzIGEgcG9pbnRlciBpbiBvbmx5XG5cdCogb25lIGRpcmVjdGlvbi4gIFN0YXJ0aW5nIGF0IGVIZWFkIGFuZCBmb2xsb3dpbmcgdGhlIGUtPm5leHQgcG9pbnRlcnNcblx0KiB3aWxsIHZpc2l0IGVhY2ggKmVkZ2UqIG9uY2UgKGllLiBlIG9yIGUtPlN5bSwgYnV0IG5vdCBib3RoKS5cblx0KiBlLT5TeW0gc3RvcmVzIGEgcG9pbnRlciBpbiB0aGUgb3Bwb3NpdGUgZGlyZWN0aW9uLCB0aHVzIGl0IGlzXG5cdCogYWx3YXlzIHRydWUgdGhhdCBlLT5TeW0tPm5leHQtPlN5bS0+bmV4dCA9PSBlLlxuXHQqXG5cdCogRWFjaCB2ZXJ0ZXggaGFzIGEgcG9pbnRlciB0byBuZXh0IGFuZCBwcmV2aW91cyB2ZXJ0aWNlcyBpbiB0aGVcblx0KiBjaXJjdWxhciBsaXN0LCBhbmQgYSBwb2ludGVyIHRvIGEgaGFsZi1lZGdlIHdpdGggdGhpcyB2ZXJ0ZXggYXNcblx0KiB0aGUgb3JpZ2luIChOVUxMIGlmIHRoaXMgaXMgdGhlIGR1bW15IGhlYWRlcikuICBUaGVyZSBpcyBhbHNvIGFcblx0KiBmaWVsZCBcImRhdGFcIiBmb3IgY2xpZW50IGRhdGEuXG5cdCpcblx0KiBFYWNoIGZhY2UgaGFzIGEgcG9pbnRlciB0byB0aGUgbmV4dCBhbmQgcHJldmlvdXMgZmFjZXMgaW4gdGhlXG5cdCogY2lyY3VsYXIgbGlzdCwgYW5kIGEgcG9pbnRlciB0byBhIGhhbGYtZWRnZSB3aXRoIHRoaXMgZmFjZSBhc1xuXHQqIHRoZSBsZWZ0IGZhY2UgKE5VTEwgaWYgdGhpcyBpcyB0aGUgZHVtbXkgaGVhZGVyKS4gIFRoZXJlIGlzIGFsc29cblx0KiBhIGZpZWxkIFwiZGF0YVwiIGZvciBjbGllbnQgZGF0YS5cblx0KlxuXHQqIE5vdGUgdGhhdCB3aGF0IHdlIGNhbGwgYSBcImZhY2VcIiBpcyByZWFsbHkgYSBsb29wOyBmYWNlcyBtYXkgY29uc2lzdFxuXHQqIG9mIG1vcmUgdGhhbiBvbmUgbG9vcCAoaWUuIG5vdCBzaW1wbHkgY29ubmVjdGVkKSwgYnV0IHRoZXJlIGlzIG5vXG5cdCogcmVjb3JkIG9mIHRoaXMgaW4gdGhlIGRhdGEgc3RydWN0dXJlLiAgVGhlIG1lc2ggbWF5IGNvbnNpc3Qgb2Zcblx0KiBzZXZlcmFsIGRpc2Nvbm5lY3RlZCByZWdpb25zLCBzbyBpdCBtYXkgbm90IGJlIHBvc3NpYmxlIHRvIHZpc2l0XG5cdCogdGhlIGVudGlyZSBtZXNoIGJ5IHN0YXJ0aW5nIGF0IGEgaGFsZi1lZGdlIGFuZCB0cmF2ZXJzaW5nIHRoZSBlZGdlXG5cdCogc3RydWN0dXJlLlxuXHQqXG5cdCogVGhlIG1lc2ggZG9lcyBOT1Qgc3VwcG9ydCBpc29sYXRlZCB2ZXJ0aWNlczsgYSB2ZXJ0ZXggaXMgZGVsZXRlZCBhbG9uZ1xuXHQqIHdpdGggaXRzIGxhc3QgZWRnZS4gIFNpbWlsYXJseSB3aGVuIHR3byBmYWNlcyBhcmUgbWVyZ2VkLCBvbmUgb2YgdGhlXG5cdCogZmFjZXMgaXMgZGVsZXRlZCAoc2VlIHRlc3NNZXNoRGVsZXRlIGJlbG93KS4gIEZvciBtZXNoIG9wZXJhdGlvbnMsXG5cdCogYWxsIGZhY2UgKGxvb3ApIGFuZCB2ZXJ0ZXggcG9pbnRlcnMgbXVzdCBub3QgYmUgTlVMTC4gIEhvd2V2ZXIsIG9uY2Vcblx0KiBtZXNoIG1hbmlwdWxhdGlvbiBpcyBmaW5pc2hlZCwgVEVTU21lc2haYXBGYWNlIGNhbiBiZSB1c2VkIHRvIGRlbGV0ZVxuXHQqIGZhY2VzIG9mIHRoZSBtZXNoLCBvbmUgYXQgYSB0aW1lLiAgQWxsIGV4dGVybmFsIGZhY2VzIGNhbiBiZSBcInphcHBlZFwiXG5cdCogYmVmb3JlIHRoZSBtZXNoIGlzIHJldHVybmVkIHRvIHRoZSBjbGllbnQ7IHRoZW4gYSBOVUxMIGZhY2UgaW5kaWNhdGVzXG5cdCogYSByZWdpb24gd2hpY2ggaXMgbm90IHBhcnQgb2YgdGhlIG91dHB1dCBwb2x5Z29uLlxuXHQqL1xuXG5cdGZ1bmN0aW9uIFRFU1N2ZXJ0ZXgoKSB7XG5cdFx0dGhpcy5uZXh0ID0gbnVsbDtcdC8qIG5leHQgdmVydGV4IChuZXZlciBOVUxMKSAqL1xuXHRcdHRoaXMucHJldiA9IG51bGw7XHQvKiBwcmV2aW91cyB2ZXJ0ZXggKG5ldmVyIE5VTEwpICovXG5cdFx0dGhpcy5hbkVkZ2UgPSBudWxsO1x0LyogYSBoYWxmLWVkZ2Ugd2l0aCB0aGlzIG9yaWdpbiAqL1xuXG5cdFx0LyogSW50ZXJuYWwgZGF0YSAoa2VlcCBoaWRkZW4pICovXG5cdFx0dGhpcy5jb29yZHMgPSBbMCwwLDBdO1x0LyogdmVydGV4IGxvY2F0aW9uIGluIDNEICovXG5cdFx0dGhpcy5zID0gMC4wO1xuXHRcdHRoaXMudCA9IDAuMDtcdFx0XHQvKiBwcm9qZWN0aW9uIG9udG8gdGhlIHN3ZWVwIHBsYW5lICovXG5cdFx0dGhpcy5wcUhhbmRsZSA9IDA7XHRcdC8qIHRvIGFsbG93IGRlbGV0aW9uIGZyb20gcHJpb3JpdHkgcXVldWUgKi9cblx0XHR0aGlzLm4gPSAwO1x0XHRcdFx0LyogdG8gYWxsb3cgaWRlbnRpZnkgdW5pcXVlIHZlcnRpY2VzICovXG5cdFx0dGhpcy5pZHggPSAwO1x0XHRcdC8qIHRvIGFsbG93IG1hcCByZXN1bHQgdG8gb3JpZ2luYWwgdmVydHMgKi9cblx0fSBcblxuXHRmdW5jdGlvbiBURVNTZmFjZSgpIHtcblx0XHR0aGlzLm5leHQgPSBudWxsO1x0XHQvKiBuZXh0IGZhY2UgKG5ldmVyIE5VTEwpICovXG5cdFx0dGhpcy5wcmV2ID0gbnVsbDtcdFx0LyogcHJldmlvdXMgZmFjZSAobmV2ZXIgTlVMTCkgKi9cblx0XHR0aGlzLmFuRWRnZSA9IG51bGw7XHRcdC8qIGEgaGFsZiBlZGdlIHdpdGggdGhpcyBsZWZ0IGZhY2UgKi9cblxuXHRcdC8qIEludGVybmFsIGRhdGEgKGtlZXAgaGlkZGVuKSAqL1xuXHRcdHRoaXMudHJhaWwgPSBudWxsO1x0XHQvKiBcInN0YWNrXCIgZm9yIGNvbnZlcnNpb24gdG8gc3RyaXBzICovXG5cdFx0dGhpcy5uID0gMDtcdFx0XHRcdC8qIHRvIGFsbG93IGlkZW50aXkgdW5pcXVlIGZhY2VzICovXG5cdFx0dGhpcy5tYXJrZWQgPSBmYWxzZTtcdC8qIGZsYWcgZm9yIGNvbnZlcnNpb24gdG8gc3RyaXBzICovXG5cdFx0dGhpcy5pbnNpZGUgPSBmYWxzZTtcdC8qIHRoaXMgZmFjZSBpcyBpbiB0aGUgcG9seWdvbiBpbnRlcmlvciAqL1xuXHR9O1xuXG5cdGZ1bmN0aW9uIFRFU1NoYWxmRWRnZShzaWRlKSB7XG5cdFx0dGhpcy5uZXh0ID0gbnVsbDtcdFx0LyogZG91Ymx5LWxpbmtlZCBsaXN0IChwcmV2PT1TeW0tPm5leHQpICovXG5cdFx0dGhpcy5TeW0gPSBudWxsO1x0XHQvKiBzYW1lIGVkZ2UsIG9wcG9zaXRlIGRpcmVjdGlvbiAqL1xuXHRcdHRoaXMuT25leHQgPSBudWxsO1x0XHQvKiBuZXh0IGVkZ2UgQ0NXIGFyb3VuZCBvcmlnaW4gKi9cblx0XHR0aGlzLkxuZXh0ID0gbnVsbDtcdFx0LyogbmV4dCBlZGdlIENDVyBhcm91bmQgbGVmdCBmYWNlICovXG5cdFx0dGhpcy5PcmcgPSBudWxsO1x0XHQvKiBvcmlnaW4gdmVydGV4IChPdmVydGV4IHRvbyBsb25nKSAqL1xuXHRcdHRoaXMuTGZhY2UgPSBudWxsO1x0XHQvKiBsZWZ0IGZhY2UgKi9cblxuXHRcdC8qIEludGVybmFsIGRhdGEgKGtlZXAgaGlkZGVuKSAqL1xuXHRcdHRoaXMuYWN0aXZlUmVnaW9uID0gbnVsbDtcdC8qIGEgcmVnaW9uIHdpdGggdGhpcyB1cHBlciBlZGdlIChzd2VlcC5jKSAqL1xuXHRcdHRoaXMud2luZGluZyA9IDA7XHRcdFx0LyogY2hhbmdlIGluIHdpbmRpbmcgbnVtYmVyIHdoZW4gY3Jvc3Npbmdcblx0XHRcdFx0XHRcdFx0XHRcdCAgIGZyb20gdGhlIHJpZ2h0IGZhY2UgdG8gdGhlIGxlZnQgZmFjZSAqL1xuXHRcdHRoaXMuc2lkZSA9IHNpZGU7XG5cdH07XG5cblx0VEVTU2hhbGZFZGdlLnByb3RvdHlwZSA9IHtcblx0XHRnZXQgUmZhY2UoKSB7IHJldHVybiB0aGlzLlN5bS5MZmFjZTsgfSxcblx0XHRzZXQgUmZhY2UodikgeyB0aGlzLlN5bS5MZmFjZSA9IHY7IH0sXG5cdFx0Z2V0IERzdCgpIHsgcmV0dXJuIHRoaXMuU3ltLk9yZzsgfSxcblx0XHRzZXQgRHN0KHYpIHsgdGhpcy5TeW0uT3JnID0gdjsgfSxcblx0XHRnZXQgT3ByZXYoKSB7IHJldHVybiB0aGlzLlN5bS5MbmV4dDsgfSxcblx0XHRzZXQgT3ByZXYodikgeyB0aGlzLlN5bS5MbmV4dCA9IHY7IH0sXG5cdFx0Z2V0IExwcmV2KCkgeyByZXR1cm4gdGhpcy5PbmV4dC5TeW07IH0sXG5cdFx0c2V0IExwcmV2KHYpIHsgdGhpcy5PbmV4dC5TeW0gPSB2OyB9LFxuXHRcdGdldCBEcHJldigpIHsgcmV0dXJuIHRoaXMuTG5leHQuU3ltOyB9LFxuXHRcdHNldCBEcHJldih2KSB7IHRoaXMuTG5leHQuU3ltID0gdjsgfSxcblx0XHRnZXQgUnByZXYoKSB7IHJldHVybiB0aGlzLlN5bS5PbmV4dDsgfSxcblx0XHRzZXQgUnByZXYodikgeyB0aGlzLlN5bS5PbmV4dCA9IHY7IH0sXG5cdFx0Z2V0IERuZXh0KCkgeyByZXR1cm4gLyp0aGlzLlJwcmV2Ki90aGlzLlN5bS5PbmV4dC5TeW07IH0sICAvKiAzIHBvaW50ZXJzICovXG5cdFx0c2V0IERuZXh0KHYpIHsgLyp0aGlzLlJwcmV2Ki90aGlzLlN5bS5PbmV4dC5TeW0gPSB2OyB9LCAgLyogMyBwb2ludGVycyAqL1xuXHRcdGdldCBSbmV4dCgpIHsgcmV0dXJuIC8qdGhpcy5PcHJldiovdGhpcy5TeW0uTG5leHQuU3ltOyB9LCAgLyogMyBwb2ludGVycyAqL1xuXHRcdHNldCBSbmV4dCh2KSB7IC8qdGhpcy5PcHJldiovdGhpcy5TeW0uTG5leHQuU3ltID0gdjsgfSwgIC8qIDMgcG9pbnRlcnMgKi9cblx0fTtcblxuXG5cblx0ZnVuY3Rpb24gVEVTU21lc2goKSB7XG5cdFx0dmFyIHYgPSBuZXcgVEVTU3ZlcnRleCgpO1xuXHRcdHZhciBmID0gbmV3IFRFU1NmYWNlKCk7XG5cdFx0dmFyIGUgPSBuZXcgVEVTU2hhbGZFZGdlKDApO1xuXHRcdHZhciBlU3ltID0gbmV3IFRFU1NoYWxmRWRnZSgxKTtcblxuXHRcdHYubmV4dCA9IHYucHJldiA9IHY7XG5cdFx0di5hbkVkZ2UgPSBudWxsO1xuXG5cdFx0Zi5uZXh0ID0gZi5wcmV2ID0gZjtcblx0XHRmLmFuRWRnZSA9IG51bGw7XG5cdFx0Zi50cmFpbCA9IG51bGw7XG5cdFx0Zi5tYXJrZWQgPSBmYWxzZTtcblx0XHRmLmluc2lkZSA9IGZhbHNlO1xuXG5cdFx0ZS5uZXh0ID0gZTtcblx0XHRlLlN5bSA9IGVTeW07XG5cdFx0ZS5PbmV4dCA9IG51bGw7XG5cdFx0ZS5MbmV4dCA9IG51bGw7XG5cdFx0ZS5PcmcgPSBudWxsO1xuXHRcdGUuTGZhY2UgPSBudWxsO1xuXHRcdGUud2luZGluZyA9IDA7XG5cdFx0ZS5hY3RpdmVSZWdpb24gPSBudWxsO1xuXG5cdFx0ZVN5bS5uZXh0ID0gZVN5bTtcblx0XHRlU3ltLlN5bSA9IGU7XG5cdFx0ZVN5bS5PbmV4dCA9IG51bGw7XG5cdFx0ZVN5bS5MbmV4dCA9IG51bGw7XG5cdFx0ZVN5bS5PcmcgPSBudWxsO1xuXHRcdGVTeW0uTGZhY2UgPSBudWxsO1xuXHRcdGVTeW0ud2luZGluZyA9IDA7XG5cdFx0ZVN5bS5hY3RpdmVSZWdpb24gPSBudWxsO1xuXG5cdFx0dGhpcy52SGVhZCA9IHY7XHRcdC8qIGR1bW15IGhlYWRlciBmb3IgdmVydGV4IGxpc3QgKi9cblx0XHR0aGlzLmZIZWFkID0gZjtcdFx0LyogZHVtbXkgaGVhZGVyIGZvciBmYWNlIGxpc3QgKi9cblx0XHR0aGlzLmVIZWFkID0gZTtcdFx0LyogZHVtbXkgaGVhZGVyIGZvciBlZGdlIGxpc3QgKi9cblx0XHR0aGlzLmVIZWFkU3ltID0gZVN5bTtcdC8qIGFuZCBpdHMgc3ltbWV0cmljIGNvdW50ZXJwYXJ0ICovXG5cdH07XG5cblx0LyogVGhlIG1lc2ggb3BlcmF0aW9ucyBiZWxvdyBoYXZlIHRocmVlIG1vdGl2YXRpb25zOiBjb21wbGV0ZW5lc3MsXG5cdCogY29udmVuaWVuY2UsIGFuZCBlZmZpY2llbmN5LiAgVGhlIGJhc2ljIG1lc2ggb3BlcmF0aW9ucyBhcmUgTWFrZUVkZ2UsXG5cdCogU3BsaWNlLCBhbmQgRGVsZXRlLiAgQWxsIHRoZSBvdGhlciBlZGdlIG9wZXJhdGlvbnMgY2FuIGJlIGltcGxlbWVudGVkXG5cdCogaW4gdGVybXMgb2YgdGhlc2UuICBUaGUgb3RoZXIgb3BlcmF0aW9ucyBhcmUgcHJvdmlkZWQgZm9yIGNvbnZlbmllbmNlXG5cdCogYW5kL29yIGVmZmljaWVuY3kuXG5cdCpcblx0KiBXaGVuIGEgZmFjZSBpcyBzcGxpdCBvciBhIHZlcnRleCBpcyBhZGRlZCwgdGhleSBhcmUgaW5zZXJ0ZWQgaW50byB0aGVcblx0KiBnbG9iYWwgbGlzdCAqYmVmb3JlKiB0aGUgZXhpc3RpbmcgdmVydGV4IG9yIGZhY2UgKGllLiBlLT5Pcmcgb3IgZS0+TGZhY2UpLlxuXHQqIFRoaXMgbWFrZXMgaXQgZWFzaWVyIHRvIHByb2Nlc3MgYWxsIHZlcnRpY2VzIG9yIGZhY2VzIGluIHRoZSBnbG9iYWwgbGlzdHNcblx0KiB3aXRob3V0IHdvcnJ5aW5nIGFib3V0IHByb2Nlc3NpbmcgdGhlIHNhbWUgZGF0YSB0d2ljZS4gIEFzIGEgY29udmVuaWVuY2UsXG5cdCogd2hlbiBhIGZhY2UgaXMgc3BsaXQsIHRoZSBcImluc2lkZVwiIGZsYWcgaXMgY29waWVkIGZyb20gdGhlIG9sZCBmYWNlLlxuXHQqIE90aGVyIGludGVybmFsIGRhdGEgKHYtPmRhdGEsIHYtPmFjdGl2ZVJlZ2lvbiwgZi0+ZGF0YSwgZi0+bWFya2VkLFxuXHQqIGYtPnRyYWlsLCBlLT53aW5kaW5nKSBpcyBzZXQgdG8gemVyby5cblx0KlxuXHQqICoqKioqKioqKioqKioqKioqKioqKiogQmFzaWMgRWRnZSBPcGVyYXRpb25zICoqKioqKioqKioqKioqKioqKioqKioqKioqXG5cdCpcblx0KiB0ZXNzTWVzaE1ha2VFZGdlKCBtZXNoICkgY3JlYXRlcyBvbmUgZWRnZSwgdHdvIHZlcnRpY2VzLCBhbmQgYSBsb29wLlxuXHQqIFRoZSBsb29wIChmYWNlKSBjb25zaXN0cyBvZiB0aGUgdHdvIG5ldyBoYWxmLWVkZ2VzLlxuXHQqXG5cdCogdGVzc01lc2hTcGxpY2UoIGVPcmcsIGVEc3QgKSBpcyB0aGUgYmFzaWMgb3BlcmF0aW9uIGZvciBjaGFuZ2luZyB0aGVcblx0KiBtZXNoIGNvbm5lY3Rpdml0eSBhbmQgdG9wb2xvZ3kuICBJdCBjaGFuZ2VzIHRoZSBtZXNoIHNvIHRoYXRcblx0KiAgZU9yZy0+T25leHQgPC0gT0xEKCBlRHN0LT5PbmV4dCApXG5cdCogIGVEc3QtPk9uZXh0IDwtIE9MRCggZU9yZy0+T25leHQgKVxuXHQqIHdoZXJlIE9MRCguLi4pIG1lYW5zIHRoZSB2YWx1ZSBiZWZvcmUgdGhlIG1lc2hTcGxpY2Ugb3BlcmF0aW9uLlxuXHQqXG5cdCogVGhpcyBjYW4gaGF2ZSB0d28gZWZmZWN0cyBvbiB0aGUgdmVydGV4IHN0cnVjdHVyZTpcblx0KiAgLSBpZiBlT3JnLT5PcmcgIT0gZURzdC0+T3JnLCB0aGUgdHdvIHZlcnRpY2VzIGFyZSBtZXJnZWQgdG9nZXRoZXJcblx0KiAgLSBpZiBlT3JnLT5PcmcgPT0gZURzdC0+T3JnLCB0aGUgb3JpZ2luIGlzIHNwbGl0IGludG8gdHdvIHZlcnRpY2VzXG5cdCogSW4gYm90aCBjYXNlcywgZURzdC0+T3JnIGlzIGNoYW5nZWQgYW5kIGVPcmctPk9yZyBpcyB1bnRvdWNoZWQuXG5cdCpcblx0KiBTaW1pbGFybHkgKGFuZCBpbmRlcGVuZGVudGx5KSBmb3IgdGhlIGZhY2Ugc3RydWN0dXJlLFxuXHQqICAtIGlmIGVPcmctPkxmYWNlID09IGVEc3QtPkxmYWNlLCBvbmUgbG9vcCBpcyBzcGxpdCBpbnRvIHR3b1xuXHQqICAtIGlmIGVPcmctPkxmYWNlICE9IGVEc3QtPkxmYWNlLCB0d28gZGlzdGluY3QgbG9vcHMgYXJlIGpvaW5lZCBpbnRvIG9uZVxuXHQqIEluIGJvdGggY2FzZXMsIGVEc3QtPkxmYWNlIGlzIGNoYW5nZWQgYW5kIGVPcmctPkxmYWNlIGlzIHVuYWZmZWN0ZWQuXG5cdCpcblx0KiB0ZXNzTWVzaERlbGV0ZSggZURlbCApIHJlbW92ZXMgdGhlIGVkZ2UgZURlbC4gIFRoZXJlIGFyZSBzZXZlcmFsIGNhc2VzOlxuXHQqIGlmIChlRGVsLT5MZmFjZSAhPSBlRGVsLT5SZmFjZSksIHdlIGpvaW4gdHdvIGxvb3BzIGludG8gb25lOyB0aGUgbG9vcFxuXHQqIGVEZWwtPkxmYWNlIGlzIGRlbGV0ZWQuICBPdGhlcndpc2UsIHdlIGFyZSBzcGxpdHRpbmcgb25lIGxvb3AgaW50byB0d287XG5cdCogdGhlIG5ld2x5IGNyZWF0ZWQgbG9vcCB3aWxsIGNvbnRhaW4gZURlbC0+RHN0LiAgSWYgdGhlIGRlbGV0aW9uIG9mIGVEZWxcblx0KiB3b3VsZCBjcmVhdGUgaXNvbGF0ZWQgdmVydGljZXMsIHRob3NlIGFyZSBkZWxldGVkIGFzIHdlbGwuXG5cdCpcblx0KiAqKioqKioqKioqKioqKioqKioqKioqIE90aGVyIEVkZ2UgT3BlcmF0aW9ucyAqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXHQqXG5cdCogdGVzc01lc2hBZGRFZGdlVmVydGV4KCBlT3JnICkgY3JlYXRlcyBhIG5ldyBlZGdlIGVOZXcgc3VjaCB0aGF0XG5cdCogZU5ldyA9PSBlT3JnLT5MbmV4dCwgYW5kIGVOZXctPkRzdCBpcyBhIG5ld2x5IGNyZWF0ZWQgdmVydGV4LlxuXHQqIGVPcmcgYW5kIGVOZXcgd2lsbCBoYXZlIHRoZSBzYW1lIGxlZnQgZmFjZS5cblx0KlxuXHQqIHRlc3NNZXNoU3BsaXRFZGdlKCBlT3JnICkgc3BsaXRzIGVPcmcgaW50byB0d28gZWRnZXMgZU9yZyBhbmQgZU5ldyxcblx0KiBzdWNoIHRoYXQgZU5ldyA9PSBlT3JnLT5MbmV4dC4gIFRoZSBuZXcgdmVydGV4IGlzIGVPcmctPkRzdCA9PSBlTmV3LT5PcmcuXG5cdCogZU9yZyBhbmQgZU5ldyB3aWxsIGhhdmUgdGhlIHNhbWUgbGVmdCBmYWNlLlxuXHQqXG5cdCogdGVzc01lc2hDb25uZWN0KCBlT3JnLCBlRHN0ICkgY3JlYXRlcyBhIG5ldyBlZGdlIGZyb20gZU9yZy0+RHN0XG5cdCogdG8gZURzdC0+T3JnLCBhbmQgcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyBoYWxmLWVkZ2UgZU5ldy5cblx0KiBJZiBlT3JnLT5MZmFjZSA9PSBlRHN0LT5MZmFjZSwgdGhpcyBzcGxpdHMgb25lIGxvb3AgaW50byB0d28sXG5cdCogYW5kIHRoZSBuZXdseSBjcmVhdGVkIGxvb3AgaXMgZU5ldy0+TGZhY2UuICBPdGhlcndpc2UsIHR3byBkaXNqb2ludFxuXHQqIGxvb3BzIGFyZSBtZXJnZWQgaW50byBvbmUsIGFuZCB0aGUgbG9vcCBlRHN0LT5MZmFjZSBpcyBkZXN0cm95ZWQuXG5cdCpcblx0KiAqKioqKioqKioqKioqKioqKioqKioqKiogT3RoZXIgT3BlcmF0aW9ucyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXHQqXG5cdCogdGVzc01lc2hOZXdNZXNoKCkgY3JlYXRlcyBhIG5ldyBtZXNoIHdpdGggbm8gZWRnZXMsIG5vIHZlcnRpY2VzLFxuXHQqIGFuZCBubyBsb29wcyAod2hhdCB3ZSB1c3VhbGx5IGNhbGwgYSBcImZhY2VcIikuXG5cdCpcblx0KiB0ZXNzTWVzaFVuaW9uKCBtZXNoMSwgbWVzaDIgKSBmb3JtcyB0aGUgdW5pb24gb2YgYWxsIHN0cnVjdHVyZXMgaW5cblx0KiBib3RoIG1lc2hlcywgYW5kIHJldHVybnMgdGhlIG5ldyBtZXNoICh0aGUgb2xkIG1lc2hlcyBhcmUgZGVzdHJveWVkKS5cblx0KlxuXHQqIHRlc3NNZXNoRGVsZXRlTWVzaCggbWVzaCApIHdpbGwgZnJlZSBhbGwgc3RvcmFnZSBmb3IgYW55IHZhbGlkIG1lc2guXG5cdCpcblx0KiB0ZXNzTWVzaFphcEZhY2UoIGZaYXAgKSBkZXN0cm95cyBhIGZhY2UgYW5kIHJlbW92ZXMgaXQgZnJvbSB0aGVcblx0KiBnbG9iYWwgZmFjZSBsaXN0LiAgQWxsIGVkZ2VzIG9mIGZaYXAgd2lsbCBoYXZlIGEgTlVMTCBwb2ludGVyIGFzIHRoZWlyXG5cdCogbGVmdCBmYWNlLiAgQW55IGVkZ2VzIHdoaWNoIGFsc28gaGF2ZSBhIE5VTEwgcG9pbnRlciBhcyB0aGVpciByaWdodCBmYWNlXG5cdCogYXJlIGRlbGV0ZWQgZW50aXJlbHkgKGFsb25nIHdpdGggYW55IGlzb2xhdGVkIHZlcnRpY2VzIHRoaXMgcHJvZHVjZXMpLlxuXHQqIEFuIGVudGlyZSBtZXNoIGNhbiBiZSBkZWxldGVkIGJ5IHphcHBpbmcgaXRzIGZhY2VzLCBvbmUgYXQgYSB0aW1lLFxuXHQqIGluIGFueSBvcmRlci4gIFphcHBlZCBmYWNlcyBjYW5ub3QgYmUgdXNlZCBpbiBmdXJ0aGVyIG1lc2ggb3BlcmF0aW9ucyFcblx0KlxuXHQqIHRlc3NNZXNoQ2hlY2tNZXNoKCBtZXNoICkgY2hlY2tzIGEgbWVzaCBmb3Igc2VsZi1jb25zaXN0ZW5jeS5cblx0Ki9cblxuXHRURVNTbWVzaC5wcm90b3R5cGUgPSB7XG5cblx0XHQvKiBNYWtlRWRnZSBjcmVhdGVzIGEgbmV3IHBhaXIgb2YgaGFsZi1lZGdlcyB3aGljaCBmb3JtIHRoZWlyIG93biBsb29wLlxuXHRcdCogTm8gdmVydGV4IG9yIGZhY2Ugc3RydWN0dXJlcyBhcmUgYWxsb2NhdGVkLCBidXQgdGhlc2UgbXVzdCBiZSBhc3NpZ25lZFxuXHRcdCogYmVmb3JlIHRoZSBjdXJyZW50IGVkZ2Ugb3BlcmF0aW9uIGlzIGNvbXBsZXRlZC5cblx0XHQqL1xuXHRcdC8vc3RhdGljIFRFU1NoYWxmRWRnZSAqTWFrZUVkZ2UoIFRFU1NtZXNoKiBtZXNoLCBURVNTaGFsZkVkZ2UgKmVOZXh0IClcblx0XHRtYWtlRWRnZV86IGZ1bmN0aW9uKGVOZXh0KSB7XG5cdFx0XHR2YXIgZSA9IG5ldyBURVNTaGFsZkVkZ2UoMCk7XG5cdFx0XHR2YXIgZVN5bSA9IG5ldyBURVNTaGFsZkVkZ2UoMSk7XG5cblx0XHRcdC8qIE1ha2Ugc3VyZSBlTmV4dCBwb2ludHMgdG8gdGhlIGZpcnN0IGVkZ2Ugb2YgdGhlIGVkZ2UgcGFpciAqL1xuXHRcdFx0aWYoIGVOZXh0LlN5bS5zaWRlIDwgZU5leHQuc2lkZSApIHsgZU5leHQgPSBlTmV4dC5TeW07IH1cblxuXHRcdFx0LyogSW5zZXJ0IGluIGNpcmN1bGFyIGRvdWJseS1saW5rZWQgbGlzdCBiZWZvcmUgZU5leHQuXG5cdFx0XHQqIE5vdGUgdGhhdCB0aGUgcHJldiBwb2ludGVyIGlzIHN0b3JlZCBpbiBTeW0tPm5leHQuXG5cdFx0XHQqL1xuXHRcdFx0dmFyIGVQcmV2ID0gZU5leHQuU3ltLm5leHQ7XG5cdFx0XHRlU3ltLm5leHQgPSBlUHJldjtcblx0XHRcdGVQcmV2LlN5bS5uZXh0ID0gZTtcblx0XHRcdGUubmV4dCA9IGVOZXh0O1xuXHRcdFx0ZU5leHQuU3ltLm5leHQgPSBlU3ltO1xuXG5cdFx0XHRlLlN5bSA9IGVTeW07XG5cdFx0XHRlLk9uZXh0ID0gZTtcblx0XHRcdGUuTG5leHQgPSBlU3ltO1xuXHRcdFx0ZS5PcmcgPSBudWxsO1xuXHRcdFx0ZS5MZmFjZSA9IG51bGw7XG5cdFx0XHRlLndpbmRpbmcgPSAwO1xuXHRcdFx0ZS5hY3RpdmVSZWdpb24gPSBudWxsO1xuXG5cdFx0XHRlU3ltLlN5bSA9IGU7XG5cdFx0XHRlU3ltLk9uZXh0ID0gZVN5bTtcblx0XHRcdGVTeW0uTG5leHQgPSBlO1xuXHRcdFx0ZVN5bS5PcmcgPSBudWxsO1xuXHRcdFx0ZVN5bS5MZmFjZSA9IG51bGw7XG5cdFx0XHRlU3ltLndpbmRpbmcgPSAwO1xuXHRcdFx0ZVN5bS5hY3RpdmVSZWdpb24gPSBudWxsO1xuXG5cdFx0XHRyZXR1cm4gZTtcblx0XHR9LFxuXG5cdFx0LyogU3BsaWNlKCBhLCBiICkgaXMgYmVzdCBkZXNjcmliZWQgYnkgdGhlIEd1aWJhcy9TdG9sZmkgcGFwZXIgb3IgdGhlXG5cdFx0KiBDUzM0OGEgbm90ZXMgKHNlZSBtZXNoLmgpLiAgQmFzaWNhbGx5IGl0IG1vZGlmaWVzIHRoZSBtZXNoIHNvIHRoYXRcblx0XHQqIGEtPk9uZXh0IGFuZCBiLT5PbmV4dCBhcmUgZXhjaGFuZ2VkLiAgVGhpcyBjYW4gaGF2ZSB2YXJpb3VzIGVmZmVjdHNcblx0XHQqIGRlcGVuZGluZyBvbiB3aGV0aGVyIGEgYW5kIGIgYmVsb25nIHRvIGRpZmZlcmVudCBmYWNlIG9yIHZlcnRleCByaW5ncy5cblx0XHQqIEZvciBtb3JlIGV4cGxhbmF0aW9uIHNlZSB0ZXNzTWVzaFNwbGljZSgpIGJlbG93LlxuXHRcdCovXG5cdFx0Ly8gc3RhdGljIHZvaWQgU3BsaWNlKCBURVNTaGFsZkVkZ2UgKmEsIFRFU1NoYWxmRWRnZSAqYiApXG5cdFx0c3BsaWNlXzogZnVuY3Rpb24oYSwgYikge1xuXHRcdFx0dmFyIGFPbmV4dCA9IGEuT25leHQ7XG5cdFx0XHR2YXIgYk9uZXh0ID0gYi5PbmV4dDtcblx0XHRcdGFPbmV4dC5TeW0uTG5leHQgPSBiO1xuXHRcdFx0Yk9uZXh0LlN5bS5MbmV4dCA9IGE7XG5cdFx0XHRhLk9uZXh0ID0gYk9uZXh0O1xuXHRcdFx0Yi5PbmV4dCA9IGFPbmV4dDtcblx0XHR9LFxuXG5cdFx0LyogTWFrZVZlcnRleCggbmV3VmVydGV4LCBlT3JpZywgdk5leHQgKSBhdHRhY2hlcyBhIG5ldyB2ZXJ0ZXggYW5kIG1ha2VzIGl0IHRoZVxuXHRcdCogb3JpZ2luIG9mIGFsbCBlZGdlcyBpbiB0aGUgdmVydGV4IGxvb3AgdG8gd2hpY2ggZU9yaWcgYmVsb25ncy4gXCJ2TmV4dFwiIGdpdmVzXG5cdFx0KiBhIHBsYWNlIHRvIGluc2VydCB0aGUgbmV3IHZlcnRleCBpbiB0aGUgZ2xvYmFsIHZlcnRleCBsaXN0LiAgV2UgaW5zZXJ0XG5cdFx0KiB0aGUgbmV3IHZlcnRleCAqYmVmb3JlKiB2TmV4dCBzbyB0aGF0IGFsZ29yaXRobXMgd2hpY2ggd2FsayB0aGUgdmVydGV4XG5cdFx0KiBsaXN0IHdpbGwgbm90IHNlZSB0aGUgbmV3bHkgY3JlYXRlZCB2ZXJ0aWNlcy5cblx0XHQqL1xuXHRcdC8vc3RhdGljIHZvaWQgTWFrZVZlcnRleCggVEVTU3ZlcnRleCAqbmV3VmVydGV4LCBURVNTaGFsZkVkZ2UgKmVPcmlnLCBURVNTdmVydGV4ICp2TmV4dCApXG5cdFx0bWFrZVZlcnRleF86IGZ1bmN0aW9uKG5ld1ZlcnRleCwgZU9yaWcsIHZOZXh0KSB7XG5cdFx0XHR2YXIgdk5ldyA9IG5ld1ZlcnRleDtcblx0XHRcdGFzc2VydCh2TmV3ICE9PSBudWxsKTtcblxuXHRcdFx0LyogaW5zZXJ0IGluIGNpcmN1bGFyIGRvdWJseS1saW5rZWQgbGlzdCBiZWZvcmUgdk5leHQgKi9cblx0XHRcdHZhciB2UHJldiA9IHZOZXh0LnByZXY7XG5cdFx0XHR2TmV3LnByZXYgPSB2UHJldjtcblx0XHRcdHZQcmV2Lm5leHQgPSB2TmV3O1xuXHRcdFx0dk5ldy5uZXh0ID0gdk5leHQ7XG5cdFx0XHR2TmV4dC5wcmV2ID0gdk5ldztcblxuXHRcdFx0dk5ldy5hbkVkZ2UgPSBlT3JpZztcblx0XHRcdC8qIGxlYXZlIGNvb3JkcywgcywgdCB1bmRlZmluZWQgKi9cblxuXHRcdFx0LyogZml4IG90aGVyIGVkZ2VzIG9uIHRoaXMgdmVydGV4IGxvb3AgKi9cblx0XHRcdHZhciBlID0gZU9yaWc7XG5cdFx0XHRkbyB7XG5cdFx0XHRcdGUuT3JnID0gdk5ldztcblx0XHRcdFx0ZSA9IGUuT25leHQ7XG5cdFx0XHR9IHdoaWxlKGUgIT09IGVPcmlnKTtcblx0XHR9LFxuXG5cdFx0LyogTWFrZUZhY2UoIG5ld0ZhY2UsIGVPcmlnLCBmTmV4dCApIGF0dGFjaGVzIGEgbmV3IGZhY2UgYW5kIG1ha2VzIGl0IHRoZSBsZWZ0XG5cdFx0KiBmYWNlIG9mIGFsbCBlZGdlcyBpbiB0aGUgZmFjZSBsb29wIHRvIHdoaWNoIGVPcmlnIGJlbG9uZ3MuICBcImZOZXh0XCIgZ2l2ZXNcblx0XHQqIGEgcGxhY2UgdG8gaW5zZXJ0IHRoZSBuZXcgZmFjZSBpbiB0aGUgZ2xvYmFsIGZhY2UgbGlzdC4gIFdlIGluc2VydFxuXHRcdCogdGhlIG5ldyBmYWNlICpiZWZvcmUqIGZOZXh0IHNvIHRoYXQgYWxnb3JpdGhtcyB3aGljaCB3YWxrIHRoZSBmYWNlXG5cdFx0KiBsaXN0IHdpbGwgbm90IHNlZSB0aGUgbmV3bHkgY3JlYXRlZCBmYWNlcy5cblx0XHQqL1xuXHRcdC8vIHN0YXRpYyB2b2lkIE1ha2VGYWNlKCBURVNTZmFjZSAqbmV3RmFjZSwgVEVTU2hhbGZFZGdlICplT3JpZywgVEVTU2ZhY2UgKmZOZXh0IClcblx0XHRtYWtlRmFjZV86IGZ1bmN0aW9uKG5ld0ZhY2UsIGVPcmlnLCBmTmV4dCkge1xuXHRcdFx0dmFyIGZOZXcgPSBuZXdGYWNlO1xuXHRcdFx0YXNzZXJ0KGZOZXcgIT09IG51bGwpOyBcblxuXHRcdFx0LyogaW5zZXJ0IGluIGNpcmN1bGFyIGRvdWJseS1saW5rZWQgbGlzdCBiZWZvcmUgZk5leHQgKi9cblx0XHRcdHZhciBmUHJldiA9IGZOZXh0LnByZXY7XG5cdFx0XHRmTmV3LnByZXYgPSBmUHJldjtcblx0XHRcdGZQcmV2Lm5leHQgPSBmTmV3O1xuXHRcdFx0Zk5ldy5uZXh0ID0gZk5leHQ7XG5cdFx0XHRmTmV4dC5wcmV2ID0gZk5ldztcblxuXHRcdFx0Zk5ldy5hbkVkZ2UgPSBlT3JpZztcblx0XHRcdGZOZXcudHJhaWwgPSBudWxsO1xuXHRcdFx0Zk5ldy5tYXJrZWQgPSBmYWxzZTtcblxuXHRcdFx0LyogVGhlIG5ldyBmYWNlIGlzIG1hcmtlZCBcImluc2lkZVwiIGlmIHRoZSBvbGQgb25lIHdhcy4gIFRoaXMgaXMgYVxuXHRcdFx0KiBjb252ZW5pZW5jZSBmb3IgdGhlIGNvbW1vbiBjYXNlIHdoZXJlIGEgZmFjZSBoYXMgYmVlbiBzcGxpdCBpbiB0d28uXG5cdFx0XHQqL1xuXHRcdFx0Zk5ldy5pbnNpZGUgPSBmTmV4dC5pbnNpZGU7XG5cblx0XHRcdC8qIGZpeCBvdGhlciBlZGdlcyBvbiB0aGlzIGZhY2UgbG9vcCAqL1xuXHRcdFx0dmFyIGUgPSBlT3JpZztcblx0XHRcdGRvIHtcblx0XHRcdFx0ZS5MZmFjZSA9IGZOZXc7XG5cdFx0XHRcdGUgPSBlLkxuZXh0O1xuXHRcdFx0fSB3aGlsZShlICE9PSBlT3JpZyk7XG5cdFx0fSxcblxuXHRcdC8qIEtpbGxFZGdlKCBlRGVsICkgZGVzdHJveXMgYW4gZWRnZSAodGhlIGhhbGYtZWRnZXMgZURlbCBhbmQgZURlbC0+U3ltKSxcblx0XHQqIGFuZCByZW1vdmVzIGZyb20gdGhlIGdsb2JhbCBlZGdlIGxpc3QuXG5cdFx0Ki9cblx0XHQvL3N0YXRpYyB2b2lkIEtpbGxFZGdlKCBURVNTbWVzaCAqbWVzaCwgVEVTU2hhbGZFZGdlICplRGVsIClcblx0XHRraWxsRWRnZV86IGZ1bmN0aW9uKGVEZWwpIHtcblx0XHRcdC8qIEhhbGYtZWRnZXMgYXJlIGFsbG9jYXRlZCBpbiBwYWlycywgc2VlIEVkZ2VQYWlyIGFib3ZlICovXG5cdFx0XHRpZiggZURlbC5TeW0uc2lkZSA8IGVEZWwuc2lkZSApIHsgZURlbCA9IGVEZWwuU3ltOyB9XG5cblx0XHRcdC8qIGRlbGV0ZSBmcm9tIGNpcmN1bGFyIGRvdWJseS1saW5rZWQgbGlzdCAqL1xuXHRcdFx0dmFyIGVOZXh0ID0gZURlbC5uZXh0O1xuXHRcdFx0dmFyIGVQcmV2ID0gZURlbC5TeW0ubmV4dDtcblx0XHRcdGVOZXh0LlN5bS5uZXh0ID0gZVByZXY7XG5cdFx0XHRlUHJldi5TeW0ubmV4dCA9IGVOZXh0O1xuXHRcdH0sXG5cblxuXHRcdC8qIEtpbGxWZXJ0ZXgoIHZEZWwgKSBkZXN0cm95cyBhIHZlcnRleCBhbmQgcmVtb3ZlcyBpdCBmcm9tIHRoZSBnbG9iYWxcblx0XHQqIHZlcnRleCBsaXN0LiAgSXQgdXBkYXRlcyB0aGUgdmVydGV4IGxvb3AgdG8gcG9pbnQgdG8gYSBnaXZlbiBuZXcgdmVydGV4LlxuXHRcdCovXG5cdFx0Ly9zdGF0aWMgdm9pZCBLaWxsVmVydGV4KCBURVNTbWVzaCAqbWVzaCwgVEVTU3ZlcnRleCAqdkRlbCwgVEVTU3ZlcnRleCAqbmV3T3JnIClcblx0XHRraWxsVmVydGV4XzogZnVuY3Rpb24odkRlbCwgbmV3T3JnKSB7XG5cdFx0XHR2YXIgZVN0YXJ0ID0gdkRlbC5hbkVkZ2U7XG5cdFx0XHQvKiBjaGFuZ2UgdGhlIG9yaWdpbiBvZiBhbGwgYWZmZWN0ZWQgZWRnZXMgKi9cblx0XHRcdHZhciBlID0gZVN0YXJ0O1xuXHRcdFx0ZG8ge1xuXHRcdFx0XHRlLk9yZyA9IG5ld09yZztcblx0XHRcdFx0ZSA9IGUuT25leHQ7XG5cdFx0XHR9IHdoaWxlKGUgIT09IGVTdGFydCk7XG5cblx0XHRcdC8qIGRlbGV0ZSBmcm9tIGNpcmN1bGFyIGRvdWJseS1saW5rZWQgbGlzdCAqL1xuXHRcdFx0dmFyIHZQcmV2ID0gdkRlbC5wcmV2O1xuXHRcdFx0dmFyIHZOZXh0ID0gdkRlbC5uZXh0O1xuXHRcdFx0dk5leHQucHJldiA9IHZQcmV2O1xuXHRcdFx0dlByZXYubmV4dCA9IHZOZXh0O1xuXHRcdH0sXG5cblx0XHQvKiBLaWxsRmFjZSggZkRlbCApIGRlc3Ryb3lzIGEgZmFjZSBhbmQgcmVtb3ZlcyBpdCBmcm9tIHRoZSBnbG9iYWwgZmFjZVxuXHRcdCogbGlzdC4gIEl0IHVwZGF0ZXMgdGhlIGZhY2UgbG9vcCB0byBwb2ludCB0byBhIGdpdmVuIG5ldyBmYWNlLlxuXHRcdCovXG5cdFx0Ly9zdGF0aWMgdm9pZCBLaWxsRmFjZSggVEVTU21lc2ggKm1lc2gsIFRFU1NmYWNlICpmRGVsLCBURVNTZmFjZSAqbmV3TGZhY2UgKVxuXHRcdGtpbGxGYWNlXzogZnVuY3Rpb24oZkRlbCwgbmV3TGZhY2UpIHtcblx0XHRcdHZhciBlU3RhcnQgPSBmRGVsLmFuRWRnZTtcblxuXHRcdFx0LyogY2hhbmdlIHRoZSBsZWZ0IGZhY2Ugb2YgYWxsIGFmZmVjdGVkIGVkZ2VzICovXG5cdFx0XHR2YXIgZSA9IGVTdGFydDtcblx0XHRcdGRvIHtcblx0XHRcdFx0ZS5MZmFjZSA9IG5ld0xmYWNlO1xuXHRcdFx0XHRlID0gZS5MbmV4dDtcblx0XHRcdH0gd2hpbGUoZSAhPT0gZVN0YXJ0KTtcblxuXHRcdFx0LyogZGVsZXRlIGZyb20gY2lyY3VsYXIgZG91Ymx5LWxpbmtlZCBsaXN0ICovXG5cdFx0XHR2YXIgZlByZXYgPSBmRGVsLnByZXY7XG5cdFx0XHR2YXIgZk5leHQgPSBmRGVsLm5leHQ7XG5cdFx0XHRmTmV4dC5wcmV2ID0gZlByZXY7XG5cdFx0XHRmUHJldi5uZXh0ID0gZk5leHQ7XG5cdFx0fSxcblxuXHRcdC8qKioqKioqKioqKioqKioqKiogQmFzaWMgRWRnZSBPcGVyYXRpb25zICoqKioqKioqKioqKioqKioqKioqKiovXG5cblx0XHQvKiB0ZXNzTWVzaE1ha2VFZGdlIGNyZWF0ZXMgb25lIGVkZ2UsIHR3byB2ZXJ0aWNlcywgYW5kIGEgbG9vcCAoZmFjZSkuXG5cdFx0KiBUaGUgbG9vcCBjb25zaXN0cyBvZiB0aGUgdHdvIG5ldyBoYWxmLWVkZ2VzLlxuXHRcdCovXG5cdFx0Ly9URVNTaGFsZkVkZ2UgKnRlc3NNZXNoTWFrZUVkZ2UoIFRFU1NtZXNoICptZXNoIClcblx0XHRtYWtlRWRnZTogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3VmVydGV4MSA9IG5ldyBURVNTdmVydGV4KCk7XG5cdFx0XHR2YXIgbmV3VmVydGV4MiA9IG5ldyBURVNTdmVydGV4KCk7XG5cdFx0XHR2YXIgbmV3RmFjZSA9IG5ldyBURVNTZmFjZSgpO1xuXHRcdFx0dmFyIGUgPSB0aGlzLm1ha2VFZGdlXyggdGhpcy5lSGVhZCk7XG5cdFx0XHR0aGlzLm1ha2VWZXJ0ZXhfKCBuZXdWZXJ0ZXgxLCBlLCB0aGlzLnZIZWFkICk7XG5cdFx0XHR0aGlzLm1ha2VWZXJ0ZXhfKCBuZXdWZXJ0ZXgyLCBlLlN5bSwgdGhpcy52SGVhZCApO1xuXHRcdFx0dGhpcy5tYWtlRmFjZV8oIG5ld0ZhY2UsIGUsIHRoaXMuZkhlYWQgKTtcblx0XHRcdHJldHVybiBlO1xuXHRcdH0sXG5cblx0XHQvKiB0ZXNzTWVzaFNwbGljZSggZU9yZywgZURzdCApIGlzIHRoZSBiYXNpYyBvcGVyYXRpb24gZm9yIGNoYW5naW5nIHRoZVxuXHRcdCogbWVzaCBjb25uZWN0aXZpdHkgYW5kIHRvcG9sb2d5LiAgSXQgY2hhbmdlcyB0aGUgbWVzaCBzbyB0aGF0XG5cdFx0Klx0ZU9yZy0+T25leHQgPC0gT0xEKCBlRHN0LT5PbmV4dCApXG5cdFx0Klx0ZURzdC0+T25leHQgPC0gT0xEKCBlT3JnLT5PbmV4dCApXG5cdFx0KiB3aGVyZSBPTEQoLi4uKSBtZWFucyB0aGUgdmFsdWUgYmVmb3JlIHRoZSBtZXNoU3BsaWNlIG9wZXJhdGlvbi5cblx0XHQqXG5cdFx0KiBUaGlzIGNhbiBoYXZlIHR3byBlZmZlY3RzIG9uIHRoZSB2ZXJ0ZXggc3RydWN0dXJlOlxuXHRcdCogIC0gaWYgZU9yZy0+T3JnICE9IGVEc3QtPk9yZywgdGhlIHR3byB2ZXJ0aWNlcyBhcmUgbWVyZ2VkIHRvZ2V0aGVyXG5cdFx0KiAgLSBpZiBlT3JnLT5PcmcgPT0gZURzdC0+T3JnLCB0aGUgb3JpZ2luIGlzIHNwbGl0IGludG8gdHdvIHZlcnRpY2VzXG5cdFx0KiBJbiBib3RoIGNhc2VzLCBlRHN0LT5PcmcgaXMgY2hhbmdlZCBhbmQgZU9yZy0+T3JnIGlzIHVudG91Y2hlZC5cblx0XHQqXG5cdFx0KiBTaW1pbGFybHkgKGFuZCBpbmRlcGVuZGVudGx5KSBmb3IgdGhlIGZhY2Ugc3RydWN0dXJlLFxuXHRcdCogIC0gaWYgZU9yZy0+TGZhY2UgPT0gZURzdC0+TGZhY2UsIG9uZSBsb29wIGlzIHNwbGl0IGludG8gdHdvXG5cdFx0KiAgLSBpZiBlT3JnLT5MZmFjZSAhPSBlRHN0LT5MZmFjZSwgdHdvIGRpc3RpbmN0IGxvb3BzIGFyZSBqb2luZWQgaW50byBvbmVcblx0XHQqIEluIGJvdGggY2FzZXMsIGVEc3QtPkxmYWNlIGlzIGNoYW5nZWQgYW5kIGVPcmctPkxmYWNlIGlzIHVuYWZmZWN0ZWQuXG5cdFx0KlxuXHRcdCogU29tZSBzcGVjaWFsIGNhc2VzOlxuXHRcdCogSWYgZURzdCA9PSBlT3JnLCB0aGUgb3BlcmF0aW9uIGhhcyBubyBlZmZlY3QuXG5cdFx0KiBJZiBlRHN0ID09IGVPcmctPkxuZXh0LCB0aGUgbmV3IGZhY2Ugd2lsbCBoYXZlIGEgc2luZ2xlIGVkZ2UuXG5cdFx0KiBJZiBlRHN0ID09IGVPcmctPkxwcmV2LCB0aGUgb2xkIGZhY2Ugd2lsbCBoYXZlIGEgc2luZ2xlIGVkZ2UuXG5cdFx0KiBJZiBlRHN0ID09IGVPcmctPk9uZXh0LCB0aGUgbmV3IHZlcnRleCB3aWxsIGhhdmUgYSBzaW5nbGUgZWRnZS5cblx0XHQqIElmIGVEc3QgPT0gZU9yZy0+T3ByZXYsIHRoZSBvbGQgdmVydGV4IHdpbGwgaGF2ZSBhIHNpbmdsZSBlZGdlLlxuXHRcdCovXG5cdFx0Ly9pbnQgdGVzc01lc2hTcGxpY2UoIFRFU1NtZXNoKiBtZXNoLCBURVNTaGFsZkVkZ2UgKmVPcmcsIFRFU1NoYWxmRWRnZSAqZURzdCApXG5cdFx0c3BsaWNlOiBmdW5jdGlvbihlT3JnLCBlRHN0KSB7XG5cdFx0XHR2YXIgam9pbmluZ0xvb3BzID0gZmFsc2U7XG5cdFx0XHR2YXIgam9pbmluZ1ZlcnRpY2VzID0gZmFsc2U7XG5cblx0XHRcdGlmKCBlT3JnID09PSBlRHN0ICkgcmV0dXJuO1xuXG5cdFx0XHRpZiggZURzdC5PcmcgIT09IGVPcmcuT3JnICkge1xuXHRcdFx0XHQvKiBXZSBhcmUgbWVyZ2luZyB0d28gZGlzam9pbnQgdmVydGljZXMgLS0gZGVzdHJveSBlRHN0LT5PcmcgKi9cblx0XHRcdFx0am9pbmluZ1ZlcnRpY2VzID0gdHJ1ZTtcblx0XHRcdFx0dGhpcy5raWxsVmVydGV4XyggZURzdC5PcmcsIGVPcmcuT3JnICk7XG5cdFx0XHR9XG5cdFx0XHRpZiggZURzdC5MZmFjZSAhPT0gZU9yZy5MZmFjZSApIHtcblx0XHRcdFx0LyogV2UgYXJlIGNvbm5lY3RpbmcgdHdvIGRpc2pvaW50IGxvb3BzIC0tIGRlc3Ryb3kgZURzdC0+TGZhY2UgKi9cblx0XHRcdFx0am9pbmluZ0xvb3BzID0gdHJ1ZTtcblx0XHRcdFx0dGhpcy5raWxsRmFjZV8oIGVEc3QuTGZhY2UsIGVPcmcuTGZhY2UgKTtcblx0XHRcdH1cblxuXHRcdFx0LyogQ2hhbmdlIHRoZSBlZGdlIHN0cnVjdHVyZSAqL1xuXHRcdFx0dGhpcy5zcGxpY2VfKCBlRHN0LCBlT3JnICk7XG5cblx0XHRcdGlmKCAhIGpvaW5pbmdWZXJ0aWNlcyApIHtcblx0XHRcdFx0dmFyIG5ld1ZlcnRleCA9IG5ldyBURVNTdmVydGV4KCk7XG5cblx0XHRcdFx0LyogV2Ugc3BsaXQgb25lIHZlcnRleCBpbnRvIHR3byAtLSB0aGUgbmV3IHZlcnRleCBpcyBlRHN0LT5PcmcuXG5cdFx0XHRcdCogTWFrZSBzdXJlIHRoZSBvbGQgdmVydGV4IHBvaW50cyB0byBhIHZhbGlkIGhhbGYtZWRnZS5cblx0XHRcdFx0Ki9cblx0XHRcdFx0dGhpcy5tYWtlVmVydGV4XyggbmV3VmVydGV4LCBlRHN0LCBlT3JnLk9yZyApO1xuXHRcdFx0XHRlT3JnLk9yZy5hbkVkZ2UgPSBlT3JnO1xuXHRcdFx0fVxuXHRcdFx0aWYoICEgam9pbmluZ0xvb3BzICkge1xuXHRcdFx0XHR2YXIgbmV3RmFjZSA9IG5ldyBURVNTZmFjZSgpOyAgXG5cblx0XHRcdFx0LyogV2Ugc3BsaXQgb25lIGxvb3AgaW50byB0d28gLS0gdGhlIG5ldyBsb29wIGlzIGVEc3QtPkxmYWNlLlxuXHRcdFx0XHQqIE1ha2Ugc3VyZSB0aGUgb2xkIGZhY2UgcG9pbnRzIHRvIGEgdmFsaWQgaGFsZi1lZGdlLlxuXHRcdFx0XHQqL1xuXHRcdFx0XHR0aGlzLm1ha2VGYWNlXyggbmV3RmFjZSwgZURzdCwgZU9yZy5MZmFjZSApO1xuXHRcdFx0XHRlT3JnLkxmYWNlLmFuRWRnZSA9IGVPcmc7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qIHRlc3NNZXNoRGVsZXRlKCBlRGVsICkgcmVtb3ZlcyB0aGUgZWRnZSBlRGVsLiAgVGhlcmUgYXJlIHNldmVyYWwgY2FzZXM6XG5cdFx0KiBpZiAoZURlbC0+TGZhY2UgIT0gZURlbC0+UmZhY2UpLCB3ZSBqb2luIHR3byBsb29wcyBpbnRvIG9uZTsgdGhlIGxvb3Bcblx0XHQqIGVEZWwtPkxmYWNlIGlzIGRlbGV0ZWQuICBPdGhlcndpc2UsIHdlIGFyZSBzcGxpdHRpbmcgb25lIGxvb3AgaW50byB0d287XG5cdFx0KiB0aGUgbmV3bHkgY3JlYXRlZCBsb29wIHdpbGwgY29udGFpbiBlRGVsLT5Ec3QuICBJZiB0aGUgZGVsZXRpb24gb2YgZURlbFxuXHRcdCogd291bGQgY3JlYXRlIGlzb2xhdGVkIHZlcnRpY2VzLCB0aG9zZSBhcmUgZGVsZXRlZCBhcyB3ZWxsLlxuXHRcdCpcblx0XHQqIFRoaXMgZnVuY3Rpb24gY291bGQgYmUgaW1wbGVtZW50ZWQgYXMgdHdvIGNhbGxzIHRvIHRlc3NNZXNoU3BsaWNlXG5cdFx0KiBwbHVzIGEgZmV3IGNhbGxzIHRvIG1lbUZyZWUsIGJ1dCB0aGlzIHdvdWxkIGFsbG9jYXRlIGFuZCBkZWxldGVcblx0XHQqIHVubmVjZXNzYXJ5IHZlcnRpY2VzIGFuZCBmYWNlcy5cblx0XHQqL1xuXHRcdC8vaW50IHRlc3NNZXNoRGVsZXRlKCBURVNTbWVzaCAqbWVzaCwgVEVTU2hhbGZFZGdlICplRGVsIClcblx0XHRkZWxldGU6IGZ1bmN0aW9uKGVEZWwpIHtcblx0XHRcdHZhciBlRGVsU3ltID0gZURlbC5TeW07XG5cdFx0XHR2YXIgam9pbmluZ0xvb3BzID0gZmFsc2U7XG5cblx0XHRcdC8qIEZpcnN0IHN0ZXA6IGRpc2Nvbm5lY3QgdGhlIG9yaWdpbiB2ZXJ0ZXggZURlbC0+T3JnLiAgV2UgbWFrZSBhbGxcblx0XHRcdCogY2hhbmdlcyB0byBnZXQgYSBjb25zaXN0ZW50IG1lc2ggaW4gdGhpcyBcImludGVybWVkaWF0ZVwiIHN0YXRlLlxuXHRcdFx0Ki9cblx0XHRcdGlmKCBlRGVsLkxmYWNlICE9PSBlRGVsLlJmYWNlICkge1xuXHRcdFx0XHQvKiBXZSBhcmUgam9pbmluZyB0d28gbG9vcHMgaW50byBvbmUgLS0gcmVtb3ZlIHRoZSBsZWZ0IGZhY2UgKi9cblx0XHRcdFx0am9pbmluZ0xvb3BzID0gdHJ1ZTtcblx0XHRcdFx0dGhpcy5raWxsRmFjZV8oIGVEZWwuTGZhY2UsIGVEZWwuUmZhY2UgKTtcblx0XHRcdH1cblxuXHRcdFx0aWYoIGVEZWwuT25leHQgPT09IGVEZWwgKSB7XG5cdFx0XHRcdHRoaXMua2lsbFZlcnRleF8oIGVEZWwuT3JnLCBudWxsICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvKiBNYWtlIHN1cmUgdGhhdCBlRGVsLT5PcmcgYW5kIGVEZWwtPlJmYWNlIHBvaW50IHRvIHZhbGlkIGhhbGYtZWRnZXMgKi9cblx0XHRcdFx0ZURlbC5SZmFjZS5hbkVkZ2UgPSBlRGVsLk9wcmV2O1xuXHRcdFx0XHRlRGVsLk9yZy5hbkVkZ2UgPSBlRGVsLk9uZXh0O1xuXG5cdFx0XHRcdHRoaXMuc3BsaWNlXyggZURlbCwgZURlbC5PcHJldiApO1xuXHRcdFx0XHRpZiggISBqb2luaW5nTG9vcHMgKSB7XG5cdFx0XHRcdFx0dmFyIG5ld0ZhY2UgPSBuZXcgVEVTU2ZhY2UoKTtcblxuXHRcdFx0XHRcdC8qIFdlIGFyZSBzcGxpdHRpbmcgb25lIGxvb3AgaW50byB0d28gLS0gY3JlYXRlIGEgbmV3IGxvb3AgZm9yIGVEZWwuICovXG5cdFx0XHRcdFx0dGhpcy5tYWtlRmFjZV8oIG5ld0ZhY2UsIGVEZWwsIGVEZWwuTGZhY2UgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvKiBDbGFpbTogdGhlIG1lc2ggaXMgbm93IGluIGEgY29uc2lzdGVudCBzdGF0ZSwgZXhjZXB0IHRoYXQgZURlbC0+T3JnXG5cdFx0XHQqIG1heSBoYXZlIGJlZW4gZGVsZXRlZC4gIE5vdyB3ZSBkaXNjb25uZWN0IGVEZWwtPkRzdC5cblx0XHRcdCovXG5cdFx0XHRpZiggZURlbFN5bS5PbmV4dCA9PT0gZURlbFN5bSApIHtcblx0XHRcdFx0dGhpcy5raWxsVmVydGV4XyggZURlbFN5bS5PcmcsIG51bGwgKTtcblx0XHRcdFx0dGhpcy5raWxsRmFjZV8oIGVEZWxTeW0uTGZhY2UsIG51bGwgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8qIE1ha2Ugc3VyZSB0aGF0IGVEZWwtPkRzdCBhbmQgZURlbC0+TGZhY2UgcG9pbnQgdG8gdmFsaWQgaGFsZi1lZGdlcyAqL1xuXHRcdFx0XHRlRGVsLkxmYWNlLmFuRWRnZSA9IGVEZWxTeW0uT3ByZXY7XG5cdFx0XHRcdGVEZWxTeW0uT3JnLmFuRWRnZSA9IGVEZWxTeW0uT25leHQ7XG5cdFx0XHRcdHRoaXMuc3BsaWNlXyggZURlbFN5bSwgZURlbFN5bS5PcHJldiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvKiBBbnkgaXNvbGF0ZWQgdmVydGljZXMgb3IgZmFjZXMgaGF2ZSBhbHJlYWR5IGJlZW4gZnJlZWQuICovXG5cdFx0XHR0aGlzLmtpbGxFZGdlXyggZURlbCApO1xuXHRcdH0sXG5cblx0XHQvKioqKioqKioqKioqKioqKioqKiogT3RoZXIgRWRnZSBPcGVyYXRpb25zICoqKioqKioqKioqKioqKioqKioqKiovXG5cblx0XHQvKiBBbGwgdGhlc2Ugcm91dGluZXMgY2FuIGJlIGltcGxlbWVudGVkIHdpdGggdGhlIGJhc2ljIGVkZ2Vcblx0XHQqIG9wZXJhdGlvbnMgYWJvdmUuICBUaGV5IGFyZSBwcm92aWRlZCBmb3IgY29udmVuaWVuY2UgYW5kIGVmZmljaWVuY3kuXG5cdFx0Ki9cblxuXG5cdFx0LyogdGVzc01lc2hBZGRFZGdlVmVydGV4KCBlT3JnICkgY3JlYXRlcyBhIG5ldyBlZGdlIGVOZXcgc3VjaCB0aGF0XG5cdFx0KiBlTmV3ID09IGVPcmctPkxuZXh0LCBhbmQgZU5ldy0+RHN0IGlzIGEgbmV3bHkgY3JlYXRlZCB2ZXJ0ZXguXG5cdFx0KiBlT3JnIGFuZCBlTmV3IHdpbGwgaGF2ZSB0aGUgc2FtZSBsZWZ0IGZhY2UuXG5cdFx0Ki9cblx0XHQvLyBURVNTaGFsZkVkZ2UgKnRlc3NNZXNoQWRkRWRnZVZlcnRleCggVEVTU21lc2ggKm1lc2gsIFRFU1NoYWxmRWRnZSAqZU9yZyApO1xuXHRcdGFkZEVkZ2VWZXJ0ZXg6IGZ1bmN0aW9uKGVPcmcpIHtcblx0XHRcdHZhciBlTmV3ID0gdGhpcy5tYWtlRWRnZV8oIGVPcmcgKTtcblx0XHRcdHZhciBlTmV3U3ltID0gZU5ldy5TeW07XG5cblx0XHRcdC8qIENvbm5lY3QgdGhlIG5ldyBlZGdlIGFwcHJvcHJpYXRlbHkgKi9cblx0XHRcdHRoaXMuc3BsaWNlXyggZU5ldywgZU9yZy5MbmV4dCApO1xuXG5cdFx0XHQvKiBTZXQgdGhlIHZlcnRleCBhbmQgZmFjZSBpbmZvcm1hdGlvbiAqL1xuXHRcdFx0ZU5ldy5PcmcgPSBlT3JnLkRzdDtcblxuXHRcdFx0dmFyIG5ld1ZlcnRleCA9IG5ldyBURVNTdmVydGV4KCk7XG5cdFx0XHR0aGlzLm1ha2VWZXJ0ZXhfKCBuZXdWZXJ0ZXgsIGVOZXdTeW0sIGVOZXcuT3JnICk7XG5cblx0XHRcdGVOZXcuTGZhY2UgPSBlTmV3U3ltLkxmYWNlID0gZU9yZy5MZmFjZTtcblxuXHRcdFx0cmV0dXJuIGVOZXc7XG5cdFx0fSxcblxuXG5cdFx0LyogdGVzc01lc2hTcGxpdEVkZ2UoIGVPcmcgKSBzcGxpdHMgZU9yZyBpbnRvIHR3byBlZGdlcyBlT3JnIGFuZCBlTmV3LFxuXHRcdCogc3VjaCB0aGF0IGVOZXcgPT0gZU9yZy0+TG5leHQuICBUaGUgbmV3IHZlcnRleCBpcyBlT3JnLT5Ec3QgPT0gZU5ldy0+T3JnLlxuXHRcdCogZU9yZyBhbmQgZU5ldyB3aWxsIGhhdmUgdGhlIHNhbWUgbGVmdCBmYWNlLlxuXHRcdCovXG5cdFx0Ly8gVEVTU2hhbGZFZGdlICp0ZXNzTWVzaFNwbGl0RWRnZSggVEVTU21lc2ggKm1lc2gsIFRFU1NoYWxmRWRnZSAqZU9yZyApO1xuXHRcdHNwbGl0RWRnZTogZnVuY3Rpb24oZU9yZywgZURzdCkge1xuXHRcdFx0dmFyIHRlbXBIYWxmRWRnZSA9IHRoaXMuYWRkRWRnZVZlcnRleCggZU9yZyApO1xuXHRcdFx0dmFyIGVOZXcgPSB0ZW1wSGFsZkVkZ2UuU3ltO1xuXG5cdFx0XHQvKiBEaXNjb25uZWN0IGVPcmcgZnJvbSBlT3JnLT5Ec3QgYW5kIGNvbm5lY3QgaXQgdG8gZU5ldy0+T3JnICovXG5cdFx0XHR0aGlzLnNwbGljZV8oIGVPcmcuU3ltLCBlT3JnLlN5bS5PcHJldiApO1xuXHRcdFx0dGhpcy5zcGxpY2VfKCBlT3JnLlN5bSwgZU5ldyApO1xuXG5cdFx0XHQvKiBTZXQgdGhlIHZlcnRleCBhbmQgZmFjZSBpbmZvcm1hdGlvbiAqL1xuXHRcdFx0ZU9yZy5Ec3QgPSBlTmV3Lk9yZztcblx0XHRcdGVOZXcuRHN0LmFuRWRnZSA9IGVOZXcuU3ltO1x0LyogbWF5IGhhdmUgcG9pbnRlZCB0byBlT3JnLT5TeW0gKi9cblx0XHRcdGVOZXcuUmZhY2UgPSBlT3JnLlJmYWNlO1xuXHRcdFx0ZU5ldy53aW5kaW5nID0gZU9yZy53aW5kaW5nO1x0LyogY29weSBvbGQgd2luZGluZyBpbmZvcm1hdGlvbiAqL1xuXHRcdFx0ZU5ldy5TeW0ud2luZGluZyA9IGVPcmcuU3ltLndpbmRpbmc7XG5cblx0XHRcdHJldHVybiBlTmV3O1xuXHRcdH0sXG5cblxuXHRcdC8qIHRlc3NNZXNoQ29ubmVjdCggZU9yZywgZURzdCApIGNyZWF0ZXMgYSBuZXcgZWRnZSBmcm9tIGVPcmctPkRzdFxuXHRcdCogdG8gZURzdC0+T3JnLCBhbmQgcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyBoYWxmLWVkZ2UgZU5ldy5cblx0XHQqIElmIGVPcmctPkxmYWNlID09IGVEc3QtPkxmYWNlLCB0aGlzIHNwbGl0cyBvbmUgbG9vcCBpbnRvIHR3byxcblx0XHQqIGFuZCB0aGUgbmV3bHkgY3JlYXRlZCBsb29wIGlzIGVOZXctPkxmYWNlLiAgT3RoZXJ3aXNlLCB0d28gZGlzam9pbnRcblx0XHQqIGxvb3BzIGFyZSBtZXJnZWQgaW50byBvbmUsIGFuZCB0aGUgbG9vcCBlRHN0LT5MZmFjZSBpcyBkZXN0cm95ZWQuXG5cdFx0KlxuXHRcdCogSWYgKGVPcmcgPT0gZURzdCksIHRoZSBuZXcgZmFjZSB3aWxsIGhhdmUgb25seSB0d28gZWRnZXMuXG5cdFx0KiBJZiAoZU9yZy0+TG5leHQgPT0gZURzdCksIHRoZSBvbGQgZmFjZSBpcyByZWR1Y2VkIHRvIGEgc2luZ2xlIGVkZ2UuXG5cdFx0KiBJZiAoZU9yZy0+TG5leHQtPkxuZXh0ID09IGVEc3QpLCB0aGUgb2xkIGZhY2UgaXMgcmVkdWNlZCB0byB0d28gZWRnZXMuXG5cdFx0Ki9cblxuXHRcdC8vIFRFU1NoYWxmRWRnZSAqdGVzc01lc2hDb25uZWN0KCBURVNTbWVzaCAqbWVzaCwgVEVTU2hhbGZFZGdlICplT3JnLCBURVNTaGFsZkVkZ2UgKmVEc3QgKTtcblx0XHRjb25uZWN0OiBmdW5jdGlvbihlT3JnLCBlRHN0KSB7XG5cdFx0XHR2YXIgam9pbmluZ0xvb3BzID0gZmFsc2U7ICBcblx0XHRcdHZhciBlTmV3ID0gdGhpcy5tYWtlRWRnZV8oIGVPcmcgKTtcblx0XHRcdHZhciBlTmV3U3ltID0gZU5ldy5TeW07XG5cblx0XHRcdGlmKCBlRHN0LkxmYWNlICE9PSBlT3JnLkxmYWNlICkge1xuXHRcdFx0XHQvKiBXZSBhcmUgY29ubmVjdGluZyB0d28gZGlzam9pbnQgbG9vcHMgLS0gZGVzdHJveSBlRHN0LT5MZmFjZSAqL1xuXHRcdFx0XHRqb2luaW5nTG9vcHMgPSB0cnVlO1xuXHRcdFx0XHR0aGlzLmtpbGxGYWNlXyggZURzdC5MZmFjZSwgZU9yZy5MZmFjZSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvKiBDb25uZWN0IHRoZSBuZXcgZWRnZSBhcHByb3ByaWF0ZWx5ICovXG5cdFx0XHR0aGlzLnNwbGljZV8oIGVOZXcsIGVPcmcuTG5leHQgKTtcblx0XHRcdHRoaXMuc3BsaWNlXyggZU5ld1N5bSwgZURzdCApO1xuXG5cdFx0XHQvKiBTZXQgdGhlIHZlcnRleCBhbmQgZmFjZSBpbmZvcm1hdGlvbiAqL1xuXHRcdFx0ZU5ldy5PcmcgPSBlT3JnLkRzdDtcblx0XHRcdGVOZXdTeW0uT3JnID0gZURzdC5Pcmc7XG5cdFx0XHRlTmV3LkxmYWNlID0gZU5ld1N5bS5MZmFjZSA9IGVPcmcuTGZhY2U7XG5cblx0XHRcdC8qIE1ha2Ugc3VyZSB0aGUgb2xkIGZhY2UgcG9pbnRzIHRvIGEgdmFsaWQgaGFsZi1lZGdlICovXG5cdFx0XHRlT3JnLkxmYWNlLmFuRWRnZSA9IGVOZXdTeW07XG5cblx0XHRcdGlmKCAhIGpvaW5pbmdMb29wcyApIHtcblx0XHRcdFx0dmFyIG5ld0ZhY2UgPSBuZXcgVEVTU2ZhY2UoKTtcblx0XHRcdFx0LyogV2Ugc3BsaXQgb25lIGxvb3AgaW50byB0d28gLS0gdGhlIG5ldyBsb29wIGlzIGVOZXctPkxmYWNlICovXG5cdFx0XHRcdHRoaXMubWFrZUZhY2VfKCBuZXdGYWNlLCBlTmV3LCBlT3JnLkxmYWNlICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZU5ldztcblx0XHR9LFxuXG5cdFx0LyogdGVzc01lc2haYXBGYWNlKCBmWmFwICkgZGVzdHJveXMgYSBmYWNlIGFuZCByZW1vdmVzIGl0IGZyb20gdGhlXG5cdFx0KiBnbG9iYWwgZmFjZSBsaXN0LiAgQWxsIGVkZ2VzIG9mIGZaYXAgd2lsbCBoYXZlIGEgTlVMTCBwb2ludGVyIGFzIHRoZWlyXG5cdFx0KiBsZWZ0IGZhY2UuICBBbnkgZWRnZXMgd2hpY2ggYWxzbyBoYXZlIGEgTlVMTCBwb2ludGVyIGFzIHRoZWlyIHJpZ2h0IGZhY2Vcblx0XHQqIGFyZSBkZWxldGVkIGVudGlyZWx5IChhbG9uZyB3aXRoIGFueSBpc29sYXRlZCB2ZXJ0aWNlcyB0aGlzIHByb2R1Y2VzKS5cblx0XHQqIEFuIGVudGlyZSBtZXNoIGNhbiBiZSBkZWxldGVkIGJ5IHphcHBpbmcgaXRzIGZhY2VzLCBvbmUgYXQgYSB0aW1lLFxuXHRcdCogaW4gYW55IG9yZGVyLiAgWmFwcGVkIGZhY2VzIGNhbm5vdCBiZSB1c2VkIGluIGZ1cnRoZXIgbWVzaCBvcGVyYXRpb25zIVxuXHRcdCovXG5cdFx0emFwRmFjZTogZnVuY3Rpb24oIGZaYXAgKVxuXHRcdHtcblx0XHRcdHZhciBlU3RhcnQgPSBmWmFwLmFuRWRnZTtcblx0XHRcdHZhciBlLCBlTmV4dCwgZVN5bTtcblx0XHRcdHZhciBmUHJldiwgZk5leHQ7XG5cblx0XHRcdC8qIHdhbGsgYXJvdW5kIGZhY2UsIGRlbGV0aW5nIGVkZ2VzIHdob3NlIHJpZ2h0IGZhY2UgaXMgYWxzbyBOVUxMICovXG5cdFx0XHRlTmV4dCA9IGVTdGFydC5MbmV4dDtcblx0XHRcdGRvIHtcblx0XHRcdFx0ZSA9IGVOZXh0O1xuXHRcdFx0XHRlTmV4dCA9IGUuTG5leHQ7XG5cblx0XHRcdFx0ZS5MZmFjZSA9IG51bGw7XG5cdFx0XHRcdGlmKCBlLlJmYWNlID09PSBudWxsICkge1xuXHRcdFx0XHRcdC8qIGRlbGV0ZSB0aGUgZWRnZSAtLSBzZWUgVEVTU21lc2hEZWxldGUgYWJvdmUgKi9cblxuXHRcdFx0XHRcdGlmKCBlLk9uZXh0ID09PSBlICkge1xuXHRcdFx0XHRcdFx0dGhpcy5raWxsVmVydGV4XyggZS5PcmcsIG51bGwgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0LyogTWFrZSBzdXJlIHRoYXQgZS0+T3JnIHBvaW50cyB0byBhIHZhbGlkIGhhbGYtZWRnZSAqL1xuXHRcdFx0XHRcdFx0ZS5PcmcuYW5FZGdlID0gZS5PbmV4dDtcblx0XHRcdFx0XHRcdHRoaXMuc3BsaWNlXyggZSwgZS5PcHJldiApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlU3ltID0gZS5TeW07XG5cdFx0XHRcdFx0aWYoIGVTeW0uT25leHQgPT09IGVTeW0gKSB7XG5cdFx0XHRcdFx0XHR0aGlzLmtpbGxWZXJ0ZXhfKCBlU3ltLk9yZywgbnVsbCApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHQvKiBNYWtlIHN1cmUgdGhhdCBlU3ltLT5PcmcgcG9pbnRzIHRvIGEgdmFsaWQgaGFsZi1lZGdlICovXG5cdFx0XHRcdFx0XHRlU3ltLk9yZy5hbkVkZ2UgPSBlU3ltLk9uZXh0O1xuXHRcdFx0XHRcdFx0dGhpcy5zcGxpY2VfKCBlU3ltLCBlU3ltLk9wcmV2ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRoaXMua2lsbEVkZ2VfKCBlICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gd2hpbGUoIGUgIT0gZVN0YXJ0ICk7XG5cblx0XHRcdC8qIGRlbGV0ZSBmcm9tIGNpcmN1bGFyIGRvdWJseS1saW5rZWQgbGlzdCAqL1xuXHRcdFx0ZlByZXYgPSBmWmFwLnByZXY7XG5cdFx0XHRmTmV4dCA9IGZaYXAubmV4dDtcblx0XHRcdGZOZXh0LnByZXYgPSBmUHJldjtcblx0XHRcdGZQcmV2Lm5leHQgPSBmTmV4dDtcblx0XHR9LFxuXG5cdFx0Y291bnRGYWNlVmVydHNfOiBmdW5jdGlvbihmKSB7XG5cdFx0XHR2YXIgZUN1ciA9IGYuYW5FZGdlO1xuXHRcdFx0dmFyIG4gPSAwO1xuXHRcdFx0ZG9cblx0XHRcdHtcblx0XHRcdFx0bisrO1xuXHRcdFx0XHRlQ3VyID0gZUN1ci5MbmV4dDtcblx0XHRcdH1cblx0XHRcdHdoaWxlIChlQ3VyICE9PSBmLmFuRWRnZSk7XG5cdFx0XHRyZXR1cm4gbjtcblx0XHR9LFxuXG5cdFx0Ly9pbnQgdGVzc01lc2hNZXJnZUNvbnZleEZhY2VzKCBURVNTbWVzaCAqbWVzaCwgaW50IG1heFZlcnRzUGVyRmFjZSApXG5cdFx0bWVyZ2VDb252ZXhGYWNlczogZnVuY3Rpb24obWF4VmVydHNQZXJGYWNlKSB7XG5cdFx0XHR2YXIgZjtcblx0XHRcdHZhciBlQ3VyLCBlTmV4dCwgZVN5bTtcblx0XHRcdHZhciB2U3RhcnQ7XG5cdFx0XHR2YXIgY3VyTnYsIHN5bU52O1xuXG5cdFx0XHRmb3IoIGYgPSB0aGlzLmZIZWFkLm5leHQ7IGYgIT09IHRoaXMuZkhlYWQ7IGYgPSBmLm5leHQgKVxuXHRcdFx0e1xuXHRcdFx0XHQvLyBTa2lwIGZhY2VzIHdoaWNoIGFyZSBvdXRzaWRlIHRoZSByZXN1bHQuXG5cdFx0XHRcdGlmKCAhZi5pbnNpZGUgKVxuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXG5cdFx0XHRcdGVDdXIgPSBmLmFuRWRnZTtcblx0XHRcdFx0dlN0YXJ0ID0gZUN1ci5Pcmc7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdHdoaWxlICh0cnVlKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0ZU5leHQgPSBlQ3VyLkxuZXh0O1xuXHRcdFx0XHRcdGVTeW0gPSBlQ3VyLlN5bTtcblxuXHRcdFx0XHRcdC8vIFRyeSB0byBtZXJnZSBpZiB0aGUgbmVpZ2hib3VyIGZhY2UgaXMgdmFsaWQuXG5cdFx0XHRcdFx0aWYoIGVTeW0gJiYgZVN5bS5MZmFjZSAmJiBlU3ltLkxmYWNlLmluc2lkZSApXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0Ly8gVHJ5IHRvIG1lcmdlIHRoZSBuZWlnaGJvdXIgZmFjZXMgaWYgdGhlIHJlc3VsdGluZyBwb2x5Z29uc1xuXHRcdFx0XHRcdFx0Ly8gZG9lcyBub3QgZXhjZWVkIG1heGltdW0gbnVtYmVyIG9mIHZlcnRpY2VzLlxuXHRcdFx0XHRcdFx0Y3VyTnYgPSB0aGlzLmNvdW50RmFjZVZlcnRzXyggZiApO1xuXHRcdFx0XHRcdFx0c3ltTnYgPSB0aGlzLmNvdW50RmFjZVZlcnRzXyggZVN5bS5MZmFjZSApO1xuXHRcdFx0XHRcdFx0aWYoIChjdXJOditzeW1Odi0yKSA8PSBtYXhWZXJ0c1BlckZhY2UgKVxuXHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHQvLyBNZXJnZSBpZiB0aGUgcmVzdWx0aW5nIHBvbHkgaXMgY29udmV4LlxuXHRcdFx0XHRcdFx0XHRpZiggR2VvbS52ZXJ0Q0NXKCBlQ3VyLkxwcmV2Lk9yZywgZUN1ci5PcmcsIGVTeW0uTG5leHQuTG5leHQuT3JnICkgJiZcblx0XHRcdFx0XHRcdFx0XHRHZW9tLnZlcnRDQ1coIGVTeW0uTHByZXYuT3JnLCBlU3ltLk9yZywgZUN1ci5MbmV4dC5MbmV4dC5PcmcgKSApXG5cdFx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0XHRlTmV4dCA9IGVTeW0uTG5leHQ7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5kZWxldGUoIGVTeW0gKTtcblx0XHRcdFx0XHRcdFx0XHRlQ3VyID0gbnVsbDtcblx0XHRcdFx0XHRcdFx0XHRlU3ltID0gbnVsbDtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcblx0XHRcdFx0XHRpZiggZUN1ciAmJiBlQ3VyLkxuZXh0Lk9yZyA9PT0gdlN0YXJ0IClcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0Ly8gQ29udGludWUgdG8gbmV4dCBlZGdlLlxuXHRcdFx0XHRcdGVDdXIgPSBlTmV4dDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0LyogdGVzc01lc2hDaGVja01lc2goIG1lc2ggKSBjaGVja3MgYSBtZXNoIGZvciBzZWxmLWNvbnNpc3RlbmN5LlxuXHRcdCovXG5cdFx0Y2hlY2s6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGZIZWFkID0gdGhpcy5mSGVhZDtcblx0XHRcdHZhciB2SGVhZCA9IHRoaXMudkhlYWQ7XG5cdFx0XHR2YXIgZUhlYWQgPSB0aGlzLmVIZWFkO1xuXHRcdFx0dmFyIGYsIGZQcmV2LCB2LCB2UHJldiwgZSwgZVByZXY7XG5cblx0XHRcdGZQcmV2ID0gZkhlYWQ7XG5cdFx0XHRmb3IoIGZQcmV2ID0gZkhlYWQgOyAoZiA9IGZQcmV2Lm5leHQpICE9PSBmSGVhZDsgZlByZXYgPSBmKSB7XG5cdFx0XHRcdGFzc2VydCggZi5wcmV2ID09PSBmUHJldiApO1xuXHRcdFx0XHRlID0gZi5hbkVkZ2U7XG5cdFx0XHRcdGRvIHtcblx0XHRcdFx0XHRhc3NlcnQoIGUuU3ltICE9PSBlICk7XG5cdFx0XHRcdFx0YXNzZXJ0KCBlLlN5bS5TeW0gPT09IGUgKTtcblx0XHRcdFx0XHRhc3NlcnQoIGUuTG5leHQuT25leHQuU3ltID09PSBlICk7XG5cdFx0XHRcdFx0YXNzZXJ0KCBlLk9uZXh0LlN5bS5MbmV4dCA9PT0gZSApO1xuXHRcdFx0XHRcdGFzc2VydCggZS5MZmFjZSA9PT0gZiApO1xuXHRcdFx0XHRcdGUgPSBlLkxuZXh0O1xuXHRcdFx0XHR9IHdoaWxlKCBlICE9PSBmLmFuRWRnZSApO1xuXHRcdFx0fVxuXHRcdFx0YXNzZXJ0KCBmLnByZXYgPT09IGZQcmV2ICYmIGYuYW5FZGdlID09PSBudWxsICk7XG5cblx0XHRcdHZQcmV2ID0gdkhlYWQ7XG5cdFx0XHRmb3IoIHZQcmV2ID0gdkhlYWQgOyAodiA9IHZQcmV2Lm5leHQpICE9PSB2SGVhZDsgdlByZXYgPSB2KSB7XG5cdFx0XHRcdGFzc2VydCggdi5wcmV2ID09PSB2UHJldiApO1xuXHRcdFx0XHRlID0gdi5hbkVkZ2U7XG5cdFx0XHRcdGRvIHtcblx0XHRcdFx0XHRhc3NlcnQoIGUuU3ltICE9PSBlICk7XG5cdFx0XHRcdFx0YXNzZXJ0KCBlLlN5bS5TeW0gPT09IGUgKTtcblx0XHRcdFx0XHRhc3NlcnQoIGUuTG5leHQuT25leHQuU3ltID09PSBlICk7XG5cdFx0XHRcdFx0YXNzZXJ0KCBlLk9uZXh0LlN5bS5MbmV4dCA9PT0gZSApO1xuXHRcdFx0XHRcdGFzc2VydCggZS5PcmcgPT09IHYgKTtcblx0XHRcdFx0XHRlID0gZS5PbmV4dDtcblx0XHRcdFx0fSB3aGlsZSggZSAhPT0gdi5hbkVkZ2UgKTtcblx0XHRcdH1cblx0XHRcdGFzc2VydCggdi5wcmV2ID09PSB2UHJldiAmJiB2LmFuRWRnZSA9PT0gbnVsbCApO1xuXG5cdFx0XHRlUHJldiA9IGVIZWFkO1xuXHRcdFx0Zm9yKCBlUHJldiA9IGVIZWFkIDsgKGUgPSBlUHJldi5uZXh0KSAhPT0gZUhlYWQ7IGVQcmV2ID0gZSkge1xuXHRcdFx0XHRhc3NlcnQoIGUuU3ltLm5leHQgPT09IGVQcmV2LlN5bSApO1xuXHRcdFx0XHRhc3NlcnQoIGUuU3ltICE9PSBlICk7XG5cdFx0XHRcdGFzc2VydCggZS5TeW0uU3ltID09PSBlICk7XG5cdFx0XHRcdGFzc2VydCggZS5PcmcgIT09IG51bGwgKTtcblx0XHRcdFx0YXNzZXJ0KCBlLkRzdCAhPT0gbnVsbCApO1xuXHRcdFx0XHRhc3NlcnQoIGUuTG5leHQuT25leHQuU3ltID09PSBlICk7XG5cdFx0XHRcdGFzc2VydCggZS5PbmV4dC5TeW0uTG5leHQgPT09IGUgKTtcblx0XHRcdH1cblx0XHRcdGFzc2VydCggZS5TeW0ubmV4dCA9PT0gZVByZXYuU3ltXG5cdFx0XHRcdCYmIGUuU3ltID09PSB0aGlzLmVIZWFkU3ltXG5cdFx0XHRcdCYmIGUuU3ltLlN5bSA9PT0gZVxuXHRcdFx0XHQmJiBlLk9yZyA9PT0gbnVsbCAmJiBlLkRzdCA9PT0gbnVsbFxuXHRcdFx0XHQmJiBlLkxmYWNlID09PSBudWxsICYmIGUuUmZhY2UgPT09IG51bGwgKTtcblx0XHR9XG5cblx0fTtcblxuXHR2YXIgR2VvbSA9IHt9O1xuXG5cdEdlb20udmVydEVxID0gZnVuY3Rpb24odSx2KSB7XG5cdFx0cmV0dXJuICh1LnMgPT09IHYucyAmJiB1LnQgPT09IHYudCk7XG5cdH07XG5cblx0LyogUmV0dXJucyBUUlVFIGlmIHUgaXMgbGV4aWNvZ3JhcGhpY2FsbHkgPD0gdi4gKi9cblx0R2VvbS52ZXJ0TGVxID0gZnVuY3Rpb24odSx2KSB7XG5cdFx0cmV0dXJuICgodS5zIDwgdi5zKSB8fCAodS5zID09PSB2LnMgJiYgdS50IDw9IHYudCkpO1xuXHR9O1xuXG5cdC8qIFZlcnNpb25zIG9mIFZlcnRMZXEsIEVkZ2VTaWduLCBFZGdlRXZhbCB3aXRoIHMgYW5kIHQgdHJhbnNwb3NlZC4gKi9cblx0R2VvbS50cmFuc0xlcSA9IGZ1bmN0aW9uKHUsdikge1xuXHRcdHJldHVybiAoKHUudCA8IHYudCkgfHwgKHUudCA9PT0gdi50ICYmIHUucyA8PSB2LnMpKTtcblx0fTtcblxuXHRHZW9tLmVkZ2VHb2VzTGVmdCA9IGZ1bmN0aW9uKGUpIHtcblx0XHRyZXR1cm4gR2VvbS52ZXJ0TGVxKCBlLkRzdCwgZS5PcmcgKTtcblx0fTtcblxuXHRHZW9tLmVkZ2VHb2VzUmlnaHQgPSBmdW5jdGlvbihlKSB7XG5cdFx0cmV0dXJuIEdlb20udmVydExlcSggZS5PcmcsIGUuRHN0ICk7XG5cdH07XG5cblx0R2VvbS52ZXJ0TDFkaXN0ID0gZnVuY3Rpb24odSx2KSB7XG5cdFx0cmV0dXJuIChNYXRoLmFicyh1LnMgLSB2LnMpICsgTWF0aC5hYnModS50IC0gdi50KSk7XG5cdH07XG5cblx0Ly9URVNTcmVhbCB0ZXNlZGdlRXZhbCggVEVTU3ZlcnRleCAqdSwgVEVTU3ZlcnRleCAqdiwgVEVTU3ZlcnRleCAqdyApXG5cdEdlb20uZWRnZUV2YWwgPSBmdW5jdGlvbiggdSwgdiwgdyApIHtcblx0XHQvKiBHaXZlbiB0aHJlZSB2ZXJ0aWNlcyB1LHYsdyBzdWNoIHRoYXQgVmVydExlcSh1LHYpICYmIFZlcnRMZXEodix3KSxcblx0XHQqIGV2YWx1YXRlcyB0aGUgdC1jb29yZCBvZiB0aGUgZWRnZSB1dyBhdCB0aGUgcy1jb29yZCBvZiB0aGUgdmVydGV4IHYuXG5cdFx0KiBSZXR1cm5zIHYtPnQgLSAodXcpKHYtPnMpLCBpZS4gdGhlIHNpZ25lZCBkaXN0YW5jZSBmcm9tIHV3IHRvIHYuXG5cdFx0KiBJZiB1dyBpcyB2ZXJ0aWNhbCAoYW5kIHRodXMgcGFzc2VzIHRocnUgdiksIHRoZSByZXN1bHQgaXMgemVyby5cblx0XHQqXG5cdFx0KiBUaGUgY2FsY3VsYXRpb24gaXMgZXh0cmVtZWx5IGFjY3VyYXRlIGFuZCBzdGFibGUsIGV2ZW4gd2hlbiB2XG5cdFx0KiBpcyB2ZXJ5IGNsb3NlIHRvIHUgb3Igdy4gIEluIHBhcnRpY3VsYXIgaWYgd2Ugc2V0IHYtPnQgPSAwIGFuZFxuXHRcdCogbGV0IHIgYmUgdGhlIG5lZ2F0ZWQgcmVzdWx0ICh0aGlzIGV2YWx1YXRlcyAodXcpKHYtPnMpKSwgdGhlblxuXHRcdCogciBpcyBndWFyYW50ZWVkIHRvIHNhdGlzZnkgTUlOKHUtPnQsdy0+dCkgPD0gciA8PSBNQVgodS0+dCx3LT50KS5cblx0XHQqL1xuXHRcdGFzc2VydCggR2VvbS52ZXJ0TGVxKCB1LCB2ICkgJiYgR2VvbS52ZXJ0TGVxKCB2LCB3ICkpO1xuXG5cdFx0dmFyIGdhcEwgPSB2LnMgLSB1LnM7XG5cdFx0dmFyIGdhcFIgPSB3LnMgLSB2LnM7XG5cblx0XHRpZiggZ2FwTCArIGdhcFIgPiAwLjAgKSB7XG5cdFx0XHRpZiggZ2FwTCA8IGdhcFIgKSB7XG5cdFx0XHRcdHJldHVybiAodi50IC0gdS50KSArICh1LnQgLSB3LnQpICogKGdhcEwgLyAoZ2FwTCArIGdhcFIpKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiAodi50IC0gdy50KSArICh3LnQgLSB1LnQpICogKGdhcFIgLyAoZ2FwTCArIGdhcFIpKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0LyogdmVydGljYWwgbGluZSAqL1xuXHRcdHJldHVybiAwLjA7XG5cdH07XG5cblx0Ly9URVNTcmVhbCB0ZXNlZGdlU2lnbiggVEVTU3ZlcnRleCAqdSwgVEVTU3ZlcnRleCAqdiwgVEVTU3ZlcnRleCAqdyApXG5cdEdlb20uZWRnZVNpZ24gPSBmdW5jdGlvbiggdSwgdiwgdyApIHtcblx0XHQvKiBSZXR1cm5zIGEgbnVtYmVyIHdob3NlIHNpZ24gbWF0Y2hlcyBFZGdlRXZhbCh1LHYsdykgYnV0IHdoaWNoXG5cdFx0KiBpcyBjaGVhcGVyIHRvIGV2YWx1YXRlLiAgUmV0dXJucyA+IDAsID09IDAgLCBvciA8IDBcblx0XHQqIGFzIHYgaXMgYWJvdmUsIG9uLCBvciBiZWxvdyB0aGUgZWRnZSB1dy5cblx0XHQqL1xuXHRcdGFzc2VydCggR2VvbS52ZXJ0TGVxKCB1LCB2ICkgJiYgR2VvbS52ZXJ0TGVxKCB2LCB3ICkpO1xuXG5cdFx0dmFyIGdhcEwgPSB2LnMgLSB1LnM7XG5cdFx0dmFyIGdhcFIgPSB3LnMgLSB2LnM7XG5cblx0XHRpZiggZ2FwTCArIGdhcFIgPiAwLjAgKSB7XG5cdFx0XHRyZXR1cm4gKHYudCAtIHcudCkgKiBnYXBMICsgKHYudCAtIHUudCkgKiBnYXBSO1xuXHRcdH1cblx0XHQvKiB2ZXJ0aWNhbCBsaW5lICovXG5cdFx0cmV0dXJuIDAuMDtcblx0fTtcblxuXG5cdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXHQqIERlZmluZSB2ZXJzaW9ucyBvZiBFZGdlU2lnbiwgRWRnZUV2YWwgd2l0aCBzIGFuZCB0IHRyYW5zcG9zZWQuXG5cdCovXG5cblx0Ly9URVNTcmVhbCB0ZXN0cmFuc0V2YWwoIFRFU1N2ZXJ0ZXggKnUsIFRFU1N2ZXJ0ZXggKnYsIFRFU1N2ZXJ0ZXggKncgKVxuXHRHZW9tLnRyYW5zRXZhbCA9IGZ1bmN0aW9uKCB1LCB2LCB3ICkge1xuXHRcdC8qIEdpdmVuIHRocmVlIHZlcnRpY2VzIHUsdix3IHN1Y2ggdGhhdCBUcmFuc0xlcSh1LHYpICYmIFRyYW5zTGVxKHYsdyksXG5cdFx0KiBldmFsdWF0ZXMgdGhlIHQtY29vcmQgb2YgdGhlIGVkZ2UgdXcgYXQgdGhlIHMtY29vcmQgb2YgdGhlIHZlcnRleCB2LlxuXHRcdCogUmV0dXJucyB2LT5zIC0gKHV3KSh2LT50KSwgaWUuIHRoZSBzaWduZWQgZGlzdGFuY2UgZnJvbSB1dyB0byB2LlxuXHRcdCogSWYgdXcgaXMgdmVydGljYWwgKGFuZCB0aHVzIHBhc3NlcyB0aHJ1IHYpLCB0aGUgcmVzdWx0IGlzIHplcm8uXG5cdFx0KlxuXHRcdCogVGhlIGNhbGN1bGF0aW9uIGlzIGV4dHJlbWVseSBhY2N1cmF0ZSBhbmQgc3RhYmxlLCBldmVuIHdoZW4gdlxuXHRcdCogaXMgdmVyeSBjbG9zZSB0byB1IG9yIHcuICBJbiBwYXJ0aWN1bGFyIGlmIHdlIHNldCB2LT5zID0gMCBhbmRcblx0XHQqIGxldCByIGJlIHRoZSBuZWdhdGVkIHJlc3VsdCAodGhpcyBldmFsdWF0ZXMgKHV3KSh2LT50KSksIHRoZW5cblx0XHQqIHIgaXMgZ3VhcmFudGVlZCB0byBzYXRpc2Z5IE1JTih1LT5zLHctPnMpIDw9IHIgPD0gTUFYKHUtPnMsdy0+cykuXG5cdFx0Ki9cblx0XHRhc3NlcnQoIEdlb20udHJhbnNMZXEoIHUsIHYgKSAmJiBHZW9tLnRyYW5zTGVxKCB2LCB3ICkpO1xuXG5cdFx0dmFyIGdhcEwgPSB2LnQgLSB1LnQ7XG5cdFx0dmFyIGdhcFIgPSB3LnQgLSB2LnQ7XG5cblx0XHRpZiggZ2FwTCArIGdhcFIgPiAwLjAgKSB7XG5cdFx0XHRpZiggZ2FwTCA8IGdhcFIgKSB7XG5cdFx0XHRcdHJldHVybiAodi5zIC0gdS5zKSArICh1LnMgLSB3LnMpICogKGdhcEwgLyAoZ2FwTCArIGdhcFIpKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiAodi5zIC0gdy5zKSArICh3LnMgLSB1LnMpICogKGdhcFIgLyAoZ2FwTCArIGdhcFIpKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0LyogdmVydGljYWwgbGluZSAqL1xuXHRcdHJldHVybiAwLjA7XG5cdH07XG5cblx0Ly9URVNTcmVhbCB0ZXN0cmFuc1NpZ24oIFRFU1N2ZXJ0ZXggKnUsIFRFU1N2ZXJ0ZXggKnYsIFRFU1N2ZXJ0ZXggKncgKVxuXHRHZW9tLnRyYW5zU2lnbiA9IGZ1bmN0aW9uKCB1LCB2LCB3ICkge1xuXHRcdC8qIFJldHVybnMgYSBudW1iZXIgd2hvc2Ugc2lnbiBtYXRjaGVzIFRyYW5zRXZhbCh1LHYsdykgYnV0IHdoaWNoXG5cdFx0KiBpcyBjaGVhcGVyIHRvIGV2YWx1YXRlLiAgUmV0dXJucyA+IDAsID09IDAgLCBvciA8IDBcblx0XHQqIGFzIHYgaXMgYWJvdmUsIG9uLCBvciBiZWxvdyB0aGUgZWRnZSB1dy5cblx0XHQqL1xuXHRcdGFzc2VydCggR2VvbS50cmFuc0xlcSggdSwgdiApICYmIEdlb20udHJhbnNMZXEoIHYsIHcgKSk7XG5cblx0XHR2YXIgZ2FwTCA9IHYudCAtIHUudDtcblx0XHR2YXIgZ2FwUiA9IHcudCAtIHYudDtcblxuXHRcdGlmKCBnYXBMICsgZ2FwUiA+IDAuMCApIHtcblx0XHRcdHJldHVybiAodi5zIC0gdy5zKSAqIGdhcEwgKyAodi5zIC0gdS5zKSAqIGdhcFI7XG5cdFx0fVxuXHRcdC8qIHZlcnRpY2FsIGxpbmUgKi9cblx0XHRyZXR1cm4gMC4wO1xuXHR9O1xuXG5cblx0Ly9pbnQgdGVzdmVydENDVyggVEVTU3ZlcnRleCAqdSwgVEVTU3ZlcnRleCAqdiwgVEVTU3ZlcnRleCAqdyApXG5cdEdlb20udmVydENDVyA9IGZ1bmN0aW9uKCB1LCB2LCB3ICkge1xuXHRcdC8qIEZvciBhbG1vc3QtZGVnZW5lcmF0ZSBzaXR1YXRpb25zLCB0aGUgcmVzdWx0cyBhcmUgbm90IHJlbGlhYmxlLlxuXHRcdCogVW5sZXNzIHRoZSBmbG9hdGluZy1wb2ludCBhcml0aG1ldGljIGNhbiBiZSBwZXJmb3JtZWQgd2l0aG91dFxuXHRcdCogcm91bmRpbmcgZXJyb3JzLCAqYW55KiBpbXBsZW1lbnRhdGlvbiB3aWxsIGdpdmUgaW5jb3JyZWN0IHJlc3VsdHNcblx0XHQqIG9uIHNvbWUgZGVnZW5lcmF0ZSBpbnB1dHMsIHNvIHRoZSBjbGllbnQgbXVzdCBoYXZlIHNvbWUgd2F5IHRvXG5cdFx0KiBoYW5kbGUgdGhpcyBzaXR1YXRpb24uXG5cdFx0Ki9cblx0XHRyZXR1cm4gKHUucyoodi50IC0gdy50KSArIHYucyoody50IC0gdS50KSArIHcucyoodS50IC0gdi50KSkgPj0gMC4wO1xuXHR9O1xuXG5cdC8qIEdpdmVuIHBhcmFtZXRlcnMgYSx4LGIseSByZXR1cm5zIHRoZSB2YWx1ZSAoYip4K2EqeSkvKGErYiksXG5cdCogb3IgKHgreSkvMiBpZiBhPT1iPT0wLiAgSXQgcmVxdWlyZXMgdGhhdCBhLGIgPj0gMCwgYW5kIGVuZm9yY2VzXG5cdCogdGhpcyBpbiB0aGUgcmFyZSBjYXNlIHRoYXQgb25lIGFyZ3VtZW50IGlzIHNsaWdodGx5IG5lZ2F0aXZlLlxuXHQqIFRoZSBpbXBsZW1lbnRhdGlvbiBpcyBleHRyZW1lbHkgc3RhYmxlIG51bWVyaWNhbGx5LlxuXHQqIEluIHBhcnRpY3VsYXIgaXQgZ3VhcmFudGVlcyB0aGF0IHRoZSByZXN1bHQgciBzYXRpc2ZpZXNcblx0KiBNSU4oeCx5KSA8PSByIDw9IE1BWCh4LHkpLCBhbmQgdGhlIHJlc3VsdHMgYXJlIHZlcnkgYWNjdXJhdGVcblx0KiBldmVuIHdoZW4gYSBhbmQgYiBkaWZmZXIgZ3JlYXRseSBpbiBtYWduaXR1ZGUuXG5cdCovXG5cdEdlb20uaW50ZXJwb2xhdGUgPSBmdW5jdGlvbihhLHgsYix5KSB7XG5cdFx0cmV0dXJuIChhID0gKGEgPCAwKSA/IDAgOiBhLCBiID0gKGIgPCAwKSA/IDAgOiBiLCAoKGEgPD0gYikgPyAoKGIgPT0gMCkgPyAoKHgreSkgLyAyKSA6ICh4ICsgKHkteCkgKiAoYS8oYStiKSkpKSA6ICh5ICsgKHgteSkgKiAoYi8oYStiKSkpKSk7XG5cdH07XG5cblx0Lypcblx0I2lmbmRlZiBGT1JfVFJJVEVfVEVTVF9QUk9HUkFNXG5cdCNkZWZpbmUgSW50ZXJwb2xhdGUoYSx4LGIseSlcdFJlYWxJbnRlcnBvbGF0ZShhLHgsYix5KVxuXHQjZWxzZVxuXG5cdC8vIENsYWltOiB0aGUgT05MWSBwcm9wZXJ0eSB0aGUgc3dlZXAgYWxnb3JpdGhtIHJlbGllcyBvbiBpcyB0aGF0XG5cdC8vIE1JTih4LHkpIDw9IHIgPD0gTUFYKHgseSkuICBUaGlzIGlzIGEgbmFzdHkgd2F5IHRvIHRlc3QgdGhhdC5cblx0I2luY2x1ZGUgPHN0ZGxpYi5oPlxuXHRleHRlcm4gaW50IFJhbmRvbUludGVycG9sYXRlO1xuXG5cdGRvdWJsZSBJbnRlcnBvbGF0ZSggZG91YmxlIGEsIGRvdWJsZSB4LCBkb3VibGUgYiwgZG91YmxlIHkpXG5cdHtcblx0XHRwcmludGYoXCIqKioqKioqKioqKioqKioqKioqKiolZFxcblwiLFJhbmRvbUludGVycG9sYXRlKTtcblx0XHRpZiggUmFuZG9tSW50ZXJwb2xhdGUgKSB7XG5cdFx0XHRhID0gMS4yICogZHJhbmQ0OCgpIC0gMC4xO1xuXHRcdFx0YSA9IChhIDwgMCkgPyAwIDogKChhID4gMSkgPyAxIDogYSk7XG5cdFx0XHRiID0gMS4wIC0gYTtcblx0XHR9XG5cdFx0cmV0dXJuIFJlYWxJbnRlcnBvbGF0ZShhLHgsYix5KTtcblx0fVxuXHQjZW5kaWYqL1xuXG5cdEdlb20uaW50ZXJzZWN0ID0gZnVuY3Rpb24oIG8xLCBkMSwgbzIsIGQyLCB2ICkge1xuXHRcdC8qIEdpdmVuIGVkZ2VzIChvMSxkMSkgYW5kIChvMixkMiksIGNvbXB1dGUgdGhlaXIgcG9pbnQgb2YgaW50ZXJzZWN0aW9uLlxuXHRcdCogVGhlIGNvbXB1dGVkIHBvaW50IGlzIGd1YXJhbnRlZWQgdG8gbGllIGluIHRoZSBpbnRlcnNlY3Rpb24gb2YgdGhlXG5cdFx0KiBib3VuZGluZyByZWN0YW5nbGVzIGRlZmluZWQgYnkgZWFjaCBlZGdlLlxuXHRcdCovXG5cdFx0dmFyIHoxLCB6Mjtcblx0XHR2YXIgdDtcblxuXHRcdC8qIFRoaXMgaXMgY2VydGFpbmx5IG5vdCB0aGUgbW9zdCBlZmZpY2llbnQgd2F5IHRvIGZpbmQgdGhlIGludGVyc2VjdGlvblxuXHRcdCogb2YgdHdvIGxpbmUgc2VnbWVudHMsIGJ1dCBpdCBpcyB2ZXJ5IG51bWVyaWNhbGx5IHN0YWJsZS5cblx0XHQqXG5cdFx0KiBTdHJhdGVneTogZmluZCB0aGUgdHdvIG1pZGRsZSB2ZXJ0aWNlcyBpbiB0aGUgVmVydExlcSBvcmRlcmluZyxcblx0XHQqIGFuZCBpbnRlcnBvbGF0ZSB0aGUgaW50ZXJzZWN0aW9uIHMtdmFsdWUgZnJvbSB0aGVzZS4gIFRoZW4gcmVwZWF0XG5cdFx0KiB1c2luZyB0aGUgVHJhbnNMZXEgb3JkZXJpbmcgdG8gZmluZCB0aGUgaW50ZXJzZWN0aW9uIHQtdmFsdWUuXG5cdFx0Ki9cblxuXHRcdGlmKCAhIEdlb20udmVydExlcSggbzEsIGQxICkpIHsgdCA9IG8xOyBvMSA9IGQxOyBkMSA9IHQ7IH0gLy9zd2FwKCBvMSwgZDEgKTsgfVxuXHRcdGlmKCAhIEdlb20udmVydExlcSggbzIsIGQyICkpIHsgdCA9IG8yOyBvMiA9IGQyOyBkMiA9IHQ7IH0gLy9zd2FwKCBvMiwgZDIgKTsgfVxuXHRcdGlmKCAhIEdlb20udmVydExlcSggbzEsIG8yICkpIHsgdCA9IG8xOyBvMSA9IG8yOyBvMiA9IHQ7IHQgPSBkMTsgZDEgPSBkMjsgZDIgPSB0OyB9Ly9zd2FwKCBvMSwgbzIgKTsgc3dhcCggZDEsIGQyICk7IH1cblxuXHRcdGlmKCAhIEdlb20udmVydExlcSggbzIsIGQxICkpIHtcblx0XHRcdC8qIFRlY2huaWNhbGx5LCBubyBpbnRlcnNlY3Rpb24gLS0gZG8gb3VyIGJlc3QgKi9cblx0XHRcdHYucyA9IChvMi5zICsgZDEucykgLyAyO1xuXHRcdH0gZWxzZSBpZiggR2VvbS52ZXJ0TGVxKCBkMSwgZDIgKSkge1xuXHRcdFx0LyogSW50ZXJwb2xhdGUgYmV0d2VlbiBvMiBhbmQgZDEgKi9cblx0XHRcdHoxID0gR2VvbS5lZGdlRXZhbCggbzEsIG8yLCBkMSApO1xuXHRcdFx0ejIgPSBHZW9tLmVkZ2VFdmFsKCBvMiwgZDEsIGQyICk7XG5cdFx0XHRpZiggejErejIgPCAwICkgeyB6MSA9IC16MTsgejIgPSAtejI7IH1cblx0XHRcdHYucyA9IEdlb20uaW50ZXJwb2xhdGUoIHoxLCBvMi5zLCB6MiwgZDEucyApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvKiBJbnRlcnBvbGF0ZSBiZXR3ZWVuIG8yIGFuZCBkMiAqL1xuXHRcdFx0ejEgPSBHZW9tLmVkZ2VTaWduKCBvMSwgbzIsIGQxICk7XG5cdFx0XHR6MiA9IC1HZW9tLmVkZ2VTaWduKCBvMSwgZDIsIGQxICk7XG5cdFx0XHRpZiggejErejIgPCAwICkgeyB6MSA9IC16MTsgejIgPSAtejI7IH1cblx0XHRcdHYucyA9IEdlb20uaW50ZXJwb2xhdGUoIHoxLCBvMi5zLCB6MiwgZDIucyApO1xuXHRcdH1cblxuXHRcdC8qIE5vdyByZXBlYXQgdGhlIHByb2Nlc3MgZm9yIHQgKi9cblxuXHRcdGlmKCAhIEdlb20udHJhbnNMZXEoIG8xLCBkMSApKSB7IHQgPSBvMTsgbzEgPSBkMTsgZDEgPSB0OyB9IC8vc3dhcCggbzEsIGQxICk7IH1cblx0XHRpZiggISBHZW9tLnRyYW5zTGVxKCBvMiwgZDIgKSkgeyB0ID0gbzI7IG8yID0gZDI7IGQyID0gdDsgfSAvL3N3YXAoIG8yLCBkMiApOyB9XG5cdFx0aWYoICEgR2VvbS50cmFuc0xlcSggbzEsIG8yICkpIHsgdCA9IG8xOyBvMSA9IG8yOyBvMiA9IHQ7IHQgPSBkMTsgZDEgPSBkMjsgZDIgPSB0OyB9IC8vc3dhcCggbzEsIG8yICk7IHN3YXAoIGQxLCBkMiApOyB9XG5cblx0XHRpZiggISBHZW9tLnRyYW5zTGVxKCBvMiwgZDEgKSkge1xuXHRcdFx0LyogVGVjaG5pY2FsbHksIG5vIGludGVyc2VjdGlvbiAtLSBkbyBvdXIgYmVzdCAqL1xuXHRcdFx0di50ID0gKG8yLnQgKyBkMS50KSAvIDI7XG5cdFx0fSBlbHNlIGlmKCBHZW9tLnRyYW5zTGVxKCBkMSwgZDIgKSkge1xuXHRcdFx0LyogSW50ZXJwb2xhdGUgYmV0d2VlbiBvMiBhbmQgZDEgKi9cblx0XHRcdHoxID0gR2VvbS50cmFuc0V2YWwoIG8xLCBvMiwgZDEgKTtcblx0XHRcdHoyID0gR2VvbS50cmFuc0V2YWwoIG8yLCBkMSwgZDIgKTtcblx0XHRcdGlmKCB6MSt6MiA8IDAgKSB7IHoxID0gLXoxOyB6MiA9IC16MjsgfVxuXHRcdFx0di50ID0gR2VvbS5pbnRlcnBvbGF0ZSggejEsIG8yLnQsIHoyLCBkMS50ICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8qIEludGVycG9sYXRlIGJldHdlZW4gbzIgYW5kIGQyICovXG5cdFx0XHR6MSA9IEdlb20udHJhbnNTaWduKCBvMSwgbzIsIGQxICk7XG5cdFx0XHR6MiA9IC1HZW9tLnRyYW5zU2lnbiggbzEsIGQyLCBkMSApO1xuXHRcdFx0aWYoIHoxK3oyIDwgMCApIHsgejEgPSAtejE7IHoyID0gLXoyOyB9XG5cdFx0XHR2LnQgPSBHZW9tLmludGVycG9sYXRlKCB6MSwgbzIudCwgejIsIGQyLnQgKTtcblx0XHR9XG5cdH07XG5cblxuXG5cdGZ1bmN0aW9uIERpY3ROb2RlKCkge1xuXHRcdHRoaXMua2V5ID0gbnVsbDtcblx0XHR0aGlzLm5leHQgPSBudWxsO1xuXHRcdHRoaXMucHJldiA9IG51bGw7XG5cdH07XG5cblx0ZnVuY3Rpb24gRGljdChmcmFtZSwgbGVxKSB7XG5cdFx0dGhpcy5oZWFkID0gbmV3IERpY3ROb2RlKCk7XG5cdFx0dGhpcy5oZWFkLm5leHQgPSB0aGlzLmhlYWQ7XG5cdFx0dGhpcy5oZWFkLnByZXYgPSB0aGlzLmhlYWQ7XG5cdFx0dGhpcy5mcmFtZSA9IGZyYW1lO1xuXHRcdHRoaXMubGVxID0gbGVxO1xuXHR9O1xuXG5cdERpY3QucHJvdG90eXBlID0ge1xuXHRcdG1pbjogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5oZWFkLm5leHQ7XG5cdFx0fSxcblxuXHRcdG1heDogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5oZWFkLnByZXY7XG5cdFx0fSxcblxuXHRcdGluc2VydDogZnVuY3Rpb24oaykge1xuXHRcdFx0cmV0dXJuIHRoaXMuaW5zZXJ0QmVmb3JlKHRoaXMuaGVhZCwgayk7XG5cdFx0fSxcblxuXHRcdHNlYXJjaDogZnVuY3Rpb24oa2V5KSB7XG5cdFx0XHQvKiBTZWFyY2ggcmV0dXJucyB0aGUgbm9kZSB3aXRoIHRoZSBzbWFsbGVzdCBrZXkgZ3JlYXRlciB0aGFuIG9yIGVxdWFsXG5cdFx0XHQqIHRvIHRoZSBnaXZlbiBrZXkuICBJZiB0aGVyZSBpcyBubyBzdWNoIGtleSwgcmV0dXJucyBhIG5vZGUgd2hvc2Vcblx0XHRcdCoga2V5IGlzIE5VTEwuICBTaW1pbGFybHksIFN1Y2MoTWF4KGQpKSBoYXMgYSBOVUxMIGtleSwgZXRjLlxuXHRcdFx0Ki9cblx0XHRcdHZhciBub2RlID0gdGhpcy5oZWFkO1xuXHRcdFx0ZG8ge1xuXHRcdFx0XHRub2RlID0gbm9kZS5uZXh0O1xuXHRcdFx0fSB3aGlsZSggbm9kZS5rZXkgIT09IG51bGwgJiYgISB0aGlzLmxlcSh0aGlzLmZyYW1lLCBrZXksIG5vZGUua2V5KSk7XG5cblx0XHRcdHJldHVybiBub2RlO1xuXHRcdH0sXG5cblx0XHRpbnNlcnRCZWZvcmU6IGZ1bmN0aW9uKG5vZGUsIGtleSkge1xuXHRcdFx0ZG8ge1xuXHRcdFx0XHRub2RlID0gbm9kZS5wcmV2O1xuXHRcdFx0fSB3aGlsZSggbm9kZS5rZXkgIT09IG51bGwgJiYgISB0aGlzLmxlcSh0aGlzLmZyYW1lLCBub2RlLmtleSwga2V5KSk7XG5cblx0XHRcdHZhciBuZXdOb2RlID0gbmV3IERpY3ROb2RlKCk7XG5cdFx0XHRuZXdOb2RlLmtleSA9IGtleTtcblx0XHRcdG5ld05vZGUubmV4dCA9IG5vZGUubmV4dDtcblx0XHRcdG5vZGUubmV4dC5wcmV2ID0gbmV3Tm9kZTtcblx0XHRcdG5ld05vZGUucHJldiA9IG5vZGU7XG5cdFx0XHRub2RlLm5leHQgPSBuZXdOb2RlO1xuXG5cdFx0XHRyZXR1cm4gbmV3Tm9kZTtcblx0XHR9LFxuXG5cdFx0ZGVsZXRlOiBmdW5jdGlvbihub2RlKSB7XG5cdFx0XHRub2RlLm5leHQucHJldiA9IG5vZGUucHJldjtcblx0XHRcdG5vZGUucHJldi5uZXh0ID0gbm9kZS5uZXh0O1xuXHRcdH1cblx0fTtcblxuXG5cdGZ1bmN0aW9uIFBRbm9kZSgpIHtcblx0XHR0aGlzLmhhbmRsZSA9IG51bGw7XG5cdH1cblxuXHRmdW5jdGlvbiBQUWhhbmRsZUVsZW0oKSB7XG5cdFx0dGhpcy5rZXkgPSBudWxsO1xuXHRcdHRoaXMubm9kZSA9IG51bGw7XG5cdH1cblxuXHRmdW5jdGlvbiBQcmlvcml0eVEoc2l6ZSwgbGVxKSB7XG5cdFx0dGhpcy5zaXplID0gMDtcblx0XHR0aGlzLm1heCA9IHNpemU7XG5cblx0XHR0aGlzLm5vZGVzID0gW107XG5cdFx0dGhpcy5ub2Rlcy5sZW5ndGggPSBzaXplKzE7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm5vZGVzLmxlbmd0aDsgaSsrKVxuXHRcdFx0dGhpcy5ub2Rlc1tpXSA9IG5ldyBQUW5vZGUoKTtcblxuXHRcdHRoaXMuaGFuZGxlcyA9IFtdO1xuXHRcdHRoaXMuaGFuZGxlcy5sZW5ndGggPSBzaXplKzE7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmhhbmRsZXMubGVuZ3RoOyBpKyspXG5cdFx0XHR0aGlzLmhhbmRsZXNbaV0gPSBuZXcgUFFoYW5kbGVFbGVtKCk7XG5cblx0XHR0aGlzLmluaXRpYWxpemVkID0gZmFsc2U7XG5cdFx0dGhpcy5mcmVlTGlzdCA9IDA7XG5cdFx0dGhpcy5sZXEgPSBsZXE7XG5cblx0XHR0aGlzLm5vZGVzWzFdLmhhbmRsZSA9IDE7XHQvKiBzbyB0aGF0IE1pbmltdW0oKSByZXR1cm5zIE5VTEwgKi9cblx0XHR0aGlzLmhhbmRsZXNbMV0ua2V5ID0gbnVsbDtcblx0fTtcblxuXHRQcmlvcml0eVEucHJvdG90eXBlID0ge1xuXG5cdFx0ZmxvYXREb3duXzogZnVuY3Rpb24oIGN1cnIgKVxuXHRcdHtcblx0XHRcdHZhciBuID0gdGhpcy5ub2Rlcztcblx0XHRcdHZhciBoID0gdGhpcy5oYW5kbGVzO1xuXHRcdFx0dmFyIGhDdXJyLCBoQ2hpbGQ7XG5cdFx0XHR2YXIgY2hpbGQ7XG5cblx0XHRcdGhDdXJyID0gbltjdXJyXS5oYW5kbGU7XG5cdFx0XHRmb3IoIDs7ICkge1xuXHRcdFx0XHRjaGlsZCA9IGN1cnIgPDwgMTtcblx0XHRcdFx0aWYoIGNoaWxkIDwgdGhpcy5zaXplICYmIHRoaXMubGVxKCBoW25bY2hpbGQrMV0uaGFuZGxlXS5rZXksIGhbbltjaGlsZF0uaGFuZGxlXS5rZXkgKSkge1xuXHRcdFx0XHRcdCsrY2hpbGQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRhc3NlcnQoY2hpbGQgPD0gdGhpcy5tYXgpO1xuXG5cdFx0XHRcdGhDaGlsZCA9IG5bY2hpbGRdLmhhbmRsZTtcblx0XHRcdFx0aWYoIGNoaWxkID4gdGhpcy5zaXplIHx8IHRoaXMubGVxKCBoW2hDdXJyXS5rZXksIGhbaENoaWxkXS5rZXkgKSkge1xuXHRcdFx0XHRcdG5bY3Vycl0uaGFuZGxlID0gaEN1cnI7XG5cdFx0XHRcdFx0aFtoQ3Vycl0ubm9kZSA9IGN1cnI7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdFx0bltjdXJyXS5oYW5kbGUgPSBoQ2hpbGQ7XG5cdFx0XHRcdGhbaENoaWxkXS5ub2RlID0gY3Vycjtcblx0XHRcdFx0Y3VyciA9IGNoaWxkO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRmbG9hdFVwXzogZnVuY3Rpb24oIGN1cnIgKVxuXHRcdHtcblx0XHRcdHZhciBuID0gdGhpcy5ub2Rlcztcblx0XHRcdHZhciBoID0gdGhpcy5oYW5kbGVzO1xuXHRcdFx0dmFyIGhDdXJyLCBoUGFyZW50O1xuXHRcdFx0dmFyIHBhcmVudDtcblxuXHRcdFx0aEN1cnIgPSBuW2N1cnJdLmhhbmRsZTtcblx0XHRcdGZvciggOzsgKSB7XG5cdFx0XHRcdHBhcmVudCA9IGN1cnIgPj4gMTtcblx0XHRcdFx0aFBhcmVudCA9IG5bcGFyZW50XS5oYW5kbGU7XG5cdFx0XHRcdGlmKCBwYXJlbnQgPT0gMCB8fCB0aGlzLmxlcSggaFtoUGFyZW50XS5rZXksIGhbaEN1cnJdLmtleSApKSB7XG5cdFx0XHRcdFx0bltjdXJyXS5oYW5kbGUgPSBoQ3Vycjtcblx0XHRcdFx0XHRoW2hDdXJyXS5ub2RlID0gY3Vycjtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0XHRuW2N1cnJdLmhhbmRsZSA9IGhQYXJlbnQ7XG5cdFx0XHRcdGhbaFBhcmVudF0ubm9kZSA9IGN1cnI7XG5cdFx0XHRcdGN1cnIgPSBwYXJlbnQ7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGluaXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0LyogVGhpcyBtZXRob2Qgb2YgYnVpbGRpbmcgYSBoZWFwIGlzIE8obiksIHJhdGhlciB0aGFuIE8obiBsZyBuKS4gKi9cblx0XHRcdGZvciggdmFyIGkgPSB0aGlzLnNpemU7IGkgPj0gMTsgLS1pICkge1xuXHRcdFx0XHR0aGlzLmZsb2F0RG93bl8oIGkgKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuXHRcdH0sXG5cblx0XHRtaW46IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuaGFuZGxlc1t0aGlzLm5vZGVzWzFdLmhhbmRsZV0ua2V5O1xuXHRcdH0sXG5cblx0XHRpc0VtcHR5OiBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMuc2l6ZSA9PT0gMDtcblx0XHR9LFxuXG5cdFx0LyogcmVhbGx5IHBxSGVhcEluc2VydCAqL1xuXHRcdC8qIHJldHVybnMgSU5WX0hBTkRMRSBpZmYgb3V0IG9mIG1lbW9yeSAqL1xuXHRcdC8vUFFoYW5kbGUgcHFIZWFwSW5zZXJ0KCBURVNTYWxsb2MqIGFsbG9jLCBQcmlvcml0eVFIZWFwICpwcSwgUFFrZXkga2V5TmV3IClcblx0XHRpbnNlcnQ6IGZ1bmN0aW9uKGtleU5ldylcblx0XHR7XG5cdFx0XHR2YXIgY3Vycjtcblx0XHRcdHZhciBmcmVlO1xuXG5cdFx0XHRjdXJyID0gKyt0aGlzLnNpemU7XG5cdFx0XHRpZiggKGN1cnIqMikgPiB0aGlzLm1heCApIHtcblx0XHRcdFx0dGhpcy5tYXggKj0gMjtcblx0XHRcdFx0dmFyIHM7XG5cdFx0XHRcdHMgPSB0aGlzLm5vZGVzLmxlbmd0aDtcblx0XHRcdFx0dGhpcy5ub2Rlcy5sZW5ndGggPSB0aGlzLm1heCsxO1xuXHRcdFx0XHRmb3IgKHZhciBpID0gczsgaSA8IHRoaXMubm9kZXMubGVuZ3RoOyBpKyspXG5cdFx0XHRcdFx0dGhpcy5ub2Rlc1tpXSA9IG5ldyBQUW5vZGUoKTtcblxuXHRcdFx0XHRzID0gdGhpcy5oYW5kbGVzLmxlbmd0aDtcblx0XHRcdFx0dGhpcy5oYW5kbGVzLmxlbmd0aCA9IHRoaXMubWF4KzE7XG5cdFx0XHRcdGZvciAodmFyIGkgPSBzOyBpIDwgdGhpcy5oYW5kbGVzLmxlbmd0aDsgaSsrKVxuXHRcdFx0XHRcdHRoaXMuaGFuZGxlc1tpXSA9IG5ldyBQUWhhbmRsZUVsZW0oKTtcblx0XHRcdH1cblxuXHRcdFx0aWYoIHRoaXMuZnJlZUxpc3QgPT09IDAgKSB7XG5cdFx0XHRcdGZyZWUgPSBjdXJyO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZnJlZSA9IHRoaXMuZnJlZUxpc3Q7XG5cdFx0XHRcdHRoaXMuZnJlZUxpc3QgPSB0aGlzLmhhbmRsZXNbZnJlZV0ubm9kZTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5ub2Rlc1tjdXJyXS5oYW5kbGUgPSBmcmVlO1xuXHRcdFx0dGhpcy5oYW5kbGVzW2ZyZWVdLm5vZGUgPSBjdXJyO1xuXHRcdFx0dGhpcy5oYW5kbGVzW2ZyZWVdLmtleSA9IGtleU5ldztcblxuXHRcdFx0aWYoIHRoaXMuaW5pdGlhbGl6ZWQgKSB7XG5cdFx0XHRcdHRoaXMuZmxvYXRVcF8oIGN1cnIgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBmcmVlO1xuXHRcdH0sXG5cblx0XHQvL1BRa2V5IHBxSGVhcEV4dHJhY3RNaW4oIFByaW9yaXR5UUhlYXAgKnBxIClcblx0XHRleHRyYWN0TWluOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuID0gdGhpcy5ub2Rlcztcblx0XHRcdHZhciBoID0gdGhpcy5oYW5kbGVzO1xuXHRcdFx0dmFyIGhNaW4gPSBuWzFdLmhhbmRsZTtcblx0XHRcdHZhciBtaW4gPSBoW2hNaW5dLmtleTtcblxuXHRcdFx0aWYoIHRoaXMuc2l6ZSA+IDAgKSB7XG5cdFx0XHRcdG5bMV0uaGFuZGxlID0gblt0aGlzLnNpemVdLmhhbmRsZTtcblx0XHRcdFx0aFtuWzFdLmhhbmRsZV0ubm9kZSA9IDE7XG5cblx0XHRcdFx0aFtoTWluXS5rZXkgPSBudWxsO1xuXHRcdFx0XHRoW2hNaW5dLm5vZGUgPSB0aGlzLmZyZWVMaXN0O1xuXHRcdFx0XHR0aGlzLmZyZWVMaXN0ID0gaE1pbjtcblxuXHRcdFx0XHQtLXRoaXMuc2l6ZTtcblx0XHRcdFx0aWYoIHRoaXMuc2l6ZSA+IDAgKSB7XG5cdFx0XHRcdFx0dGhpcy5mbG9hdERvd25fKCAxICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBtaW47XG5cdFx0fSxcblxuXHRcdGRlbGV0ZTogZnVuY3Rpb24oIGhDdXJyICkge1xuXHRcdFx0dmFyIG4gPSB0aGlzLm5vZGVzO1xuXHRcdFx0dmFyIGggPSB0aGlzLmhhbmRsZXM7XG5cdFx0XHR2YXIgY3VycjtcblxuXHRcdFx0YXNzZXJ0KCBoQ3VyciA+PSAxICYmIGhDdXJyIDw9IHRoaXMubWF4ICYmIGhbaEN1cnJdLmtleSAhPT0gbnVsbCApO1xuXG5cdFx0XHRjdXJyID0gaFtoQ3Vycl0ubm9kZTtcblx0XHRcdG5bY3Vycl0uaGFuZGxlID0gblt0aGlzLnNpemVdLmhhbmRsZTtcblx0XHRcdGhbbltjdXJyXS5oYW5kbGVdLm5vZGUgPSBjdXJyO1xuXG5cdFx0XHQtLXRoaXMuc2l6ZTtcblx0XHRcdGlmKCBjdXJyIDw9IHRoaXMuc2l6ZSApIHtcblx0XHRcdFx0aWYoIGN1cnIgPD0gMSB8fCB0aGlzLmxlcSggaFtuW2N1cnI+PjFdLmhhbmRsZV0ua2V5LCBoW25bY3Vycl0uaGFuZGxlXS5rZXkgKSkge1xuXHRcdFx0XHRcdHRoaXMuZmxvYXREb3duXyggY3VyciApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuZmxvYXRVcF8oIGN1cnIgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aFtoQ3Vycl0ua2V5ID0gbnVsbDtcblx0XHRcdGhbaEN1cnJdLm5vZGUgPSB0aGlzLmZyZWVMaXN0O1xuXHRcdFx0dGhpcy5mcmVlTGlzdCA9IGhDdXJyO1xuXHRcdH1cblx0fTtcblxuXG5cdC8qIEZvciBlYWNoIHBhaXIgb2YgYWRqYWNlbnQgZWRnZXMgY3Jvc3NpbmcgdGhlIHN3ZWVwIGxpbmUsIHRoZXJlIGlzXG5cdCogYW4gQWN0aXZlUmVnaW9uIHRvIHJlcHJlc2VudCB0aGUgcmVnaW9uIGJldHdlZW4gdGhlbS4gIFRoZSBhY3RpdmVcblx0KiByZWdpb25zIGFyZSBrZXB0IGluIHNvcnRlZCBvcmRlciBpbiBhIGR5bmFtaWMgZGljdGlvbmFyeS4gIEFzIHRoZVxuXHQqIHN3ZWVwIGxpbmUgY3Jvc3NlcyBlYWNoIHZlcnRleCwgd2UgdXBkYXRlIHRoZSBhZmZlY3RlZCByZWdpb25zLlxuXHQqL1xuXG5cdGZ1bmN0aW9uIEFjdGl2ZVJlZ2lvbigpIHtcblx0XHR0aGlzLmVVcCA9IG51bGw7XHRcdC8qIHVwcGVyIGVkZ2UsIGRpcmVjdGVkIHJpZ2h0IHRvIGxlZnQgKi9cblx0XHR0aGlzLm5vZGVVcCA9IG51bGw7XHQvKiBkaWN0aW9uYXJ5IG5vZGUgY29ycmVzcG9uZGluZyB0byBlVXAgKi9cblx0XHR0aGlzLndpbmRpbmdOdW1iZXIgPSAwO1x0LyogdXNlZCB0byBkZXRlcm1pbmUgd2hpY2ggcmVnaW9ucyBhcmVcblx0XHRcdFx0XHRcdFx0XHQqIGluc2lkZSB0aGUgcG9seWdvbiAqL1xuXHRcdHRoaXMuaW5zaWRlID0gZmFsc2U7XHRcdC8qIGlzIHRoaXMgcmVnaW9uIGluc2lkZSB0aGUgcG9seWdvbj8gKi9cblx0XHR0aGlzLnNlbnRpbmVsID0gZmFsc2U7XHQvKiBtYXJrcyBmYWtlIGVkZ2VzIGF0IHQgPSArLy1pbmZpbml0eSAqL1xuXHRcdHRoaXMuZGlydHkgPSBmYWxzZTtcdFx0LyogbWFya3MgcmVnaW9ucyB3aGVyZSB0aGUgdXBwZXIgb3IgbG93ZXJcblx0XHRcdFx0XHRcdCogZWRnZSBoYXMgY2hhbmdlZCwgYnV0IHdlIGhhdmVuJ3QgY2hlY2tlZFxuXHRcdFx0XHRcdFx0KiB3aGV0aGVyIHRoZXkgaW50ZXJzZWN0IHlldCAqL1xuXHRcdHRoaXMuZml4VXBwZXJFZGdlID0gZmFsc2U7XHQvKiBtYXJrcyB0ZW1wb3JhcnkgZWRnZXMgaW50cm9kdWNlZCB3aGVuXG5cdFx0XHRcdFx0XHRcdCogd2UgcHJvY2VzcyBhIFwicmlnaHQgdmVydGV4XCIgKG9uZSB3aXRob3V0XG5cdFx0XHRcdFx0XHRcdCogYW55IGVkZ2VzIGxlYXZpbmcgdG8gdGhlIHJpZ2h0KSAqL1xuXHR9O1xuXG5cdHZhciBTd2VlcCA9IHt9O1xuXG5cdFN3ZWVwLnJlZ2lvbkJlbG93ID0gZnVuY3Rpb24ocikge1xuXHRcdHJldHVybiByLm5vZGVVcC5wcmV2LmtleTtcblx0fVxuXG5cdFN3ZWVwLnJlZ2lvbkFib3ZlID0gZnVuY3Rpb24ocikge1xuXHRcdHJldHVybiByLm5vZGVVcC5uZXh0LmtleTtcblx0fVxuXG5cdFN3ZWVwLmRlYnVnRXZlbnQgPSBmdW5jdGlvbiggdGVzcyApIHtcblx0XHQvLyBlbXB0eVxuXHR9XG5cblxuXHQvKlxuXHQqIEludmFyaWFudHMgZm9yIHRoZSBFZGdlIERpY3Rpb25hcnkuXG5cdCogLSBlYWNoIHBhaXIgb2YgYWRqYWNlbnQgZWRnZXMgZTI9U3VjYyhlMSkgc2F0aXNmaWVzIEVkZ2VMZXEoZTEsZTIpXG5cdCogICBhdCBhbnkgdmFsaWQgbG9jYXRpb24gb2YgdGhlIHN3ZWVwIGV2ZW50XG5cdCogLSBpZiBFZGdlTGVxKGUyLGUxKSBhcyB3ZWxsIChhdCBhbnkgdmFsaWQgc3dlZXAgZXZlbnQpLCB0aGVuIGUxIGFuZCBlMlxuXHQqICAgc2hhcmUgYSBjb21tb24gZW5kcG9pbnRcblx0KiAtIGZvciBlYWNoIGUsIGUtPkRzdCBoYXMgYmVlbiBwcm9jZXNzZWQsIGJ1dCBub3QgZS0+T3JnXG5cdCogLSBlYWNoIGVkZ2UgZSBzYXRpc2ZpZXMgVmVydExlcShlLT5Ec3QsZXZlbnQpICYmIFZlcnRMZXEoZXZlbnQsZS0+T3JnKVxuXHQqICAgd2hlcmUgXCJldmVudFwiIGlzIHRoZSBjdXJyZW50IHN3ZWVwIGxpbmUgZXZlbnQuXG5cdCogLSBubyBlZGdlIGUgaGFzIHplcm8gbGVuZ3RoXG5cdCpcblx0KiBJbnZhcmlhbnRzIGZvciB0aGUgTWVzaCAodGhlIHByb2Nlc3NlZCBwb3J0aW9uKS5cblx0KiAtIHRoZSBwb3J0aW9uIG9mIHRoZSBtZXNoIGxlZnQgb2YgdGhlIHN3ZWVwIGxpbmUgaXMgYSBwbGFuYXIgZ3JhcGgsXG5cdCogICBpZS4gdGhlcmUgaXMgKnNvbWUqIHdheSB0byBlbWJlZCBpdCBpbiB0aGUgcGxhbmVcblx0KiAtIG5vIHByb2Nlc3NlZCBlZGdlIGhhcyB6ZXJvIGxlbmd0aFxuXHQqIC0gbm8gdHdvIHByb2Nlc3NlZCB2ZXJ0aWNlcyBoYXZlIGlkZW50aWNhbCBjb29yZGluYXRlc1xuXHQqIC0gZWFjaCBcImluc2lkZVwiIHJlZ2lvbiBpcyBtb25vdG9uZSwgaWUuIGNhbiBiZSBicm9rZW4gaW50byB0d28gY2hhaW5zXG5cdCogICBvZiBtb25vdG9uaWNhbGx5IGluY3JlYXNpbmcgdmVydGljZXMgYWNjb3JkaW5nIHRvIFZlcnRMZXEodjEsdjIpXG5cdCogICAtIGEgbm9uLWludmFyaWFudDogdGhlc2UgY2hhaW5zIG1heSBpbnRlcnNlY3QgKHZlcnkgc2xpZ2h0bHkpXG5cdCpcblx0KiBJbnZhcmlhbnRzIGZvciB0aGUgU3dlZXAuXG5cdCogLSBpZiBub25lIG9mIHRoZSBlZGdlcyBpbmNpZGVudCB0byB0aGUgZXZlbnQgdmVydGV4IGhhdmUgYW4gYWN0aXZlUmVnaW9uXG5cdCogICAoaWUuIG5vbmUgb2YgdGhlc2UgZWRnZXMgYXJlIGluIHRoZSBlZGdlIGRpY3Rpb25hcnkpLCB0aGVuIHRoZSB2ZXJ0ZXhcblx0KiAgIGhhcyBvbmx5IHJpZ2h0LWdvaW5nIGVkZ2VzLlxuXHQqIC0gaWYgYW4gZWRnZSBpcyBtYXJrZWQgXCJmaXhVcHBlckVkZ2VcIiAoaXQgaXMgYSB0ZW1wb3JhcnkgZWRnZSBpbnRyb2R1Y2VkXG5cdCogICBieSBDb25uZWN0UmlnaHRWZXJ0ZXgpLCB0aGVuIGl0IGlzIHRoZSBvbmx5IHJpZ2h0LWdvaW5nIGVkZ2UgZnJvbVxuXHQqICAgaXRzIGFzc29jaWF0ZWQgdmVydGV4LiAgKFRoaXMgc2F5cyB0aGF0IHRoZXNlIGVkZ2VzIGV4aXN0IG9ubHlcblx0KiAgIHdoZW4gaXQgaXMgbmVjZXNzYXJ5Lilcblx0Ki9cblxuXHQvKiBXaGVuIHdlIG1lcmdlIHR3byBlZGdlcyBpbnRvIG9uZSwgd2UgbmVlZCB0byBjb21wdXRlIHRoZSBjb21iaW5lZFxuXHQqIHdpbmRpbmcgb2YgdGhlIG5ldyBlZGdlLlxuXHQqL1xuXHRTd2VlcC5hZGRXaW5kaW5nID0gZnVuY3Rpb24oZURzdCxlU3JjKSB7XG5cdFx0ZURzdC53aW5kaW5nICs9IGVTcmMud2luZGluZztcblx0XHRlRHN0LlN5bS53aW5kaW5nICs9IGVTcmMuU3ltLndpbmRpbmc7XG5cdH1cblxuXG5cdC8vc3RhdGljIGludCBFZGdlTGVxKCBURVNTdGVzc2VsYXRvciAqdGVzcywgQWN0aXZlUmVnaW9uICpyZWcxLCBBY3RpdmVSZWdpb24gKnJlZzIgKVxuXHRTd2VlcC5lZGdlTGVxID0gZnVuY3Rpb24oIHRlc3MsIHJlZzEsIHJlZzIgKSB7XG5cdFx0Lypcblx0XHQqIEJvdGggZWRnZXMgbXVzdCBiZSBkaXJlY3RlZCBmcm9tIHJpZ2h0IHRvIGxlZnQgKHRoaXMgaXMgdGhlIGNhbm9uaWNhbFxuXHRcdCogZGlyZWN0aW9uIGZvciB0aGUgdXBwZXIgZWRnZSBvZiBlYWNoIHJlZ2lvbikuXG5cdFx0KlxuXHRcdCogVGhlIHN0cmF0ZWd5IGlzIHRvIGV2YWx1YXRlIGEgXCJ0XCIgdmFsdWUgZm9yIGVhY2ggZWRnZSBhdCB0aGVcblx0XHQqIGN1cnJlbnQgc3dlZXAgbGluZSBwb3NpdGlvbiwgZ2l2ZW4gYnkgdGVzcy0+ZXZlbnQuICBUaGUgY2FsY3VsYXRpb25zXG5cdFx0KiBhcmUgZGVzaWduZWQgdG8gYmUgdmVyeSBzdGFibGUsIGJ1dCBvZiBjb3Vyc2UgdGhleSBhcmUgbm90IHBlcmZlY3QuXG5cdFx0KlxuXHRcdCogU3BlY2lhbCBjYXNlOiBpZiBib3RoIGVkZ2UgZGVzdGluYXRpb25zIGFyZSBhdCB0aGUgc3dlZXAgZXZlbnQsXG5cdFx0KiB3ZSBzb3J0IHRoZSBlZGdlcyBieSBzbG9wZSAodGhleSB3b3VsZCBvdGhlcndpc2UgY29tcGFyZSBlcXVhbGx5KS5cblx0XHQqL1xuXHRcdHZhciBldiA9IHRlc3MuZXZlbnQ7XG5cdFx0dmFyIHQxLCB0MjtcblxuXHRcdHZhciBlMSA9IHJlZzEuZVVwO1xuXHRcdHZhciBlMiA9IHJlZzIuZVVwO1xuXG5cdFx0aWYoIGUxLkRzdCA9PT0gZXYgKSB7XG5cdFx0XHRpZiggZTIuRHN0ID09PSBldiApIHtcblx0XHRcdFx0LyogVHdvIGVkZ2VzIHJpZ2h0IG9mIHRoZSBzd2VlcCBsaW5lIHdoaWNoIG1lZXQgYXQgdGhlIHN3ZWVwIGV2ZW50LlxuXHRcdFx0XHQqIFNvcnQgdGhlbSBieSBzbG9wZS5cblx0XHRcdFx0Ki9cblx0XHRcdFx0aWYoIEdlb20udmVydExlcSggZTEuT3JnLCBlMi5PcmcgKSkge1xuXHRcdFx0XHRcdHJldHVybiBHZW9tLmVkZ2VTaWduKCBlMi5Ec3QsIGUxLk9yZywgZTIuT3JnICkgPD0gMDtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gR2VvbS5lZGdlU2lnbiggZTEuRHN0LCBlMi5PcmcsIGUxLk9yZyApID49IDA7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gR2VvbS5lZGdlU2lnbiggZTIuRHN0LCBldiwgZTIuT3JnICkgPD0gMDtcblx0XHR9XG5cdFx0aWYoIGUyLkRzdCA9PT0gZXYgKSB7XG5cdFx0XHRyZXR1cm4gR2VvbS5lZGdlU2lnbiggZTEuRHN0LCBldiwgZTEuT3JnICkgPj0gMDtcblx0XHR9XG5cblx0XHQvKiBHZW5lcmFsIGNhc2UgLSBjb21wdXRlIHNpZ25lZCBkaXN0YW5jZSAqZnJvbSogZTEsIGUyIHRvIGV2ZW50ICovXG5cdFx0dmFyIHQxID0gR2VvbS5lZGdlRXZhbCggZTEuRHN0LCBldiwgZTEuT3JnICk7XG5cdFx0dmFyIHQyID0gR2VvbS5lZGdlRXZhbCggZTIuRHN0LCBldiwgZTIuT3JnICk7XG5cdFx0cmV0dXJuICh0MSA+PSB0Mik7XG5cdH1cblxuXG5cdC8vc3RhdGljIHZvaWQgRGVsZXRlUmVnaW9uKCBURVNTdGVzc2VsYXRvciAqdGVzcywgQWN0aXZlUmVnaW9uICpyZWcgKVxuXHRTd2VlcC5kZWxldGVSZWdpb24gPSBmdW5jdGlvbiggdGVzcywgcmVnICkge1xuXHRcdGlmKCByZWcuZml4VXBwZXJFZGdlICkge1xuXHRcdFx0LyogSXQgd2FzIGNyZWF0ZWQgd2l0aCB6ZXJvIHdpbmRpbmcgbnVtYmVyLCBzbyBpdCBiZXR0ZXIgYmVcblx0XHRcdCogZGVsZXRlZCB3aXRoIHplcm8gd2luZGluZyBudW1iZXIgKGllLiBpdCBiZXR0ZXIgbm90IGdldCBtZXJnZWRcblx0XHRcdCogd2l0aCBhIHJlYWwgZWRnZSkuXG5cdFx0XHQqL1xuXHRcdFx0YXNzZXJ0KCByZWcuZVVwLndpbmRpbmcgPT09IDAgKTtcblx0XHR9XG5cdFx0cmVnLmVVcC5hY3RpdmVSZWdpb24gPSBudWxsO1xuXHRcdHRlc3MuZGljdC5kZWxldGUoIHJlZy5ub2RlVXAgKTtcblx0fVxuXG5cdC8vc3RhdGljIGludCBGaXhVcHBlckVkZ2UoIFRFU1N0ZXNzZWxhdG9yICp0ZXNzLCBBY3RpdmVSZWdpb24gKnJlZywgVEVTU2hhbGZFZGdlICpuZXdFZGdlIClcblx0U3dlZXAuZml4VXBwZXJFZGdlID0gZnVuY3Rpb24oIHRlc3MsIHJlZywgbmV3RWRnZSApIHtcblx0XHQvKlxuXHRcdCogUmVwbGFjZSBhbiB1cHBlciBlZGdlIHdoaWNoIG5lZWRzIGZpeGluZyAoc2VlIENvbm5lY3RSaWdodFZlcnRleCkuXG5cdFx0Ki9cblx0XHRhc3NlcnQoIHJlZy5maXhVcHBlckVkZ2UgKTtcblx0XHR0ZXNzLm1lc2guZGVsZXRlKCByZWcuZVVwICk7XG5cdFx0cmVnLmZpeFVwcGVyRWRnZSA9IGZhbHNlO1xuXHRcdHJlZy5lVXAgPSBuZXdFZGdlO1xuXHRcdG5ld0VkZ2UuYWN0aXZlUmVnaW9uID0gcmVnO1xuXHR9XG5cblx0Ly9zdGF0aWMgQWN0aXZlUmVnaW9uICpUb3BMZWZ0UmVnaW9uKCBURVNTdGVzc2VsYXRvciAqdGVzcywgQWN0aXZlUmVnaW9uICpyZWcgKVxuXHRTd2VlcC50b3BMZWZ0UmVnaW9uID0gZnVuY3Rpb24oIHRlc3MsIHJlZyApIHtcblx0XHR2YXIgb3JnID0gcmVnLmVVcC5Pcmc7XG5cdFx0dmFyIGU7XG5cblx0XHQvKiBGaW5kIHRoZSByZWdpb24gYWJvdmUgdGhlIHVwcGVybW9zdCBlZGdlIHdpdGggdGhlIHNhbWUgb3JpZ2luICovXG5cdFx0ZG8ge1xuXHRcdFx0cmVnID0gU3dlZXAucmVnaW9uQWJvdmUoIHJlZyApO1xuXHRcdH0gd2hpbGUoIHJlZy5lVXAuT3JnID09PSBvcmcgKTtcblxuXHRcdC8qIElmIHRoZSBlZGdlIGFib3ZlIHdhcyBhIHRlbXBvcmFyeSBlZGdlIGludHJvZHVjZWQgYnkgQ29ubmVjdFJpZ2h0VmVydGV4LFxuXHRcdCogbm93IGlzIHRoZSB0aW1lIHRvIGZpeCBpdC5cblx0XHQqL1xuXHRcdGlmKCByZWcuZml4VXBwZXJFZGdlICkge1xuXHRcdFx0ZSA9IHRlc3MubWVzaC5jb25uZWN0KCBTd2VlcC5yZWdpb25CZWxvdyhyZWcpLmVVcC5TeW0sIHJlZy5lVXAuTG5leHQgKTtcblx0XHRcdGlmIChlID09PSBudWxsKSByZXR1cm4gbnVsbDtcblx0XHRcdFN3ZWVwLmZpeFVwcGVyRWRnZSggdGVzcywgcmVnLCBlICk7XG5cdFx0XHRyZWcgPSBTd2VlcC5yZWdpb25BYm92ZSggcmVnICk7XG5cdFx0fVxuXHRcdHJldHVybiByZWc7XG5cdH1cblxuXHQvL3N0YXRpYyBBY3RpdmVSZWdpb24gKlRvcFJpZ2h0UmVnaW9uKCBBY3RpdmVSZWdpb24gKnJlZyApXG5cdFN3ZWVwLnRvcFJpZ2h0UmVnaW9uID0gZnVuY3Rpb24oIHJlZyApXG5cdHtcblx0XHR2YXIgZHN0ID0gcmVnLmVVcC5Ec3Q7XG5cdFx0dmFyIHJlZyA9IG51bGw7XG5cdFx0LyogRmluZCB0aGUgcmVnaW9uIGFib3ZlIHRoZSB1cHBlcm1vc3QgZWRnZSB3aXRoIHRoZSBzYW1lIGRlc3RpbmF0aW9uICovXG5cdFx0ZG8ge1xuXHRcdFx0cmVnID0gU3dlZXAucmVnaW9uQWJvdmUoIHJlZyApO1xuXHRcdH0gd2hpbGUoIHJlZy5lVXAuRHN0ID09PSBkc3QgKTtcblx0XHRyZXR1cm4gcmVnO1xuXHR9XG5cblx0Ly9zdGF0aWMgQWN0aXZlUmVnaW9uICpBZGRSZWdpb25CZWxvdyggVEVTU3Rlc3NlbGF0b3IgKnRlc3MsIEFjdGl2ZVJlZ2lvbiAqcmVnQWJvdmUsIFRFU1NoYWxmRWRnZSAqZU5ld1VwIClcblx0U3dlZXAuYWRkUmVnaW9uQmVsb3cgPSBmdW5jdGlvbiggdGVzcywgcmVnQWJvdmUsIGVOZXdVcCApIHtcblx0XHQvKlxuXHRcdCogQWRkIGEgbmV3IGFjdGl2ZSByZWdpb24gdG8gdGhlIHN3ZWVwIGxpbmUsICpzb21ld2hlcmUqIGJlbG93IFwicmVnQWJvdmVcIlxuXHRcdCogKGFjY29yZGluZyB0byB3aGVyZSB0aGUgbmV3IGVkZ2UgYmVsb25ncyBpbiB0aGUgc3dlZXAtbGluZSBkaWN0aW9uYXJ5KS5cblx0XHQqIFRoZSB1cHBlciBlZGdlIG9mIHRoZSBuZXcgcmVnaW9uIHdpbGwgYmUgXCJlTmV3VXBcIi5cblx0XHQqIFdpbmRpbmcgbnVtYmVyIGFuZCBcImluc2lkZVwiIGZsYWcgYXJlIG5vdCB1cGRhdGVkLlxuXHRcdCovXG5cdFx0dmFyIHJlZ05ldyA9IG5ldyBBY3RpdmVSZWdpb24oKTtcblx0XHRyZWdOZXcuZVVwID0gZU5ld1VwO1xuXHRcdHJlZ05ldy5ub2RlVXAgPSB0ZXNzLmRpY3QuaW5zZXJ0QmVmb3JlKCByZWdBYm92ZS5ub2RlVXAsIHJlZ05ldyApO1xuXHQvL1x0aWYgKHJlZ05ldy0+bm9kZVVwID09IE5VTEwpIGxvbmdqbXAodGVzcy0+ZW52LDEpO1xuXHRcdHJlZ05ldy5maXhVcHBlckVkZ2UgPSBmYWxzZTtcblx0XHRyZWdOZXcuc2VudGluZWwgPSBmYWxzZTtcblx0XHRyZWdOZXcuZGlydHkgPSBmYWxzZTtcblxuXHRcdGVOZXdVcC5hY3RpdmVSZWdpb24gPSByZWdOZXc7XG5cdFx0cmV0dXJuIHJlZ05ldztcblx0fVxuXG5cdC8vc3RhdGljIGludCBJc1dpbmRpbmdJbnNpZGUoIFRFU1N0ZXNzZWxhdG9yICp0ZXNzLCBpbnQgbiApXG5cdFN3ZWVwLmlzV2luZGluZ0luc2lkZSA9IGZ1bmN0aW9uKCB0ZXNzLCBuICkge1xuXHRcdHN3aXRjaCggdGVzcy53aW5kaW5nUnVsZSApIHtcblx0XHRcdGNhc2UgVGVzczIuV0lORElOR19PREQ6XG5cdFx0XHRcdHJldHVybiAobiAmIDEpICE9IDA7XG5cdFx0XHRjYXNlIFRlc3MyLldJTkRJTkdfTk9OWkVSTzpcblx0XHRcdFx0cmV0dXJuIChuICE9IDApO1xuXHRcdFx0Y2FzZSBUZXNzMi5XSU5ESU5HX1BPU0lUSVZFOlxuXHRcdFx0XHRyZXR1cm4gKG4gPiAwKTtcblx0XHRcdGNhc2UgVGVzczIuV0lORElOR19ORUdBVElWRTpcblx0XHRcdFx0cmV0dXJuIChuIDwgMCk7XG5cdFx0XHRjYXNlIFRlc3MyLldJTkRJTkdfQUJTX0dFUV9UV086XG5cdFx0XHRcdHJldHVybiAobiA+PSAyKSB8fCAobiA8PSAtMik7XG5cdFx0fVxuXHRcdGFzc2VydCggZmFsc2UgKTtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHQvL3N0YXRpYyB2b2lkIENvbXB1dGVXaW5kaW5nKCBURVNTdGVzc2VsYXRvciAqdGVzcywgQWN0aXZlUmVnaW9uICpyZWcgKVxuXHRTd2VlcC5jb21wdXRlV2luZGluZyA9IGZ1bmN0aW9uKCB0ZXNzLCByZWcgKSB7XG5cdFx0cmVnLndpbmRpbmdOdW1iZXIgPSBTd2VlcC5yZWdpb25BYm92ZShyZWcpLndpbmRpbmdOdW1iZXIgKyByZWcuZVVwLndpbmRpbmc7XG5cdFx0cmVnLmluc2lkZSA9IFN3ZWVwLmlzV2luZGluZ0luc2lkZSggdGVzcywgcmVnLndpbmRpbmdOdW1iZXIgKTtcblx0fVxuXG5cblx0Ly9zdGF0aWMgdm9pZCBGaW5pc2hSZWdpb24oIFRFU1N0ZXNzZWxhdG9yICp0ZXNzLCBBY3RpdmVSZWdpb24gKnJlZyApXG5cdFN3ZWVwLmZpbmlzaFJlZ2lvbiA9IGZ1bmN0aW9uKCB0ZXNzLCByZWcgKSB7XG5cdFx0Lypcblx0XHQqIERlbGV0ZSBhIHJlZ2lvbiBmcm9tIHRoZSBzd2VlcCBsaW5lLiAgVGhpcyBoYXBwZW5zIHdoZW4gdGhlIHVwcGVyXG5cdFx0KiBhbmQgbG93ZXIgY2hhaW5zIG9mIGEgcmVnaW9uIG1lZXQgKGF0IGEgdmVydGV4IG9uIHRoZSBzd2VlcCBsaW5lKS5cblx0XHQqIFRoZSBcImluc2lkZVwiIGZsYWcgaXMgY29waWVkIHRvIHRoZSBhcHByb3ByaWF0ZSBtZXNoIGZhY2UgKHdlIGNvdWxkXG5cdFx0KiBub3QgZG8gdGhpcyBiZWZvcmUgLS0gc2luY2UgdGhlIHN0cnVjdHVyZSBvZiB0aGUgbWVzaCBpcyBhbHdheXNcblx0XHQqIGNoYW5naW5nLCB0aGlzIGZhY2UgbWF5IG5vdCBoYXZlIGV2ZW4gZXhpc3RlZCB1bnRpbCBub3cpLlxuXHRcdCovXG5cdFx0dmFyIGUgPSByZWcuZVVwO1xuXHRcdHZhciBmID0gZS5MZmFjZTtcblxuXHRcdGYuaW5zaWRlID0gcmVnLmluc2lkZTtcblx0XHRmLmFuRWRnZSA9IGU7ICAgLyogb3B0aW1pemF0aW9uIGZvciB0ZXNzTWVzaFRlc3NlbGxhdGVNb25vUmVnaW9uKCkgKi9cblx0XHRTd2VlcC5kZWxldGVSZWdpb24oIHRlc3MsIHJlZyApO1xuXHR9XG5cblxuXHQvL3N0YXRpYyBURVNTaGFsZkVkZ2UgKkZpbmlzaExlZnRSZWdpb25zKCBURVNTdGVzc2VsYXRvciAqdGVzcywgQWN0aXZlUmVnaW9uICpyZWdGaXJzdCwgQWN0aXZlUmVnaW9uICpyZWdMYXN0IClcblx0U3dlZXAuZmluaXNoTGVmdFJlZ2lvbnMgPSBmdW5jdGlvbiggdGVzcywgcmVnRmlyc3QsIHJlZ0xhc3QgKSB7XG5cdFx0Lypcblx0XHQqIFdlIGFyZSBnaXZlbiBhIHZlcnRleCB3aXRoIG9uZSBvciBtb3JlIGxlZnQtZ29pbmcgZWRnZXMuICBBbGwgYWZmZWN0ZWRcblx0XHQqIGVkZ2VzIHNob3VsZCBiZSBpbiB0aGUgZWRnZSBkaWN0aW9uYXJ5LiAgU3RhcnRpbmcgYXQgcmVnRmlyc3QtPmVVcCxcblx0XHQqIHdlIHdhbGsgZG93biBkZWxldGluZyBhbGwgcmVnaW9ucyB3aGVyZSBib3RoIGVkZ2VzIGhhdmUgdGhlIHNhbWVcblx0XHQqIG9yaWdpbiB2T3JnLiAgQXQgdGhlIHNhbWUgdGltZSB3ZSBjb3B5IHRoZSBcImluc2lkZVwiIGZsYWcgZnJvbSB0aGVcblx0XHQqIGFjdGl2ZSByZWdpb24gdG8gdGhlIGZhY2UsIHNpbmNlIGF0IHRoaXMgcG9pbnQgZWFjaCBmYWNlIHdpbGwgYmVsb25nXG5cdFx0KiB0byBhdCBtb3N0IG9uZSByZWdpb24gKHRoaXMgd2FzIG5vdCBuZWNlc3NhcmlseSB0cnVlIHVudGlsIHRoaXMgcG9pbnRcblx0XHQqIGluIHRoZSBzd2VlcCkuICBUaGUgd2FsayBzdG9wcyBhdCB0aGUgcmVnaW9uIGFib3ZlIHJlZ0xhc3Q7IGlmIHJlZ0xhc3Rcblx0XHQqIGlzIE5VTEwgd2Ugd2FsayBhcyBmYXIgYXMgcG9zc2libGUuICBBdCB0aGUgc2FtZSB0aW1lIHdlIHJlbGluayB0aGVcblx0XHQqIG1lc2ggaWYgbmVjZXNzYXJ5LCBzbyB0aGF0IHRoZSBvcmRlcmluZyBvZiBlZGdlcyBhcm91bmQgdk9yZyBpcyB0aGVcblx0XHQqIHNhbWUgYXMgaW4gdGhlIGRpY3Rpb25hcnkuXG5cdFx0Ki9cblx0XHR2YXIgZSwgZVByZXY7XG5cdFx0dmFyIHJlZyA9IG51bGw7XG5cdFx0dmFyIHJlZ1ByZXYgPSByZWdGaXJzdDtcblx0XHR2YXIgZVByZXYgPSByZWdGaXJzdC5lVXA7XG5cdFx0d2hpbGUoIHJlZ1ByZXYgIT09IHJlZ0xhc3QgKSB7XG5cdFx0XHRyZWdQcmV2LmZpeFVwcGVyRWRnZSA9IGZhbHNlO1x0LyogcGxhY2VtZW50IHdhcyBPSyAqL1xuXHRcdFx0cmVnID0gU3dlZXAucmVnaW9uQmVsb3coIHJlZ1ByZXYgKTtcblx0XHRcdGUgPSByZWcuZVVwO1xuXHRcdFx0aWYoIGUuT3JnICE9IGVQcmV2Lk9yZyApIHtcblx0XHRcdFx0aWYoICEgcmVnLmZpeFVwcGVyRWRnZSApIHtcblx0XHRcdFx0XHQvKiBSZW1vdmUgdGhlIGxhc3QgbGVmdC1nb2luZyBlZGdlLiAgRXZlbiB0aG91Z2ggdGhlcmUgYXJlIG5vIGZ1cnRoZXJcblx0XHRcdFx0XHQqIGVkZ2VzIGluIHRoZSBkaWN0aW9uYXJ5IHdpdGggdGhpcyBvcmlnaW4sIHRoZXJlIG1heSBiZSBmdXJ0aGVyXG5cdFx0XHRcdFx0KiBzdWNoIGVkZ2VzIGluIHRoZSBtZXNoIChpZiB3ZSBhcmUgYWRkaW5nIGxlZnQgZWRnZXMgdG8gYSB2ZXJ0ZXhcblx0XHRcdFx0XHQqIHRoYXQgaGFzIGFscmVhZHkgYmVlbiBwcm9jZXNzZWQpLiAgVGh1cyBpdCBpcyBpbXBvcnRhbnQgdG8gY2FsbFxuXHRcdFx0XHRcdCogRmluaXNoUmVnaW9uIHJhdGhlciB0aGFuIGp1c3QgRGVsZXRlUmVnaW9uLlxuXHRcdFx0XHRcdCovXG5cdFx0XHRcdFx0U3dlZXAuZmluaXNoUmVnaW9uKCB0ZXNzLCByZWdQcmV2ICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdFx0LyogSWYgdGhlIGVkZ2UgYmVsb3cgd2FzIGEgdGVtcG9yYXJ5IGVkZ2UgaW50cm9kdWNlZCBieVxuXHRcdFx0XHQqIENvbm5lY3RSaWdodFZlcnRleCwgbm93IGlzIHRoZSB0aW1lIHRvIGZpeCBpdC5cblx0XHRcdFx0Ki9cblx0XHRcdFx0ZSA9IHRlc3MubWVzaC5jb25uZWN0KCBlUHJldi5McHJldiwgZS5TeW0gKTtcblx0Ly9cdFx0XHRpZiAoZSA9PSBOVUxMKSBsb25nam1wKHRlc3MtPmVudiwxKTtcblx0XHRcdFx0U3dlZXAuZml4VXBwZXJFZGdlKCB0ZXNzLCByZWcsIGUgKTtcblx0XHRcdH1cblxuXHRcdFx0LyogUmVsaW5rIGVkZ2VzIHNvIHRoYXQgZVByZXYtPk9uZXh0ID09IGUgKi9cblx0XHRcdGlmKCBlUHJldi5PbmV4dCAhPT0gZSApIHtcblx0XHRcdFx0dGVzcy5tZXNoLnNwbGljZSggZS5PcHJldiwgZSApO1xuXHRcdFx0XHR0ZXNzLm1lc2guc3BsaWNlKCBlUHJldiwgZSApO1xuXHRcdFx0fVxuXHRcdFx0U3dlZXAuZmluaXNoUmVnaW9uKCB0ZXNzLCByZWdQcmV2ICk7XHQvKiBtYXkgY2hhbmdlIHJlZy0+ZVVwICovXG5cdFx0XHRlUHJldiA9IHJlZy5lVXA7XG5cdFx0XHRyZWdQcmV2ID0gcmVnO1xuXHRcdH1cblx0XHRyZXR1cm4gZVByZXY7XG5cdH1cblxuXG5cdC8vc3RhdGljIHZvaWQgQWRkUmlnaHRFZGdlcyggVEVTU3Rlc3NlbGF0b3IgKnRlc3MsIEFjdGl2ZVJlZ2lvbiAqcmVnVXAsIFRFU1NoYWxmRWRnZSAqZUZpcnN0LCBURVNTaGFsZkVkZ2UgKmVMYXN0LCBURVNTaGFsZkVkZ2UgKmVUb3BMZWZ0LCBpbnQgY2xlYW5VcCApXG5cdFN3ZWVwLmFkZFJpZ2h0RWRnZXMgPSBmdW5jdGlvbiggdGVzcywgcmVnVXAsIGVGaXJzdCwgZUxhc3QsIGVUb3BMZWZ0LCBjbGVhblVwICkge1xuXHRcdC8qXG5cdFx0KiBQdXJwb3NlOiBpbnNlcnQgcmlnaHQtZ29pbmcgZWRnZXMgaW50byB0aGUgZWRnZSBkaWN0aW9uYXJ5LCBhbmQgdXBkYXRlXG5cdFx0KiB3aW5kaW5nIG51bWJlcnMgYW5kIG1lc2ggY29ubmVjdGl2aXR5IGFwcHJvcHJpYXRlbHkuICBBbGwgcmlnaHQtZ29pbmdcblx0XHQqIGVkZ2VzIHNoYXJlIGEgY29tbW9uIG9yaWdpbiB2T3JnLiAgRWRnZXMgYXJlIGluc2VydGVkIENDVyBzdGFydGluZyBhdFxuXHRcdCogZUZpcnN0OyB0aGUgbGFzdCBlZGdlIGluc2VydGVkIGlzIGVMYXN0LT5PcHJldi4gIElmIHZPcmcgaGFzIGFueVxuXHRcdCogbGVmdC1nb2luZyBlZGdlcyBhbHJlYWR5IHByb2Nlc3NlZCwgdGhlbiBlVG9wTGVmdCBtdXN0IGJlIHRoZSBlZGdlXG5cdFx0KiBzdWNoIHRoYXQgYW4gaW1hZ2luYXJ5IHVwd2FyZCB2ZXJ0aWNhbCBzZWdtZW50IGZyb20gdk9yZyB3b3VsZCBiZVxuXHRcdCogY29udGFpbmVkIGJldHdlZW4gZVRvcExlZnQtPk9wcmV2IGFuZCBlVG9wTGVmdDsgb3RoZXJ3aXNlIGVUb3BMZWZ0XG5cdFx0KiBzaG91bGQgYmUgTlVMTC5cblx0XHQqL1xuXHRcdHZhciByZWcsIHJlZ1ByZXY7XG5cdFx0dmFyIGUsIGVQcmV2O1xuXHRcdHZhciBmaXJzdFRpbWUgPSB0cnVlO1xuXG5cdFx0LyogSW5zZXJ0IHRoZSBuZXcgcmlnaHQtZ29pbmcgZWRnZXMgaW4gdGhlIGRpY3Rpb25hcnkgKi9cblx0XHRlID0gZUZpcnN0O1xuXHRcdGRvIHtcblx0XHRcdGFzc2VydCggR2VvbS52ZXJ0TGVxKCBlLk9yZywgZS5Ec3QgKSk7XG5cdFx0XHRTd2VlcC5hZGRSZWdpb25CZWxvdyggdGVzcywgcmVnVXAsIGUuU3ltICk7XG5cdFx0XHRlID0gZS5PbmV4dDtcblx0XHR9IHdoaWxlICggZSAhPT0gZUxhc3QgKTtcblxuXHRcdC8qIFdhbGsgKmFsbCogcmlnaHQtZ29pbmcgZWRnZXMgZnJvbSBlLT5PcmcsIGluIHRoZSBkaWN0aW9uYXJ5IG9yZGVyLFxuXHRcdCogdXBkYXRpbmcgdGhlIHdpbmRpbmcgbnVtYmVycyBvZiBlYWNoIHJlZ2lvbiwgYW5kIHJlLWxpbmtpbmcgdGhlIG1lc2hcblx0XHQqIGVkZ2VzIHRvIG1hdGNoIHRoZSBkaWN0aW9uYXJ5IG9yZGVyaW5nIChpZiBuZWNlc3NhcnkpLlxuXHRcdCovXG5cdFx0aWYoIGVUb3BMZWZ0ID09PSBudWxsICkge1xuXHRcdFx0ZVRvcExlZnQgPSBTd2VlcC5yZWdpb25CZWxvdyggcmVnVXAgKS5lVXAuUnByZXY7XG5cdFx0fVxuXHRcdHJlZ1ByZXYgPSByZWdVcDtcblx0XHRlUHJldiA9IGVUb3BMZWZ0O1xuXHRcdGZvciggOzsgKSB7XG5cdFx0XHRyZWcgPSBTd2VlcC5yZWdpb25CZWxvdyggcmVnUHJldiApO1xuXHRcdFx0ZSA9IHJlZy5lVXAuU3ltO1xuXHRcdFx0aWYoIGUuT3JnICE9PSBlUHJldi5PcmcgKSBicmVhaztcblxuXHRcdFx0aWYoIGUuT25leHQgIT09IGVQcmV2ICkge1xuXHRcdFx0XHQvKiBVbmxpbmsgZSBmcm9tIGl0cyBjdXJyZW50IHBvc2l0aW9uLCBhbmQgcmVsaW5rIGJlbG93IGVQcmV2ICovXG5cdFx0XHRcdHRlc3MubWVzaC5zcGxpY2UoIGUuT3ByZXYsIGUgKTtcblx0XHRcdFx0dGVzcy5tZXNoLnNwbGljZSggZVByZXYuT3ByZXYsIGUgKTtcblx0XHRcdH1cblx0XHRcdC8qIENvbXB1dGUgdGhlIHdpbmRpbmcgbnVtYmVyIGFuZCBcImluc2lkZVwiIGZsYWcgZm9yIHRoZSBuZXcgcmVnaW9ucyAqL1xuXHRcdFx0cmVnLndpbmRpbmdOdW1iZXIgPSByZWdQcmV2LndpbmRpbmdOdW1iZXIgLSBlLndpbmRpbmc7XG5cdFx0XHRyZWcuaW5zaWRlID0gU3dlZXAuaXNXaW5kaW5nSW5zaWRlKCB0ZXNzLCByZWcud2luZGluZ051bWJlciApO1xuXG5cdFx0XHQvKiBDaGVjayBmb3IgdHdvIG91dGdvaW5nIGVkZ2VzIHdpdGggc2FtZSBzbG9wZSAtLSBwcm9jZXNzIHRoZXNlXG5cdFx0XHQqIGJlZm9yZSBhbnkgaW50ZXJzZWN0aW9uIHRlc3RzIChzZWUgZXhhbXBsZSBpbiB0ZXNzQ29tcHV0ZUludGVyaW9yKS5cblx0XHRcdCovXG5cdFx0XHRyZWdQcmV2LmRpcnR5ID0gdHJ1ZTtcblx0XHRcdGlmKCAhIGZpcnN0VGltZSAmJiBTd2VlcC5jaGVja0ZvclJpZ2h0U3BsaWNlKCB0ZXNzLCByZWdQcmV2ICkpIHtcblx0XHRcdFx0U3dlZXAuYWRkV2luZGluZyggZSwgZVByZXYgKTtcblx0XHRcdFx0U3dlZXAuZGVsZXRlUmVnaW9uKCB0ZXNzLCByZWdQcmV2ICk7XG5cdFx0XHRcdHRlc3MubWVzaC5kZWxldGUoIGVQcmV2ICk7XG5cdFx0XHR9XG5cdFx0XHRmaXJzdFRpbWUgPSBmYWxzZTtcblx0XHRcdHJlZ1ByZXYgPSByZWc7XG5cdFx0XHRlUHJldiA9IGU7XG5cdFx0fVxuXHRcdHJlZ1ByZXYuZGlydHkgPSB0cnVlO1xuXHRcdGFzc2VydCggcmVnUHJldi53aW5kaW5nTnVtYmVyIC0gZS53aW5kaW5nID09PSByZWcud2luZGluZ051bWJlciApO1xuXG5cdFx0aWYoIGNsZWFuVXAgKSB7XG5cdFx0XHQvKiBDaGVjayBmb3IgaW50ZXJzZWN0aW9ucyBiZXR3ZWVuIG5ld2x5IGFkamFjZW50IGVkZ2VzLiAqL1xuXHRcdFx0U3dlZXAud2Fsa0RpcnR5UmVnaW9ucyggdGVzcywgcmVnUHJldiApO1xuXHRcdH1cblx0fVxuXG5cblx0Ly9zdGF0aWMgdm9pZCBTcGxpY2VNZXJnZVZlcnRpY2VzKCBURVNTdGVzc2VsYXRvciAqdGVzcywgVEVTU2hhbGZFZGdlICplMSwgVEVTU2hhbGZFZGdlICplMiApXG5cdFN3ZWVwLnNwbGljZU1lcmdlVmVydGljZXMgPSBmdW5jdGlvbiggdGVzcywgZTEsIGUyICkge1xuXHRcdC8qXG5cdFx0KiBUd28gdmVydGljZXMgd2l0aCBpZGVudGlhbCBjb29yZGluYXRlcyBhcmUgY29tYmluZWQgaW50byBvbmUuXG5cdFx0KiBlMS0+T3JnIGlzIGtlcHQsIHdoaWxlIGUyLT5PcmcgaXMgZGlzY2FyZGVkLlxuXHRcdCovXG5cdFx0dGVzcy5tZXNoLnNwbGljZSggZTEsIGUyICk7IFxuXHR9XG5cblx0Ly9zdGF0aWMgdm9pZCBWZXJ0ZXhXZWlnaHRzKCBURVNTdmVydGV4ICppc2VjdCwgVEVTU3ZlcnRleCAqb3JnLCBURVNTdmVydGV4ICpkc3QsIFRFU1NyZWFsICp3ZWlnaHRzIClcblx0U3dlZXAudmVydGV4V2VpZ2h0cyA9IGZ1bmN0aW9uKCBpc2VjdCwgb3JnLCBkc3QgKSB7XG5cdFx0Lypcblx0XHQqIEZpbmQgc29tZSB3ZWlnaHRzIHdoaWNoIGRlc2NyaWJlIGhvdyB0aGUgaW50ZXJzZWN0aW9uIHZlcnRleCBpc1xuXHRcdCogYSBsaW5lYXIgY29tYmluYXRpb24gb2YgXCJvcmdcIiBhbmQgXCJkZXN0XCIuICBFYWNoIG9mIHRoZSB0d28gZWRnZXNcblx0XHQqIHdoaWNoIGdlbmVyYXRlZCBcImlzZWN0XCIgaXMgYWxsb2NhdGVkIDUwJSBvZiB0aGUgd2VpZ2h0OyBlYWNoIGVkZ2Vcblx0XHQqIHNwbGl0cyB0aGUgd2VpZ2h0IGJldHdlZW4gaXRzIG9yZyBhbmQgZHN0IGFjY29yZGluZyB0byB0aGVcblx0XHQqIHJlbGF0aXZlIGRpc3RhbmNlIHRvIFwiaXNlY3RcIi5cblx0XHQqL1xuXHRcdHZhciB0MSA9IEdlb20udmVydEwxZGlzdCggb3JnLCBpc2VjdCApO1xuXHRcdHZhciB0MiA9IEdlb20udmVydEwxZGlzdCggZHN0LCBpc2VjdCApO1xuXHRcdHZhciB3MCA9IDAuNSAqIHQyIC8gKHQxICsgdDIpO1xuXHRcdHZhciB3MSA9IDAuNSAqIHQxIC8gKHQxICsgdDIpO1xuXHRcdGlzZWN0LmNvb3Jkc1swXSArPSB3MCpvcmcuY29vcmRzWzBdICsgdzEqZHN0LmNvb3Jkc1swXTtcblx0XHRpc2VjdC5jb29yZHNbMV0gKz0gdzAqb3JnLmNvb3Jkc1sxXSArIHcxKmRzdC5jb29yZHNbMV07XG5cdFx0aXNlY3QuY29vcmRzWzJdICs9IHcwKm9yZy5jb29yZHNbMl0gKyB3MSpkc3QuY29vcmRzWzJdO1xuXHR9XG5cblxuXHQvL3N0YXRpYyB2b2lkIEdldEludGVyc2VjdERhdGEoIFRFU1N0ZXNzZWxhdG9yICp0ZXNzLCBURVNTdmVydGV4ICppc2VjdCwgVEVTU3ZlcnRleCAqb3JnVXAsIFRFU1N2ZXJ0ZXggKmRzdFVwLCBURVNTdmVydGV4ICpvcmdMbywgVEVTU3ZlcnRleCAqZHN0TG8gKVxuXHRTd2VlcC5nZXRJbnRlcnNlY3REYXRhID0gZnVuY3Rpb24oIHRlc3MsIGlzZWN0LCBvcmdVcCwgZHN0VXAsIG9yZ0xvLCBkc3RMbyApIHtcblx0XHQgLypcblx0XHQgKiBXZSd2ZSBjb21wdXRlZCBhIG5ldyBpbnRlcnNlY3Rpb24gcG9pbnQsIG5vdyB3ZSBuZWVkIGEgXCJkYXRhXCIgcG9pbnRlclxuXHRcdCAqIGZyb20gdGhlIHVzZXIgc28gdGhhdCB3ZSBjYW4gcmVmZXIgdG8gdGhpcyBuZXcgdmVydGV4IGluIHRoZVxuXHRcdCAqIHJlbmRlcmluZyBjYWxsYmFja3MuXG5cdFx0ICovXG5cdFx0aXNlY3QuY29vcmRzWzBdID0gaXNlY3QuY29vcmRzWzFdID0gaXNlY3QuY29vcmRzWzJdID0gMDtcblx0XHRpc2VjdC5pZHggPSAtMTtcblx0XHRTd2VlcC52ZXJ0ZXhXZWlnaHRzKCBpc2VjdCwgb3JnVXAsIGRzdFVwICk7XG5cdFx0U3dlZXAudmVydGV4V2VpZ2h0cyggaXNlY3QsIG9yZ0xvLCBkc3RMbyApO1xuXHR9XG5cblx0Ly9zdGF0aWMgaW50IENoZWNrRm9yUmlnaHRTcGxpY2UoIFRFU1N0ZXNzZWxhdG9yICp0ZXNzLCBBY3RpdmVSZWdpb24gKnJlZ1VwIClcblx0U3dlZXAuY2hlY2tGb3JSaWdodFNwbGljZSA9IGZ1bmN0aW9uKCB0ZXNzLCByZWdVcCApIHtcblx0XHQvKlxuXHRcdCogQ2hlY2sgdGhlIHVwcGVyIGFuZCBsb3dlciBlZGdlIG9mIFwicmVnVXBcIiwgdG8gbWFrZSBzdXJlIHRoYXQgdGhlXG5cdFx0KiBlVXAtPk9yZyBpcyBhYm92ZSBlTG8sIG9yIGVMby0+T3JnIGlzIGJlbG93IGVVcCAoZGVwZW5kaW5nIG9uIHdoaWNoXG5cdFx0KiBvcmlnaW4gaXMgbGVmdG1vc3QpLlxuXHRcdCpcblx0XHQqIFRoZSBtYWluIHB1cnBvc2UgaXMgdG8gc3BsaWNlIHJpZ2h0LWdvaW5nIGVkZ2VzIHdpdGggdGhlIHNhbWVcblx0XHQqIGRlc3QgdmVydGV4IGFuZCBuZWFybHkgaWRlbnRpY2FsIHNsb3BlcyAoaWUuIHdlIGNhbid0IGRpc3Rpbmd1aXNoXG5cdFx0KiB0aGUgc2xvcGVzIG51bWVyaWNhbGx5KS4gIEhvd2V2ZXIgdGhlIHNwbGljaW5nIGNhbiBhbHNvIGhlbHAgdXNcblx0XHQqIHRvIHJlY292ZXIgZnJvbSBudW1lcmljYWwgZXJyb3JzLiAgRm9yIGV4YW1wbGUsIHN1cHBvc2UgYXQgb25lXG5cdFx0KiBwb2ludCB3ZSBjaGVja2VkIGVVcCBhbmQgZUxvLCBhbmQgZGVjaWRlZCB0aGF0IGVVcC0+T3JnIGlzIGJhcmVseVxuXHRcdCogYWJvdmUgZUxvLiAgVGhlbiBsYXRlciwgd2Ugc3BsaXQgZUxvIGludG8gdHdvIGVkZ2VzIChlZy4gZnJvbVxuXHRcdCogYSBzcGxpY2Ugb3BlcmF0aW9uIGxpa2UgdGhpcyBvbmUpLiAgVGhpcyBjYW4gY2hhbmdlIHRoZSByZXN1bHQgb2Zcblx0XHQqIG91ciB0ZXN0IHNvIHRoYXQgbm93IGVVcC0+T3JnIGlzIGluY2lkZW50IHRvIGVMbywgb3IgYmFyZWx5IGJlbG93IGl0LlxuXHRcdCogV2UgbXVzdCBjb3JyZWN0IHRoaXMgY29uZGl0aW9uIHRvIG1haW50YWluIHRoZSBkaWN0aW9uYXJ5IGludmFyaWFudHMuXG5cdFx0KlxuXHRcdCogT25lIHBvc3NpYmlsaXR5IGlzIHRvIGNoZWNrIHRoZXNlIGVkZ2VzIGZvciBpbnRlcnNlY3Rpb24gYWdhaW5cblx0XHQqIChpZS4gQ2hlY2tGb3JJbnRlcnNlY3QpLiAgVGhpcyBpcyB3aGF0IHdlIGRvIGlmIHBvc3NpYmxlLiAgSG93ZXZlclxuXHRcdCogQ2hlY2tGb3JJbnRlcnNlY3QgcmVxdWlyZXMgdGhhdCB0ZXNzLT5ldmVudCBsaWVzIGJldHdlZW4gZVVwIGFuZCBlTG8sXG5cdFx0KiBzbyB0aGF0IGl0IGhhcyBzb21ldGhpbmcgdG8gZmFsbCBiYWNrIG9uIHdoZW4gdGhlIGludGVyc2VjdGlvblxuXHRcdCogY2FsY3VsYXRpb24gZ2l2ZXMgdXMgYW4gdW51c2FibGUgYW5zd2VyLiAgU28sIGZvciB0aG9zZSBjYXNlcyB3aGVyZVxuXHRcdCogd2UgY2FuJ3QgY2hlY2sgZm9yIGludGVyc2VjdGlvbiwgdGhpcyByb3V0aW5lIGZpeGVzIHRoZSBwcm9ibGVtXG5cdFx0KiBieSBqdXN0IHNwbGljaW5nIHRoZSBvZmZlbmRpbmcgdmVydGV4IGludG8gdGhlIG90aGVyIGVkZ2UuXG5cdFx0KiBUaGlzIGlzIGEgZ3VhcmFudGVlZCBzb2x1dGlvbiwgbm8gbWF0dGVyIGhvdyBkZWdlbmVyYXRlIHRoaW5ncyBnZXQuXG5cdFx0KiBCYXNpY2FsbHkgdGhpcyBpcyBhIGNvbWJpbmF0b3JpYWwgc29sdXRpb24gdG8gYSBudW1lcmljYWwgcHJvYmxlbS5cblx0XHQqL1xuXHRcdHZhciByZWdMbyA9IFN3ZWVwLnJlZ2lvbkJlbG93KHJlZ1VwKTtcblx0XHR2YXIgZVVwID0gcmVnVXAuZVVwO1xuXHRcdHZhciBlTG8gPSByZWdMby5lVXA7XG5cblx0XHRpZiggR2VvbS52ZXJ0TGVxKCBlVXAuT3JnLCBlTG8uT3JnICkpIHtcblx0XHRcdGlmKCBHZW9tLmVkZ2VTaWduKCBlTG8uRHN0LCBlVXAuT3JnLCBlTG8uT3JnICkgPiAwICkgcmV0dXJuIGZhbHNlO1xuXG5cdFx0XHQvKiBlVXAtPk9yZyBhcHBlYXJzIHRvIGJlIGJlbG93IGVMbyAqL1xuXHRcdFx0aWYoICEgR2VvbS52ZXJ0RXEoIGVVcC5PcmcsIGVMby5PcmcgKSkge1xuXHRcdFx0XHQvKiBTcGxpY2UgZVVwLT5PcmcgaW50byBlTG8gKi9cblx0XHRcdFx0dGVzcy5tZXNoLnNwbGl0RWRnZSggZUxvLlN5bSApO1xuXHRcdFx0XHR0ZXNzLm1lc2guc3BsaWNlKCBlVXAsIGVMby5PcHJldiApO1xuXHRcdFx0XHRyZWdVcC5kaXJ0eSA9IHJlZ0xvLmRpcnR5ID0gdHJ1ZTtcblxuXHRcdFx0fSBlbHNlIGlmKCBlVXAuT3JnICE9PSBlTG8uT3JnICkge1xuXHRcdFx0XHQvKiBtZXJnZSB0aGUgdHdvIHZlcnRpY2VzLCBkaXNjYXJkaW5nIGVVcC0+T3JnICovXG5cdFx0XHRcdHRlc3MucHEuZGVsZXRlKCBlVXAuT3JnLnBxSGFuZGxlICk7XG5cdFx0XHRcdFN3ZWVwLnNwbGljZU1lcmdlVmVydGljZXMoIHRlc3MsIGVMby5PcHJldiwgZVVwICk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmKCBHZW9tLmVkZ2VTaWduKCBlVXAuRHN0LCBlTG8uT3JnLCBlVXAuT3JnICkgPCAwICkgcmV0dXJuIGZhbHNlO1xuXG5cdFx0XHQvKiBlTG8tPk9yZyBhcHBlYXJzIHRvIGJlIGFib3ZlIGVVcCwgc28gc3BsaWNlIGVMby0+T3JnIGludG8gZVVwICovXG5cdFx0XHRTd2VlcC5yZWdpb25BYm92ZShyZWdVcCkuZGlydHkgPSByZWdVcC5kaXJ0eSA9IHRydWU7XG5cdFx0XHR0ZXNzLm1lc2guc3BsaXRFZGdlKCBlVXAuU3ltICk7XG5cdFx0XHR0ZXNzLm1lc2guc3BsaWNlKCBlTG8uT3ByZXYsIGVVcCApO1xuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdC8vc3RhdGljIGludCBDaGVja0ZvckxlZnRTcGxpY2UoIFRFU1N0ZXNzZWxhdG9yICp0ZXNzLCBBY3RpdmVSZWdpb24gKnJlZ1VwIClcblx0U3dlZXAuY2hlY2tGb3JMZWZ0U3BsaWNlID0gZnVuY3Rpb24oIHRlc3MsIHJlZ1VwICkge1xuXHRcdC8qXG5cdFx0KiBDaGVjayB0aGUgdXBwZXIgYW5kIGxvd2VyIGVkZ2Ugb2YgXCJyZWdVcFwiLCB0byBtYWtlIHN1cmUgdGhhdCB0aGVcblx0XHQqIGVVcC0+RHN0IGlzIGFib3ZlIGVMbywgb3IgZUxvLT5Ec3QgaXMgYmVsb3cgZVVwIChkZXBlbmRpbmcgb24gd2hpY2hcblx0XHQqIGRlc3RpbmF0aW9uIGlzIHJpZ2h0bW9zdCkuXG5cdFx0KlxuXHRcdCogVGhlb3JldGljYWxseSwgdGhpcyBzaG91bGQgYWx3YXlzIGJlIHRydWUuICBIb3dldmVyLCBzcGxpdHRpbmcgYW4gZWRnZVxuXHRcdCogaW50byB0d28gcGllY2VzIGNhbiBjaGFuZ2UgdGhlIHJlc3VsdHMgb2YgcHJldmlvdXMgdGVzdHMuICBGb3IgZXhhbXBsZSxcblx0XHQqIHN1cHBvc2UgYXQgb25lIHBvaW50IHdlIGNoZWNrZWQgZVVwIGFuZCBlTG8sIGFuZCBkZWNpZGVkIHRoYXQgZVVwLT5Ec3Rcblx0XHQqIGlzIGJhcmVseSBhYm92ZSBlTG8uICBUaGVuIGxhdGVyLCB3ZSBzcGxpdCBlTG8gaW50byB0d28gZWRnZXMgKGVnLiBmcm9tXG5cdFx0KiBhIHNwbGljZSBvcGVyYXRpb24gbGlrZSB0aGlzIG9uZSkuICBUaGlzIGNhbiBjaGFuZ2UgdGhlIHJlc3VsdCBvZlxuXHRcdCogdGhlIHRlc3Qgc28gdGhhdCBub3cgZVVwLT5Ec3QgaXMgaW5jaWRlbnQgdG8gZUxvLCBvciBiYXJlbHkgYmVsb3cgaXQuXG5cdFx0KiBXZSBtdXN0IGNvcnJlY3QgdGhpcyBjb25kaXRpb24gdG8gbWFpbnRhaW4gdGhlIGRpY3Rpb25hcnkgaW52YXJpYW50c1xuXHRcdCogKG90aGVyd2lzZSBuZXcgZWRnZXMgbWlnaHQgZ2V0IGluc2VydGVkIGluIHRoZSB3cm9uZyBwbGFjZSBpbiB0aGVcblx0XHQqIGRpY3Rpb25hcnksIGFuZCBiYWQgc3R1ZmYgd2lsbCBoYXBwZW4pLlxuXHRcdCpcblx0XHQqIFdlIGZpeCB0aGUgcHJvYmxlbSBieSBqdXN0IHNwbGljaW5nIHRoZSBvZmZlbmRpbmcgdmVydGV4IGludG8gdGhlXG5cdFx0KiBvdGhlciBlZGdlLlxuXHRcdCovXG5cdFx0dmFyIHJlZ0xvID0gU3dlZXAucmVnaW9uQmVsb3cocmVnVXApO1xuXHRcdHZhciBlVXAgPSByZWdVcC5lVXA7XG5cdFx0dmFyIGVMbyA9IHJlZ0xvLmVVcDtcblx0XHR2YXIgZTtcblxuXHRcdGFzc2VydCggISBHZW9tLnZlcnRFcSggZVVwLkRzdCwgZUxvLkRzdCApKTtcblxuXHRcdGlmKCBHZW9tLnZlcnRMZXEoIGVVcC5Ec3QsIGVMby5Ec3QgKSkge1xuXHRcdFx0aWYoIEdlb20uZWRnZVNpZ24oIGVVcC5Ec3QsIGVMby5Ec3QsIGVVcC5PcmcgKSA8IDAgKSByZXR1cm4gZmFsc2U7XG5cblx0XHRcdC8qIGVMby0+RHN0IGlzIGFib3ZlIGVVcCwgc28gc3BsaWNlIGVMby0+RHN0IGludG8gZVVwICovXG5cdFx0XHRTd2VlcC5yZWdpb25BYm92ZShyZWdVcCkuZGlydHkgPSByZWdVcC5kaXJ0eSA9IHRydWU7XG5cdFx0XHRlID0gdGVzcy5tZXNoLnNwbGl0RWRnZSggZVVwICk7XG5cdFx0XHR0ZXNzLm1lc2guc3BsaWNlKCBlTG8uU3ltLCBlICk7XG5cdFx0XHRlLkxmYWNlLmluc2lkZSA9IHJlZ1VwLmluc2lkZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYoIEdlb20uZWRnZVNpZ24oIGVMby5Ec3QsIGVVcC5Ec3QsIGVMby5PcmcgKSA+IDAgKSByZXR1cm4gZmFsc2U7XG5cblx0XHRcdC8qIGVVcC0+RHN0IGlzIGJlbG93IGVMbywgc28gc3BsaWNlIGVVcC0+RHN0IGludG8gZUxvICovXG5cdFx0XHRyZWdVcC5kaXJ0eSA9IHJlZ0xvLmRpcnR5ID0gdHJ1ZTtcblx0XHRcdGUgPSB0ZXNzLm1lc2guc3BsaXRFZGdlKCBlTG8gKTtcblx0XHRcdHRlc3MubWVzaC5zcGxpY2UoIGVVcC5MbmV4dCwgZUxvLlN5bSApO1xuXHRcdFx0ZS5SZmFjZS5pbnNpZGUgPSByZWdVcC5pbnNpZGU7XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblxuXHQvL3N0YXRpYyBpbnQgQ2hlY2tGb3JJbnRlcnNlY3QoIFRFU1N0ZXNzZWxhdG9yICp0ZXNzLCBBY3RpdmVSZWdpb24gKnJlZ1VwIClcblx0U3dlZXAuY2hlY2tGb3JJbnRlcnNlY3QgPSBmdW5jdGlvbiggdGVzcywgcmVnVXAgKSB7XG5cdFx0Lypcblx0XHQqIENoZWNrIHRoZSB1cHBlciBhbmQgbG93ZXIgZWRnZXMgb2YgdGhlIGdpdmVuIHJlZ2lvbiB0byBzZWUgaWZcblx0XHQqIHRoZXkgaW50ZXJzZWN0LiAgSWYgc28sIGNyZWF0ZSB0aGUgaW50ZXJzZWN0aW9uIGFuZCBhZGQgaXRcblx0XHQqIHRvIHRoZSBkYXRhIHN0cnVjdHVyZXMuXG5cdFx0KlxuXHRcdCogUmV0dXJucyBUUlVFIGlmIGFkZGluZyB0aGUgbmV3IGludGVyc2VjdGlvbiByZXN1bHRlZCBpbiBhIHJlY3Vyc2l2ZVxuXHRcdCogY2FsbCB0byBBZGRSaWdodEVkZ2VzKCk7IGluIHRoaXMgY2FzZSBhbGwgXCJkaXJ0eVwiIHJlZ2lvbnMgaGF2ZSBiZWVuXG5cdFx0KiBjaGVja2VkIGZvciBpbnRlcnNlY3Rpb25zLCBhbmQgcG9zc2libHkgcmVnVXAgaGFzIGJlZW4gZGVsZXRlZC5cblx0XHQqL1xuXHRcdHZhciByZWdMbyA9IFN3ZWVwLnJlZ2lvbkJlbG93KHJlZ1VwKTtcblx0XHR2YXIgZVVwID0gcmVnVXAuZVVwO1xuXHRcdHZhciBlTG8gPSByZWdMby5lVXA7XG5cdFx0dmFyIG9yZ1VwID0gZVVwLk9yZztcblx0XHR2YXIgb3JnTG8gPSBlTG8uT3JnO1xuXHRcdHZhciBkc3RVcCA9IGVVcC5Ec3Q7XG5cdFx0dmFyIGRzdExvID0gZUxvLkRzdDtcblx0XHR2YXIgdE1pblVwLCB0TWF4TG87XG5cdFx0dmFyIGlzZWN0ID0gbmV3IFRFU1N2ZXJ0ZXgsIG9yZ01pbjtcblx0XHR2YXIgZTtcblxuXHRcdGFzc2VydCggISBHZW9tLnZlcnRFcSggZHN0TG8sIGRzdFVwICkpO1xuXHRcdGFzc2VydCggR2VvbS5lZGdlU2lnbiggZHN0VXAsIHRlc3MuZXZlbnQsIG9yZ1VwICkgPD0gMCApO1xuXHRcdGFzc2VydCggR2VvbS5lZGdlU2lnbiggZHN0TG8sIHRlc3MuZXZlbnQsIG9yZ0xvICkgPj0gMCApO1xuXHRcdGFzc2VydCggb3JnVXAgIT09IHRlc3MuZXZlbnQgJiYgb3JnTG8gIT09IHRlc3MuZXZlbnQgKTtcblx0XHRhc3NlcnQoICEgcmVnVXAuZml4VXBwZXJFZGdlICYmICEgcmVnTG8uZml4VXBwZXJFZGdlICk7XG5cblx0XHRpZiggb3JnVXAgPT09IG9yZ0xvICkgcmV0dXJuIGZhbHNlO1x0LyogcmlnaHQgZW5kcG9pbnRzIGFyZSB0aGUgc2FtZSAqL1xuXG5cdFx0dE1pblVwID0gTWF0aC5taW4oIG9yZ1VwLnQsIGRzdFVwLnQgKTtcblx0XHR0TWF4TG8gPSBNYXRoLm1heCggb3JnTG8udCwgZHN0TG8udCApO1xuXHRcdGlmKCB0TWluVXAgPiB0TWF4TG8gKSByZXR1cm4gZmFsc2U7XHQvKiB0IHJhbmdlcyBkbyBub3Qgb3ZlcmxhcCAqL1xuXG5cdFx0aWYoIEdlb20udmVydExlcSggb3JnVXAsIG9yZ0xvICkpIHtcblx0XHRcdGlmKCBHZW9tLmVkZ2VTaWduKCBkc3RMbywgb3JnVXAsIG9yZ0xvICkgPiAwICkgcmV0dXJuIGZhbHNlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiggR2VvbS5lZGdlU2lnbiggZHN0VXAsIG9yZ0xvLCBvcmdVcCApIDwgMCApIHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvKiBBdCB0aGlzIHBvaW50IHRoZSBlZGdlcyBpbnRlcnNlY3QsIGF0IGxlYXN0IG1hcmdpbmFsbHkgKi9cblx0XHRTd2VlcC5kZWJ1Z0V2ZW50KCB0ZXNzICk7XG5cblx0XHRHZW9tLmludGVyc2VjdCggZHN0VXAsIG9yZ1VwLCBkc3RMbywgb3JnTG8sIGlzZWN0ICk7XG5cdFx0LyogVGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzIGFyZSBndWFyYW50ZWVkOiAqL1xuXHRcdGFzc2VydCggTWF0aC5taW4oIG9yZ1VwLnQsIGRzdFVwLnQgKSA8PSBpc2VjdC50ICk7XG5cdFx0YXNzZXJ0KCBpc2VjdC50IDw9IE1hdGgubWF4KCBvcmdMby50LCBkc3RMby50ICkpO1xuXHRcdGFzc2VydCggTWF0aC5taW4oIGRzdExvLnMsIGRzdFVwLnMgKSA8PSBpc2VjdC5zICk7XG5cdFx0YXNzZXJ0KCBpc2VjdC5zIDw9IE1hdGgubWF4KCBvcmdMby5zLCBvcmdVcC5zICkpO1xuXG5cdFx0aWYoIEdlb20udmVydExlcSggaXNlY3QsIHRlc3MuZXZlbnQgKSkge1xuXHRcdFx0LyogVGhlIGludGVyc2VjdGlvbiBwb2ludCBsaWVzIHNsaWdodGx5IHRvIHRoZSBsZWZ0IG9mIHRoZSBzd2VlcCBsaW5lLFxuXHRcdFx0KiBzbyBtb3ZlIGl0IHVudGlsIGl0JydzIHNsaWdodGx5IHRvIHRoZSByaWdodCBvZiB0aGUgc3dlZXAgbGluZS5cblx0XHRcdCogKElmIHdlIGhhZCBwZXJmZWN0IG51bWVyaWNhbCBwcmVjaXNpb24sIHRoaXMgd291bGQgbmV2ZXIgaGFwcGVuXG5cdFx0XHQqIGluIHRoZSBmaXJzdCBwbGFjZSkuICBUaGUgZWFzaWVzdCBhbmQgc2FmZXN0IHRoaW5nIHRvIGRvIGlzXG5cdFx0XHQqIHJlcGxhY2UgdGhlIGludGVyc2VjdGlvbiBieSB0ZXNzLT5ldmVudC5cblx0XHRcdCovXG5cdFx0XHRpc2VjdC5zID0gdGVzcy5ldmVudC5zO1xuXHRcdFx0aXNlY3QudCA9IHRlc3MuZXZlbnQudDtcblx0XHR9XG5cdFx0LyogU2ltaWxhcmx5LCBpZiB0aGUgY29tcHV0ZWQgaW50ZXJzZWN0aW9uIGxpZXMgdG8gdGhlIHJpZ2h0IG9mIHRoZVxuXHRcdCogcmlnaHRtb3N0IG9yaWdpbiAod2hpY2ggc2hvdWxkIHJhcmVseSBoYXBwZW4pLCBpdCBjYW4gY2F1c2Vcblx0XHQqIHVuYmVsaWV2YWJsZSBpbmVmZmljaWVuY3kgb24gc3VmZmljaWVudGx5IGRlZ2VuZXJhdGUgaW5wdXRzLlxuXHRcdCogKElmIHlvdSBoYXZlIHRoZSB0ZXN0IHByb2dyYW0sIHRyeSBydW5uaW5nIHRlc3Q1NC5kIHdpdGggdGhlXG5cdFx0KiBcIlggem9vbVwiIG9wdGlvbiB0dXJuZWQgb24pLlxuXHRcdCovXG5cdFx0b3JnTWluID0gR2VvbS52ZXJ0TGVxKCBvcmdVcCwgb3JnTG8gKSA/IG9yZ1VwIDogb3JnTG87XG5cdFx0aWYoIEdlb20udmVydExlcSggb3JnTWluLCBpc2VjdCApKSB7XG5cdFx0XHRpc2VjdC5zID0gb3JnTWluLnM7XG5cdFx0XHRpc2VjdC50ID0gb3JnTWluLnQ7XG5cdFx0fVxuXG5cdFx0aWYoIEdlb20udmVydEVxKCBpc2VjdCwgb3JnVXAgKSB8fCBHZW9tLnZlcnRFcSggaXNlY3QsIG9yZ0xvICkpIHtcblx0XHRcdC8qIEVhc3kgY2FzZSAtLSBpbnRlcnNlY3Rpb24gYXQgb25lIG9mIHRoZSByaWdodCBlbmRwb2ludHMgKi9cblx0XHRcdFN3ZWVwLmNoZWNrRm9yUmlnaHRTcGxpY2UoIHRlc3MsIHJlZ1VwICk7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0aWYoICAgICghIEdlb20udmVydEVxKCBkc3RVcCwgdGVzcy5ldmVudCApXG5cdFx0XHQmJiBHZW9tLmVkZ2VTaWduKCBkc3RVcCwgdGVzcy5ldmVudCwgaXNlY3QgKSA+PSAwKVxuXHRcdFx0fHwgKCEgR2VvbS52ZXJ0RXEoIGRzdExvLCB0ZXNzLmV2ZW50IClcblx0XHRcdCYmIEdlb20uZWRnZVNpZ24oIGRzdExvLCB0ZXNzLmV2ZW50LCBpc2VjdCApIDw9IDAgKSlcblx0XHR7XG5cdFx0XHQvKiBWZXJ5IHVudXN1YWwgLS0gdGhlIG5ldyB1cHBlciBvciBsb3dlciBlZGdlIHdvdWxkIHBhc3Mgb24gdGhlXG5cdFx0XHQqIHdyb25nIHNpZGUgb2YgdGhlIHN3ZWVwIGV2ZW50LCBvciB0aHJvdWdoIGl0LiAgVGhpcyBjYW4gaGFwcGVuXG5cdFx0XHQqIGR1ZSB0byB2ZXJ5IHNtYWxsIG51bWVyaWNhbCBlcnJvcnMgaW4gdGhlIGludGVyc2VjdGlvbiBjYWxjdWxhdGlvbi5cblx0XHRcdCovXG5cdFx0XHRpZiggZHN0TG8gPT09IHRlc3MuZXZlbnQgKSB7XG5cdFx0XHRcdC8qIFNwbGljZSBkc3RMbyBpbnRvIGVVcCwgYW5kIHByb2Nlc3MgdGhlIG5ldyByZWdpb24ocykgKi9cblx0XHRcdFx0dGVzcy5tZXNoLnNwbGl0RWRnZSggZVVwLlN5bSApO1xuXHRcdFx0XHR0ZXNzLm1lc2guc3BsaWNlKCBlTG8uU3ltLCBlVXAgKTtcblx0XHRcdFx0cmVnVXAgPSBTd2VlcC50b3BMZWZ0UmVnaW9uKCB0ZXNzLCByZWdVcCApO1xuXHQvL1x0XHRcdGlmIChyZWdVcCA9PSBOVUxMKSBsb25nam1wKHRlc3MtPmVudiwxKTtcblx0XHRcdFx0ZVVwID0gU3dlZXAucmVnaW9uQmVsb3cocmVnVXApLmVVcDtcblx0XHRcdFx0U3dlZXAuZmluaXNoTGVmdFJlZ2lvbnMoIHRlc3MsIFN3ZWVwLnJlZ2lvbkJlbG93KHJlZ1VwKSwgcmVnTG8gKTtcblx0XHRcdFx0U3dlZXAuYWRkUmlnaHRFZGdlcyggdGVzcywgcmVnVXAsIGVVcC5PcHJldiwgZVVwLCBlVXAsIHRydWUgKTtcblx0XHRcdFx0cmV0dXJuIFRSVUU7XG5cdFx0XHR9XG5cdFx0XHRpZiggZHN0VXAgPT09IHRlc3MuZXZlbnQgKSB7XG5cdFx0XHRcdC8qIFNwbGljZSBkc3RVcCBpbnRvIGVMbywgYW5kIHByb2Nlc3MgdGhlIG5ldyByZWdpb24ocykgKi9cblx0XHRcdFx0dGVzcy5tZXNoLnNwbGl0RWRnZSggZUxvLlN5bSApO1xuXHRcdFx0XHR0ZXNzLm1lc2guc3BsaWNlKCBlVXAuTG5leHQsIGVMby5PcHJldiApOyBcblx0XHRcdFx0cmVnTG8gPSByZWdVcDtcblx0XHRcdFx0cmVnVXAgPSBTd2VlcC50b3BSaWdodFJlZ2lvbiggcmVnVXAgKTtcblx0XHRcdFx0ZSA9IFN3ZWVwLnJlZ2lvbkJlbG93KHJlZ1VwKS5lVXAuUnByZXY7XG5cdFx0XHRcdHJlZ0xvLmVVcCA9IGVMby5PcHJldjtcblx0XHRcdFx0ZUxvID0gU3dlZXAuZmluaXNoTGVmdFJlZ2lvbnMoIHRlc3MsIHJlZ0xvLCBudWxsICk7XG5cdFx0XHRcdFN3ZWVwLmFkZFJpZ2h0RWRnZXMoIHRlc3MsIHJlZ1VwLCBlTG8uT25leHQsIGVVcC5ScHJldiwgZSwgdHJ1ZSApO1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdC8qIFNwZWNpYWwgY2FzZTogY2FsbGVkIGZyb20gQ29ubmVjdFJpZ2h0VmVydGV4LiAgSWYgZWl0aGVyXG5cdFx0XHQqIGVkZ2UgcGFzc2VzIG9uIHRoZSB3cm9uZyBzaWRlIG9mIHRlc3MtPmV2ZW50LCBzcGxpdCBpdFxuXHRcdFx0KiAoYW5kIHdhaXQgZm9yIENvbm5lY3RSaWdodFZlcnRleCB0byBzcGxpY2UgaXQgYXBwcm9wcmlhdGVseSkuXG5cdFx0XHQqL1xuXHRcdFx0aWYoIEdlb20uZWRnZVNpZ24oIGRzdFVwLCB0ZXNzLmV2ZW50LCBpc2VjdCApID49IDAgKSB7XG5cdFx0XHRcdFN3ZWVwLnJlZ2lvbkFib3ZlKHJlZ1VwKS5kaXJ0eSA9IHJlZ1VwLmRpcnR5ID0gdHJ1ZTtcblx0XHRcdFx0dGVzcy5tZXNoLnNwbGl0RWRnZSggZVVwLlN5bSApO1xuXHRcdFx0XHRlVXAuT3JnLnMgPSB0ZXNzLmV2ZW50LnM7XG5cdFx0XHRcdGVVcC5PcmcudCA9IHRlc3MuZXZlbnQudDtcblx0XHRcdH1cblx0XHRcdGlmKCBHZW9tLmVkZ2VTaWduKCBkc3RMbywgdGVzcy5ldmVudCwgaXNlY3QgKSA8PSAwICkge1xuXHRcdFx0XHRyZWdVcC5kaXJ0eSA9IHJlZ0xvLmRpcnR5ID0gdHJ1ZTtcblx0XHRcdFx0dGVzcy5tZXNoLnNwbGl0RWRnZSggZUxvLlN5bSApO1xuXHRcdFx0XHRlTG8uT3JnLnMgPSB0ZXNzLmV2ZW50LnM7XG5cdFx0XHRcdGVMby5PcmcudCA9IHRlc3MuZXZlbnQudDtcblx0XHRcdH1cblx0XHRcdC8qIGxlYXZlIHRoZSByZXN0IGZvciBDb25uZWN0UmlnaHRWZXJ0ZXggKi9cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvKiBHZW5lcmFsIGNhc2UgLS0gc3BsaXQgYm90aCBlZGdlcywgc3BsaWNlIGludG8gbmV3IHZlcnRleC5cblx0XHQqIFdoZW4gd2UgZG8gdGhlIHNwbGljZSBvcGVyYXRpb24sIHRoZSBvcmRlciBvZiB0aGUgYXJndW1lbnRzIGlzXG5cdFx0KiBhcmJpdHJhcnkgYXMgZmFyIGFzIGNvcnJlY3RuZXNzIGdvZXMuICBIb3dldmVyLCB3aGVuIHRoZSBvcGVyYXRpb25cblx0XHQqIGNyZWF0ZXMgYSBuZXcgZmFjZSwgdGhlIHdvcmsgZG9uZSBpcyBwcm9wb3J0aW9uYWwgdG8gdGhlIHNpemUgb2Zcblx0XHQqIHRoZSBuZXcgZmFjZS4gIFdlIGV4cGVjdCB0aGUgZmFjZXMgaW4gdGhlIHByb2Nlc3NlZCBwYXJ0IG9mXG5cdFx0KiB0aGUgbWVzaCAoaWUuIGVVcC0+TGZhY2UpIHRvIGJlIHNtYWxsZXIgdGhhbiB0aGUgZmFjZXMgaW4gdGhlXG5cdFx0KiB1bnByb2Nlc3NlZCBvcmlnaW5hbCBjb250b3VycyAod2hpY2ggd2lsbCBiZSBlTG8tPk9wcmV2LT5MZmFjZSkuXG5cdFx0Ki9cblx0XHR0ZXNzLm1lc2guc3BsaXRFZGdlKCBlVXAuU3ltICk7XG5cdFx0dGVzcy5tZXNoLnNwbGl0RWRnZSggZUxvLlN5bSApO1xuXHRcdHRlc3MubWVzaC5zcGxpY2UoIGVMby5PcHJldiwgZVVwICk7XG5cdFx0ZVVwLk9yZy5zID0gaXNlY3Qucztcblx0XHRlVXAuT3JnLnQgPSBpc2VjdC50O1xuXHRcdGVVcC5PcmcucHFIYW5kbGUgPSB0ZXNzLnBxLmluc2VydCggZVVwLk9yZyApO1xuXHRcdFN3ZWVwLmdldEludGVyc2VjdERhdGEoIHRlc3MsIGVVcC5PcmcsIG9yZ1VwLCBkc3RVcCwgb3JnTG8sIGRzdExvICk7XG5cdFx0U3dlZXAucmVnaW9uQWJvdmUocmVnVXApLmRpcnR5ID0gcmVnVXAuZGlydHkgPSByZWdMby5kaXJ0eSA9IHRydWU7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0Ly9zdGF0aWMgdm9pZCBXYWxrRGlydHlSZWdpb25zKCBURVNTdGVzc2VsYXRvciAqdGVzcywgQWN0aXZlUmVnaW9uICpyZWdVcCApXG5cdFN3ZWVwLndhbGtEaXJ0eVJlZ2lvbnMgPSBmdW5jdGlvbiggdGVzcywgcmVnVXAgKSB7XG5cdFx0Lypcblx0XHQqIFdoZW4gdGhlIHVwcGVyIG9yIGxvd2VyIGVkZ2Ugb2YgYW55IHJlZ2lvbiBjaGFuZ2VzLCB0aGUgcmVnaW9uIGlzXG5cdFx0KiBtYXJrZWQgXCJkaXJ0eVwiLiAgVGhpcyByb3V0aW5lIHdhbGtzIHRocm91Z2ggYWxsIHRoZSBkaXJ0eSByZWdpb25zXG5cdFx0KiBhbmQgbWFrZXMgc3VyZSB0aGF0IHRoZSBkaWN0aW9uYXJ5IGludmFyaWFudHMgYXJlIHNhdGlzZmllZFxuXHRcdCogKHNlZSB0aGUgY29tbWVudHMgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGlzIGZpbGUpLiAgT2YgY291cnNlXG5cdFx0KiBuZXcgZGlydHkgcmVnaW9ucyBjYW4gYmUgY3JlYXRlZCBhcyB3ZSBtYWtlIGNoYW5nZXMgdG8gcmVzdG9yZVxuXHRcdCogdGhlIGludmFyaWFudHMuXG5cdFx0Ki9cblx0XHR2YXIgcmVnTG8gPSBTd2VlcC5yZWdpb25CZWxvdyhyZWdVcCk7XG5cdFx0dmFyIGVVcCwgZUxvO1xuXG5cdFx0Zm9yKCA7OyApIHtcblx0XHRcdC8qIEZpbmQgdGhlIGxvd2VzdCBkaXJ0eSByZWdpb24gKHdlIHdhbGsgZnJvbSB0aGUgYm90dG9tIHVwKS4gKi9cblx0XHRcdHdoaWxlKCByZWdMby5kaXJ0eSApIHtcblx0XHRcdFx0cmVnVXAgPSByZWdMbztcblx0XHRcdFx0cmVnTG8gPSBTd2VlcC5yZWdpb25CZWxvdyhyZWdMbyk7XG5cdFx0XHR9XG5cdFx0XHRpZiggISByZWdVcC5kaXJ0eSApIHtcblx0XHRcdFx0cmVnTG8gPSByZWdVcDtcblx0XHRcdFx0cmVnVXAgPSBTd2VlcC5yZWdpb25BYm92ZSggcmVnVXAgKTtcblx0XHRcdFx0aWYoIHJlZ1VwID09IG51bGwgfHwgISByZWdVcC5kaXJ0eSApIHtcblx0XHRcdFx0XHQvKiBXZSd2ZSB3YWxrZWQgYWxsIHRoZSBkaXJ0eSByZWdpb25zICovXG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZWdVcC5kaXJ0eSA9IGZhbHNlO1xuXHRcdFx0ZVVwID0gcmVnVXAuZVVwO1xuXHRcdFx0ZUxvID0gcmVnTG8uZVVwO1xuXG5cdFx0XHRpZiggZVVwLkRzdCAhPT0gZUxvLkRzdCApIHtcblx0XHRcdFx0LyogQ2hlY2sgdGhhdCB0aGUgZWRnZSBvcmRlcmluZyBpcyBvYmV5ZWQgYXQgdGhlIERzdCB2ZXJ0aWNlcy4gKi9cblx0XHRcdFx0aWYoIFN3ZWVwLmNoZWNrRm9yTGVmdFNwbGljZSggdGVzcywgcmVnVXAgKSkge1xuXG5cdFx0XHRcdFx0LyogSWYgdGhlIHVwcGVyIG9yIGxvd2VyIGVkZ2Ugd2FzIG1hcmtlZCBmaXhVcHBlckVkZ2UsIHRoZW5cblx0XHRcdFx0XHQqIHdlIG5vIGxvbmdlciBuZWVkIGl0IChzaW5jZSB0aGVzZSBlZGdlcyBhcmUgbmVlZGVkIG9ubHkgZm9yXG5cdFx0XHRcdFx0KiB2ZXJ0aWNlcyB3aGljaCBvdGhlcndpc2UgaGF2ZSBubyByaWdodC1nb2luZyBlZGdlcykuXG5cdFx0XHRcdFx0Ki9cblx0XHRcdFx0XHRpZiggcmVnTG8uZml4VXBwZXJFZGdlICkge1xuXHRcdFx0XHRcdFx0U3dlZXAuZGVsZXRlUmVnaW9uKCB0ZXNzLCByZWdMbyApO1xuXHRcdFx0XHRcdFx0dGVzcy5tZXNoLmRlbGV0ZSggZUxvICk7XG5cdFx0XHRcdFx0XHRyZWdMbyA9IFN3ZWVwLnJlZ2lvbkJlbG93KCByZWdVcCApO1xuXHRcdFx0XHRcdFx0ZUxvID0gcmVnTG8uZVVwO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiggcmVnVXAuZml4VXBwZXJFZGdlICkge1xuXHRcdFx0XHRcdFx0U3dlZXAuZGVsZXRlUmVnaW9uKCB0ZXNzLCByZWdVcCApO1xuXHRcdFx0XHRcdFx0dGVzcy5tZXNoLmRlbGV0ZSggZVVwICk7XG5cdFx0XHRcdFx0XHRyZWdVcCA9IFN3ZWVwLnJlZ2lvbkFib3ZlKCByZWdMbyApO1xuXHRcdFx0XHRcdFx0ZVVwID0gcmVnVXAuZVVwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYoIGVVcC5PcmcgIT09IGVMby5PcmcgKSB7XG5cdFx0XHRcdGlmKCAgICBlVXAuRHN0ICE9PSBlTG8uRHN0XG5cdFx0XHRcdFx0JiYgISByZWdVcC5maXhVcHBlckVkZ2UgJiYgISByZWdMby5maXhVcHBlckVkZ2Vcblx0XHRcdFx0XHQmJiAoZVVwLkRzdCA9PT0gdGVzcy5ldmVudCB8fCBlTG8uRHN0ID09PSB0ZXNzLmV2ZW50KSApXG5cdFx0XHRcdHtcblx0XHRcdFx0XHQvKiBXaGVuIGFsbCBlbHNlIGZhaWxzIGluIENoZWNrRm9ySW50ZXJzZWN0KCksIGl0IHVzZXMgdGVzcy0+ZXZlbnRcblx0XHRcdFx0XHQqIGFzIHRoZSBpbnRlcnNlY3Rpb24gbG9jYXRpb24uICBUbyBtYWtlIHRoaXMgcG9zc2libGUsIGl0IHJlcXVpcmVzXG5cdFx0XHRcdFx0KiB0aGF0IHRlc3MtPmV2ZW50IGxpZSBiZXR3ZWVuIHRoZSB1cHBlciBhbmQgbG93ZXIgZWRnZXMsIGFuZCBhbHNvXG5cdFx0XHRcdFx0KiB0aGF0IG5laXRoZXIgb2YgdGhlc2UgaXMgbWFya2VkIGZpeFVwcGVyRWRnZSAoc2luY2UgaW4gdGhlIHdvcnN0XG5cdFx0XHRcdFx0KiBjYXNlIGl0IG1pZ2h0IHNwbGljZSBvbmUgb2YgdGhlc2UgZWRnZXMgaW50byB0ZXNzLT5ldmVudCwgYW5kXG5cdFx0XHRcdFx0KiB2aW9sYXRlIHRoZSBpbnZhcmlhbnQgdGhhdCBmaXhhYmxlIGVkZ2VzIGFyZSB0aGUgb25seSByaWdodC1nb2luZ1xuXHRcdFx0XHRcdCogZWRnZSBmcm9tIHRoZWlyIGFzc29jaWF0ZWQgdmVydGV4KS5cblx0XHRcdFx0XHQqL1xuXHRcdFx0XHRcdGlmKCBTd2VlcC5jaGVja0ZvckludGVyc2VjdCggdGVzcywgcmVnVXAgKSkge1xuXHRcdFx0XHRcdFx0LyogV2Fsa0RpcnR5UmVnaW9ucygpIHdhcyBjYWxsZWQgcmVjdXJzaXZlbHk7IHdlJ3JlIGRvbmUgKi9cblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0LyogRXZlbiB0aG91Z2ggd2UgY2FuJ3QgdXNlIENoZWNrRm9ySW50ZXJzZWN0KCksIHRoZSBPcmcgdmVydGljZXNcblx0XHRcdFx0XHQqIG1heSB2aW9sYXRlIHRoZSBkaWN0aW9uYXJ5IGVkZ2Ugb3JkZXJpbmcuICBDaGVjayBhbmQgY29ycmVjdCB0aGlzLlxuXHRcdFx0XHRcdCovXG5cdFx0XHRcdFx0U3dlZXAuY2hlY2tGb3JSaWdodFNwbGljZSggdGVzcywgcmVnVXAgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYoIGVVcC5PcmcgPT09IGVMby5PcmcgJiYgZVVwLkRzdCA9PT0gZUxvLkRzdCApIHtcblx0XHRcdFx0LyogQSBkZWdlbmVyYXRlIGxvb3AgY29uc2lzdGluZyBvZiBvbmx5IHR3byBlZGdlcyAtLSBkZWxldGUgaXQuICovXG5cdFx0XHRcdFN3ZWVwLmFkZFdpbmRpbmcoIGVMbywgZVVwICk7XG5cdFx0XHRcdFN3ZWVwLmRlbGV0ZVJlZ2lvbiggdGVzcywgcmVnVXAgKTtcblx0XHRcdFx0dGVzcy5tZXNoLmRlbGV0ZSggZVVwICk7XG5cdFx0XHRcdHJlZ1VwID0gU3dlZXAucmVnaW9uQWJvdmUoIHJlZ0xvICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblxuXHQvL3N0YXRpYyB2b2lkIENvbm5lY3RSaWdodFZlcnRleCggVEVTU3Rlc3NlbGF0b3IgKnRlc3MsIEFjdGl2ZVJlZ2lvbiAqcmVnVXAsIFRFU1NoYWxmRWRnZSAqZUJvdHRvbUxlZnQgKVxuXHRTd2VlcC5jb25uZWN0UmlnaHRWZXJ0ZXggPSBmdW5jdGlvbiggdGVzcywgcmVnVXAsIGVCb3R0b21MZWZ0ICkge1xuXHRcdC8qXG5cdFx0KiBQdXJwb3NlOiBjb25uZWN0IGEgXCJyaWdodFwiIHZlcnRleCB2RXZlbnQgKG9uZSB3aGVyZSBhbGwgZWRnZXMgZ28gbGVmdClcblx0XHQqIHRvIHRoZSB1bnByb2Nlc3NlZCBwb3J0aW9uIG9mIHRoZSBtZXNoLiAgU2luY2UgdGhlcmUgYXJlIG5vIHJpZ2h0LWdvaW5nXG5cdFx0KiBlZGdlcywgdHdvIHJlZ2lvbnMgKG9uZSBhYm92ZSB2RXZlbnQgYW5kIG9uZSBiZWxvdykgYXJlIGJlaW5nIG1lcmdlZFxuXHRcdCogaW50byBvbmUuICBcInJlZ1VwXCIgaXMgdGhlIHVwcGVyIG9mIHRoZXNlIHR3byByZWdpb25zLlxuXHRcdCpcblx0XHQqIFRoZXJlIGFyZSB0d28gcmVhc29ucyBmb3IgZG9pbmcgdGhpcyAoYWRkaW5nIGEgcmlnaHQtZ29pbmcgZWRnZSk6XG5cdFx0KiAgLSBpZiB0aGUgdHdvIHJlZ2lvbnMgYmVpbmcgbWVyZ2VkIGFyZSBcImluc2lkZVwiLCB3ZSBtdXN0IGFkZCBhbiBlZGdlXG5cdFx0KiAgICB0byBrZWVwIHRoZW0gc2VwYXJhdGVkICh0aGUgY29tYmluZWQgcmVnaW9uIHdvdWxkIG5vdCBiZSBtb25vdG9uZSkuXG5cdFx0KiAgLSBpbiBhbnkgY2FzZSwgd2UgbXVzdCBsZWF2ZSBzb21lIHJlY29yZCBvZiB2RXZlbnQgaW4gdGhlIGRpY3Rpb25hcnksXG5cdFx0KiAgICBzbyB0aGF0IHdlIGNhbiBtZXJnZSB2RXZlbnQgd2l0aCBmZWF0dXJlcyB0aGF0IHdlIGhhdmUgbm90IHNlZW4geWV0LlxuXHRcdCogICAgRm9yIGV4YW1wbGUsIG1heWJlIHRoZXJlIGlzIGEgdmVydGljYWwgZWRnZSB3aGljaCBwYXNzZXMganVzdCB0b1xuXHRcdCogICAgdGhlIHJpZ2h0IG9mIHZFdmVudDsgd2Ugd291bGQgbGlrZSB0byBzcGxpY2UgdkV2ZW50IGludG8gdGhpcyBlZGdlLlxuXHRcdCpcblx0XHQqIEhvd2V2ZXIsIHdlIGRvbid0IHdhbnQgdG8gY29ubmVjdCB2RXZlbnQgdG8ganVzdCBhbnkgdmVydGV4LiAgV2UgZG9uJyd0XG5cdFx0KiB3YW50IHRoZSBuZXcgZWRnZSB0byBjcm9zcyBhbnkgb3RoZXIgZWRnZXM7IG90aGVyd2lzZSB3ZSB3aWxsIGNyZWF0ZVxuXHRcdCogaW50ZXJzZWN0aW9uIHZlcnRpY2VzIGV2ZW4gd2hlbiB0aGUgaW5wdXQgZGF0YSBoYWQgbm8gc2VsZi1pbnRlcnNlY3Rpb25zLlxuXHRcdCogKFRoaXMgaXMgYSBiYWQgdGhpbmc7IGlmIHRoZSB1c2VyJ3MgaW5wdXQgZGF0YSBoYXMgbm8gaW50ZXJzZWN0aW9ucyxcblx0XHQqIHdlIGRvbid0IHdhbnQgdG8gZ2VuZXJhdGUgYW55IGZhbHNlIGludGVyc2VjdGlvbnMgb3Vyc2VsdmVzLilcblx0XHQqXG5cdFx0KiBPdXIgZXZlbnR1YWwgZ29hbCBpcyB0byBjb25uZWN0IHZFdmVudCB0byB0aGUgbGVmdG1vc3QgdW5wcm9jZXNzZWRcblx0XHQqIHZlcnRleCBvZiB0aGUgY29tYmluZWQgcmVnaW9uICh0aGUgdW5pb24gb2YgcmVnVXAgYW5kIHJlZ0xvKS5cblx0XHQqIEJ1dCBiZWNhdXNlIG9mIHVuc2VlbiB2ZXJ0aWNlcyB3aXRoIGFsbCByaWdodC1nb2luZyBlZGdlcywgYW5kIGFsc29cblx0XHQqIG5ldyB2ZXJ0aWNlcyB3aGljaCBtYXkgYmUgY3JlYXRlZCBieSBlZGdlIGludGVyc2VjdGlvbnMsIHdlIGRvbicndFxuXHRcdCoga25vdyB3aGVyZSB0aGF0IGxlZnRtb3N0IHVucHJvY2Vzc2VkIHZlcnRleCBpcy4gIEluIHRoZSBtZWFudGltZSwgd2Vcblx0XHQqIGNvbm5lY3QgdkV2ZW50IHRvIHRoZSBjbG9zZXN0IHZlcnRleCBvZiBlaXRoZXIgY2hhaW4sIGFuZCBtYXJrIHRoZSByZWdpb25cblx0XHQqIGFzIFwiZml4VXBwZXJFZGdlXCIuICBUaGlzIGZsYWcgc2F5cyB0byBkZWxldGUgYW5kIHJlY29ubmVjdCB0aGlzIGVkZ2Vcblx0XHQqIHRvIHRoZSBuZXh0IHByb2Nlc3NlZCB2ZXJ0ZXggb24gdGhlIGJvdW5kYXJ5IG9mIHRoZSBjb21iaW5lZCByZWdpb24uXG5cdFx0KiBRdWl0ZSBwb3NzaWJseSB0aGUgdmVydGV4IHdlIGNvbm5lY3RlZCB0byB3aWxsIHR1cm4gb3V0IHRvIGJlIHRoZVxuXHRcdCogY2xvc2VzdCBvbmUsIGluIHdoaWNoIGNhc2Ugd2Ugd29uJyd0IG5lZWQgdG8gbWFrZSBhbnkgY2hhbmdlcy5cblx0XHQqL1xuXHRcdHZhciBlTmV3O1xuXHRcdHZhciBlVG9wTGVmdCA9IGVCb3R0b21MZWZ0Lk9uZXh0O1xuXHRcdHZhciByZWdMbyA9IFN3ZWVwLnJlZ2lvbkJlbG93KHJlZ1VwKTtcblx0XHR2YXIgZVVwID0gcmVnVXAuZVVwO1xuXHRcdHZhciBlTG8gPSByZWdMby5lVXA7XG5cdFx0dmFyIGRlZ2VuZXJhdGUgPSBmYWxzZTtcblxuXHRcdGlmKCBlVXAuRHN0ICE9PSBlTG8uRHN0ICkge1xuXHRcdFx0U3dlZXAuY2hlY2tGb3JJbnRlcnNlY3QoIHRlc3MsIHJlZ1VwICk7XG5cdFx0fVxuXG5cdFx0LyogUG9zc2libGUgbmV3IGRlZ2VuZXJhY2llczogdXBwZXIgb3IgbG93ZXIgZWRnZSBvZiByZWdVcCBtYXkgcGFzc1xuXHRcdCogdGhyb3VnaCB2RXZlbnQsIG9yIG1heSBjb2luY2lkZSB3aXRoIG5ldyBpbnRlcnNlY3Rpb24gdmVydGV4XG5cdFx0Ki9cblx0XHRpZiggR2VvbS52ZXJ0RXEoIGVVcC5PcmcsIHRlc3MuZXZlbnQgKSkge1xuXHRcdFx0dGVzcy5tZXNoLnNwbGljZSggZVRvcExlZnQuT3ByZXYsIGVVcCApO1xuXHRcdFx0cmVnVXAgPSBTd2VlcC50b3BMZWZ0UmVnaW9uKCB0ZXNzLCByZWdVcCApO1xuXHRcdFx0ZVRvcExlZnQgPSBTd2VlcC5yZWdpb25CZWxvdyggcmVnVXAgKS5lVXA7XG5cdFx0XHRTd2VlcC5maW5pc2hMZWZ0UmVnaW9ucyggdGVzcywgU3dlZXAucmVnaW9uQmVsb3cocmVnVXApLCByZWdMbyApO1xuXHRcdFx0ZGVnZW5lcmF0ZSA9IHRydWU7XG5cdFx0fVxuXHRcdGlmKCBHZW9tLnZlcnRFcSggZUxvLk9yZywgdGVzcy5ldmVudCApKSB7XG5cdFx0XHR0ZXNzLm1lc2guc3BsaWNlKCBlQm90dG9tTGVmdCwgZUxvLk9wcmV2ICk7XG5cdFx0XHRlQm90dG9tTGVmdCA9IFN3ZWVwLmZpbmlzaExlZnRSZWdpb25zKCB0ZXNzLCByZWdMbywgbnVsbCApO1xuXHRcdFx0ZGVnZW5lcmF0ZSA9IHRydWU7XG5cdFx0fVxuXHRcdGlmKCBkZWdlbmVyYXRlICkge1xuXHRcdFx0U3dlZXAuYWRkUmlnaHRFZGdlcyggdGVzcywgcmVnVXAsIGVCb3R0b21MZWZ0Lk9uZXh0LCBlVG9wTGVmdCwgZVRvcExlZnQsIHRydWUgKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvKiBOb24tZGVnZW5lcmF0ZSBzaXR1YXRpb24gLS0gbmVlZCB0byBhZGQgYSB0ZW1wb3JhcnksIGZpeGFibGUgZWRnZS5cblx0XHQqIENvbm5lY3QgdG8gdGhlIGNsb3NlciBvZiBlTG8tPk9yZywgZVVwLT5PcmcuXG5cdFx0Ki9cblx0XHRpZiggR2VvbS52ZXJ0TGVxKCBlTG8uT3JnLCBlVXAuT3JnICkpIHtcblx0XHRcdGVOZXcgPSBlTG8uT3ByZXY7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGVOZXcgPSBlVXA7XG5cdFx0fVxuXHRcdGVOZXcgPSB0ZXNzLm1lc2guY29ubmVjdCggZUJvdHRvbUxlZnQuTHByZXYsIGVOZXcgKTtcblxuXHRcdC8qIFByZXZlbnQgY2xlYW51cCwgb3RoZXJ3aXNlIGVOZXcgbWlnaHQgZGlzYXBwZWFyIGJlZm9yZSB3ZSd2ZSBldmVuXG5cdFx0KiBoYWQgYSBjaGFuY2UgdG8gbWFyayBpdCBhcyBhIHRlbXBvcmFyeSBlZGdlLlxuXHRcdCovXG5cdFx0U3dlZXAuYWRkUmlnaHRFZGdlcyggdGVzcywgcmVnVXAsIGVOZXcsIGVOZXcuT25leHQsIGVOZXcuT25leHQsIGZhbHNlICk7XG5cdFx0ZU5ldy5TeW0uYWN0aXZlUmVnaW9uLmZpeFVwcGVyRWRnZSA9IHRydWU7XG5cdFx0U3dlZXAud2Fsa0RpcnR5UmVnaW9ucyggdGVzcywgcmVnVXAgKTtcblx0fVxuXG5cdC8qIEJlY2F1c2UgdmVydGljZXMgYXQgZXhhY3RseSB0aGUgc2FtZSBsb2NhdGlvbiBhcmUgbWVyZ2VkIHRvZ2V0aGVyXG5cdCogYmVmb3JlIHdlIHByb2Nlc3MgdGhlIHN3ZWVwIGV2ZW50LCBzb21lIGRlZ2VuZXJhdGUgY2FzZXMgY2FuJ3Qgb2NjdXIuXG5cdCogSG93ZXZlciBpZiBzb21lb25lIGV2ZW50dWFsbHkgbWFrZXMgdGhlIG1vZGlmaWNhdGlvbnMgcmVxdWlyZWQgdG9cblx0KiBtZXJnZSBmZWF0dXJlcyB3aGljaCBhcmUgY2xvc2UgdG9nZXRoZXIsIHRoZSBjYXNlcyBiZWxvdyBtYXJrZWRcblx0KiBUT0xFUkFOQ0VfTk9OWkVSTyB3aWxsIGJlIHVzZWZ1bC4gIFRoZXkgd2VyZSBkZWJ1Z2dlZCBiZWZvcmUgdGhlXG5cdCogY29kZSB0byBtZXJnZSBpZGVudGljYWwgdmVydGljZXMgaW4gdGhlIG1haW4gbG9vcCB3YXMgYWRkZWQuXG5cdCovXG5cdC8vI2RlZmluZSBUT0xFUkFOQ0VfTk9OWkVST1x0RkFMU0VcblxuXHQvL3N0YXRpYyB2b2lkIENvbm5lY3RMZWZ0RGVnZW5lcmF0ZSggVEVTU3Rlc3NlbGF0b3IgKnRlc3MsIEFjdGl2ZVJlZ2lvbiAqcmVnVXAsIFRFU1N2ZXJ0ZXggKnZFdmVudCApXG5cdFN3ZWVwLmNvbm5lY3RMZWZ0RGVnZW5lcmF0ZSA9IGZ1bmN0aW9uKCB0ZXNzLCByZWdVcCwgdkV2ZW50ICkge1xuXHRcdC8qXG5cdFx0KiBUaGUgZXZlbnQgdmVydGV4IGxpZXMgZXhhY3R5IG9uIGFuIGFscmVhZHktcHJvY2Vzc2VkIGVkZ2Ugb3IgdmVydGV4LlxuXHRcdCogQWRkaW5nIHRoZSBuZXcgdmVydGV4IGludm9sdmVzIHNwbGljaW5nIGl0IGludG8gdGhlIGFscmVhZHktcHJvY2Vzc2VkXG5cdFx0KiBwYXJ0IG9mIHRoZSBtZXNoLlxuXHRcdCovXG5cdFx0dmFyIGUsIGVUb3BMZWZ0LCBlVG9wUmlnaHQsIGVMYXN0O1xuXHRcdHZhciByZWc7XG5cblx0XHRlID0gcmVnVXAuZVVwO1xuXHRcdGlmKCBHZW9tLnZlcnRFcSggZS5PcmcsIHZFdmVudCApKSB7XG5cdFx0XHQvKiBlLT5PcmcgaXMgYW4gdW5wcm9jZXNzZWQgdmVydGV4IC0ganVzdCBjb21iaW5lIHRoZW0sIGFuZCB3YWl0XG5cdFx0XHQqIGZvciBlLT5PcmcgdG8gYmUgcHVsbGVkIGZyb20gdGhlIHF1ZXVlXG5cdFx0XHQqL1xuXHRcdFx0YXNzZXJ0KCBmYWxzZSAvKlRPTEVSQU5DRV9OT05aRVJPKi8gKTtcblx0XHRcdFN3ZWVwLnNwbGljZU1lcmdlVmVydGljZXMoIHRlc3MsIGUsIHZFdmVudC5hbkVkZ2UgKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiggISBHZW9tLnZlcnRFcSggZS5Ec3QsIHZFdmVudCApKSB7XG5cdFx0XHQvKiBHZW5lcmFsIGNhc2UgLS0gc3BsaWNlIHZFdmVudCBpbnRvIGVkZ2UgZSB3aGljaCBwYXNzZXMgdGhyb3VnaCBpdCAqL1xuXHRcdFx0dGVzcy5tZXNoLnNwbGl0RWRnZSggZS5TeW0gKTtcblx0XHRcdGlmKCByZWdVcC5maXhVcHBlckVkZ2UgKSB7XG5cdFx0XHRcdC8qIFRoaXMgZWRnZSB3YXMgZml4YWJsZSAtLSBkZWxldGUgdW51c2VkIHBvcnRpb24gb2Ygb3JpZ2luYWwgZWRnZSAqL1xuXHRcdFx0XHR0ZXNzLm1lc2guZGVsZXRlKCBlLk9uZXh0ICk7XG5cdFx0XHRcdHJlZ1VwLmZpeFVwcGVyRWRnZSA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0dGVzcy5tZXNoLnNwbGljZSggdkV2ZW50LmFuRWRnZSwgZSApO1xuXHRcdFx0U3dlZXAuc3dlZXBFdmVudCggdGVzcywgdkV2ZW50ICk7XHQvKiByZWN1cnNlICovXG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0LyogdkV2ZW50IGNvaW5jaWRlcyB3aXRoIGUtPkRzdCwgd2hpY2ggaGFzIGFscmVhZHkgYmVlbiBwcm9jZXNzZWQuXG5cdFx0KiBTcGxpY2UgaW4gdGhlIGFkZGl0aW9uYWwgcmlnaHQtZ29pbmcgZWRnZXMuXG5cdFx0Ki9cblx0XHRhc3NlcnQoIGZhbHNlIC8qVE9MRVJBTkNFX05PTlpFUk8qLyApO1xuXHRcdHJlZ1VwID0gU3dlZXAudG9wUmlnaHRSZWdpb24oIHJlZ1VwICk7XG5cdFx0cmVnID0gU3dlZXAucmVnaW9uQmVsb3coIHJlZ1VwICk7XG5cdFx0ZVRvcFJpZ2h0ID0gcmVnLmVVcC5TeW07XG5cdFx0ZVRvcExlZnQgPSBlTGFzdCA9IGVUb3BSaWdodC5PbmV4dDtcblx0XHRpZiggcmVnLmZpeFVwcGVyRWRnZSApIHtcblx0XHRcdC8qIEhlcmUgZS0+RHN0IGhhcyBvbmx5IGEgc2luZ2xlIGZpeGFibGUgZWRnZSBnb2luZyByaWdodC5cblx0XHRcdCogV2UgY2FuIGRlbGV0ZSBpdCBzaW5jZSBub3cgd2UgaGF2ZSBzb21lIHJlYWwgcmlnaHQtZ29pbmcgZWRnZXMuXG5cdFx0XHQqL1xuXHRcdFx0YXNzZXJ0KCBlVG9wTGVmdCAhPT0gZVRvcFJpZ2h0ICk7ICAgLyogdGhlcmUgYXJlIHNvbWUgbGVmdCBlZGdlcyB0b28gKi9cblx0XHRcdFN3ZWVwLmRlbGV0ZVJlZ2lvbiggdGVzcywgcmVnICk7XG5cdFx0XHR0ZXNzLm1lc2guZGVsZXRlKCBlVG9wUmlnaHQgKTtcblx0XHRcdGVUb3BSaWdodCA9IGVUb3BMZWZ0Lk9wcmV2O1xuXHRcdH1cblx0XHR0ZXNzLm1lc2guc3BsaWNlKCB2RXZlbnQuYW5FZGdlLCBlVG9wUmlnaHQgKTtcblx0XHRpZiggISBHZW9tLmVkZ2VHb2VzTGVmdCggZVRvcExlZnQgKSkge1xuXHRcdFx0LyogZS0+RHN0IGhhZCBubyBsZWZ0LWdvaW5nIGVkZ2VzIC0tIGluZGljYXRlIHRoaXMgdG8gQWRkUmlnaHRFZGdlcygpICovXG5cdFx0XHRlVG9wTGVmdCA9IG51bGw7XG5cdFx0fVxuXHRcdFN3ZWVwLmFkZFJpZ2h0RWRnZXMoIHRlc3MsIHJlZ1VwLCBlVG9wUmlnaHQuT25leHQsIGVMYXN0LCBlVG9wTGVmdCwgdHJ1ZSApO1xuXHR9XG5cblxuXHQvL3N0YXRpYyB2b2lkIENvbm5lY3RMZWZ0VmVydGV4KCBURVNTdGVzc2VsYXRvciAqdGVzcywgVEVTU3ZlcnRleCAqdkV2ZW50IClcblx0U3dlZXAuY29ubmVjdExlZnRWZXJ0ZXggPSBmdW5jdGlvbiggdGVzcywgdkV2ZW50ICkge1xuXHRcdC8qXG5cdFx0KiBQdXJwb3NlOiBjb25uZWN0IGEgXCJsZWZ0XCIgdmVydGV4IChvbmUgd2hlcmUgYm90aCBlZGdlcyBnbyByaWdodClcblx0XHQqIHRvIHRoZSBwcm9jZXNzZWQgcG9ydGlvbiBvZiB0aGUgbWVzaC4gIExldCBSIGJlIHRoZSBhY3RpdmUgcmVnaW9uXG5cdFx0KiBjb250YWluaW5nIHZFdmVudCwgYW5kIGxldCBVIGFuZCBMIGJlIHRoZSB1cHBlciBhbmQgbG93ZXIgZWRnZVxuXHRcdCogY2hhaW5zIG9mIFIuICBUaGVyZSBhcmUgdHdvIHBvc3NpYmlsaXRpZXM6XG5cdFx0KlxuXHRcdCogLSB0aGUgbm9ybWFsIGNhc2U6IHNwbGl0IFIgaW50byB0d28gcmVnaW9ucywgYnkgY29ubmVjdGluZyB2RXZlbnQgdG9cblx0XHQqICAgdGhlIHJpZ2h0bW9zdCB2ZXJ0ZXggb2YgVSBvciBMIGx5aW5nIHRvIHRoZSBsZWZ0IG9mIHRoZSBzd2VlcCBsaW5lXG5cdFx0KlxuXHRcdCogLSB0aGUgZGVnZW5lcmF0ZSBjYXNlOiBpZiB2RXZlbnQgaXMgY2xvc2UgZW5vdWdoIHRvIFUgb3IgTCwgd2Vcblx0XHQqICAgbWVyZ2UgdkV2ZW50IGludG8gdGhhdCBlZGdlIGNoYWluLiAgVGhlIHN1YmNhc2VzIGFyZTpcblx0XHQqXHQtIG1lcmdpbmcgd2l0aCB0aGUgcmlnaHRtb3N0IHZlcnRleCBvZiBVIG9yIExcblx0XHQqXHQtIG1lcmdpbmcgd2l0aCB0aGUgYWN0aXZlIGVkZ2Ugb2YgVSBvciBMXG5cdFx0Klx0LSBtZXJnaW5nIHdpdGggYW4gYWxyZWFkeS1wcm9jZXNzZWQgcG9ydGlvbiBvZiBVIG9yIExcblx0XHQqL1xuXHRcdHZhciByZWdVcCwgcmVnTG8sIHJlZztcblx0XHR2YXIgZVVwLCBlTG8sIGVOZXc7XG5cdFx0dmFyIHRtcCA9IG5ldyBBY3RpdmVSZWdpb24oKTtcblxuXHRcdC8qIGFzc2VydCggdkV2ZW50LT5hbkVkZ2UtPk9uZXh0LT5PbmV4dCA9PSB2RXZlbnQtPmFuRWRnZSApOyAqL1xuXG5cdFx0LyogR2V0IGEgcG9pbnRlciB0byB0aGUgYWN0aXZlIHJlZ2lvbiBjb250YWluaW5nIHZFdmVudCAqL1xuXHRcdHRtcC5lVXAgPSB2RXZlbnQuYW5FZGdlLlN5bTtcblx0XHQvKiBfX0dMX0RJQ1RMSVNUS0VZICovIC8qIHRlc3NEaWN0TGlzdFNlYXJjaCAqL1xuXHRcdHJlZ1VwID0gdGVzcy5kaWN0LnNlYXJjaCggdG1wICkua2V5O1xuXHRcdHJlZ0xvID0gU3dlZXAucmVnaW9uQmVsb3coIHJlZ1VwICk7XG5cdFx0aWYoICFyZWdMbyApIHtcblx0XHRcdC8vIFRoaXMgbWF5IGhhcHBlbiBpZiB0aGUgaW5wdXQgcG9seWdvbiBpcyBjb3BsYW5hci5cblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0ZVVwID0gcmVnVXAuZVVwO1xuXHRcdGVMbyA9IHJlZ0xvLmVVcDtcblxuXHRcdC8qIFRyeSBtZXJnaW5nIHdpdGggVSBvciBMIGZpcnN0ICovXG5cdFx0aWYoIEdlb20uZWRnZVNpZ24oIGVVcC5Ec3QsIHZFdmVudCwgZVVwLk9yZyApID09PSAwLjAgKSB7XG5cdFx0XHRTd2VlcC5jb25uZWN0TGVmdERlZ2VuZXJhdGUoIHRlc3MsIHJlZ1VwLCB2RXZlbnQgKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvKiBDb25uZWN0IHZFdmVudCB0byByaWdodG1vc3QgcHJvY2Vzc2VkIHZlcnRleCBvZiBlaXRoZXIgY2hhaW4uXG5cdFx0KiBlLT5Ec3QgaXMgdGhlIHZlcnRleCB0aGF0IHdlIHdpbGwgY29ubmVjdCB0byB2RXZlbnQuXG5cdFx0Ki9cblx0XHRyZWcgPSBHZW9tLnZlcnRMZXEoIGVMby5Ec3QsIGVVcC5Ec3QgKSA/IHJlZ1VwIDogcmVnTG87XG5cblx0XHRpZiggcmVnVXAuaW5zaWRlIHx8IHJlZy5maXhVcHBlckVkZ2UpIHtcblx0XHRcdGlmKCByZWcgPT09IHJlZ1VwICkge1xuXHRcdFx0XHRlTmV3ID0gdGVzcy5tZXNoLmNvbm5lY3QoIHZFdmVudC5hbkVkZ2UuU3ltLCBlVXAuTG5leHQgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciB0ZW1wSGFsZkVkZ2UgPSB0ZXNzLm1lc2guY29ubmVjdCggZUxvLkRuZXh0LCB2RXZlbnQuYW5FZGdlKTtcblx0XHRcdFx0ZU5ldyA9IHRlbXBIYWxmRWRnZS5TeW07XG5cdFx0XHR9XG5cdFx0XHRpZiggcmVnLmZpeFVwcGVyRWRnZSApIHtcblx0XHRcdFx0U3dlZXAuZml4VXBwZXJFZGdlKCB0ZXNzLCByZWcsIGVOZXcgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFN3ZWVwLmNvbXB1dGVXaW5kaW5nKCB0ZXNzLCBTd2VlcC5hZGRSZWdpb25CZWxvdyggdGVzcywgcmVnVXAsIGVOZXcgKSk7XG5cdFx0XHR9XG5cdFx0XHRTd2VlcC5zd2VlcEV2ZW50KCB0ZXNzLCB2RXZlbnQgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0LyogVGhlIG5ldyB2ZXJ0ZXggaXMgaW4gYSByZWdpb24gd2hpY2ggZG9lcyBub3QgYmVsb25nIHRvIHRoZSBwb2x5Z29uLlxuXHRcdFx0KiBXZSBkb24nJ3QgbmVlZCB0byBjb25uZWN0IHRoaXMgdmVydGV4IHRvIHRoZSByZXN0IG9mIHRoZSBtZXNoLlxuXHRcdFx0Ki9cblx0XHRcdFN3ZWVwLmFkZFJpZ2h0RWRnZXMoIHRlc3MsIHJlZ1VwLCB2RXZlbnQuYW5FZGdlLCB2RXZlbnQuYW5FZGdlLCBudWxsLCB0cnVlICk7XG5cdFx0fVxuXHR9O1xuXG5cblx0Ly9zdGF0aWMgdm9pZCBTd2VlcEV2ZW50KCBURVNTdGVzc2VsYXRvciAqdGVzcywgVEVTU3ZlcnRleCAqdkV2ZW50IClcblx0U3dlZXAuc3dlZXBFdmVudCA9IGZ1bmN0aW9uKCB0ZXNzLCB2RXZlbnQgKSB7XG5cdFx0Lypcblx0XHQqIERvZXMgZXZlcnl0aGluZyBuZWNlc3Nhcnkgd2hlbiB0aGUgc3dlZXAgbGluZSBjcm9zc2VzIGEgdmVydGV4LlxuXHRcdCogVXBkYXRlcyB0aGUgbWVzaCBhbmQgdGhlIGVkZ2UgZGljdGlvbmFyeS5cblx0XHQqL1xuXG5cdFx0dGVzcy5ldmVudCA9IHZFdmVudDtcdFx0LyogZm9yIGFjY2VzcyBpbiBFZGdlTGVxKCkgKi9cblx0XHRTd2VlcC5kZWJ1Z0V2ZW50KCB0ZXNzICk7XG5cblx0XHQvKiBDaGVjayBpZiB0aGlzIHZlcnRleCBpcyB0aGUgcmlnaHQgZW5kcG9pbnQgb2YgYW4gZWRnZSB0aGF0IGlzXG5cdFx0KiBhbHJlYWR5IGluIHRoZSBkaWN0aW9uYXJ5LiAgSW4gdGhpcyBjYXNlIHdlIGRvbid0IG5lZWQgdG8gd2FzdGVcblx0XHQqIHRpbWUgc2VhcmNoaW5nIGZvciB0aGUgbG9jYXRpb24gdG8gaW5zZXJ0IG5ldyBlZGdlcy5cblx0XHQqL1xuXHRcdHZhciBlID0gdkV2ZW50LmFuRWRnZTtcblx0XHR3aGlsZSggZS5hY3RpdmVSZWdpb24gPT09IG51bGwgKSB7XG5cdFx0XHRlID0gZS5PbmV4dDtcblx0XHRcdGlmKCBlID09IHZFdmVudC5hbkVkZ2UgKSB7XG5cdFx0XHRcdC8qIEFsbCBlZGdlcyBnbyByaWdodCAtLSBub3QgaW5jaWRlbnQgdG8gYW55IHByb2Nlc3NlZCBlZGdlcyAqL1xuXHRcdFx0XHRTd2VlcC5jb25uZWN0TGVmdFZlcnRleCggdGVzcywgdkV2ZW50ICk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvKiBQcm9jZXNzaW5nIGNvbnNpc3RzIG9mIHR3byBwaGFzZXM6IGZpcnN0IHdlIFwiZmluaXNoXCIgYWxsIHRoZVxuXHRcdCogYWN0aXZlIHJlZ2lvbnMgd2hlcmUgYm90aCB0aGUgdXBwZXIgYW5kIGxvd2VyIGVkZ2VzIHRlcm1pbmF0ZVxuXHRcdCogYXQgdkV2ZW50IChpZS4gdkV2ZW50IGlzIGNsb3Npbmcgb2ZmIHRoZXNlIHJlZ2lvbnMpLlxuXHRcdCogV2UgbWFyayB0aGVzZSBmYWNlcyBcImluc2lkZVwiIG9yIFwib3V0c2lkZVwiIHRoZSBwb2x5Z29uIGFjY29yZGluZ1xuXHRcdCogdG8gdGhlaXIgd2luZGluZyBudW1iZXIsIGFuZCBkZWxldGUgdGhlIGVkZ2VzIGZyb20gdGhlIGRpY3Rpb25hcnkuXG5cdFx0KiBUaGlzIHRha2VzIGNhcmUgb2YgYWxsIHRoZSBsZWZ0LWdvaW5nIGVkZ2VzIGZyb20gdkV2ZW50LlxuXHRcdCovXG5cdFx0dmFyIHJlZ1VwID0gU3dlZXAudG9wTGVmdFJlZ2lvbiggdGVzcywgZS5hY3RpdmVSZWdpb24gKTtcblx0XHRhc3NlcnQoIHJlZ1VwICE9PSBudWxsICk7XG5cdC8vXHRpZiAocmVnVXAgPT0gTlVMTCkgbG9uZ2ptcCh0ZXNzLT5lbnYsMSk7XG5cdFx0dmFyIHJlZyA9IFN3ZWVwLnJlZ2lvbkJlbG93KCByZWdVcCApO1xuXHRcdHZhciBlVG9wTGVmdCA9IHJlZy5lVXA7XG5cdFx0dmFyIGVCb3R0b21MZWZ0ID0gU3dlZXAuZmluaXNoTGVmdFJlZ2lvbnMoIHRlc3MsIHJlZywgbnVsbCApO1xuXG5cdFx0LyogTmV4dCB3ZSBwcm9jZXNzIGFsbCB0aGUgcmlnaHQtZ29pbmcgZWRnZXMgZnJvbSB2RXZlbnQuICBUaGlzXG5cdFx0KiBpbnZvbHZlcyBhZGRpbmcgdGhlIGVkZ2VzIHRvIHRoZSBkaWN0aW9uYXJ5LCBhbmQgY3JlYXRpbmcgdGhlXG5cdFx0KiBhc3NvY2lhdGVkIFwiYWN0aXZlIHJlZ2lvbnNcIiB3aGljaCByZWNvcmQgaW5mb3JtYXRpb24gYWJvdXQgdGhlXG5cdFx0KiByZWdpb25zIGJldHdlZW4gYWRqYWNlbnQgZGljdGlvbmFyeSBlZGdlcy5cblx0XHQqL1xuXHRcdGlmKCBlQm90dG9tTGVmdC5PbmV4dCA9PT0gZVRvcExlZnQgKSB7XG5cdFx0XHQvKiBObyByaWdodC1nb2luZyBlZGdlcyAtLSBhZGQgYSB0ZW1wb3JhcnkgXCJmaXhhYmxlXCIgZWRnZSAqL1xuXHRcdFx0U3dlZXAuY29ubmVjdFJpZ2h0VmVydGV4KCB0ZXNzLCByZWdVcCwgZUJvdHRvbUxlZnQgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0U3dlZXAuYWRkUmlnaHRFZGdlcyggdGVzcywgcmVnVXAsIGVCb3R0b21MZWZ0Lk9uZXh0LCBlVG9wTGVmdCwgZVRvcExlZnQsIHRydWUgKTtcblx0XHR9XG5cdH07XG5cblxuXHQvKiBNYWtlIHRoZSBzZW50aW5lbCBjb29yZGluYXRlcyBiaWcgZW5vdWdoIHRoYXQgdGhleSB3aWxsIG5ldmVyIGJlXG5cdCogbWVyZ2VkIHdpdGggcmVhbCBpbnB1dCBmZWF0dXJlcy5cblx0Ki9cblxuXHQvL3N0YXRpYyB2b2lkIEFkZFNlbnRpbmVsKCBURVNTdGVzc2VsYXRvciAqdGVzcywgVEVTU3JlYWwgc21pbiwgVEVTU3JlYWwgc21heCwgVEVTU3JlYWwgdCApXG5cdFN3ZWVwLmFkZFNlbnRpbmVsID0gZnVuY3Rpb24oIHRlc3MsIHNtaW4sIHNtYXgsIHQgKSB7XG5cdFx0Lypcblx0XHQqIFdlIGFkZCB0d28gc2VudGluZWwgZWRnZXMgYWJvdmUgYW5kIGJlbG93IGFsbCBvdGhlciBlZGdlcyxcblx0XHQqIHRvIGF2b2lkIHNwZWNpYWwgY2FzZXMgYXQgdGhlIHRvcCBhbmQgYm90dG9tLlxuXHRcdCovXG5cdFx0dmFyIHJlZyA9IG5ldyBBY3RpdmVSZWdpb24oKTtcblx0XHR2YXIgZSA9IHRlc3MubWVzaC5tYWtlRWRnZSgpO1xuXHQvL1x0aWYgKGUgPT0gTlVMTCkgbG9uZ2ptcCh0ZXNzLT5lbnYsMSk7XG5cblx0XHRlLk9yZy5zID0gc21heDtcblx0XHRlLk9yZy50ID0gdDtcblx0XHRlLkRzdC5zID0gc21pbjtcblx0XHRlLkRzdC50ID0gdDtcblx0XHR0ZXNzLmV2ZW50ID0gZS5Ec3Q7XHRcdC8qIGluaXRpYWxpemUgaXQgKi9cblxuXHRcdHJlZy5lVXAgPSBlO1xuXHRcdHJlZy53aW5kaW5nTnVtYmVyID0gMDtcblx0XHRyZWcuaW5zaWRlID0gZmFsc2U7XG5cdFx0cmVnLmZpeFVwcGVyRWRnZSA9IGZhbHNlO1xuXHRcdHJlZy5zZW50aW5lbCA9IHRydWU7XG5cdFx0cmVnLmRpcnR5ID0gZmFsc2U7XG5cdFx0cmVnLm5vZGVVcCA9IHRlc3MuZGljdC5pbnNlcnQoIHJlZyApO1xuXHQvL1x0aWYgKHJlZy0+bm9kZVVwID09IE5VTEwpIGxvbmdqbXAodGVzcy0+ZW52LDEpO1xuXHR9XG5cblxuXHQvL3N0YXRpYyB2b2lkIEluaXRFZGdlRGljdCggVEVTU3Rlc3NlbGF0b3IgKnRlc3MgKVxuXHRTd2VlcC5pbml0RWRnZURpY3QgPSBmdW5jdGlvbiggdGVzcyApIHtcblx0XHQvKlxuXHRcdCogV2UgbWFpbnRhaW4gYW4gb3JkZXJpbmcgb2YgZWRnZSBpbnRlcnNlY3Rpb25zIHdpdGggdGhlIHN3ZWVwIGxpbmUuXG5cdFx0KiBUaGlzIG9yZGVyIGlzIG1haW50YWluZWQgaW4gYSBkeW5hbWljIGRpY3Rpb25hcnkuXG5cdFx0Ki9cblx0XHR0ZXNzLmRpY3QgPSBuZXcgRGljdCggdGVzcywgU3dlZXAuZWRnZUxlcSApO1xuXHQvL1x0aWYgKHRlc3MtPmRpY3QgPT0gTlVMTCkgbG9uZ2ptcCh0ZXNzLT5lbnYsMSk7XG5cblx0XHR2YXIgdyA9ICh0ZXNzLmJtYXhbMF0gLSB0ZXNzLmJtaW5bMF0pO1xuXHRcdHZhciBoID0gKHRlc3MuYm1heFsxXSAtIHRlc3MuYm1pblsxXSk7XG5cblx0XHR2YXIgc21pbiA9IHRlc3MuYm1pblswXSAtIHc7XG5cdFx0dmFyIHNtYXggPSB0ZXNzLmJtYXhbMF0gKyB3O1xuXHRcdHZhciB0bWluID0gdGVzcy5ibWluWzFdIC0gaDtcblx0XHR2YXIgdG1heCA9IHRlc3MuYm1heFsxXSArIGg7XG5cblx0XHRTd2VlcC5hZGRTZW50aW5lbCggdGVzcywgc21pbiwgc21heCwgdG1pbiApO1xuXHRcdFN3ZWVwLmFkZFNlbnRpbmVsKCB0ZXNzLCBzbWluLCBzbWF4LCB0bWF4ICk7XG5cdH1cblxuXG5cdFN3ZWVwLmRvbmVFZGdlRGljdCA9IGZ1bmN0aW9uKCB0ZXNzIClcblx0e1xuXHRcdHZhciByZWc7XG5cdFx0dmFyIGZpeGVkRWRnZXMgPSAwO1xuXG5cdFx0d2hpbGUoIChyZWcgPSB0ZXNzLmRpY3QubWluKCkua2V5KSAhPT0gbnVsbCApIHtcblx0XHRcdC8qXG5cdFx0XHQqIEF0IHRoZSBlbmQgb2YgYWxsIHByb2Nlc3NpbmcsIHRoZSBkaWN0aW9uYXJ5IHNob3VsZCBjb250YWluXG5cdFx0XHQqIG9ubHkgdGhlIHR3byBzZW50aW5lbCBlZGdlcywgcGx1cyBhdCBtb3N0IG9uZSBcImZpeGFibGVcIiBlZGdlXG5cdFx0XHQqIGNyZWF0ZWQgYnkgQ29ubmVjdFJpZ2h0VmVydGV4KCkuXG5cdFx0XHQqL1xuXHRcdFx0aWYoICEgcmVnLnNlbnRpbmVsICkge1xuXHRcdFx0XHRhc3NlcnQoIHJlZy5maXhVcHBlckVkZ2UgKTtcblx0XHRcdFx0YXNzZXJ0KCArK2ZpeGVkRWRnZXMgPT0gMSApO1xuXHRcdFx0fVxuXHRcdFx0YXNzZXJ0KCByZWcud2luZGluZ051bWJlciA9PSAwICk7XG5cdFx0XHRTd2VlcC5kZWxldGVSZWdpb24oIHRlc3MsIHJlZyApO1xuXHRcdFx0LyogICAgdGVzc01lc2hEZWxldGUoIHJlZy0+ZVVwICk7Ki9cblx0XHR9XG5cdC8vXHRkaWN0RGVsZXRlRGljdCggJnRlc3MtPmFsbG9jLCB0ZXNzLT5kaWN0ICk7XG5cdH1cblxuXG5cdFN3ZWVwLnJlbW92ZURlZ2VuZXJhdGVFZGdlcyA9IGZ1bmN0aW9uKCB0ZXNzICkge1xuXHRcdC8qXG5cdFx0KiBSZW1vdmUgemVyby1sZW5ndGggZWRnZXMsIGFuZCBjb250b3VycyB3aXRoIGZld2VyIHRoYW4gMyB2ZXJ0aWNlcy5cblx0XHQqL1xuXHRcdHZhciBlLCBlTmV4dCwgZUxuZXh0O1xuXHRcdHZhciBlSGVhZCA9IHRlc3MubWVzaC5lSGVhZDtcblxuXHRcdC8qTElOVEVEKi9cblx0XHRmb3IoIGUgPSBlSGVhZC5uZXh0OyBlICE9PSBlSGVhZDsgZSA9IGVOZXh0ICkge1xuXHRcdFx0ZU5leHQgPSBlLm5leHQ7XG5cdFx0XHRlTG5leHQgPSBlLkxuZXh0O1xuXG5cdFx0XHRpZiggR2VvbS52ZXJ0RXEoIGUuT3JnLCBlLkRzdCApICYmIGUuTG5leHQuTG5leHQgIT09IGUgKSB7XG5cdFx0XHRcdC8qIFplcm8tbGVuZ3RoIGVkZ2UsIGNvbnRvdXIgaGFzIGF0IGxlYXN0IDMgZWRnZXMgKi9cblx0XHRcdFx0U3dlZXAuc3BsaWNlTWVyZ2VWZXJ0aWNlcyggdGVzcywgZUxuZXh0LCBlICk7XHQvKiBkZWxldGVzIGUtPk9yZyAqL1xuXHRcdFx0XHR0ZXNzLm1lc2guZGVsZXRlKCBlICk7IC8qIGUgaXMgYSBzZWxmLWxvb3AgKi9cblx0XHRcdFx0ZSA9IGVMbmV4dDtcblx0XHRcdFx0ZUxuZXh0ID0gZS5MbmV4dDtcblx0XHRcdH1cblx0XHRcdGlmKCBlTG5leHQuTG5leHQgPT09IGUgKSB7XG5cdFx0XHRcdC8qIERlZ2VuZXJhdGUgY29udG91ciAob25lIG9yIHR3byBlZGdlcykgKi9cblx0XHRcdFx0aWYoIGVMbmV4dCAhPT0gZSApIHtcblx0XHRcdFx0XHRpZiggZUxuZXh0ID09PSBlTmV4dCB8fCBlTG5leHQgPT09IGVOZXh0LlN5bSApIHsgZU5leHQgPSBlTmV4dC5uZXh0OyB9XG5cdFx0XHRcdFx0dGVzcy5tZXNoLmRlbGV0ZSggZUxuZXh0ICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYoIGUgPT09IGVOZXh0IHx8IGUgPT09IGVOZXh0LlN5bSApIHsgZU5leHQgPSBlTmV4dC5uZXh0OyB9XG5cdFx0XHRcdHRlc3MubWVzaC5kZWxldGUoIGUgKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRTd2VlcC5pbml0UHJpb3JpdHlRID0gZnVuY3Rpb24oIHRlc3MgKSB7XG5cdFx0Lypcblx0XHQqIEluc2VydCBhbGwgdmVydGljZXMgaW50byB0aGUgcHJpb3JpdHkgcXVldWUgd2hpY2ggZGV0ZXJtaW5lcyB0aGVcblx0XHQqIG9yZGVyIGluIHdoaWNoIHZlcnRpY2VzIGNyb3NzIHRoZSBzd2VlcCBsaW5lLlxuXHRcdCovXG5cdFx0dmFyIHBxO1xuXHRcdHZhciB2LCB2SGVhZDtcblx0XHR2YXIgdmVydGV4Q291bnQgPSAwO1xuXHRcdFxuXHRcdHZIZWFkID0gdGVzcy5tZXNoLnZIZWFkO1xuXHRcdGZvciggdiA9IHZIZWFkLm5leHQ7IHYgIT09IHZIZWFkOyB2ID0gdi5uZXh0ICkge1xuXHRcdFx0dmVydGV4Q291bnQrKztcblx0XHR9XG5cdFx0LyogTWFrZSBzdXJlIHRoZXJlIGlzIGVub3VnaCBzcGFjZSBmb3Igc2VudGluZWxzLiAqL1xuXHRcdHZlcnRleENvdW50ICs9IDg7IC8vTUFYKCA4LCB0ZXNzLT5hbGxvYy5leHRyYVZlcnRpY2VzICk7XG5cdFx0XG5cdFx0cHEgPSB0ZXNzLnBxID0gbmV3IFByaW9yaXR5USggdmVydGV4Q291bnQsIEdlb20udmVydExlcSApO1xuXHQvL1x0aWYgKHBxID09IE5VTEwpIHJldHVybiAwO1xuXG5cdFx0dkhlYWQgPSB0ZXNzLm1lc2gudkhlYWQ7XG5cdFx0Zm9yKCB2ID0gdkhlYWQubmV4dDsgdiAhPT0gdkhlYWQ7IHYgPSB2Lm5leHQgKSB7XG5cdFx0XHR2LnBxSGFuZGxlID0gcHEuaW5zZXJ0KCB2ICk7XG5cdC8vXHRcdGlmICh2LnBxSGFuZGxlID09IElOVl9IQU5ETEUpXG5cdC8vXHRcdFx0YnJlYWs7XG5cdFx0fVxuXG5cdFx0aWYgKHYgIT09IHZIZWFkKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cHEuaW5pdCgpO1xuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXG5cdFN3ZWVwLmRvbmVQcmlvcml0eVEgPSBmdW5jdGlvbiggdGVzcyApIHtcblx0XHR0ZXNzLnBxID0gbnVsbDtcblx0fVxuXG5cblx0U3dlZXAucmVtb3ZlRGVnZW5lcmF0ZUZhY2VzID0gZnVuY3Rpb24oIHRlc3MsIG1lc2ggKSB7XG5cdFx0Lypcblx0XHQqIERlbGV0ZSBhbnkgZGVnZW5lcmF0ZSBmYWNlcyB3aXRoIG9ubHkgdHdvIGVkZ2VzLiAgV2Fsa0RpcnR5UmVnaW9ucygpXG5cdFx0KiB3aWxsIGNhdGNoIGFsbW9zdCBhbGwgb2YgdGhlc2UsIGJ1dCBpdCB3b24ndCBjYXRjaCBkZWdlbmVyYXRlIGZhY2VzXG5cdFx0KiBwcm9kdWNlZCBieSBzcGxpY2Ugb3BlcmF0aW9ucyBvbiBhbHJlYWR5LXByb2Nlc3NlZCBlZGdlcy5cblx0XHQqIFRoZSB0d28gcGxhY2VzIHRoaXMgY2FuIGhhcHBlbiBhcmUgaW4gRmluaXNoTGVmdFJlZ2lvbnMoKSwgd2hlblxuXHRcdCogd2Ugc3BsaWNlIGluIGEgXCJ0ZW1wb3JhcnlcIiBlZGdlIHByb2R1Y2VkIGJ5IENvbm5lY3RSaWdodFZlcnRleCgpLFxuXHRcdCogYW5kIGluIENoZWNrRm9yTGVmdFNwbGljZSgpLCB3aGVyZSB3ZSBzcGxpY2UgYWxyZWFkeS1wcm9jZXNzZWRcblx0XHQqIGVkZ2VzIHRvIGVuc3VyZSB0aGF0IG91ciBkaWN0aW9uYXJ5IGludmFyaWFudHMgYXJlIG5vdCB2aW9sYXRlZFxuXHRcdCogYnkgbnVtZXJpY2FsIGVycm9ycy5cblx0XHQqXG5cdFx0KiBJbiBib3RoIHRoZXNlIGNhc2VzIGl0IGlzICp2ZXJ5KiBkYW5nZXJvdXMgdG8gZGVsZXRlIHRoZSBvZmZlbmRpbmdcblx0XHQqIGVkZ2UgYXQgdGhlIHRpbWUsIHNpbmNlIG9uZSBvZiB0aGUgcm91dGluZXMgZnVydGhlciB1cCB0aGUgc3RhY2tcblx0XHQqIHdpbGwgc29tZXRpbWVzIGJlIGtlZXBpbmcgYSBwb2ludGVyIHRvIHRoYXQgZWRnZS5cblx0XHQqL1xuXHRcdHZhciBmLCBmTmV4dDtcblx0XHR2YXIgZTtcblxuXHRcdC8qTElOVEVEKi9cblx0XHRmb3IoIGYgPSBtZXNoLmZIZWFkLm5leHQ7IGYgIT09IG1lc2guZkhlYWQ7IGYgPSBmTmV4dCApIHtcblx0XHRcdGZOZXh0ID0gZi5uZXh0O1xuXHRcdFx0ZSA9IGYuYW5FZGdlO1xuXHRcdFx0YXNzZXJ0KCBlLkxuZXh0ICE9PSBlICk7XG5cblx0XHRcdGlmKCBlLkxuZXh0LkxuZXh0ID09PSBlICkge1xuXHRcdFx0XHQvKiBBIGZhY2Ugd2l0aCBvbmx5IHR3byBlZGdlcyAqL1xuXHRcdFx0XHRTd2VlcC5hZGRXaW5kaW5nKCBlLk9uZXh0LCBlICk7XG5cdFx0XHRcdHRlc3MubWVzaC5kZWxldGUoIGUgKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHRTd2VlcC5jb21wdXRlSW50ZXJpb3IgPSBmdW5jdGlvbiggdGVzcyApIHtcblx0XHQvKlxuXHRcdCogdGVzc0NvbXB1dGVJbnRlcmlvciggdGVzcyApIGNvbXB1dGVzIHRoZSBwbGFuYXIgYXJyYW5nZW1lbnQgc3BlY2lmaWVkXG5cdFx0KiBieSB0aGUgZ2l2ZW4gY29udG91cnMsIGFuZCBmdXJ0aGVyIHN1YmRpdmlkZXMgdGhpcyBhcnJhbmdlbWVudFxuXHRcdCogaW50byByZWdpb25zLiAgRWFjaCByZWdpb24gaXMgbWFya2VkIFwiaW5zaWRlXCIgaWYgaXQgYmVsb25nc1xuXHRcdCogdG8gdGhlIHBvbHlnb24sIGFjY29yZGluZyB0byB0aGUgcnVsZSBnaXZlbiBieSB0ZXNzLT53aW5kaW5nUnVsZS5cblx0XHQqIEVhY2ggaW50ZXJpb3IgcmVnaW9uIGlzIGd1YXJhbnRlZWQgYmUgbW9ub3RvbmUuXG5cdFx0Ki9cblx0XHR2YXIgdiwgdk5leHQ7XG5cblx0XHQvKiBFYWNoIHZlcnRleCBkZWZpbmVzIGFuIGV2ZW50IGZvciBvdXIgc3dlZXAgbGluZS4gIFN0YXJ0IGJ5IGluc2VydGluZ1xuXHRcdCogYWxsIHRoZSB2ZXJ0aWNlcyBpbiBhIHByaW9yaXR5IHF1ZXVlLiAgRXZlbnRzIGFyZSBwcm9jZXNzZWQgaW5cblx0XHQqIGxleGljb2dyYXBoaWMgb3JkZXIsIGllLlxuXHRcdCpcblx0XHQqXHRlMSA8IGUyICBpZmYgIGUxLnggPCBlMi54IHx8IChlMS54ID09IGUyLnggJiYgZTEueSA8IGUyLnkpXG5cdFx0Ki9cblx0XHRTd2VlcC5yZW1vdmVEZWdlbmVyYXRlRWRnZXMoIHRlc3MgKTtcblx0XHRpZiAoICFTd2VlcC5pbml0UHJpb3JpdHlRKCB0ZXNzICkgKSByZXR1cm4gZmFsc2U7IC8qIGlmIGVycm9yICovXG5cdFx0U3dlZXAuaW5pdEVkZ2VEaWN0KCB0ZXNzICk7XG5cblx0XHR3aGlsZSggKHYgPSB0ZXNzLnBxLmV4dHJhY3RNaW4oKSkgIT09IG51bGwgKSB7XG5cdFx0XHRmb3IoIDs7ICkge1xuXHRcdFx0XHR2TmV4dCA9IHRlc3MucHEubWluKCk7XG5cdFx0XHRcdGlmKCB2TmV4dCA9PT0gbnVsbCB8fCAhIEdlb20udmVydEVxKCB2TmV4dCwgdiApKSBicmVhaztcblxuXHRcdFx0XHQvKiBNZXJnZSB0b2dldGhlciBhbGwgdmVydGljZXMgYXQgZXhhY3RseSB0aGUgc2FtZSBsb2NhdGlvbi5cblx0XHRcdFx0KiBUaGlzIGlzIG1vcmUgZWZmaWNpZW50IHRoYW4gcHJvY2Vzc2luZyB0aGVtIG9uZSBhdCBhIHRpbWUsXG5cdFx0XHRcdCogc2ltcGxpZmllcyB0aGUgY29kZSAoc2VlIENvbm5lY3RMZWZ0RGVnZW5lcmF0ZSksIGFuZCBpcyBhbHNvXG5cdFx0XHRcdCogaW1wb3J0YW50IGZvciBjb3JyZWN0IGhhbmRsaW5nIG9mIGNlcnRhaW4gZGVnZW5lcmF0ZSBjYXNlcy5cblx0XHRcdFx0KiBGb3IgZXhhbXBsZSwgc3VwcG9zZSB0aGVyZSBhcmUgdHdvIGlkZW50aWNhbCBlZGdlcyBBIGFuZCBCXG5cdFx0XHRcdCogdGhhdCBiZWxvbmcgdG8gZGlmZmVyZW50IGNvbnRvdXJzIChzbyB3aXRob3V0IHRoaXMgY29kZSB0aGV5IHdvdWxkXG5cdFx0XHRcdCogYmUgcHJvY2Vzc2VkIGJ5IHNlcGFyYXRlIHN3ZWVwIGV2ZW50cykuICBTdXBwb3NlIGFub3RoZXIgZWRnZSBDXG5cdFx0XHRcdCogY3Jvc3NlcyBBIGFuZCBCIGZyb20gYWJvdmUuICBXaGVuIEEgaXMgcHJvY2Vzc2VkLCB3ZSBzcGxpdCBpdFxuXHRcdFx0XHQqIGF0IGl0cyBpbnRlcnNlY3Rpb24gcG9pbnQgd2l0aCBDLiAgSG93ZXZlciB0aGlzIGFsc28gc3BsaXRzIEMsXG5cdFx0XHRcdCogc28gd2hlbiB3ZSBpbnNlcnQgQiB3ZSBtYXkgY29tcHV0ZSBhIHNsaWdodGx5IGRpZmZlcmVudFxuXHRcdFx0XHQqIGludGVyc2VjdGlvbiBwb2ludC4gIFRoaXMgbWlnaHQgbGVhdmUgdHdvIGVkZ2VzIHdpdGggYSBzbWFsbFxuXHRcdFx0XHQqIGdhcCBiZXR3ZWVuIHRoZW0uICBUaGlzIGtpbmQgb2YgZXJyb3IgaXMgZXNwZWNpYWxseSBvYnZpb3VzXG5cdFx0XHRcdCogd2hlbiB1c2luZyBib3VuZGFyeSBleHRyYWN0aW9uIChURVNTX0JPVU5EQVJZX09OTFkpLlxuXHRcdFx0XHQqL1xuXHRcdFx0XHR2TmV4dCA9IHRlc3MucHEuZXh0cmFjdE1pbigpO1xuXHRcdFx0XHRTd2VlcC5zcGxpY2VNZXJnZVZlcnRpY2VzKCB0ZXNzLCB2LmFuRWRnZSwgdk5leHQuYW5FZGdlICk7XG5cdFx0XHR9XG5cdFx0XHRTd2VlcC5zd2VlcEV2ZW50KCB0ZXNzLCB2ICk7XG5cdFx0fVxuXG5cdFx0LyogU2V0IHRlc3MtPmV2ZW50IGZvciBkZWJ1Z2dpbmcgcHVycG9zZXMgKi9cblx0XHR0ZXNzLmV2ZW50ID0gdGVzcy5kaWN0Lm1pbigpLmtleS5lVXAuT3JnO1xuXHRcdFN3ZWVwLmRlYnVnRXZlbnQoIHRlc3MgKTtcblx0XHRTd2VlcC5kb25lRWRnZURpY3QoIHRlc3MgKTtcblx0XHRTd2VlcC5kb25lUHJpb3JpdHlRKCB0ZXNzICk7XG5cblx0XHRpZiAoICFTd2VlcC5yZW1vdmVEZWdlbmVyYXRlRmFjZXMoIHRlc3MsIHRlc3MubWVzaCApICkgcmV0dXJuIGZhbHNlO1xuXHRcdHRlc3MubWVzaC5jaGVjaygpO1xuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXG5cdGZ1bmN0aW9uIFRlc3NlbGF0b3IoKSB7XG5cblx0XHQvKioqIHN0YXRlIG5lZWRlZCBmb3IgY29sbGVjdGluZyB0aGUgaW5wdXQgZGF0YSAqKiovXG5cdFx0dGhpcy5tZXNoID0gbnVsbDtcdFx0Lyogc3RvcmVzIHRoZSBpbnB1dCBjb250b3VycywgYW5kIGV2ZW50dWFsbHlcblx0XHRcdFx0XHRcdFx0dGhlIHRlc3NlbGxhdGlvbiBpdHNlbGYgKi9cblxuXHRcdC8qKiogc3RhdGUgbmVlZGVkIGZvciBwcm9qZWN0aW5nIG9udG8gdGhlIHN3ZWVwIHBsYW5lICoqKi9cblxuXHRcdHRoaXMubm9ybWFsID0gWzAuMCwgMC4wLCAwLjBdO1x0LyogdXNlci1zcGVjaWZpZWQgbm9ybWFsIChpZiBwcm92aWRlZCkgKi9cblx0XHR0aGlzLnNVbml0ID0gWzAuMCwgMC4wLCAwLjBdO1x0LyogdW5pdCB2ZWN0b3IgaW4gcy1kaXJlY3Rpb24gKGRlYnVnZ2luZykgKi9cblx0XHR0aGlzLnRVbml0ID0gWzAuMCwgMC4wLCAwLjBdO1x0LyogdW5pdCB2ZWN0b3IgaW4gdC1kaXJlY3Rpb24gKGRlYnVnZ2luZykgKi9cblxuXHRcdHRoaXMuYm1pbiA9IFswLjAsIDAuMF07XG5cdFx0dGhpcy5ibWF4ID0gWzAuMCwgMC4wXTtcblxuXHRcdC8qKiogc3RhdGUgbmVlZGVkIGZvciB0aGUgbGluZSBzd2VlcCAqKiovXG5cdFx0dGhpcy53aW5kaW5nUnVsZSA9IFRlc3MyLldJTkRJTkdfT0REO1x0LyogcnVsZSBmb3IgZGV0ZXJtaW5pbmcgcG9seWdvbiBpbnRlcmlvciAqL1xuXG5cdFx0dGhpcy5kaWN0ID0gbnVsbDtcdFx0LyogZWRnZSBkaWN0aW9uYXJ5IGZvciBzd2VlcCBsaW5lICovXG5cdFx0dGhpcy5wcSA9IG51bGw7XHRcdC8qIHByaW9yaXR5IHF1ZXVlIG9mIHZlcnRleCBldmVudHMgKi9cblx0XHR0aGlzLmV2ZW50ID0gbnVsbDtcdFx0LyogY3VycmVudCBzd2VlcCBldmVudCBiZWluZyBwcm9jZXNzZWQgKi9cblxuXHRcdHRoaXMudmVydGV4SW5kZXhDb3VudGVyID0gMDtcblx0XHRcblx0XHR0aGlzLnZlcnRpY2VzID0gW107XG5cdFx0dGhpcy52ZXJ0ZXhJbmRpY2VzID0gW107XG5cdFx0dGhpcy52ZXJ0ZXhDb3VudCA9IDA7XG5cdFx0dGhpcy5lbGVtZW50cyA9IFtdO1xuXHRcdHRoaXMuZWxlbWVudENvdW50ID0gMDtcblx0fTtcblxuXHRUZXNzZWxhdG9yLnByb3RvdHlwZSA9IHtcblxuXHRcdGRvdF86IGZ1bmN0aW9uKHUsIHYpIHtcblx0XHRcdHJldHVybiAodVswXSp2WzBdICsgdVsxXSp2WzFdICsgdVsyXSp2WzJdKTtcblx0XHR9LFxuXG5cdFx0bm9ybWFsaXplXzogZnVuY3Rpb24oIHYgKSB7XG5cdFx0XHR2YXIgbGVuID0gdlswXSp2WzBdICsgdlsxXSp2WzFdICsgdlsyXSp2WzJdO1xuXHRcdFx0YXNzZXJ0KCBsZW4gPiAwLjAgKTtcblx0XHRcdGxlbiA9IE1hdGguc3FydCggbGVuICk7XG5cdFx0XHR2WzBdIC89IGxlbjtcblx0XHRcdHZbMV0gLz0gbGVuO1xuXHRcdFx0dlsyXSAvPSBsZW47XG5cdFx0fSxcblxuXHRcdGxvbmdBeGlzXzogZnVuY3Rpb24oIHYgKSB7XG5cdFx0XHR2YXIgaSA9IDA7XG5cdFx0XHRpZiggTWF0aC5hYnModlsxXSkgPiBNYXRoLmFicyh2WzBdKSApIHsgaSA9IDE7IH1cblx0XHRcdGlmKCBNYXRoLmFicyh2WzJdKSA+IE1hdGguYWJzKHZbaV0pICkgeyBpID0gMjsgfVxuXHRcdFx0cmV0dXJuIGk7XG5cdFx0fSxcblxuXHRcdGNvbXB1dGVOb3JtYWxfOiBmdW5jdGlvbiggbm9ybSApXG5cdFx0e1xuXHRcdFx0dmFyIHYsIHYxLCB2Mjtcblx0XHRcdHZhciBjLCB0TGVuMiwgbWF4TGVuMjtcblx0XHRcdHZhciBtYXhWYWwgPSBbMCwwLDBdLCBtaW5WYWwgPSBbMCwwLDBdLCBkMSA9IFswLDAsMF0sIGQyID0gWzAsMCwwXSwgdE5vcm0gPSBbMCwwLDBdO1xuXHRcdFx0dmFyIG1heFZlcnQgPSBbbnVsbCxudWxsLG51bGxdLCBtaW5WZXJ0ID0gW251bGwsbnVsbCxudWxsXTtcblx0XHRcdHZhciB2SGVhZCA9IHRoaXMubWVzaC52SGVhZDtcblx0XHRcdHZhciBpO1xuXG5cdFx0XHR2ID0gdkhlYWQubmV4dDtcblx0XHRcdGZvciggaSA9IDA7IGkgPCAzOyArK2kgKSB7XG5cdFx0XHRcdGMgPSB2LmNvb3Jkc1tpXTtcblx0XHRcdFx0bWluVmFsW2ldID0gYztcblx0XHRcdFx0bWluVmVydFtpXSA9IHY7XG5cdFx0XHRcdG1heFZhbFtpXSA9IGM7XG5cdFx0XHRcdG1heFZlcnRbaV0gPSB2O1xuXHRcdFx0fVxuXG5cdFx0XHRmb3IoIHYgPSB2SGVhZC5uZXh0OyB2ICE9PSB2SGVhZDsgdiA9IHYubmV4dCApIHtcblx0XHRcdFx0Zm9yKCBpID0gMDsgaSA8IDM7ICsraSApIHtcblx0XHRcdFx0XHRjID0gdi5jb29yZHNbaV07XG5cdFx0XHRcdFx0aWYoIGMgPCBtaW5WYWxbaV0gKSB7IG1pblZhbFtpXSA9IGM7IG1pblZlcnRbaV0gPSB2OyB9XG5cdFx0XHRcdFx0aWYoIGMgPiBtYXhWYWxbaV0gKSB7IG1heFZhbFtpXSA9IGM7IG1heFZlcnRbaV0gPSB2OyB9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0LyogRmluZCB0d28gdmVydGljZXMgc2VwYXJhdGVkIGJ5IGF0IGxlYXN0IDEvc3FydCgzKSBvZiB0aGUgbWF4aW11bVxuXHRcdFx0KiBkaXN0YW5jZSBiZXR3ZWVuIGFueSB0d28gdmVydGljZXNcblx0XHRcdCovXG5cdFx0XHRpID0gMDtcblx0XHRcdGlmKCBtYXhWYWxbMV0gLSBtaW5WYWxbMV0gPiBtYXhWYWxbMF0gLSBtaW5WYWxbMF0gKSB7IGkgPSAxOyB9XG5cdFx0XHRpZiggbWF4VmFsWzJdIC0gbWluVmFsWzJdID4gbWF4VmFsW2ldIC0gbWluVmFsW2ldICkgeyBpID0gMjsgfVxuXHRcdFx0aWYoIG1pblZhbFtpXSA+PSBtYXhWYWxbaV0gKSB7XG5cdFx0XHRcdC8qIEFsbCB2ZXJ0aWNlcyBhcmUgdGhlIHNhbWUgLS0gbm9ybWFsIGRvZXNuJ3QgbWF0dGVyICovXG5cdFx0XHRcdG5vcm1bMF0gPSAwOyBub3JtWzFdID0gMDsgbm9ybVsyXSA9IDE7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0LyogTG9vayBmb3IgYSB0aGlyZCB2ZXJ0ZXggd2hpY2ggZm9ybXMgdGhlIHRyaWFuZ2xlIHdpdGggbWF4aW11bSBhcmVhXG5cdFx0XHQqIChMZW5ndGggb2Ygbm9ybWFsID09IHR3aWNlIHRoZSB0cmlhbmdsZSBhcmVhKVxuXHRcdFx0Ki9cblx0XHRcdG1heExlbjIgPSAwO1xuXHRcdFx0djEgPSBtaW5WZXJ0W2ldO1xuXHRcdFx0djIgPSBtYXhWZXJ0W2ldO1xuXHRcdFx0ZDFbMF0gPSB2MS5jb29yZHNbMF0gLSB2Mi5jb29yZHNbMF07XG5cdFx0XHRkMVsxXSA9IHYxLmNvb3Jkc1sxXSAtIHYyLmNvb3Jkc1sxXTtcblx0XHRcdGQxWzJdID0gdjEuY29vcmRzWzJdIC0gdjIuY29vcmRzWzJdO1xuXHRcdFx0Zm9yKCB2ID0gdkhlYWQubmV4dDsgdiAhPT0gdkhlYWQ7IHYgPSB2Lm5leHQgKSB7XG5cdFx0XHRcdGQyWzBdID0gdi5jb29yZHNbMF0gLSB2Mi5jb29yZHNbMF07XG5cdFx0XHRcdGQyWzFdID0gdi5jb29yZHNbMV0gLSB2Mi5jb29yZHNbMV07XG5cdFx0XHRcdGQyWzJdID0gdi5jb29yZHNbMl0gLSB2Mi5jb29yZHNbMl07XG5cdFx0XHRcdHROb3JtWzBdID0gZDFbMV0qZDJbMl0gLSBkMVsyXSpkMlsxXTtcblx0XHRcdFx0dE5vcm1bMV0gPSBkMVsyXSpkMlswXSAtIGQxWzBdKmQyWzJdO1xuXHRcdFx0XHR0Tm9ybVsyXSA9IGQxWzBdKmQyWzFdIC0gZDFbMV0qZDJbMF07XG5cdFx0XHRcdHRMZW4yID0gdE5vcm1bMF0qdE5vcm1bMF0gKyB0Tm9ybVsxXSp0Tm9ybVsxXSArIHROb3JtWzJdKnROb3JtWzJdO1xuXHRcdFx0XHRpZiggdExlbjIgPiBtYXhMZW4yICkge1xuXHRcdFx0XHRcdG1heExlbjIgPSB0TGVuMjtcblx0XHRcdFx0XHRub3JtWzBdID0gdE5vcm1bMF07XG5cdFx0XHRcdFx0bm9ybVsxXSA9IHROb3JtWzFdO1xuXHRcdFx0XHRcdG5vcm1bMl0gPSB0Tm9ybVsyXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiggbWF4TGVuMiA8PSAwICkge1xuXHRcdFx0XHQvKiBBbGwgcG9pbnRzIGxpZSBvbiBhIHNpbmdsZSBsaW5lIC0tIGFueSBkZWNlbnQgbm9ybWFsIHdpbGwgZG8gKi9cblx0XHRcdFx0bm9ybVswXSA9IG5vcm1bMV0gPSBub3JtWzJdID0gMDtcblx0XHRcdFx0bm9ybVt0aGlzLmxvbmdBeGlzXyhkMSldID0gMTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Y2hlY2tPcmllbnRhdGlvbl86IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGFyZWE7XG5cdFx0XHR2YXIgZiwgZkhlYWQgPSB0aGlzLm1lc2guZkhlYWQ7XG5cdFx0XHR2YXIgdiwgdkhlYWQgPSB0aGlzLm1lc2gudkhlYWQ7XG5cdFx0XHR2YXIgZTtcblxuXHRcdFx0LyogV2hlbiB3ZSBjb21wdXRlIHRoZSBub3JtYWwgYXV0b21hdGljYWxseSwgd2UgY2hvb3NlIHRoZSBvcmllbnRhdGlvblxuXHRcdFx0KiBzbyB0aGF0IHRoZSB0aGUgc3VtIG9mIHRoZSBzaWduZWQgYXJlYXMgb2YgYWxsIGNvbnRvdXJzIGlzIG5vbi1uZWdhdGl2ZS5cblx0XHRcdCovXG5cdFx0XHRhcmVhID0gMDtcblx0XHRcdGZvciggZiA9IGZIZWFkLm5leHQ7IGYgIT09IGZIZWFkOyBmID0gZi5uZXh0ICkge1xuXHRcdFx0XHRlID0gZi5hbkVkZ2U7XG5cdFx0XHRcdGlmKCBlLndpbmRpbmcgPD0gMCApIGNvbnRpbnVlO1xuXHRcdFx0XHRkbyB7XG5cdFx0XHRcdFx0YXJlYSArPSAoZS5PcmcucyAtIGUuRHN0LnMpICogKGUuT3JnLnQgKyBlLkRzdC50KTtcblx0XHRcdFx0XHRlID0gZS5MbmV4dDtcblx0XHRcdFx0fSB3aGlsZSggZSAhPT0gZi5hbkVkZ2UgKTtcblx0XHRcdH1cblx0XHRcdGlmKCBhcmVhIDwgMCApIHtcblx0XHRcdFx0LyogUmV2ZXJzZSB0aGUgb3JpZW50YXRpb24gYnkgZmxpcHBpbmcgYWxsIHRoZSB0LWNvb3JkaW5hdGVzICovXG5cdFx0XHRcdGZvciggdiA9IHZIZWFkLm5leHQ7IHYgIT09IHZIZWFkOyB2ID0gdi5uZXh0ICkge1xuXHRcdFx0XHRcdHYudCA9IC0gdi50O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMudFVuaXRbMF0gPSAtIHRoaXMudFVuaXRbMF07XG5cdFx0XHRcdHRoaXMudFVuaXRbMV0gPSAtIHRoaXMudFVuaXRbMV07XG5cdFx0XHRcdHRoaXMudFVuaXRbMl0gPSAtIHRoaXMudFVuaXRbMl07XG5cdFx0XHR9XG5cdFx0fSxcblxuXHQvKlx0I2lmZGVmIEZPUl9UUklURV9URVNUX1BST0dSQU1cblx0XHQjaW5jbHVkZSA8c3RkbGliLmg+XG5cdFx0ZXh0ZXJuIGludCBSYW5kb21Td2VlcDtcblx0XHQjZGVmaW5lIFNfVU5JVF9YXHQoUmFuZG9tU3dlZXAgPyAoMipkcmFuZDQ4KCktMSkgOiAxLjApXG5cdFx0I2RlZmluZSBTX1VOSVRfWVx0KFJhbmRvbVN3ZWVwID8gKDIqZHJhbmQ0OCgpLTEpIDogMC4wKVxuXHRcdCNlbHNlXG5cdFx0I2lmIGRlZmluZWQoU0xBTlRFRF9TV0VFUCkgKi9cblx0XHQvKiBUaGUgXCJmZWF0dXJlIG1lcmdpbmdcIiBpcyBub3QgaW50ZW5kZWQgdG8gYmUgY29tcGxldGUuICBUaGVyZSBhcmVcblx0XHQqIHNwZWNpYWwgY2FzZXMgd2hlcmUgZWRnZXMgYXJlIG5lYXJseSBwYXJhbGxlbCB0byB0aGUgc3dlZXAgbGluZVxuXHRcdCogd2hpY2ggYXJlIG5vdCBpbXBsZW1lbnRlZC4gIFRoZSBhbGdvcml0aG0gc2hvdWxkIHN0aWxsIGJlaGF2ZVxuXHRcdCogcm9idXN0bHkgKGllLiBwcm9kdWNlIGEgcmVhc29uYWJsZSB0ZXNzZWxhdGlvbikgaW4gdGhlIHByZXNlbmNlXG5cdFx0KiBvZiBzdWNoIGVkZ2VzLCBob3dldmVyIGl0IG1heSBtaXNzIGZlYXR1cmVzIHdoaWNoIGNvdWxkIGhhdmUgYmVlblxuXHRcdCogbWVyZ2VkLiAgV2UgY291bGQgbWluaW1pemUgdGhpcyBlZmZlY3QgYnkgY2hvb3NpbmcgdGhlIHN3ZWVwIGxpbmVcblx0XHQqIGRpcmVjdGlvbiB0byBiZSBzb21ldGhpbmcgdW51c3VhbCAoaWUuIG5vdCBwYXJhbGxlbCB0byBvbmUgb2YgdGhlXG5cdFx0KiBjb29yZGluYXRlIGF4ZXMpLlxuXHRcdCovXG5cdC8qXHQjZGVmaW5lIFNfVU5JVF9YXHQoVEVTU3JlYWwpMC41MDk0MTUzOTU2NDk1NTM4NVx0Ly8gUHJlLW5vcm1hbGl6ZWRcblx0XHQjZGVmaW5lIFNfVU5JVF9ZXHQoVEVTU3JlYWwpMC44NjA1MjA3NDYyMjAxMDYzM1xuXHRcdCNlbHNlXG5cdFx0I2RlZmluZSBTX1VOSVRfWFx0KFRFU1NyZWFsKTEuMFxuXHRcdCNkZWZpbmUgU19VTklUX1lcdChURVNTcmVhbCkwLjBcblx0XHQjZW5kaWZcblx0XHQjZW5kaWYqL1xuXG5cdFx0LyogRGV0ZXJtaW5lIHRoZSBwb2x5Z29uIG5vcm1hbCBhbmQgcHJvamVjdCB2ZXJ0aWNlcyBvbnRvIHRoZSBwbGFuZVxuXHRcdCogb2YgdGhlIHBvbHlnb24uXG5cdFx0Ki9cblx0XHRwcm9qZWN0UG9seWdvbl86IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHYsIHZIZWFkID0gdGhpcy5tZXNoLnZIZWFkO1xuXHRcdFx0dmFyIG5vcm0gPSBbMCwwLDBdO1xuXHRcdFx0dmFyIHNVbml0LCB0VW5pdDtcblx0XHRcdHZhciBpLCBmaXJzdCwgY29tcHV0ZWROb3JtYWwgPSBmYWxzZTtcblxuXHRcdFx0bm9ybVswXSA9IHRoaXMubm9ybWFsWzBdO1xuXHRcdFx0bm9ybVsxXSA9IHRoaXMubm9ybWFsWzFdO1xuXHRcdFx0bm9ybVsyXSA9IHRoaXMubm9ybWFsWzJdO1xuXHRcdFx0aWYoIG5vcm1bMF0gPT09IDAuMCAmJiBub3JtWzFdID09PSAwLjAgJiYgbm9ybVsyXSA9PT0gMC4wICkge1xuXHRcdFx0XHR0aGlzLmNvbXB1dGVOb3JtYWxfKCBub3JtICk7XG5cdFx0XHRcdGNvbXB1dGVkTm9ybWFsID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdHNVbml0ID0gdGhpcy5zVW5pdDtcblx0XHRcdHRVbml0ID0gdGhpcy50VW5pdDtcblx0XHRcdGkgPSB0aGlzLmxvbmdBeGlzXyggbm9ybSApO1xuXG5cdC8qXHQjaWYgZGVmaW5lZChGT1JfVFJJVEVfVEVTVF9QUk9HUkFNKSB8fCBkZWZpbmVkKFRSVUVfUFJPSkVDVClcblx0XHRcdC8vIENob29zZSB0aGUgaW5pdGlhbCBzVW5pdCB2ZWN0b3IgdG8gYmUgYXBwcm94aW1hdGVseSBwZXJwZW5kaWN1bGFyXG5cdFx0XHQvLyB0byB0aGUgbm9ybWFsLlxuXHRcdFx0XG5cdFx0XHROb3JtYWxpemUoIG5vcm0gKTtcblxuXHRcdFx0c1VuaXRbaV0gPSAwO1xuXHRcdFx0c1VuaXRbKGkrMSklM10gPSBTX1VOSVRfWDtcblx0XHRcdHNVbml0WyhpKzIpJTNdID0gU19VTklUX1k7XG5cblx0XHRcdC8vIE5vdyBtYWtlIGl0IGV4YWN0bHkgcGVycGVuZGljdWxhciBcblx0XHRcdHcgPSBEb3QoIHNVbml0LCBub3JtICk7XG5cdFx0XHRzVW5pdFswXSAtPSB3ICogbm9ybVswXTtcblx0XHRcdHNVbml0WzFdIC09IHcgKiBub3JtWzFdO1xuXHRcdFx0c1VuaXRbMl0gLT0gdyAqIG5vcm1bMl07XG5cdFx0XHROb3JtYWxpemUoIHNVbml0ICk7XG5cblx0XHRcdC8vIENob29zZSB0VW5pdCBzbyB0aGF0IChzVW5pdCx0VW5pdCxub3JtKSBmb3JtIGEgcmlnaHQtaGFuZGVkIGZyYW1lIFxuXHRcdFx0dFVuaXRbMF0gPSBub3JtWzFdKnNVbml0WzJdIC0gbm9ybVsyXSpzVW5pdFsxXTtcblx0XHRcdHRVbml0WzFdID0gbm9ybVsyXSpzVW5pdFswXSAtIG5vcm1bMF0qc1VuaXRbMl07XG5cdFx0XHR0VW5pdFsyXSA9IG5vcm1bMF0qc1VuaXRbMV0gLSBub3JtWzFdKnNVbml0WzBdO1xuXHRcdFx0Tm9ybWFsaXplKCB0VW5pdCApO1xuXHRcdCNlbHNlKi9cblx0XHRcdC8qIFByb2plY3QgcGVycGVuZGljdWxhciB0byBhIGNvb3JkaW5hdGUgYXhpcyAtLSBiZXR0ZXIgbnVtZXJpY2FsbHkgKi9cblx0XHRcdHNVbml0W2ldID0gMDtcblx0XHRcdHNVbml0WyhpKzEpJTNdID0gMS4wO1xuXHRcdFx0c1VuaXRbKGkrMiklM10gPSAwLjA7XG5cblx0XHRcdHRVbml0W2ldID0gMDtcblx0XHRcdHRVbml0WyhpKzEpJTNdID0gMC4wO1xuXHRcdFx0dFVuaXRbKGkrMiklM10gPSAobm9ybVtpXSA+IDApID8gMS4wIDogLTEuMDtcblx0Ly9cdCNlbmRpZlxuXG5cdFx0XHQvKiBQcm9qZWN0IHRoZSB2ZXJ0aWNlcyBvbnRvIHRoZSBzd2VlcCBwbGFuZSAqL1xuXHRcdFx0Zm9yKCB2ID0gdkhlYWQubmV4dDsgdiAhPT0gdkhlYWQ7IHYgPSB2Lm5leHQgKSB7XG5cdFx0XHRcdHYucyA9IHRoaXMuZG90Xyggdi5jb29yZHMsIHNVbml0ICk7XG5cdFx0XHRcdHYudCA9IHRoaXMuZG90Xyggdi5jb29yZHMsIHRVbml0ICk7XG5cdFx0XHR9XG5cdFx0XHRpZiggY29tcHV0ZWROb3JtYWwgKSB7XG5cdFx0XHRcdHRoaXMuY2hlY2tPcmllbnRhdGlvbl8oKTtcblx0XHRcdH1cblxuXHRcdFx0LyogQ29tcHV0ZSBTVCBib3VuZHMuICovXG5cdFx0XHRmaXJzdCA9IHRydWU7XG5cdFx0XHRmb3IoIHYgPSB2SGVhZC5uZXh0OyB2ICE9PSB2SGVhZDsgdiA9IHYubmV4dCApIHtcblx0XHRcdFx0aWYgKGZpcnN0KSB7XG5cdFx0XHRcdFx0dGhpcy5ibWluWzBdID0gdGhpcy5ibWF4WzBdID0gdi5zO1xuXHRcdFx0XHRcdHRoaXMuYm1pblsxXSA9IHRoaXMuYm1heFsxXSA9IHYudDtcblx0XHRcdFx0XHRmaXJzdCA9IGZhbHNlO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGlmICh2LnMgPCB0aGlzLmJtaW5bMF0pIHRoaXMuYm1pblswXSA9IHYucztcblx0XHRcdFx0XHRpZiAodi5zID4gdGhpcy5ibWF4WzBdKSB0aGlzLmJtYXhbMF0gPSB2LnM7XG5cdFx0XHRcdFx0aWYgKHYudCA8IHRoaXMuYm1pblsxXSkgdGhpcy5ibWluWzFdID0gdi50O1xuXHRcdFx0XHRcdGlmICh2LnQgPiB0aGlzLmJtYXhbMV0pIHRoaXMuYm1heFsxXSA9IHYudDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRhZGRXaW5kaW5nXzogZnVuY3Rpb24oZURzdCxlU3JjKSB7XG5cdFx0XHRlRHN0LndpbmRpbmcgKz0gZVNyYy53aW5kaW5nO1xuXHRcdFx0ZURzdC5TeW0ud2luZGluZyArPSBlU3JjLlN5bS53aW5kaW5nO1xuXHRcdH0sXG5cdFx0XG5cdFx0LyogdGVzc01lc2hUZXNzZWxsYXRlTW9ub1JlZ2lvbiggZmFjZSApIHRlc3NlbGxhdGVzIGEgbW9ub3RvbmUgcmVnaW9uXG5cdFx0KiAod2hhdCBlbHNlIHdvdWxkIGl0IGRvPz8pICBUaGUgcmVnaW9uIG11c3QgY29uc2lzdCBvZiBhIHNpbmdsZVxuXHRcdCogbG9vcCBvZiBoYWxmLWVkZ2VzIChzZWUgbWVzaC5oKSBvcmllbnRlZCBDQ1cuICBcIk1vbm90b25lXCIgaW4gdGhpc1xuXHRcdCogY2FzZSBtZWFucyB0aGF0IGFueSB2ZXJ0aWNhbCBsaW5lIGludGVyc2VjdHMgdGhlIGludGVyaW9yIG9mIHRoZVxuXHRcdCogcmVnaW9uIGluIGEgc2luZ2xlIGludGVydmFsLiAgXG5cdFx0KlxuXHRcdCogVGVzc2VsbGF0aW9uIGNvbnNpc3RzIG9mIGFkZGluZyBpbnRlcmlvciBlZGdlcyAoYWN0dWFsbHkgcGFpcnMgb2Zcblx0XHQqIGhhbGYtZWRnZXMpLCB0byBzcGxpdCB0aGUgcmVnaW9uIGludG8gbm9uLW92ZXJsYXBwaW5nIHRyaWFuZ2xlcy5cblx0XHQqXG5cdFx0KiBUaGUgYmFzaWMgaWRlYSBpcyBleHBsYWluZWQgaW4gUHJlcGFyYXRhIGFuZCBTaGFtb3MgKHdoaWNoIEkgZG9uJyd0XG5cdFx0KiBoYXZlIGhhbmR5IHJpZ2h0IG5vdyksIGFsdGhvdWdoIHRoZWlyIGltcGxlbWVudGF0aW9uIGlzIG1vcmVcblx0XHQqIGNvbXBsaWNhdGVkIHRoYW4gdGhpcyBvbmUuICBUaGUgYXJlIHR3byBlZGdlIGNoYWlucywgYW4gdXBwZXIgY2hhaW5cblx0XHQqIGFuZCBhIGxvd2VyIGNoYWluLiAgV2UgcHJvY2VzcyBhbGwgdmVydGljZXMgZnJvbSBib3RoIGNoYWlucyBpbiBvcmRlcixcblx0XHQqIGZyb20gcmlnaHQgdG8gbGVmdC5cblx0XHQqXG5cdFx0KiBUaGUgYWxnb3JpdGhtIGVuc3VyZXMgdGhhdCB0aGUgZm9sbG93aW5nIGludmFyaWFudCBob2xkcyBhZnRlciBlYWNoXG5cdFx0KiB2ZXJ0ZXggaXMgcHJvY2Vzc2VkOiB0aGUgdW50ZXNzZWxsYXRlZCByZWdpb24gY29uc2lzdHMgb2YgdHdvXG5cdFx0KiBjaGFpbnMsIHdoZXJlIG9uZSBjaGFpbiAoc2F5IHRoZSB1cHBlcikgaXMgYSBzaW5nbGUgZWRnZSwgYW5kXG5cdFx0KiB0aGUgb3RoZXIgY2hhaW4gaXMgY29uY2F2ZS4gIFRoZSBsZWZ0IHZlcnRleCBvZiB0aGUgc2luZ2xlIGVkZ2Vcblx0XHQqIGlzIGFsd2F5cyB0byB0aGUgbGVmdCBvZiBhbGwgdmVydGljZXMgaW4gdGhlIGNvbmNhdmUgY2hhaW4uXG5cdFx0KlxuXHRcdCogRWFjaCBzdGVwIGNvbnNpc3RzIG9mIGFkZGluZyB0aGUgcmlnaHRtb3N0IHVucHJvY2Vzc2VkIHZlcnRleCB0byBvbmVcblx0XHQqIG9mIHRoZSB0d28gY2hhaW5zLCBhbmQgZm9ybWluZyBhIGZhbiBvZiB0cmlhbmdsZXMgZnJvbSB0aGUgcmlnaHRtb3N0XG5cdFx0KiBvZiB0d28gY2hhaW4gZW5kcG9pbnRzLiAgRGV0ZXJtaW5pbmcgd2hldGhlciB3ZSBjYW4gYWRkIGVhY2ggdHJpYW5nbGVcblx0XHQqIHRvIHRoZSBmYW4gaXMgYSBzaW1wbGUgb3JpZW50YXRpb24gdGVzdC4gIEJ5IG1ha2luZyB0aGUgZmFuIGFzIGxhcmdlXG5cdFx0KiBhcyBwb3NzaWJsZSwgd2UgcmVzdG9yZSB0aGUgaW52YXJpYW50IChjaGVjayBpdCB5b3Vyc2VsZikuXG5cdFx0Ki9cblx0Ly9cdGludCB0ZXNzTWVzaFRlc3NlbGxhdGVNb25vUmVnaW9uKCBURVNTbWVzaCAqbWVzaCwgVEVTU2ZhY2UgKmZhY2UgKVxuXHRcdHRlc3NlbGxhdGVNb25vUmVnaW9uXzogZnVuY3Rpb24oIG1lc2gsIGZhY2UgKSB7XG5cdFx0XHR2YXIgdXAsIGxvO1xuXG5cdFx0XHQvKiBBbGwgZWRnZXMgYXJlIG9yaWVudGVkIENDVyBhcm91bmQgdGhlIGJvdW5kYXJ5IG9mIHRoZSByZWdpb24uXG5cdFx0XHQqIEZpcnN0LCBmaW5kIHRoZSBoYWxmLWVkZ2Ugd2hvc2Ugb3JpZ2luIHZlcnRleCBpcyByaWdodG1vc3QuXG5cdFx0XHQqIFNpbmNlIHRoZSBzd2VlcCBnb2VzIGZyb20gbGVmdCB0byByaWdodCwgZmFjZS0+YW5FZGdlIHNob3VsZFxuXHRcdFx0KiBiZSBjbG9zZSB0byB0aGUgZWRnZSB3ZSB3YW50LlxuXHRcdFx0Ki9cblx0XHRcdHVwID0gZmFjZS5hbkVkZ2U7XG5cdFx0XHRhc3NlcnQoIHVwLkxuZXh0ICE9PSB1cCAmJiB1cC5MbmV4dC5MbmV4dCAhPT0gdXAgKTtcblxuXHRcdFx0Zm9yKCA7IEdlb20udmVydExlcSggdXAuRHN0LCB1cC5PcmcgKTsgdXAgPSB1cC5McHJldiApXG5cdFx0XHRcdDtcblx0XHRcdGZvciggOyBHZW9tLnZlcnRMZXEoIHVwLk9yZywgdXAuRHN0ICk7IHVwID0gdXAuTG5leHQgKVxuXHRcdFx0XHQ7XG5cdFx0XHRsbyA9IHVwLkxwcmV2O1xuXG5cdFx0XHR3aGlsZSggdXAuTG5leHQgIT09IGxvICkge1xuXHRcdFx0XHRpZiggR2VvbS52ZXJ0TGVxKCB1cC5Ec3QsIGxvLk9yZyApKSB7XG5cdFx0XHRcdFx0LyogdXAtPkRzdCBpcyBvbiB0aGUgbGVmdC4gIEl0IGlzIHNhZmUgdG8gZm9ybSB0cmlhbmdsZXMgZnJvbSBsby0+T3JnLlxuXHRcdFx0XHRcdCogVGhlIEVkZ2VHb2VzTGVmdCB0ZXN0IGd1YXJhbnRlZXMgcHJvZ3Jlc3MgZXZlbiB3aGVuIHNvbWUgdHJpYW5nbGVzXG5cdFx0XHRcdFx0KiBhcmUgQ1csIGdpdmVuIHRoYXQgdGhlIHVwcGVyIGFuZCBsb3dlciBjaGFpbnMgYXJlIHRydWx5IG1vbm90b25lLlxuXHRcdFx0XHRcdCovXG5cdFx0XHRcdFx0d2hpbGUoIGxvLkxuZXh0ICE9PSB1cCAmJiAoR2VvbS5lZGdlR29lc0xlZnQoIGxvLkxuZXh0IClcblx0XHRcdFx0XHRcdHx8IEdlb20uZWRnZVNpZ24oIGxvLk9yZywgbG8uRHN0LCBsby5MbmV4dC5Ec3QgKSA8PSAwLjAgKSkge1xuXHRcdFx0XHRcdFx0XHR2YXIgdGVtcEhhbGZFZGdlID0gbWVzaC5jb25uZWN0KCBsby5MbmV4dCwgbG8gKTtcblx0XHRcdFx0XHRcdFx0Ly9pZiAodGVtcEhhbGZFZGdlID09IE5VTEwpIHJldHVybiAwO1xuXHRcdFx0XHRcdFx0XHRsbyA9IHRlbXBIYWxmRWRnZS5TeW07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGxvID0gbG8uTHByZXY7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0LyogbG8tPk9yZyBpcyBvbiB0aGUgbGVmdC4gIFdlIGNhbiBtYWtlIENDVyB0cmlhbmdsZXMgZnJvbSB1cC0+RHN0LiAqL1xuXHRcdFx0XHRcdHdoaWxlKCBsby5MbmV4dCAhPSB1cCAmJiAoR2VvbS5lZGdlR29lc1JpZ2h0KCB1cC5McHJldiApXG5cdFx0XHRcdFx0XHR8fCBHZW9tLmVkZ2VTaWduKCB1cC5Ec3QsIHVwLk9yZywgdXAuTHByZXYuT3JnICkgPj0gMC4wICkpIHtcblx0XHRcdFx0XHRcdFx0dmFyIHRlbXBIYWxmRWRnZSA9IG1lc2guY29ubmVjdCggdXAsIHVwLkxwcmV2ICk7XG5cdFx0XHRcdFx0XHRcdC8vaWYgKHRlbXBIYWxmRWRnZSA9PSBOVUxMKSByZXR1cm4gMDtcblx0XHRcdFx0XHRcdFx0dXAgPSB0ZW1wSGFsZkVkZ2UuU3ltO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR1cCA9IHVwLkxuZXh0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8qIE5vdyBsby0+T3JnID09IHVwLT5Ec3QgPT0gdGhlIGxlZnRtb3N0IHZlcnRleC4gIFRoZSByZW1haW5pbmcgcmVnaW9uXG5cdFx0XHQqIGNhbiBiZSB0ZXNzZWxsYXRlZCBpbiBhIGZhbiBmcm9tIHRoaXMgbGVmdG1vc3QgdmVydGV4LlxuXHRcdFx0Ki9cblx0XHRcdGFzc2VydCggbG8uTG5leHQgIT09IHVwICk7XG5cdFx0XHR3aGlsZSggbG8uTG5leHQuTG5leHQgIT09IHVwICkge1xuXHRcdFx0XHR2YXIgdGVtcEhhbGZFZGdlID0gbWVzaC5jb25uZWN0KCBsby5MbmV4dCwgbG8gKTtcblx0XHRcdFx0Ly9pZiAodGVtcEhhbGZFZGdlID09IE5VTEwpIHJldHVybiAwO1xuXHRcdFx0XHRsbyA9IHRlbXBIYWxmRWRnZS5TeW07XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0sXG5cblxuXHRcdC8qIHRlc3NNZXNoVGVzc2VsbGF0ZUludGVyaW9yKCBtZXNoICkgdGVzc2VsbGF0ZXMgZWFjaCByZWdpb24gb2Zcblx0XHQqIHRoZSBtZXNoIHdoaWNoIGlzIG1hcmtlZCBcImluc2lkZVwiIHRoZSBwb2x5Z29uLiAgRWFjaCBzdWNoIHJlZ2lvblxuXHRcdCogbXVzdCBiZSBtb25vdG9uZS5cblx0XHQqL1xuXHRcdC8vaW50IHRlc3NNZXNoVGVzc2VsbGF0ZUludGVyaW9yKCBURVNTbWVzaCAqbWVzaCApXG5cdFx0dGVzc2VsbGF0ZUludGVyaW9yXzogZnVuY3Rpb24oIG1lc2ggKSB7XG5cdFx0XHR2YXIgZiwgbmV4dDtcblxuXHRcdFx0LypMSU5URUQqL1xuXHRcdFx0Zm9yKCBmID0gbWVzaC5mSGVhZC5uZXh0OyBmICE9PSBtZXNoLmZIZWFkOyBmID0gbmV4dCApIHtcblx0XHRcdFx0LyogTWFrZSBzdXJlIHdlIGRvbicndCB0cnkgdG8gdGVzc2VsbGF0ZSB0aGUgbmV3IHRyaWFuZ2xlcy4gKi9cblx0XHRcdFx0bmV4dCA9IGYubmV4dDtcblx0XHRcdFx0aWYoIGYuaW5zaWRlICkge1xuXHRcdFx0XHRcdGlmICggIXRoaXMudGVzc2VsbGF0ZU1vbm9SZWdpb25fKCBtZXNoLCBmICkgKSByZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSxcblxuXG5cdFx0LyogdGVzc01lc2hEaXNjYXJkRXh0ZXJpb3IoIG1lc2ggKSB6YXBzIChpZS4gc2V0cyB0byBOVUxMKSBhbGwgZmFjZXNcblx0XHQqIHdoaWNoIGFyZSBub3QgbWFya2VkIFwiaW5zaWRlXCIgdGhlIHBvbHlnb24uICBTaW5jZSBmdXJ0aGVyIG1lc2ggb3BlcmF0aW9uc1xuXHRcdCogb24gTlVMTCBmYWNlcyBhcmUgbm90IGFsbG93ZWQsIHRoZSBtYWluIHB1cnBvc2UgaXMgdG8gY2xlYW4gdXAgdGhlXG5cdFx0KiBtZXNoIHNvIHRoYXQgZXh0ZXJpb3IgbG9vcHMgYXJlIG5vdCByZXByZXNlbnRlZCBpbiB0aGUgZGF0YSBzdHJ1Y3R1cmUuXG5cdFx0Ki9cblx0XHQvL3ZvaWQgdGVzc01lc2hEaXNjYXJkRXh0ZXJpb3IoIFRFU1NtZXNoICptZXNoIClcblx0XHRkaXNjYXJkRXh0ZXJpb3JfOiBmdW5jdGlvbiggbWVzaCApIHtcblx0XHRcdHZhciBmLCBuZXh0O1xuXG5cdFx0XHQvKkxJTlRFRCovXG5cdFx0XHRmb3IoIGYgPSBtZXNoLmZIZWFkLm5leHQ7IGYgIT09IG1lc2guZkhlYWQ7IGYgPSBuZXh0ICkge1xuXHRcdFx0XHQvKiBTaW5jZSBmIHdpbGwgYmUgZGVzdHJveWVkLCBzYXZlIGl0cyBuZXh0IHBvaW50ZXIuICovXG5cdFx0XHRcdG5leHQgPSBmLm5leHQ7XG5cdFx0XHRcdGlmKCAhIGYuaW5zaWRlICkge1xuXHRcdFx0XHRcdG1lc2guemFwRmFjZSggZiApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qIHRlc3NNZXNoU2V0V2luZGluZ051bWJlciggbWVzaCwgdmFsdWUsIGtlZXBPbmx5Qm91bmRhcnkgKSByZXNldHMgdGhlXG5cdFx0KiB3aW5kaW5nIG51bWJlcnMgb24gYWxsIGVkZ2VzIHNvIHRoYXQgcmVnaW9ucyBtYXJrZWQgXCJpbnNpZGVcIiB0aGVcblx0XHQqIHBvbHlnb24gaGF2ZSBhIHdpbmRpbmcgbnVtYmVyIG9mIFwidmFsdWVcIiwgYW5kIHJlZ2lvbnMgb3V0c2lkZVxuXHRcdCogaGF2ZSBhIHdpbmRpbmcgbnVtYmVyIG9mIDAuXG5cdFx0KlxuXHRcdCogSWYga2VlcE9ubHlCb3VuZGFyeSBpcyBUUlVFLCBpdCBhbHNvIGRlbGV0ZXMgYWxsIGVkZ2VzIHdoaWNoIGRvIG5vdFxuXHRcdCogc2VwYXJhdGUgYW4gaW50ZXJpb3IgcmVnaW9uIGZyb20gYW4gZXh0ZXJpb3Igb25lLlxuXHRcdCovXG5cdC8vXHRpbnQgdGVzc01lc2hTZXRXaW5kaW5nTnVtYmVyKCBURVNTbWVzaCAqbWVzaCwgaW50IHZhbHVlLCBpbnQga2VlcE9ubHlCb3VuZGFyeSApXG5cdFx0c2V0V2luZGluZ051bWJlcl86IGZ1bmN0aW9uKCBtZXNoLCB2YWx1ZSwga2VlcE9ubHlCb3VuZGFyeSApIHtcblx0XHRcdHZhciBlLCBlTmV4dDtcblxuXHRcdFx0Zm9yKCBlID0gbWVzaC5lSGVhZC5uZXh0OyBlICE9PSBtZXNoLmVIZWFkOyBlID0gZU5leHQgKSB7XG5cdFx0XHRcdGVOZXh0ID0gZS5uZXh0O1xuXHRcdFx0XHRpZiggZS5SZmFjZS5pbnNpZGUgIT09IGUuTGZhY2UuaW5zaWRlICkge1xuXG5cdFx0XHRcdFx0LyogVGhpcyBpcyBhIGJvdW5kYXJ5IGVkZ2UgKG9uZSBzaWRlIGlzIGludGVyaW9yLCBvbmUgaXMgZXh0ZXJpb3IpLiAqL1xuXHRcdFx0XHRcdGUud2luZGluZyA9IChlLkxmYWNlLmluc2lkZSkgPyB2YWx1ZSA6IC12YWx1ZTtcblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdC8qIEJvdGggcmVnaW9ucyBhcmUgaW50ZXJpb3IsIG9yIGJvdGggYXJlIGV4dGVyaW9yLiAqL1xuXHRcdFx0XHRcdGlmKCAhIGtlZXBPbmx5Qm91bmRhcnkgKSB7XG5cdFx0XHRcdFx0XHRlLndpbmRpbmcgPSAwO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRtZXNoLmRlbGV0ZSggZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRnZXROZWlnaGJvdXJGYWNlXzogZnVuY3Rpb24oZWRnZSlcblx0XHR7XG5cdFx0XHRpZiAoIWVkZ2UuUmZhY2UpXG5cdFx0XHRcdHJldHVybiAtMTtcblx0XHRcdGlmICghZWRnZS5SZmFjZS5pbnNpZGUpXG5cdFx0XHRcdHJldHVybiAtMTtcblx0XHRcdHJldHVybiBlZGdlLlJmYWNlLm47XG5cdFx0fSxcblxuXHRcdG91dHB1dFBvbHltZXNoXzogZnVuY3Rpb24oIG1lc2gsIGVsZW1lbnRUeXBlLCBwb2x5U2l6ZSwgdmVydGV4U2l6ZSApIHtcblx0XHRcdHZhciB2O1xuXHRcdFx0dmFyIGY7XG5cdFx0XHR2YXIgZWRnZTtcblx0XHRcdHZhciBtYXhGYWNlQ291bnQgPSAwO1xuXHRcdFx0dmFyIG1heFZlcnRleENvdW50ID0gMDtcblx0XHRcdHZhciBmYWNlVmVydHMsIGk7XG5cdFx0XHR2YXIgZWxlbWVudHMgPSAwO1xuXHRcdFx0dmFyIHZlcnQ7XG5cblx0XHRcdC8vIEFzc3VtZSB0aGF0IHRoZSBpbnB1dCBkYXRhIGlzIHRyaWFuZ2xlcyBub3cuXG5cdFx0XHQvLyBUcnkgdG8gbWVyZ2UgYXMgbWFueSBwb2x5Z29ucyBhcyBwb3NzaWJsZVxuXHRcdFx0aWYgKHBvbHlTaXplID4gMylcblx0XHRcdHtcblx0XHRcdFx0bWVzaC5tZXJnZUNvbnZleEZhY2VzKCBwb2x5U2l6ZSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNYXJrIHVudXNlZFxuXHRcdFx0Zm9yICggdiA9IG1lc2gudkhlYWQubmV4dDsgdiAhPT0gbWVzaC52SGVhZDsgdiA9IHYubmV4dCApXG5cdFx0XHRcdHYubiA9IC0xO1xuXG5cdFx0XHQvLyBDcmVhdGUgdW5pcXVlIElEcyBmb3IgYWxsIHZlcnRpY2VzIGFuZCBmYWNlcy5cblx0XHRcdGZvciAoIGYgPSBtZXNoLmZIZWFkLm5leHQ7IGYgIT0gbWVzaC5mSGVhZDsgZiA9IGYubmV4dCApXG5cdFx0XHR7XG5cdFx0XHRcdGYubiA9IC0xO1xuXHRcdFx0XHRpZiggIWYuaW5zaWRlICkgY29udGludWU7XG5cblx0XHRcdFx0ZWRnZSA9IGYuYW5FZGdlO1xuXHRcdFx0XHRmYWNlVmVydHMgPSAwO1xuXHRcdFx0XHRkb1xuXHRcdFx0XHR7XG5cdFx0XHRcdFx0diA9IGVkZ2UuT3JnO1xuXHRcdFx0XHRcdGlmICggdi5uID09PSAtMSApXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0di5uID0gbWF4VmVydGV4Q291bnQ7XG5cdFx0XHRcdFx0XHRtYXhWZXJ0ZXhDb3VudCsrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRmYWNlVmVydHMrKztcblx0XHRcdFx0XHRlZGdlID0gZWRnZS5MbmV4dDtcblx0XHRcdFx0fVxuXHRcdFx0XHR3aGlsZSAoZWRnZSAhPT0gZi5hbkVkZ2UpO1xuXHRcdFx0XHRcblx0XHRcdFx0YXNzZXJ0KCBmYWNlVmVydHMgPD0gcG9seVNpemUgKTtcblxuXHRcdFx0XHRmLm4gPSBtYXhGYWNlQ291bnQ7XG5cdFx0XHRcdCsrbWF4RmFjZUNvdW50O1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLmVsZW1lbnRDb3VudCA9IG1heEZhY2VDb3VudDtcblx0XHRcdGlmIChlbGVtZW50VHlwZSA9PSBUZXNzMi5DT05ORUNURURfUE9MWUdPTlMpXG5cdFx0XHRcdG1heEZhY2VDb3VudCAqPSAyO1xuXHQvKlx0XHR0ZXNzLmVsZW1lbnRzID0gKFRFU1NpbmRleCopdGVzcy0+YWxsb2MubWVtYWxsb2MoIHRlc3MtPmFsbG9jLnVzZXJEYXRhLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ICBzaXplb2YoVEVTU2luZGV4KSAqIG1heEZhY2VDb3VudCAqIHBvbHlTaXplICk7XG5cdFx0XHRpZiAoIXRlc3MtPmVsZW1lbnRzKVxuXHRcdFx0e1xuXHRcdFx0XHR0ZXNzLT5vdXRPZk1lbW9yeSA9IDE7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH0qL1xuXHRcdFx0dGhpcy5lbGVtZW50cyA9IFtdO1xuXHRcdFx0dGhpcy5lbGVtZW50cy5sZW5ndGggPSBtYXhGYWNlQ291bnQgKiBwb2x5U2l6ZTtcblx0XHRcdFxuXHRcdFx0dGhpcy52ZXJ0ZXhDb3VudCA9IG1heFZlcnRleENvdW50O1xuXHQvKlx0XHR0ZXNzLT52ZXJ0aWNlcyA9IChURVNTcmVhbCopdGVzcy0+YWxsb2MubWVtYWxsb2MoIHRlc3MtPmFsbG9jLnVzZXJEYXRhLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0IHNpemVvZihURVNTcmVhbCkgKiB0ZXNzLT52ZXJ0ZXhDb3VudCAqIHZlcnRleFNpemUgKTtcblx0XHRcdGlmICghdGVzcy0+dmVydGljZXMpXG5cdFx0XHR7XG5cdFx0XHRcdHRlc3MtPm91dE9mTWVtb3J5ID0gMTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fSovXG5cdFx0XHR0aGlzLnZlcnRpY2VzID0gW107XG5cdFx0XHR0aGlzLnZlcnRpY2VzLmxlbmd0aCA9IG1heFZlcnRleENvdW50ICogdmVydGV4U2l6ZTtcblxuXHQvKlx0XHR0ZXNzLT52ZXJ0ZXhJbmRpY2VzID0gKFRFU1NpbmRleCopdGVzcy0+YWxsb2MubWVtYWxsb2MoIHRlc3MtPmFsbG9jLnVzZXJEYXRhLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQgICAgc2l6ZW9mKFRFU1NpbmRleCkgKiB0ZXNzLT52ZXJ0ZXhDb3VudCApO1xuXHRcdFx0aWYgKCF0ZXNzLT52ZXJ0ZXhJbmRpY2VzKVxuXHRcdFx0e1xuXHRcdFx0XHR0ZXNzLT5vdXRPZk1lbW9yeSA9IDE7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH0qL1xuXHRcdFx0dGhpcy52ZXJ0ZXhJbmRpY2VzID0gW107XG5cdFx0XHR0aGlzLnZlcnRleEluZGljZXMubGVuZ3RoID0gbWF4VmVydGV4Q291bnQ7XG5cblx0XHRcdFxuXHRcdFx0Ly8gT3V0cHV0IHZlcnRpY2VzLlxuXHRcdFx0Zm9yICggdiA9IG1lc2gudkhlYWQubmV4dDsgdiAhPT0gbWVzaC52SGVhZDsgdiA9IHYubmV4dCApXG5cdFx0XHR7XG5cdFx0XHRcdGlmICggdi5uICE9IC0xIClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdC8vIFN0b3JlIGNvb3JkaW5hdGVcblx0XHRcdFx0XHR2YXIgaWR4ID0gdi5uICogdmVydGV4U2l6ZTtcblx0XHRcdFx0XHR0aGlzLnZlcnRpY2VzW2lkeCswXSA9IHYuY29vcmRzWzBdO1xuXHRcdFx0XHRcdHRoaXMudmVydGljZXNbaWR4KzFdID0gdi5jb29yZHNbMV07XG5cdFx0XHRcdFx0aWYgKCB2ZXJ0ZXhTaXplID4gMiApXG5cdFx0XHRcdFx0XHR0aGlzLnZlcnRpY2VzW2lkeCsyXSA9IHYuY29vcmRzWzJdO1xuXHRcdFx0XHRcdC8vIFN0b3JlIHZlcnRleCBpbmRleC5cblx0XHRcdFx0XHR0aGlzLnZlcnRleEluZGljZXNbdi5uXSA9IHYuaWR4O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIE91dHB1dCBpbmRpY2VzLlxuXHRcdFx0dmFyIG5lbCA9IDA7XG5cdFx0XHRmb3IgKCBmID0gbWVzaC5mSGVhZC5uZXh0OyBmICE9PSBtZXNoLmZIZWFkOyBmID0gZi5uZXh0IClcblx0XHRcdHtcblx0XHRcdFx0aWYgKCAhZi5pbnNpZGUgKSBjb250aW51ZTtcblx0XHRcdFx0XG5cdFx0XHRcdC8vIFN0b3JlIHBvbHlnb25cblx0XHRcdFx0ZWRnZSA9IGYuYW5FZGdlO1xuXHRcdFx0XHRmYWNlVmVydHMgPSAwO1xuXHRcdFx0XHRkb1xuXHRcdFx0XHR7XG5cdFx0XHRcdFx0diA9IGVkZ2UuT3JnO1xuXHRcdFx0XHRcdHRoaXMuZWxlbWVudHNbbmVsKytdID0gdi5uO1xuXHRcdFx0XHRcdGZhY2VWZXJ0cysrO1xuXHRcdFx0XHRcdGVkZ2UgPSBlZGdlLkxuZXh0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHdoaWxlIChlZGdlICE9PSBmLmFuRWRnZSk7XG5cdFx0XHRcdC8vIEZpbGwgdW51c2VkLlxuXHRcdFx0XHRmb3IgKGkgPSBmYWNlVmVydHM7IGkgPCBwb2x5U2l6ZTsgKytpKVxuXHRcdFx0XHRcdHRoaXMuZWxlbWVudHNbbmVsKytdID0gLTE7XG5cblx0XHRcdFx0Ly8gU3RvcmUgcG9seWdvbiBjb25uZWN0aXZpdHlcblx0XHRcdFx0aWYgKCBlbGVtZW50VHlwZSA9PSBUZXNzMi5DT05ORUNURURfUE9MWUdPTlMgKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0ZWRnZSA9IGYuYW5FZGdlO1xuXHRcdFx0XHRcdGRvXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0dGhpcy5lbGVtZW50c1tuZWwrK10gPSB0aGlzLmdldE5laWdoYm91ckZhY2VfKCBlZGdlICk7XG5cdFx0XHRcdFx0XHRlZGdlID0gZWRnZS5MbmV4dDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0d2hpbGUgKGVkZ2UgIT09IGYuYW5FZGdlKTtcblx0XHRcdFx0XHQvLyBGaWxsIHVudXNlZC5cblx0XHRcdFx0XHRmb3IgKGkgPSBmYWNlVmVydHM7IGkgPCBwb2x5U2l6ZTsgKytpKVxuXHRcdFx0XHRcdFx0dGhpcy5lbGVtZW50c1tuZWwrK10gPSAtMTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0Ly9cdHZvaWQgT3V0cHV0Q29udG91cnMoIFRFU1N0ZXNzZWxhdG9yICp0ZXNzLCBURVNTbWVzaCAqbWVzaCwgaW50IHZlcnRleFNpemUgKVxuXHRcdG91dHB1dENvbnRvdXJzXzogZnVuY3Rpb24oIG1lc2gsIHZlcnRleFNpemUgKSB7XG5cdFx0XHR2YXIgZjtcblx0XHRcdHZhciBlZGdlO1xuXHRcdFx0dmFyIHN0YXJ0O1xuXHRcdFx0dmFyIHZlcnRzO1xuXHRcdFx0dmFyIGVsZW1lbnRzO1xuXHRcdFx0dmFyIHZlcnRJbmRzO1xuXHRcdFx0dmFyIHN0YXJ0VmVydCA9IDA7XG5cdFx0XHR2YXIgdmVydENvdW50ID0gMDtcblxuXHRcdFx0dGhpcy52ZXJ0ZXhDb3VudCA9IDA7XG5cdFx0XHR0aGlzLmVsZW1lbnRDb3VudCA9IDA7XG5cblx0XHRcdGZvciAoIGYgPSBtZXNoLmZIZWFkLm5leHQ7IGYgIT09IG1lc2guZkhlYWQ7IGYgPSBmLm5leHQgKVxuXHRcdFx0e1xuXHRcdFx0XHRpZiAoICFmLmluc2lkZSApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdHN0YXJ0ID0gZWRnZSA9IGYuYW5FZGdlO1xuXHRcdFx0XHRkb1xuXHRcdFx0XHR7XG5cdFx0XHRcdFx0dGhpcy52ZXJ0ZXhDb3VudCsrO1xuXHRcdFx0XHRcdGVkZ2UgPSBlZGdlLkxuZXh0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHdoaWxlICggZWRnZSAhPT0gc3RhcnQgKTtcblxuXHRcdFx0XHR0aGlzLmVsZW1lbnRDb3VudCsrO1xuXHRcdFx0fVxuXG5cdC8qXHRcdHRlc3MtPmVsZW1lbnRzID0gKFRFU1NpbmRleCopdGVzcy0+YWxsb2MubWVtYWxsb2MoIHRlc3MtPmFsbG9jLnVzZXJEYXRhLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ICBzaXplb2YoVEVTU2luZGV4KSAqIHRlc3MtPmVsZW1lbnRDb3VudCAqIDIgKTtcblx0XHRcdGlmICghdGVzcy0+ZWxlbWVudHMpXG5cdFx0XHR7XG5cdFx0XHRcdHRlc3MtPm91dE9mTWVtb3J5ID0gMTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fSovXG5cdFx0XHR0aGlzLmVsZW1lbnRzID0gW107XG5cdFx0XHR0aGlzLmVsZW1lbnRzLmxlbmd0aCA9IHRoaXMuZWxlbWVudENvdW50ICogMjtcblx0XHRcdFxuXHQvKlx0XHR0ZXNzLT52ZXJ0aWNlcyA9IChURVNTcmVhbCopdGVzcy0+YWxsb2MubWVtYWxsb2MoIHRlc3MtPmFsbG9jLnVzZXJEYXRhLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ICBzaXplb2YoVEVTU3JlYWwpICogdGVzcy0+dmVydGV4Q291bnQgKiB2ZXJ0ZXhTaXplICk7XG5cdFx0XHRpZiAoIXRlc3MtPnZlcnRpY2VzKVxuXHRcdFx0e1xuXHRcdFx0XHR0ZXNzLT5vdXRPZk1lbW9yeSA9IDE7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH0qL1xuXHRcdFx0dGhpcy52ZXJ0aWNlcyA9IFtdO1xuXHRcdFx0dGhpcy52ZXJ0aWNlcy5sZW5ndGggPSB0aGlzLnZlcnRleENvdW50ICogdmVydGV4U2l6ZTtcblxuXHQvKlx0XHR0ZXNzLT52ZXJ0ZXhJbmRpY2VzID0gKFRFU1NpbmRleCopdGVzcy0+YWxsb2MubWVtYWxsb2MoIHRlc3MtPmFsbG9jLnVzZXJEYXRhLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQgICAgc2l6ZW9mKFRFU1NpbmRleCkgKiB0ZXNzLT52ZXJ0ZXhDb3VudCApO1xuXHRcdFx0aWYgKCF0ZXNzLT52ZXJ0ZXhJbmRpY2VzKVxuXHRcdFx0e1xuXHRcdFx0XHR0ZXNzLT5vdXRPZk1lbW9yeSA9IDE7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH0qL1xuXHRcdFx0dGhpcy52ZXJ0ZXhJbmRpY2VzID0gW107XG5cdFx0XHR0aGlzLnZlcnRleEluZGljZXMubGVuZ3RoID0gdGhpcy52ZXJ0ZXhDb3VudDtcblxuXHRcdFx0dmFyIG52ID0gMDtcblx0XHRcdHZhciBudmkgPSAwO1xuXHRcdFx0dmFyIG5lbCA9IDA7XG5cdFx0XHRzdGFydFZlcnQgPSAwO1xuXG5cdFx0XHRmb3IgKCBmID0gbWVzaC5mSGVhZC5uZXh0OyBmICE9PSBtZXNoLmZIZWFkOyBmID0gZi5uZXh0IClcblx0XHRcdHtcblx0XHRcdFx0aWYgKCAhZi5pbnNpZGUgKSBjb250aW51ZTtcblxuXHRcdFx0XHR2ZXJ0Q291bnQgPSAwO1xuXHRcdFx0XHRzdGFydCA9IGVkZ2UgPSBmLmFuRWRnZTtcblx0XHRcdFx0ZG9cblx0XHRcdFx0e1xuXHRcdFx0XHRcdHRoaXMudmVydGljZXNbbnYrK10gPSBlZGdlLk9yZy5jb29yZHNbMF07XG5cdFx0XHRcdFx0dGhpcy52ZXJ0aWNlc1tudisrXSA9IGVkZ2UuT3JnLmNvb3Jkc1sxXTtcblx0XHRcdFx0XHRpZiAoIHZlcnRleFNpemUgPiAyIClcblx0XHRcdFx0XHRcdHRoaXMudmVydGljZXNbbnYrK10gPSBlZGdlLk9yZy5jb29yZHNbMl07XG5cdFx0XHRcdFx0dGhpcy52ZXJ0ZXhJbmRpY2VzW252aSsrXSA9IGVkZ2UuT3JnLmlkeDtcblx0XHRcdFx0XHR2ZXJ0Q291bnQrKztcblx0XHRcdFx0XHRlZGdlID0gZWRnZS5MbmV4dDtcblx0XHRcdFx0fVxuXHRcdFx0XHR3aGlsZSAoIGVkZ2UgIT09IHN0YXJ0ICk7XG5cblx0XHRcdFx0dGhpcy5lbGVtZW50c1tuZWwrK10gPSBzdGFydFZlcnQ7XG5cdFx0XHRcdHRoaXMuZWxlbWVudHNbbmVsKytdID0gdmVydENvdW50O1xuXG5cdFx0XHRcdHN0YXJ0VmVydCArPSB2ZXJ0Q291bnQ7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGFkZENvbnRvdXI6IGZ1bmN0aW9uKCBzaXplLCB2ZXJ0aWNlcyApXG5cdFx0e1xuXHRcdFx0dmFyIGU7XG5cdFx0XHR2YXIgaTtcblxuXHRcdFx0aWYgKCB0aGlzLm1lc2ggPT09IG51bGwgKVxuXHRcdFx0ICBcdHRoaXMubWVzaCA9IG5ldyBURVNTbWVzaCgpO1xuXHQvKlx0IFx0aWYgKCB0ZXNzLT5tZXNoID09IE5VTEwgKSB7XG5cdFx0XHRcdHRlc3MtPm91dE9mTWVtb3J5ID0gMTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fSovXG5cblx0XHRcdGlmICggc2l6ZSA8IDIgKVxuXHRcdFx0XHRzaXplID0gMjtcblx0XHRcdGlmICggc2l6ZSA+IDMgKVxuXHRcdFx0XHRzaXplID0gMztcblxuXHRcdFx0ZSA9IG51bGw7XG5cblx0XHRcdGZvciggaSA9IDA7IGkgPCB2ZXJ0aWNlcy5sZW5ndGg7IGkgKz0gc2l6ZSApXG5cdFx0XHR7XG5cdFx0XHRcdGlmKCBlID09IG51bGwgKSB7XG5cdFx0XHRcdFx0LyogTWFrZSBhIHNlbGYtbG9vcCAob25lIHZlcnRleCwgb25lIGVkZ2UpLiAqL1xuXHRcdFx0XHRcdGUgPSB0aGlzLm1lc2gubWFrZUVkZ2UoKTtcblx0LypcdFx0XHRcdGlmICggZSA9PSBOVUxMICkge1xuXHRcdFx0XHRcdFx0dGVzcy0+b3V0T2ZNZW1vcnkgPSAxO1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH0qL1xuXHRcdFx0XHRcdHRoaXMubWVzaC5zcGxpY2UoIGUsIGUuU3ltICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0LyogQ3JlYXRlIGEgbmV3IHZlcnRleCBhbmQgZWRnZSB3aGljaCBpbW1lZGlhdGVseSBmb2xsb3cgZVxuXHRcdFx0XHRcdCogaW4gdGhlIG9yZGVyaW5nIGFyb3VuZCB0aGUgbGVmdCBmYWNlLlxuXHRcdFx0XHRcdCovXG5cdFx0XHRcdFx0dGhpcy5tZXNoLnNwbGl0RWRnZSggZSApO1xuXHRcdFx0XHRcdGUgPSBlLkxuZXh0O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0LyogVGhlIG5ldyB2ZXJ0ZXggaXMgbm93IGUtPk9yZy4gKi9cblx0XHRcdFx0ZS5PcmcuY29vcmRzWzBdID0gdmVydGljZXNbaSswXTtcblx0XHRcdFx0ZS5PcmcuY29vcmRzWzFdID0gdmVydGljZXNbaSsxXTtcblx0XHRcdFx0aWYgKCBzaXplID4gMiApXG5cdFx0XHRcdFx0ZS5PcmcuY29vcmRzWzJdID0gdmVydGljZXNbaSsyXTtcblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdGUuT3JnLmNvb3Jkc1syXSA9IDAuMDtcblx0XHRcdFx0LyogU3RvcmUgdGhlIGluc2VydGlvbiBudW1iZXIgc28gdGhhdCB0aGUgdmVydGV4IGNhbiBiZSBsYXRlciByZWNvZ25pemVkLiAqL1xuXHRcdFx0XHRlLk9yZy5pZHggPSB0aGlzLnZlcnRleEluZGV4Q291bnRlcisrO1xuXG5cdFx0XHRcdC8qIFRoZSB3aW5kaW5nIG9mIGFuIGVkZ2Ugc2F5cyBob3cgdGhlIHdpbmRpbmcgbnVtYmVyIGNoYW5nZXMgYXMgd2Vcblx0XHRcdFx0KiBjcm9zcyBmcm9tIHRoZSBlZGdlJydzIHJpZ2h0IGZhY2UgdG8gaXRzIGxlZnQgZmFjZS4gIFdlIGFkZCB0aGVcblx0XHRcdFx0KiB2ZXJ0aWNlcyBpbiBzdWNoIGFuIG9yZGVyIHRoYXQgYSBDQ1cgY29udG91ciB3aWxsIGFkZCArMSB0b1xuXHRcdFx0XHQqIHRoZSB3aW5kaW5nIG51bWJlciBvZiB0aGUgcmVnaW9uIGluc2lkZSB0aGUgY29udG91ci5cblx0XHRcdFx0Ki9cblx0XHRcdFx0ZS53aW5kaW5nID0gMTtcblx0XHRcdFx0ZS5TeW0ud2luZGluZyA9IC0xO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0Ly9cdGludCB0ZXNzVGVzc2VsYXRlKCBURVNTdGVzc2VsYXRvciAqdGVzcywgaW50IHdpbmRpbmdSdWxlLCBpbnQgZWxlbWVudFR5cGUsIGludCBwb2x5U2l6ZSwgaW50IHZlcnRleFNpemUsIGNvbnN0IFRFU1NyZWFsKiBub3JtYWwgKVxuXHRcdHRlc3NlbGF0ZTogZnVuY3Rpb24oIHdpbmRpbmdSdWxlLCBlbGVtZW50VHlwZSwgcG9seVNpemUsIHZlcnRleFNpemUsIG5vcm1hbCApIHtcblx0XHRcdHRoaXMudmVydGljZXMgPSBbXTtcblx0XHRcdHRoaXMuZWxlbWVudHMgPSBbXTtcblx0XHRcdHRoaXMudmVydGV4SW5kaWNlcyA9IFtdO1xuXG5cdFx0XHR0aGlzLnZlcnRleEluZGV4Q291bnRlciA9IDA7XG5cdFx0XHRcblx0XHRcdGlmIChub3JtYWwpXG5cdFx0XHR7XG5cdFx0XHRcdHRoaXMubm9ybWFsWzBdID0gbm9ybWFsWzBdO1xuXHRcdFx0XHR0aGlzLm5vcm1hbFsxXSA9IG5vcm1hbFsxXTtcblx0XHRcdFx0dGhpcy5ub3JtYWxbMl0gPSBub3JtYWxbMl07XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMud2luZGluZ1J1bGUgPSB3aW5kaW5nUnVsZTtcblxuXHRcdFx0aWYgKHZlcnRleFNpemUgPCAyKVxuXHRcdFx0XHR2ZXJ0ZXhTaXplID0gMjtcblx0XHRcdGlmICh2ZXJ0ZXhTaXplID4gMylcblx0XHRcdFx0dmVydGV4U2l6ZSA9IDM7XG5cblx0LypcdFx0aWYgKHNldGptcCh0ZXNzLT5lbnYpICE9IDApIHsgXG5cdFx0XHRcdC8vIGNvbWUgYmFjayBoZXJlIGlmIG91dCBvZiBtZW1vcnlcblx0XHRcdFx0cmV0dXJuIDA7XG5cdFx0XHR9Ki9cblxuXHRcdFx0aWYgKCF0aGlzLm1lc2gpXG5cdFx0XHR7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0LyogRGV0ZXJtaW5lIHRoZSBwb2x5Z29uIG5vcm1hbCBhbmQgcHJvamVjdCB2ZXJ0aWNlcyBvbnRvIHRoZSBwbGFuZVxuXHRcdFx0KiBvZiB0aGUgcG9seWdvbi5cblx0XHRcdCovXG5cdFx0XHR0aGlzLnByb2plY3RQb2x5Z29uXygpO1xuXG5cdFx0XHQvKiB0ZXNzQ29tcHV0ZUludGVyaW9yKCB0ZXNzICkgY29tcHV0ZXMgdGhlIHBsYW5hciBhcnJhbmdlbWVudCBzcGVjaWZpZWRcblx0XHRcdCogYnkgdGhlIGdpdmVuIGNvbnRvdXJzLCBhbmQgZnVydGhlciBzdWJkaXZpZGVzIHRoaXMgYXJyYW5nZW1lbnRcblx0XHRcdCogaW50byByZWdpb25zLiAgRWFjaCByZWdpb24gaXMgbWFya2VkIFwiaW5zaWRlXCIgaWYgaXQgYmVsb25nc1xuXHRcdFx0KiB0byB0aGUgcG9seWdvbiwgYWNjb3JkaW5nIHRvIHRoZSBydWxlIGdpdmVuIGJ5IHRlc3MtPndpbmRpbmdSdWxlLlxuXHRcdFx0KiBFYWNoIGludGVyaW9yIHJlZ2lvbiBpcyBndWFyYW50ZWVkIGJlIG1vbm90b25lLlxuXHRcdFx0Ki9cblx0XHRcdFN3ZWVwLmNvbXB1dGVJbnRlcmlvciggdGhpcyApO1xuXG5cdFx0XHR2YXIgbWVzaCA9IHRoaXMubWVzaDtcblxuXHRcdFx0LyogSWYgdGhlIHVzZXIgd2FudHMgb25seSB0aGUgYm91bmRhcnkgY29udG91cnMsIHdlIHRocm93IGF3YXkgYWxsIGVkZ2VzXG5cdFx0XHQqIGV4Y2VwdCB0aG9zZSB3aGljaCBzZXBhcmF0ZSB0aGUgaW50ZXJpb3IgZnJvbSB0aGUgZXh0ZXJpb3IuXG5cdFx0XHQqIE90aGVyd2lzZSB3ZSB0ZXNzZWxsYXRlIGFsbCB0aGUgcmVnaW9ucyBtYXJrZWQgXCJpbnNpZGVcIi5cblx0XHRcdCovXG5cdFx0XHRpZiAoZWxlbWVudFR5cGUgPT0gVGVzczIuQk9VTkRBUllfQ09OVE9VUlMpIHtcblx0XHRcdFx0dGhpcy5zZXRXaW5kaW5nTnVtYmVyXyggbWVzaCwgMSwgdHJ1ZSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy50ZXNzZWxsYXRlSW50ZXJpb3JfKCBtZXNoICk7IFxuXHRcdFx0fVxuXHQvL1x0XHRpZiAocmMgPT0gMCkgbG9uZ2ptcCh0ZXNzLT5lbnYsMSk7ICAvKiBjb3VsZCd2ZSB1c2VkIGEgbGFiZWwgKi9cblxuXHRcdFx0bWVzaC5jaGVjaygpO1xuXG5cdFx0XHRpZiAoZWxlbWVudFR5cGUgPT0gVGVzczIuQk9VTkRBUllfQ09OVE9VUlMpIHtcblx0XHRcdFx0dGhpcy5vdXRwdXRDb250b3Vyc18oIG1lc2gsIHZlcnRleFNpemUgKTsgICAgIC8qIG91dHB1dCBjb250b3VycyAqL1xuXHRcdFx0fVxuXHRcdFx0ZWxzZVxuXHRcdFx0e1xuXHRcdFx0XHR0aGlzLm91dHB1dFBvbHltZXNoXyggbWVzaCwgZWxlbWVudFR5cGUsIHBvbHlTaXplLCB2ZXJ0ZXhTaXplICk7ICAgICAvKiBvdXRwdXQgcG9seWdvbnMgKi9cblx0XHRcdH1cblxuLy9cdFx0XHR0ZXNzLm1lc2ggPSBudWxsO1xuXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdH07IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiByYW5nZShtaW4sIG1heCwgdmFsdWUpIHtcbiAgcmV0dXJuICh2YWx1ZSAtIG1pbikgLyAobWF4IC0gbWluKVxufSIsIm1vZHVsZS5leHBvcnRzPXJlcXVpcmUoXCIvcHJvamVjdHMvYmxhY2tpY2Uvbm9kZV9tb2R1bGVzL3RocmVlLXNkZi10ZXh0L25vZGVfbW9kdWxlcy94dGVuZC9pbW11dGFibGUuanNcIikiXX0=
