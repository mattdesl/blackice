(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({"./test.js":[function(require,module,exports){
var blackice = require('./')

require('domready')(function() {
    document.body.style.margin = '0'
    document.body.style.overflow = 'hidden'

    //your canvas...
    var canvas = document.createElement('canvas')
    canvas.style.display = 'block'
    document.body.appendChild(canvas)

    var app = blackice({ 
        canvas: canvas
    })

    app.load(function(err) {
        if (err)
            console.error(err)
        app.start()
    })
})
},{"./":"/projects/blackice/index.js","domready":"/projects/blackice/node_modules/domready/ready.js"}],"/projects/blackice/fonts/Exo2SemiBold.json":[function(require,module,exports){
module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports={"pages":["Exo2SemiBold.png"],"chars":[{"id":32,"x":0,"y":0,"width":0,"height":0,"xoffset":0,"yoffset":33,"xadvance":7,"page":0,"chnl":0},{"id":41,"x":0,"y":0,"width":20,"height":41,"xoffset":-4,"yoffset":3,"xadvance":12,"page":0,"chnl":0},{"id":40,"x":20,"y":0,"width":19,"height":41,"xoffset":-3,"yoffset":3,"xadvance":12,"page":0,"chnl":0},{"id":124,"x":39,"y":0,"width":13,"height":40,"xoffset":-2,"yoffset":3,"xadvance":8,"page":0,"chnl":0},{"id":125,"x":52,"y":0,"width":18,"height":40,"xoffset":-3,"yoffset":4,"xadvance":11,"page":0,"chnl":0},{"id":123,"x":70,"y":0,"width":18,"height":40,"xoffset":-3,"yoffset":4,"xadvance":11,"page":0,"chnl":0},{"id":36,"x":88,"y":0,"width":25,"height":39,"xoffset":-3,"yoffset":3,"xadvance":18,"page":0,"chnl":0},{"id":93,"x":113,"y":0,"width":17,"height":39,"xoffset":-3,"yoffset":4,"xadvance":11,"page":0,"chnl":0},{"id":91,"x":130,"y":0,"width":17,"height":39,"xoffset":-2,"yoffset":4,"xadvance":11,"page":0,"chnl":0},{"id":81,"x":147,"y":0,"width":28,"height":39,"xoffset":-3,"yoffset":6,"xadvance":22,"page":0,"chnl":0},{"id":106,"x":175,"y":0,"width":16,"height":38,"xoffset":-4,"yoffset":6,"xadvance":9,"page":0,"chnl":0},{"id":92,"x":191,"y":0,"width":26,"height":34,"xoffset":-4,"yoffset":6,"xadvance":17,"page":0,"chnl":0},{"id":47,"x":217,"y":0,"width":26,"height":34,"xoffset":-4,"yoffset":6,"xadvance":17,"page":0,"chnl":0},{"id":102,"x":243,"y":0,"width":23,"height":33,"xoffset":-4,"yoffset":5,"xadvance":13,"page":0,"chnl":0},{"id":38,"x":266,"y":0,"width":32,"height":32,"xoffset":-3,"yoffset":6,"xadvance":25,"page":0,"chnl":0},{"id":35,"x":298,"y":0,"width":30,"height":32,"xoffset":-3,"yoffset":6,"xadvance":22,"page":0,"chnl":0},{"id":37,"x":328,"y":0,"width":36,"height":32,"xoffset":-3,"yoffset":6,"xadvance":29,"page":0,"chnl":0},{"id":63,"x":364,"y":0,"width":24,"height":32,"xoffset":-3,"yoffset":6,"xadvance":16,"page":0,"chnl":0},{"id":33,"x":388,"y":0,"width":14,"height":32,"xoffset":-2,"yoffset":6,"xadvance":9,"page":0,"chnl":0},{"id":48,"x":402,"y":0,"width":26,"height":32,"xoffset":-3,"yoffset":6,"xadvance":20,"page":0,"chnl":0},{"id":57,"x":428,"y":0,"width":25,"height":32,"xoffset":-3,"yoffset":6,"xadvance":19,"page":0,"chnl":0},{"id":56,"x":453,"y":0,"width":26,"height":32,"xoffset":-3,"yoffset":6,"xadvance":20,"page":0,"chnl":0},{"id":55,"x":479,"y":0,"width":24,"height":32,"xoffset":-3,"yoffset":6,"xadvance":17,"page":0,"chnl":0},{"id":54,"x":0,"y":41,"width":26,"height":32,"xoffset":-3,"yoffset":6,"xadvance":19,"page":0,"chnl":0},{"id":53,"x":26,"y":41,"width":24,"height":32,"xoffset":-3,"yoffset":6,"xadvance":17,"page":0,"chnl":0},{"id":52,"x":50,"y":41,"width":27,"height":32,"xoffset":-3,"yoffset":6,"xadvance":20,"page":0,"chnl":0},{"id":51,"x":77,"y":41,"width":25,"height":32,"xoffset":-3,"yoffset":6,"xadvance":18,"page":0,"chnl":0},{"id":50,"x":102,"y":41,"width":25,"height":32,"xoffset":-3,"yoffset":6,"xadvance":18,"page":0,"chnl":0},{"id":49,"x":127,"y":41,"width":19,"height":32,"xoffset":-4,"yoffset":6,"xadvance":13,"page":0,"chnl":0},{"id":121,"x":146,"y":41,"width":27,"height":32,"xoffset":-4,"yoffset":12,"xadvance":17,"page":0,"chnl":0},{"id":113,"x":173,"y":41,"width":25,"height":32,"xoffset":-3,"yoffset":12,"xadvance":19,"page":0,"chnl":0},{"id":112,"x":198,"y":41,"width":25,"height":32,"xoffset":-2,"yoffset":12,"xadvance":19,"page":0,"chnl":0},{"id":108,"x":223,"y":41,"width":17,"height":32,"xoffset":-2,"yoffset":6,"xadvance":10,"page":0,"chnl":0},{"id":107,"x":240,"y":41,"width":24,"height":32,"xoffset":-2,"yoffset":6,"xadvance":17,"page":0,"chnl":0},{"id":105,"x":264,"y":41,"width":14,"height":32,"xoffset":-2,"yoffset":6,"xadvance":8,"page":0,"chnl":0},{"id":104,"x":278,"y":41,"width":24,"height":32,"xoffset":-2,"yoffset":6,"xadvance":19,"page":0,"chnl":0},{"id":103,"x":302,"y":41,"width":27,"height":32,"xoffset":-4,"yoffset":12,"xadvance":18,"page":0,"chnl":0},{"id":100,"x":329,"y":41,"width":25,"height":32,"xoffset":-3,"yoffset":6,"xadvance":19,"page":0,"chnl":0},{"id":98,"x":354,"y":41,"width":25,"height":32,"xoffset":-2,"yoffset":6,"xadvance":19,"page":0,"chnl":0},{"id":90,"x":379,"y":41,"width":25,"height":32,"xoffset":-3,"yoffset":6,"xadvance":18,"page":0,"chnl":0},{"id":89,"x":404,"y":41,"width":28,"height":32,"xoffset":-4,"yoffset":6,"xadvance":19,"page":0,"chnl":0},{"id":88,"x":432,"y":41,"width":29,"height":32,"xoffset":-4,"yoffset":6,"xadvance":20,"page":0,"chnl":0},{"id":87,"x":461,"y":41,"width":39,"height":32,"xoffset":-4,"yoffset":6,"xadvance":31,"page":0,"chnl":0},{"id":86,"x":0,"y":73,"width":29,"height":32,"xoffset":-4,"yoffset":6,"xadvance":20,"page":0,"chnl":0},{"id":85,"x":29,"y":73,"width":27,"height":32,"xoffset":-2,"yoffset":6,"xadvance":21,"page":0,"chnl":0},{"id":84,"x":56,"y":73,"width":28,"height":32,"xoffset":-4,"yoffset":6,"xadvance":19,"page":0,"chnl":0},{"id":83,"x":84,"y":73,"width":25,"height":32,"xoffset":-3,"yoffset":6,"xadvance":18,"page":0,"chnl":0},{"id":82,"x":109,"y":73,"width":26,"height":32,"xoffset":-2,"yoffset":6,"xadvance":20,"page":0,"chnl":0},{"id":80,"x":135,"y":73,"width":26,"height":32,"xoffset":-2,"yoffset":6,"xadvance":19,"page":0,"chnl":0},{"id":79,"x":161,"y":73,"width":28,"height":32,"xoffset":-3,"yoffset":6,"xadvance":22,"page":0,"chnl":0},{"id":78,"x":189,"y":73,"width":28,"height":32,"xoffset":-2,"yoffset":6,"xadvance":23,"page":0,"chnl":0},{"id":77,"x":217,"y":73,"width":34,"height":32,"xoffset":-2,"yoffset":6,"xadvance":29,"page":0,"chnl":0},{"id":76,"x":251,"y":73,"width":24,"height":32,"xoffset":-2,"yoffset":6,"xadvance":17,"page":0,"chnl":0},{"id":75,"x":275,"y":73,"width":27,"height":32,"xoffset":-2,"yoffset":6,"xadvance":20,"page":0,"chnl":0},{"id":74,"x":302,"y":73,"width":18,"height":32,"xoffset":-4,"yoffset":6,"xadvance":11,"page":0,"chnl":0},{"id":73,"x":320,"y":73,"width":14,"height":32,"xoffset":-2,"yoffset":6,"xadvance":9,"page":0,"chnl":0},{"id":72,"x":334,"y":73,"width":27,"height":32,"xoffset":-2,"yoffset":6,"xadvance":22,"page":0,"chnl":0},{"id":71,"x":361,"y":73,"width":27,"height":32,"xoffset":-3,"yoffset":6,"xadvance":20,"page":0,"chnl":0},{"id":70,"x":388,"y":73,"width":24,"height":32,"xoffset":-2,"yoffset":6,"xadvance":17,"page":0,"chnl":0},{"id":69,"x":412,"y":73,"width":24,"height":32,"xoffset":-2,"yoffset":6,"xadvance":18,"page":0,"chnl":0},{"id":68,"x":436,"y":73,"width":27,"height":32,"xoffset":-2,"yoffset":6,"xadvance":21,"page":0,"chnl":0},{"id":67,"x":463,"y":73,"width":26,"height":32,"xoffset":-3,"yoffset":6,"xadvance":19,"page":0,"chnl":0},{"id":66,"x":0,"y":105,"width":26,"height":32,"xoffset":-2,"yoffset":6,"xadvance":20,"page":0,"chnl":0},{"id":65,"x":26,"y":105,"width":30,"height":32,"xoffset":-4,"yoffset":6,"xadvance":20,"page":0,"chnl":0},{"id":64,"x":56,"y":105,"width":29,"height":31,"xoffset":-2,"yoffset":9,"xadvance":24,"page":0,"chnl":0},{"id":116,"x":85,"y":105,"width":22,"height":30,"xoffset":-4,"yoffset":8,"xadvance":13,"page":0,"chnl":0},{"id":59,"x":107,"y":105,"width":14,"height":29,"xoffset":-2,"yoffset":14,"xadvance":8,"page":0,"chnl":0},{"id":122,"x":121,"y":105,"width":24,"height":26,"xoffset":-3,"yoffset":12,"xadvance":17,"page":0,"chnl":0},{"id":120,"x":145,"y":105,"width":26,"height":26,"xoffset":-4,"yoffset":12,"xadvance":17,"page":0,"chnl":0},{"id":119,"x":171,"y":105,"width":36,"height":26,"xoffset":-4,"yoffset":12,"xadvance":27,"page":0,"chnl":0},{"id":118,"x":207,"y":105,"width":27,"height":26,"xoffset":-4,"yoffset":12,"xadvance":17,"page":0,"chnl":0},{"id":117,"x":234,"y":105,"width":24,"height":26,"xoffset":-2,"yoffset":12,"xadvance":19,"page":0,"chnl":0},{"id":115,"x":258,"y":105,"width":24,"height":26,"xoffset":-3,"yoffset":12,"xadvance":17,"page":0,"chnl":0},{"id":114,"x":282,"y":105,"width":20,"height":26,"xoffset":-2,"yoffset":12,"xadvance":13,"page":0,"chnl":0},{"id":111,"x":302,"y":105,"width":25,"height":26,"xoffset":-3,"yoffset":12,"xadvance":18,"page":0,"chnl":0},{"id":110,"x":327,"y":105,"width":24,"height":26,"xoffset":-2,"yoffset":12,"xadvance":19,"page":0,"chnl":0},{"id":109,"x":351,"y":105,"width":33,"height":26,"xoffset":-2,"yoffset":12,"xadvance":28,"page":0,"chnl":0},{"id":101,"x":384,"y":105,"width":25,"height":26,"xoffset":-3,"yoffset":12,"xadvance":18,"page":0,"chnl":0},{"id":99,"x":409,"y":105,"width":23,"height":26,"xoffset":-3,"yoffset":12,"xadvance":16,"page":0,"chnl":0},{"id":97,"x":432,"y":105,"width":24,"height":26,"xoffset":-3,"yoffset":12,"xadvance":18,"page":0,"chnl":0},{"id":43,"x":456,"y":105,"width":24,"height":24,"xoffset":-3,"yoffset":11,"xadvance":17,"page":0,"chnl":0},{"id":62,"x":480,"y":105,"width":23,"height":24,"xoffset":-2,"yoffset":12,"xadvance":17,"page":0,"chnl":0},{"id":60,"x":0,"y":137,"width":23,"height":24,"xoffset":-3,"yoffset":12,"xadvance":17,"page":0,"chnl":0},{"id":58,"x":23,"y":137,"width":14,"height":24,"xoffset":-3,"yoffset":14,"xadvance":8,"page":0,"chnl":0},{"id":42,"x":37,"y":137,"width":21,"height":21,"xoffset":-3,"yoffset":6,"xadvance":14,"page":0,"chnl":0},{"id":61,"x":58,"y":137,"width":24,"height":20,"xoffset":-2,"yoffset":13,"xadvance":19,"page":0,"chnl":0},{"id":94,"x":82,"y":137,"width":23,"height":19,"xoffset":-4,"yoffset":8,"xadvance":14,"page":0,"chnl":0},{"id":44,"x":105,"y":137,"width":14,"height":19,"xoffset":-3,"yoffset":24,"xadvance":8,"page":0,"chnl":0},{"id":39,"x":119,"y":137,"width":13,"height":17,"xoffset":-3,"yoffset":6,"xadvance":7,"page":0,"chnl":0},{"id":96,"x":132,"y":137,"width":18,"height":17,"xoffset":-4,"yoffset":5,"xadvance":11,"page":0,"chnl":0},{"id":34,"x":150,"y":137,"width":18,"height":17,"xoffset":-3,"yoffset":6,"xadvance":12,"page":0,"chnl":0},{"id":126,"x":168,"y":137,"width":22,"height":14,"xoffset":-2,"yoffset":17,"xadvance":17,"page":0,"chnl":0},{"id":46,"x":190,"y":137,"width":14,"height":14,"xoffset":-3,"yoffset":24,"xadvance":8,"page":0,"chnl":0},{"id":95,"x":204,"y":137,"width":24,"height":13,"xoffset":-2,"yoffset":28,"xadvance":18,"page":0,"chnl":0},{"id":45,"x":228,"y":137,"width":19,"height":13,"xoffset":-2,"yoffset":18,"xadvance":14,"page":0,"chnl":0}],"kernings":[],"info":{"face":"Exo 2 Semi Bold","size":32,"bold":0,"italic":0,"charset":"","unicode":0,"stretchH":100,"smooth":1,"aa":1,"padding":[4,4,4,4],"spacing":[-8,-8]},"common":{"lineHeight":40,"base":33,"scaleW":512,"scaleH":512,"pages":1,"packed":0}}
},{}],"/projects/blackice/index.js":[function(require,module,exports){
(function (global){
require('raf.js')

var THREE = (typeof window !== "undefined" ? window.THREE : typeof global !== "undefined" ? global.THREE : null)
var Renderer = require('./lib/renderer')
var createFont = require('./lib/create-font')
var xtend = require('xtend')

module.exports = function(opt) {
    opt = opt||{}
    var app = require('canvas-app')(render, xtend({
        context: 'webgl',
        contextAttributes: { antialias: false, alpha: false },
        retina: true,
        onResize: handleResize
    }, opt))

    
    var renderer

    app.load = function(cb) {
        cb = cb || function() {}
        var gl = app.context
        createFont(gl, function(err, font) {
            renderer = Renderer({
                gl: gl, 
                width: app.width, 
                height: app.height,
                font: font
            })
            cb(err)
        })
    }

    return app

    function render(gl, width, height, dt) {
        if (renderer)
            renderer.draw(dt)
    }

    function handleResize(width, height) {
        if (renderer)
            renderer.resize(width, height)
    }

    function setupSmoothTex(gl, t) {
        t.minFilter = gl.LINEAR_MIPMAP_LINEAR
        t.magFilter = gl.LINEAR

        var ext = (gl.getExtension('EXT_texture_filter_anisotropic') 
                        || gl.getExtension("MOZ_EXT_texture_filter_anisotropic"));
        if (ext) {
            var maxAnistrophy = gl.getParameter(ext.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
            gl.texParameterf(gl.TEXTURE_2D, ext.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(16, maxAnistrophy));
        }

        t.generateMipmap()
    }

    function setupNearestTex(gl, t) {
        t.minFilter = t.magFilter = gl.NEAREST
    }
}
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./lib/create-font":"/projects/blackice/lib/create-font.js","./lib/renderer":"/projects/blackice/lib/renderer.js","canvas-app":"/projects/blackice/node_modules/canvas-app/index.js","raf.js":"/projects/blackice/node_modules/raf.js/raf.js","xtend":"/projects/blackice/node_modules/xtend/immutable.js"}],"/projects/blackice/lib/RigScene.js":[function(require,module,exports){
(function (global){
var THREE = (typeof window !== "undefined" ? window.THREE : typeof global !== "undefined" ? global.THREE : null)
var inherits = require('inherits')
var mixes = require('mixes')
var Base = THREE.Scene

var YOFF = 2.5

function RigScene(opt) {
    if (!(this instanceof RigScene))
        return new RigScene(opt)
    Base.call(this)
    this.fog = new THREE.FogExp2( 0x0b0516, 0.00015 );


    // var box = new THREE.Mesh(
    //     new THREE.BoxGeometry(20, 20, 10),
    //     new THREE.MeshBasicMaterial({ color: 0xaaaaaa, wireframe: false })
    // )

    // this.add(box)


    this.time = 0
    this.cubeMap = null
    this.updateMaterial()

    var loader = new THREE.OBJMTLLoader()
    loader.load('model/Prirazlomnayawithpipes3.obj', 'model/Prirazlomnayawithpipes3.mtl', function(object, materials) {
        var s = 0.3
        console.log(object, materials)
        object.scale.set(s,s,s)
        object.position.y -= YOFF
        this.mesh = object

        this.mesh.traverse(function(obj) {
            if (obj instanceof THREE.Mesh) {
                obj.castShadow = true
                obj.receiveShadow = true
                obj.material.shininess = 1
                if (obj.material.map) {
                    obj.material.transparent = true
                }
                // console.log(obj.material.uniforms)
            }
        })

        this.add(object)
    }.bind(this))
    

    // var geometry = new THREE.TorusKnotGeometry( 10, 3, 100, 16 );
    // var material = new THREE.MeshBasicMaterial( { color: 0xffff00 } );
    // var torusKnot = new THREE.Mesh( geometry, material );
    // this.add( torusKnot );
    // torusKnot.castShadow = true
    // torusKnot.receiveShadow = true

    this.lights = [
        [ new THREE.Vector3(-10, 20, -20), 1 ],
        [ new THREE.Vector3(15, 10, 15), 0.5 ]
    ].map(function(args, i) {
        var light = new THREE.DirectionalLight( 0xddf4fd, args[1] )
        light.position.copy(args[0])
        light.castShadow = true
        light.shadowMapWidth = 1024
        light.shadowMapHeight = 1024
        light.shadowCameraNear = 1
        light.shadowCameraFar = 100

        // light.helper = new THREE.DirectionalLightHelper(light, 4)
        // this.add(light.helper)
        this.add(light)
        return light
    },this)
}

inherits(RigScene, Base)

mixes(RigScene, {

    updateMaterial: function() {
        this.material = new THREE.MeshLambertMaterial({
            color: 0xaaaaaa,
            reflectivity: 0.4,
            envMap: this.cubeMap
        })

    },

    update: function(dt) {
        this.time += Math.min(dt, 30)/1000
        var m = this.mesh
        if (!m)
            return
        var anim = Math.sin(this.time)

        // this.lights.forEach(function(light) { light.helper.update() })
        // m.position.y = YOFF + anim*0.2
        // m.position.x = Math.sin(this.time*0.1)*0.05
        // m.position.z = Math.sin(this.time*0.2)*0.1
        // m.rotation.x = anim*0.03
        // m.rotation.y = Math.sin(this.time*Math.cos(this.time*0.1))*0.005
    }
})

module.exports = RigScene
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"inherits":"/projects/blackice/node_modules/inherits/inherits_browser.js","mixes":"/projects/blackice/node_modules/mixes/index.js"}],"/projects/blackice/lib/TextPass.js":[function(require,module,exports){
(function (global){
var THREE = (typeof window !== "undefined" ? window.THREE : typeof global !== "undefined" ? global.THREE : null);
var EffectComposer = require("three-effectcomposer")(THREE);
var inherits = require("inherits");
var Base = EffectComposer.RenderPass;
var plucker = require("plucker");
var number = require("as-number");
var TextElement = require("three-sdf-text")(THREE);
var xtend = require("xtend");
var UNIT_SCALE = 0.1;
var SCALE = [UNIT_SCALE, UNIT_SCALE, UNIT_SCALE];

var mat4 = {
    scale: require("gl-mat4/scale"),
    identity: require("gl-mat4/identity"),
    multiply: require("gl-mat4/multiply"),
    translate: require("gl-mat4/translate")
};

var setVec3 = require("gl-vec3/set");
var tmpVec3 = [0, 0, 0];
var pluckPanels = plucker("panels");
var glslify = require("glslify");
var createSDFShader = require("glslify/adapter.js")("\n#define GLSLIFY 1\n\nattribute vec4 position;\nattribute vec4 color;\nattribute vec2 texcoord0;\nuniform mat4 projection;\nuniform mat4 view;\nuniform mat4 model;\nvarying vec4 v_col;\nvarying vec2 v_tex0;\nvarying float animOffset;\nvoid main() {\n  gl_Position = projection * view * model * position;\n  v_col = color;\n  v_tex0 = texcoord0;\n  gl_PointSize = 1.0;\n  animOffset = position.x / 100.0;\n}", "\n#define GLSLIFY 1\n\n#ifdef GL_ES\n\nprecision mediump float;\n#endif\n\nvarying vec4 v_col;\nvarying vec2 v_tex0;\nvarying float animOffset;\nuniform sampler2D texture0;\nuniform sampler2D texture1;\nuniform float smoothing;\nuniform float fade;\nconst vec2 shadowOffset = vec2(-1.0 / 512.0);\nconst vec4 glowColor = vec4(vec3(0.1), 1.0);\nconst float glowMin = 0.4;\nconst float glowMax = 0.8;\nvoid main() {\n  float anim = fade * animOffset;\n  anim = clamp(mix(anim, 1.0, fade * fade), 0.0, 1.0);\n  vec4 smoothColor = vec4(0.0);\n  vec4 texColor = texture2D(texture0, v_tex0);\n  float dst = texColor.a;\n  float smoothAmt = mix(1.5, smoothing, anim);\n  float alpha = smoothstep(0.5 - smoothAmt, 0.5 + smoothAmt, dst);\n  vec4 base = v_col * vec4(alpha);\n  float glowDst = texture2D(texture0, v_tex0 + shadowOffset).a;\n  vec4 glow = glowColor * smoothstep(glowMin, glowMax, glowDst);\n  float mask = 1.0 - alpha;\n  gl_FragColor = mix(vec4(0.0), base, anim);\n  if(gl_FragColor.a < 0.1)\n    discard;\n  \n}", [{"name":"projection","type":"mat4"},{"name":"view","type":"mat4"},{"name":"model","type":"mat4"},{"name":"texture0","type":"sampler2D"},{"name":"texture1","type":"sampler2D"},{"name":"smoothing","type":"float"},{"name":"fade","type":"float"}], [{"name":"position","type":"vec4"},{"name":"color","type":"vec4"},{"name":"texcoord0","type":"vec2"}]);
var sdfShader;

function TextPass(opt) {
    if (!(this instanceof TextPass))
        return new TextPass(opt);

    opt = opt || {};
    var renderer = opt.renderer;
    var camera = opt.camera;
    var scene = opt.scene;
    Base.call(this, scene, camera);
    var font = opt.font;

    if (!sdfShader)
        sdfShader = createSDFShader(renderer.getContext());

    this.groups = (opt.groups || []).map(createGroups(renderer, font));
    window.groups = this.groups;
}

function createGroups(renderer, font) {
    return function(group, groupIndex) {
        group.elements = group.panels.map(function(panel, index) {
            var side = (index === 0 ? 1 : -1);

            return panel.labels.map(function(label) {
                return createElement(label, side, renderer, font);
            });
        }).reduce(function(prev, b) {
            return prev.concat(b);
        }, []);

        group._opacity = 1;
        group.fade = 1;
        group.showing = true;
        group.animatingOut = false;

        Object.defineProperty(group, "opacity", {
            get: function() {
                return group._opacity;
            },

            set: function(val) {
                group._opacity = val;

                group.elements.forEach(function(e) {
                    e.text.opacity = val;
                });

                group.panels.forEach(function(p) {
                    p.container.visible = val > 0.01;

                    p.shapes.forEach(function(shape) {
                        shape.material.opacity = val;
                        shape.visible = val > 0.01;
                    });
                });
            }
        });

        return group;
    };
}

function createElement(label, side, renderer, font) {
    var textOpt = xtend(label, {
        font: font,
        textures: font.textures,
        shader: sdfShader
    });

    var textEl = TextElement(renderer, textOpt);

    return xtend(label, {
        text: textEl,
        side: side
    });
}

function renderElement(camera, e, fade) {
    e.object3d.updateMatrixWorld(true);
    var transform = e.text.transform;
    mat4.identity(transform);
    mat4.scale(transform, transform, SCALE);
    setVec3(tmpVec3, e.translation[0], e.translation[1], e.translation[2]);
    mat4.translate(transform, transform, tmpVec3);
    setVec3(tmpVec3, e.size, e.size, e.size);
    mat4.scale(transform, transform, tmpVec3);
    e.text.shader.bind();
    e.text.shader.uniforms.fade = fade;
    e.text.draw(camera, e.object3d);
}

inherits(TextPass, Base);

TextPass.prototype.render = function(renderer, writeBuffer, readBuffer, delta) {
    Base.prototype.render.call(this, renderer, writeBuffer, readBuffer, delta);
    var camera = this.camera;

    this.groups.forEach(function(g) {
        g.elements.forEach(function(e) {
            if (!g.showing)
                return;

            renderElement(camera, e, g.fade);
        });
    });

    renderer.resetGLState();
    renderer.resetAttributes();
};

module.exports = TextPass;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"as-number":"/projects/blackice/node_modules/as-number/index.js","gl-mat4/identity":"/projects/blackice/node_modules/gl-mat4/identity.js","gl-mat4/multiply":"/projects/blackice/node_modules/gl-mat4/multiply.js","gl-mat4/scale":"/projects/blackice/node_modules/gl-mat4/scale.js","gl-mat4/translate":"/projects/blackice/node_modules/gl-mat4/translate.js","gl-vec3/set":"/projects/blackice/node_modules/gl-vec3/set.js","glslify":"/projects/blackice/node_modules/glslify/browser.js","glslify/adapter.js":"/projects/blackice/node_modules/glslify/adapter.js","inherits":"/projects/blackice/node_modules/inherits/inherits_browser.js","plucker":"/projects/blackice/node_modules/plucker/index.js","three-effectcomposer":"/projects/blackice/node_modules/three-effectcomposer/index.js","three-sdf-text":"/projects/blackice/node_modules/three-sdf-text/index.js","xtend":"/projects/blackice/node_modules/xtend/immutable.js"}],"/projects/blackice/lib/animate-labels.js":[function(require,module,exports){
(function (global){
var TweenMax = (typeof window !== "undefined" ? window.TweenMax : typeof global !== "undefined" ? global.TweenMax : null)
var clamp = require('clamp')
var smoothstep = require('smoothstep')

var lastIndex = -1

module.exports = function(controller, labels) {
    var closeIndex = closest(controller, labels)

    // console.log(controller.theta)
    labels.forEach(function(label, i) {
        // setShowing(label, true)
        var visible = i===closeIndex
        if (visible && !label.showing) {
            animateInFeature(label)
        } else if (!visible && label.showing) {
            animateOutFeature(label)
        }
    })
}

module.exports.hideAll = function(features) {
    features.forEach(function(f) {
        setShowing(f, false)
    })
}

function distance(controller, label) {
    //signed distance
    var x = -label.theta, 
        y = controller.theta

    var abdist = Math.abs(x - y)
    return Math.min((2 * Math.PI) - abdist, abdist)

}

function closest(controller, labels) {
    var minDist = Number.MAX_VALUE
    var ret = -1
    labels.forEach(function(label, index) {
        var dist = distance(controller, label)
        
        if (dist < minDist) {
            minDist = dist
            ret = index
        }
    })
    return ret
}

function setShowing(feature, showing) {
    feature.showing = showing
}

function animateInFeature(feature) {
    feature.showing = true
    feature.fade = 0
    TweenMax.killTweensOf(feature)
    TweenMax.to(feature, 0.5, {
        fade: 1.0,
        ease: "easeOutQuad"
    })
}

function animateOutFeature(feature) {
    if (feature.animatingOut)
        return

    feature.animatingOut = true
    TweenMax.to(feature, 0.5, {
        fade: 0,
        ease: 'easeOutQuad',
        onComplete: hideFeature.bind(null, feature)
    })
}

function hideFeature(feature) {
    feature.animatingOut = false
    feature.showing = false
}
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"clamp":"/projects/blackice/node_modules/clamp/index.js","smoothstep":"/projects/blackice/node_modules/smoothstep/index.js"}],"/projects/blackice/lib/create-font.js":[function(require,module,exports){
var Font = require('../fonts/Exo2SemiBold.json')
var fontImage = 'fonts/Exo2SemiBold.png'
var img = require('img')
var createTexture = require('gl-texture2d')

module.exports = function(gl, cb) {
    img(fontImage, function(err, res) {
        if (err) {
            cb(err)
            return
        }

        Font.textures = [res].map(function(i) {
            var t = createTexture(gl, i)

            t.minFilter = gl.LINEAR_MIPMAP_LINEAR
            t.magFilter = gl.LINEAR

            var ext = (gl.getExtension('EXT_texture_filter_anisotropic') 
                            || gl.getExtension("MOZ_EXT_texture_filter_anisotropic"));
            if (ext) {
                var maxAnistrophy = gl.getParameter(ext.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
                gl.texParameterf(gl.TEXTURE_2D, ext.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(16, maxAnistrophy));
            }

            t.generateMipmap()
            return t
        })
        
        cb(null, Font)
    })
}
},{"../fonts/Exo2SemiBold.json":"/projects/blackice/fonts/Exo2SemiBold.json","gl-texture2d":"/projects/blackice/node_modules/gl-texture2d/texture.js","img":"/projects/blackice/node_modules/img/index.js"}],"/projects/blackice/lib/create-text-pass.js":[function(require,module,exports){
(function (global){
var TextPass = require('./TextPass')
var THREE = (typeof window !== "undefined" ? window.THREE : typeof global !== "undefined" ? global.THREE : null)
var xtend = require('xtend')
var getSVG = require('./get-svg')
var getPoly = require('./get-polygon')
var Complex = require('three-simplicial-complex')(THREE)

var UNIT_SCALE = 0.1

var data = require('./text-data')

module.exports = function(opt) {
    var groups = createGroups()
    
    groups.forEach(function(group) {
        // var len = 100
        // var dir = new THREE.Vector3(Math.cos(group.theta), 0, Math.sin(group.theta))
        // var arrow = new THREE.ArrowHelper(dir, new THREE.Vector3(), len)
        // opt.scene.add(arrow)

        group.panels.forEach(function(panel) {
            opt.scene.add(panel.container)
        })
    })

    return TextPass(xtend(opt, {
        groups: groups
    }))
}

function createGroups() {
    return data.map(function(group, i, list) {
        var theta = i/(list.length+1) * Math.PI * 2
        group = xtend(group, {
            panels: group.panels.map(function(panel, index) {
                return createPanel(panel, index, theta)
            }),
            theta: theta
        })
        return group
    })
}

function createPanel(data, index, rotation) {
    var container = new THREE.Object3D()
    var mirror = index === 1

    var radius = 20
    if (mirror) {
        rotation += Math.PI*2
        radius *= -1
    }

    //make text perpendicular to theta rotation
    // rotation -= Math.PI/2 

    container.position.set(
        Math.cos(rotation) * radius,
        15,
        Math.sin(rotation) * radius
    )
    

    // container.position.copy(data.origin)

    var pos = container.position
    var dir = pos.clone().sub(new THREE.Vector3(0,pos.y,0)).normalize()

    var rotOff = 0//Math.PI/10 * (mirror ? -1 : 1)

    var dx = pos.x,
        dz = pos.z,
        theta = -Math.atan2(dz, dx) - rotOff
    // container.rotation.y = theta
    container.rotation.y = theta
    container.rotation.x = 0
    
    if (mirror) {
        container.scale.x *= -1
    }

    var labels = data.labels.map(function(label) {
        var obj = new THREE.Object3D()
        container.add(obj)
        if (mirror)
            obj.position.x = -data.width||0
        return xtend({ size: 1, translation: [0, 0, 0] }, label, { 
            object3d: obj, 
            // theta: theta
        })
    })

    var shapes = (data.shapes||[]).map(function(shape) {
        var complex = shape.path ? getSVG(shape.path) : getPoly(shape.points)
        var geo = Complex(complex)
        var mesh = new THREE.Mesh(geo, new THREE.MeshBasicMaterial({ 
            color: 0xffffff,
            side: THREE.DoubleSide,
            opacity: 1,
            transparent: true
        }))
        
        if (shape.position) mesh.position.fromArray(shape.position)
        if (shape.scale) mesh.scale.fromArray(shape.scale)

        container.add(mesh)
        return mesh
    })

    return {
        labels: labels,
        shapes: shapes,
        container: container
    }
}
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./TextPass":"/projects/blackice/lib/TextPass.js","./get-polygon":"/projects/blackice/lib/get-polygon.js","./get-svg":"/projects/blackice/lib/get-svg.js","./text-data":"/projects/blackice/lib/text-data.js","three-simplicial-complex":"/projects/blackice/node_modules/three-simplicial-complex/index.js","xtend":"/projects/blackice/node_modules/xtend/immutable.js"}],"/projects/blackice/lib/get-polygon.js":[function(require,module,exports){
var triangulate = require('triangulate-contours')
var normalize = require('normalize-path-scale')

module.exports = function(points) {
    points = points.split(' ').map(function(p) {
        return p.split(',').map(function(n) {
            return parseFloat(n, 10)
        })
    })

    points = normalize(points)

    var triangulated = triangulate([ points ])
    triangulated.positions = triangulated.positions.map(function(p) {
        return [p[0], p[1], 0]
    })
    return triangulated
}
},{"normalize-path-scale":"/projects/blackice/node_modules/normalize-path-scale/index.js","triangulate-contours":"/projects/blackice/node_modules/triangulate-contours/index.js"}],"/projects/blackice/lib/get-svg.js":[function(require,module,exports){
var parse = require('parse-svg-path')
var contours = require('svg-path-contours')
var simplify = require('simplify-path')
var triangulate = require('triangulate-contours')
var normalize = require('normalize-path-scale')

module.exports = function(contents) {
    var parsed = parse(contents)
    console.log(parsed, contents)
    //get a list of polylines/contours from svg contents
    var lines = contours(parsed)

    //simplify the contours before triangulation
    // lines = lines.map(function(path) {
    //     return simplify(path, threshold)
    // })
    
    //turns into triangles, returns { positions, cells }
    var shape = triangulate(lines)

    //normalize(shape.positions)

    shape.positions = shape.positions.map(function(p) {
        return [p[0], p[1], 0]
    })
    return shape
}
},{"normalize-path-scale":"/projects/blackice/node_modules/normalize-path-scale/index.js","parse-svg-path":"/projects/blackice/node_modules/parse-svg-path/index.js","simplify-path":"/projects/blackice/node_modules/simplify-path/index.js","svg-path-contours":"/projects/blackice/node_modules/svg-path-contours/index.js","triangulate-contours":"/projects/blackice/node_modules/triangulate-contours/index.js"}],"/projects/blackice/lib/renderer.js":[function(require,module,exports){
(function (global){
var THREE = (typeof window !== "undefined" ? window.THREE : typeof global !== "undefined" ? global.THREE : null)

var RigScene = require('./RigScene')
var OrbitController = require('./three-orbit-camera')(THREE)
var Effects = require('./setup-effects')

var TweenMax = (typeof window !== "undefined" ? window.TweenMax : typeof global !== "undefined" ? global.TweenMax : null)
var animateLabels = require('./animate-labels')
var hideLabels = animateLabels.hideAll

var clamp = require('clamp')
var pluck = require('plucker')
var number = require('as-number')
var smoothstep = require('smoothstep')
var lerp = require('lerp')
var unlerp = require('unlerp')

module.exports = function(opt) {
    opt = opt||{}

    var Font = opt.font

    if (!Font || !Font.textures)
        throw new Error('must specify font with textures')

    var renderer,
        scene,
        textPass,
        camera,
        controller,
        features,
        water,
        effects,
        labels = [],
        time = 0

    if (!opt.gl)
        throw new Error('must specify GL context')

    setup(opt.gl, opt.width||0, opt.height||0)

    function draw(dt) {
        time +=  Math.min(dt, 30) / 1000
        renderer.resetAttributes()
        renderer.resetGLState()

        water.material.uniforms.time.value = time * 0.1
        water.render()

        controller.update()
        
        scene.update(dt)
        if (effects)
            effects.render(dt)
        else {
            textPass.render(renderer)
        }

        animateLabels(controller, labels)

        var t = unlerp(0.6, 1.4, controller.phi)
        t = smoothstep(1.4, 0.45, t)
        var range = clamp(t, 0, 1)
        water.alpha = range||0
    }

    function setup(gl, width, height) {
        renderer = new THREE.WebGLRenderer({ 
            canvas: gl.canvas,
            antialias: false,
            alpha: false
        })
        renderer.setClearColor(0xffffff, 0)
        renderer.shadowMapType = THREE.BasicShadowMap
        // renderer.shadowMapEnabled = true

        opt.fov = number(opt.fov, 50)
        camera = new THREE.PerspectiveCamera(opt.fov, width/height, 0.5, 20000)
        camera.position.x = -60
        camera.position.z = -40
        camera.position.y = 38
        camera.lookAt(new THREE.Vector3())

        controller = new OrbitController(camera)
        controller.userPan = false
        controller.userPanSpeed = 0.0
        controller.zoomSpeed = 0.1
        controller.rotateSpeed = 0.2
        controller.minDistance = 30
        controller.maxDistance = 200.0
        controller.maxPolarAngle = 90 * Math.PI/180
        controller.minPolarAngle = 40 * Math.PI/180
        controller.center.set( 0, 5, 0 )
        scene = RigScene()

        require('./setup-floor')(scene)

        water = require('./setup-water')(renderer, camera, scene)
        
        scene.cubeMap = water.cubeMap
        scene.updateMaterial()

        var pass = require('./create-text-pass')({
            renderer: renderer,
            scene: scene,
            camera: camera,
            font: Font
        })

        textPass = pass
        labels = pass.groups

        effects = Effects({
            renderer: renderer,
            scene: scene,
            camera: camera,
            width: width,
            blur: false,
            height: height,
            renderPass: pass
        })

        hideLabels(labels)
    }

    function handleResize(width, height) {
        renderer.setSize(width, height)
        camera.aspect = width/height
        camera.updateProjectionMatrix()

        if (effects)
            effects.resize(width, height)
    }

    return {
        draw: draw,
        resize: handleResize
    }
}
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./RigScene":"/projects/blackice/lib/RigScene.js","./animate-labels":"/projects/blackice/lib/animate-labels.js","./create-text-pass":"/projects/blackice/lib/create-text-pass.js","./setup-effects":"/projects/blackice/lib/setup-effects.js","./setup-floor":"/projects/blackice/lib/setup-floor.js","./setup-water":"/projects/blackice/lib/setup-water.js","./three-orbit-camera":"/projects/blackice/lib/three-orbit-camera/index.js","as-number":"/projects/blackice/node_modules/as-number/index.js","clamp":"/projects/blackice/node_modules/clamp/index.js","lerp":"/projects/blackice/node_modules/lerp/index.js","plucker":"/projects/blackice/node_modules/plucker/index.js","smoothstep":"/projects/blackice/node_modules/smoothstep/index.js","unlerp":"/projects/blackice/node_modules/unlerp/index.js"}],"/projects/blackice/lib/setup-effects.js":[function(require,module,exports){
(function (global){
var THREE = (typeof window !== "undefined" ? window.THREE : typeof global !== "undefined" ? global.THREE : null)
var EffectComposer = require('three-effectcomposer')(THREE)
var createFXAA = require('three-shader-fxaa')(THREE)
var createBlur = require('./shaders/blur')
var createLens = require('./shaders/lens')
var createEmpty = require('./shaders/pass')
// var TextPass = require('./TextPass')

module.exports = Effects

function Effects(opt) {
    if (!(this instanceof Effects)) 
        return new Effects(opt)
    opt = opt||{}

    var parameters = { 
        minFilter: THREE.LinearFilter, 
        magFilter: THREE.LinearFilter, 
        format: THREE.RGBFormat, 
        stencilBuffer: false 
    }
    var width = opt.width
    var height = opt.height
    var renderTarget = new THREE.WebGLRenderTarget(width, height, parameters);

    this.composer = new EffectComposer(opt.renderer, renderTarget)
    this.composer.addPass(opt.renderPass)
    
    this.shaders = []
    this.noiseDelay = 33
    this.noiseTime = 0

    // this.shaders.push(new EffectComposer.ShaderPass(createEmpty()))


    var fxaaShader = new EffectComposer.ShaderPass(createFXAA())
    this.shaders.push(fxaaShader)

    if (opt.blur !== false) {
        var blur = createBlur()
        var iterations = 1;
        for (var i=0; i<iterations; i++) {
            var r = (i+1)*2;

            var horiz = new EffectComposer.ShaderPass( blur );
            horiz.uniforms.radius.value = r
            horiz.uniforms.strength.value = 1
            horiz.uniforms.dir.value.set(1,0)

            var vert = new EffectComposer.ShaderPass( blur );
            vert.uniforms.radius.value = r
            vert.uniforms.strength.value = 1
            vert.uniforms.dir.value.set(0,1)

            this.shaders.push(horiz, vert)
        }
    }

    var lensPass = new EffectComposer.ShaderPass(createLens())
    this.shaders.push(lensPass)

    //default values to avoid div by zero
    lensPass.uniforms.overlayResolution.value.set(1, 1)
    lensPass.uniforms.tLookup.value = loadTexture('img/lookup.png', { 
        generateMipmaps: false,
        filter: THREE.LinearFilter 
    })
    lensPass.uniforms.tOverlay.value = loadTexture('img/dust.jpg', {
        generateMipmaps: false,
        filter: THREE.LinearFilter
    }, function(err, tex) {
        lensPass.uniforms.overlayResolution.value.set(tex.image.width, tex.image.height)
    })

    this.shaders.forEach(function(pass, i, self) {
        this.composer.addPass(pass)
        if (i === self.length-1)
            pass.renderToScreen = true
    }, this)  
    if (opt.width && opt.height) 
        this.resize(opt.width, opt.height)
}


function loadTexture(path, opt, cb) {
    if (typeof opt === 'function') {
        cb = opt
        opt = {}
    }

    return THREE.ImageUtils.loadTexture(path, undefined, function(tex) {
        if (opt.filter) tex.minFilter = tex.magFilter = opt.filter
        if (opt.wrap) tex.wrapS = tex.wrapT = opt.wrap
        tex.generateMipmaps = opt.generateMipmaps
        if (typeof cb === 'function') 
            cb(null, tex)
    })
}

require('mixes')(Effects, {

    render: function(dt) {
        this.noiseTime += dt
        if (this.noiseTime > this.noiseDelay) {
            this.noiseTime = 0
            this.shaders.forEach(function(pass) {
                if (pass.uniforms.tick)
                    pass.uniforms.tick.value += 0.005
            })
        }

        this.composer.render()
    },

    resize: function(width, height) {
        width *= 2
        height *= 2
        this.composer.setSize(width, height)
        this.shaders.forEach(function(pass) {
            var dpr = 1
            // var dpr = (window.devicePixelRatio||1)
            if (pass.uniforms.resolution)
                pass.uniforms.resolution.value.set(width*dpr, height*dpr)
            
        })
    }
})
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./shaders/blur":"/projects/blackice/lib/shaders/blur.js","./shaders/lens":"/projects/blackice/lib/shaders/lens.js","./shaders/pass":"/projects/blackice/lib/shaders/pass.js","mixes":"/projects/blackice/node_modules/mixes/index.js","three-effectcomposer":"/projects/blackice/node_modules/three-effectcomposer/index.js","three-shader-fxaa":"/projects/blackice/node_modules/three-shader-fxaa/index.js"}],"/projects/blackice/lib/setup-floor.js":[function(require,module,exports){
(function (global){
var random = require('randf')
var THREE = (typeof window !== "undefined" ? window.THREE : typeof global !== "undefined" ? global.THREE : null)
var smoothstep = require('smoothstep')
var lerp = require('lerp')

module.exports = function(scene) {
    var geo = new THREE.PlaneGeometry(100, 100, 40, 40)
    var vec2 = new THREE.Vector2()
    geo.vertices.forEach(function(v) {
        var len = vec2.set(v.x, v.y).length() / 50
        var slen = smoothstep(0.4, 1.0, len)
        v.z = random(-20, 35) * slen 

        slen = smoothstep(0.7, 1.0, len)
        var L = lerp(0.2, 1.0, slen)
        var color = new THREE.Color(L, L, L)
        geo.colors.push(color)
    })

    geo.faces.forEach(function(face) {
        face.vertexColors[0] = geo.colors[face.a]
        face.vertexColors[1] = geo.colors[face.b]
        face.vertexColors[2] = geo.colors[face.c]
    })

    var tex = THREE.ImageUtils.loadTexture('img/snow.jpg')
    tex.repeat.set(1, 1)
    tex.wrapS = tex.wrapT = THREE.RepeatWrapping

    var mat = new THREE.MeshBasicMaterial({ 
        map: tex,
        vertexColors: THREE.VertexColors 
        // color: "rgb(150,150,150)"
    })
    var mesh = new THREE.Mesh(geo, mat)
    mesh.rotation.x = -Math.PI/2
    mesh.position.y = -25
    var stretch = 10
    mesh.scale.x = mesh.scale.y = stretch
    scene.add(mesh)

    window.floor = mesh
}
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"lerp":"/projects/blackice/node_modules/lerp/index.js","randf":"/projects/blackice/node_modules/randf/index.js","smoothstep":"/projects/blackice/node_modules/smoothstep/index.js"}],"/projects/blackice/lib/setup-water.js":[function(require,module,exports){
var cubeShader = {

    uniforms: THREE.UniformsUtils.merge( [
        { "tCube": { type: "t", value: null },
        "tFlip": { type: "f", value: - 1 } },
        THREE.UniformsLib[ "fog" ]
    ] ),

    vertexShader: [

        "varying vec3 vWorldPosition;",

        THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

        "void main() {",

        "   vec4 worldPosition = modelMatrix * vec4( position, 1.0 );",
        "   vWorldPosition = worldPosition.xyz;",

        "   gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

            THREE.ShaderChunk[ "logdepthbuf_vertex" ],

        "}"

    ].join("\n"),

    fragmentShader: [

        "uniform samplerCube tCube;",
        "uniform float tFlip;",

        "varying vec3 vWorldPosition;",
        THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],
        THREE.ShaderChunk[ "fog_pars_fragment" ],
        "void main() {",
        "   gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );",
            THREE.ShaderChunk[ "logdepthbuf_fragment" ],
            THREE.ShaderChunk[ "fog_fragment" ],
        "}"

    ].join("\n")

}
module.exports = function(renderer, camera, scene) {
    var light = new THREE.HemisphereLight(0xbbe9ff, 0x080820, 1)
    light.position.set(-1, 1, -1)
    scene.add(light)

    var waterNormals = new THREE.ImageUtils.loadTexture('img/waternormals5.jpg')
    waterNormals.wrapS = waterNormals.wrapT = THREE.RepeatWrapping

    var water = new THREE.Water(renderer, camera, scene, {
        textureWidth: 512,
        textureHeight: 512,
        waterNormals: waterNormals,
        alpha: 0.9,
        sunDirection: light.position.clone().normalize(),
        sunColor: 0xffffff,
        waterColor: 0x020d15,
        distortionScale: 80.0,
    })

    var mirrorMesh = new THREE.Mesh(
        new THREE.PlaneBufferGeometry(5000, 5000),
        water.material
    )

    mirrorMesh.add(water)
    mirrorMesh.rotation.x = -Math.PI * 0.5
    scene.add(mirrorMesh)


    // load skybox

    var cubeMap = new THREE.CubeTexture([])
    cubeMap.format = THREE.RGBFormat
    cubeMap.flipY = false

    var loader = new THREE.ImageLoader()
    loader.load('img/cloudy_night2.jpg', function(image) {

        var getSide = function(x, y) {

            var size = 1024

            var canvas = document.createElement('canvas')
            canvas.width = size
            canvas.height = size

            var context = canvas.getContext('2d')
            context.drawImage(image, -x * size, -y * size)

            return canvas

        }

        cubeMap.images[0] = getSide(2, 1) // px
        cubeMap.images[1] = getSide(0, 1) // nx
        cubeMap.images[2] = getSide(1, 0) // py
        cubeMap.images[3] = getSide(1, 2) // ny
        cubeMap.images[4] = getSide(1, 1) // pz
        cubeMap.images[5] = getSide(3, 1) // nz
        cubeMap.needsUpdate = true

    })

    cubeShader.uniforms.tCube.value = cubeMap

    var skyBoxMaterial = new THREE.ShaderMaterial({
        fragmentShader: cubeShader.fragmentShader,
        vertexShader: cubeShader.vertexShader,
        uniforms: cubeShader.uniforms,
        // depthWrite: false,
        side: THREE.BackSide,
        fog: true,
    })

    var skyBox = new THREE.Mesh(
        new THREE.BoxGeometry(5000, 5000, 5000),
        skyBoxMaterial
    )
    
    water.cubeMap = cubeMap

    scene.add(skyBox)
    return water
}
},{}],"/projects/blackice/lib/shaders/blur.js":[function(require,module,exports){
var glslify = require("glslify");
var source = require("glslify/simple-adapter.js")("\n#define GLSLIFY 1\n\nvarying vec2 vUv;\nvoid main() {\n  vUv = uv;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}", "\n#define GLSLIFY 1\n\nuniform vec2 resolution;\nuniform float radius;\nuniform vec2 dir;\nuniform float strength;\nuniform sampler2D tDiffuse;\nvarying vec2 vUv;\nvec4 a_x_blur(sampler2D tex, vec2 uv, vec2 blur, vec2 direction) {\n  vec4 sum = vec4(0.0);\n  sum += texture2D(tex, vec2(uv.x - 4.0 * blur.x * direction.x, uv.y - 4.0 * blur.y * direction.y)) * 0.0162162162;\n  sum += texture2D(tex, vec2(uv.x - 3.0 * blur.x * direction.x, uv.y - 3.0 * blur.y * direction.y)) * 0.0540540541;\n  sum += texture2D(tex, vec2(uv.x - 2.0 * blur.x * direction.x, uv.y - 2.0 * blur.y * direction.y)) * 0.1216216216;\n  sum += texture2D(tex, vec2(uv.x - 1.0 * blur.x * direction.x, uv.y - 1.0 * blur.y * direction.y)) * 0.1945945946;\n  sum += texture2D(tex, vec2(uv.x, uv.y)) * 0.2270270270;\n  sum += texture2D(tex, vec2(uv.x + 1.0 * blur.x * direction.x, uv.y + 1.0 * blur.y * direction.y)) * 0.1945945946;\n  sum += texture2D(tex, vec2(uv.x + 2.0 * blur.x * direction.x, uv.y + 2.0 * blur.y * direction.y)) * 0.1216216216;\n  sum += texture2D(tex, vec2(uv.x + 3.0 * blur.x * direction.x, uv.y + 3.0 * blur.y * direction.y)) * 0.0540540541;\n  sum += texture2D(tex, vec2(uv.x + 4.0 * blur.x * direction.x, uv.y + 4.0 * blur.y * direction.y)) * 0.0162162162;\n  return sum;\n}\nvoid main() {\n  vec2 blurAmt = vec2(radius) / resolution;\n  vec4 sum = a_x_blur(tDiffuse, vUv, blurAmt, dir);\n  vec2 p = (gl_FragCoord.xy / resolution.xy - 0.5);\n  p.x *= resolution.x / resolution.y;\n  float len = smoothstep(0.5, 1.2, length(p));\n  vec3 orig = texture2D(tDiffuse, vUv).rgb;\n  gl_FragColor.rgb = mix(orig, sum.rgb, len + 0.1);\n  gl_FragColor.a = 1.0;\n}", [{"name":"resolution","type":"vec2"},{"name":"radius","type":"float"},{"name":"dir","type":"vec2"},{"name":"strength","type":"float"},{"name":"tDiffuse","type":"sampler2D"}], []);
module.exports = require("./create")(source);
},{"./create":"/projects/blackice/lib/shaders/create.js","glslify":"/projects/blackice/node_modules/glslify/browser.js","glslify/simple-adapter.js":"/projects/blackice/node_modules/glslify/simple-adapter.js"}],"/projects/blackice/lib/shaders/create.js":[function(require,module,exports){
(function (global){
var THREE = (typeof window !== "undefined" ? window.THREE : typeof global !== "undefined" ? global.THREE : null)
var threeify = require('three-glslify')(THREE)
var xtend = require('xtend') 
 
module.exports = function(source) {
    return function(opt) {
        return xtend(threeify(source), opt)
    }
}
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"three-glslify":"/projects/blackice/node_modules/three-glslify/index.js","xtend":"/projects/blackice/node_modules/xtend/immutable.js"}],"/projects/blackice/lib/shaders/lens.js":[function(require,module,exports){
var glslify = require("glslify");
var source = require("glslify/simple-adapter.js")("\n#define GLSLIFY 1\n\nuniform vec2 overlayResolution;\nuniform vec2 resolution;\nvarying vec2 vUv;\nvarying vec2 overlayUV;\nvoid main() {\n  vUv = uv;\n  float aspect = overlayResolution.x / overlayResolution.y;\n  float ratio = resolution.x / resolution.y;\n  overlayUV = uv;\n  float tAspect = overlayResolution.x / overlayResolution.y;\n  float pAspect = resolution.x / resolution.y;\n  overlayUV = uv;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}", "\n#define GLSLIFY 1\n\nuniform float tick;\nuniform sampler2D tDiffuse;\nuniform sampler2D tLookup;\nuniform sampler2D tOverlay;\nvarying vec2 vUv;\nvarying vec2 overlayUV;\nhighp float a_x_random(vec2 co) {\n  highp float a = 12.9898;\n  highp float b = 78.233;\n  highp float c = 43758.5453;\n  highp float dt = dot(co.xy, vec2(a, b));\n  highp float sn = mod(dt, 3.14);\n  return fract(sin(sn) * c);\n}\nvec3 b_x_blendOverlay(vec3 base, vec3 blend) {\n  return vec3(base.r < 0.5 ? (2.0 * base.r * blend.r) : (1.0 - 2.0 * (1.0 - base.r) * (1.0 - blend.r)), base.g < 0.5 ? (2.0 * base.g * blend.g) : (1.0 - 2.0 * (1.0 - base.g) * (1.0 - blend.g)), base.b < 0.5 ? (2.0 * base.b * blend.b) : (1.0 - 2.0 * (1.0 - base.b) * (1.0 - blend.b)));\n}\nfloat c_x_luma(vec3 color) {\n  return dot(color, vec3(0.299, 0.587, 0.114));\n}\nfloat c_x_luma(vec4 color) {\n  return dot(color.rgb, vec3(0.299, 0.587, 0.114));\n}\n#define LUT_FLIP_Y\n\nvec4 e_x_lookup(in vec4 textureColor, in sampler2D lookupTable) {\n  \n  #ifndef LUT_NO_CLAMP\n  textureColor = clamp(textureColor, 0.0, 1.0);\n  #endif\n  mediump float blueColor = textureColor.b * 63.0;\n  mediump vec2 quad1;\n  quad1.y = floor(floor(blueColor) / 8.0);\n  quad1.x = floor(blueColor) - (quad1.y * 8.0);\n  mediump vec2 quad2;\n  quad2.y = floor(ceil(blueColor) / 8.0);\n  quad2.x = ceil(blueColor) - (quad2.y * 8.0);\n  highp vec2 texPos1;\n  texPos1.x = (quad1.x * 0.125) + 0.5 / 512.0 + ((0.125 - 1.0 / 512.0) * textureColor.r);\n  texPos1.y = (quad1.y * 0.125) + 0.5 / 512.0 + ((0.125 - 1.0 / 512.0) * textureColor.g);\n  #ifdef LUT_FLIP_Y\n  texPos1.y = 1.0 - texPos1.y;\n  #endif\n  highp vec2 texPos2;\n  texPos2.x = (quad2.x * 0.125) + 0.5 / 512.0 + ((0.125 - 1.0 / 512.0) * textureColor.r);\n  texPos2.y = (quad2.y * 0.125) + 0.5 / 512.0 + ((0.125 - 1.0 / 512.0) * textureColor.g);\n  #ifdef LUT_FLIP_Y\n  texPos2.y = 1.0 - texPos2.y;\n  #endif\n  lowp vec4 newColor1 = texture2D(lookupTable, texPos1);\n  lowp vec4 newColor2 = texture2D(lookupTable, texPos2);\n  lowp vec4 newColor = mix(newColor1, newColor2, fract(blueColor));\n  return newColor;\n}\nvoid main() {\n  vec3 texColor = texture2D(tDiffuse, vUv).rgb;\n  float luminance = c_x_luma(texColor);\n  float noiseMap = smoothstep(luminance, 0.5, 0.0);\n  vec2 tUv = vUv + tick;\n  vec3 noise = vec3(a_x_random(tUv), a_x_random(tUv * 1.5), a_x_random(tUv * 0.5));\n  vec3 noiseColor = mix(noise, vec3(0.5), noiseMap);\n  vec3 color = mix(texColor, b_x_blendOverlay(texColor, noise), 0.15);\n  vec3 corrected = e_x_lookup(vec4(color, 1.0), tLookup).rgb;\n  color = mix(color, corrected, 0.9);\n  gl_FragColor = vec4(color, 1.0);\n  vec4 scratches = texture2D(tOverlay, overlayUV);\n  vec3 scratchBlend = gl_FragColor.rgb + scratches.rgb;\n  float center = smoothstep(0.0, 0.6, length(vUv - 0.5));\n  float dirtMap = smoothstep(0.1, 0.4, luminance * center);\n  gl_FragColor.rgb = mix(gl_FragColor.rgb, scratchBlend, dirtMap);\n}", [{"name":"overlayResolution","type":"vec2"},{"name":"resolution","type":"vec2"},{"name":"tick","type":"float"},{"name":"tDiffuse","type":"sampler2D"},{"name":"tLookup","type":"sampler2D"},{"name":"tOverlay","type":"sampler2D"}], []);
module.exports = require("./create")(source);
},{"./create":"/projects/blackice/lib/shaders/create.js","glslify":"/projects/blackice/node_modules/glslify/browser.js","glslify/simple-adapter.js":"/projects/blackice/node_modules/glslify/simple-adapter.js"}],"/projects/blackice/lib/shaders/pass.js":[function(require,module,exports){
var glslify = require("glslify");
var source = require("glslify/simple-adapter.js")("\n#define GLSLIFY 1\n\nvarying vec2 vUv;\nvoid main() {\n  vUv = uv;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}", "\n#define GLSLIFY 1\n\nuniform sampler2D tDiffuse;\nvarying vec2 vUv;\nvoid main() {\n  gl_FragColor = texture2D(tDiffuse, vUv);\n}", [{"name":"tDiffuse","type":"sampler2D"}], []);
module.exports = require("./create")(source);
},{"./create":"/projects/blackice/lib/shaders/create.js","glslify":"/projects/blackice/node_modules/glslify/browser.js","glslify/simple-adapter.js":"/projects/blackice/node_modules/glslify/simple-adapter.js"}],"/projects/blackice/lib/text-data.js":[function(require,module,exports){
(function (global){
var THREE = (typeof window !== "undefined" ? window.THREE : typeof global !== "undefined" ? global.THREE : null)
var lineHeight = 22
var big = 0.7
var small = 0.5

var panelWidth = 20
module.exports = [
    
    {
        name: 'tonnes',
        panels: [ {
            // origin: new THREE.Vector3(18, 10, 2),
            labels: [
                { text: '5 million tonnes', size: big },
                { text: 'estimated oil spilt in Russia each year', size: small, translation: [-2, -lineHeight, 0] },
            ]
        }, 
        {
            // origin: new THREE.Vector3(-20, 10, 2),
            width: panelWidth,
            labels: [
                { text: '6 million tonnes', size: big },
                { text: 'expected yearly output of this platform', size: small, translation: [0, -lineHeight, 0] },
            ]
        } 
        ]
    },
    {
        name: 'top',
        panels: [ {
            labels: [
                { text: 'Technologically outdated', size: big },
                { text: 'using secondhand components', size: small, translation: [0, -lineHeight, 0] },
            ]
        },
        {
            width: panelWidth,
            labels: [
                { text: '$3.2 billion over budget', size: big },
                { text: '18 years to construct', size: small, translation: [0, -lineHeight, 0] },
            ]
        } ]
    },
    {
        name: 'nature',
        panels: [ {
            labels: [
                { text: '50 km from Nature reserve', size: big },
                { text: 'Less than 20hrs for oil to reach', size: small, translation: [0, -lineHeight, 0] },
            ]
        },
        {
            width: panelWidth,
            labels: [
                { text: 'Crucial breeding grounds', size: big },
                { text: 'for walrus, whales & polar bears', size: small, translation: [0, -lineHeight, 0] },
            ]
        } ]
    },
    {
        name: 'response',
        panels: [ {
            labels: [
                { text: 'Large scale spill equipment ', size: big },
                { text: '1000km (3 days sailing) away', size: small, translation: [0, -lineHeight, 0] },
            ]
        },
        {
            width: panelWidth*1.5,
            labels: [
                { text: '15 buckets and 3 axes', size: big },
                { text: 'included in previous response plan', size: small, translation: [0, -lineHeight, 0] },
            ]
        } ]
    },
    {
        name: 'spill',
        panels: [ {
            labels: [
                { text: 'Arctic Oil spills', size: big },
                { text: 'are close to impossible to clean up', size: small, translation: [0, -lineHeight, 0] },
            ]
        },
        {
            width: panelWidth,
            labels: [
                { text: 'Offshore drilling for arctic oil', size: big },
                { text: 'spills are virtually inevitable', size: small, translation: [0, -lineHeight, 0] },
            ]
        } ]
    },
    {
        name: 'weather',
        panels: [ {
            labels: [
                { text: 'As cold as -50˚c /122˚f', size: big },
                { text: 'two thirds of the year surrounded by ice', size: small, translation: [0, -lineHeight, 0] },
            ]
        },
        {
            width: panelWidth,
            labels: [
                { text: 'Plagued by bad weather', size: big },
                { text: 'waves as high as 12m', size: small, translation: [0, -lineHeight, 0] },
            ]
        } ]
    },
]

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],"/projects/blackice/lib/three-orbit-camera/index.js":[function(require,module,exports){
(function (global){
var inherits = require('inherits')
var TweenMax = (typeof window !== "undefined" ? window.TweenMax : typeof global !== "undefined" ? global.TweenMax : null)

module.exports = function(THREE) {
    if (!THREE.MOUSE)
        THREE.MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };

    /**
     * @author qiao / https://github.com/qiao
     * @author mrdoob / http://mrdoob.com
     * @author alteredq / http://alteredqualia.com/
     * @author WestLangley / http://github.com/WestLangley
     * @author erich666 / http://erichaines.com
     */
    /*global THREE, console */

    // This set of controls performs orbiting, dollying (zooming), and panning. It maintains
    // the "up" direction as +Y, unlike the TrackballControls. Touch on tablet and phones is
    // supported.
    //
    //    Orbit - left mouse / touch: one finger move
    //    Zoom - middle mouse, or mousewheel / touch: two finger spread or squish
    //    Pan - right mouse, or arrow keys / touch: three finter swipe
    //
    // This is a drop-in replacement for (most) TrackballControls used in examples.
    // That is, include this js file and wherever you see:
    //      controls = new THREE.TrackballControls( camera );
    //      controls.target.z = 150;
    // Simple substitute "OrbitControls" and the control should work as-is.

    function OrbitControls( object, domElement ) {

        this.object = object;
        this.domElement = ( domElement !== undefined ) ? domElement : document;

        // API

        // Set to false to disable this control
        this.enabled = true;

        // "target" sets the location of focus, where the control orbits around
        // and where it pans with respect to.
        this.target = new THREE.Vector3();

        // center is old, deprecated; use "target" instead
        this.center = this.target;

        // This option actually enables dollying in and out; left as "zoom" for
        // backwards compatibility
        this.noZoom = false;
        this.zoomSpeed = 1.0;

        // Limits to how far you can dolly in and out
        this.minDistance = 0;
        this.maxDistance = Infinity;

        // Set to true to disable this control
        this.noRotate = false;
        this.rotateSpeed = 1.0;

        // Set to true to disable this control
        this.noPan = false;
        this.keyPanSpeed = 7.0; // pixels moved per arrow key push

        // Set to true to automatically rotate around the target
        this.autoRotate = false;
        this.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60

        // How far you can orbit vertically, upper and lower limits.
        // Range is 0 to Math.PI radians.
        this.minPolarAngle = 0; // radians
        this.maxPolarAngle = Math.PI; // radians

        // Set to true to disable use of the keys
        this.noKeys = false;

        this.phi = 0
        this.theta = 0 

        // The four arrow keys
        this.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 };

        this.constrainDelta = { x: 0, y: 0 };

        ////////////
        // internals

        var scope = this;

        var EPS = 0.000001;

        var rotateStart = new THREE.Vector2();
        var rotateEnd = new THREE.Vector2();
        var rotateDelta = new THREE.Vector2();

        var panStart = new THREE.Vector2();
        var panEnd = new THREE.Vector2();
        var panDelta = new THREE.Vector2();
        var panOffset = new THREE.Vector3();

        var offset = new THREE.Vector3();

        var dollyStart = new THREE.Vector2();
        var dollyEnd = new THREE.Vector2();
        var dollyDelta = new THREE.Vector2();

        var phiDelta = 0;
        var thetaDelta = 0;
        var scale = 1;
        var pan = new THREE.Vector3();

        var lastPosition = new THREE.Vector3();

        var STATE = { NONE : -1, ROTATE : 0, DOLLY : 1, PAN : 2, TOUCH_ROTATE : 3, TOUCH_DOLLY : 4, TOUCH_PAN : 5 };

        var state = STATE.NONE;

        // for reset

        this.target0 = this.target.clone();
        this.position0 = this.object.position.clone();

        // so camera.up is the orbit axis

        var quat = new THREE.Quaternion().setFromUnitVectors( object.up, new THREE.Vector3( 0, 1, 0 ) );
        var quatInverse = quat.clone().inverse();

        // events

        var changeEvent = { type: 'change' };
        var startEvent = { type: 'start'};
        var endEvent = { type: 'end'};

        this.rotateLeft = function ( angle ) {

            if ( angle === undefined ) {

                angle = getAutoRotationAngle();

            }

            thetaDelta -= angle;

        };

        this.rotateUp = function ( angle ) {

            if ( angle === undefined ) {

                angle = getAutoRotationAngle();

            }

            phiDelta -= angle;

        };

        // pass in distance in world space to move left
        this.panLeft = function ( distance ) {

            var te = this.object.matrix.elements;

            // get X column of matrix
            panOffset.set( te[ 0 ], te[ 1 ], te[ 2 ] );
            panOffset.multiplyScalar( - distance );
            
            pan.add( panOffset );

        };

        // pass in distance in world space to move up
        this.panUp = function ( distance ) {

            var te = this.object.matrix.elements;

            // get Y column of matrix
            panOffset.set( te[ 4 ], te[ 5 ], te[ 6 ] );
            panOffset.multiplyScalar( distance );
            
            pan.add( panOffset );

        };
        
        // pass in x,y of change desired in pixel space,
        // right and down are positive
        this.pan = function ( deltaX, deltaY ) {

            var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

            if ( scope.object.fov !== undefined ) {

                // perspective
                var position = scope.object.position;
                var offset = position.clone().sub( scope.target );
                var targetDistance = offset.length();

                // half of the fov is center to top of screen
                targetDistance *= Math.tan( ( scope.object.fov / 2 ) * Math.PI / 180.0 );

                // we actually don't use screenWidth, since perspective camera is fixed to screen height
                scope.panLeft( 2 * deltaX * targetDistance / element.clientHeight );
                scope.panUp( 2 * deltaY * targetDistance / element.clientHeight );

            } else if ( scope.object.top !== undefined ) {

                // orthographic
                scope.panLeft( deltaX * (scope.object.right - scope.object.left) / element.clientWidth );
                scope.panUp( deltaY * (scope.object.top - scope.object.bottom) / element.clientHeight );

            } else {

                // camera neither orthographic or perspective
                console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.' );

            }

        };

        this.dollyIn = function ( dollyScale ) {

            if ( dollyScale === undefined ) {

                dollyScale = getZoomScale();

            }

            scale /= dollyScale;

        };

        this.dollyOut = function ( dollyScale ) {

            if ( dollyScale === undefined ) {

                dollyScale = getZoomScale();

            }

            scale *= dollyScale;

        };

        this.update = function () {

            var position = this.object.position;

            // // rotating across whole screen goes 360 degrees around
            scope.rotateLeft( 2 * Math.PI * scope.constrainDelta.x / window.innerWidth * scope.rotateSpeed );

            // // rotating up and down along whole screen attempts to go 360, but limited to 180
            scope.rotateUp( 2 * Math.PI * scope.constrainDelta.y / window.innerHeight * scope.rotateSpeed );

            offset.copy( position ).sub( this.target );

            // rotate offset to "y-axis-is-up" space
            offset.applyQuaternion( quat );

            // angle from z-axis around y-axis

            var theta = Math.atan2( offset.x, offset.z );

            // angle from y-axis

            var phi = Math.atan2( Math.sqrt( offset.x * offset.x + offset.z * offset.z ), offset.y );

            if ( this.autoRotate ) {

                this.rotateLeft( getAutoRotationAngle() );

            }

            theta += thetaDelta;
            phi += phiDelta;

            // restrict phi to be between desired limits
            phi = Math.max( this.minPolarAngle, Math.min( this.maxPolarAngle, phi ) );

            // restrict phi to be betwee EPS and PI-EPS
            phi = Math.max( EPS, Math.min( Math.PI - EPS, phi ) );

            var radius = offset.length() * scale;

            // restrict radius to be between desired limits
            radius = Math.max( this.minDistance, Math.min( this.maxDistance, radius ) );
            
            // move target to panned location
            this.target.add( pan );

            scope.phi = phi
            scope.theta = theta

            offset.x = radius * Math.sin( phi ) * Math.sin( theta );
            offset.y = radius * Math.cos( phi );
            offset.z = radius * Math.sin( phi ) * Math.cos( theta );

            // rotate offset back to "camera-up-vector-is-up" space
            offset.applyQuaternion( quatInverse );

            position.copy( this.target ).add( offset );

            this.object.lookAt( this.target );

            thetaDelta = 0;
            phiDelta = 0;
            scale = 1;
            pan.set( 0, 0, 0 );

            if ( lastPosition.distanceToSquared( this.object.position ) > EPS ) {

                this.dispatchEvent( changeEvent );

                lastPosition.copy( this.object.position );

            }

        };


        this.reset = function () {

            state = STATE.NONE;

            this.target.copy( this.target0 );
            this.object.position.copy( this.position0 );

            this.update();

        };

        function getAutoRotationAngle() {

            return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;

        }

        function getZoomScale() {

            return Math.pow( 0.95, scope.zoomSpeed );

        }

        function onMouseDown( event ) {

            if ( scope.enabled === false ) return;
            event.preventDefault();

            if ( event.button === 0 ) {
                if ( scope.noRotate === true ) return;

                state = STATE.ROTATE;

                rotateStart.set( event.clientX, event.clientY );

            } else if ( event.button === 1 ) {
                if ( scope.noZoom === true ) return;

                state = STATE.DOLLY;

                dollyStart.set( event.clientX, event.clientY );

            } else if ( event.button === 2 ) {
                if ( scope.noPan === true ) return;

                state = STATE.PAN;

                panStart.set( event.clientX, event.clientY );

            }

            scope.domElement.addEventListener( 'mousemove', onMouseMove, false );
            scope.domElement.addEventListener( 'mouseup', onMouseUp, false );
            scope.dispatchEvent( startEvent );

        }

        function onMouseMove( event ) {

            if ( scope.enabled === false ) return;

            event.preventDefault();

            var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

            if ( state === STATE.ROTATE ) {

                if ( scope.noRotate === true ) return;

                rotateEnd.set( event.clientX, event.clientY );
                rotateDelta.subVectors( rotateEnd, rotateStart );

                scope.constrainDelta.x = rotateDelta.x;
                scope.constrainDelta.y = rotateDelta.y;
                
                TweenMax.killTweensOf(scope.constrainDelta);
                TweenMax.to(scope.constrainDelta, 0.50, {
                    x: 0,
                    y: 0,
                    ease: 'easeOutQuad',
                    delay: 0.0
                });

                rotateStart.copy( rotateEnd );

            } else if ( state === STATE.DOLLY ) {

                if ( scope.noZoom === true ) return;

                dollyEnd.set( event.clientX, event.clientY );
                dollyDelta.subVectors( dollyEnd, dollyStart );

                if ( dollyDelta.y > 0 ) {

                    scope.dollyIn();

                } else {

                    scope.dollyOut();

                }

                dollyStart.copy( dollyEnd );

            } else if ( state === STATE.PAN ) {

                if ( scope.noPan === true ) return;

                panEnd.set( event.clientX, event.clientY );
                panDelta.subVectors( panEnd, panStart );
                
                scope.pan( panDelta.x, panDelta.y );

                panStart.copy( panEnd );

            }

            scope.update();

        }

        function onMouseUp( /* event */ ) {

            if ( scope.enabled === false ) return;

            scope.domElement.removeEventListener( 'mousemove', onMouseMove, false );
            scope.domElement.removeEventListener( 'mouseup', onMouseUp, false );
            scope.dispatchEvent( endEvent );
            state = STATE.NONE;

        }

        function onMouseWheel( event ) {

            if ( scope.enabled === false || scope.noZoom === true ) return;

            event.preventDefault();
            event.stopPropagation();

            var delta = 0;

            if ( event.wheelDelta !== undefined ) { // WebKit / Opera / Explorer 9

                delta = event.wheelDelta;

            } else if ( event.detail !== undefined ) { // Firefox

                delta = - event.detail;

            }

            if ( delta > 0 ) {

                scope.dollyOut();

            } else {

                scope.dollyIn();

            }

            scope.update();
            scope.dispatchEvent( startEvent );
            scope.dispatchEvent( endEvent );

        }

        function onKeyDown( event ) {

            if ( scope.enabled === false || scope.noKeys === true || scope.noPan === true ) return;
            
            switch ( event.keyCode ) {

                case scope.keys.UP:
                    scope.pan( 0, scope.keyPanSpeed );
                    scope.update();
                    break;

                case scope.keys.BOTTOM:
                    scope.pan( 0, - scope.keyPanSpeed );
                    scope.update();
                    break;

                case scope.keys.LEFT:
                    scope.pan( scope.keyPanSpeed, 0 );
                    scope.update();
                    break;

                case scope.keys.RIGHT:
                    scope.pan( - scope.keyPanSpeed, 0 );
                    scope.update();
                    break;

            }

        }

        function touchstart( event ) {

            if ( scope.enabled === false ) return;

            switch ( event.touches.length ) {

                case 1: // one-fingered touch: rotate

                    if ( scope.noRotate === true ) return;

                    state = STATE.TOUCH_ROTATE;

                    rotateStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );
                    break;

                case 2: // two-fingered touch: dolly

                    if ( scope.noZoom === true ) return;

                    state = STATE.TOUCH_DOLLY;

                    var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;
                    var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;
                    var distance = Math.sqrt( dx * dx + dy * dy );
                    dollyStart.set( 0, distance );
                    break;

                case 3: // three-fingered touch: pan

                    if ( scope.noPan === true ) return;

                    state = STATE.TOUCH_PAN;

                    panStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );
                    break;

                default:

                    state = STATE.NONE;

            }

            scope.dispatchEvent( startEvent );

        }

        function touchmove( event ) {

            if ( scope.enabled === false ) return;

            event.preventDefault();
            event.stopPropagation();

            var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

            switch ( event.touches.length ) {

                case 1: // one-fingered touch: rotate

                    if ( scope.noRotate === true ) return;
                    if ( state !== STATE.TOUCH_ROTATE ) return;

                    rotateEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );
                    rotateDelta.subVectors( rotateEnd, rotateStart );

                    // rotating across whole screen goes 360 degrees around
                    scope.rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed );
                    // rotating up and down along whole screen attempts to go 360, but limited to 180
                    scope.rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed );

                    rotateStart.copy( rotateEnd );

                    scope.update();
                    break;

                case 2: // two-fingered touch: dolly

                    if ( scope.noZoom === true ) return;
                    if ( state !== STATE.TOUCH_DOLLY ) return;

                    var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;
                    var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;
                    var distance = Math.sqrt( dx * dx + dy * dy );

                    dollyEnd.set( 0, distance );
                    dollyDelta.subVectors( dollyEnd, dollyStart );

                    if ( dollyDelta.y > 0 ) {

                        scope.dollyOut();

                    } else {

                        scope.dollyIn();

                    }

                    dollyStart.copy( dollyEnd );

                    scope.update();
                    break;

                case 3: // three-fingered touch: pan

                    if ( scope.noPan === true ) return;
                    if ( state !== STATE.TOUCH_PAN ) return;

                    panEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );
                    panDelta.subVectors( panEnd, panStart );
                    
                    scope.pan( panDelta.x, panDelta.y );

                    panStart.copy( panEnd );

                    scope.update();
                    break;

                default:

                    state = STATE.NONE;

            }

        }

        function touchend( /* event */ ) {

            if ( scope.enabled === false ) return;

            scope.dispatchEvent( endEvent );
            state = STATE.NONE;

        }

        this.domElement.addEventListener( 'contextmenu', function ( event ) { event.preventDefault(); }, false );
        this.domElement.addEventListener( 'mousedown', onMouseDown, false );
        this.domElement.addEventListener( 'mousewheel', onMouseWheel, false );
        this.domElement.addEventListener( 'DOMMouseScroll', onMouseWheel, false ); // firefox

        this.domElement.addEventListener( 'touchstart', touchstart, false );
        this.domElement.addEventListener( 'touchend', touchend, false );
        this.domElement.addEventListener( 'touchmove', touchmove, false );

        window.addEventListener( 'keydown', onKeyDown, false );

        // force an update at start
        this.update();

    };

    inherits(OrbitControls, THREE.EventDispatcher)
    return OrbitControls
}
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"inherits":"/projects/blackice/node_modules/inherits/inherits_browser.js"}],"/projects/blackice/node_modules/as-number/index.js":[function(require,module,exports){
module.exports = function numtype(num, def) {
	return typeof num === 'number'
		? num 
		: (typeof def === 'number' ? def : 0)
}
},{}],"/projects/blackice/node_modules/browserify/node_modules/buffer/index.js":[function(require,module,exports){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var isArray = require('is-array')

exports.Buffer = Buffer
exports.SlowBuffer = Buffer
exports.INSPECT_MAX_BYTES = 50
Buffer.poolSize = 8192 // not used by this implementation

var kMaxLength = 0x3fffffff

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Note:
 *
 * - Implementation must support adding new properties to `Uint8Array` instances.
 *   Firefox 4-29 lacked support, fixed in Firefox 30+.
 *   See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *  - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *  - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *    incorrect length in some situations.
 *
 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they will
 * get the Object implementation, which is slower but will work correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = (function () {
  try {
    var buf = new ArrayBuffer(0)
    var arr = new Uint8Array(buf)
    arr.foo = function () { return 42 }
    return 42 === arr.foo() && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        new Uint8Array(1).subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
})()

/**
 * Class: Buffer
 * =============
 *
 * The Buffer constructor returns instances of `Uint8Array` that are augmented
 * with function properties for all the node `Buffer` API functions. We use
 * `Uint8Array` so that square bracket notation works as expected -- it returns
 * a single octet.
 *
 * By augmenting the instances, we can avoid modifying the `Uint8Array`
 * prototype.
 */
function Buffer (subject, encoding, noZero) {
  if (!(this instanceof Buffer))
    return new Buffer(subject, encoding, noZero)

  var type = typeof subject

  // Find the length
  var length
  if (type === 'number')
    length = subject > 0 ? subject >>> 0 : 0
  else if (type === 'string') {
    if (encoding === 'base64')
      subject = base64clean(subject)
    length = Buffer.byteLength(subject, encoding)
  } else if (type === 'object' && subject !== null) { // assume object is array-like
    if (subject.type === 'Buffer' && isArray(subject.data))
      subject = subject.data
    length = +subject.length > 0 ? Math.floor(+subject.length) : 0
  } else
    throw new TypeError('must start with number, buffer, array or string')

  if (this.length > kMaxLength)
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
      'size: 0x' + kMaxLength.toString(16) + ' bytes')

  var buf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Preferred: Return an augmented `Uint8Array` instance for best performance
    buf = Buffer._augment(new Uint8Array(length))
  } else {
    // Fallback: Return THIS instance of Buffer (created by `new`)
    buf = this
    buf.length = length
    buf._isBuffer = true
  }

  var i
  if (Buffer.TYPED_ARRAY_SUPPORT && typeof subject.byteLength === 'number') {
    // Speed optimization -- use set if we're copying from a typed array
    buf._set(subject)
  } else if (isArrayish(subject)) {
    // Treat array-ish objects as a byte array
    if (Buffer.isBuffer(subject)) {
      for (i = 0; i < length; i++)
        buf[i] = subject.readUInt8(i)
    } else {
      for (i = 0; i < length; i++)
        buf[i] = ((subject[i] % 256) + 256) % 256
    }
  } else if (type === 'string') {
    buf.write(subject, 0, encoding)
  } else if (type === 'number' && !Buffer.TYPED_ARRAY_SUPPORT && !noZero) {
    for (i = 0; i < length; i++) {
      buf[i] = 0
    }
  }

  return buf
}

Buffer.isBuffer = function (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b))
    throw new TypeError('Arguments must be Buffers')

  var x = a.length
  var y = b.length
  for (var i = 0, len = Math.min(x, y); i < len && a[i] === b[i]; i++) {}
  if (i !== len) {
    x = a[i]
    y = b[i]
  }
  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'raw':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function (list, totalLength) {
  if (!isArray(list)) throw new TypeError('Usage: Buffer.concat(list[, length])')

  if (list.length === 0) {
    return new Buffer(0)
  } else if (list.length === 1) {
    return list[0]
  }

  var i
  if (totalLength === undefined) {
    totalLength = 0
    for (i = 0; i < list.length; i++) {
      totalLength += list[i].length
    }
  }

  var buf = new Buffer(totalLength)
  var pos = 0
  for (i = 0; i < list.length; i++) {
    var item = list[i]
    item.copy(buf, pos)
    pos += item.length
  }
  return buf
}

Buffer.byteLength = function (str, encoding) {
  var ret
  str = str + ''
  switch (encoding || 'utf8') {
    case 'ascii':
    case 'binary':
    case 'raw':
      ret = str.length
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = str.length * 2
      break
    case 'hex':
      ret = str.length >>> 1
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8ToBytes(str).length
      break
    case 'base64':
      ret = base64ToBytes(str).length
      break
    default:
      ret = str.length
  }
  return ret
}

// pre-set for values that may exist in the future
Buffer.prototype.length = undefined
Buffer.prototype.parent = undefined

// toString(encoding, start=0, end=buffer.length)
Buffer.prototype.toString = function (encoding, start, end) {
  var loweredCase = false

  start = start >>> 0
  end = end === undefined || end === Infinity ? this.length : end >>> 0

  if (!encoding) encoding = 'utf8'
  if (start < 0) start = 0
  if (end > this.length) end = this.length
  if (end <= start) return ''

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'binary':
        return binarySlice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase)
          throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.equals = function (b) {
  if(!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max)
      str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  return Buffer.compare(this, b)
}

// `get` will be removed in Node 0.13+
Buffer.prototype.get = function (offset) {
  console.log('.get() is deprecated. Access using array indexes instead.')
  return this.readUInt8(offset)
}

// `set` will be removed in Node 0.13+
Buffer.prototype.set = function (v, offset) {
  console.log('.set() is deprecated. Access using array indexes instead.')
  return this.writeUInt8(v, offset)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new Error('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; i++) {
    var byte = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(byte)) throw new Error('Invalid hex string')
    buf[offset + i] = byte
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  var charsWritten = blitBuffer(utf8ToBytes(string), buf, offset, length)
  return charsWritten
}

function asciiWrite (buf, string, offset, length) {
  var charsWritten = blitBuffer(asciiToBytes(string), buf, offset, length)
  return charsWritten
}

function binaryWrite (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  var charsWritten = blitBuffer(base64ToBytes(string), buf, offset, length)
  return charsWritten
}

function utf16leWrite (buf, string, offset, length) {
  var charsWritten = blitBuffer(utf16leToBytes(string), buf, offset, length)
  return charsWritten
}

Buffer.prototype.write = function (string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length
      length = undefined
    }
  } else {  // legacy
    var swap = encoding
    encoding = offset
    offset = length
    length = swap
  }

  offset = Number(offset) || 0
  var remaining = this.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase()

  var ret
  switch (encoding) {
    case 'hex':
      ret = hexWrite(this, string, offset, length)
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8Write(this, string, offset, length)
      break
    case 'ascii':
      ret = asciiWrite(this, string, offset, length)
      break
    case 'binary':
      ret = binaryWrite(this, string, offset, length)
      break
    case 'base64':
      ret = base64Write(this, string, offset, length)
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = utf16leWrite(this, string, offset, length)
      break
    default:
      throw new TypeError('Unknown encoding: ' + encoding)
  }
  return ret
}

Buffer.prototype.toJSON = function () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  var res = ''
  var tmp = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    if (buf[i] <= 0x7F) {
      res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i])
      tmp = ''
    } else {
      tmp += '%' + buf[i].toString(16)
    }
  }

  return res + decodeUtf8Char(tmp)
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function binarySlice (buf, start, end) {
  return asciiSlice(buf, start, end)
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; i++) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len;
    if (start < 0)
      start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0)
      end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start)
    end = start

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    return Buffer._augment(this.subarray(start, end))
  } else {
    var sliceLen = end - start
    var newBuf = new Buffer(sliceLen, undefined, true)
    for (var i = 0; i < sliceLen; i++) {
      newBuf[i] = this[i + start]
    }
    return newBuf
  }
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0)
    throw new RangeError('offset is not uint')
  if (offset + ext > length)
    throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUInt8 = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
      ((this[offset + 1] << 16) |
      (this[offset + 2] << 8) |
      this[offset + 3])
}

Buffer.prototype.readInt8 = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80))
    return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)

  return (this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16) |
      (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
      (this[offset + 1] << 16) |
      (this[offset + 2] << 8) |
      (this[offset + 3])
}

Buffer.prototype.readFloatLE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')
  if (value > max || value < min) throw new TypeError('value is out of bounds')
  if (offset + ext > buf.length) throw new TypeError('index out of range')
}

Buffer.prototype.writeUInt8 = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = value
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
  } else objectWriteUInt16(this, value, offset, true)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = value
  } else objectWriteUInt16(this, value, offset, false)
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = value
  } else objectWriteUInt32(this, value, offset, true)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = value
  } else objectWriteUInt32(this, value, offset, false)
  return offset + 4
}

Buffer.prototype.writeInt8 = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = value
  return offset + 1
}

Buffer.prototype.writeInt16LE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
  } else objectWriteUInt16(this, value, offset, true)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = value
  } else objectWriteUInt16(this, value, offset, false)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else objectWriteUInt32(this, value, offset, true)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = value
  } else objectWriteUInt32(this, value, offset, false)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (value > max || value < min) throw new TypeError('value is out of bounds')
  if (offset + ext > buf.length) throw new TypeError('index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert)
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert)
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function (target, target_start, start, end) {
  var source = this

  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (!target_start) target_start = 0

  // Copy 0 bytes; we're done
  if (end === start) return
  if (target.length === 0 || source.length === 0) return

  // Fatal error conditions
  if (end < start) throw new TypeError('sourceEnd < sourceStart')
  if (target_start < 0 || target_start >= target.length)
    throw new TypeError('targetStart out of bounds')
  if (start < 0 || start >= source.length) throw new TypeError('sourceStart out of bounds')
  if (end < 0 || end > source.length) throw new TypeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length)
    end = this.length
  if (target.length - target_start < end - start)
    end = target.length - target_start + start

  var len = end - start

  if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < len; i++) {
      target[i + target_start] = this[i + start]
    }
  } else {
    target._set(this.subarray(start, start + len), target_start)
  }
}

// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function (value, start, end) {
  if (!value) value = 0
  if (!start) start = 0
  if (!end) end = this.length

  if (end < start) throw new TypeError('end < start')

  // Fill 0 bytes; we're done
  if (end === start) return
  if (this.length === 0) return

  if (start < 0 || start >= this.length) throw new TypeError('start out of bounds')
  if (end < 0 || end > this.length) throw new TypeError('end out of bounds')

  var i
  if (typeof value === 'number') {
    for (i = start; i < end; i++) {
      this[i] = value
    }
  } else {
    var bytes = utf8ToBytes(value.toString())
    var len = bytes.length
    for (i = start; i < end; i++) {
      this[i] = bytes[i % len]
    }
  }

  return this
}

/**
 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
 */
Buffer.prototype.toArrayBuffer = function () {
  if (typeof Uint8Array !== 'undefined') {
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      return (new Buffer(this)).buffer
    } else {
      var buf = new Uint8Array(this.length)
      for (var i = 0, len = buf.length; i < len; i += 1) {
        buf[i] = this[i]
      }
      return buf.buffer
    }
  } else {
    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')
  }
}

// HELPER FUNCTIONS
// ================

var BP = Buffer.prototype

/**
 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
 */
Buffer._augment = function (arr) {
  arr.constructor = Buffer
  arr._isBuffer = true

  // save reference to original Uint8Array get/set methods before overwriting
  arr._get = arr.get
  arr._set = arr.set

  // deprecated, will be removed in node 0.13+
  arr.get = BP.get
  arr.set = BP.set

  arr.write = BP.write
  arr.toString = BP.toString
  arr.toLocaleString = BP.toString
  arr.toJSON = BP.toJSON
  arr.equals = BP.equals
  arr.compare = BP.compare
  arr.copy = BP.copy
  arr.slice = BP.slice
  arr.readUInt8 = BP.readUInt8
  arr.readUInt16LE = BP.readUInt16LE
  arr.readUInt16BE = BP.readUInt16BE
  arr.readUInt32LE = BP.readUInt32LE
  arr.readUInt32BE = BP.readUInt32BE
  arr.readInt8 = BP.readInt8
  arr.readInt16LE = BP.readInt16LE
  arr.readInt16BE = BP.readInt16BE
  arr.readInt32LE = BP.readInt32LE
  arr.readInt32BE = BP.readInt32BE
  arr.readFloatLE = BP.readFloatLE
  arr.readFloatBE = BP.readFloatBE
  arr.readDoubleLE = BP.readDoubleLE
  arr.readDoubleBE = BP.readDoubleBE
  arr.writeUInt8 = BP.writeUInt8
  arr.writeUInt16LE = BP.writeUInt16LE
  arr.writeUInt16BE = BP.writeUInt16BE
  arr.writeUInt32LE = BP.writeUInt32LE
  arr.writeUInt32BE = BP.writeUInt32BE
  arr.writeInt8 = BP.writeInt8
  arr.writeInt16LE = BP.writeInt16LE
  arr.writeInt16BE = BP.writeInt16BE
  arr.writeInt32LE = BP.writeInt32LE
  arr.writeInt32BE = BP.writeInt32BE
  arr.writeFloatLE = BP.writeFloatLE
  arr.writeFloatBE = BP.writeFloatBE
  arr.writeDoubleLE = BP.writeDoubleLE
  arr.writeDoubleBE = BP.writeDoubleBE
  arr.fill = BP.fill
  arr.inspect = BP.inspect
  arr.toArrayBuffer = BP.toArrayBuffer

  return arr
}

var INVALID_BASE64_RE = /[^+\/0-9A-z]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function isArrayish (subject) {
  return isArray(subject) || Buffer.isBuffer(subject) ||
      subject && typeof subject === 'object' &&
      typeof subject.length === 'number'
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    var b = str.charCodeAt(i)
    if (b <= 0x7F) {
      byteArray.push(b)
    } else {
      var start = i
      if (b >= 0xD800 && b <= 0xDFFF) i++
      var h = encodeURIComponent(str.slice(start, i+1)).substr(1).split('%')
      for (var j = 0; j < h.length; j++) {
        byteArray.push(parseInt(h[j], 16))
      }
    }
  }
  return byteArray
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(str)
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; i++) {
    if ((i + offset >= dst.length) || (i >= src.length))
      break
    dst[i + offset] = src[i]
  }
  return i
}

function decodeUtf8Char (str) {
  try {
    return decodeURIComponent(str)
  } catch (err) {
    return String.fromCharCode(0xFFFD) // UTF 8 invalid char
  }
}

},{"base64-js":"/projects/blackice/node_modules/browserify/node_modules/buffer/node_modules/base64-js/lib/b64.js","ieee754":"/projects/blackice/node_modules/browserify/node_modules/buffer/node_modules/ieee754/index.js","is-array":"/projects/blackice/node_modules/browserify/node_modules/buffer/node_modules/is-array/index.js"}],"/projects/blackice/node_modules/browserify/node_modules/buffer/node_modules/base64-js/lib/b64.js":[function(require,module,exports){
var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

;(function (exports) {
	'use strict';

  var Arr = (typeof Uint8Array !== 'undefined')
    ? Uint8Array
    : Array

	var PLUS   = '+'.charCodeAt(0)
	var SLASH  = '/'.charCodeAt(0)
	var NUMBER = '0'.charCodeAt(0)
	var LOWER  = 'a'.charCodeAt(0)
	var UPPER  = 'A'.charCodeAt(0)

	function decode (elt) {
		var code = elt.charCodeAt(0)
		if (code === PLUS)
			return 62 // '+'
		if (code === SLASH)
			return 63 // '/'
		if (code < NUMBER)
			return -1 //no match
		if (code < NUMBER + 10)
			return code - NUMBER + 26 + 26
		if (code < UPPER + 26)
			return code - UPPER
		if (code < LOWER + 26)
			return code - LOWER + 26
	}

	function b64ToByteArray (b64) {
		var i, j, l, tmp, placeHolders, arr

		if (b64.length % 4 > 0) {
			throw new Error('Invalid string. Length must be a multiple of 4')
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		var len = b64.length
		placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

		// base64 is 4/3 + up to two characters of the original data
		arr = new Arr(b64.length * 3 / 4 - placeHolders)

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length

		var L = 0

		function push (v) {
			arr[L++] = v
		}

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
			push((tmp & 0xFF0000) >> 16)
			push((tmp & 0xFF00) >> 8)
			push(tmp & 0xFF)
		}

		if (placeHolders === 2) {
			tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
			push(tmp & 0xFF)
		} else if (placeHolders === 1) {
			tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
			push((tmp >> 8) & 0xFF)
			push(tmp & 0xFF)
		}

		return arr
	}

	function uint8ToBase64 (uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length

		function encode (num) {
			return lookup.charAt(num)
		}

		function tripletToBase64 (num) {
			return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
		}

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
			output += tripletToBase64(temp)
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1]
				output += encode(temp >> 2)
				output += encode((temp << 4) & 0x3F)
				output += '=='
				break
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
				output += encode(temp >> 10)
				output += encode((temp >> 4) & 0x3F)
				output += encode((temp << 2) & 0x3F)
				output += '='
				break
		}

		return output
	}

	exports.toByteArray = b64ToByteArray
	exports.fromByteArray = uint8ToBase64
}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))

},{}],"/projects/blackice/node_modules/browserify/node_modules/buffer/node_modules/ieee754/index.js":[function(require,module,exports){
exports.read = function(buffer, offset, isLE, mLen, nBytes) {
  var e, m,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      nBits = -7,
      i = isLE ? (nBytes - 1) : 0,
      d = isLE ? -1 : 1,
      s = buffer[offset + i];

  i += d;

  e = s & ((1 << (-nBits)) - 1);
  s >>= (-nBits);
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);

  m = e & ((1 << (-nBits)) - 1);
  e >>= (-nBits);
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity);
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
      i = isLE ? 0 : (nBytes - 1),
      d = isLE ? 1 : -1,
      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);

  e = (e << mLen) | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);

  buffer[offset + i - d] |= s * 128;
};

},{}],"/projects/blackice/node_modules/browserify/node_modules/buffer/node_modules/is-array/index.js":[function(require,module,exports){

/**
 * isArray
 */

var isArray = Array.isArray;

/**
 * toString
 */

var str = Object.prototype.toString;

/**
 * Whether or not the given `val`
 * is an array.
 *
 * example:
 *
 *        isArray([]);
 *        // > true
 *        isArray(arguments);
 *        // > false
 *        isArray('');
 *        // > false
 *
 * @param {mixed} val
 * @return {bool}
 */

module.exports = isArray || function (val) {
  return !! val && '[object Array]' == str.call(val);
};

},{}],"/projects/blackice/node_modules/canvas-app/index.js":[function(require,module,exports){
var isGL = require('is-webgl-context');
var getGL = require('webgl-context');
var debounce = require('debounce');
var addEvent = require('add-event-listener');

function isCanvasContext(obj) {
    var ctx2d = typeof CanvasRenderingContext2D !== 'undefined' && obj instanceof CanvasRenderingContext2D;
    return obj && (ctx2d || isGL(obj));
}

function CanvasApp(render, options) {
    if (!(this instanceof CanvasApp))
        return new CanvasApp(render, options);

    //allow options to be passed as first argument
    if (typeof render === 'object' && render) {
        options = render;
        render = null;
    }

    render = typeof render === 'function' ? render : options.onRender;

    options = options||{};
    options.retina = typeof options.retina === "boolean" ? options.retina : true;
    
    var hasWidth = typeof options.width === "number", 
        hasHeight = typeof options.height === "number";

    //if either width or height is specified, don't auto-resize to the window...
    if (hasWidth || hasHeight) 
        options.ignoreResize = true;

    options.width = hasWidth ? options.width : window.innerWidth;
    options.height = hasHeight ? options.height : window.innerHeight;

    var DPR = options.retina ? (window.devicePixelRatio||1) : 1; 

    //setup the canvas
    var canvas,
        context,
        attribs = options.contextAttributes||{};

    this.isWebGL = false;

    //if user provided a context object
    if (isCanvasContext(options.context)) {
        context = options.context;
        canvas = context.canvas;
    }

    //otherwise allow for a string to set one up
    if (!canvas)
        canvas = options.canvas || document.createElement("canvas");

    canvas.width = options.width * DPR;
    canvas.height = options.height * DPR;

    if (!context) {
        if (options.context === "webgl" || options.context === "experimental-webgl") {
            context = getGL({ canvas: canvas, attributes: attribs });
            if (!context) {
                throw "WebGL Context Not Supported -- try enabling it or using a different browser";
            }
        } else {
            context = canvas.getContext(options.context||"2d", attribs);
        }
    }

    this.isWebGL = isGL(context);

    if (options.retina) {
        canvas.style.width = options.width + 'px';
        canvas.style.height = options.height + 'px';
    }

    this.running = false;
    this.width = options.width;
    this.height = options.height;
    this.canvas = canvas;
    this.context = context;
    this.onResize = options.onResize;
    this._DPR = DPR;
    this._retina = options.retina;
    this._once = options.once;
    this._ignoreResize = options.ignoreResize;
    this._lastFrame = null;
    this._then = Date.now();

    //FPS counter
    this.fps = 60;
    this._frames = 0;
    this._prevTime = this._then;

    if (!this._ignoreResize) {
        options.resizeDebounce = typeof options.resizeDebounce === 'number'
                    ? options.resizeDebounce : 50;
        addEvent(window, "resize", debounce(function() {
            this.resize(window.innerWidth, window.innerHeight);
        }.bind(this), options.resizeDebounce, false));

        addEvent(window, "orientationchange", function() {
            this.resize(window.innerWidth, window.innerHeight);
        }.bind(this));
    }

    if (typeof render === "function") {
        this.onRender = render.bind(this);   
    } else {
        //dummy render function
        this.onRender = function (context, width, height, dt) { };
    }

    this.renderOnce = function() {
        var now = Date.now();
        var dt = (now-this._then);

        this._frames++;
        if (now > this._prevTime + 1000) {
            this.fps = Math.round((this._frames * 1000) / (now - this._prevTime));

            this._prevTime = now;
            this._frames = 0;
        }

        if (!this.isWebGL) {
            this.context.save();
            this.context.scale(this._DPR, this._DPR);
        } else {
            this.context.viewport(0, 0, this.width * this._DPR, this.height * this._DPR);
        }
        
        this.onRender(this.context, this.width, this.height, dt);

        if (!this.isWebGL)
            this.context.restore();

        this._then = now;
    };

    this._renderHandler = function() {
        if (!this.running) 
            return;
        
        if (!this._once) {
            this._lastFrame = requestAnimationFrame(this._renderHandler);
        }

        this.renderOnce();
    }.bind(this);

    if (typeof options.onReady === "function") {
        options.onReady.call(this, context, this.width, this.height);
    }
}

Object.defineProperty(CanvasApp.prototype, 'retinaEnabled', {

    set: function(v) {
        this._retina = v;
        this._DPR = this._retina ? (window.devicePixelRatio||1) : 1;
        this.resize(this.width, this.height);
    },

    get: function() {
        return this._retina;
    }
});

Object.defineProperty(CanvasApp.prototype, 'deviceWidth', {

    get: function() {
        return this.width * this._DPR;
    }
});

Object.defineProperty(CanvasApp.prototype, 'deviceHeight', {

    get: function() {
        return this.height * this._DPR;
    }
});

CanvasApp.prototype.resetFPS = function() {
    this._frames = 0;
    this._prevTime = Date.now();
    this._then = this._prevTime;
    this.fps = 60;
};

CanvasApp.prototype.start = function() {
    if (this.running)
        return;
    
    if (this._lastFrame) 
        cancelAnimationFrame(this._lastFrame);

    //reset FPS counter
    this.resetFPS();

    this.running = true;
    this._lastFrame = requestAnimationFrame(this._renderHandler);
};

CanvasApp.prototype.stop = function() {
    if (this._lastFrame) {
        cancelAnimationFrame(this._lastFrame);
        this._lastFrame = null;
    }
    this.running = false;
};

CanvasApp.prototype.resize = function(width, height) {
    var canvas = this.canvas;

    this.width = width;
    this.height = height;
    canvas.width = this.width * this._DPR;
    canvas.height = this.height * this._DPR;

    if (this._retina) {
        canvas.style.width = this.width + 'px';
        canvas.style.height = this.height + 'px';
    }

    if (this._once)
        requestAnimationFrame(this._renderHandler);
    if (typeof this.onResize === "function")
        this.onResize(this.width, this.height);
};

module.exports = CanvasApp;
},{"add-event-listener":"/projects/blackice/node_modules/canvas-app/node_modules/add-event-listener/index.js","debounce":"/projects/blackice/node_modules/canvas-app/node_modules/debounce/index.js","is-webgl-context":"/projects/blackice/node_modules/canvas-app/node_modules/is-webgl-context/index.js","webgl-context":"/projects/blackice/node_modules/canvas-app/node_modules/webgl-context/index.js"}],"/projects/blackice/node_modules/canvas-app/node_modules/add-event-listener/index.js":[function(require,module,exports){
addEventListener.removeEventListener = removeEventListener
addEventListener.addEventListener = addEventListener

module.exports = addEventListener

var Events = null

function addEventListener(el, eventName, listener, useCapture) {
  Events = Events || (
    document.addEventListener ?
    {add: stdAttach, rm: stdDetach} :
    {add: oldIEAttach, rm: oldIEDetach}
  )
  
  return Events.add(el, eventName, listener, useCapture)
}

function removeEventListener(el, eventName, listener, useCapture) {
  Events = Events || (
    document.addEventListener ?
    {add: stdAttach, rm: stdDetach} :
    {add: oldIEAttach, rm: oldIEDetach}
  )
  
  return Events.rm(el, eventName, listener, useCapture)
}

function stdAttach(el, eventName, listener, useCapture) {
  el.addEventListener(eventName, listener, useCapture)
}

function stdDetach(el, eventName, listener, useCapture) {
  el.removeEventListener(eventName, listener, useCapture)
}

function oldIEAttach(el, eventName, listener, useCapture) {
  if(useCapture) {
    throw new Error('cannot useCapture in oldIE')
  }

  el.attachEvent('on' + eventName, listener)
}

function oldIEDetach(el, eventName, listener, useCapture) {
  el.detachEvent('on' + eventName, listener)
}

},{}],"/projects/blackice/node_modules/canvas-app/node_modules/debounce/index.js":[function(require,module,exports){

/**
 * Module dependencies.
 */

var now = require('date-now');

/**
 * Returns a function, that, as long as it continues to be invoked, will not
 * be triggered. The function will be called after it stops being called for
 * N milliseconds. If `immediate` is passed, trigger the function on the
 * leading edge, instead of the trailing.
 *
 * @source underscore.js
 * @see http://unscriptable.com/2009/03/20/debouncing-javascript-methods/
 * @param {Function} function to wrap
 * @param {Number} timeout in ms (`100`)
 * @param {Boolean} whether to execute at the beginning (`false`)
 * @api public
 */

module.exports = function debounce(func, wait, immediate){
  var timeout, args, context, timestamp, result;
  if (null == wait) wait = 100;

  function later() {
    var last = now() - timestamp;

    if (last < wait && last > 0) {
      timeout = setTimeout(later, wait - last);
    } else {
      timeout = null;
      if (!immediate) {
        result = func.apply(context, args);
        if (!timeout) context = args = null;
      }
    }
  };

  return function debounced() {
    context = this;
    args = arguments;
    timestamp = now();
    var callNow = immediate && !timeout;
    if (!timeout) timeout = setTimeout(later, wait);
    if (callNow) {
      result = func.apply(context, args);
      context = args = null;
    }

    return result;
  };
};

},{"date-now":"/projects/blackice/node_modules/canvas-app/node_modules/debounce/node_modules/date-now/index.js"}],"/projects/blackice/node_modules/canvas-app/node_modules/debounce/node_modules/date-now/index.js":[function(require,module,exports){
module.exports = Date.now || now

function now() {
    return new Date().getTime()
}

},{}],"/projects/blackice/node_modules/canvas-app/node_modules/is-webgl-context/index.js":[function(require,module,exports){
module.exports = function(ctx) {
	if (!ctx) return false
	var gl = ctx
	//compatibility with Chrome WebGL Inspector Addon
	if (typeof ctx.rawgl !== 'undefined')
		gl = ctx.rawgl
	if (typeof WebGLRenderingContext !== 'undefined' && gl instanceof WebGLRenderingContext)
		return true
	return false
}
},{}],"/projects/blackice/node_modules/canvas-app/node_modules/webgl-context/index.js":[function(require,module,exports){
module.exports = function(opts) {
    opts = opts||{};
    var canvas = opts.canvas || document.createElement("canvas");
    if (typeof opts.width === "number")
        canvas.width = opts.width;
    if (typeof opts.height === "number")
        canvas.height = opts.height;
    
    var attribs = (opts.attributes || opts.attribs || {});
    try {
        gl = (canvas.getContext('webgl', attribs) || canvas.getContext('experimental-webgl', attribs));
    } catch (e) {
        gl = null;
    }
    return gl;
};
},{}],"/projects/blackice/node_modules/clamp/index.js":[function(require,module,exports){
module.exports = clamp

function clamp(value, min, max) {
  return min < max
    ? (value < min ? min : value > max ? max : value)
    : (value < max ? max : value > min ? min : value)
}

},{}],"/projects/blackice/node_modules/domready/ready.js":[function(require,module,exports){
/*!
  * domready (c) Dustin Diaz 2014 - License MIT
  */
!function (name, definition) {

  if (typeof module != 'undefined') module.exports = definition()
  else if (typeof define == 'function' && typeof define.amd == 'object') define(definition)
  else this[name] = definition()

}('domready', function () {

  var fns = [], listener
    , doc = document
    , hack = doc.documentElement.doScroll
    , domContentLoaded = 'DOMContentLoaded'
    , loaded = (hack ? /^loaded|^c/ : /^loaded|^i|^c/).test(doc.readyState)


  if (!loaded)
  doc.addEventListener(domContentLoaded, listener = function () {
    doc.removeEventListener(domContentLoaded, listener)
    loaded = 1
    while (listener = fns.shift()) listener()
  })

  return function (fn) {
    loaded ? fn() : fns.push(fn)
  }

});

},{}],"/projects/blackice/node_modules/gl-mat4/identity.js":[function(require,module,exports){
module.exports = identity;

/**
 * Set a mat4 to the identity matrix
 *
 * @param {mat4} out the receiving matrix
 * @returns {mat4} out
 */
function identity(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
};
},{}],"/projects/blackice/node_modules/gl-mat4/multiply.js":[function(require,module,exports){
module.exports = multiply;

/**
 * Multiplies two mat4's
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
function multiply(out, a, b) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

    // Cache only the current line of the second matrix
    var b0  = b[0], b1 = b[1], b2 = b[2], b3 = b[3];  
    out[0] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[1] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[2] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[3] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[4]; b1 = b[5]; b2 = b[6]; b3 = b[7];
    out[4] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[5] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[6] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[7] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[8]; b1 = b[9]; b2 = b[10]; b3 = b[11];
    out[8] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[9] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[10] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[11] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[12]; b1 = b[13]; b2 = b[14]; b3 = b[15];
    out[12] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[13] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[14] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[15] = b0*a03 + b1*a13 + b2*a23 + b3*a33;
    return out;
};
},{}],"/projects/blackice/node_modules/gl-mat4/scale.js":[function(require,module,exports){
module.exports = scale;

/**
 * Scales the mat4 by the dimensions in the given vec3
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {vec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 **/
function scale(out, a, v) {
    var x = v[0], y = v[1], z = v[2];

    out[0] = a[0] * x;
    out[1] = a[1] * x;
    out[2] = a[2] * x;
    out[3] = a[3] * x;
    out[4] = a[4] * y;
    out[5] = a[5] * y;
    out[6] = a[6] * y;
    out[7] = a[7] * y;
    out[8] = a[8] * z;
    out[9] = a[9] * z;
    out[10] = a[10] * z;
    out[11] = a[11] * z;
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};
},{}],"/projects/blackice/node_modules/gl-mat4/translate.js":[function(require,module,exports){
module.exports = translate;

/**
 * Translate a mat4 by the given vector
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to translate
 * @param {vec3} v vector to translate by
 * @returns {mat4} out
 */
function translate(out, a, v) {
    var x = v[0], y = v[1], z = v[2],
        a00, a01, a02, a03,
        a10, a11, a12, a13,
        a20, a21, a22, a23;

    if (a === out) {
        out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
        out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
        out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
        out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
    } else {
        a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
        a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
        a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

        out[0] = a00; out[1] = a01; out[2] = a02; out[3] = a03;
        out[4] = a10; out[5] = a11; out[6] = a12; out[7] = a13;
        out[8] = a20; out[9] = a21; out[10] = a22; out[11] = a23;

        out[12] = a00 * x + a10 * y + a20 * z + a[12];
        out[13] = a01 * x + a11 * y + a21 * z + a[13];
        out[14] = a02 * x + a12 * y + a22 * z + a[14];
        out[15] = a03 * x + a13 * y + a23 * z + a[15];
    }

    return out;
};
},{}],"/projects/blackice/node_modules/gl-texture2d/node_modules/ndarray-ops/ndarray-ops.js":[function(require,module,exports){
"use strict"

var compile = require("cwise-compiler")

var EmptyProc = {
  body: "",
  args: [],
  thisVars: [],
  localVars: []
}

function fixup(x) {
  if(!x) {
    return EmptyProc
  }
  for(var i=0; i<x.args.length; ++i) {
    var a = x.args[i]
    if(i === 0) {
      x.args[i] = {name: a, lvalue:true, rvalue: !!x.rvalue, count:x.count||1 }
    } else {
      x.args[i] = {name: a, lvalue:false, rvalue:true, count: 1}
    }
  }
  if(!x.thisVars) {
    x.thisVars = []
  }
  if(!x.localVars) {
    x.localVars = []
  }
  return x
}

function pcompile(user_args) {
  return compile({
    args:     user_args.args,
    pre:      fixup(user_args.pre),
    body:     fixup(user_args.body),
    post:     fixup(user_args.proc),
    funcName: user_args.funcName
  })
}

function makeOp(user_args) {
  var args = []
  for(var i=0; i<user_args.args.length; ++i) {
    args.push("a"+i)
  }
  var wrapper = new Function("P", [
    "return function ", user_args.funcName, "_ndarrayops(", args.join(","), ") {P(", args.join(","), ");return a0}"
  ].join(""))
  return wrapper(pcompile(user_args))
}

var assign_ops = {
  add:  "+",
  sub:  "-",
  mul:  "*",
  div:  "/",
  mod:  "%",
  band: "&",
  bor:  "|",
  bxor: "^",
  lshift: "<<",
  rshift: ">>",
  rrshift: ">>>"
}
;(function(){
  for(var id in assign_ops) {
    var op = assign_ops[id]
    exports[id] = makeOp({
      args: ["array","array","array"],
      body: {args:["a","b","c"],
             body: "a=b"+op+"c"},
      funcName: id
    })
    exports[id+"eq"] = makeOp({
      args: ["array","array"],
      body: {args:["a","b"],
             body:"a"+op+"=b"},
      rvalue: true,
      funcName: id+"eq"
    })
    exports[id+"s"] = makeOp({
      args: ["array", "array", "scalar"],
      body: {args:["a","b","s"],
             body:"a=b"+op+"s"},
      funcName: id+"s"
    })
    exports[id+"seq"] = makeOp({
      args: ["array","scalar"],
      body: {args:["a","s"],
             body:"a"+op+"=s"},
      rvalue: true,
      funcName: id+"seq"
    })
  }
})();

var unary_ops = {
  not: "!",
  bnot: "~",
  neg: "-",
  recip: "1.0/"
}
;(function(){
  for(var id in unary_ops) {
    var op = unary_ops[id]
    exports[id] = makeOp({
      args: ["array", "array"],
      body: {args:["a","b"],
             body:"a="+op+"b"},
      funcName: id
    })
    exports[id+"eq"] = makeOp({
      args: ["array"],
      body: {args:["a"],
             body:"a="+op+"a"},
      rvalue: true,
      count: 2,
      funcName: id+"eq"
    })
  }
})();

var binary_ops = {
  and: "&&",
  or: "||",
  eq: "===",
  neq: "!==",
  lt: "<",
  gt: ">",
  leq: "<=",
  geq: ">="
}
;(function() {
  for(var id in binary_ops) {
    var op = binary_ops[id]
    exports[id] = makeOp({
      args: ["array","array","array"],
      body: {args:["a", "b", "c"],
             body:"a=b"+op+"c"},
      funcName: id
    })
    exports[id+"s"] = makeOp({
      args: ["array","array","scalar"],
      body: {args:["a", "b", "s"],
             body:"a=b"+op+"s"},
      funcName: id+"s"
    })
    exports[id+"eq"] = makeOp({
      args: ["array", "array"],
      body: {args:["a", "b"],
             body:"a=a"+op+"b"},
      rvalue:true,
      count:2,
      funcName: id+"eq"
    })
    exports[id+"seq"] = makeOp({
      args: ["array", "scalar"],
      body: {args:["a","s"],
             body:"a=a"+op+"s"},
      rvalue:true,
      count:2,
      funcName: id+"seq"
    })
  }
})();

var math_unary = [
  "abs",
  "acos",
  "asin",
  "atan",
  "ceil",
  "cos",
  "exp",
  "floor",
  "log",
  "round",
  "sin",
  "sqrt",
  "tan"
]
;(function() {
  for(var i=0; i<math_unary.length; ++i) {
    var f = math_unary[i]
    exports[f] = makeOp({
                    args: ["array", "array"],
                    pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
                    body: {args:["a","b"], body:"a=this_f(b)", thisVars:["this_f"]},
                    funcName: f
                  })
    exports[f+"eq"] = makeOp({
                      args: ["array"],
                      pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
                      body: {args: ["a"], body:"a=this_f(a)", thisVars:["this_f"]},
                      rvalue: true,
                      count: 2,
                      funcName: f+"eq"
                    })
  }
})();

var math_comm = [
  "max",
  "min",
  "atan2",
  "pow"
]
;(function(){
  for(var i=0; i<math_comm.length; ++i) {
    var f= math_comm[i]
    exports[f] = makeOp({
                  args:["array", "array", "array"],
                  pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
                  body: {args:["a","b","c"], body:"a=this_f(b,c)", thisVars:["this_f"]},
                  funcName: f
                })
    exports[f+"s"] = makeOp({
                  args:["array", "array", "scalar"],
                  pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
                  body: {args:["a","b","c"], body:"a=this_f(b,c)", thisVars:["this_f"]},
                  funcName: f+"s"
                  })
    exports[f+"eq"] = makeOp({ args:["array", "array"],
                  pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
                  body: {args:["a","b"], body:"a=this_f(a,b)", thisVars:["this_f"]},
                  rvalue: true,
                  count: 2,
                  funcName: f+"eq"
                  })
    exports[f+"seq"] = makeOp({ args:["array", "scalar"],
                  pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
                  body: {args:["a","b"], body:"a=this_f(a,b)", thisVars:["this_f"]},
                  rvalue:true,
                  count:2,
                  funcName: f+"seq"
                  })
  }
})();

var math_noncomm = [
  "atan2",
  "pow"
]
;(function(){
  for(var i=0; i<math_noncomm.length; ++i) {
    var f= math_noncomm[i]
    exports[f+"op"] = makeOp({
                  args:["array", "array", "array"],
                  pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
                  body: {args:["a","b","c"], body:"a=this_f(c,b)", thisVars:["this_f"]},
                  funcName: f+"op"
                })
    exports[f+"ops"] = makeOp({
                  args:["array", "array", "scalar"],
                  pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
                  body: {args:["a","b","c"], body:"a=this_f(c,b)", thisVars:["this_f"]},
                  funcName: f+"ops"
                  })
    exports[f+"opeq"] = makeOp({ args:["array", "array"],
                  pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
                  body: {args:["a","b"], body:"a=this_f(b,a)", thisVars:["this_f"]},
                  rvalue: true,
                  count: 2,
                  funcName: f+"opeq"
                  })
    exports[f+"opseq"] = makeOp({ args:["array", "scalar"],
                  pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
                  body: {args:["a","b"], body:"a=this_f(b,a)", thisVars:["this_f"]},
                  rvalue:true,
                  count:2,
                  funcName: f+"opseq"
                  })
  }
})();

exports.any = compile({
  args:["array"],
  pre: EmptyProc,
  body: {args:[{name:"a", lvalue:false, rvalue:true, count:1}], body: "if(a){return true}", localVars: [], thisVars: []},
  post: {args:[], localVars:[], thisVars:[], body:"return false"},
  funcName: "any"
})

exports.all = compile({
  args:["array"],
  pre: EmptyProc,
  body: {args:[{name:"x", lvalue:false, rvalue:true, count:1}], body: "if(!x){return false}", localVars: [], thisVars: []},
  post: {args:[], localVars:[], thisVars:[], body:"return true"},
  funcName: "all"
})

exports.sum = compile({
  args:["array"],
  pre: {args:[], localVars:[], thisVars:["this_s"], body:"this_s=0"},
  body: {args:[{name:"a", lvalue:false, rvalue:true, count:1}], body: "this_s+=a", localVars: [], thisVars: ["this_s"]},
  post: {args:[], localVars:[], thisVars:["this_s"], body:"return this_s"},
  funcName: "sum"
})

exports.prod = compile({
  args:["array"],
  pre: {args:[], localVars:[], thisVars:["this_s"], body:"this_s=1"},
  body: {args:[{name:"a", lvalue:false, rvalue:true, count:1}], body: "this_s*=a", localVars: [], thisVars: ["this_s"]},
  post: {args:[], localVars:[], thisVars:["this_s"], body:"return this_s"},
  funcName: "prod"
})

exports.norm2squared = compile({
  args:["array"],
  pre: {args:[], localVars:[], thisVars:["this_s"], body:"this_s=0"},
  body: {args:[{name:"a", lvalue:false, rvalue:true, count:2}], body: "this_s+=a*a", localVars: [], thisVars: ["this_s"]},
  post: {args:[], localVars:[], thisVars:["this_s"], body:"return this_s"},
  funcName: "norm2squared"
})
  
exports.norm2 = compile({
  args:["array"],
  pre: {args:[], localVars:[], thisVars:["this_s"], body:"this_s=0"},
  body: {args:[{name:"a", lvalue:false, rvalue:true, count:2}], body: "this_s+=a*a", localVars: [], thisVars: ["this_s"]},
  post: {args:[], localVars:[], thisVars:["this_s"], body:"return Math.sqrt(this_s)"},
  funcName: "norm2"
})
  

exports.norminf = compile({
  args:["array"],
  pre: {args:[], localVars:[], thisVars:["this_s"], body:"this_s=0"},
  body: {args:[{name:"a", lvalue:false, rvalue:true, count:4}], body:"if(-a>this_s){this_s=-a}else if(a>this_s){this_s=a}", localVars: [], thisVars: ["this_s"]},
  post: {args:[], localVars:[], thisVars:["this_s"], body:"return this_s"},
  funcName: "norminf"
})

exports.norm1 = compile({
  args:["array"],
  pre: {args:[], localVars:[], thisVars:["this_s"], body:"this_s=0"},
  body: {args:[{name:"a", lvalue:false, rvalue:true, count:3}], body: "this_s+=a<0?-a:a", localVars: [], thisVars: ["this_s"]},
  post: {args:[], localVars:[], thisVars:["this_s"], body:"return this_s"},
  funcName: "norm1"
})

exports.sup = compile({
  args: [ "array" ],
  pre:
   { body: "this_h=-Infinity",
     args: [],
     thisVars: [ "this_h" ],
     localVars: [] },
  body:
   { body: "if(_inline_1_arg0_>this_h)this_h=_inline_1_arg0_",
     args: [{"name":"_inline_1_arg0_","lvalue":false,"rvalue":true,"count":2} ],
     thisVars: [ "this_h" ],
     localVars: [] },
  post:
   { body: "return this_h",
     args: [],
     thisVars: [ "this_h" ],
     localVars: [] }
 })

exports.inf = compile({
  args: [ "array" ],
  pre:
   { body: "this_h=Infinity",
     args: [],
     thisVars: [ "this_h" ],
     localVars: [] },
  body:
   { body: "if(_inline_1_arg0_<this_h)this_h=_inline_1_arg0_",
     args: [{"name":"_inline_1_arg0_","lvalue":false,"rvalue":true,"count":2} ],
     thisVars: [ "this_h" ],
     localVars: [] },
  post:
   { body: "return this_h",
     args: [],
     thisVars: [ "this_h" ],
     localVars: [] }
 })

exports.argmin = compile({
  args:["index","array","shape"],
  pre:{
    body:"{this_v=Infinity;this_i=_inline_0_arg2_.slice(0)}",
    args:[
      {name:"_inline_0_arg0_",lvalue:false,rvalue:false,count:0},
      {name:"_inline_0_arg1_",lvalue:false,rvalue:false,count:0},
      {name:"_inline_0_arg2_",lvalue:false,rvalue:true,count:1}
      ],
    thisVars:["this_i","this_v"],
    localVars:[]},
  body:{
    body:"{if(_inline_1_arg1_<this_v){this_v=_inline_1_arg1_;for(var _inline_1_k=0;_inline_1_k<_inline_1_arg0_.length;++_inline_1_k){this_i[_inline_1_k]=_inline_1_arg0_[_inline_1_k]}}}",
    args:[
      {name:"_inline_1_arg0_",lvalue:false,rvalue:true,count:2},
      {name:"_inline_1_arg1_",lvalue:false,rvalue:true,count:2}],
    thisVars:["this_i","this_v"],
    localVars:["_inline_1_k"]},
  post:{
    body:"{return this_i}",
    args:[],
    thisVars:["this_i"],
    localVars:[]}
})

exports.argmax = compile({
  args:["index","array","shape"],
  pre:{
    body:"{this_v=-Infinity;this_i=_inline_0_arg2_.slice(0)}",
    args:[
      {name:"_inline_0_arg0_",lvalue:false,rvalue:false,count:0},
      {name:"_inline_0_arg1_",lvalue:false,rvalue:false,count:0},
      {name:"_inline_0_arg2_",lvalue:false,rvalue:true,count:1}
      ],
    thisVars:["this_i","this_v"],
    localVars:[]},
  body:{
    body:"{if(_inline_1_arg1_>this_v){this_v=_inline_1_arg1_;for(var _inline_1_k=0;_inline_1_k<_inline_1_arg0_.length;++_inline_1_k){this_i[_inline_1_k]=_inline_1_arg0_[_inline_1_k]}}}",
    args:[
      {name:"_inline_1_arg0_",lvalue:false,rvalue:true,count:2},
      {name:"_inline_1_arg1_",lvalue:false,rvalue:true,count:2}],
    thisVars:["this_i","this_v"],
    localVars:["_inline_1_k"]},
  post:{
    body:"{return this_i}",
    args:[],
    thisVars:["this_i"],
    localVars:[]}
})  

exports.random = makeOp({
  args: ["array"],
  pre: {args:[], body:"this_f=Math.random", thisVars:["this_f"]},
  body: {args: ["a"], body:"a=this_f()", thisVars:["this_f"]},
  funcName: "random"
})

exports.assign = makeOp({
  args:["array", "array"],
  body: {args:["a", "b"], body:"a=b"},
  funcName: "assign" })

exports.assigns = makeOp({
  args:["array", "scalar"],
  body: {args:["a", "b"], body:"a=b"},
  funcName: "assigns" })


exports.equals = compile({
  args:["array", "array"],
  pre: EmptyProc,
  body: {args:[{name:"x", lvalue:false, rvalue:true, count:1},
               {name:"y", lvalue:false, rvalue:true, count:1}], 
        body: "if(x!==y){return false}", 
        localVars: [], 
        thisVars: []},
  post: {args:[], localVars:[], thisVars:[], body:"return true"},
  funcName: "equals"
})



},{"cwise-compiler":"/projects/blackice/node_modules/gl-texture2d/node_modules/ndarray-ops/node_modules/cwise-compiler/compiler.js"}],"/projects/blackice/node_modules/gl-texture2d/node_modules/ndarray-ops/node_modules/cwise-compiler/compiler.js":[function(require,module,exports){
"use strict"

var createThunk = require("./lib/thunk.js")

function Procedure() {
  this.argTypes = []
  this.shimArgs = []
  this.arrayArgs = []
  this.scalarArgs = []
  this.offsetArgs = []
  this.offsetArgIndex = []
  this.indexArgs = []
  this.shapeArgs = []
  this.funcName = ""
  this.pre = null
  this.body = null
  this.post = null
  this.debug = false
}

function compileCwise(user_args) {
  //Create procedure
  var proc = new Procedure()
  
  //Parse blocks
  proc.pre    = user_args.pre
  proc.body   = user_args.body
  proc.post   = user_args.post

  //Parse arguments
  var proc_args = user_args.args.slice(0)
  proc.argTypes = proc_args
  for(var i=0; i<proc_args.length; ++i) {
    var arg_type = proc_args[i]
    if(arg_type === "array") {
      proc.arrayArgs.push(i)
      proc.shimArgs.push("array" + i)
      if(i < proc.pre.args.length && proc.pre.args[i].count>0) {
        throw new Error("cwise: pre() block may not reference array args")
      }
      if(i < proc.post.args.length && proc.post.args[i].count>0) {
        throw new Error("cwise: post() block may not reference array args")
      }
    } else if(arg_type === "scalar") {
      proc.scalarArgs.push(i)
      proc.shimArgs.push("scalar" + i)
    } else if(arg_type === "index") {
      proc.indexArgs.push(i)
      if(i < proc.pre.args.length && proc.pre.args[i].count > 0) {
        throw new Error("cwise: pre() block may not reference array index")
      }
      if(i < proc.body.args.length && proc.body.args[i].lvalue) {
        throw new Error("cwise: body() block may not write to array index")
      }
      if(i < proc.post.args.length && proc.post.args[i].count > 0) {
        throw new Error("cwise: post() block may not reference array index")
      }
    } else if(arg_type === "shape") {
      proc.shapeArgs.push(i)
      if(i < proc.pre.args.length && proc.pre.args[i].lvalue) {
        throw new Error("cwise: pre() block may not write to array shape")
      }
      if(i < proc.body.args.length && proc.body.args[i].lvalue) {
        throw new Error("cwise: body() block may not write to array shape")
      }
      if(i < proc.post.args.length && proc.post.args[i].lvalue) {
        throw new Error("cwise: post() block may not write to array shape")
      }
    } else if(typeof arg_type === "object" && arg_type.offset) {
      proc.argTypes[i] = "offset"
      proc.offsetArgs.push({ array: arg_type.array, offset:arg_type.offset })
      proc.offsetArgIndex.push(i)
    } else {
      throw new Error("cwise: Unknown argument type " + proc_args[i])
    }
  }
  
  //Make sure at least one array argument was specified
  if(proc.arrayArgs.length <= 0) {
    throw new Error("cwise: No array arguments specified")
  }
  
  //Make sure arguments are correct
  if(proc.pre.args.length > proc_args.length) {
    throw new Error("cwise: Too many arguments in pre() block")
  }
  if(proc.body.args.length > proc_args.length) {
    throw new Error("cwise: Too many arguments in body() block")
  }
  if(proc.post.args.length > proc_args.length) {
    throw new Error("cwise: Too many arguments in post() block")
  }

  //Check debug flag
  proc.debug = !!user_args.printCode || !!user_args.debug
  
  //Retrieve name
  proc.funcName = user_args.funcName || "cwise"
  
  //Read in block size
  proc.blockSize = user_args.blockSize || 64

  return createThunk(proc)
}

module.exports = compileCwise

},{"./lib/thunk.js":"/projects/blackice/node_modules/gl-texture2d/node_modules/ndarray-ops/node_modules/cwise-compiler/lib/thunk.js"}],"/projects/blackice/node_modules/gl-texture2d/node_modules/ndarray-ops/node_modules/cwise-compiler/lib/compile.js":[function(require,module,exports){
"use strict"

var uniq = require("uniq")

function innerFill(order, proc, body) {
  var dimension = order.length
    , nargs = proc.arrayArgs.length
    , has_index = proc.indexArgs.length>0
    , code = []
    , vars = []
    , idx=0, pidx=0, i, j
  for(i=0; i<dimension; ++i) {
    vars.push(["i",i,"=0"].join(""))
  }
  //Compute scan deltas
  for(j=0; j<nargs; ++j) {
    for(i=0; i<dimension; ++i) {
      pidx = idx
      idx = order[i]
      if(i === 0) {
        vars.push(["d",j,"s",i,"=t",j,"p",idx].join(""))
      } else {
        vars.push(["d",j,"s",i,"=(t",j,"p",idx,"-s",pidx,"*t",j,"p",pidx,")"].join(""))
      }
    }
  }
  code.push("var " + vars.join(","))
  //Scan loop
  for(i=dimension-1; i>=0; --i) {
    idx = order[i]
    code.push(["for(i",i,"=0;i",i,"<s",idx,";++i",i,"){"].join(""))
  }
  //Push body of inner loop
  code.push(body)
  //Advance scan pointers
  for(i=0; i<dimension; ++i) {
    pidx = idx
    idx = order[i]
    for(j=0; j<nargs; ++j) {
      code.push(["p",j,"+=d",j,"s",i].join(""))
    }
    if(has_index) {
      if(i > 0) {
        code.push(["index[",pidx,"]-=s",pidx].join(""))
      }
      code.push(["++index[",idx,"]"].join(""))
    }
    code.push("}")
  }
  return code.join("\n")
}

function outerFill(matched, order, proc, body) {
  var dimension = order.length
    , nargs = proc.arrayArgs.length
    , blockSize = proc.blockSize
    , has_index = proc.indexArgs.length > 0
    , code = []
  for(var i=0; i<nargs; ++i) {
    code.push(["var offset",i,"=p",i].join(""))
  }
  //Generate matched loops
  for(var i=matched; i<dimension; ++i) {
    code.push(["for(var j"+i+"=SS[", order[i], "]|0;j", i, ">0;){"].join(""))
    code.push(["if(j",i,"<",blockSize,"){"].join(""))
    code.push(["s",order[i],"=j",i].join(""))
    code.push(["j",i,"=0"].join(""))
    code.push(["}else{s",order[i],"=",blockSize].join(""))
    code.push(["j",i,"-=",blockSize,"}"].join(""))
    if(has_index) {
      code.push(["index[",order[i],"]=j",i].join(""))
    }
  }
  for(var i=0; i<nargs; ++i) {
    var indexStr = ["offset"+i]
    for(var j=matched; j<dimension; ++j) {
      indexStr.push(["j",j,"*t",i,"p",order[j]].join(""))
    }
    code.push(["p",i,"=(",indexStr.join("+"),")"].join(""))
  }
  code.push(innerFill(order, proc, body))
  for(var i=matched; i<dimension; ++i) {
    code.push("}")
  }
  return code.join("\n")
}

//Count the number of compatible inner orders
function countMatches(orders) {
  var matched = 0, dimension = orders[0].length
  while(matched < dimension) {
    for(var j=1; j<orders.length; ++j) {
      if(orders[j][matched] !== orders[0][matched]) {
        return matched
      }
    }
    ++matched
  }
  return matched
}

//Processes a block according to the given data types
function processBlock(block, proc, dtypes) {
  var code = block.body
  var pre = []
  var post = []
  for(var i=0; i<block.args.length; ++i) {
    var carg = block.args[i]
    if(carg.count <= 0) {
      continue
    }
    var re = new RegExp(carg.name, "g")
    var ptrStr = ""
    var arrNum = proc.arrayArgs.indexOf(i)
    switch(proc.argTypes[i]) {
      case "offset":
        var offArgIndex = proc.offsetArgIndex.indexOf(i)
        var offArg = proc.offsetArgs[offArgIndex]
        arrNum = offArg.array
        ptrStr = "+q" + offArgIndex
      case "array":
        ptrStr = "p" + arrNum + ptrStr
        var localStr = "l" + i
        var arrStr = "a" + arrNum
        if(carg.count === 1) {
          if(dtypes[arrNum] === "generic") {
            if(carg.lvalue) {
              pre.push(["var ", localStr, "=", arrStr, ".get(", ptrStr, ")"].join(""))
              code = code.replace(re, localStr)
              post.push([arrStr, ".set(", ptrStr, ",", localStr,")"].join(""))
            } else {
              code = code.replace(re, [arrStr, ".get(", ptrStr, ")"].join(""))
            }
          } else {
            code = code.replace(re, [arrStr, "[", ptrStr, "]"].join(""))
          }
        } else if(dtypes[arrNum] === "generic") {
          pre.push(["var ", localStr, "=", arrStr, ".get(", ptrStr, ")"].join(""))
          code = code.replace(re, localStr)
          if(carg.lvalue) {
            post.push([arrStr, ".set(", ptrStr, ",", localStr,")"].join(""))
          }
        } else {
          pre.push(["var ", localStr, "=", arrStr, "[", ptrStr, "]"].join(""))
          code = code.replace(re, localStr)
          if(carg.lvalue) {
            post.push([arrStr, "[", ptrStr, "]=", localStr].join(""))
          }
        }
      break
      case "scalar":
        code = code.replace(re, "Y" + proc.scalarArgs.indexOf(i))
      break
      case "index":
        code = code.replace(re, "index")
      break
      case "shape":
        code = code.replace(re, "shape")
      break
    }
  }
  return [pre.join("\n"), code, post.join("\n")].join("\n").trim()
}

function typeSummary(dtypes) {
  var summary = new Array(dtypes.length)
  var allEqual = true
  for(var i=0; i<dtypes.length; ++i) {
    var t = dtypes[i]
    var digits = t.match(/\d+/)
    if(!digits) {
      digits = ""
    } else {
      digits = digits[0]
    }
    if(t.charAt(0) === 0) {
      summary[i] = "u" + t.charAt(1) + digits
    } else {
      summary[i] = t.charAt(0) + digits
    }
    if(i > 0) {
      allEqual = allEqual && summary[i] === summary[i-1]
    }
  }
  if(allEqual) {
    return summary[0]
  }
  return summary.join("")
}

//Generates a cwise operator
function generateCWiseOp(proc, typesig) {

  //Compute dimension
  var dimension = typesig[1].length|0
  var orders = new Array(proc.arrayArgs.length)
  var dtypes = new Array(proc.arrayArgs.length)

  //First create arguments for procedure
  var arglist = ["SS"]
  var code = ["'use strict'"]
  var vars = []
  
  for(var j=0; j<dimension; ++j) {
    vars.push(["s", j, "=SS[", j, "]"].join(""))
  }
  for(var i=0; i<proc.arrayArgs.length; ++i) {
    arglist.push("a"+i)
    arglist.push("t"+i)
    arglist.push("p"+i)
    dtypes[i] = typesig[2*i]
    orders[i] = typesig[2*i+1]
    
    for(var j=0; j<dimension; ++j) {
      vars.push(["t",i,"p",j,"=t",i,"[",j,"]"].join(""))
    }
  }
  for(var i=0; i<proc.scalarArgs.length; ++i) {
    arglist.push("Y" + i)
  }
  if(proc.shapeArgs.length > 0) {
    vars.push("shape=SS.slice(0)")
  }
  if(proc.indexArgs.length > 0) {
    var zeros = new Array(dimension)
    for(var i=0; i<dimension; ++i) {
      zeros[i] = "0"
    }
    vars.push(["index=[", zeros.join(","), "]"].join(""))
  }
  for(var i=0; i<proc.offsetArgs.length; ++i) {
    var off_arg = proc.offsetArgs[i]
    var init_string = []
    for(var j=0; j<off_arg.offset.length; ++j) {
      if(off_arg.offset[j] === 0) {
        continue
      } else if(off_arg.offset[j] === 1) {
        init_string.push(["t", off_arg.array, "p", j].join(""))      
      } else {
        init_string.push([off_arg.offset[j], "*t", off_arg.array, "p", j].join(""))
      }
    }
    if(init_string.length === 0) {
      vars.push("q" + i + "=0")
    } else {
      vars.push(["q", i, "=", init_string.join("+")].join(""))
    }
  }

  //Prepare this variables
  var thisVars = uniq([].concat(proc.pre.thisVars)
                      .concat(proc.body.thisVars)
                      .concat(proc.post.thisVars))
  vars = vars.concat(thisVars)
  code.push("var " + vars.join(","))
  for(var i=0; i<proc.arrayArgs.length; ++i) {
    code.push("p"+i+"|=0")
  }
  
  //Inline prelude
  if(proc.pre.body.length > 3) {
    code.push(processBlock(proc.pre, proc, dtypes))
  }

  //Process body
  var body = processBlock(proc.body, proc, dtypes)
  var matched = countMatches(orders)
  if(matched < dimension) {
    code.push(outerFill(matched, orders[0], proc, body))
  } else {
    code.push(innerFill(orders[0], proc, body))
  }

  //Inline epilog
  if(proc.post.body.length > 3) {
    code.push(processBlock(proc.post, proc, dtypes))
  }
  
  if(proc.debug) {
    console.log("Generated cwise routine for ", typesig, ":\n\n", code.join("\n"))
  }
  
  var loopName = [(proc.funcName||"unnamed"), "_cwise_loop_", orders[0].join("s"),"m",matched,typeSummary(dtypes)].join("")
  var f = new Function(["function ",loopName,"(", arglist.join(","),"){", code.join("\n"),"} return ", loopName].join(""))
  return f()
}
module.exports = generateCWiseOp
},{"uniq":"/projects/blackice/node_modules/gl-texture2d/node_modules/ndarray-ops/node_modules/cwise-compiler/node_modules/uniq/uniq.js"}],"/projects/blackice/node_modules/gl-texture2d/node_modules/ndarray-ops/node_modules/cwise-compiler/lib/thunk.js":[function(require,module,exports){
"use strict"

var compile = require("./compile.js")

function createThunk(proc) {
  var code = ["'use strict'", "var CACHED={}"]
  var vars = []
  var thunkName = proc.funcName + "_cwise_thunk"
  
  //Build thunk
  code.push(["return function ", thunkName, "(", proc.shimArgs.join(","), "){"].join(""))
  var typesig = []
  var string_typesig = []
  var proc_args = [["array",proc.arrayArgs[0],".shape"].join("")]
  for(var i=0; i<proc.arrayArgs.length; ++i) {
    var j = proc.arrayArgs[i]
    vars.push(["t", j, "=array", j, ".dtype,",
               "r", j, "=array", j, ".order"].join(""))
    typesig.push("t" + j)
    typesig.push("r" + j)
    string_typesig.push("t"+j)
    string_typesig.push("r"+j+".join()")
    proc_args.push("array" + j + ".data")
    proc_args.push("array" + j + ".stride")
    proc_args.push("array" + j + ".offset|0")
  }
  for(var i=0; i<proc.scalarArgs.length; ++i) {
    proc_args.push("scalar" + proc.scalarArgs[i])
  }
  vars.push(["type=[", string_typesig.join(","), "].join()"].join(""))
  vars.push("proc=CACHED[type]")
  code.push("var " + vars.join(","))
  
  code.push(["if(!proc){",
             "CACHED[type]=proc=compile([", typesig.join(","), "])}",
             "return proc(", proc_args.join(","), ")}"].join(""))

  if(proc.debug) {
    console.log("Generated thunk:", code.join("\n"))
  }
  
  //Compile thunk
  var thunk = new Function("compile", code.join("\n"))
  return thunk(compile.bind(undefined, proc))
}

module.exports = createThunk

},{"./compile.js":"/projects/blackice/node_modules/gl-texture2d/node_modules/ndarray-ops/node_modules/cwise-compiler/lib/compile.js"}],"/projects/blackice/node_modules/gl-texture2d/node_modules/ndarray-ops/node_modules/cwise-compiler/node_modules/uniq/uniq.js":[function(require,module,exports){
"use strict"

function unique_pred(list, compare) {
  var ptr = 1
    , len = list.length
    , a=list[0], b=list[0]
  for(var i=1; i<len; ++i) {
    b = a
    a = list[i]
    if(compare(a, b)) {
      if(i === ptr) {
        ptr++
        continue
      }
      list[ptr++] = a
    }
  }
  list.length = ptr
  return list
}

function unique_eq(list) {
  var ptr = 1
    , len = list.length
    , a=list[0], b = list[0]
  for(var i=1; i<len; ++i, b=a) {
    b = a
    a = list[i]
    if(a !== b) {
      if(i === ptr) {
        ptr++
        continue
      }
      list[ptr++] = a
    }
  }
  list.length = ptr
  return list
}

function unique(list, compare, sorted) {
  if(list.length === 0) {
    return list
  }
  if(compare) {
    if(!sorted) {
      list.sort(compare)
    }
    return unique_pred(list, compare)
  }
  if(!sorted) {
    list.sort()
  }
  return unique_eq(list)
}

module.exports = unique

},{}],"/projects/blackice/node_modules/gl-texture2d/node_modules/ndarray/ndarray.js":[function(require,module,exports){
(function (Buffer){
var iota = require("iota-array")

var arrayMethods = [
  "concat",
  "join",
  "slice",
  "toString",
  "indexOf",
  "lastIndexOf",
  "forEach",
  "every",
  "some",
  "filter",
  "map",
  "reduce",
  "reduceRight"
]

var hasTypedArrays  = ((typeof Float64Array) !== "undefined")
var hasBuffer       = ((typeof Buffer) !== "undefined")

function compare1st(a, b) {
  return a[0] - b[0]
}

function order() {
  var stride = this.stride
  var terms = new Array(stride.length)
  var i
  for(i=0; i<terms.length; ++i) {
    terms[i] = [Math.abs(stride[i]), i]
  }
  terms.sort(compare1st)
  var result = new Array(terms.length)
  for(i=0; i<result.length; ++i) {
    result[i] = terms[i][1]
  }
  return result
}

function compileConstructor(dtype, dimension) {
  var className = ["View", dimension, "d", dtype].join("")
  if(dimension < 0) {
    className = "View_Nil" + dtype
  }
  var useGetters = (dtype === "generic")
  
  if(dimension === -1) {
    //Special case for trivial arrays
    var code = 
      "function "+className+"(a){this.data=a;};\
var proto="+className+".prototype;\
proto.dtype='"+dtype+"';\
proto.index=function(){return -1};\
proto.size=0;\
proto.dimension=-1;\
proto.shape=proto.stride=proto.order=[];\
proto.lo=proto.hi=proto.transpose=proto.step=\
function(){return new "+className+"(this.data);};\
proto.get=proto.set=function(){};\
proto.pick=function(){return null};\
return function construct_"+className+"(a){return new "+className+"(a);}"
    var procedure = new Function(code)
    return procedure()
  } else if(dimension === 0) {
    //Special case for 0d arrays
    var code =
      "function "+className+"(a,d) {\
this.data = a;\
this.offset = d\
};\
var proto="+className+".prototype;\
proto.dtype='"+dtype+"';\
proto.index=function(){return this.offset};\
proto.dimension=0;\
proto.size=1;\
proto.shape=\
proto.stride=\
proto.order=[];\
proto.lo=\
proto.hi=\
proto.transpose=\
proto.step=function "+className+"_copy() {\
return new "+className+"(this.data,this.offset)\
};\
proto.pick=function "+className+"_pick(){\
return TrivialArray(this.data);\
};\
proto.valueOf=proto.get=function "+className+"_get(){\
return "+(useGetters ? "this.data.get(this.offset)" : "this.data[this.offset]")+
"};\
proto.set=function "+className+"_set(v){\
return "+(useGetters ? "this.data.set(this.offset,v)" : "this.data[this.offset]=v")+"\
};\
return function construct_"+className+"(a,b,c,d){return new "+className+"(a,d)}"
    var procedure = new Function("TrivialArray", code)
    return procedure(CACHED_CONSTRUCTORS[dtype][0])
  }

  var code = ["'use strict'"]
    
  //Create constructor for view
  var indices = iota(dimension)
  var args = indices.map(function(i) { return "i"+i })
  var index_str = "this.offset+" + indices.map(function(i) {
        return "this._stride" + i + "*i" + i
      }).join("+")
  code.push("function "+className+"(a,"+
    indices.map(function(i) {
      return "b"+i
    }).join(",") + "," +
    indices.map(function(i) {
      return "c"+i
    }).join(",") + ",d){this.data=a")
  for(var i=0; i<dimension; ++i) {
    code.push("this._shape"+i+"=b"+i+"|0")
  }
  for(var i=0; i<dimension; ++i) {
    code.push("this._stride"+i+"=c"+i+"|0")
  }
  code.push("this.offset=d|0}",
    "var proto="+className+".prototype",
    "proto.dtype='"+dtype+"'",
    "proto.dimension="+dimension)
  
  //view.stride and view.shape
  var strideClassName = "VStride" + dimension + "d" + dtype
  var shapeClassName = "VShape" + dimension + "d" + dtype
  var props = {"stride":strideClassName, "shape":shapeClassName}
  for(var prop in props) {
    var arrayName = props[prop]
    code.push(
      "function " + arrayName + "(v) {this._v=v} var aproto=" + arrayName + ".prototype",
      "aproto.length="+dimension)
    
    var array_elements = []
    for(var i=0; i<dimension; ++i) {
      array_elements.push(["this._v._", prop, i].join(""))
    }
    code.push(
      "aproto.toJSON=function " + arrayName + "_toJSON(){return [" + array_elements.join(",") + "]}",
      "aproto.valueOf=aproto.toString=function " + arrayName + "_toString(){return [" + array_elements.join(",") + "].join()}")
    
    for(var i=0; i<dimension; ++i) {
      code.push("Object.defineProperty(aproto,"+i+",{get:function(){return this._v._"+prop+i+"},set:function(v){return this._v._"+prop+i+"=v|0},enumerable:true})")
    }
    for(var i=0; i<arrayMethods.length; ++i) {
      if(arrayMethods[i] in Array.prototype) {
        code.push("aproto."+arrayMethods[i]+"=Array.prototype."+arrayMethods[i])
      }
    }
    code.push(["Object.defineProperty(proto,'",prop,"',{get:function ", arrayName, "_get(){return new ", arrayName, "(this)},set: function ", arrayName, "_set(v){"].join(""))
    for(var i=0; i<dimension; ++i) {
      code.push("this._"+prop+i+"=v["+i+"]|0")
    }
    code.push("return v}})")
  }
  
  //view.size:
  code.push("Object.defineProperty(proto,'size',{get:function "+className+"_size(){\
return "+indices.map(function(i) { return "this._shape"+i }).join("*"),
"}})")

  //view.order:
  if(dimension === 1) {
    code.push("proto.order=[0]")
  } else {
    code.push("Object.defineProperty(proto,'order',{get:")
    if(dimension < 4) {
      code.push("function "+className+"_order(){")
      if(dimension === 2) {
        code.push("return (Math.abs(this._stride0)>Math.abs(this._stride1))?[1,0]:[0,1]}})")
      } else if(dimension === 3) {
        code.push(
"var s0=Math.abs(this._stride0),s1=Math.abs(this._stride1),s2=Math.abs(this._stride2);\
if(s0>s1){\
if(s1>s2){\
return [2,1,0];\
}else if(s0>s2){\
return [1,2,0];\
}else{\
return [1,0,2];\
}\
}else if(s0>s2){\
return [2,0,1];\
}else if(s2>s1){\
return [0,1,2];\
}else{\
return [0,2,1];\
}}})")
      }
    } else {
      code.push("ORDER})")
    }
  }
  
  //view.set(i0, ..., v):
  code.push(
"proto.set=function "+className+"_set("+args.join(",")+",v){")
  if(useGetters) {
    code.push("return this.data.set("+index_str+",v)}")
  } else {
    code.push("return this.data["+index_str+"]=v}")
  }
  
  //view.get(i0, ...):
  code.push("proto.get=function "+className+"_get("+args.join(",")+"){")
  if(useGetters) {
    code.push("return this.data.get("+index_str+")}")
  } else {
    code.push("return this.data["+index_str+"]}")
  }
  
  //view.index:
  code.push(
    "proto.index=function "+className+"_index(", args.join(), "){return "+index_str+"}")

  //view.hi():
  code.push("proto.hi=function "+className+"_hi("+args.join(",")+"){return new "+className+"(this.data,"+
    indices.map(function(i) {
      return ["(typeof i",i,"!=='number'||i",i,"<0)?this._shape", i, ":i", i,"|0"].join("")
    }).join(",")+","+
    indices.map(function(i) {
      return "this._stride"+i
    }).join(",")+",this.offset)}")
  
  //view.lo():
  var a_vars = indices.map(function(i) { return "a"+i+"=this._shape"+i })
  var c_vars = indices.map(function(i) { return "c"+i+"=this._stride"+i })
  code.push("proto.lo=function "+className+"_lo("+args.join(",")+"){var b=this.offset,d=0,"+a_vars.join(",")+","+c_vars.join(","))
  for(var i=0; i<dimension; ++i) {
    code.push(
"if(typeof i"+i+"==='number'&&i"+i+">=0){\
d=i"+i+"|0;\
b+=c"+i+"*d;\
a"+i+"-=d}")
  }
  code.push("return new "+className+"(this.data,"+
    indices.map(function(i) {
      return "a"+i
    }).join(",")+","+
    indices.map(function(i) {
      return "c"+i
    }).join(",")+",b)}")
  
  //view.step():
  code.push("proto.step=function "+className+"_step("+args.join(",")+"){var "+
    indices.map(function(i) {
      return "a"+i+"=this._shape"+i
    }).join(",")+","+
    indices.map(function(i) {
      return "b"+i+"=this._stride"+i
    }).join(",")+",c=this.offset,d=0,ceil=Math.ceil")
  for(var i=0; i<dimension; ++i) {
    code.push(
"if(typeof i"+i+"==='number'){\
d=i"+i+"|0;\
if(d<0){\
c+=b"+i+"*(a"+i+"-1);\
a"+i+"=ceil(-a"+i+"/d)\
}else{\
a"+i+"=ceil(a"+i+"/d)\
}\
b"+i+"*=d\
}")
  }
  code.push("return new "+className+"(this.data,"+
    indices.map(function(i) {
      return "a" + i
    }).join(",")+","+
    indices.map(function(i) {
      return "b" + i
    }).join(",")+",c)}")
  
  //view.transpose():
  var tShape = new Array(dimension)
  var tStride = new Array(dimension)
  for(var i=0; i<dimension; ++i) {
    tShape[i] = "a[i"+i+"]"
    tStride[i] = "b[i"+i+"]"
  }
  code.push("proto.transpose=function "+className+"_transpose("+args+"){"+
    args.map(function(n,idx) { return n + "=(" + n + "===undefined?" + idx + ":" + n + "|0)"}).join(";"),
    "var a=this.shape,b=this.stride;return new "+className+"(this.data,"+tShape.join(",")+","+tStride.join(",")+",this.offset)}")
  
  //view.pick():
  code.push("proto.pick=function "+className+"_pick("+args+"){var a=[],b=[],c=this.offset")
  for(var i=0; i<dimension; ++i) {
    code.push("if(typeof i"+i+"==='number'&&i"+i+">=0){c=(c+this._stride"+i+"*i"+i+")|0}else{a.push(this._shape"+i+");b.push(this._stride"+i+")}")
  }
  code.push("var ctor=CTOR_LIST[a.length+1];return ctor(this.data,a,b,c)}")
    
  //Add return statement
  code.push("return function construct_"+className+"(data,shape,stride,offset){return new "+className+"(data,"+
    indices.map(function(i) {
      return "shape["+i+"]"
    }).join(",")+","+
    indices.map(function(i) {
      return "stride["+i+"]"
    }).join(",")+",offset)}")

  //Compile procedure
  var procedure = new Function("CTOR_LIST", "ORDER", code.join("\n"))
  return procedure(CACHED_CONSTRUCTORS[dtype], order)
}

function arrayDType(data) {
  if(hasBuffer) {
    if(Buffer.isBuffer(data)) {
      return "buffer"
    }
  }
  if(hasTypedArrays) {
    switch(Object.prototype.toString.call(data)) {
      case "[object Float64Array]":
        return "float64"
      case "[object Float32Array]":
        return "float32"
      case "[object Int8Array]":
        return "int8"
      case "[object Int16Array]":
        return "int16"
      case "[object Int32Array]":
        return "int32"
      case "[object Uint8Array]":
        return "uint8"
      case "[object Uint16Array]":
        return "uint16"
      case "[object Uint32Array]":
        return "uint32"
      case "[object Uint8ClampedArray]":
        return "uint8_clamped"
    }
  }
  if(Array.isArray(data)) {
    return "array"
  }
  return "generic"
}

var CACHED_CONSTRUCTORS = {
  "float32":[],
  "float64":[],
  "int8":[],
  "int16":[],
  "int32":[],
  "uint8":[],
  "uint16":[],
  "uint32":[],
  "array":[],
  "uint8_clamped":[],
  "buffer":[],
  "generic":[]
}

;(function() {
  for(var id in CACHED_CONSTRUCTORS) {
    CACHED_CONSTRUCTORS[id].push(compileConstructor(id, -1))
  }
});

function wrappedNDArrayCtor(data, shape, stride, offset) {
  if(data === undefined) {
    var ctor = CACHED_CONSTRUCTORS.array[0]
    return ctor([])
  } else if(typeof data === "number") {
    data = [data]
  }
  if(shape === undefined) {
    shape = [ data.length ]
  }
  var d = shape.length
  if(stride === undefined) {
    stride = new Array(d)
    for(var i=d-1, sz=1; i>=0; --i) {
      stride[i] = sz
      sz *= shape[i]
    }
  }
  if(offset === undefined) {
    offset = 0
    for(var i=0; i<d; ++i) {
      if(stride[i] < 0) {
        offset -= (shape[i]-1)*stride[i]
      }
    }
  }
  var dtype = arrayDType(data)
  var ctor_list = CACHED_CONSTRUCTORS[dtype]
  while(ctor_list.length <= d+1) {
    ctor_list.push(compileConstructor(dtype, ctor_list.length-1))
  }
  var ctor = ctor_list[d+1]
  return ctor(data, shape, stride, offset)
}

module.exports = wrappedNDArrayCtor
}).call(this,require("buffer").Buffer)
},{"buffer":"/projects/blackice/node_modules/browserify/node_modules/buffer/index.js","iota-array":"/projects/blackice/node_modules/gl-texture2d/node_modules/ndarray/node_modules/iota-array/iota.js"}],"/projects/blackice/node_modules/gl-texture2d/node_modules/ndarray/node_modules/iota-array/iota.js":[function(require,module,exports){
"use strict"

function iota(n) {
  var result = new Array(n)
  for(var i=0; i<n; ++i) {
    result[i] = i
  }
  return result
}

module.exports = iota
},{}],"/projects/blackice/node_modules/gl-texture2d/node_modules/typedarray-pool/node_modules/bit-twiddle/twiddle.js":[function(require,module,exports){
/**
 * Bit twiddling hacks for JavaScript.
 *
 * Author: Mikola Lysenko
 *
 * Ported from Stanford bit twiddling hack library:
 *    http://graphics.stanford.edu/~seander/bithacks.html
 */

"use strict"; "use restrict";

//Number of bits in an integer
var INT_BITS = 32;

//Constants
exports.INT_BITS  = INT_BITS;
exports.INT_MAX   =  0x7fffffff;
exports.INT_MIN   = -1<<(INT_BITS-1);

//Returns -1, 0, +1 depending on sign of x
exports.sign = function(v) {
  return (v > 0) - (v < 0);
}

//Computes absolute value of integer
exports.abs = function(v) {
  var mask = v >> (INT_BITS-1);
  return (v ^ mask) - mask;
}

//Computes minimum of integers x and y
exports.min = function(x, y) {
  return y ^ ((x ^ y) & -(x < y));
}

//Computes maximum of integers x and y
exports.max = function(x, y) {
  return x ^ ((x ^ y) & -(x < y));
}

//Checks if a number is a power of two
exports.isPow2 = function(v) {
  return !(v & (v-1)) && (!!v);
}

//Computes log base 2 of v
exports.log2 = function(v) {
  var r, shift;
  r =     (v > 0xFFFF) << 4; v >>>= r;
  shift = (v > 0xFF  ) << 3; v >>>= shift; r |= shift;
  shift = (v > 0xF   ) << 2; v >>>= shift; r |= shift;
  shift = (v > 0x3   ) << 1; v >>>= shift; r |= shift;
  return r | (v >> 1);
}

//Computes log base 10 of v
exports.log10 = function(v) {
  return  (v >= 1000000000) ? 9 : (v >= 100000000) ? 8 : (v >= 10000000) ? 7 :
          (v >= 1000000) ? 6 : (v >= 100000) ? 5 : (v >= 10000) ? 4 :
          (v >= 1000) ? 3 : (v >= 100) ? 2 : (v >= 10) ? 1 : 0;
}

//Counts number of bits
exports.popCount = function(v) {
  v = v - ((v >>> 1) & 0x55555555);
  v = (v & 0x33333333) + ((v >>> 2) & 0x33333333);
  return ((v + (v >>> 4) & 0xF0F0F0F) * 0x1010101) >>> 24;
}

//Counts number of trailing zeros
function countTrailingZeros(v) {
  var c = 32;
  v &= -v;
  if (v) c--;
  if (v & 0x0000FFFF) c -= 16;
  if (v & 0x00FF00FF) c -= 8;
  if (v & 0x0F0F0F0F) c -= 4;
  if (v & 0x33333333) c -= 2;
  if (v & 0x55555555) c -= 1;
  return c;
}
exports.countTrailingZeros = countTrailingZeros;

//Rounds to next power of 2
exports.nextPow2 = function(v) {
  v += v === 0;
  --v;
  v |= v >>> 1;
  v |= v >>> 2;
  v |= v >>> 4;
  v |= v >>> 8;
  v |= v >>> 16;
  return v + 1;
}

//Rounds down to previous power of 2
exports.prevPow2 = function(v) {
  v |= v >>> 1;
  v |= v >>> 2;
  v |= v >>> 4;
  v |= v >>> 8;
  v |= v >>> 16;
  return v - (v>>>1);
}

//Computes parity of word
exports.parity = function(v) {
  v ^= v >>> 16;
  v ^= v >>> 8;
  v ^= v >>> 4;
  v &= 0xf;
  return (0x6996 >>> v) & 1;
}

var REVERSE_TABLE = new Array(256);

(function(tab) {
  for(var i=0; i<256; ++i) {
    var v = i, r = i, s = 7;
    for (v >>>= 1; v; v >>>= 1) {
      r <<= 1;
      r |= v & 1;
      --s;
    }
    tab[i] = (r << s) & 0xff;
  }
})(REVERSE_TABLE);

//Reverse bits in a 32 bit word
exports.reverse = function(v) {
  return  (REVERSE_TABLE[ v         & 0xff] << 24) |
          (REVERSE_TABLE[(v >>> 8)  & 0xff] << 16) |
          (REVERSE_TABLE[(v >>> 16) & 0xff] << 8)  |
           REVERSE_TABLE[(v >>> 24) & 0xff];
}

//Interleave bits of 2 coordinates with 16 bits.  Useful for fast quadtree codes
exports.interleave2 = function(x, y) {
  x &= 0xFFFF;
  x = (x | (x << 8)) & 0x00FF00FF;
  x = (x | (x << 4)) & 0x0F0F0F0F;
  x = (x | (x << 2)) & 0x33333333;
  x = (x | (x << 1)) & 0x55555555;

  y &= 0xFFFF;
  y = (y | (y << 8)) & 0x00FF00FF;
  y = (y | (y << 4)) & 0x0F0F0F0F;
  y = (y | (y << 2)) & 0x33333333;
  y = (y | (y << 1)) & 0x55555555;

  return x | (y << 1);
}

//Extracts the nth interleaved component
exports.deinterleave2 = function(v, n) {
  v = (v >>> n) & 0x55555555;
  v = (v | (v >>> 1))  & 0x33333333;
  v = (v | (v >>> 2))  & 0x0F0F0F0F;
  v = (v | (v >>> 4))  & 0x00FF00FF;
  v = (v | (v >>> 16)) & 0x000FFFF;
  return (v << 16) >> 16;
}


//Interleave bits of 3 coordinates, each with 10 bits.  Useful for fast octree codes
exports.interleave3 = function(x, y, z) {
  x &= 0x3FF;
  x  = (x | (x<<16)) & 4278190335;
  x  = (x | (x<<8))  & 251719695;
  x  = (x | (x<<4))  & 3272356035;
  x  = (x | (x<<2))  & 1227133513;

  y &= 0x3FF;
  y  = (y | (y<<16)) & 4278190335;
  y  = (y | (y<<8))  & 251719695;
  y  = (y | (y<<4))  & 3272356035;
  y  = (y | (y<<2))  & 1227133513;
  x |= (y << 1);
  
  z &= 0x3FF;
  z  = (z | (z<<16)) & 4278190335;
  z  = (z | (z<<8))  & 251719695;
  z  = (z | (z<<4))  & 3272356035;
  z  = (z | (z<<2))  & 1227133513;
  
  return x | (z << 2);
}

//Extracts nth interleaved component of a 3-tuple
exports.deinterleave3 = function(v, n) {
  v = (v >>> n)       & 1227133513;
  v = (v | (v>>>2))   & 3272356035;
  v = (v | (v>>>4))   & 251719695;
  v = (v | (v>>>8))   & 4278190335;
  v = (v | (v>>>16))  & 0x3FF;
  return (v<<22)>>22;
}

//Computes next combination in colexicographic order (this is mistakenly called nextPermutation on the bit twiddling hacks page)
exports.nextCombination = function(v) {
  var t = v | (v - 1);
  return (t + 1) | (((~t & -~t) - 1) >>> (countTrailingZeros(v) + 1));
}


},{}],"/projects/blackice/node_modules/gl-texture2d/node_modules/typedarray-pool/node_modules/dup/dup.js":[function(require,module,exports){
"use strict"

function dupe_array(count, value, i) {
  var c = count[i]|0
  if(c <= 0) {
    return []
  }
  var result = new Array(c), j
  if(i === count.length-1) {
    for(j=0; j<c; ++j) {
      result[j] = value
    }
  } else {
    for(j=0; j<c; ++j) {
      result[j] = dupe_array(count, value, i+1)
    }
  }
  return result
}

function dupe_number(count, value) {
  var result, i
  result = new Array(count)
  for(i=0; i<count; ++i) {
    result[i] = value
  }
  return result
}

function dupe(count, value) {
  if(typeof value === "undefined") {
    value = 0
  }
  switch(typeof count) {
    case "number":
      if(count > 0) {
        return dupe_number(count|0, value)
      }
    break
    case "object":
      if(typeof (count.length) === "number") {
        return dupe_array(count, value, 0)
      }
    break
  }
  return []
}

module.exports = dupe
},{}],"/projects/blackice/node_modules/gl-texture2d/node_modules/typedarray-pool/pool.js":[function(require,module,exports){
(function (global,Buffer){
'use strict'

var bits = require('bit-twiddle')
var dup = require('dup')

//Legacy pool support
if(!global.__TYPEDARRAY_POOL) {
  global.__TYPEDARRAY_POOL = {
      UINT8   : dup([32, 0])
    , UINT16  : dup([32, 0])
    , UINT32  : dup([32, 0])
    , INT8    : dup([32, 0])
    , INT16   : dup([32, 0])
    , INT32   : dup([32, 0])
    , FLOAT   : dup([32, 0])
    , DOUBLE  : dup([32, 0])
    , DATA    : dup([32, 0])
    , UINT8C  : dup([32, 0])
    , BUFFER  : dup([32, 0])
  }
}

var hasUint8C = (typeof Uint8ClampedArray) !== 'undefined'
var POOL = global.__TYPEDARRAY_POOL

//Upgrade pool
if(!POOL.UINT8C) {
  POOL.UINT8C = dup([32, 0])
}
if(!POOL.BUFFER) {
  POOL.BUFFER = dup([32, 0])
}

//New technique: Only allocate from ArrayBufferView and Buffer
var DATA    = POOL.DATA
  , BUFFER  = POOL.BUFFER

exports.free = function free(array) {
  if(Buffer.isBuffer(array)) {
    BUFFER[bits.log2(array.length)].push(array)
  } else {
    if(Object.prototype.toString.call(array) !== '[object ArrayBuffer]') {
      array = array.buffer
    }
    if(!array) {
      return
    }
    var n = array.length || array.byteLength
    var log_n = bits.log2(n)|0
    DATA[log_n].push(array)
  }
}

function freeArrayBuffer(buffer) {
  if(!buffer) {
    return
  }
  var n = buffer.length || buffer.byteLength
  var log_n = bits.log2(n)
  DATA[log_n].push(buffer)
}

function freeTypedArray(array) {
  freeArrayBuffer(array.buffer)
}

exports.freeUint8 =
exports.freeUint16 =
exports.freeUint32 =
exports.freeInt8 =
exports.freeInt16 =
exports.freeInt32 =
exports.freeFloat32 = 
exports.freeFloat =
exports.freeFloat64 = 
exports.freeDouble = 
exports.freeUint8Clamped = 
exports.freeDataView = freeTypedArray

exports.freeArrayBuffer = freeArrayBuffer

exports.freeBuffer = function freeBuffer(array) {
  BUFFER[bits.log2(array.length)].push(array)
}

exports.malloc = function malloc(n, dtype) {
  if(dtype === undefined || dtype === 'arraybuffer') {
    return mallocArrayBuffer(n)
  } else {
    switch(dtype) {
      case 'uint8':
        return mallocUint8(n)
      case 'uint16':
        return mallocUint16(n)
      case 'uint32':
        return mallocUint32(n)
      case 'int8':
        return mallocInt8(n)
      case 'int16':
        return mallocInt16(n)
      case 'int32':
        return mallocInt32(n)
      case 'float':
      case 'float32':
        return mallocFloat(n)
      case 'double':
      case 'float64':
        return mallocDouble(n)
      case 'uint8_clamped':
        return mallocUint8Clamped(n)
      case 'buffer':
        return mallocBuffer(n)
      case 'data':
      case 'dataview':
        return mallocDataView(n)

      default:
        return null
    }
  }
  return null
}

function mallocArrayBuffer(n) {
  var n = bits.nextPow2(n)
  var log_n = bits.log2(n)
  var d = DATA[log_n]
  if(d.length > 0) {
    return d.pop()
  }
  return new ArrayBuffer(n)
}
exports.mallocArrayBuffer = mallocArrayBuffer

function mallocUint8(n) {
  return new Uint8Array(mallocArrayBuffer(n), 0, n)
}
exports.mallocUint8 = mallocUint8

function mallocUint16(n) {
  return new Uint16Array(mallocArrayBuffer(2*n), 0, n)
}
exports.mallocUint16 = mallocUint16

function mallocUint32(n) {
  return new Uint32Array(mallocArrayBuffer(4*n), 0, n)
}
exports.mallocUint32 = mallocUint32

function mallocInt8(n) {
  return new Int8Array(mallocArrayBuffer(n), 0, n)
}
exports.mallocInt8 = mallocInt8

function mallocInt16(n) {
  return new Int16Array(mallocArrayBuffer(2*n), 0, n)
}
exports.mallocInt16 = mallocInt16

function mallocInt32(n) {
  return new Int32Array(mallocArrayBuffer(4*n), 0, n)
}
exports.mallocInt32 = mallocInt32

function mallocFloat(n) {
  return new Float32Array(mallocArrayBuffer(4*n), 0, n)
}
exports.mallocFloat32 = exports.mallocFloat = mallocFloat

function mallocDouble(n) {
  return new Float64Array(mallocArrayBuffer(8*n), 0, n)
}
exports.mallocFloat64 = exports.mallocDouble = mallocDouble

function mallocUint8Clamped(n) {
  if(hasUint8C) {
    return new Uint8ClampedArray(mallocArrayBuffer(n), 0, n)
  } else {
    return mallocUint8(n)
  }
}
exports.mallocUint8Clamped = mallocUint8Clamped

function mallocDataView(n) {
  return new DataView(mallocArrayBuffer(n), 0, n)
}
exports.mallocDataView = mallocDataView

function mallocBuffer(n) {
  n = bits.nextPow2(n)
  var log_n = bits.log2(n)
  var cache = BUFFER[log_n]
  if(cache.length > 0) {
    return cache.pop()
  }
  return new Buffer(n)
}
exports.mallocBuffer = mallocBuffer

exports.clearCache = function clearCache() {
  for(var i=0; i<32; ++i) {
    POOL.UINT8[i].length = 0
    POOL.UINT16[i].length = 0
    POOL.UINT32[i].length = 0
    POOL.INT8[i].length = 0
    POOL.INT16[i].length = 0
    POOL.INT32[i].length = 0
    POOL.FLOAT[i].length = 0
    POOL.DOUBLE[i].length = 0
    POOL.UINT8C[i].length = 0
    DATA[i].length = 0
    BUFFER[i].length = 0
  }
}
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer)
},{"bit-twiddle":"/projects/blackice/node_modules/gl-texture2d/node_modules/typedarray-pool/node_modules/bit-twiddle/twiddle.js","buffer":"/projects/blackice/node_modules/browserify/node_modules/buffer/index.js","dup":"/projects/blackice/node_modules/gl-texture2d/node_modules/typedarray-pool/node_modules/dup/dup.js"}],"/projects/blackice/node_modules/gl-texture2d/node_modules/webglew/node_modules/weakmap/weakmap.js":[function(require,module,exports){
/* (The MIT License)
 *
 * Copyright (c) 2012 Brandon Benvie <http://bbenvie.com>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
 * associated documentation files (the 'Software'), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge, publish, distribute,
 * sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included with all copies or
 * substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
 * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY  CLAIM,
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

// Original WeakMap implementation by Gozala @ https://gist.github.com/1269991
// Updated and bugfixed by Raynos @ https://gist.github.com/1638059
// Expanded by Benvie @ https://github.com/Benvie/harmony-collections

void function(global, undefined_, undefined){
  var getProps = Object.getOwnPropertyNames,
      defProp  = Object.defineProperty,
      toSource = Function.prototype.toString,
      create   = Object.create,
      hasOwn   = Object.prototype.hasOwnProperty,
      funcName = /^\n?function\s?(\w*)?_?\(/;


  function define(object, key, value){
    if (typeof key === 'function') {
      value = key;
      key = nameOf(value).replace(/_$/, '');
    }
    return defProp(object, key, { configurable: true, writable: true, value: value });
  }

  function nameOf(func){
    return typeof func !== 'function'
          ? '' : 'name' in func
          ? func.name : toSource.call(func).match(funcName)[1];
  }

  // ############
  // ### Data ###
  // ############

  var Data = (function(){
    var dataDesc = { value: { writable: true, value: undefined } },
        datalock = 'return function(k){if(k===s)return l}',
        uids     = create(null),

        createUID = function(){
          var key = Math.random().toString(36).slice(2);
          return key in uids ? createUID() : uids[key] = key;
        },

        globalID = createUID(),

        storage = function(obj){
          if (hasOwn.call(obj, globalID))
            return obj[globalID];

          if (!Object.isExtensible(obj))
            throw new TypeError("Object must be extensible");

          var store = create(null);
          defProp(obj, globalID, { value: store });
          return store;
        };

    // common per-object storage area made visible by patching getOwnPropertyNames'
    define(Object, function getOwnPropertyNames(obj){
      var props = getProps(obj);
      if (hasOwn.call(obj, globalID))
        props.splice(props.indexOf(globalID), 1);
      return props;
    });

    function Data(){
      var puid = createUID(),
          secret = {};

      this.unlock = function(obj){
        var store = storage(obj);
        if (hasOwn.call(store, puid))
          return store[puid](secret);

        var data = create(null, dataDesc);
        defProp(store, puid, {
          value: new Function('s', 'l', datalock)(secret, data)
        });
        return data;
      }
    }

    define(Data.prototype, function get(o){ return this.unlock(o).value });
    define(Data.prototype, function set(o, v){ this.unlock(o).value = v });

    return Data;
  }());


  var WM = (function(data){
    var validate = function(key){
      if (key == null || typeof key !== 'object' && typeof key !== 'function')
        throw new TypeError("Invalid WeakMap key");
    }

    var wrap = function(collection, value){
      var store = data.unlock(collection);
      if (store.value)
        throw new TypeError("Object is already a WeakMap");
      store.value = value;
    }

    var unwrap = function(collection){
      var storage = data.unlock(collection).value;
      if (!storage)
        throw new TypeError("WeakMap is not generic");
      return storage;
    }

    var initialize = function(weakmap, iterable){
      if (iterable !== null && typeof iterable === 'object' && typeof iterable.forEach === 'function') {
        iterable.forEach(function(item, i){
          if (item instanceof Array && item.length === 2)
            set.call(weakmap, iterable[i][0], iterable[i][1]);
        });
      }
    }


    function WeakMap(iterable){
      if (this === global || this == null || this === WeakMap.prototype)
        return new WeakMap(iterable);

      wrap(this, new Data);
      initialize(this, iterable);
    }

    function get(key){
      validate(key);
      var value = unwrap(this).get(key);
      return value === undefined_ ? undefined : value;
    }

    function set(key, value){
      validate(key);
      // store a token for explicit undefined so that "has" works correctly
      unwrap(this).set(key, value === undefined ? undefined_ : value);
    }

    function has(key){
      validate(key);
      return unwrap(this).get(key) !== undefined;
    }

    function delete_(key){
      validate(key);
      var data = unwrap(this),
          had = data.get(key) !== undefined;
      data.set(key, undefined);
      return had;
    }

    function toString(){
      unwrap(this);
      return '[object WeakMap]';
    }

    try {
      var src = ('return '+delete_).replace('e_', '\\u0065'),
          del = new Function('unwrap', 'validate', src)(unwrap, validate);
    } catch (e) {
      var del = delete_;
    }

    var src = (''+Object).split('Object');
    var stringifier = function toString(){
      return src[0] + nameOf(this) + src[1];
    };

    define(stringifier, stringifier);

    var prep = { __proto__: [] } instanceof Array
      ? function(f){ f.__proto__ = stringifier }
      : function(f){ define(f, stringifier) };

    prep(WeakMap);

    [toString, get, set, has, del].forEach(function(method){
      define(WeakMap.prototype, method);
      prep(method);
    });

    return WeakMap;
  }(new Data));

  var defaultCreator = Object.create
    ? function(){ return Object.create(null) }
    : function(){ return {} };

  function createStorage(creator){
    var weakmap = new WM;
    creator || (creator = defaultCreator);

    function storage(object, value){
      if (value || arguments.length === 2) {
        weakmap.set(object, value);
      } else {
        value = weakmap.get(object);
        if (value === undefined) {
          value = creator(object);
          weakmap.set(object, value);
        }
      }
      return value;
    }

    return storage;
  }


  if (typeof module !== 'undefined') {
    module.exports = WM;
  } else if (typeof exports !== 'undefined') {
    exports.WeakMap = WM;
  } else if (!('WeakMap' in global)) {
    global.WeakMap = WM;
  }

  WM.createStorage = createStorage;
  if (global.WeakMap)
    global.WeakMap.createStorage = createStorage;
}((0, eval)('this'));

},{}],"/projects/blackice/node_modules/gl-texture2d/node_modules/webglew/webglew.js":[function(require,module,exports){
'use strict'

var weakMap = typeof WeakMap === 'undefined' ? require('weakmap') : WeakMap

var WebGLEWStruct = new weakMap()

function baseName(ext_name) {
  return ext_name.replace(/^[A-Z]+_/, '')
}

function initWebGLEW(gl) {
  var struct = WebGLEWStruct.get(gl)
  if(struct) {
    return struct
  }
  var extensions = {}
  var supported = gl.getSupportedExtensions()
  for(var i=0; i<supported.length; ++i) {
    var extName = supported[i]

    //Skip MOZ_ extensions
    if(extName.indexOf('MOZ_') === 0) {
      continue
    }
    var ext = gl.getExtension(supported[i])
    if(!ext) {
      continue
    }
    while(true) {
      extensions[extName] = ext
      var base = baseName(extName)
      if(base === extName) {
        break
      }
      extName = base
    }
  }
  WebGLEWStruct.set(gl, extensions)
  return extensions
}
module.exports = initWebGLEW
},{"weakmap":"/projects/blackice/node_modules/gl-texture2d/node_modules/webglew/node_modules/weakmap/weakmap.js"}],"/projects/blackice/node_modules/gl-texture2d/texture.js":[function(require,module,exports){
'use strict'

var ndarray = require('ndarray')
var ops     = require('ndarray-ops')
var pool    = require('typedarray-pool')
var webglew = require('webglew')

module.exports = createTexture2D

var linearTypes = null
var filterTypes = null
var wrapTypes   = null

function lazyInitLinearTypes(gl) {
  linearTypes = [
    gl.LINEAR,
    gl.NEAREST_MIPMAP_LINEAR,
    gl.LINEAR_MIPMAP_NEAREST,
    gl.LINEAR_MIPMAP_NEAREST
  ]
  filterTypes = [
    gl.NEAREST,
    gl.LINEAR,
    gl.NEAREST_MIPMAP_NEAREST,
    gl.NEAREST_MIPMAP_LINEAR,
    gl.LINEAR_MIPMAP_NEAREST,
    gl.LINEAR_MIPMAP_LINEAR
  ]
  wrapTypes = [
    gl.REPEAT,
    gl.CLAMP_TO_EDGE,
    gl.MIRRORED_REPEAT
  ]
}

var convertFloatToUint8 = function(out, inp) {
  ops.muls(out, inp, 255.0)
}

function reshapeTexture(tex, w, h) {
  var gl = tex.gl
  var maxSize = gl.getParameter(gl.MAX_TEXTURE_SIZE)
  if(w < 0 || w > maxSize || h < 0 || h > maxSize) {
    throw new Error('gl-texture2d: Invalid texture size')
  }
  tex._shape = [w, h]
  tex.bind()
  gl.texImage2D(gl.TEXTURE_2D, 0, tex.format, w, h, 0, tex.format, tex.type, null)
  tex._mipLevels = [0]
  return tex
}

function Texture2D(gl, handle, width, height, format, type) {
  this.gl = gl
  this.handle = handle
  this.format = format
  this.type = type
  this._shape = [width, height]
  this._mipLevels = [0]
  this._magFilter = gl.NEAREST
  this._minFilter = gl.NEAREST
  this._wrapS = gl.CLAMP_TO_EDGE
  this._wrapT = gl.CLAMP_TO_EDGE
  this._anisoSamples = 1

  var parent = this
  var wrapVector = [this._wrapS, this._wrapT]
  Object.defineProperties(wrapVector, [
    {
      get: function() {
        return parent._wrapS
      },
      set: function(v) {
        return parent.wrapS = v
      }
    },
    {
      get: function() {
        return parent._wrapT
      },
      set: function(v) {
        return parent.wrapT = v
      }
    }
  ])
  this._wrapVector = wrapVector

  var shapeVector = [this._shape[0], this._shape[1]]
  Object.defineProperties(shapeVector, [
    {
      get: function() {
        return parent._shape[0]
      },
      set: function(v) {
        return parent.width = v
      }
    },
    {
      get: function() {
        return parent._shape[1]
      },
      set: function(v) {
        return parent.height = v
      }
    }
  ])
  this._shapeVector = shapeVector
}

var proto = Texture2D.prototype

Object.defineProperties(proto, {
  minFilter: {
    get: function() {
      return this._minFilter
    },
    set: function(v) {
      this.bind()
      var gl = this.gl
      if(this.type === gl.FLOAT && linearTypes.indexOf(v) >= 0) {
        if(!webglew(gl).texture_float_linear) {
          v = gl.NEAREST
        }
      }
      if(filterTypes.indexOf(v) < 0) {
        throw new Error('gl-texture2d: Unknown filter mode ' + v)
      }
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, v)
      return this._minFilter = v
    }
  },
  magFilter: {
    get: function() {
      return this._magFilter
    },
    set: function(v) {
      this.bind()
      var gl = this.gl
      if(this.type === gl.FLOAT && linearTypes.indexOf(v) >= 0) {
        if(!webglew(gl).texture_float_linear) {
          v = gl.NEAREST
        }
      }
      if(filterTypes.indexOf(v) < 0) {
        throw new Error('gl-texture2d: Unknown filter mode ' + v)
      }
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, v)
      return this._magFilter = v
    }
  },
  mipSamples: {
    get: function() {
      return this._anisoSamples
    },
    set: function(i) {
      var psamples = this._anisoSamples
      this._anisoSamples = Math.max(i, 1)|0
      if(psamples !== this._anisoSamples) {
        var ext = webglew(this.gl).EXT_texture_filter_anisotropic
        if(ext) {
          this.gl.texParameterf(this.gl.TEXTURE_2D, ext.TEXTURE_MAX_ANISOTROPY_EXT, this._anisoSamples)
        }
      }
      return this._anisoSamples
    }
  },
  wrapS: {
    get: function() {
      return this._wrapS
    },
    set: function(v) {
      this.bind()
      if(wrapTypes.indexOf(v) < 0) {
        throw new Error('gl-texture2d: Unknown wrap mode ' + v)
      }
      this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, v)
      return this._wrapS = v
    }
  },
  wrapT: {
    get: function() {
      return this._wrapT
    },
    set: function(v) {
      this.bind()
      if(wrapTypes.indexOf(v) < 0) {
        throw new Error('gl-texture2d: Unknown wrap mode ' + v)
      }
      this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, v)
      return this._wrapT = v
    }
  },
  wrap: {
    get: function() {
      return this._wrapVector
    },
    set: function(v) {
      if(!Array.isArray(v)) {
        v = [v,v]
      }
      if(v.length !== 2) {
        throw new Error('gl-texture2d: Must specify wrap mode for rows and columns')
      }
      for(var i=0; i<2; ++i) {
        if(wrapTypes.indexOf(v[i]) < 0) {
          throw new Error('gl-texture2d: Unknown wrap mode ' + v)
        }
      }
      this._wrapS = v[0]
      this._wrapT = v[1]

      var gl = this.gl
      this.bind()
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, this._wrapS)
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, this._wrapT)

      return v
    }
  },
  shape: {
    get: function() {
      return this._shapeVector
    }, 
    set: function(x) {
      if(!Array.isArray(x)) {
        x = [x|0,x|0]
      } else {
        if(x.length !== 2) {
          throw new Error('gl-texture2d: Invalid texture shape')
        }
      }
      reshapeTexture(this, x[0]|0, x[1]|0)
      return [x[0]|0, x[1]|0]
    }
  },
  width: {
    get: function() {
      return this._shape[0]
    },
    set: function(w) {
      w = w|0
      reshapeTexture(this, w, this._shape[1])
      return w
    }
  },
  height: {
    get: function() {
      return this._shape[1]
    },
    set: function(h) {
      h = h|0
      reshapeTexture(this, this._shape[0], h)
      return h
    }
  }
})

proto.bind = function(unit) {
  var gl = this.gl
  if(unit !== undefined) {
    gl.activeTexture(gl.TEXTURE0 + (unit|0))
  }
  gl.bindTexture(gl.TEXTURE_2D, this.handle)
  if(unit !== undefined) {
    return (unit|0)
  }
  return gl.getParameter(gl.ACTIVE_TEXTURE) - gl.TEXTURE0
}

proto.dispose = function() {
  this.gl.deleteTexture(this.handle)
}

proto.generateMipmap = function() {
  this.bind()
  this.gl.generateMipmap(this.gl.TEXTURE_2D)
  
  //Update mip levels
  var l = Math.min(this._shape[0], this._shape[1])
  for(var i=0; l>0; ++i, l>>>=1) {
    if(this._mipLevels.indexOf(i) < 0) {
      this._mipLevels.push(i)
    }
  }
}

proto.setPixels = function(data, x_off, y_off, mip_level) {
  var gl = this.gl
  this.bind()
  if(Array.isArray(x_off)) {
    mip_level = y_off
    y_off = x_off[1]|0
    x_off = x_off[0]|0
  } else {
    x_off = x_off || 0
    y_off = y_off || 0
  }
  mip_level = mip_level || 0
  if(data instanceof HTMLCanvasElement ||
     data instanceof ImageData ||
     data instanceof HTMLImageElement ||
     data instanceof HTMLVideoElement) {
    var needsMip = this._mipLevels.indexOf(mip_level) < 0
    if(needsMip) {
      gl.texImage2D(gl.TEXTURE_2D, 0, this.format, this.format, this.type, data)
      this._mipLevels.push(mip_level)
    } else {
      gl.texSubImage2D(gl.TEXTURE_2D, mip_level, x_off, y_off, this.format, this.type, data)
    }
  } else if(data.shape && data.stride && data.data) {
    if(data.shape.length < 2 ||
       x_off + data.shape[1] > this._shape[1]>>>mip_level ||
       y_off + data.shape[0] > this._shape[0]>>>mip_level ||
       x_off < 0 ||
       y_off < 0) {
      throw new Error('gl-texture2d: Texture dimensions are out of bounds')
    }
    texSubImageArray(gl, x_off, y_off, mip_level, this.format, this.type, this._mipLevels, data)
  } else {
    throw new Error('gl-texture2d: Unsupported data type')
  }
}


function isPacked(shape, stride) {
  if(shape.length === 3) {
    return  (stride[2] === 1) && 
            (stride[1] === shape[0]*shape[2]) &&
            (stride[0] === shape[2])
  }
  return  (stride[0] === 1) && 
          (stride[1] === shape[0])
}

function texSubImageArray(gl, x_off, y_off, mip_level, cformat, ctype, mipLevels, array) {
  var dtype = array.dtype
  var shape = array.shape.slice()
  if(shape.length < 2 || shape.length > 3) {
    throw new Error('gl-texture2d: Invalid ndarray, must be 2d or 3d')
  }
  var type = 0, format = 0
  var packed = isPacked(shape, array.stride.slice())
  if(dtype === 'float32') {
    type = gl.FLOAT
  } else if(dtype === 'float64') {
    type = gl.FLOAT
    packed = false
    dtype = 'float32'
  } else if(dtype === 'uint8') {
    type = gl.UNSIGNED_BYTE
  } else {
    type = gl.UNSIGNED_BYTE
    packed = false
    dtype = 'uint8'
  }
  var channels = 1
  if(shape.length === 2) {
    format = gl.LUMINANCE
    shape = [shape[0], shape[1], 1]
    array = ndarray(array.data, shape, [array.stride[0], array.stride[1], 1], array.offset)
  } else if(shape.length === 3) {
    if(shape[2] === 1) {
      format = gl.ALPHA
    } else if(shape[2] === 2) {
      format = gl.LUMINANCE_ALPHA
    } else if(shape[2] === 3) {
      format = gl.RGB
    } else if(shape[2] === 4) {
      format = gl.RGBA
    } else {
      throw new Error('gl-texture2d: Invalid shape for pixel coords')
    }
    channels = shape[2]
  } else {
    throw new Error('gl-texture2d: Invalid shape for texture')
  }
  //For 1-channel textures allow conversion between formats
  if((format  === gl.LUMINANCE || format  === gl.ALPHA) &&
     (cformat === gl.LUMINANCE || cformat === gl.ALPHA)) {
    format = cformat
  }
  if(format !== cformat) {
    throw new Error('gl-texture2d: Incompatible texture format for setPixels')
  }
  var size = array.size
  var needsMip = mipLevels.indexOf(mip_level) < 0
  if(needsMip) {
    mipLevels.push(mip_level)
  }
  if(type === ctype && packed) {
    //Array data types are compatible, can directly copy into texture
    if(array.offset === 0 && array.data.length === size) {
      if(needsMip) {
        gl.texImage2D(gl.TEXTURE_2D, mip_level, cformat, shape[0], shape[1], 0, cformat, ctype, array.data)
      } else {
        gl.texSubImage2D(gl.TEXTURE_2D, mip_level, x_off, y_off, shape[0], shape[1], cformat, ctype, array.data)
      }
    } else {
      if(needsMip) {
        gl.texImage2D(gl.TEXTURE_2D, mip_level, cformat, shape[0], shape[1], 0, cformat, ctype, array.data.subarray(array.offset, array.offset+size))
      } else {
        gl.texSubImage2D(gl.TEXTURE_2D, mip_level, x_off, y_off, shape[0], shape[1], cformat, ctype, array.data.subarray(array.offset, array.offset+size))
      }
    }
  } else {
    //Need to do type conversion to pack data into buffer
    var pack_buffer
    if(ctype === gl.FLOAT) {
      pack_buffer = pool.mallocFloat32(size)
    } else {
      pack_buffer = pool.mallocUint8(size)
    }
    var pack_view = ndarray(pack_buffer, shape, [shape[2], shape[2]*shape[0], 1])
    if(type === gl.FLOAT && ctype === gl.UNSIGNED_BYTE) {
      convertFloatToUint8(pack_view, array)
    } else {
      ops.assign(pack_view, array)
    }
    if(needsMip) {
      gl.texImage2D(gl.TEXTURE_2D, mip_level, cformat, shape[0], shape[1], 0, cformat, ctype, pack_buffer.subarray(0, size))
    } else {
      gl.texSubImage2D(gl.TEXTURE_2D, mip_level, x_off, y_off, shape[0], shape[1], cformat, ctype, pack_buffer.subarray(0, size))
    }
    if(ctype === gl.FLOAT) {
      pool.freeFloat32(pack_buffer)
    } else {
      pool.freeUint8(pack_buffer)
    }
  }
}

function initTexture(gl) {
  var tex = gl.createTexture()
  gl.bindTexture(gl.TEXTURE_2D, tex)
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST)
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST)
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE)
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE)
  return tex
}

function createTextureShape(gl, width, height, format, type) {
  var maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE)
  if(width < 0 || width > maxTextureSize || height < 0 || height  > maxTextureSize) {
    throw new Error('gl-texture2d: Invalid texture shape')
  }
  if(type === gl.FLOAT && !webglew(gl).texture_float) {
    throw new Error('gl-texture2d: Floating point textures not supported on this platform')
  }
  var tex = initTexture(gl)
  gl.texImage2D(gl.TEXTURE_2D, 0, format, width, height, 0, format, type, null)
  return new Texture2D(gl, tex, width, height, format, type)
}

function createTextureDOM(gl, element, format, type) {
  var tex = initTexture(gl)
  gl.texImage2D(gl.TEXTURE_2D, 0, format, format, type, element)
  return new Texture2D(gl, tex, element.width|0, element.height|0, format, type)
}

//Creates a texture from an ndarray
function createTextureArray(gl, array) {
  var dtype = array.dtype
  var shape = array.shape.slice()
  var maxSize = gl.getParameter(gl.MAX_TEXTURE_SIZE)
  if(shape[0] < 0 || shape[0] > maxSize || shape[1] < 0 || shape[1] > maxSize) {
    throw new Error('gl-texture2d: Invalid texture size')
  }
  var packed = isPacked(shape, array.stride.slice())
  var type = 0
  if(dtype === 'float32') {
    type = gl.FLOAT
  } else if(dtype === 'float64') {
    type = gl.FLOAT
    packed = false
    dtype = 'float32'
  } else if(dtype === 'uint8') {
    type = gl.UNSIGNED_BYTE
  } else {
    type = gl.UNSIGNED_BYTE
    packed = false
    dtype = 'uint8'
  }
  var format = 0
  if(shape.length === 2) {
    format = gl.LUMINANCE
    shape = [shape[0], shape[1], 1]
    array = ndarray(array.data, shape, [array.stride[0], array.stride[1], 1], array.offset)
  } else if(shape.length === 3) {
    if(shape[2] === 1) {
      format = gl.ALPHA
    } else if(shape[2] === 2) {
      format = gl.LUMINANCE_ALPHA
    } else if(shape[2] === 3) {
      format = gl.RGB
    } else if(shape[2] === 4) {
      format = gl.RGBA
    } else {
      throw new Error('gl-texture2d: Invalid shape for pixel coords')
    }
  } else {
    throw new Error('gl-texture2d: Invalid shape for texture')
  }
  if(type === gl.FLOAT && !webglew(gl).texture_float) {
    type = gl.UNSIGNED_BYTE
    packed = false
  }
  var buffer, buf_store
  var size = array.size
  if(!packed) {
    var stride = [shape[2], shape[2]*shape[0], 1]
    buf_store = pool.malloc(size, dtype)
    var buf_array = ndarray(buf_store, shape, stride, 0)
    if((dtype === 'float32' || dtype === 'float64') && type === gl.UNSIGNED_BYTE) {
      convertFloatToUint8(buf_array, array)
    } else {
      ops.assign(buf_array, array)
    }
    buffer = buf_store.subarray(0, size)
  } else if (array.offset === 0 && array.data.length === size) {
    buffer = array.data
  } else {
    buffer = array.data.subarray(array.offset, array.offset + size)
  }
  var tex = initTexture(gl)
  gl.texImage2D(gl.TEXTURE_2D, 0, format, shape[0], shape[1], 0, format, type, buffer)
  if(!packed) {
    pool.free(buf_store)
  }
  return new Texture2D(gl, tex, shape[0], shape[1], format, type)
}

function createTexture2D(gl) {
  if(arguments.length <= 1) {
    throw new Error('gl-texture2d: Missing arguments for texture2d constructor')
  }
  if(!linearTypes) {
    lazyInitLinearTypes(gl)
  }
  if(typeof arguments[1] === 'number') {
    return createTextureShape(gl, arguments[1], arguments[2], arguments[3]||gl.RGBA, arguments[4]||gl.UNSIGNED_BYTE)
  }
  if(Array.isArray(arguments[1])) {
    return createTextureShape(gl, arguments[1][0]|0, arguments[1][1]|0, arguments[2]||gl.RGBA, arguments[3]||gl.UNSIGNED_BYTE)
  }
  if(typeof arguments[1] === 'object') {
    var obj = arguments[1]
    if(obj instanceof HTMLCanvasElement ||
       obj instanceof HTMLImageElement ||
       obj instanceof HTMLVideoElement ||
       obj instanceof ImageData) {
      return createTextureDOM(gl, obj, arguments[2]||gl.RGBA, arguments[3]||gl.UNSIGNED_BYTE)
    } else if(obj.shape && obj.data && obj.stride) {
      return createTextureArray(gl, obj)
    }
  }
  throw new Error('gl-texture2d: Invalid arguments for texture2d constructor')
}

},{"ndarray":"/projects/blackice/node_modules/gl-texture2d/node_modules/ndarray/ndarray.js","ndarray-ops":"/projects/blackice/node_modules/gl-texture2d/node_modules/ndarray-ops/ndarray-ops.js","typedarray-pool":"/projects/blackice/node_modules/gl-texture2d/node_modules/typedarray-pool/pool.js","webglew":"/projects/blackice/node_modules/gl-texture2d/node_modules/webglew/webglew.js"}],"/projects/blackice/node_modules/gl-vec3/set.js":[function(require,module,exports){
module.exports = set;

/**
 * Set the components of a vec3 to the given values
 *
 * @param {vec3} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} out
 */
function set(out, x, y, z) {
    out[0] = x
    out[1] = y
    out[2] = z
    return out
}
},{}],"/projects/blackice/node_modules/glslify/adapter.js":[function(require,module,exports){
module.exports = programify

var shader = require('gl-shader-core')

function programify(vertex, fragment, uniforms, attributes) {
  return function(gl) {
    return shader(gl, vertex, fragment, uniforms, attributes)
  }
}

},{"gl-shader-core":"/projects/blackice/node_modules/glslify/node_modules/gl-shader-core/shader-core.js"}],"/projects/blackice/node_modules/glslify/browser.js":[function(require,module,exports){
module.exports = noop

function noop() {
  throw new Error(
      'You should bundle your code ' +
      'using `glslify` as a transform.'
  )
}

},{}],"/projects/blackice/node_modules/glslify/node_modules/gl-shader-core/lib/create-attributes.js":[function(require,module,exports){
'use strict'

module.exports = createAttributeWrapper

//Shader attribute class
function ShaderAttribute(gl, program, location, dimension, name, constFunc, relink) {
  this._gl = gl
  this._program = program
  this._location = location
  this._dimension = dimension
  this._name = name
  this._constFunc = constFunc
  this._relink = relink
}

var proto = ShaderAttribute.prototype

proto.pointer = function setAttribPointer(type, normalized, stride, offset) {
  var gl = this._gl
  gl.vertexAttribPointer(this._location, this._dimension, type||gl.FLOAT, !!normalized, stride||0, offset||0)
  this._gl.enableVertexAttribArray(this._location)
}

Object.defineProperty(proto, 'location', {
  get: function() {
    return this._location
  }
  , set: function(v) {
    if(v !== this._location) {
      this._location = v
      this._gl.bindAttribLocation(this._program, v, this._name)
      this._gl.linkProgram(this._program)
      this._relink()
    }
  }
})


//Adds a vector attribute to obj
function addVectorAttribute(gl, program, location, dimension, obj, name, doLink) {
  var constFuncArgs = [ 'gl', 'v' ]
  var varNames = []
  for(var i=0; i<dimension; ++i) {
    constFuncArgs.push('x'+i)
    varNames.push('x'+i)
  }
  constFuncArgs.push([
    'if(x0.length===void 0){return gl.vertexAttrib', dimension, 'f(v,', varNames.join(), ')}else{return gl.vertexAttrib', dimension, 'fv(v,x0)}'
  ].join(''))
  var constFunc = Function.apply(undefined, constFuncArgs)
  var attr = new ShaderAttribute(gl, program, location, dimension, name, constFunc, doLink)
  Object.defineProperty(obj, name, {
    set: function(x) {
      gl.disableVertexAttribArray(attr._location)
      constFunc(gl, attr._location, x)
      return x
    }
    , get: function() {
      return attr
    }
    , enumerable: true
  })
}

//Create shims for attributes
function createAttributeWrapper(gl, program, attributes, doLink) {
  var obj = {}
  for(var i=0, n=attributes.length; i<n; ++i) {
    var a = attributes[i]
    var name = a.name
    var type = a.type
    var location = gl.getAttribLocation(program, name)
    
    switch(type) {
      case 'bool':
      case 'int':
      case 'float':
        addVectorAttribute(gl, program, location, 1, obj, name, doLink)
      break
      
      default:
        if(type.indexOf('vec') >= 0) {
          var d = type.charCodeAt(type.length-1) - 48
          if(d < 2 || d > 4) {
            throw new Error('gl-shader: Invalid data type for attribute ' + name + ': ' + type)
          }
          addVectorAttribute(gl, program, location, d, obj, name, doLink)
        } else {
          throw new Error('gl-shader: Unknown data type for attribute ' + name + ': ' + type)
        }
      break
    }
  }
  return obj
}
},{}],"/projects/blackice/node_modules/glslify/node_modules/gl-shader-core/lib/create-uniforms.js":[function(require,module,exports){
'use strict'

var dup = require('dup')
var coallesceUniforms = require('./reflect')

module.exports = createUniformWrapper

//Binds a function and returns a value
function identity(x) {
  var c = new Function('y', 'return function(){return y}')
  return c(x)
}

//Create shims for uniforms
function createUniformWrapper(gl, program, uniforms, locations) {

  function makeGetter(index) {
    var proc = new Function('gl', 'prog', 'locations', 
      'return function(){return gl.getUniform(prog,locations[' + index + '])}') 
    return proc(gl, program, locations)
  }

  function makePropSetter(path, index, type) {
    switch(type) {
      case 'bool':
      case 'int':
      case 'sampler2D':
      case 'samplerCube':
        return 'gl.uniform1i(locations[' + index + '],obj' + path + ')'
      case 'float':
        return 'gl.uniform1f(locations[' + index + '],obj' + path + ')'
      default:
        var vidx = type.indexOf('vec')
        if(0 <= vidx && vidx <= 1 && type.length === 4 + vidx) {
          var d = type.charCodeAt(type.length-1) - 48
          if(d < 2 || d > 4) {
            throw new Error('gl-shader: Invalid data type')
          }
          switch(type.charAt(0)) {
            case 'b':
            case 'i':
              return 'gl.uniform' + d + 'iv(locations[' + index + '],obj' + path + ')'
            case 'v':
              return 'gl.uniform' + d + 'fv(locations[' + index + '],obj' + path + ')'
            default:
              throw new Error('gl-shader: Unrecognized data type for vector ' + name + ': ' + type)
          }
        } else if(type.indexOf('mat') === 0 && type.length === 4) {
          var d = type.charCodeAt(type.length-1) - 48
          if(d < 2 || d > 4) {
            throw new Error('gl-shader: Invalid uniform dimension type for matrix ' + name + ': ' + type)
          }
          return 'gl.uniformMatrix' + d + 'fv(locations[' + index + '],false,obj' + path + ')'
        } else {
          throw new Error('gl-shader: Unknown uniform data type for ' + name + ': ' + type)
        }
      break
    }
  }

  function enumerateIndices(prefix, type) {
    if(typeof type !== 'object') {
      return [ [prefix, type] ]
    }
    var indices = []
    for(var id in type) {
      var prop = type[id]
      var tprefix = prefix
      if(parseInt(id) + '' === id) {
        tprefix += '[' + id + ']'
      } else {
        tprefix += '.' + id
      }
      if(typeof prop === 'object') {
        indices.push.apply(indices, enumerateIndices(tprefix, prop))
      } else {
        indices.push([tprefix, prop])
      }
    }
    return indices
  }

  function makeSetter(type) {
    var code = [ 'return function updateProperty(obj){' ]
    var indices = enumerateIndices('', type)
    for(var i=0; i<indices.length; ++i) {
      var item = indices[i]
      var path = item[0]
      var idx  = item[1]
      if(locations[idx]) {
        code.push(makePropSetter(path, idx, uniforms[idx].type))
      }
    }
    code.push('return obj}')
    var proc = new Function('gl', 'prog', 'locations', code.join('\n'))
    return proc(gl, program, locations)
  }

  function defaultValue(type) {
    switch(type) {
      case 'bool':
        return false
      case 'int':
      case 'sampler2D':
      case 'samplerCube':
        return 0
      case 'float':
        return 0.0
      default:
        var vidx = type.indexOf('vec')
        if(0 <= vidx && vidx <= 1 && type.length === 4 + vidx) {
          var d = type.charCodeAt(type.length-1) - 48
          if(d < 2 || d > 4) {
            throw new Error('gl-shader: Invalid data type')
          }
          if(type.charAt(0) === 'b') {
            return dup(d, false)
          }
          return dup(d)
        } else if(type.indexOf('mat') === 0 && type.length === 4) {
          var d = type.charCodeAt(type.length-1) - 48
          if(d < 2 || d > 4) {
            throw new Error('gl-shader: Invalid uniform dimension type for matrix ' + name + ': ' + type)
          }
          return dup([d,d])
        } else {
          throw new Error('gl-shader: Unknown uniform data type for ' + name + ': ' + type)
        }
      break
    }
  }

  function storeProperty(obj, prop, type) {
    if(typeof type === 'object') {
      var child = processObject(type)
      Object.defineProperty(obj, prop, {
        get: identity(child),
        set: makeSetter(type),
        enumerable: true,
        configurable: false
      })
    } else {
      if(locations[type]) {
        Object.defineProperty(obj, prop, {
          get: makeGetter(type),
          set: makeSetter(type),
          enumerable: true,
          configurable: false
        })
      } else {
        obj[prop] = defaultValue(uniforms[type].type)
      }
    }
  }

  function processObject(obj) {
    var result
    if(Array.isArray(obj)) {
      result = new Array(obj.length)
      for(var i=0; i<obj.length; ++i) {
        storeProperty(result, i, obj[i])
      }
    } else {
      result = {}
      for(var id in obj) {
        storeProperty(result, id, obj[id])
      }
    }
    return result
  }

  //Return data
  var coallesced = coallesceUniforms(uniforms, true)
  return {
    get: identity(processObject(coallesced)),
    set: makeSetter(coallesced),
    enumerable: true,
    configurable: true
  }
}

},{"./reflect":"/projects/blackice/node_modules/glslify/node_modules/gl-shader-core/lib/reflect.js","dup":"/projects/blackice/node_modules/glslify/node_modules/gl-shader-core/node_modules/dup/dup.js"}],"/projects/blackice/node_modules/glslify/node_modules/gl-shader-core/lib/reflect.js":[function(require,module,exports){
'use strict'

module.exports = makeReflectTypes

//Construct type info for reflection.
//
// This iterates over the flattened list of uniform type values and smashes them into a JSON object.
//
// The leaves of the resulting object are either indices or type strings representing primitive glslify types
function makeReflectTypes(uniforms, useIndex) {
  var obj = {}
  for(var i=0; i<uniforms.length; ++i) {
    var n = uniforms[i].name
    var parts = n.split(".")
    var o = obj
    for(var j=0; j<parts.length; ++j) {
      var x = parts[j].split("[")
      if(x.length > 1) {
        if(!(x[0] in o)) {
          o[x[0]] = []
        }
        o = o[x[0]]
        for(var k=1; k<x.length; ++k) {
          var y = parseInt(x[k])
          if(k<x.length-1 || j<parts.length-1) {
            if(!(y in o)) {
              if(k < x.length-1) {
                o[y] = []
              } else {
                o[y] = {}
              }
            }
            o = o[y]
          } else {
            if(useIndex) {
              o[y] = i
            } else {
              o[y] = uniforms[i].type
            }
          }
        }
      } else if(j < parts.length-1) {
        if(!(x[0] in o)) {
          o[x[0]] = {}
        }
        o = o[x[0]]
      } else {
        if(useIndex) {
          o[x[0]] = i
        } else {
          o[x[0]] = uniforms[i].type
        }
      }
    }
  }
  return obj
}
},{}],"/projects/blackice/node_modules/glslify/node_modules/gl-shader-core/node_modules/dup/dup.js":[function(require,module,exports){
module.exports=require("/projects/blackice/node_modules/gl-texture2d/node_modules/typedarray-pool/node_modules/dup/dup.js")
},{"/projects/blackice/node_modules/gl-texture2d/node_modules/typedarray-pool/node_modules/dup/dup.js":"/projects/blackice/node_modules/gl-texture2d/node_modules/typedarray-pool/node_modules/dup/dup.js"}],"/projects/blackice/node_modules/glslify/node_modules/gl-shader-core/shader-core.js":[function(require,module,exports){
'use strict'

var createUniformWrapper = require('./lib/create-uniforms')
var createAttributeWrapper = require('./lib/create-attributes')
var makeReflect = require('./lib/reflect')

//Shader object
function Shader(gl, prog, vertShader, fragShader) {
  this.gl = gl
  this.handle = prog
  this.attributes = null
  this.uniforms = null
  this.types = null
  this.vertexShader = vertShader
  this.fragmentShader = fragShader
}

//Binds the shader
Shader.prototype.bind = function() {
  this.gl.useProgram(this.handle)
}

//Destroy shader, release resources
Shader.prototype.dispose = function() {
  var gl = this.gl
  gl.deleteShader(this.vertexShader)
  gl.deleteShader(this.fragmentShader)
  gl.deleteProgram(this.handle)
}

Shader.prototype.updateExports = function(uniforms, attributes) {
  var locations = new Array(uniforms.length)
  var program = this.handle
  var gl = this.gl

  var doLink = relinkUniforms.bind(void 0,
    gl,
    program,
    locations,
    uniforms
  )
  doLink()

  this.types = {
    uniforms: makeReflect(uniforms),
    attributes: makeReflect(attributes)
  }

  this.attributes = createAttributeWrapper(
    gl,
    program,
    attributes,
    doLink
  )

  Object.defineProperty(this, 'uniforms', createUniformWrapper(
    gl,
    program,
    uniforms,
    locations
  ))
}

//Relinks all uniforms
function relinkUniforms(gl, program, locations, uniforms) {
  for(var i=0; i<uniforms.length; ++i) {
    locations[i] = gl.getUniformLocation(program, uniforms[i].name)
  }
}

//Compiles and links a shader program with the given attribute and vertex list
function createShader(
    gl
  , vertSource
  , fragSource
  , uniforms
  , attributes) {
  
  //Compile vertex shader
  var vertShader = gl.createShader(gl.VERTEX_SHADER)
  gl.shaderSource(vertShader, vertSource)
  gl.compileShader(vertShader)
  if(!gl.getShaderParameter(vertShader, gl.COMPILE_STATUS)) {
    var errLog = gl.getShaderInfoLog(vertShader)
    console.error('gl-shader: Error compling vertex shader:', errLog)
    throw new Error('gl-shader: Error compiling vertex shader:' + errLog)
  }
  
  //Compile fragment shader
  var fragShader = gl.createShader(gl.FRAGMENT_SHADER)
  gl.shaderSource(fragShader, fragSource)
  gl.compileShader(fragShader)
  if(!gl.getShaderParameter(fragShader, gl.COMPILE_STATUS)) {
    var errLog = gl.getShaderInfoLog(fragShader)
    console.error('gl-shader: Error compiling fragment shader:', errLog)
    throw new Error('gl-shader: Error compiling fragment shader:' + errLog)
  }
  
  //Link program
  var program = gl.createProgram()
  gl.attachShader(program, fragShader)
  gl.attachShader(program, vertShader)

  //Optional default attriubte locations
  attributes.forEach(function(a) {
    if (typeof a.location === 'number') 
      gl.bindAttribLocation(program, a.location, a.name)
  })

  gl.linkProgram(program)
  if(!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    var errLog = gl.getProgramInfoLog(program)
    console.error('gl-shader: Error linking shader program:', errLog)
    throw new Error('gl-shader: Error linking shader program:' + errLog)
  }
  
  //Return final linked shader object
  var shader = new Shader(
    gl,
    program,
    vertShader,
    fragShader
  )
  shader.updateExports(uniforms, attributes)

  return shader
}

module.exports = createShader

},{"./lib/create-attributes":"/projects/blackice/node_modules/glslify/node_modules/gl-shader-core/lib/create-attributes.js","./lib/create-uniforms":"/projects/blackice/node_modules/glslify/node_modules/gl-shader-core/lib/create-uniforms.js","./lib/reflect":"/projects/blackice/node_modules/glslify/node_modules/gl-shader-core/lib/reflect.js"}],"/projects/blackice/node_modules/glslify/simple-adapter.js":[function(require,module,exports){
module.exports = programify

function programify(vertex, fragment, uniforms, attributes) {
  return {
    vertex: vertex, 
    fragment: fragment,
    uniforms: uniforms, 
    attributes: attributes
  };
}

},{}],"/projects/blackice/node_modules/img/index.js":[function(require,module,exports){
module.exports = img;

function img (src, opt, callback) {
  if (typeof opt === 'function') {
    callback = opt
    opt = null
  }


  var el = document.createElement('img');
  var locked;

  el.onload = function () {
    if (locked) return;
    locked = true;

    callback && callback(undefined, el);
  };

  el.onerror = function (err) {
    if (locked) return;
    locked = true;

    callback && callback(new Error('Unable to load "' + src + '"'), el);
  };
  
  if (opt && opt.crossOrigin)
    el.crossOrigin = opt.crossOrigin;

  el.src = src;

  return el;
}

},{}],"/projects/blackice/node_modules/inherits/inherits_browser.js":[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],"/projects/blackice/node_modules/lerp/index.js":[function(require,module,exports){
function lerp(v0, v1, t) {
    return v0*(1-t)+v1*t
}
module.exports = lerp
},{}],"/projects/blackice/node_modules/mixes/index.js":[function(require,module,exports){
var xtend = require('xtend')

var defaults = {
	enumerable: true,
	configurable: true
}

function mix(obj, entries) {
	for (var k in entries) {
		if (!entries.hasOwnProperty(k))
			continue
		var f = entries[k]
		if (typeof f === 'function') {
			obj[k] = f
		} else if (f && typeof f === 'object') {
			var def = xtend(defaults, f)
			Object.defineProperty(obj, k, def);
		}
	}
}

module.exports = function mixes(ctor, entries) {
	mix(ctor.prototype, entries)
}

module.exports.mix = mix
},{"xtend":"/projects/blackice/node_modules/xtend/immutable.js"}],"/projects/blackice/node_modules/normalize-path-scale/index.js":[function(require,module,exports){
var bounds = require('getboundingbox')
var unlerp = require('unlerp')

module.exports = function normalize(path, box) {
    var b
    if (box && typeof box === 'object') {
        b = box
    } else
        b = bounds(path)

    //TODO: hmm, doesn't really handle div by zero
    //in any sane manner

    var w = (b.maxX-b.minX),
        h = (b.maxY-b.minY)

    var aspectX = w>h ? 1 : h/w,
        aspectY = w>h ? w/h : 1

    return path.map(function(p) {
        return [
            range(b.minX, b.maxX, p[0])*1/aspectX,
            range(b.minY, b.maxY, p[1])*1/aspectY
        ]
    })
}

function range(min, max, value) {
    return ((max-min===0) ? 0 : unlerp(min, max, value))*2-1
}
},{"getboundingbox":"/projects/blackice/node_modules/normalize-path-scale/node_modules/getboundingbox/index.js","unlerp":"/projects/blackice/node_modules/unlerp/index.js"}],"/projects/blackice/node_modules/normalize-path-scale/node_modules/getboundingbox/index.js":[function(require,module,exports){
module.exports = function( path, box, xKey, yKey ) {
    xKey = typeof xKey === 'string' ? xKey : 0;
    yKey = typeof yKey === 'string' ? yKey : 1;
    if (!box || typeof box === 'number')
        box = {};

    box.minX = Infinity;
    box.minY = Infinity;
    box.maxX = -Infinity;
    box.maxY = -Infinity;

    for (var i=0; i<path.length; i++) {
        var x = path[i][ xKey ],
            y = path[i][ yKey ];
        box.minX = Math.min( box.minX, x );
        box.minY = Math.min( box.minY, y );
        box.maxX = Math.max( box.maxX, x );
        box.maxY = Math.max( box.maxY, y );
    }
    
    if (path.length === 0) 
        box.minX = box.maxX = box.minY = box.maxY = 0
    return box;
};
},{}],"/projects/blackice/node_modules/parse-svg-path/index.js":[function(require,module,exports){

module.exports = parse

/**
 * expected argument lengths
 * @type {Object}
 */

var length = {a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0}

/**
 * segment pattern
 * @type {RegExp}
 */

var segment = /([astvzqmhlc])([^astvzqmhlc]*)/ig

/**
 * parse an svg path data string. Generates an Array
 * of commands where each command is an Array of the
 * form `[command, arg1, arg2, ...]`
 *
 * @param {String} path
 * @return {Array}
 */

function parse(path) {
	var data = []
	path.replace(segment, function(_, command, args){
		var type = command.toLowerCase()
		args = parseValues(args)

		// overloaded moveTo
		if (type == 'm' && args.length > 2) {
			data.push([command].concat(args.splice(0, 2)))
			type = 'l'
			command = command == 'm' ? 'l' : 'L'
		}

		while (true) {
			if (args.length == length[type]) {
				args.unshift(command)
				return data.push(args)
			}
			if (args.length < length[type]) throw new Error('malformed path data')
			data.push([command].concat(args.splice(0, length[type])))
		}
	})
	return data
}

function parseValues(args){
	args = args.match(/-?[.0-9]+(?:e[-+]?\d+)?/ig)
	return args ? args.map(Number) : []
}

},{}],"/projects/blackice/node_modules/plucker/index.js":[function(require,module,exports){
module.exports = plucker

function plucker(path, object) {
  return arguments.length >= 2
    ? pluck(path)(object)
    : pluck(path)
}

function pluck(path) {
  path = typeof path === 'string'
    ? String(path).trim().split('.')
    : path

  if (path.length < 2) {
    path = path[0]
    return pluckSingle
  } else {
    var l = path.length
    return pluckPath
  }

  function pluckSingle(object) {
    return object[path]
  }

  function pluckPath(object) {
    for (var i = 0; i < l; i++) {
      if (typeof object === 'undefined') break

      object = object[path[i]]
    }

    return object
  }
}

},{}],"/projects/blackice/node_modules/raf.js/raf.js":[function(require,module,exports){
/*
 * raf.js
 * https://github.com/ngryman/raf.js
 *
 * original requestAnimationFrame polyfill by Erik Möller
 * inspired from paul_irish gist and post
 *
 * Copyright (c) 2013 ngryman
 * Licensed under the MIT license.
 */

(function(window) {
	var lastTime = 0,
		vendors = ['webkit', 'moz'],
		requestAnimationFrame = window.requestAnimationFrame,
		cancelAnimationFrame = window.cancelAnimationFrame,
		i = vendors.length;

	// try to un-prefix existing raf
	while (--i >= 0 && !requestAnimationFrame) {
		requestAnimationFrame = window[vendors[i] + 'RequestAnimationFrame'];
		cancelAnimationFrame = window[vendors[i] + 'CancelAnimationFrame'];
	}

	// polyfill with setTimeout fallback
	// heavily inspired from @darius gist mod: https://gist.github.com/paulirish/1579671#comment-837945
	if (!requestAnimationFrame || !cancelAnimationFrame) {
		requestAnimationFrame = function(callback) {
			var now = +new Date(), nextTime = Math.max(lastTime + 16, now);
			return setTimeout(function() {
				callback(lastTime = nextTime);
			}, nextTime - now);
		};

		cancelAnimationFrame = clearTimeout;
	}

	// export to window
	window.requestAnimationFrame = requestAnimationFrame;
	window.cancelAnimationFrame = cancelAnimationFrame;
}(window));

},{}],"/projects/blackice/node_modules/randf/index.js":[function(require,module,exports){
function random(start, end) {
    var n0 = typeof start === 'number',
        n1 = typeof end === 'number'

    if (n0 && !n1) {
        end = start
        start = 0
    } else if (!n0 && !n1) {
        start = 0
        end = 1
    }
    return start + Math.random() * (end - start)
}

module.exports = random
},{}],"/projects/blackice/node_modules/simplify-path/douglas-peucker.js":[function(require,module,exports){
// square distance from a point to a segment
function getSqSegDist(p, p1, p2) {
    var x = p1[0],
        y = p1[1],
        dx = p2[0] - x,
        dy = p2[1] - y;

    if (dx !== 0 || dy !== 0) {

        var t = ((p[0] - x) * dx + (p[1] - y) * dy) / (dx * dx + dy * dy);

        if (t > 1) {
            x = p2[0];
            y = p2[1];

        } else if (t > 0) {
            x += dx * t;
            y += dy * t;
        }
    }

    dx = p[0] - x;
    dy = p[1] - y;

    return dx * dx + dy * dy;
}

// simplification using optimized Douglas-Peucker algorithm with recursion elimination
module.exports = function simplifyDouglasPeucker(points, tolerance) {
    if (points.length<=1)
        return points;
    tolerance = typeof tolerance === 'number' ? tolerance : 1;
    var sqTolerance = tolerance * tolerance;

    var len = points.length,
        MarkerArray = typeof Uint8Array !== 'undefined' ? Uint8Array : Array,
        markers = new MarkerArray(len),
        first = 0,
        last = len - 1,
        stack = [],
        newPoints = [],
        i, maxSqDist, sqDist, index;

    markers[first] = markers[last] = 1;

    while (last) {

        maxSqDist = 0;

        for (i = first + 1; i < last; i++) {
            sqDist = getSqSegDist(points[i], points[first], points[last]);

            if (sqDist > maxSqDist) {
                index = i;
                maxSqDist = sqDist;
            }
        }

        if (maxSqDist > sqTolerance) {
            markers[index] = 1;
            stack.push(first, index, index, last);
        }

        last = stack.pop();
        first = stack.pop();
    }

    for (i = 0; i < len; i++) {
        if (markers[i]) newPoints.push(points[i]);
    }

    return newPoints;
}
},{}],"/projects/blackice/node_modules/simplify-path/index.js":[function(require,module,exports){
var simplifyRadialDist = require('./radial-distance')
var simplifyDouglasPeucker = require('./douglas-peucker')

//simplifies using both algorithms
module.exports = function simplify(points, tolerance) {
    points = simplifyRadialDist(points, tolerance);
    points = simplifyDouglasPeucker(points, tolerance);
    return points;
}

module.exports.radialDistance = simplifyRadialDist;
module.exports.douglasPeucker = simplifyDouglasPeucker;
},{"./douglas-peucker":"/projects/blackice/node_modules/simplify-path/douglas-peucker.js","./radial-distance":"/projects/blackice/node_modules/simplify-path/radial-distance.js"}],"/projects/blackice/node_modules/simplify-path/radial-distance.js":[function(require,module,exports){
function getSqDist(p1, p2) {
    var dx = p1[0] - p2[0],
        dy = p1[1] - p2[1];

    return dx * dx + dy * dy;
}

// basic distance-based simplification
module.exports = function simplifyRadialDist(points, tolerance) {
    if (points.length<=1)
        return points;
    tolerance = typeof tolerance === 'number' ? tolerance : 1;
    var sqTolerance = tolerance * tolerance;
    
    var prevPoint = points[0],
        newPoints = [prevPoint],
        point;

    for (var i = 1, len = points.length; i < len; i++) {
        point = points[i];

        if (getSqDist(point, prevPoint) > sqTolerance) {
            newPoints.push(point);
            prevPoint = point;
        }
    }

    if (prevPoint !== point) newPoints.push(point);

    return newPoints;
}
},{}],"/projects/blackice/node_modules/smoothstep/index.js":[function(require,module,exports){
module.exports = function smoothstep (min, max, value) {
  var x = Math.max(0, Math.min(1, (value-min)/(max-min)));
  return x*x*(3 - 2*x);
};

},{}],"/projects/blackice/node_modules/svg-path-contours/index.js":[function(require,module,exports){
var bezier = require('adaptive-bezier-curve')
var abs = require('abs-svg-path')
var norm = require('normalize-svg-path')
var copy = require('vec2-copy')

function set(out, x, y) {
    out[0] = x
    out[1] = y
    return out
}

var tmp1 = [0,0],
    tmp2 = [0,0],
    tmp3 = [0,0]

function bezierTo(points, scale, start, seg) {
    bezier(start, 
        set(tmp1, seg[1], seg[2]), 
        set(tmp2, seg[3], seg[4]),
        set(tmp3, seg[5], seg[6]), scale, points)
}

module.exports = function contours(svg, scale) {
    var paths = []

    var points = []
    var pen = [0, 0]
    norm(abs(svg)).forEach(function(segment, i, self) {
        if (segment[0] === 'M') {
            copy(pen, segment.slice(1))
            if (points.length>0) {
                paths.push(points)
                points = []
            }
            points.push(pen)
        } else if (segment[0] === 'C') {
            bezierTo(points, scale, pen, segment)
            set(pen, segment[5], segment[6])
        } else {
            throw new Error('illegal type in SVG: '+segment[0])
        }
    })
    if (points.length>0)
        paths.push(points)
    return paths
}
},{"abs-svg-path":"/projects/blackice/node_modules/svg-path-contours/node_modules/abs-svg-path/index.js","adaptive-bezier-curve":"/projects/blackice/node_modules/svg-path-contours/node_modules/adaptive-bezier-curve/index.js","normalize-svg-path":"/projects/blackice/node_modules/svg-path-contours/node_modules/normalize-svg-path/index.js","vec2-copy":"/projects/blackice/node_modules/svg-path-contours/node_modules/vec2-copy/index.js"}],"/projects/blackice/node_modules/svg-path-contours/node_modules/abs-svg-path/index.js":[function(require,module,exports){

module.exports = absolutize

/**
 * redefine `path` with absolute coordinates
 *
 * @param {Array} path
 * @return {Array}
 */

function absolutize(path){
	var startX = 0
	var startY = 0
	var x = 0
	var y = 0

	return path.map(function(seg){
		seg = seg.slice()
		var type = seg[0]
		var command = type.toUpperCase()

		// is relative
		if (type != command) {
			seg[0] = command
			switch (type) {
				case 'a':
					seg[6] += x
					seg[7] += y
					break
				case 'v':
					seg[1] += y
					break
				case 'h':
					seg[1] += x
					break
				default:
					for (var i = 1; i < seg.length;) {
						seg[i++] += x
						seg[i++] += y
					}
			}
		}

		// update cursor state
		switch (command) {
			case 'Z':
				x = startX
				y = startY
				break
			case 'H':
				x = seg[1]
				break
			case 'V':
				y = seg[1]
				break
			case 'M':
				x = startX = seg[1]
				y = startY = seg[2]
				break
			default:
				x = seg[seg.length - 2]
				y = seg[seg.length - 1]
		}

		return seg
	})
}

},{}],"/projects/blackice/node_modules/svg-path-contours/node_modules/adaptive-bezier-curve/function.js":[function(require,module,exports){
function clone(point) { //TODO: use gl-vec2 for this
    return [point[0], point[1]]
}

function vec2(x, y) {
    return [x, y]
}

module.exports = function createBezierBuilder(opt) {
    opt = opt||{}

    var RECURSION_LIMIT = typeof opt.recursion === 'number' ? opt.recursion : 8
    var FLT_EPSILON = typeof opt.epsilon === 'number' ? opt.epsilon : 1.19209290e-7
    var PATH_DISTANCE_EPSILON = typeof opt.pathEpsilon === 'number' ? opt.pathEpsilon : 1.0

    var curve_angle_tolerance_epsilon = typeof opt.angleEpsilon === 'number' ? opt.angleEpsilon : 0.01
    var m_angle_tolerance = opt.angleTolerance || 0
    var m_cusp_limit = opt.cuspLimit || 0

    return function bezierCurve(start, c1, c2, end, scale, points) {
        if (!points)
            points = []

        scale = typeof scale === 'number' ? scale : 1.0
        var distanceTolerance = PATH_DISTANCE_EPSILON / scale
        distanceTolerance *= distanceTolerance
        begin(start, c1, c2, end, points, distanceTolerance)
        return points
    }


    ////// Based on:
    ////// https://github.com/pelson/antigrain/blob/master/agg-2.4/src/agg_curves.cpp

    function begin(start, c1, c2, end, points, distanceTolerance) {
        points.push(clone(start))
        var x1 = start[0],
            y1 = start[1],
            x2 = c1[0],
            y2 = c1[1],
            x3 = c2[0],
            y3 = c2[1],
            x4 = end[0],
            y4 = end[1]
        recursive(x1, y1, x2, y2, x3, y3, x4, y4, points, distanceTolerance, 0)
        points.push(clone(end))
    }

    function recursive(x1, y1, x2, y2, x3, y3, x4, y4, points, distanceTolerance, level) {
        if(level > RECURSION_LIMIT) 
            return

        var pi = Math.PI

        // Calculate all the mid-points of the line segments
        //----------------------
        var x12   = (x1 + x2) / 2
        var y12   = (y1 + y2) / 2
        var x23   = (x2 + x3) / 2
        var y23   = (y2 + y3) / 2
        var x34   = (x3 + x4) / 2
        var y34   = (y3 + y4) / 2
        var x123  = (x12 + x23) / 2
        var y123  = (y12 + y23) / 2
        var x234  = (x23 + x34) / 2
        var y234  = (y23 + y34) / 2
        var x1234 = (x123 + x234) / 2
        var y1234 = (y123 + y234) / 2

        if(level > 0) { // Enforce subdivision first time
            // Try to approximate the full cubic curve by a single straight line
            //------------------
            var dx = x4-x1
            var dy = y4-y1

            var d2 = Math.abs((x2 - x4) * dy - (y2 - y4) * dx)
            var d3 = Math.abs((x3 - x4) * dy - (y3 - y4) * dx)

            var da1, da2

            if(d2 > FLT_EPSILON && d3 > FLT_EPSILON) {
                // Regular care
                //-----------------
                if((d2 + d3)*(d2 + d3) <= distanceTolerance * (dx*dx + dy*dy)) {
                    // If the curvature doesn't exceed the distanceTolerance value
                    // we tend to finish subdivisions.
                    //----------------------
                    if(m_angle_tolerance < curve_angle_tolerance_epsilon) {
                        points.push(vec2(x1234, y1234))
                        return
                    }

                    // Angle & Cusp Condition
                    //----------------------
                    var a23 = Math.atan2(y3 - y2, x3 - x2)
                    da1 = Math.abs(a23 - Math.atan2(y2 - y1, x2 - x1))
                    da2 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - a23)
                    if(da1 >= pi) da1 = 2*pi - da1
                    if(da2 >= pi) da2 = 2*pi - da2

                    if(da1 + da2 < m_angle_tolerance) {
                        // Finally we can stop the recursion
                        //----------------------
                        points.push(vec2(x1234, y1234))
                        return
                    }

                    if(m_cusp_limit !== 0.0) {
                        if(da1 > m_cusp_limit) {
                            points.push(vec2(x2, y2))
                            return
                        }

                        if(da2 > m_cusp_limit) {
                            points.push(vec2(x3, y3))
                            return
                        }
                    }
                }
            }
            else {
                if(d2 > FLT_EPSILON) {
                    // p1,p3,p4 are collinear, p2 is considerable
                    //----------------------
                    if(d2 * d2 <= distanceTolerance * (dx*dx + dy*dy)) {
                        if(m_angle_tolerance < curve_angle_tolerance_epsilon) {
                            points.push(vec2(x1234, y1234))
                            return
                        }

                        // Angle Condition
                        //----------------------
                        da1 = Math.abs(Math.atan2(y3 - y2, x3 - x2) - Math.atan2(y2 - y1, x2 - x1))
                        if(da1 >= pi) da1 = 2*pi - da1

                        if(da1 < m_angle_tolerance) {
                            points.push(vec2(x2, y2))
                            points.push(vec2(x3, y3))
                            return
                        }

                        if(m_cusp_limit !== 0.0) {
                            if(da1 > m_cusp_limit) {
                                points.push(vec2(x2, y2))
                                return
                            }
                        }
                    }
                }
                else if(d3 > FLT_EPSILON) {
                    // p1,p2,p4 are collinear, p3 is considerable
                    //----------------------
                    if(d3 * d3 <= distanceTolerance * (dx*dx + dy*dy)) {
                        if(m_angle_tolerance < curve_angle_tolerance_epsilon) {
                            points.push(vec2(x1234, y1234))
                            return
                        }

                        // Angle Condition
                        //----------------------
                        da1 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - Math.atan2(y3 - y2, x3 - x2))
                        if(da1 >= pi) da1 = 2*pi - da1

                        if(da1 < m_angle_tolerance) {
                            points.push(vec2(x2, y2))
                            points.push(vec2(x3, y3))
                            return
                        }

                        if(m_cusp_limit !== 0.0) {
                            if(da1 > m_cusp_limit)
                            {
                                points.push(vec2(x3, y3))
                                return
                            }
                        }
                    }
                }
                else {
                    // Collinear case
                    //-----------------
                    dx = x1234 - (x1 + x4) / 2
                    dy = y1234 - (y1 + y4) / 2
                    if(dx*dx + dy*dy <= distanceTolerance) {
                        points.push(vec2(x1234, y1234))
                        return
                    }
                }
            }
        }

        // Continue subdivision
        //----------------------
        recursive(x1, y1, x12, y12, x123, y123, x1234, y1234, points, distanceTolerance, level + 1) 
        recursive(x1234, y1234, x234, y234, x34, y34, x4, y4, points, distanceTolerance, level + 1) 
    }
}

},{}],"/projects/blackice/node_modules/svg-path-contours/node_modules/adaptive-bezier-curve/index.js":[function(require,module,exports){
module.exports = require('./function')()
},{"./function":"/projects/blackice/node_modules/svg-path-contours/node_modules/adaptive-bezier-curve/function.js"}],"/projects/blackice/node_modules/svg-path-contours/node_modules/normalize-svg-path/index.js":[function(require,module,exports){

var π = Math.PI
var _120 = radians(120)

module.exports = normalize

/**
 * describe `path` in terms of cubic bézier 
 * curves and move commands
 *
 * @param {Array} path
 * @return {Array}
 */

function normalize(path){
	// init state
	var prev
	var result = []
	var bezierX = 0
	var bezierY = 0
	var startX = 0
	var startY = 0
	var quadX = null
	var quadY = null
	var x = 0
	var y = 0

	for (var i = 0, len = path.length; i < len; i++) {
		var seg = path[i]
		var command = seg[0]
		switch (command) {
			case 'M':
				startX = seg[1]
				startY = seg[2]
				break
			case 'A':
				seg = arc(x, y,seg[1],seg[2],radians(seg[3]),seg[4],seg[5],seg[6],seg[7])
				// split multi part
				seg.unshift('C')
				if (seg.length > 7) {
					result.push(seg.splice(0, 7))
					seg.unshift('C')
				}
				break
			case 'S':
				// default control point
				var cx = x
				var cy = y
				if (prev == 'C' || prev == 'S') {
					cx += cx - bezierX // reflect the previous command's control
					cy += cy - bezierY // point relative to the current point
				}
				seg = ['C', cx, cy, seg[1], seg[2], seg[3], seg[4]]
				break
			case 'T':
				if (prev == 'Q' || prev == 'T') {
					quadX = x * 2 - quadX // as with 'S' reflect previous control point
					quadY = y * 2 - quadY
				} else {
					quadX = x
					quadY = y
				}
				seg = quadratic(x, y, quadX, quadY, seg[1], seg[2])
				break
			case 'Q':
				quadX = seg[1]
				quadY = seg[2]
				seg = quadratic(x, y, seg[1], seg[2], seg[3], seg[4])
				break
			case 'L':
				seg = line(x, y, seg[1], seg[2])
				break
			case 'H':
				seg = line(x, y, seg[1], y)
				break
			case 'V':
				seg = line(x, y, x, seg[1])
				break
			case 'Z':
				seg = line(x, y, startX, startY)
				break
		}

		// update state
		prev = command
		x = seg[seg.length - 2]
		y = seg[seg.length - 1]
		if (seg.length > 4) {
			bezierX = seg[seg.length - 4]
			bezierY = seg[seg.length - 3]
		} else {
			bezierX = x
			bezierY = y
		}
		result.push(seg)
	}

	return result
}

function line(x1, y1, x2, y2){
	return ['C', x1, y1, x2, y2, x2, y2]
}

function quadratic(x1, y1, cx, cy, x2, y2){
	return [
		'C',
		x1/3 + (2/3) * cx,
		y1/3 + (2/3) * cy,
		x2/3 + (2/3) * cx,
		y2/3 + (2/3) * cy,
		x2,
		y2
	]
}

// This function is ripped from 
// github.com/DmitryBaranovskiy/raphael/blob/4d97d4/raphael.js#L2216-L2304 
// which references w3.org/TR/SVG11/implnote.html#ArcImplementationNotes
// TODO: make it human readable

function arc(x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {
	if (!recursive) {
		var xy = rotate(x1, y1, -angle)
		x1 = xy.x
		y1 = xy.y
		xy = rotate(x2, y2, -angle)
		x2 = xy.x
		y2 = xy.y
		var x = (x1 - x2) / 2
		var y = (y1 - y2) / 2
		var h = (x * x) / (rx * rx) + (y * y) / (ry * ry)
		if (h > 1) {
			h = Math.sqrt(h)
			rx = h * rx
			ry = h * ry
		}
		var rx2 = rx * rx
		var ry2 = ry * ry
		var k = (large_arc_flag == sweep_flag ? -1 : 1)
			* Math.sqrt(Math.abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x)))
		if (k == Infinity) k = 1 // neutralize
		var cx = k * rx * y / ry + (x1 + x2) / 2
		var cy = k * -ry * x / rx + (y1 + y2) / 2
		var f1 = Math.asin(((y1 - cy) / ry).toFixed(9))
		var f2 = Math.asin(((y2 - cy) / ry).toFixed(9))

		f1 = x1 < cx ? π - f1 : f1
		f2 = x2 < cx ? π - f2 : f2
		if (f1 < 0) f1 = π * 2 + f1
		if (f2 < 0) f2 = π * 2 + f2
		if (sweep_flag && f1 > f2) f1 = f1 - π * 2
		if (!sweep_flag && f2 > f1) f2 = f2 - π * 2
	} else {
		f1 = recursive[0]
		f2 = recursive[1]
		cx = recursive[2]
		cy = recursive[3]
	}
	// greater than 120 degrees requires multiple segments
	if (Math.abs(f2 - f1) > _120) {
		var f2old = f2
		var x2old = x2
		var y2old = y2
		f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1)
		x2 = cx + rx * Math.cos(f2)
		y2 = cy + ry * Math.sin(f2)
		var res = arc(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy])
	}
	var t = Math.tan((f2 - f1) / 4)
	var hx = 4 / 3 * rx * t
	var hy = 4 / 3 * ry * t
	var curve = [
		2 * x1 - (x1 + hx * Math.sin(f1)),
		2 * y1 - (y1 - hy * Math.cos(f1)),
		x2 + hx * Math.sin(f2),
		y2 - hy * Math.cos(f2),
		x2,
		y2
	]
	if (recursive) return curve
	if (res) curve = curve.concat(res)
	for (var i = 0; i < curve.length;) {
		var rot = rotate(curve[i], curve[i+1], angle)
		curve[i++] = rot.x
		curve[i++] = rot.y
	}
	return curve
}

function rotate(x, y, rad){
	return {
		x: x * Math.cos(rad) - y * Math.sin(rad),
		y: x * Math.sin(rad) + y * Math.cos(rad)
	}
}

function radians(degress){
	return degress * (π / 180)
}

},{}],"/projects/blackice/node_modules/svg-path-contours/node_modules/vec2-copy/index.js":[function(require,module,exports){
module.exports = function vec2Copy(out, a) {
    out[0] = a[0]
    out[1] = a[1]
    return out
}
},{}],"/projects/blackice/node_modules/three-effectcomposer/index.js":[function(require,module,exports){
/**
 * @author alteredq / http://alteredqualia.com/
 */

module.exports = function(THREE) {
  var CopyShader = EffectComposer.CopyShader = require('three-copyshader')
    , RenderPass = EffectComposer.RenderPass = require('./lib/renderpass')(THREE)
    , ShaderPass = EffectComposer.ShaderPass = require('./lib/shaderpass')(THREE, EffectComposer)
    , MaskPass = EffectComposer.MaskPass = require('./lib/maskpass')(THREE)
    , ClearMaskPass = EffectComposer.ClearMaskPass = require('./lib/clearmaskpass')(THREE)

  function EffectComposer( renderer, renderTarget ) {
    this.renderer = renderer;

    if ( renderTarget === undefined ) {
      var width = window.innerWidth || 1;
      var height = window.innerHeight || 1;
      var parameters = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBFormat, stencilBuffer: false };

      renderTarget = new THREE.WebGLRenderTarget( width, height, parameters );
    }

    this.renderTarget1 = renderTarget;
    this.renderTarget2 = renderTarget.clone();

    this.writeBuffer = this.renderTarget1;
    this.readBuffer = this.renderTarget2;

    this.passes = [];

    this.copyPass = new ShaderPass( CopyShader );
  };

  EffectComposer.prototype = {
    swapBuffers: function() {

      var tmp = this.readBuffer;
      this.readBuffer = this.writeBuffer;
      this.writeBuffer = tmp;

    },

    addPass: function ( pass ) {

      this.passes.push( pass );

    },

    insertPass: function ( pass, index ) {

      this.passes.splice( index, 0, pass );

    },

    render: function ( delta ) {

      this.writeBuffer = this.renderTarget1;
      this.readBuffer = this.renderTarget2;

      var maskActive = false;

      var pass, i, il = this.passes.length;

      for ( i = 0; i < il; i ++ ) {

        pass = this.passes[ i ];

        if ( !pass.enabled ) continue;

        pass.render( this.renderer, this.writeBuffer, this.readBuffer, delta, maskActive );

        if ( pass.needsSwap ) {

          if ( maskActive ) {

            var context = this.renderer.context;

            context.stencilFunc( context.NOTEQUAL, 1, 0xffffffff );

            this.copyPass.render( this.renderer, this.writeBuffer, this.readBuffer, delta );

            context.stencilFunc( context.EQUAL, 1, 0xffffffff );

          }

          this.swapBuffers();

        }

        if ( pass instanceof MaskPass ) {

          maskActive = true;

        } else if ( pass instanceof ClearMaskPass ) {

          maskActive = false;

        }

      }

    },

    reset: function ( renderTarget ) {

      if ( renderTarget === undefined ) {

        renderTarget = this.renderTarget1.clone();

        renderTarget.width = window.innerWidth;
        renderTarget.height = window.innerHeight;

      }

      this.renderTarget1 = renderTarget;
      this.renderTarget2 = renderTarget.clone();

      this.writeBuffer = this.renderTarget1;
      this.readBuffer = this.renderTarget2;

    },

    setSize: function ( width, height ) {

      var renderTarget = this.renderTarget1.clone();

      renderTarget.width = width;
      renderTarget.height = height;

      this.reset( renderTarget );

    }

  };

  // shared ortho camera

  EffectComposer.camera = new THREE.OrthographicCamera( -1, 1, 1, -1, 0, 1 );

  EffectComposer.quad = new THREE.Mesh( new THREE.PlaneGeometry( 2, 2 ), null );

  EffectComposer.scene = new THREE.Scene();
  EffectComposer.scene.add( EffectComposer.quad );

  return EffectComposer
};
},{"./lib/clearmaskpass":"/projects/blackice/node_modules/three-effectcomposer/lib/clearmaskpass.js","./lib/maskpass":"/projects/blackice/node_modules/three-effectcomposer/lib/maskpass.js","./lib/renderpass":"/projects/blackice/node_modules/three-effectcomposer/lib/renderpass.js","./lib/shaderpass":"/projects/blackice/node_modules/three-effectcomposer/lib/shaderpass.js","three-copyshader":"/projects/blackice/node_modules/three-effectcomposer/node_modules/three-copyshader/index.js"}],"/projects/blackice/node_modules/three-effectcomposer/lib/clearmaskpass.js":[function(require,module,exports){
/**
 * @author alteredq / http://alteredqualia.com/
 */

module.exports = function(THREE) {
  function ClearMaskPass() {
    if (!(this instanceof ClearMaskPass)) return new ClearMaskPass(scene, camera);
    this.enabled = true;
  };

  ClearMaskPass.prototype = {
    render: function ( renderer, writeBuffer, readBuffer, delta ) {
      var context = renderer.context;
      context.disable( context.STENCIL_TEST );
    }
  };

  return ClearMaskPass
};
},{}],"/projects/blackice/node_modules/three-effectcomposer/lib/maskpass.js":[function(require,module,exports){
/**
 * @author alteredq / http://alteredqualia.com/
 */

module.exports = function(THREE) {
  function MaskPass( scene, camera ) {
    if (!(this instanceof MaskPass)) return new MaskPass(scene, camera);

    this.scene = scene;
    this.camera = camera;

    this.enabled = true;
    this.clear = true;
    this.needsSwap = false;

    this.inverse = false;
  };

  MaskPass.prototype = {

    render: function ( renderer, writeBuffer, readBuffer, delta ) {

      var context = renderer.context;

      // don't update color or depth

      context.colorMask( false, false, false, false );
      context.depthMask( false );

      // set up stencil

      var writeValue, clearValue;

      if ( this.inverse ) {

        writeValue = 0;
        clearValue = 1;

      } else {

        writeValue = 1;
        clearValue = 0;

      }

      context.enable( context.STENCIL_TEST );
      context.stencilOp( context.REPLACE, context.REPLACE, context.REPLACE );
      context.stencilFunc( context.ALWAYS, writeValue, 0xffffffff );
      context.clearStencil( clearValue );

      // draw into the stencil buffer

      renderer.render( this.scene, this.camera, readBuffer, this.clear );
      renderer.render( this.scene, this.camera, writeBuffer, this.clear );

      // re-enable update of color and depth

      context.colorMask( true, true, true, true );
      context.depthMask( true );

      // only render where stencil is set to 1

      context.stencilFunc( context.EQUAL, 1, 0xffffffff );  // draw if == 1
      context.stencilOp( context.KEEP, context.KEEP, context.KEEP );

    }

  };

  return MaskPass
};

},{}],"/projects/blackice/node_modules/three-effectcomposer/lib/renderpass.js":[function(require,module,exports){
/**
 * @author alteredq / http://alteredqualia.com/
 */

module.exports = function(THREE) {
  function RenderPass( scene, camera, overrideMaterial, clearColor, clearAlpha ) {
    if (!(this instanceof RenderPass)) return new RenderPass(scene, camera, overrideMaterial, clearColor, clearAlpha);

    this.scene = scene;
    this.camera = camera;

    this.overrideMaterial = overrideMaterial;

    this.clearColor = clearColor;
    this.clearAlpha = ( clearAlpha !== undefined ) ? clearAlpha : 1;

    this.oldClearColor = new THREE.Color();
    this.oldClearAlpha = 1;

    this.enabled = true;
    this.clear = true;
    this.needsSwap = false;

  };

  RenderPass.prototype = {

    render: function ( renderer, writeBuffer, readBuffer, delta ) {

      this.scene.overrideMaterial = this.overrideMaterial;

      if ( this.clearColor ) {

        this.oldClearColor.copy( renderer.getClearColor() );
        this.oldClearAlpha = renderer.getClearAlpha();

        renderer.setClearColor( this.clearColor, this.clearAlpha );

      }

      renderer.render( this.scene, this.camera, readBuffer, this.clear );

      if ( this.clearColor ) {

        renderer.setClearColor( this.oldClearColor, this.oldClearAlpha );

      }

      this.scene.overrideMaterial = null;

    }

  };

  return RenderPass;

};

},{}],"/projects/blackice/node_modules/three-effectcomposer/lib/shaderpass.js":[function(require,module,exports){
/**
 * @author alteredq / http://alteredqualia.com/
 */

module.exports = function(THREE, EffectComposer) {
  function ShaderPass( shader, textureID ) {
    if (!(this instanceof ShaderPass)) return new ShaderPass(shader, textureID);

    this.textureID = ( textureID !== undefined ) ? textureID : "tDiffuse";

    this.uniforms = THREE.UniformsUtils.clone( shader.uniforms );

    this.material = new THREE.ShaderMaterial( {

      uniforms: this.uniforms,
      vertexShader: shader.vertexShader,
      fragmentShader: shader.fragmentShader

    } );

    this.renderToScreen = false;

    this.enabled = true;
    this.needsSwap = true;
    this.clear = false;

  };

  ShaderPass.prototype = {

    render: function ( renderer, writeBuffer, readBuffer, delta ) {

      if ( this.uniforms[ this.textureID ] ) {

        this.uniforms[ this.textureID ].value = readBuffer;

      }

      EffectComposer.quad.material = this.material;

      if ( this.renderToScreen ) {

        renderer.render( EffectComposer.scene, EffectComposer.camera );

      } else {

        renderer.render( EffectComposer.scene, EffectComposer.camera, writeBuffer, this.clear );

      }

    }

  };

  return ShaderPass;

};
},{}],"/projects/blackice/node_modules/three-effectcomposer/node_modules/three-copyshader/index.js":[function(require,module,exports){
/**
 * @author alteredq / http://alteredqualia.com/
 *
 * Full-screen textured quad shader
 */

module.exports = {
  uniforms: {
    "tDiffuse": { type: "t", value: null },
    "opacity":  { type: "f", value: 1.0 }
  },
  vertexShader: [
    "varying vec2 vUv;",

    "void main() {",

      "vUv = uv;",
      "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

    "}"
  ].join("\n"),
  fragmentShader: [
    "uniform float opacity;",

    "uniform sampler2D tDiffuse;",

    "varying vec2 vUv;",

    "void main() {",

      "vec4 texel = texture2D( tDiffuse, vUv );",
      "gl_FragColor = opacity * texel;",

    "}"
  ].join("\n")
};

},{}],"/projects/blackice/node_modules/three-glslify/index.js":[function(require,module,exports){
var createTypes = require('./types')


module.exports = function(THREE) {

    var types = createTypes(THREE) 

    return function create(glShader, opts) {
        opts = opts||{}

        if (typeof opts.colors === 'string')
            opts.colors = [opts.colors]
        
        var tUniforms = types( glShader.uniforms, opts.colors )
        var tAttribs = types( glShader.attributes, opts.colors )
            
        //clear the attribute arrays
        for (var k in tAttribs) {
            tAttribs[k].value = []
        }

        return {
            vertexShader: glShader.vertex,
            fragmentShader: glShader.fragment,
            uniforms: tUniforms,
            attributes: tAttribs
        }
    }
}
},{"./types":"/projects/blackice/node_modules/three-glslify/types.js"}],"/projects/blackice/node_modules/three-glslify/types.js":[function(require,module,exports){
var typeMap = {
    'int': 'i',
    'float': 'f',
    'ivec2': 'i2',
    'ivec3': 'i3',
    'ivec4': 'i4',
    'vec2': 'v2',
    'vec3': 'v3',
    'vec4': 'v4',
    'mat4': 'm4',
    'mat3': 'm3',
    'sampler2D': 't',
    'samplerCube': 't'
}

function create(THREE) {
    function newInstance(type, isArray) {
        switch (type) {
            case 'float': 
            case 'int':
                return 0
            case 'vec2':
            case 'ivec2':
                return new THREE.Vector2()
            case 'vec3':
            case 'ivec3':
                return new THREE.Vector3()
            case 'vec4':
            case 'ivec4':
                return new THREE.Vector4()
            case 'mat4':
                return new THREE.Matrix4()
            case 'mat3':
                return new THREE.Matrix3()
            case 'samplerCube':
            case 'sampler2D':
                return new THREE.Texture()
            default:
                return undefined
        }
    }

    function defaultValue(type, isArray, arrayLen) {
        if (isArray) {
            //ThreeJS flattens ivec3 type
            //(we don't support 'fv' type)
            if (type === 'ivec3')
                arrayLen *= 3
            var ar = new Array(arrayLen)
            for (var i=0; i<ar.length; i++)
                ar[i] = newInstance(type, isArray)
            return ar
        }  
        return newInstance(type)
    }

    function getType(type, isArray) {
        if (!isArray)
            return typeMap[type]

        if (type === 'int')
            return 'iv1'
        else if (type === 'float')
            return 'fv1'
        else
            return typeMap[type]+'v'
    }

    return function setupUniforms(glUniforms, colorNames) {
        if (!Array.isArray(colorNames))
            colorNames = Array.prototype.slice.call(arguments, 1)

        var result = {}
        var arrays = {}

        //map uniform types
        glUniforms.forEach(function(uniform) {
            var name = uniform.name
            var isArray = /(.+)\[[0-9]+\]/.exec(name)

            //special case: colors...
            if (colorNames && colorNames.indexOf(name) !== -1) {
                if (isArray)
                    throw new Error("array of color uniforms not supported")
                if (uniform.type !== 'vec3')
                    throw new Error("ThreeJS expects vec3 for Color uniforms") 
                result[name] = {
                    type: 'c',
                    value: new THREE.Color()
                }
                return
            }

            if (isArray) {
                name = isArray[1]
                if (name in arrays) 
                    arrays[name].count++ 
                else
                    arrays[name] = { count: 1, type: uniform.type }
            }
            result[name] = { 
                type: getType(uniform.type, isArray), 
                value: isArray ? null : defaultValue(uniform.type) 
            }
        })

        //now clean up any array values
        for (var k in result) {
            var u = result[k]
            if (k in arrays) { //is an array
                var a = arrays[k]
                u.value = defaultValue(a.type, true, a.count)
            }
        }
        return result
    }
}

module.exports = create
},{}],"/projects/blackice/node_modules/three-sdf-text/index.js":[function(require,module,exports){
module.exports = require('./lib/renderer')
},{"./lib/renderer":"/projects/blackice/node_modules/three-sdf-text/lib/renderer.js"}],"/projects/blackice/node_modules/three-sdf-text/lib/renderer.js":[function(require,module,exports){
var createText = require('gl-sprite-text')
var mat4 = {
    create: require('gl-mat4/create'),
    scale: require('gl-mat4/scale'),
    multiply: require('gl-mat4/multiply')
}

var modelTransform = mat4.create()
var flip = mat4.create()
mat4.scale(flip, flip, [1, -1, 1])

var WrapTexture = require('./texture-wrap')
var number = require('as-number')
var xtend = require('xtend')

var createShader = require('gl-shader-core')


//nasty temp hack until #971 is fixed
var vertex = 'attribute vec4 position;\nattribute vec4 color;\nattribute vec2 texcoord0;\n\nuniform mat4 projection;\nuniform mat4 view;\nuniform mat4 model;\n\nvarying vec4 v_col;\nvarying vec2 v_tex0;\n\nvoid main() {\n gl_Position = projection * view * model * position;\n v_col = color;\n v_tex0 = texcoord0;\n gl_PointSize = 1.0;\n}'
var fragment = '#ifdef GL_ES\nprecision mediump float;\n#endif\n\nvarying vec4 v_col;\nvarying vec2 v_tex0;\nuniform sampler2D texture0;\n\nuniform float smoothing;\n// = 1.0/32.0;\n\n// drop shadow computed in fragment shader\nvoid main() {\n vec4 texColor = texture2D(texture0, v_tex0);\n\n float dst = texColor.a;\n float alpha = smoothstep(0.5 - smoothing, 0.5 + smoothing, dst);\n vec4 base = v_col * vec4(alpha);\n\n gl_FragColor = base;\n if (gl_FragColor.a<0.1)\n discard;\n}'

var uniforms = [
        { type: 'float', name: 'smoothing' },
        { type: 'sampler2D', name: 'texture0' },
        { type: 'mat4', name: 'projection' },
        { type: 'mat4', name: 'view' },
        { type: 'mat4', name: 'model' }        
    ],
    attributes = [
        { type: 'vec4', name: 'position' },
        { type: 'vec4', name: 'color' },
        { type: 'vec2', name: 'texcoord0' }
    ]



function copyColor(out, color, opacity) {
    out[0] = color.r
    out[1] = color.g 
    out[2] = color.b 
    out[3] = opacity
}

module.exports = function(THREE) {
    var sharedShader

    function TextRenderer(renderer, opt) {
        if (!(this instanceof TextRenderer))
            return new TextRenderer(renderer, opt)
        opt=opt||{}

        var gl = renderer.getContext()
        this.gl = gl
        this.color = new THREE.Color()
        if (opt.color !== null && typeof opt.color !== 'undefined')
            this.color.set(opt.color)
        this.opacity = number(opt.opacity, 1.0)

        //if no textures are given, presume they are base64 packed
        //into the Font object (like with bmfont-lato)
        var textOpts = xtend(opt)
        if (textOpts.textures) {
            textOpts.textures = textOpts.textures.map(function(tex) {
                // return require('gl-texture2d')(gl, tex.image)
                if (tex instanceof THREE.Texture)
                    return WrapTexture(renderer, tex)
                return tex
            })
        }
        
        this.element = createText(gl, textOpts)
        this.transform = mat4.create()

        if (!sharedShader && !opt.shader)
            sharedShader = createShader(gl, vertex, fragment, uniforms, attributes)
        this.shader = opt.shader || sharedShader
        this.shader.bind()

        this.padding = number(opt.padding, 0)

        var s = number(opt.smoothing, 1.0/32.0)
        this.shader.uniforms.smoothing = s
        this.shader.uniforms.texture0 = 0
    }

    TextRenderer.prototype.draw = function(camera, object) {
        var gl = this.gl

        if (!object.visible)
            return

        if (!this.element.textures || this.element.textures.length === 0)
            return

        gl.enable(gl.BLEND)
        // gl.bindFramebuffer(gl.FRAMEBUFFER, null)

        gl.enable(gl.DEPTH_TEST)
        gl.depthFunc(gl.LEQUAL)

        // gl.frontFace( gl.CCW )    
        gl.enable(gl.CULL_FACE)
        // gl.cullFace( gl.FRONT )
        gl.colorMask(true, true, true, true)
        gl.disable(gl.STENCIL_TEST)
        gl.activeTexture(gl.TEXTURE0)
        gl.depthMask(true)
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA)

        this.shader.bind()
        this.element.textures[0].bind(0)

        // gl.colorMask(true, true, true, true)

        gl.cullFace(gl.FRONT)

        mat4.multiply(modelTransform, object.matrixWorld.elements, this.transform)
        mat4.multiply(modelTransform, modelTransform, flip)

        this.shader.bind()
        this.shader.uniforms.projection = camera.projectionMatrix.elements
        this.shader.uniforms.view = camera.matrixWorldInverse.elements
        this.shader.uniforms.model = modelTransform
            
        copyColor(this.element.batch.color, this.color, this.opacity)
        this.element.draw(this.shader, this.padding, this.padding)

        gl.cullFace( gl.BACK )
    }


    return TextRenderer
}
},{"./texture-wrap":"/projects/blackice/node_modules/three-sdf-text/lib/texture-wrap.js","as-number":"/projects/blackice/node_modules/three-sdf-text/node_modules/as-number/index.js","gl-mat4/create":"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-mat4/create.js","gl-mat4/multiply":"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-mat4/multiply.js","gl-mat4/scale":"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-mat4/scale.js","gl-shader-core":"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-shader-core/shader-core.js","gl-sprite-text":"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/index.js","xtend":"/projects/blackice/node_modules/three-sdf-text/node_modules/xtend/immutable.js"}],"/projects/blackice/node_modules/three-sdf-text/lib/texture-wrap.js":[function(require,module,exports){
// in time this will be replaced with a solution
// that better supported ThreeJS Texture objects


function TextureWrap(renderer, tex) {
    if (!(this instanceof TextureWrap))
        return new TextureWrap(renderer, tex)
    this.renderer = renderer
    this.texture = tex
    this._shape = [0, 0]
}

TextureWrap.prototype.bind = function(unit) {
    updateSize(this._shape, this.texture)


    var gl = this.renderer.getContext()
    this.renderer.setTexture(this.texture, unit|0)
    
    gl.bindTexture(gl.TEXTURE_2D, this.texture.__webglTexture)
}

Object.defineProperty(TextureWrap.prototype, "shape", {

    get: function() {
        updateSize(this._shape, this.texture)
        return this._shape
    }
})

function updateSize(shape, texture) {
    shape[0] = (texture.image && texture.image.width)  |0
    shape[1] = (texture.image && texture.image.height) |0
}

module.exports = TextureWrap
},{}],"/projects/blackice/node_modules/three-sdf-text/node_modules/as-number/index.js":[function(require,module,exports){
module.exports=require("/projects/blackice/node_modules/as-number/index.js")
},{"/projects/blackice/node_modules/as-number/index.js":"/projects/blackice/node_modules/as-number/index.js"}],"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-mat4/create.js":[function(require,module,exports){
module.exports = create;

/**
 * Creates a new identity mat4
 *
 * @returns {mat4} a new 4x4 matrix
 */
function create() {
    var out = new Float32Array(16);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
};
},{}],"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-mat4/multiply.js":[function(require,module,exports){
module.exports=require("/projects/blackice/node_modules/gl-mat4/multiply.js")
},{"/projects/blackice/node_modules/gl-mat4/multiply.js":"/projects/blackice/node_modules/gl-mat4/multiply.js"}],"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-mat4/scale.js":[function(require,module,exports){
module.exports=require("/projects/blackice/node_modules/gl-mat4/scale.js")
},{"/projects/blackice/node_modules/gl-mat4/scale.js":"/projects/blackice/node_modules/gl-mat4/scale.js"}],"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-shader-core/shader-core.js":[function(require,module,exports){
module.exports=require("/projects/blackice/node_modules/glslify/node_modules/gl-shader-core/shader-core.js")
},{"/projects/blackice/node_modules/glslify/node_modules/gl-shader-core/shader-core.js":"/projects/blackice/node_modules/glslify/node_modules/gl-shader-core/shader-core.js"}],"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/index.js":[function(require,module,exports){
var Base = require('fontpath-simple-renderer')
var inherits = require('inherits')
var bmfont2fontpath = require('fontpath-bmfont')
var texcoord = require('texcoord')
var xtend = require('xtend')
var createTexture = require('gl-texture2d')

var Batch = require('gl-sprite-batch')

var tmpPos = [0, 0],
    tmpShape = [0, 0],
    tmp1 = [0, 0],
    tmp2 = [0, 0]
var DEFAULT_TEXCOORD = [0, 0, 1, 1]
var maxInitialCapacity = 500

function texcoordGlyph(glyph, atlas, out) {
    tmp1[0] = glyph.x
    tmp1[1] = glyph.y
    tmp2[0] = glyph.width
    tmp2[1] = glyph.height
    return texcoord(tmp1, tmp2, atlas, out)
}

function TextRenderer(gl, opt) {
    if (!(this instanceof TextRenderer))
        return new TextRenderer(gl, opt)
    opt = opt||{}

    if (!opt.font) 
        throw new Error('must specify bmfont at creation time')

    //if the font has Image/ndarray array
    if (!opt.textures && Array.isArray(opt.font.images)) {
        opt.textures = opt.font.images.map(function(img) {
            return createTexture(gl, img)
        })
    }

    opt.font = bmfont2fontpath(opt.font)

    Base.call(this, opt)

    this.textures = opt.textures || []
    this.gl = gl
    if (!gl)
        throw new Error("must specify gl context")
    
    //assume text will be used dynamically 
    if (typeof opt.dynamic !== 'boolean')
        opt.dynamic = true

    var batch = opt.batch
    if (!batch)
        this.defaultBatch = Batch(gl, opt)
    this.batch = batch || this.defaultBatch

    if (typeof opt.wrapWidth !== 'number')
        this.layout()
}

inherits(TextRenderer, Base)

TextRenderer.prototype.dispose = function(textures) {
    if (this.defaultBatch)
        this.defaultBatch.dispose()
    if (textures) {
        this.textures.forEach(function(t) {
            if (typeof t.dispose === 'function')
                t.dispose()
        })
    }
    return this
}

TextRenderer.prototype.uncache = function() {
    this._cache = false
    this.batch.clear()
    return this
}

TextRenderer.prototype.cache = function(x, y, start, end) {
    // if (this.underline || this.font.pages.length > 1)
    //     throw new Error('currently cached text does not support underlines or multiple texture pages')
    
    this._cache = true
    this.batch.ensureCapacity(this.text.length)
    this.batch.clear()
    this._build(x, y, start, end)
    return this
}

TextRenderer.prototype.draw = function(shader, x, y, start, end) {
    var batch = this.batch
    batch.bind(shader)

    //if we're drawing dynamically
    if (!this._cache) {
        batch.clear()
        this._build(x, y, start, end)
    }
    
    batch.draw()
    batch.unbind()
    return this
}

TextRenderer.prototype._build = function(x, y, start, end) {
    var result = this.render(x, y, start, end)

    var batch = this.batch
    var i = 0
    
    //underlines currently not supported with cache()
    if (!this._cache) {
        batch.texcoord = DEFAULT_TEXCOORD
        batch.texture = null

        for (i = 0; i < result.underlines.length; i++) {
            var underline = result.underlines[i]
            batch.position = underline.position
            batch.shape = underline.size
            batch.push()
        }
    }

    //now draw our glyphs into the batch...
    for (i = 0; i < result.glyphs.length; i++) {
        var g = result.glyphs[i]
        this._drawGlyph(batch, g)
    }
}

TextRenderer.prototype._drawGlyph = function(batch, data) {
    //... we could sort these by texture page to reduce draws
    var glyph = data.glyph
    var img = this.textures[glyph.page]
    tmpPos[0] = data.position[0]+glyph.hbx
    tmpPos[1] = data.position[1]+glyph.hby - this.font.descender
    tmpShape[0] = glyph.width * data.scale[0]
    tmpShape[1] = glyph.height * data.scale[1]
    
    batch.texture = img
    texcoordGlyph(glyph, img && img.shape, batch.texcoord)
    batch.position = tmpPos
    batch.shape = tmpShape
    batch.push()
}

module.exports = TextRenderer
},{"fontpath-bmfont":"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/fontpath-bmfont/index.js","fontpath-simple-renderer":"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/fontpath-simple-renderer/index.js","gl-sprite-batch":"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/index.js","gl-texture2d":"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-texture2d/texture.js","inherits":"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/inherits/inherits_browser.js","texcoord":"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/texcoord/index.js","xtend":"/projects/blackice/node_modules/three-sdf-text/node_modules/xtend/immutable.js"}],"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/fontpath-bmfont/index.js":[function(require,module,exports){
function glyph(data) {
    return {
        page: data.page,
        hbx: data.xoffset,
        hby: data.yoffset,
        width: data.width,
        height: data.height,
        xoff: data.xadvance,
        x: data.x,
        y: data.y
    }
}

function glyphs(chars) {
    var out = {}
    chars.forEach(function(c) {
        out[String.fromCharCode(c.id)] = glyph(c)
    })
    return out
}

module.exports = function(bmfont) {
    return {
        pages: bmfont.pages,
        resolution: 72,
        size: bmfont.info.size,
        units_per_EM: 1,
        bitmap: true,
        family_name: bmfont.info.face,
        height: bmfont.common.lineHeight,
        descender: bmfont.common.base,
        ascender: bmfont.common.base,
        glyphs: glyphs(bmfont.chars),
        kerning: bmfont.kernings.map(function(k) {
            return [String.fromCharCode(k.first),String.fromCharCode(k.second),k.amount]
        })
    }
}
},{}],"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/fontpath-simple-renderer/index.js":[function(require,module,exports){
var Base = require('fontpath-renderer')
var inherits = require('inherits')

//TODO: Eventually lots of this code will just replace fontpath-renderer...

function FontpathRenderer(options) {
    if (!(this instanceof FontpathRenderer))
        return new FontpathRenderer(options)
    Base.call(this, options)

    this.data = {
        glyphs: [],
        underlines: []
    }
}

inherits(FontpathRenderer, Base)

FontpathRenderer.prototype.renderGlyph = function(i, glyph, scale, x, y) {
    this.data.glyphs.push(new Glyph(i, glyph, 
                this.text.charCodeAt(i), 
                [ scale, this.font.bitmap ? scale : -scale ],
                [ x, y ]))
}

FontpathRenderer.prototype.renderUnderline = function(x, y, width, height) {
    this.data.underlines.push(new Underline(
        [ x, y ],
        [ width, height ]
    ))
}

FontpathRenderer.prototype.render = function(x, y, start, end) {
    //new data for result
    this.data.glyphs.length = 0
    this.data.underlines.length = 0
    Base.prototype.render.call(this, x, y, start, end)
    return this.data
}

function Glyph(index, glyph, charCode, scale, position) {
    this.glyph = glyph
    this.index = index
    this.charCode = charCode
    this.position = position
    this.scale = scale
}

function Underline(position, size) {
    this.position = position
    this.size = size
}

module.exports = FontpathRenderer
},{"fontpath-renderer":"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/fontpath-simple-renderer/node_modules/fontpath-renderer/index.js","inherits":"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/inherits/inherits_browser.js"}],"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/fontpath-simple-renderer/node_modules/fontpath-renderer/index.js":[function(require,module,exports){
var GlyphIterator = require('fontpath-glyph-iterator');
var WordWrap = require('fontpath-wordwrap');

var tmpBounds = { x: 0, y: 0, width: 0, height: 0, glyphs: 0 };

function TextRenderer(options) {
    if (!(this instanceof TextRenderer))
        return new TextRenderer(options);
    options = options||{}

    this.iterator = new GlyphIterator(options.font, options.fontSize);
    this.wordwrap = new WordWrap();

    this.align = 'left';
    this.underline = false;

    this.underlineThickness = undefined;
    this.underlinePosition = undefined;
    this._text = "";

    if (typeof options.align === 'string')
        this.align = options.align;
    if (typeof options.underline === 'boolean')
        this.underline = options.underline;
    if (typeof options.underlineThickness === 'number')
        this.underlineThickness = options.underlineThickness;
    if (typeof options.underlinePosition === 'number')
        this.underlinePosition = options.underlinePosition;
    if (typeof options.text === 'string')
        this.text = options.text;
    if (typeof options.lineHeight === 'number')
        this.lineHeight = options.lineHeight;
    if (typeof options.letterSpacing === 'number')
        this.letterSpacing = options.letterSpacing;
    if (typeof options.wrapMode === 'string')
        this.wordwrap.mode = options.wrapMode;
    if (typeof options.wrapWidth === 'number')
        this.layout(options.wrapWidth);
}

//Internally we will use integers to avoid string comparison for each glyph
var LEFT_ALIGN = 0, CENTER_ALIGN = 1, RIGHT_ALIGN = 2;
var ALIGN_ARRAY = [
    'left', 
    'center', 
    'right'
];
    
Object.defineProperties(TextRenderer.prototype, {
    /**
     * If the new font differs from the last, the text layout is cleared
     * and placed onto a single line. Users must manually re-layout the text 
     * for word wrapping.
     */
    "font": {
        get: function() {
            return this.iterator.font;
        },
        set: function(val) {
            var oldFont = this.iterator.font;
            this.iterator.font = val;
            if (oldFont !== this.iterator.font)
                this.clearLayout();
        },
    },

    /**
     * If the new font size differs from the last, the text layout is cleared
     * and placed onto a single line. Users must manually re-layout the text 
     * for word wrapping.
     */
    "fontSize": {
        get: function() {
            return this.iterator.fontSize;
        },
        set: function(val) {
            var oldSize = this.iterator.fontSize;

            this.iterator.fontSize = val;

            if (oldSize !== this.iterator.fontSize)
                this.clearLayout();
        },
    },
    "lineHeight": {
        get: function() {
            return this.iterator.lineHeight;
        },
        set: function(val) {
            this.iterator.lineHeight = val;
        },
    },
    "letterSpacing": {
         get: function() {
            return this.iterator.letterSpacing;
        },
        set: function(val) {
            this.iterator.letterSpacing = val;
        },
    },

    /**
     * If the new text is different from the last, the layout (i.e. word-wrapping)
     * is cleared and the result is a single line of text (similar to HTML5 canvas text
     * rendering).
     * 
     * The text then needs to be re-wordwrapped with a call to `layout()`.
     */
    "text": {
        get: function() {
            return this._text;
        },

        set: function(text) {
            text = text||"";

            var old = this._text;
            this._text = text;
            this.wordwrap.text = this.text;

            if (this._text !== old) 
                this.clearLayout();
        }
    }
});

/**
 * Clears the text layout and word-wrapping, placing all of it on a single line.
 */
TextRenderer.prototype.clearLayout = function() {
    this.wordwrap.text = this.text;
    this.wordwrap.empty();

    if (this.iterator.font) //font might not have been passed at constructor
        this.wordwrap.clearLayout(this.iterator);
};

/**
 * Calls the word wrapper to layout the current text string,
 * based on the wrap width and any current wordwrapping options.
 *
 * This is called when the text is changed. 
 * 
 * @return {[type]} [description]
 */
TextRenderer.prototype.layout = function(wrapWidth) {
    this.wordwrap.text = this.text;
    this.wordwrap.empty();
    this.wordwrap.layout(this.iterator, wrapWidth);
};

/**
 * "Renders" this glyph at the given location. This may involve filling
 * a VBO with vertex data, or it may be a direct call to draw a bitmap glyph
 * or shape outline.
 * @return {[type]} [description]
 */
TextRenderer.prototype.renderGlyph = function() {

};

TextRenderer.prototype.renderUnderline = function() {

};

/**
 * Returns the bounds of the current text layout. 
 *
 * The height does not extend past the baseline of the
 * last line; unless `includeUnderline` is true, in which
 * case the underline's position and height is included
 * in the calculation. 
 *
 * The bounding y position is offset so that the box has an upper-left
 * origin, for parity with HTML5 canvas rendering.
 * 
 * @param {Boolean} includeUnderline whether to include the underline in the calculation, default false
 * @param {Object} out an optional {width, height} object for re-use
 * @return {Object} a size with { width, height } properties
 */
TextRenderer.prototype.getBounds = function (includeUnderline, out) {
    if (!out)
        out = { x: 0, y: 0, width: 0, height: 0 };

    var wordwrapper = this.wordwrap;
    var itr = this.iterator;

    //tighten the bounding box around the first line..
    var firstLineHeight = 0;
    if (wordwrapper.lines.length > 0) {
        var firstLine = wordwrapper.lines[0];
        itr.getBounds(this.text, firstLine.start, firstLine.end, undefined, tmpBounds);
        firstLineHeight = tmpBounds.height;
    }

    out.width = wordwrapper.getMaxLineWidth();   
    out.height = Math.max(0, wordwrapper.lines.length-1) * itr.getLineGap() + firstLineHeight;

    out.x = 0;
    out.y = -out.height;

    if (includeUnderline) {
        var underlineHeight = this.computeUnderlineHeight();
        var underlinePosition = this.computeUnderlinePosition();
        var underlineOff = underlinePosition+underlineHeight/2;
        out.height += underlineOff;
    }

    return out;
};

/**
 * Computes the scaled underline height as pixels, based on 
 * the explicit `underlineHeight` (in pixels). If `underlineHeight` is
 * undefined or null, it will try to use the font's non-zero underline height, 
 * otherwise default to 1/8 of the font's EM square.
 * 
 * @return {Number} the pixel height of the underline 
 */
TextRenderer.prototype.computeUnderlineHeight = function () {
    var font = this.font;
    var scale = this.iterator.fontScale;
    if (this.underlineThickness===0||this.underlineThickness) {
        return this.underlineThickness; 
    } else if (font.underline_thickness) {
        return font.underline_thickness * scale; 
    } else if (font.bitmap)
        return font.size/8;
    else
        return (font.units_per_EM/8)*scale;
};

/**
 * Computes the scaled underline height as pixels, based on 
 * the explicit `underlinePosition` (in pixels). If `underlinePosition` is
 * undefined or null, it will try to use the font's non-zero underline position, 
 * otherwise default to 1/4 of the font's EM square.
 *
 * This is the Y offset from the text baseline to the center of the underline 
 * bar, in pixels. It is generally a positive value.
 * 
 * @return {Number} the pixel position of the underline 
 */
TextRenderer.prototype.computeUnderlinePosition = function () {
    var font = this.font;
    var scale = this.iterator.fontScale;
        
    if (this.underlinePosition===0||this.underlinePosition) {
        return this.underlinePosition; 
    } else if (font.underline_position) {
        return -font.underline_position * scale; 
    } else if (font.bitmap) {
        return font.size/4;
    } else {
        return (font.units_per_EM/4)*scale;
    }
};

/**
 * Gets the descent of the current font (assumes its size 
 * is already set). This is an absolute (positive) value.
 * 
 * @return {[type]} [description]
 */
TextRenderer.prototype.getDescender = function () {
    return Math.abs(this.iterator.fontScale * this.iterator.font.descender);
};

/**
 * Gets the descent of the current font (assumes its size 
 * is already set). This is an absolute (positive) value.
 * 
 * @return {[type]} [description]
 */
TextRenderer.prototype.getAscender = function () {
    return Math.abs(this.iterator.fontScale * this.iterator.font.ascender);
};

//Signals for subclasses to optionally implmeent
//This may be useful to stop/start paths with different fills
TextRenderer.prototype.onBegin = function() { }
TextRenderer.prototype.onEnd = function() { }
TextRenderer.prototype.onBeginLine = function(lineIndex) { }
TextRenderer.prototype.onEndLine = function(lineIndex) { }

/**
 * Renders the current text layout, where lower-left is 
 * the origin. Multiple lines will be positioned above the
 * origin.
 */
TextRenderer.prototype.render = function (x, y, start, end) {
    x = x||0;
    y = y||0;

    var text = this.text;
    var wordwrapper = this.wordwrap;

    //if we have nothing to draw
    if (!text || wordwrapper.lines.length === 0)
        return;

    //default start/end params
    start = start||0;
    end = typeof end === "number" ? end : text.length;

    var itr = this.iterator;
    var scale = itr.fontScale;
    var font = itr.font;
    var underline = this.underline;

    //used for alignment...
    var maxLineWidth = wordwrapper.getMaxLineWidth();
    
    y -= Math.max(0, wordwrapper.lines.length-1) * itr.getLineGap();


    //use numbers to avoid str compare for each glyph
    var alignType = ALIGN_ARRAY.indexOf(this.align||"");
    if (alignType===-1)
        alignType = LEFT_ALIGN;

    var underlineX = 0;
    var underlineStartX = 0;
    var underlineY = 0;
    var underlineWidth = 0;

    var underlineStarted = false;

    //Try to use user-specified underline settings, otherwise use the font if possible,
    //otherwise just use a rough default based on EM square.    
    var underlinePos = this.computeUnderlinePosition();
    var underlineHeight = this.computeUnderlineHeight();

    this.onBegin();
    
    //set the origin and pen position
    itr.begin(x, y);
    for (var k=0; k<wordwrapper.lines.length; k++) {
        var line = wordwrapper.lines[k];
        underlineStarted = false;

        var lastAdvance = 0;

        var lineX = itr.pen.x;
        var lineY = itr.pen.y;

        this.onBeginLine(k);

        //TODO: use multiple Nodes inside a single line
        //a node will have attributes like font, size, color, 
        //letter-spacing, underline, etc.
        //This will affect the line height, as it will have to be the max of all nodes.

        for (var i=line.start; i<line.end; i++) {
            var chr = text.charAt(i);

            //Step the iterator, moving forward based on kerning from last char
            var glyph = itr.step(text, i);

            if (!glyph)
                continue;

            //within desired range
            if (i >= start && i < end) {
                var tx = itr.pen.x;
                var ty = itr.pen.y;

                if (alignType === CENTER_ALIGN) {
                    tx += (maxLineWidth-line.width)/2;
                } else if (alignType === RIGHT_ALIGN) {
                    tx += (maxLineWidth-line.width);
                }

                if (!underlineStarted) {
                    underlineX = tx;
                    underlineStartX = tx;
                    underlineY = ty + underlinePos;
                    underlineWidth = 0;
                    underlineStarted = true;
                } else {
                    underlineWidth = tx - underlineStartX;
                }

                this.renderGlyph(i, glyph, scale, tx, ty);
            }

            //Advance the iterator to the next glyph in the string
            var newAdvance = itr.advance(glyph);

            if (i >= start && i < end)
                lastAdvance = newAdvance;
        }

        this.onEndLine(k);

        if (underline) {
            underlineWidth += lastAdvance;
            this.renderUnderline(underlineX, underlineY-underlineHeight/2, underlineWidth, underlineHeight);
        }
        
        //Steps down a line...
        if (k < wordwrapper.lines.length-1) {
            itr.advanceLine();
        }
    }

    //finish the iterator...
    itr.end();
    this.onEnd();
};

module.exports = TextRenderer;
},{"fontpath-glyph-iterator":"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/fontpath-simple-renderer/node_modules/fontpath-renderer/node_modules/fontpath-glyph-iterator/index.js","fontpath-wordwrap":"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/fontpath-simple-renderer/node_modules/fontpath-renderer/node_modules/fontpath-wordwrap/index.js"}],"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/fontpath-simple-renderer/node_modules/fontpath-renderer/node_modules/fontpath-glyph-iterator/index.js":[function(require,module,exports){
var util = require('fontpath-util');

var DEFAULT_TAB_WIDTH = 4;

function GlyphIterator(font, fontSize) {
    this._fontSize = undefined;
    this._fontScale = undefined;
    this._font = undefined;
    this.fontScale = 1.0;
    this.kerning = true;
    this.letterSpacing = 0;
    this.lineHeight = undefined;
    
    this.fontSize = typeof fontSize === 'number'
            ? fontSize
            : (font ? font.size : undefined);
    this.font = font;

    //Number of spaces for a tab character
    this.tabWidth = DEFAULT_TAB_WIDTH;
    this._tabGlyph = null;

    this.origin = { x: 0, y: 0 };
    this.pen = { x: 0, y: 0 };
}

Object.defineProperty(GlyphIterator.prototype, "font", {
    get: function() {
        return this._font;
    },

    set: function(font) {
        this._font = font;

        //Determine the new scaling factor...
        if (font) {
            this.fontScale = util.getPxScale(font, this.fontSize);

            //Updates the tab glyph
            this.tabWidth = this._tabWidth;
        }
    },
});

//There might be a better way of handling tab width using FreeType ? 
Object.defineProperty(GlyphIterator.prototype, "tabWidth", {

    get: function() {
        return this._tabWidth;
    },

    set: function(val) {
        this._tabWidth = val===0 || val ? val : DEFAULT_TAB_WIDTH;
        this._tabGlyph = {};

        var spaceGlyph = this.font ? this.font.glyphs[" "] : null;
        if (spaceGlyph) {
            this._tabGlyph = {};
            for (var k in spaceGlyph) {
                this._tabGlyph[k] = spaceGlyph[k];
            }
            if (this._tabGlyph.xoff)
                this._tabGlyph.xoff *= this._tabWidth;
        }
    },
});

Object.defineProperty(GlyphIterator.prototype, "fontSize", {
    get: function() {
        if (typeof this._fontSize !== 'number')
            return this.font.bitmap 
                ? this.font.size 
                : util.pointToPixel(this.font.size)
        return this._fontSize;
    },

    set: function(val) {
        this._fontSize = val;

        //If the font is already set, determine the new scaling factor
        if (this._font) {
            this.fontScale = util.getPxScale(this._font, this._fontSize);
        }
    },
});

GlyphIterator.prototype.getKerning = function(left, right) {
    var font = this.font;

    if (!font || !font.kerning)
        return 0;

    var table = this.kerningTable;

    for (var i=0; i<font.kerning.length; i++) {
        var k = font.kerning[i];
        if (k[0] === left && k[1] === right) 
            return k[2];
    }
    return 0;
};

GlyphIterator.prototype.begin = function(x, y) {
    this.origin.x = x||0;
    this.origin.y = y||0;

    this.pen.x = this.origin.x;
    this.pen.y = this.origin.y;
};

GlyphIterator.prototype.end = function() {
    //.. mainly for consistency with begin()
    //Might be useful later on
};

GlyphIterator.prototype.getLineGap = function() {
    //Line height handling is a mess in browsers.
    //Maybe the best solution is to encourage users to 
    //specify pixel line heights if they want to match browser standards,
    //otherwise it's unreasonable to expect the line gaps to line up exactly
    //across all browsers. Example of the disaster:
    //http://lists.w3.org/Archives/Public/www-style/2008Jan/0413.html

    //For reference, some baseline-to-baseline calculations:
    //http://www.microsoft.com/typography/otspec/recom.htm
    //freetype.org/freetype2/docs/reference/ft2-base_interface.html
    //http://www.freetype.org/freetype2/docs/glyphs/glyphs-3.html

    //Unfortunately none of these are producing line-heights that avoid overlapping
    //or resemble browser rendering in any way. 

    // If CSS uses 1em or 1, the browser offsets the line by the 
    // font's pixel size. If an exact pixel line-height is specified,
    // the browser will use that + a computed "linegap." 
    // If 'auto' is specified for line-height, the calculations seem
    // much more complex and browser/platform dependent (not included here).
    
    var font = this.font,
        scale = this.fontScale;
    var gap = (font.height - font.ascender + Math.abs(font.descender)) * scale;    
    var lineHeight = this.lineHeight;
    
    lineHeight = (lineHeight===0||lineHeight) 
            ? (lineHeight + gap)
            : this.fontSize;
    return lineHeight;
};

GlyphIterator.prototype.translate = function(x, y) {
    this.origin.x += x||0;
    this.origin.y += y||0;

    this.pen.x += x||0;
    this.pen.y += y||0;
};

GlyphIterator.prototype.step = function(text, index) {
    var scale = this.fontScale,
        font = this._font;

    var chr = text.charAt(index); 

    if (chr === '\t' && this._tabGlyph) {
        return this._tabGlyph;
    }

    //Skip missing characters...
    if (!(chr in font.glyphs))
        return;
    
    var glyph = font.glyphs[chr];

    //If we have a char to the left, determine its kerning
    if (index > 0 && this.kerning) {
        var kern = this.getKerning(text.charAt(index-1), chr);
        this.pen.x += (kern*scale);
    }

    return glyph;
};

GlyphIterator.prototype.advanceLine = function() {
    this.pen.y += this.getLineGap();
    this.pen.x = this.origin.x;
};

/**
 * Called after step. 
 */
GlyphIterator.prototype.advance = function(glyph) {
    var advance = (glyph.xoff * this.fontScale);
    // Advance to next pen position
    this.pen.x += advance + this.letterSpacing;
    return advance;
};

/**
 * This is a utility function that provides the bounds of the given
 * text (from start and end positions) as if they were laid out horizontally,
 * left to right.
 *
 * For convenience, this will not alter the current pen and origin positions.
 * This way it can be utilized inside a glyph iteration (i.e. for rendering).
 *
 * If `availableWidth` is specified, this will break before reaching the specified
 * pixel width, to ensure that all glyphs will fit inside the bounds. 
 *
 * The return object also includes a `glyphs` property, which is the number of glyphs
 * that are visible within the returned bounds. 
 *
 * If `out` is specified (an object with x, y, width, height, and glyph properties),
 * it will be re-used. Otherwise a new object is created.
 * 
 * @param {String} text the text to check
 * @param {Number} start the start position, defaults to 0
 * @param {Number} end the end position, exclusive, defaults to text length
 * @param {Number} availableWidth the width before stopping the bound check
 * @param {Object} out an object to re-use for the return value
 * @return {Object} the bounds and glyph count {x,y,width,height,glyphs}
 */
GlyphIterator.prototype.getBounds = function(text, start, end, availableWidth, out) {
    if (!out)
        out = { x:0, y:0, width: 0, height: 0, glyphs: 0 };

    var checkWidth = availableWidth===0||availableWidth;

    start = start||0;
    end = end===0||end ? end : text.length;

    var maxHeight = 0;

    out.x = 0;
    out.y = 0;
    out.glyphs = 0;

    var oldPenX = this.pen.x,
        oldPenY = this.pen.y,
        oldOriginX = this.origin.x,
        oldOriginY = this.origin.y;


    var font = this.font;
    this.begin();
    for (var i=start; i<end; i++) {
        var chr = text.charAt(i);

        //step the iterator
        var glyph = this.step(text, i);

        //if the glyph is valid, we can advance past it and calculate new height
        if (glyph) {
            var height = (glyph.height)*this.fontScale;

            out.y = Math.max(out.y, this.fontScale*(glyph.height-glyph.hby));

            maxHeight = Math.max(maxHeight, height);
            var lastAdvance = this.advance(glyph);

            //if we're past the available width
            var newWidth = this.pen.x - this.origin.x;
            if (checkWidth && (newWidth - availableWidth > 0.001)) {
                this.pen.x -= lastAdvance;
                break;
            }

            out.glyphs++;
        }
    }
    this.end();

    out.width = this.pen.x - this.origin.x;
    out.height = maxHeight;

    this.pen.x = oldPenX;
    this.pen.y = oldPenY;
    this.origin.x = oldOriginX;
    this.origin.y = oldOriginY;

    return out;
};

module.exports = GlyphIterator;
},{"fontpath-util":"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/fontpath-simple-renderer/node_modules/fontpath-renderer/node_modules/fontpath-util/index.js"}],"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/fontpath-simple-renderer/node_modules/fontpath-renderer/node_modules/fontpath-util/index.js":[function(require,module,exports){
// module.exports.pointsToPixels = function(pointSize, resolution) {
// 	resolution = typeof resolution === "number" ? resolution : 72;
// 	return pointSize * resolution / 72;
// };

// module.exports.coordToPixel = function(coord, pixelSize, emSize) {
// 	emSize = typeof emSize === "number" ? emSize : 2048;
// 	return coord * pixelSize / emSize;
// };

/**
 * Converts a pt size to px size, namely useful for matching
 * size with CSS styles. If no DPI is specified, 96 is assumed
 * (as it leads to correct rendering in all browsers).
 * 
 * @param  {Number} fontSize the desired font size in points
 * @param  {Number} dpi      the expected DPI, generally 96 for browsers
 * @return {Number}          the rounded pixel font size
 */
module.exports.pointToPixel = function(fontSize, dpi) {
    dpi = dpi||dpi===0 ? dpi : 96;
    fontSize = fontSize * dpi / 72;
    return Math.round(fontSize);
};

/**
 * For the given font and (pixel) font size, this method returns the
 * scale that will need to be applied to EM units (i.e. font paths) 
 * to have the font render at the expected size (i.e. to match the browser).
 *
 * If no font size is specified, we will use the default font size (which is in points)
 * and convert it to pixels. 
 * 
 * @param  {Font} font     a font object from the fontpath tool
 * @param  {Number} fontSize the desired font size, defaults to the font's default size
 * @return {Number} returns the scale for this font size         
 */
module.exports.getPxScale = function(font, fontSize) {
    if (font.bitmap)
        return 1.0;

    //If no fontSize is specified, it will just fall back to using the font's own size with 96 DPI.
    fontSize = typeof fontSize === "number" ? fontSize : this.pointToPixel(font.size);

    //Takes in a font size in PIXELS and gives us the expected scaling factor
    var sz = font.units_per_EM/64;
    sz = (sz/font.size * fontSize);

    return ((font.resolution * 1/72 * sz) / font.units_per_EM);
};

/**
 * For the given font and (point) font size, this method returns the
 * scale that will need to be applied to EM units (i.e. font paths) 
 * to have the font render at the expected size (i.e. to match the browser).
 * 
 * If no font size is specified, we will use the default font size.
 * 
 * @param  {Font} font       a font object from the fontpath tool
 * @param  {Number} fontSize the desired font size, defaults to the font's default size
 * @return {Number}          the scale for this font size
 */
module.exports.getPtScale = function(font, fontSize) {
    fontSize = typeof fontSize === "number" ? fontSize : font.size;
    fontSize = this.pointToPixel(fontSize);
    return this.getPxScale(font, fontSize);
};

},{}],"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/fontpath-simple-renderer/node_modules/fontpath-renderer/node_modules/fontpath-wordwrap/index.js":[function(require,module,exports){
var tmpBounds = { x: 0, y: 0, width: 0, height: 0, glyphs: 0 };

function isWhitespace(chr) {
	return chr===' '
		|| chr==='\n'
		|| chr==='\r'
		|| chr==='\t';
}

function idxOf(text, chr, start, end) {
	var idx = text.indexOf(chr, start);
	if (idx === -1 || idx > end)
		return end;
	return idx;
}

function WordWrap(text) {
	/**
	 * The text being operated on.
	 * @param {String} text
	 */
	this.text = text||"";

	/**
	 * An array of lines representing the state of this word wrapper.
	 * @param {Array} lines
	 */
	this.lines = [];

	/** 
	 * The newline character to break on, default '\n'
	 * @param {String} newline
	 */
	this.newline = '\n';

	/**
	 * Whether to clip non-breaking text (nowrap and pre)
	 * if the wrapWidth is too small. 
	 *  
	 * @param {Boolean} clip
	 */
	this.clip = false;

	/**
	 * The mode for wordwrapping: 'pre', 'normal', or 'nowrap'.
	 *
	 * You can also use the `PRE`, `NORMAL`, and `NOWRAP` constants
	 * in `WordWrap.Mode`.
	 * 
	 * @param {String} mode
	 */
	this.mode = WordWrap.Mode.NORMAL;
}

WordWrap.Mode = {
	PRE: 'pre',       //whitespace isn't collapsed
	NORMAL: 'normal', //whitespace is collapsed
	NOWRAP: 'nowrap'  //only break on '\n'
};

/**
 * Clears any multi-line layout by placing all the text in a single Line object.
 * 
 * @param {GlyphIterator} iterator the iterator to use 
 * @method  clearLayout
 */
WordWrap.prototype.clearLayout = function(iterator) {
	this.lines.length = 0;
	
	if (this.text.length > 0) {
		iterator.getBounds(this.text, 0, this.text.length, undefined, tmpBounds);
		
		var line = new WordWrap.Line(0, this.text.length, tmpBounds.width);
		this.lines.push(line);
	}
};

/**
 * Resets the word wrapper by emptying all current lines.
 * @method  empty
 */
WordWrap.prototype.empty = function() {
	this.lines.length = 0;
};

/**
 * Word-wraps the given text into multiple lines.
 * @param  {[type]} iterator [description]
 * @param  {[type]} width    [description]
 * @param  {[type]} start    [description]
 * @param  {[type]} end      [description]
 * @return {[type]}          [description]
 */
WordWrap.prototype.layout = function(iterator, wrapWidth, start, end) {
	var text = this.text;

	var lines = this.lines;

	start = Math.max(0, start||0);
	end = (end===0||end) ? end : text.length;

	iterator.begin();

	//default wrap width...
	wrapWidth = (wrapWidth===0 || wrapWidth) ? wrapWidth : Number.MAX_VALUE;

	//<pre> mode just uses a simple algorithm...
	if (this.mode === WordWrap.Mode.PRE) {
		var lineStart = start;
		for (var i=start; i<end; i++) {
			var chr = text.charAt(i);

			//If we've reached a newline, then step down a line
			//Or if we've reached the EOF
			if ( chr === this.newline || i===end-1) {
				var availableWidth = this.clip ? wrapWidth : undefined;
				iterator.getBounds(text, lineStart, i+1, availableWidth, tmpBounds);
				lines.push( new WordWrap.Line(lineStart, lineStart+tmpBounds.glyphs, tmpBounds.width) );
				lineStart = i+1;
			}
		}
	} 
	//'normal' mode uses LibGDX's word wrapping algorithm:
	//https://github.com/libgdx/libgdx/blob/master/gdx/src/com/badlogic/gdx/graphics/g2d/BitmapFontCache.java
	else {
		//if 'nowrap' is specified, we only wrap on newline chars
		
		var testWidth = wrapWidth;
		if (this.mode === WordWrap.Mode.NOWRAP) {
			testWidth = Number.MAX_VALUE;
		}

		while (start < end) {
			//get next newline position
			var newLine = idxOf(text, this.newline, start, end);

			//eat whitespace at start of line
			while (start < newLine) {
				if (!isWhitespace( text.charAt(start) ))
					break;
				start++;
			}

			//determine visible # of glyphs for the available width
			iterator.getBounds(text, start, newLine, testWidth, tmpBounds)

			var lineEnd = start + tmpBounds.glyphs;
			var nextStart = lineEnd + this.newline.length;

			//if we had to cut the line before the next newline...
			if (lineEnd < newLine) {
				//find char to break on
				while (lineEnd > start) {
					if (isWhitespace(text.charAt(lineEnd)))
						break;
					lineEnd--;
				}
				if (lineEnd === start) {
					if (nextStart > start + this.newline.length) nextStart--;
					lineEnd = nextStart; // If no characters to break, show all.
				} else {
					nextStart = lineEnd;
					//eat whitespace at end of line
					while (lineEnd > start) {
						if (!isWhitespace(text.charAt(lineEnd - this.newline.length)))
							break;
						lineEnd--;
					}
				}
			}

			if (lineEnd > start) {
				//to clip, use the original wrap width (unaltered by mode)
				var availableWidth = this.clip ? wrapWidth : undefined;
				iterator.getBounds(text, start, lineEnd, availableWidth, tmpBounds);
				var lineWidth = tmpBounds.width;

				var rLineEnd = this.clip ? start+tmpBounds.glyphs : lineEnd;
				lines.push( new WordWrap.Line(start, rLineEnd, lineWidth) );
			}
			start = nextStart;

		}
	}

	iterator.end();
};

/**
 * A convenience method to return the maximum width of all current lines.
 * This is useful for aligning blocks of text.
 *
 * @method  getMaxLineWidth
 * @return {Number} the maximum width of all lines
 */
WordWrap.prototype.getMaxLineWidth = function() {
	var maxWidth = 0;
	for (var i=0; i<this.lines.length; i++) {
		var line = this.lines[i];
		maxWidth = Math.max(line.width, maxWidth);
	}
	return maxWidth;
};

/**
 * The Line object holds the start and end indices into the string,
 * and the width as computed by GlyphIterator.
 * 
 * @class  WordWrap.Line
 * @param {Number} start the start index, inclusive
 * @param {Number} end   the end index, exclusive
 * @param {Number} width the computed width of this line
 */
WordWrap.Line = function(start, end, width) {
	this.start = start;
	this.end = end;
	this.width = width;
};

module.exports = WordWrap;
},{}],"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/common.js":[function(require,module,exports){
var createVAO = require('gl-aliased-vao') //TODO: improve this with gl-vao
var createBuffer = require('gl-buffer')

module.exports.floatsPerVertex = 5

function createIndices(capacity) {
    var numIndices = capacity * 6
    var indices = new Uint16Array(numIndices)

    for (var i = 0, j = 0; i < numIndices; i += 6, j += 4) {
        indices[i + 0] = j + 0
        indices[i + 1] = j + 1
        indices[i + 2] = j + 2
        indices[i + 3] = j + 0
        indices[i + 4] = j + 2
        indices[i + 5] = j + 3
    }
    return indices
}

module.exports.mixins = {

    create: function create(opt) {
        opt = opt||{}
        this.clear()

        //dispose before building...
        if (this.vao)
            this.dispose()

        var capacity = typeof opt.capacity === 'number' ? opt.capacity : 100

        // 65535 is max index, so 65535 / 6 = 10922.
        if (capacity > 10922)
            throw new Error("Can't have more than 10922 quads per batch: " + capacity)

        this._capacity = capacity

        //the total number of floats in our batch
        var numVerts = capacity * 4 * module.exports.floatsPerVertex

        this.vertices = new Float32Array(numVerts)
        this.indices = createIndices(capacity)

        var gl = this.gl
        var usage = opt.dynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW
        this.vertexBuffer = createBuffer(gl, this.vertices, gl.ARRAY_BUFFER, usage)
        this.indexBuffer = createBuffer(gl, this.indices, gl.ELEMENT_ARRAY_BUFFER, gl.STATIC_DRAW)

        var stride = 5 * 4
        this.vao = createVAO(gl, [{ //position XY
            name: 'position',
            buffer: this.vertexBuffer,
            size: 2,
            stride: stride
        }, { //texcoord UV
            name: 'texcoord0',
            buffer: this.vertexBuffer,
            size: 2,
            offset: 2 * 4,
            stride: stride
        }, { //color (packed) C
            name: 'color',
            buffer: this.vertexBuffer,
            size: 4,
            stride: stride,
            offset: 4 * 4,
            type: gl.UNSIGNED_BYTE,
            normalized: true
        }], this.indexBuffer)
        return this
    },

    ensureCapacity: function(capacity) {
        if (this.capacity < capacity)
            this.create({ capacity: capacity })
        return this
    }
}
},{"gl-aliased-vao":"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/gl-aliased-vao/index.js","gl-buffer":"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/gl-buffer/buffer.js"}],"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/index.js":[function(require,module,exports){
var colorToFloat = require('./pack-rgba-float')
var mixes = require('mixes')
var premult = require('premultiplied-rgba')
var WhiteTex = require('gl-white-texture')

var vertNumFloats = require('./common').floatsPerVertex

//Temporary arrays to avoid GC thrashing
var position = [0, 0],
    shape = [0, 0],
    texcoord = [0, 0, 0, 0],
    color = [0, 0, 0, 0]

var tmp4 = [0, 0, 0, 0],
    rotOrigin = [0, 0],
    tmp2 = [0, 0]

function SpriteBatch(gl, opt) {
    if (!(this instanceof SpriteBatch))
        return new SpriteBatch(gl, opt)
    if (!gl)
        throw new Error("must specify gl context")
    this.gl = gl
    opt = opt || {}
    
    this._bound = false
    this.idx = 0

    //no transform means identity
    this.transform = null

    //white texture is akin to "no texture" (without switching shaders)
    this._defaultTexture = opt.defaultTexture || WhiteTex(gl)
    this._ownsDefault = !opt.defaultTexture
    this._lastTexture = this._defaultTexture
    this._texture = this._defaultTexture
    this.texture = null

    this.mode = typeof opt.mode === 'number' ? opt.mode : gl.TRIANGLES
    this.premultiplied = opt.premultiplied || false

    this._dirty = true
    this.create(opt)

    //set default attributes
    this.defaults()
}

//mix in create() and ensureCapacity() functions
mixes(SpriteBatch, require('./common').mixins)

mixes(SpriteBatch, {

    capacity: {
        get: function() {
            return this._capacity
        }
    },

    texture: {
        get: function() {
            return this._texture
        },

        set: function(tex) {
            this._texture = tex || this._defaultTexture
        }
    },

    dispose: function() {
        if (this.vertexBuffer)
            this.vertexBuffer.dispose()
        if (this.indexBuffer)
            this.indexBuffer.dispose()
        if (this.vao)
            this.vao.dispose()
        if (this._ownsDefault)
            this._defaultTexture.dispose()
    },

    clear: function() {
        this.idx = 0
        return this
    },

    bind: function(shader) {
        shader.bind()
        this.vao.bind(shader)
        this._bound = true
    },

    unbind: function() {
        this.vao.unbind()
        this._bound = false
    },

    defaults: function() {
        this.position = copy2(position, 0, 0)
        this.texcoord = copy4(texcoord, 0, 0, 1, 1)
        this.color = copy4(color, 1, 1, 1, 1)
        this.shape = copy2(shape, 0, 0)
        return this
    },

    push: function(sprite) {
        //if we are defining attributes on the fly
        if (sprite) {
            this.texture = sprite.texture
            this.position = sprite.position || copy2(position, 0, 0)
            this.texcoord = sprite.texcoord || copy4(texcoord, 0, 0, 1, 1)
            this.color = sprite.color || copy4(color, 1, 1, 1, 1)
            this.shape = sprite.shape || copy2(shape, 0, 0)
        }

        if (this.texture !== this._lastTexture) {
            //new texture, flush previous data
            if (this._bound)
                this.flush()
            this._lastTexture = this.texture
        } else if (this.idx === this.vertices.length) {
            //if we AREN'T bound, we need to stop pushing vertex data!
            if (!this._bound)
                return this

            //if we ARE bound, we can flush the batch and continue drawing
            this.flush()
        }

        this._dirty = true

        //get RGBA components and pack into a single float
        var colorRGBA = this.premultiplied ? premult(this.color, tmp4) : this.color
        var c = colorToFloat(colorRGBA)

        var u1 = this.texcoord[0],
            v1 = this.texcoord[1],
            u2 = this.texcoord[2],
            v2 = this.texcoord[3]

        var x = this.position[0],
            y = this.position[1],
            width = this.shape[0],
            height = this.shape[1]

        this._vert(x, y, u1, v1, c)
        this._vert(x+width, y, u2, v1, c)
        this._vert(x+width, y+height, u2, v2, c)
        this._vert(x, y+height, u1, v2, c)
        
        return this
    },

    _vert: function(x1, y1, u1, v1, c) {
        var idx = this.idx,
            verts = this.vertices,
            transform = this.transform

        if (transform) {
            var x = x1, y = y1
            x1 = transform[0] * x + transform[4] * y + transform[12]
            y1 = transform[1] * x + transform[5] * y + transform[13]
        }

        //xy
        verts[idx++] = x1
        verts[idx++] = y1
        //uv
        verts[idx++] = u1
        verts[idx++] = v1
        //color
        verts[idx++] = c
        this.idx = idx
    },

    flush: function() {
        this.draw()
        return this.clear()
    },

    draw: function() {
        //If we've reached a new texture or capacity
        //while not bound, then we will just clear the batch
        //to zero and draw nothing
        if (this.idx === 0 || !this._bound)
            return this

        var gl = this.gl
        
        if (this._dirty) {
            var view = this.vertices.subarray(0, this.idx)
            this.vertexBuffer.update(view, 0)
            this._dirty = false
        }

        if (this._lastTexture)
            this._lastTexture.bind()
        this._lastTexture = this.texture

        var sprites = (this.idx / (vertNumFloats * 4))
        if (sprites > 0)
            this.vao.draw(this.mode, sprites * 6, 0)
        return this
    },
})

module.exports = SpriteBatch

//TODO: will use modular gl-matrix for these...
function copy2(out, x, y) {
    out[0] = x
    out[1] = y
    return out
}

function copy4(out, x, y, z, w) {
    out[0] = x
    out[1] = y
    out[2] = z
    out[3] = w
    return out
}

function copyVec2(out, vec) {
    return copy2(out, vec[0], vec[1])
}

function transformMat4(out, a, m) {
    var x = a[0], 
        y = a[1]
    out[0] = m[0] * x + m[4] * y + m[12]
    out[1] = m[1] * x + m[5] * y + m[13]
    return out
}
},{"./common":"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/common.js","./pack-rgba-float":"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/pack-rgba-float.js","gl-white-texture":"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/gl-white-texture/index.js","mixes":"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/mixes/index.js","premultiplied-rgba":"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/premultiplied-rgba/index.js"}],"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/gl-aliased-vao/index.js":[function(require,module,exports){
var createVAOEmulated = require("./lib/vao-emulated.js")

function createVAO(gl, attributes, elements, elementsType) {
  var vao = createVAOEmulated(gl)
  vao.update(attributes, elements, elementsType)
  return vao
}

module.exports = createVAO
},{"./lib/vao-emulated.js":"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/gl-aliased-vao/lib/vao-emulated.js"}],"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/gl-aliased-vao/lib/do-bind.js":[function(require,module,exports){
function getAttributeLocation(name, shader) {
    if (!name)
        return null
    var attr = shader.attributes
    if (attr[name]) 
        return attr[name].location
    return null
}

var nattribs = null
var bound = null

function doBind(gl, elements, attributes, shader) {
    if (elements) {
        elements.bind()
    } else {
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null)
    }
    if (nattribs === null) {
      nattribs = gl.getParameter(gl.MAX_VERTEX_ATTRIBS) | 0
      bound = new Array(nattribs)
    }

    if (attributes) {
        if (attributes.length > nattribs) {
            throw new Error("gl-vao: Too many vertex attributes")
        }

        var lastBound = null

        for (i=0; i<nattribs; i++)
          bound[i] = false

        //now bind aliased attributes
        for (i=0; i<attributes.length; i++) {
            var attrib = attributes[i]
            var loc = getAttributeLocation(attrib.name, shader)
            if (loc === null)
                continue

            bound[loc] = true

            if(attrib.buffer) {
              var buffer = attrib.buffer
              var size = attrib.size || 4
              var type = attrib.type || gl.FLOAT
              var normalized = !!attrib.normalized
              var stride = attrib.stride || 0
              var offset = attrib.offset || 0
              if (lastBound !== buffer) {
                buffer.bind()
                lastBound = buffer
              }
              gl.enableVertexAttribArray(loc)
              gl.vertexAttribPointer(loc, size, type, normalized, stride, offset)
            } else {
              if(typeof attrib === "number") {
                gl.vertexAttrib1f(loc, attrib)
              } else if(attrib.length === 1) {
                gl.vertexAttrib1f(loc, attrib[0])
              } else if(attrib.length === 2) {
                gl.vertexAttrib2f(loc, attrib[0], attrib[1])
              } else if(attrib.length === 3) {
                gl.vertexAttrib3f(loc, attrib[0], attrib[1], attrib[2])
              } else if(attrib.length === 4) {
                gl.vertexAttrib4f(loc, attrib[0], attrib[1], attrib[2], attrib[3])
              } else {
                throw new Error("gl-vao: Invalid vertex attribute")
              }
              gl.disableVertexAttribArray(loc)
            }

        }
        
        for (i=0; i<nattribs; i++) {
          if (!bound[i])
            gl.disableVertexAttribArray(i)
        }
    } else {
      gl.bindBuffer(gl.ARRAY_BUFFER, null)
      for(var i=0; i<nattribs; ++i) {
        gl.disableVertexAttribArray(i)
      }
    }
}

module.exports = doBind
},{}],"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/gl-aliased-vao/lib/vao-emulated.js":[function(require,module,exports){
var bindAttribs = require("./do-bind.js")

function VAOEmulated(gl) {
  this.gl = gl
  this._elements = null
  this._attributes = null
  this._elementsType = gl.UNSIGNED_SHORT
}

VAOEmulated.prototype.bind = function(shader) {
  if (!shader)
    throw new Error('must associate shader with vertex array')
  bindAttribs(this.gl, this._elements, this._attributes, shader)
}

VAOEmulated.prototype.update = function(attributes, elements, elementsType) {
  this._elements = elements
  this._attributes = attributes
  this._elementsType = elementsType || this.gl.UNSIGNED_SHORT
}

VAOEmulated.prototype.dispose = function() { }
VAOEmulated.prototype.unbind = function() {
  bindAttribs(this.gl)
}

VAOEmulated.prototype.draw = function(mode, count, offset) {
  offset = offset || 0
  var gl = this.gl
  if(this._elements) {
    gl.drawElements(mode, count, this._elementsType, offset)
  } else {
    gl.drawArrays(mode, offset, count)
  }
}

function createVAOEmulated(gl) {
  return new VAOEmulated(gl)
}

module.exports = createVAOEmulated
},{"./do-bind.js":"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/gl-aliased-vao/lib/do-bind.js"}],"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/gl-buffer/buffer.js":[function(require,module,exports){
"use strict"

var pool = require("typedarray-pool")
var ops = require("ndarray-ops")
var ndarray = require("ndarray")
var webglew = require("webglew")

var SUPPORTED_TYPES = [
  "uint8",
  "uint8_clamped",
  "uint16",
  "uint32",
  "int8",
  "int16",
  "int32",
  "float32" ]

function GLBuffer(gl, type, handle, length, usage) {
  this.gl = gl
  this.type = type
  this.handle = handle
  this.length = length
  this.usage = usage
}

var proto = GLBuffer.prototype

proto.bind = function() {
  this.gl.bindBuffer(this.type, this.handle)
}

proto.unbind = function() {
  this.gl.bindBuffer(this.type, null)
}

proto.dispose = function() {
  this.gl.deleteBuffer(this.handle)
}

function updateTypeArray(gl, type, len, usage, data, offset) {
  var dataLen = data.length * data.BYTES_PER_ELEMENT 
  if(offset < 0) {
    gl.bufferData(type, data, usage)
    return dataLen
  }
  if(dataLen + offset > len) {
    throw new Error("gl-buffer: If resizing buffer, must not specify offset")
  }
  gl.bufferSubData(type, offset, data)
  return len
}

function makeScratchTypeArray(array, dtype) {
  var res = pool.malloc(array.length, dtype)
  var n = array.length
  for(var i=0; i<n; ++i) {
    res[i] = array[i]
  }
  return res
}

function isPacked(shape, stride) {
  var n = 1
  for(var i=stride.length-1; i>=0; --i) {
    if(stride[i] !== n) {
      return false
    }
    n *= shape[i]
  }
  return true
}

proto.update = function(array, offset) {
  if(typeof offset !== "number") {
    offset = -1
  }
  this.bind()
  if(typeof array === "object" && typeof array.shape !== "undefined") { //ndarray
    var dtype = array.dtype
    if(SUPPORTED_TYPES.indexOf(dtype) < 0) {
      dtype = "float32"
    }
    if(this.type === this.gl.ELEMENT_ARRAY_BUFFER) {
      var wgl = webglew(this.gl)
      var ext = wgl.OES_element_index_uint
      if(ext && dtype !== "uint16") {
        dtype = "uint32"
      } else {
        dtype = "uint16"
      }
    }
    if(dtype === array.dtype && isPacked(array.shape, array.stride)) {
      if(array.offset === 0 && array.data.length === array.shape[0]) {
        this.length = updateTypeArray(this.gl, this.type, this.length, this.usage, array.data, offset)
      } else {
        this.length = updateTypeArray(this.gl, this.type, this.length, this.usage, array.data.subarray(array.offset, array.shape[0]), offset)
      }
    } else {
      var tmp = pool.malloc(array.size, dtype)
      var ndt = ndarray(tmp, array.shape)
      ops.assign(ndt, array)
      if(offset < 0) {
        this.length = updateTypeArray(this.gl, this.type, this.length, this.usage, tmp, offset)  
      } else {
        this.length = updateTypeArray(this.gl, this.type, this.length, this.usage, tmp.subarray(0, array.size), offset)  
      }
      pool.free(tmp)
    }
  } else if(Array.isArray(array)) { //Vanilla array
    var t
    if(this.type === this.gl.ELEMENT_ARRAY_BUFFER) {
      t = makeScratchTypeArray(array, "uint16")
    } else {
      t = makeScratchTypeArray(array, "float32")
    }
    if(offset < 0) {
      this.length = updateTypeArray(this.gl, this.type, this.length, this.usage, t, offset)
    } else {
      this.length = updateTypeArray(this.gl, this.type, this.length, this.usage, t.subarray(0, array.length), offset)
    }
    pool.free(t)
  } else if(typeof array === "object" && typeof array.length === "number") { //Typed array
    this.length = updateTypeArray(this.gl, this.type, this.length, this.usage, array, offset)
  } else if(typeof array === "number" || array === undefined) { //Number/default
    if(offset >= 0) {
      throw new Error("gl-buffer: Cannot specify offset when resizing buffer")
    }
    array = array | 0
    if(array <= 0) {
      array = 1
    }
    this.gl.bufferData(this.type, array|0, this.usage)
    this.length = array
  } else { //Error, case should not happen
    throw new Error("gl-buffer: Invalid data type")
  }
}

function createBuffer(gl, data, type, usage) {
  webglew(gl)
  type = type || gl.ARRAY_BUFFER
  usage = usage || gl.DYNAMIC_DRAW
  if(type !== gl.ARRAY_BUFFER && type !== gl.ELEMENT_ARRAY_BUFFER) {
    throw new Error("gl-buffer: Invalid type for webgl buffer, must be either gl.ARRAY_BUFFER or gl.ELEMENT_ARRAY_BUFFER")
  }
  if(usage !== gl.DYNAMIC_DRAW && usage !== gl.STATIC_DRAW && usage !== gl.STREAM_DRAW) {
    throw new Error("gl-buffer: Invalid usage for buffer, must be either gl.DYNAMIC_DRAW, gl.STATIC_DRAW or gl.STREAM_DRAW")
  }
  var handle = gl.createBuffer()
  var result = new GLBuffer(gl, type, handle, 0, usage)
  result.update(data)
  return result
}

module.exports = createBuffer
},{"ndarray":"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/gl-buffer/node_modules/ndarray/ndarray.js","ndarray-ops":"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/gl-buffer/node_modules/ndarray-ops/ndarray-ops.js","typedarray-pool":"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/gl-buffer/node_modules/typedarray-pool/pool.js","webglew":"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/gl-buffer/node_modules/webglew/webglew.js"}],"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/gl-buffer/node_modules/ndarray-ops/ndarray-ops.js":[function(require,module,exports){
module.exports=require("/projects/blackice/node_modules/gl-texture2d/node_modules/ndarray-ops/ndarray-ops.js")
},{"/projects/blackice/node_modules/gl-texture2d/node_modules/ndarray-ops/ndarray-ops.js":"/projects/blackice/node_modules/gl-texture2d/node_modules/ndarray-ops/ndarray-ops.js"}],"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/gl-buffer/node_modules/ndarray/ndarray.js":[function(require,module,exports){
(function (Buffer){
var iota = require("iota-array")

var hasTypedArrays  = ((typeof Float64Array) !== "undefined")
var hasBuffer       = ((typeof Buffer) !== "undefined")

function compare1st(a, b) {
  return a[0] - b[0]
}

function order() {
  var stride = this.stride
  var terms = new Array(stride.length)
  var i
  for(i=0; i<terms.length; ++i) {
    terms[i] = [Math.abs(stride[i]), i]
  }
  terms.sort(compare1st)
  var result = new Array(terms.length)
  for(i=0; i<result.length; ++i) {
    result[i] = terms[i][1]
  }
  return result
}

function compileConstructor(dtype, dimension) {
  var className = ["View", dimension, "d", dtype].join("")
  if(dimension < 0) {
    className = "View_Nil" + dtype
  }
  var useGetters = (dtype === "generic")
  
  if(dimension === -1) {
    //Special case for trivial arrays
    var code = 
      "function "+className+"(a){this.data=a;};\
var proto="+className+".prototype;\
proto.dtype='"+dtype+"';\
proto.index=function(){return -1};\
proto.size=0;\
proto.dimension=-1;\
proto.shape=proto.stride=proto.order=[];\
proto.lo=proto.hi=proto.transpose=proto.step=\
function(){return new "+className+"(this.data);};\
proto.get=proto.set=function(){};\
proto.pick=function(){return null};\
return function construct_"+className+"(a){return new "+className+"(a);}"
    var procedure = new Function(code)
    return procedure()
  } else if(dimension === 0) {
    //Special case for 0d arrays
    var code =
      "function "+className+"(a,d) {\
this.data = a;\
this.offset = d\
};\
var proto="+className+".prototype;\
proto.dtype='"+dtype+"';\
proto.index=function(){return this.offset};\
proto.dimension=0;\
proto.size=1;\
proto.shape=\
proto.stride=\
proto.order=[];\
proto.lo=\
proto.hi=\
proto.transpose=\
proto.step=function "+className+"_copy() {\
return new "+className+"(this.data,this.offset)\
};\
proto.pick=function "+className+"_pick(){\
return TrivialArray(this.data);\
};\
proto.valueOf=proto.get=function "+className+"_get(){\
return "+(useGetters ? "this.data.get(this.offset)" : "this.data[this.offset]")+
"};\
proto.set=function "+className+"_set(v){\
return "+(useGetters ? "this.data.set(this.offset,v)" : "this.data[this.offset]=v")+"\
};\
return function construct_"+className+"(a,b,c,d){return new "+className+"(a,d)}"
    var procedure = new Function("TrivialArray", code)
    return procedure(CACHED_CONSTRUCTORS[dtype][0])
  }

  var code = ["'use strict'"]
    
  //Create constructor for view
  var indices = iota(dimension)
  var args = indices.map(function(i) { return "i"+i })
  var index_str = "this.offset+" + indices.map(function(i) {
        return "this.stride[" + i + "]*i" + i
      }).join("+")
  var shapeArg = indices.map(function(i) {
      return "b"+i
    }).join(",")
  var strideArg = indices.map(function(i) {
      return "c"+i
    }).join(",")
  code.push(
    "function "+className+"(a," + shapeArg + "," + strideArg + ",d){this.data=a",
      "this.shape=[" + shapeArg + "]",
      "this.stride=[" + strideArg + "]",
      "this.offset=d|0}",
    "var proto="+className+".prototype",
    "proto.dtype='"+dtype+"'",
    "proto.dimension="+dimension)
  
  //view.size:
  code.push("Object.defineProperty(proto,'size',{get:function "+className+"_size(){\
return "+indices.map(function(i) { return "this.shape["+i+"]" }).join("*"),
"}})")

  //view.order:
  if(dimension === 1) {
    code.push("proto.order=[0]")
  } else {
    code.push("Object.defineProperty(proto,'order',{get:")
    if(dimension < 4) {
      code.push("function "+className+"_order(){")
      if(dimension === 2) {
        code.push("return (Math.abs(this.stride[0])>Math.abs(this.stride[1]))?[1,0]:[0,1]}})")
      } else if(dimension === 3) {
        code.push(
"var s0=Math.abs(this.stride[0]),s1=Math.abs(this.stride[1]),s2=Math.abs(this.stride[2]);\
if(s0>s1){\
if(s1>s2){\
return [2,1,0];\
}else if(s0>s2){\
return [1,2,0];\
}else{\
return [1,0,2];\
}\
}else if(s0>s2){\
return [2,0,1];\
}else if(s2>s1){\
return [0,1,2];\
}else{\
return [0,2,1];\
}}})")
      }
    } else {
      code.push("ORDER})")
    }
  }
  
  //view.set(i0, ..., v):
  code.push(
"proto.set=function "+className+"_set("+args.join(",")+",v){")
  if(useGetters) {
    code.push("return this.data.set("+index_str+",v)}")
  } else {
    code.push("return this.data["+index_str+"]=v}")
  }
  
  //view.get(i0, ...):
  code.push("proto.get=function "+className+"_get("+args.join(",")+"){")
  if(useGetters) {
    code.push("return this.data.get("+index_str+")}")
  } else {
    code.push("return this.data["+index_str+"]}")
  }
  
  //view.index:
  code.push(
    "proto.index=function "+className+"_index(", args.join(), "){return "+index_str+"}")

  //view.hi():
  code.push("proto.hi=function "+className+"_hi("+args.join(",")+"){return new "+className+"(this.data,"+
    indices.map(function(i) {
      return ["(typeof i",i,"!=='number'||i",i,"<0)?this.shape[", i, "]:i", i,"|0"].join("")
    }).join(",")+","+
    indices.map(function(i) {
      return "this.stride["+i + "]"
    }).join(",")+",this.offset)}")
  
  //view.lo():
  var a_vars = indices.map(function(i) { return "a"+i+"=this.shape["+i+"]" })
  var c_vars = indices.map(function(i) { return "c"+i+"=this.stride["+i+"]" })
  code.push("proto.lo=function "+className+"_lo("+args.join(",")+"){var b=this.offset,d=0,"+a_vars.join(",")+","+c_vars.join(","))
  for(var i=0; i<dimension; ++i) {
    code.push(
"if(typeof i"+i+"==='number'&&i"+i+">=0){\
d=i"+i+"|0;\
b+=c"+i+"*d;\
a"+i+"-=d}")
  }
  code.push("return new "+className+"(this.data,"+
    indices.map(function(i) {
      return "a"+i
    }).join(",")+","+
    indices.map(function(i) {
      return "c"+i
    }).join(",")+",b)}")
  
  //view.step():
  code.push("proto.step=function "+className+"_step("+args.join(",")+"){var "+
    indices.map(function(i) {
      return "a"+i+"=this.shape["+i+"]"
    }).join(",")+","+
    indices.map(function(i) {
      return "b"+i+"=this.stride["+i+"]"
    }).join(",")+",c=this.offset,d=0,ceil=Math.ceil")
  for(var i=0; i<dimension; ++i) {
    code.push(
"if(typeof i"+i+"==='number'){\
d=i"+i+"|0;\
if(d<0){\
c+=b"+i+"*(a"+i+"-1);\
a"+i+"=ceil(-a"+i+"/d)\
}else{\
a"+i+"=ceil(a"+i+"/d)\
}\
b"+i+"*=d\
}")
  }
  code.push("return new "+className+"(this.data,"+
    indices.map(function(i) {
      return "a" + i
    }).join(",")+","+
    indices.map(function(i) {
      return "b" + i
    }).join(",")+",c)}")
  
  //view.transpose():
  var tShape = new Array(dimension)
  var tStride = new Array(dimension)
  for(var i=0; i<dimension; ++i) {
    tShape[i] = "a[i"+i+"]"
    tStride[i] = "b[i"+i+"]"
  }
  code.push("proto.transpose=function "+className+"_transpose("+args+"){"+
    args.map(function(n,idx) { return n + "=(" + n + "===undefined?" + idx + ":" + n + "|0)"}).join(";"),
    "var a=this.shape,b=this.stride;return new "+className+"(this.data,"+tShape.join(",")+","+tStride.join(",")+",this.offset)}")
  
  //view.pick():
  code.push("proto.pick=function "+className+"_pick("+args+"){var a=[],b=[],c=this.offset")
  for(var i=0; i<dimension; ++i) {
    code.push("if(typeof i"+i+"==='number'&&i"+i+">=0){c=(c+this.stride["+i+"]*i"+i+")|0}else{a.push(this.shape["+i+"]);b.push(this.stride["+i+"])}")
  }
  code.push("var ctor=CTOR_LIST[a.length+1];return ctor(this.data,a,b,c)}")
    
  //Add return statement
  code.push("return function construct_"+className+"(data,shape,stride,offset){return new "+className+"(data,"+
    indices.map(function(i) {
      return "shape["+i+"]"
    }).join(",")+","+
    indices.map(function(i) {
      return "stride["+i+"]"
    }).join(",")+",offset)}")

  //Compile procedure
  var procedure = new Function("CTOR_LIST", "ORDER", code.join("\n"))
  return procedure(CACHED_CONSTRUCTORS[dtype], order)
}

function arrayDType(data) {
  if(hasBuffer) {
    if(Buffer.isBuffer(data)) {
      return "buffer"
    }
  }
  if(hasTypedArrays) {
    switch(Object.prototype.toString.call(data)) {
      case "[object Float64Array]":
        return "float64"
      case "[object Float32Array]":
        return "float32"
      case "[object Int8Array]":
        return "int8"
      case "[object Int16Array]":
        return "int16"
      case "[object Int32Array]":
        return "int32"
      case "[object Uint8Array]":
        return "uint8"
      case "[object Uint16Array]":
        return "uint16"
      case "[object Uint32Array]":
        return "uint32"
      case "[object Uint8ClampedArray]":
        return "uint8_clamped"
    }
  }
  if(Array.isArray(data)) {
    return "array"
  }
  return "generic"
}

var CACHED_CONSTRUCTORS = {
  "float32":[],
  "float64":[],
  "int8":[],
  "int16":[],
  "int32":[],
  "uint8":[],
  "uint16":[],
  "uint32":[],
  "array":[],
  "uint8_clamped":[],
  "buffer":[],
  "generic":[]
}

;(function() {
  for(var id in CACHED_CONSTRUCTORS) {
    CACHED_CONSTRUCTORS[id].push(compileConstructor(id, -1))
  }
});

function wrappedNDArrayCtor(data, shape, stride, offset) {
  if(data === undefined) {
    var ctor = CACHED_CONSTRUCTORS.array[0]
    return ctor([])
  } else if(typeof data === "number") {
    data = [data]
  }
  if(shape === undefined) {
    shape = [ data.length ]
  }
  var d = shape.length
  if(stride === undefined) {
    stride = new Array(d)
    for(var i=d-1, sz=1; i>=0; --i) {
      stride[i] = sz
      sz *= shape[i]
    }
  }
  if(offset === undefined) {
    offset = 0
    for(var i=0; i<d; ++i) {
      if(stride[i] < 0) {
        offset -= (shape[i]-1)*stride[i]
      }
    }
  }
  var dtype = arrayDType(data)
  var ctor_list = CACHED_CONSTRUCTORS[dtype]
  while(ctor_list.length <= d+1) {
    ctor_list.push(compileConstructor(dtype, ctor_list.length-1))
  }
  var ctor = ctor_list[d+1]
  return ctor(data, shape, stride, offset)
}

module.exports = wrappedNDArrayCtor
}).call(this,require("buffer").Buffer)
},{"buffer":"/projects/blackice/node_modules/browserify/node_modules/buffer/index.js","iota-array":"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/gl-buffer/node_modules/ndarray/node_modules/iota-array/iota.js"}],"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/gl-buffer/node_modules/ndarray/node_modules/iota-array/iota.js":[function(require,module,exports){
module.exports=require("/projects/blackice/node_modules/gl-texture2d/node_modules/ndarray/node_modules/iota-array/iota.js")
},{"/projects/blackice/node_modules/gl-texture2d/node_modules/ndarray/node_modules/iota-array/iota.js":"/projects/blackice/node_modules/gl-texture2d/node_modules/ndarray/node_modules/iota-array/iota.js"}],"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/gl-buffer/node_modules/typedarray-pool/pool.js":[function(require,module,exports){
module.exports=require("/projects/blackice/node_modules/gl-texture2d/node_modules/typedarray-pool/pool.js")
},{"/projects/blackice/node_modules/gl-texture2d/node_modules/typedarray-pool/pool.js":"/projects/blackice/node_modules/gl-texture2d/node_modules/typedarray-pool/pool.js"}],"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/gl-buffer/node_modules/webglew/node_modules/weak-map/weak-map.js":[function(require,module,exports){
// Copyright (C) 2011 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Install a leaky WeakMap emulation on platforms that
 * don't provide a built-in one.
 *
 * <p>Assumes that an ES5 platform where, if {@code WeakMap} is
 * already present, then it conforms to the anticipated ES6
 * specification. To run this file on an ES5 or almost ES5
 * implementation where the {@code WeakMap} specification does not
 * quite conform, run <code>repairES5.js</code> first.
 *
 * <p>Even though WeakMapModule is not global, the linter thinks it
 * is, which is why it is in the overrides list below.
 *
 * <p>NOTE: Before using this WeakMap emulation in a non-SES
 * environment, see the note below about hiddenRecord.
 *
 * @author Mark S. Miller
 * @requires crypto, ArrayBuffer, Uint8Array, navigator, console
 * @overrides WeakMap, ses, Proxy
 * @overrides WeakMapModule
 */

/**
 * This {@code WeakMap} emulation is observably equivalent to the
 * ES-Harmony WeakMap, but with leakier garbage collection properties.
 *
 * <p>As with true WeakMaps, in this emulation, a key does not
 * retain maps indexed by that key and (crucially) a map does not
 * retain the keys it indexes. A map by itself also does not retain
 * the values associated with that map.
 *
 * <p>However, the values associated with a key in some map are
 * retained so long as that key is retained and those associations are
 * not overridden. For example, when used to support membranes, all
 * values exported from a given membrane will live for the lifetime
 * they would have had in the absence of an interposed membrane. Even
 * when the membrane is revoked, all objects that would have been
 * reachable in the absence of revocation will still be reachable, as
 * far as the GC can tell, even though they will no longer be relevant
 * to ongoing computation.
 *
 * <p>The API implemented here is approximately the API as implemented
 * in FF6.0a1 and agreed to by MarkM, Andreas Gal, and Dave Herman,
 * rather than the offially approved proposal page. TODO(erights):
 * upgrade the ecmascript WeakMap proposal page to explain this API
 * change and present to EcmaScript committee for their approval.
 *
 * <p>The first difference between the emulation here and that in
 * FF6.0a1 is the presence of non enumerable {@code get___, has___,
 * set___, and delete___} methods on WeakMap instances to represent
 * what would be the hidden internal properties of a primitive
 * implementation. Whereas the FF6.0a1 WeakMap.prototype methods
 * require their {@code this} to be a genuine WeakMap instance (i.e.,
 * an object of {@code [[Class]]} "WeakMap}), since there is nothing
 * unforgeable about the pseudo-internal method names used here,
 * nothing prevents these emulated prototype methods from being
 * applied to non-WeakMaps with pseudo-internal methods of the same
 * names.
 *
 * <p>Another difference is that our emulated {@code
 * WeakMap.prototype} is not itself a WeakMap. A problem with the
 * current FF6.0a1 API is that WeakMap.prototype is itself a WeakMap
 * providing ambient mutability and an ambient communications
 * channel. Thus, if a WeakMap is already present and has this
 * problem, repairES5.js wraps it in a safe wrappper in order to
 * prevent access to this channel. (See
 * PATCH_MUTABLE_FROZEN_WEAKMAP_PROTO in repairES5.js).
 */

/**
 * If this is a full <a href=
 * "http://code.google.com/p/es-lab/wiki/SecureableES5"
 * >secureable ES5</a> platform and the ES-Harmony {@code WeakMap} is
 * absent, install an approximate emulation.
 *
 * <p>If WeakMap is present but cannot store some objects, use our approximate
 * emulation as a wrapper.
 *
 * <p>If this is almost a secureable ES5 platform, then WeakMap.js
 * should be run after repairES5.js.
 *
 * <p>See {@code WeakMap} for documentation of the garbage collection
 * properties of this WeakMap emulation.
 */
(function WeakMapModule() {
  "use strict";

  if (typeof ses !== 'undefined' && ses.ok && !ses.ok()) {
    // already too broken, so give up
    return;
  }

  /**
   * In some cases (current Firefox), we must make a choice betweeen a
   * WeakMap which is capable of using all varieties of host objects as
   * keys and one which is capable of safely using proxies as keys. See
   * comments below about HostWeakMap and DoubleWeakMap for details.
   *
   * This function (which is a global, not exposed to guests) marks a
   * WeakMap as permitted to do what is necessary to index all host
   * objects, at the cost of making it unsafe for proxies.
   *
   * Do not apply this function to anything which is not a genuine
   * fresh WeakMap.
   */
  function weakMapPermitHostObjects(map) {
    // identity of function used as a secret -- good enough and cheap
    if (map.permitHostObjects___) {
      map.permitHostObjects___(weakMapPermitHostObjects);
    }
  }
  if (typeof ses !== 'undefined') {
    ses.weakMapPermitHostObjects = weakMapPermitHostObjects;
  }

  // IE 11 has no Proxy but has a broken WeakMap such that we need to patch
  // it using DoubleWeakMap; this flag tells DoubleWeakMap so.
  var doubleWeakMapCheckSilentFailure = false;

  // Check if there is already a good-enough WeakMap implementation, and if so
  // exit without replacing it.
  if (typeof WeakMap === 'function') {
    var HostWeakMap = WeakMap;
    // There is a WeakMap -- is it good enough?
    if (typeof navigator !== 'undefined' &&
        /Firefox/.test(navigator.userAgent)) {
      // We're now *assuming not*, because as of this writing (2013-05-06)
      // Firefox's WeakMaps have a miscellany of objects they won't accept, and
      // we don't want to make an exhaustive list, and testing for just one
      // will be a problem if that one is fixed alone (as they did for Event).

      // If there is a platform that we *can* reliably test on, here's how to
      // do it:
      //  var problematic = ... ;
      //  var testHostMap = new HostWeakMap();
      //  try {
      //    testHostMap.set(problematic, 1);  // Firefox 20 will throw here
      //    if (testHostMap.get(problematic) === 1) {
      //      return;
      //    }
      //  } catch (e) {}

    } else {
      // IE 11 bug: WeakMaps silently fail to store frozen objects.
      var testMap = new HostWeakMap();
      var testObject = Object.freeze({});
      testMap.set(testObject, 1);
      if (testMap.get(testObject) !== 1) {
        doubleWeakMapCheckSilentFailure = true;
        // Fall through to installing our WeakMap.
      } else {
        module.exports = WeakMap;
        return;
      }
    }
  }

  var hop = Object.prototype.hasOwnProperty;
  var gopn = Object.getOwnPropertyNames;
  var defProp = Object.defineProperty;
  var isExtensible = Object.isExtensible;

  /**
   * Security depends on HIDDEN_NAME being both <i>unguessable</i> and
   * <i>undiscoverable</i> by untrusted code.
   *
   * <p>Given the known weaknesses of Math.random() on existing
   * browsers, it does not generate unguessability we can be confident
   * of.
   *
   * <p>It is the monkey patching logic in this file that is intended
   * to ensure undiscoverability. The basic idea is that there are
   * three fundamental means of discovering properties of an object:
   * The for/in loop, Object.keys(), and Object.getOwnPropertyNames(),
   * as well as some proposed ES6 extensions that appear on our
   * whitelist. The first two only discover enumerable properties, and
   * we only use HIDDEN_NAME to name a non-enumerable property, so the
   * only remaining threat should be getOwnPropertyNames and some
   * proposed ES6 extensions that appear on our whitelist. We monkey
   * patch them to remove HIDDEN_NAME from the list of properties they
   * returns.
   *
   * <p>TODO(erights): On a platform with built-in Proxies, proxies
   * could be used to trap and thereby discover the HIDDEN_NAME, so we
   * need to monkey patch Proxy.create, Proxy.createFunction, etc, in
   * order to wrap the provided handler with the real handler which
   * filters out all traps using HIDDEN_NAME.
   *
   * <p>TODO(erights): Revisit Mike Stay's suggestion that we use an
   * encapsulated function at a not-necessarily-secret name, which
   * uses the Stiegler shared-state rights amplification pattern to
   * reveal the associated value only to the WeakMap in which this key
   * is associated with that value. Since only the key retains the
   * function, the function can also remember the key without causing
   * leakage of the key, so this doesn't violate our general gc
   * goals. In addition, because the name need not be a guarded
   * secret, we could efficiently handle cross-frame frozen keys.
   */
  var HIDDEN_NAME_PREFIX = 'weakmap:';
  var HIDDEN_NAME = HIDDEN_NAME_PREFIX + 'ident:' + Math.random() + '___';

  if (typeof crypto !== 'undefined' &&
      typeof crypto.getRandomValues === 'function' &&
      typeof ArrayBuffer === 'function' &&
      typeof Uint8Array === 'function') {
    var ab = new ArrayBuffer(25);
    var u8s = new Uint8Array(ab);
    crypto.getRandomValues(u8s);
    HIDDEN_NAME = HIDDEN_NAME_PREFIX + 'rand:' +
      Array.prototype.map.call(u8s, function(u8) {
        return (u8 % 36).toString(36);
      }).join('') + '___';
  }

  function isNotHiddenName(name) {
    return !(
        name.substr(0, HIDDEN_NAME_PREFIX.length) == HIDDEN_NAME_PREFIX &&
        name.substr(name.length - 3) === '___');
  }

  /**
   * Monkey patch getOwnPropertyNames to avoid revealing the
   * HIDDEN_NAME.
   *
   * <p>The ES5.1 spec requires each name to appear only once, but as
   * of this writing, this requirement is controversial for ES6, so we
   * made this code robust against this case. If the resulting extra
   * search turns out to be expensive, we can probably relax this once
   * ES6 is adequately supported on all major browsers, iff no browser
   * versions we support at that time have relaxed this constraint
   * without providing built-in ES6 WeakMaps.
   */
  defProp(Object, 'getOwnPropertyNames', {
    value: function fakeGetOwnPropertyNames(obj) {
      return gopn(obj).filter(isNotHiddenName);
    }
  });

  /**
   * getPropertyNames is not in ES5 but it is proposed for ES6 and
   * does appear in our whitelist, so we need to clean it too.
   */
  if ('getPropertyNames' in Object) {
    var originalGetPropertyNames = Object.getPropertyNames;
    defProp(Object, 'getPropertyNames', {
      value: function fakeGetPropertyNames(obj) {
        return originalGetPropertyNames(obj).filter(isNotHiddenName);
      }
    });
  }

  /**
   * <p>To treat objects as identity-keys with reasonable efficiency
   * on ES5 by itself (i.e., without any object-keyed collections), we
   * need to add a hidden property to such key objects when we
   * can. This raises several issues:
   * <ul>
   * <li>Arranging to add this property to objects before we lose the
   *     chance, and
   * <li>Hiding the existence of this new property from most
   *     JavaScript code.
   * <li>Preventing <i>certification theft</i>, where one object is
   *     created falsely claiming to be the key of an association
   *     actually keyed by another object.
   * <li>Preventing <i>value theft</i>, where untrusted code with
   *     access to a key object but not a weak map nevertheless
   *     obtains access to the value associated with that key in that
   *     weak map.
   * </ul>
   * We do so by
   * <ul>
   * <li>Making the name of the hidden property unguessable, so "[]"
   *     indexing, which we cannot intercept, cannot be used to access
   *     a property without knowing the name.
   * <li>Making the hidden property non-enumerable, so we need not
   *     worry about for-in loops or {@code Object.keys},
   * <li>monkey patching those reflective methods that would
   *     prevent extensions, to add this hidden property first,
   * <li>monkey patching those methods that would reveal this
   *     hidden property.
   * </ul>
   * Unfortunately, because of same-origin iframes, we cannot reliably
   * add this hidden property before an object becomes
   * non-extensible. Instead, if we encounter a non-extensible object
   * without a hidden record that we can detect (whether or not it has
   * a hidden record stored under a name secret to us), then we just
   * use the key object itself to represent its identity in a brute
   * force leaky map stored in the weak map, losing all the advantages
   * of weakness for these.
   */
  function getHiddenRecord(key) {
    if (key !== Object(key)) {
      throw new TypeError('Not an object: ' + key);
    }
    var hiddenRecord = key[HIDDEN_NAME];
    if (hiddenRecord && hiddenRecord.key === key) { return hiddenRecord; }
    if (!isExtensible(key)) {
      // Weak map must brute force, as explained in doc-comment above.
      return void 0;
    }

    // The hiddenRecord and the key point directly at each other, via
    // the "key" and HIDDEN_NAME properties respectively. The key
    // field is for quickly verifying that this hidden record is an
    // own property, not a hidden record from up the prototype chain.
    //
    // NOTE: Because this WeakMap emulation is meant only for systems like
    // SES where Object.prototype is frozen without any numeric
    // properties, it is ok to use an object literal for the hiddenRecord.
    // This has two advantages:
    // * It is much faster in a performance critical place
    // * It avoids relying on Object.create(null), which had been
    //   problematic on Chrome 28.0.1480.0. See
    //   https://code.google.com/p/google-caja/issues/detail?id=1687
    hiddenRecord = { key: key };

    // When using this WeakMap emulation on platforms where
    // Object.prototype might not be frozen and Object.create(null) is
    // reliable, use the following two commented out lines instead.
    // hiddenRecord = Object.create(null);
    // hiddenRecord.key = key;

    // Please contact us if you need this to work on platforms where
    // Object.prototype might not be frozen and
    // Object.create(null) might not be reliable.

    try {
      defProp(key, HIDDEN_NAME, {
        value: hiddenRecord,
        writable: false,
        enumerable: false,
        configurable: false
      });
      return hiddenRecord;
    } catch (error) {
      // Under some circumstances, isExtensible seems to misreport whether
      // the HIDDEN_NAME can be defined.
      // The circumstances have not been isolated, but at least affect
      // Node.js v0.10.26 on TravisCI / Linux, but not the same version of
      // Node.js on OS X.
      return void 0;
    }
  }

  /**
   * Monkey patch operations that would make their argument
   * non-extensible.
   *
   * <p>The monkey patched versions throw a TypeError if their
   * argument is not an object, so it should only be done to functions
   * that should throw a TypeError anyway if their argument is not an
   * object.
   */
  (function(){
    var oldFreeze = Object.freeze;
    defProp(Object, 'freeze', {
      value: function identifyingFreeze(obj) {
        getHiddenRecord(obj);
        return oldFreeze(obj);
      }
    });
    var oldSeal = Object.seal;
    defProp(Object, 'seal', {
      value: function identifyingSeal(obj) {
        getHiddenRecord(obj);
        return oldSeal(obj);
      }
    });
    var oldPreventExtensions = Object.preventExtensions;
    defProp(Object, 'preventExtensions', {
      value: function identifyingPreventExtensions(obj) {
        getHiddenRecord(obj);
        return oldPreventExtensions(obj);
      }
    });
  })();

  function constFunc(func) {
    func.prototype = null;
    return Object.freeze(func);
  }

  var calledAsFunctionWarningDone = false;
  function calledAsFunctionWarning() {
    // Future ES6 WeakMap is currently (2013-09-10) expected to reject WeakMap()
    // but we used to permit it and do it ourselves, so warn only.
    if (!calledAsFunctionWarningDone && typeof console !== 'undefined') {
      calledAsFunctionWarningDone = true;
      console.warn('WeakMap should be invoked as new WeakMap(), not ' +
          'WeakMap(). This will be an error in the future.');
    }
  }

  var nextId = 0;

  var OurWeakMap = function() {
    if (!(this instanceof OurWeakMap)) {  // approximate test for new ...()
      calledAsFunctionWarning();
    }

    // We are currently (12/25/2012) never encountering any prematurely
    // non-extensible keys.
    var keys = []; // brute force for prematurely non-extensible keys.
    var values = []; // brute force for corresponding values.
    var id = nextId++;

    function get___(key, opt_default) {
      var index;
      var hiddenRecord = getHiddenRecord(key);
      if (hiddenRecord) {
        return id in hiddenRecord ? hiddenRecord[id] : opt_default;
      } else {
        index = keys.indexOf(key);
        return index >= 0 ? values[index] : opt_default;
      }
    }

    function has___(key) {
      var hiddenRecord = getHiddenRecord(key);
      if (hiddenRecord) {
        return id in hiddenRecord;
      } else {
        return keys.indexOf(key) >= 0;
      }
    }

    function set___(key, value) {
      var index;
      var hiddenRecord = getHiddenRecord(key);
      if (hiddenRecord) {
        hiddenRecord[id] = value;
      } else {
        index = keys.indexOf(key);
        if (index >= 0) {
          values[index] = value;
        } else {
          // Since some browsers preemptively terminate slow turns but
          // then continue computing with presumably corrupted heap
          // state, we here defensively get keys.length first and then
          // use it to update both the values and keys arrays, keeping
          // them in sync.
          index = keys.length;
          values[index] = value;
          // If we crash here, values will be one longer than keys.
          keys[index] = key;
        }
      }
      return this;
    }

    function delete___(key) {
      var hiddenRecord = getHiddenRecord(key);
      var index, lastIndex;
      if (hiddenRecord) {
        return id in hiddenRecord && delete hiddenRecord[id];
      } else {
        index = keys.indexOf(key);
        if (index < 0) {
          return false;
        }
        // Since some browsers preemptively terminate slow turns but
        // then continue computing with potentially corrupted heap
        // state, we here defensively get keys.length first and then use
        // it to update both the keys and the values array, keeping
        // them in sync. We update the two with an order of assignments,
        // such that any prefix of these assignments will preserve the
        // key/value correspondence, either before or after the delete.
        // Note that this needs to work correctly when index === lastIndex.
        lastIndex = keys.length - 1;
        keys[index] = void 0;
        // If we crash here, there's a void 0 in the keys array, but
        // no operation will cause a "keys.indexOf(void 0)", since
        // getHiddenRecord(void 0) will always throw an error first.
        values[index] = values[lastIndex];
        // If we crash here, values[index] cannot be found here,
        // because keys[index] is void 0.
        keys[index] = keys[lastIndex];
        // If index === lastIndex and we crash here, then keys[index]
        // is still void 0, since the aliasing killed the previous key.
        keys.length = lastIndex;
        // If we crash here, keys will be one shorter than values.
        values.length = lastIndex;
        return true;
      }
    }

    return Object.create(OurWeakMap.prototype, {
      get___:    { value: constFunc(get___) },
      has___:    { value: constFunc(has___) },
      set___:    { value: constFunc(set___) },
      delete___: { value: constFunc(delete___) }
    });
  };

  OurWeakMap.prototype = Object.create(Object.prototype, {
    get: {
      /**
       * Return the value most recently associated with key, or
       * opt_default if none.
       */
      value: function get(key, opt_default) {
        return this.get___(key, opt_default);
      },
      writable: true,
      configurable: true
    },

    has: {
      /**
       * Is there a value associated with key in this WeakMap?
       */
      value: function has(key) {
        return this.has___(key);
      },
      writable: true,
      configurable: true
    },

    set: {
      /**
       * Associate value with key in this WeakMap, overwriting any
       * previous association if present.
       */
      value: function set(key, value) {
        return this.set___(key, value);
      },
      writable: true,
      configurable: true
    },

    'delete': {
      /**
       * Remove any association for key in this WeakMap, returning
       * whether there was one.
       *
       * <p>Note that the boolean return here does not work like the
       * {@code delete} operator. The {@code delete} operator returns
       * whether the deletion succeeds at bringing about a state in
       * which the deleted property is absent. The {@code delete}
       * operator therefore returns true if the property was already
       * absent, whereas this {@code delete} method returns false if
       * the association was already absent.
       */
      value: function remove(key) {
        return this.delete___(key);
      },
      writable: true,
      configurable: true
    }
  });

  if (typeof HostWeakMap === 'function') {
    (function() {
      // If we got here, then the platform has a WeakMap but we are concerned
      // that it may refuse to store some key types. Therefore, make a map
      // implementation which makes use of both as possible.

      // In this mode we are always using double maps, so we are not proxy-safe.
      // This combination does not occur in any known browser, but we had best
      // be safe.
      if (doubleWeakMapCheckSilentFailure && typeof Proxy !== 'undefined') {
        Proxy = undefined;
      }

      function DoubleWeakMap() {
        if (!(this instanceof OurWeakMap)) {  // approximate test for new ...()
          calledAsFunctionWarning();
        }

        // Preferable, truly weak map.
        var hmap = new HostWeakMap();

        // Our hidden-property-based pseudo-weak-map. Lazily initialized in the
        // 'set' implementation; thus we can avoid performing extra lookups if
        // we know all entries actually stored are entered in 'hmap'.
        var omap = undefined;

        // Hidden-property maps are not compatible with proxies because proxies
        // can observe the hidden name and either accidentally expose it or fail
        // to allow the hidden property to be set. Therefore, we do not allow
        // arbitrary WeakMaps to switch to using hidden properties, but only
        // those which need the ability, and unprivileged code is not allowed
        // to set the flag.
        //
        // (Except in doubleWeakMapCheckSilentFailure mode in which case we
        // disable proxies.)
        var enableSwitching = false;

        function dget(key, opt_default) {
          if (omap) {
            return hmap.has(key) ? hmap.get(key)
                : omap.get___(key, opt_default);
          } else {
            return hmap.get(key, opt_default);
          }
        }

        function dhas(key) {
          return hmap.has(key) || (omap ? omap.has___(key) : false);
        }

        var dset;
        if (doubleWeakMapCheckSilentFailure) {
          dset = function(key, value) {
            hmap.set(key, value);
            if (!hmap.has(key)) {
              if (!omap) { omap = new OurWeakMap(); }
              omap.set(key, value);
            }
            return this;
          };
        } else {
          dset = function(key, value) {
            if (enableSwitching) {
              try {
                hmap.set(key, value);
              } catch (e) {
                if (!omap) { omap = new OurWeakMap(); }
                omap.set___(key, value);
              }
            } else {
              hmap.set(key, value);
            }
            return this;
          };
        }

        function ddelete(key) {
          var result = !!hmap['delete'](key);
          if (omap) { return omap.delete___(key) || result; }
          return result;
        }

        return Object.create(OurWeakMap.prototype, {
          get___:    { value: constFunc(dget) },
          has___:    { value: constFunc(dhas) },
          set___:    { value: constFunc(dset) },
          delete___: { value: constFunc(ddelete) },
          permitHostObjects___: { value: constFunc(function(token) {
            if (token === weakMapPermitHostObjects) {
              enableSwitching = true;
            } else {
              throw new Error('bogus call to permitHostObjects___');
            }
          })}
        });
      }
      DoubleWeakMap.prototype = OurWeakMap.prototype;
      module.exports = DoubleWeakMap;

      // define .constructor to hide OurWeakMap ctor
      Object.defineProperty(WeakMap.prototype, 'constructor', {
        value: WeakMap,
        enumerable: false,  // as default .constructor is
        configurable: true,
        writable: true
      });
    })();
  } else {
    // There is no host WeakMap, so we must use the emulation.

    // Emulated WeakMaps are incompatible with native proxies (because proxies
    // can observe the hidden name), so we must disable Proxy usage (in
    // ArrayLike and Domado, currently).
    if (typeof Proxy !== 'undefined') {
      Proxy = undefined;
    }

    module.exports = OurWeakMap;
  }
})();

},{}],"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/gl-buffer/node_modules/webglew/webglew.js":[function(require,module,exports){
'use strict'

var weakMap = typeof WeakMap === 'undefined' ? require('weak-map') : WeakMap

var WebGLEWStruct = new weakMap()

function baseName(ext_name) {
  return ext_name.replace(/^[A-Z]+_/, '')
}

function initWebGLEW(gl) {
  var struct = WebGLEWStruct.get(gl)
  if(struct) {
    return struct
  }
  var extensions = {}
  var supported = gl.getSupportedExtensions()
  for(var i=0; i<supported.length; ++i) {
    var extName = supported[i]

    //Skip MOZ_ extensions
    if(extName.indexOf('MOZ_') === 0) {
      continue
    }
    var ext = gl.getExtension(supported[i])
    if(!ext) {
      continue
    }
    while(true) {
      extensions[extName] = ext
      var base = baseName(extName)
      if(base === extName) {
        break
      }
      extName = base
    }
  }
  WebGLEWStruct.set(gl, extensions)
  return extensions
}
module.exports = initWebGLEW
},{"weak-map":"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/gl-buffer/node_modules/webglew/node_modules/weak-map/weak-map.js"}],"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/gl-white-texture/index.js":[function(require,module,exports){
var create = require('gl-texture2d')
var ndarray = require('ndarray')

module.exports = function(gl) {
    //fill an array with 0xff
    var data = Array.apply(null, new Array(16))
            .map(Number.prototype.valueOf, 0xFF);
    //create a 2D ndarray
    var array = ndarray(new Uint8Array(data), [2, 2, 4])
    return create(gl, array)
}
},{"gl-texture2d":"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-texture2d/texture.js","ndarray":"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/gl-white-texture/node_modules/ndarray/ndarray.js"}],"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/gl-white-texture/node_modules/ndarray/ndarray.js":[function(require,module,exports){
module.exports=require("/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/gl-buffer/node_modules/ndarray/ndarray.js")
},{"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/gl-buffer/node_modules/ndarray/ndarray.js":"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/gl-buffer/node_modules/ndarray/ndarray.js"}],"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/mixes/index.js":[function(require,module,exports){
module.exports=require("/projects/blackice/node_modules/mixes/index.js")
},{"/projects/blackice/node_modules/mixes/index.js":"/projects/blackice/node_modules/mixes/index.js"}],"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/number-util/index.js":[function(require,module,exports){
var int8 = new Int8Array(4);
var int32 = new Int32Array(int8.buffer, 0, 1);
var float32 = new Float32Array(int8.buffer, 0, 1);

/**
 * A singleton for number utilities. 
 * @class NumberUtil
 */
var NumberUtil = function() {

};


/**
 * Returns a float representation of the given int bits. ArrayBuffer
 * is used for the conversion.
 *
 * @method  intBitsToFloat
 * @static
 * @param  {Number} i the int to cast
 * @return {Number}   the float
 */
NumberUtil.intBitsToFloat = function(i) {
	int32[0] = i;
	return float32[0];
};

/**
 * Returns the int bits from the given float. ArrayBuffer is used
 * for the conversion.
 *
 * @method  floatToIntBits
 * @static
 * @param  {Number} f the float to cast
 * @return {Number}   the int bits
 */
NumberUtil.floatToIntBits = function(f) {
	float32[0] = f;
	return int32[0];
};

/**
 * Encodes ABGR int as a float, with slight precision loss.
 *
 * @method  intToFloatColor
 * @static
 * @param {Number} value an ABGR packed integer
 */
NumberUtil.intToFloatColor = function(value) {
	return NumberUtil.intBitsToFloat( value & 0xfeffffff );
};

/**
 * Returns a float encoded ABGR value from the given RGBA
 * bytes (0 - 255). Useful for saving bandwidth in vertex data.
 *
 * @method  colorToFloat
 * @static
 * @param {Number} r the Red byte (0 - 255)
 * @param {Number} g the Green byte (0 - 255)
 * @param {Number} b the Blue byte (0 - 255)
 * @param {Number} a the Alpha byte (0 - 255)
 * @return {Float32}  a Float32 of the RGBA color
 */
NumberUtil.colorToFloat = function(r, g, b, a) {
	var bits = (a << 24 | b << 16 | g << 8 | r);
	return NumberUtil.intToFloatColor(bits);
};

/**
 * Returns true if the number is a power-of-two.
 *
 * @method  isPowerOfTwo
 * @param  {Number}  n the number to test
 * @return {Boolean}   true if power-of-two
 */
NumberUtil.isPowerOfTwo = function(n) {
	return (n & (n - 1)) === 0;
};

/**
 * Returns the next highest power-of-two from the specified number. 
 * 
 * @param  {Number} n the number to test
 * @return {Number}   the next highest power of two
 */
NumberUtil.nextPowerOfTwo = function(n) {
	n--;
	n |= n >> 1;
	n |= n >> 2;
	n |= n >> 4;
	n |= n >> 8;
	n |= n >> 16;
	return n+1;
};

module.exports = NumberUtil;
},{}],"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/premultiplied-rgba/index.js":[function(require,module,exports){
function premultiply(rgba, out) {
	if (!out || typeof out === 'number')
		out = [0,0,0,0]
	out[0] = rgba[0] * rgba[3]
	out[1] = rgba[1] * rgba[3]
	out[2] = rgba[2] * rgba[3]
	out[3] = rgba[3]
	return out
}
module.exports = premultiply
},{}],"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/pack-rgba-float.js":[function(require,module,exports){
var packColor = require('number-util').colorToFloat

module.exports = function colorToFloat(rgba) {
    return packColor(
        ~~(rgba[0] * 255),
        ~~(rgba[1] * 255),
        ~~(rgba[2] * 255),
        ~~(rgba[3] * 255)
    )
}
},{"number-util":"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/number-util/index.js"}],"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/inherits/inherits_browser.js":[function(require,module,exports){
module.exports=require("/projects/blackice/node_modules/inherits/inherits_browser.js")
},{"/projects/blackice/node_modules/inherits/inherits_browser.js":"/projects/blackice/node_modules/inherits/inherits_browser.js"}],"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/texcoord/index.js":[function(require,module,exports){
module.exports = function texcoord(position, shape, texShape, out) {
    if (!out)
        out = [0, 0, 1, 1]

    position = position || [0, 0]
    shape = shape || [1, 1]

    texShape = texShape || shape

    var invWidth = 1 / texShape[0]
    var invHeight = 1 / texShape[1]
    var x = position[0],
        y = position[1],
        w = shape[0],
        h = shape[1]

    out[0] = x * invWidth
    out[1] = y * invHeight
    out[2] = (x + w) * invWidth
    out[3] = (y + h) * invHeight
    return out
}
},{}],"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-texture2d/texture.js":[function(require,module,exports){
module.exports=require("/projects/blackice/node_modules/gl-texture2d/texture.js")
},{"/projects/blackice/node_modules/gl-texture2d/texture.js":"/projects/blackice/node_modules/gl-texture2d/texture.js"}],"/projects/blackice/node_modules/three-sdf-text/node_modules/xtend/immutable.js":[function(require,module,exports){
module.exports = extend

function extend() {
    var target = {}

    for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i]

        for (var key in source) {
            if (source.hasOwnProperty(key)) {
                target[key] = source[key]
            }
        }
    }

    return target
}

},{}],"/projects/blackice/node_modules/three-shader-fxaa/index.js":[function(require,module,exports){
var glslify = require("glslify");
var threeify = require("three-glslify");
var source = require("glslify/simple-adapter.js")("\n#define GLSLIFY 1\n\nvarying vec2 vUv;\nvarying vec2 v_rgbNW;\nvarying vec2 v_rgbNE;\nvarying vec2 v_rgbSW;\nvarying vec2 v_rgbSE;\nvarying vec2 v_rgbM;\nuniform vec2 resolution;\nvoid a_x_texcoords(vec2 fragCoord, vec2 resolution, out vec2 v_rgbNW, out vec2 v_rgbNE, out vec2 v_rgbSW, out vec2 v_rgbSE, out vec2 v_rgbM) {\n  vec2 inverseVP = 1.0 / resolution.xy;\n  v_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;\n  v_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;\n  v_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;\n  v_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;\n  v_rgbM = vec2(fragCoord * inverseVP);\n}\nvoid main() {\n  vUv = uv;\n  vec2 fragCoord = uv * resolution;\n  a_x_texcoords(fragCoord, resolution, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}", "\n#define GLSLIFY 1\n\nvarying vec2 vUv;\nvarying vec2 v_rgbNW;\nvarying vec2 v_rgbNE;\nvarying vec2 v_rgbSW;\nvarying vec2 v_rgbSE;\nvarying vec2 v_rgbM;\nuniform vec2 resolution;\nuniform sampler2D tDiffuse;\n#ifndef FXAA_REDUCE_MIN\n\n#define FXAA_REDUCE_MIN   (1.0/ 128.0)\n\n#endif\n\n#ifndef FXAA_REDUCE_MUL\n\n#define FXAA_REDUCE_MUL   (1.0 / 8.0)\n\n#endif\n\n#ifndef FXAA_SPAN_MAX\n\n#define FXAA_SPAN_MAX     8.0\n\n#endif\n\nvec4 a_x_fxaa(sampler2D tex, vec2 fragCoord, vec2 resolution, vec2 v_rgbNW, vec2 v_rgbNE, vec2 v_rgbSW, vec2 v_rgbSE, vec2 v_rgbM) {\n  vec4 color;\n  mediump vec2 inverseVP = vec2(1.0 / resolution.x, 1.0 / resolution.y);\n  vec3 rgbNW = texture2D(tex, v_rgbNW).xyz;\n  vec3 rgbNE = texture2D(tex, v_rgbNE).xyz;\n  vec3 rgbSW = texture2D(tex, v_rgbSW).xyz;\n  vec3 rgbSE = texture2D(tex, v_rgbSE).xyz;\n  vec4 texColor = texture2D(tex, v_rgbM);\n  vec3 rgbM = texColor.xyz;\n  vec3 luma = vec3(0.299, 0.587, 0.114);\n  float lumaNW = dot(rgbNW, luma);\n  float lumaNE = dot(rgbNE, luma);\n  float lumaSW = dot(rgbSW, luma);\n  float lumaSE = dot(rgbSE, luma);\n  float lumaM = dot(rgbM, luma);\n  float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n  float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n  mediump vec2 dir;\n  dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n  dir.y = ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n  float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) * (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\n  float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n  dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX), max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX), dir * rcpDirMin)) * inverseVP;\n  vec3 rgbA = 0.5 * (texture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz + texture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);\n  vec3 rgbB = rgbA * 0.5 + 0.25 * (texture2D(tex, fragCoord * inverseVP + dir * -0.5).xyz + texture2D(tex, fragCoord * inverseVP + dir * 0.5).xyz);\n  float lumaB = dot(rgbB, luma);\n  if((lumaB < lumaMin) || (lumaB > lumaMax))\n    color = vec4(rgbA, texColor.a);\n  else\n    color = vec4(rgbB, texColor.a);\n  return color;\n}\nvoid main() {\n  vec2 fragCoord = vUv * resolution;\n  gl_FragColor = a_x_fxaa(tDiffuse, fragCoord, resolution, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n}", [{"name":"resolution","type":"vec2"},{"name":"resolution","type":"vec2"},{"name":"tDiffuse","type":"sampler2D"}], []);

module.exports = function(THREE) {
    var createShader = threeify(THREE);

    return function() {
        return createShader(source);
    };
};
},{"glslify":"/projects/blackice/node_modules/glslify/browser.js","glslify/simple-adapter.js":"/projects/blackice/node_modules/glslify/simple-adapter.js","three-glslify":"/projects/blackice/node_modules/three-glslify/index.js"}],"/projects/blackice/node_modules/three-simplicial-complex/index.js":[function(require,module,exports){
var inherits = require('inherits')

module.exports = function(THREE) {

    function Complex(mesh) {
        if (!(this instanceof Complex))
            return new Complex(mesh)
        THREE.Geometry.call(this)
        this.dynamic = true

        if (mesh)
            this.update(mesh)
    }

    inherits(Complex, THREE.Geometry)

    //may expose these in next version
    Complex.prototype._updatePositions = function(positions) {
        for (var i=0; i<positions.length; i++) {
            var pos = positions[i]
            if (i > this.vertices.length-1)
                this.vertices.push(new THREE.Vector3().fromArray(pos))
            else 
                this.vertices[i].fromArray(pos)
        }
        this.vertices.length = positions.length
        this.verticesNeedUpdate = true
    }

    Complex.prototype._updateCells = function(cells) {
        for (var i=0; i<cells.length; i++) {
            var face = cells[i]
            if (i > this.faces.length-1)
                this.faces.push(new THREE.Face3(face[0], face[1], face[2]))
            else {
                var tf = this.faces[i]
                tf.a = face[0]
                tf.b = face[1]
                tf.c = face[2]
            }
        }

        this.faces.length = cells.length
        this.elementsNeedUpdate = true
    }

    Complex.prototype.update = function(mesh) {
        this._updatePositions(mesh.positions)
        this._updateCells(mesh.cells)
    }

    return Complex
}
},{"inherits":"/projects/blackice/node_modules/inherits/inherits_browser.js"}],"/projects/blackice/node_modules/triangulate-contours/index.js":[function(require,module,exports){
var Tess2 = require('tess2')
var xtend = require('xtend')

module.exports = function(contours, opt) {
    opt = opt||{}
    contours = contours.filter(function(c) {
        return c.length>0
    })
    
    if (contours.length === 0) {
        return { 
            positions: [],
            cells: []
        }
    }

    if (typeof opt.vertexSize !== 'number')
        opt.vertexSize = contours[0][0].length

    //flatten for tess2.js
    contours = contours.map(function(c) {
        return c.reduce(function(a, b) {
            return a.concat(b)
        })
    })

    // Tesselate
    var res = Tess2.tesselate(xtend({
        contours: contours,
        windingRule: Tess2.WINDING_ODD,
        elementType: Tess2.POLYGONS,
        polySize: 3,
        vertexSize: 2
    }, opt))

    var positions = []
    for (var i=0; i<res.vertices.length; i+=opt.vertexSize) {
        var pos = res.vertices.slice(i, i+opt.vertexSize)
        positions.push(pos)
    }
    
    var cells = []
    for (i=0; i<res.elements.length; i+=3) {
        var a = res.elements[i],
            b = res.elements[i+1],
            c = res.elements[i+2]
        cells.push([a, b, c])
    }

    //return a simplicial complex
    return {
        positions: positions,
        cells: cells
    }
}
},{"tess2":"/projects/blackice/node_modules/triangulate-contours/node_modules/tess2/index.js","xtend":"/projects/blackice/node_modules/xtend/immutable.js"}],"/projects/blackice/node_modules/triangulate-contours/node_modules/tess2/index.js":[function(require,module,exports){
module.exports = require('./src/tess2');
},{"./src/tess2":"/projects/blackice/node_modules/triangulate-contours/node_modules/tess2/src/tess2.js"}],"/projects/blackice/node_modules/triangulate-contours/node_modules/tess2/src/tess2.js":[function(require,module,exports){
/*
** SGI FREE SOFTWARE LICENSE B (Version 2.0, Sept. 18, 2008) 
** Copyright (C) [dates of first publication] Silicon Graphics, Inc.
** All Rights Reserved.
**
** Permission is hereby granted, free of charge, to any person obtaining a copy
** of this software and associated documentation files (the "Software"), to deal
** in the Software without restriction, including without limitation the rights
** to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
** of the Software, and to permit persons to whom the Software is furnished to do so,
** subject to the following conditions:
** 
** The above copyright notice including the dates of first publication and either this
** permission notice or a reference to http://oss.sgi.com/projects/FreeB/ shall be
** included in all copies or substantial portions of the Software. 
**
** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
** INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
** PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL SILICON GRAPHICS, INC.
** BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
** TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
** OR OTHER DEALINGS IN THE SOFTWARE.
** 
** Except as contained in this notice, the name of Silicon Graphics, Inc. shall not
** be used in advertising or otherwise to promote the sale, use or other dealings in
** this Software without prior written authorization from Silicon Graphics, Inc.
*/
/*
** Author: Mikko Mononen, Aug 2013.
** The code is based on GLU libtess by Eric Veach, July 1994
*/

	"use strict";

	/* Public API */

	var Tess2 = {};

	module.exports = Tess2;
	
	Tess2.WINDING_ODD = 0;
	Tess2.WINDING_NONZERO = 1;
	Tess2.WINDING_POSITIVE = 2;
	Tess2.WINDING_NEGATIVE = 3;
	Tess2.WINDING_ABS_GEQ_TWO = 4;

	Tess2.POLYGONS = 0;
	Tess2.CONNECTED_POLYGONS = 1;
	Tess2.BOUNDARY_CONTOURS = 2;

	Tess2.tesselate = function(opts) {
		var debug =  opts.debug || false;
		var tess = new Tesselator();
		for (var i = 0; i < opts.contours.length; i++) {
			tess.addContour(opts.vertexSize || 2, opts.contours[i]);
		}
		tess.tesselate(opts.windingRule || Tess2.WINDING_ODD,
					   opts.elementType || Tess2.POLYGONS,
					   opts.polySize || 3,
					   opts.vertexSize || 2,
					   opts.normal || [0,0,1]);
		return {
			vertices: tess.vertices,
			vertexIndices: tess.vertexIndices,
			vertexCount: tess.vertexCount,
			elements: tess.elements,
			elementCount: tess.elementCount,
			mesh: debug ? tess.mesh : undefined
		};
	};

	/* Internal */

	var assert = function(cond) {
		if (!cond) {
			throw "Assertion Failed!";
		}
	}

	/* The mesh structure is similar in spirit, notation, and operations
	* to the "quad-edge" structure (see L. Guibas and J. Stolfi, Primitives
	* for the manipulation of general subdivisions and the computation of
	* Voronoi diagrams, ACM Transactions on Graphics, 4(2):74-123, April 1985).
	* For a simplified description, see the course notes for CS348a,
	* "Mathematical Foundations of Computer Graphics", available at the
	* Stanford bookstore (and taught during the fall quarter).
	* The implementation also borrows a tiny subset of the graph-based approach
	* use in Mantyla's Geometric Work Bench (see M. Mantyla, An Introduction
	* to Sold Modeling, Computer Science Press, Rockville, Maryland, 1988).
	*
	* The fundamental data structure is the "half-edge".  Two half-edges
	* go together to make an edge, but they point in opposite directions.
	* Each half-edge has a pointer to its mate (the "symmetric" half-edge Sym),
	* its origin vertex (Org), the face on its left side (Lface), and the
	* adjacent half-edges in the CCW direction around the origin vertex
	* (Onext) and around the left face (Lnext).  There is also a "next"
	* pointer for the global edge list (see below).
	*
	* The notation used for mesh navigation:
	*  Sym   = the mate of a half-edge (same edge, but opposite direction)
	*  Onext = edge CCW around origin vertex (keep same origin)
	*  Dnext = edge CCW around destination vertex (keep same dest)
	*  Lnext = edge CCW around left face (dest becomes new origin)
	*  Rnext = edge CCW around right face (origin becomes new dest)
	*
	* "prev" means to substitute CW for CCW in the definitions above.
	*
	* The mesh keeps global lists of all vertices, faces, and edges,
	* stored as doubly-linked circular lists with a dummy header node.
	* The mesh stores pointers to these dummy headers (vHead, fHead, eHead).
	*
	* The circular edge list is special; since half-edges always occur
	* in pairs (e and e->Sym), each half-edge stores a pointer in only
	* one direction.  Starting at eHead and following the e->next pointers
	* will visit each *edge* once (ie. e or e->Sym, but not both).
	* e->Sym stores a pointer in the opposite direction, thus it is
	* always true that e->Sym->next->Sym->next == e.
	*
	* Each vertex has a pointer to next and previous vertices in the
	* circular list, and a pointer to a half-edge with this vertex as
	* the origin (NULL if this is the dummy header).  There is also a
	* field "data" for client data.
	*
	* Each face has a pointer to the next and previous faces in the
	* circular list, and a pointer to a half-edge with this face as
	* the left face (NULL if this is the dummy header).  There is also
	* a field "data" for client data.
	*
	* Note that what we call a "face" is really a loop; faces may consist
	* of more than one loop (ie. not simply connected), but there is no
	* record of this in the data structure.  The mesh may consist of
	* several disconnected regions, so it may not be possible to visit
	* the entire mesh by starting at a half-edge and traversing the edge
	* structure.
	*
	* The mesh does NOT support isolated vertices; a vertex is deleted along
	* with its last edge.  Similarly when two faces are merged, one of the
	* faces is deleted (see tessMeshDelete below).  For mesh operations,
	* all face (loop) and vertex pointers must not be NULL.  However, once
	* mesh manipulation is finished, TESSmeshZapFace can be used to delete
	* faces of the mesh, one at a time.  All external faces can be "zapped"
	* before the mesh is returned to the client; then a NULL face indicates
	* a region which is not part of the output polygon.
	*/

	function TESSvertex() {
		this.next = null;	/* next vertex (never NULL) */
		this.prev = null;	/* previous vertex (never NULL) */
		this.anEdge = null;	/* a half-edge with this origin */

		/* Internal data (keep hidden) */
		this.coords = [0,0,0];	/* vertex location in 3D */
		this.s = 0.0;
		this.t = 0.0;			/* projection onto the sweep plane */
		this.pqHandle = 0;		/* to allow deletion from priority queue */
		this.n = 0;				/* to allow identify unique vertices */
		this.idx = 0;			/* to allow map result to original verts */
	} 

	function TESSface() {
		this.next = null;		/* next face (never NULL) */
		this.prev = null;		/* previous face (never NULL) */
		this.anEdge = null;		/* a half edge with this left face */

		/* Internal data (keep hidden) */
		this.trail = null;		/* "stack" for conversion to strips */
		this.n = 0;				/* to allow identiy unique faces */
		this.marked = false;	/* flag for conversion to strips */
		this.inside = false;	/* this face is in the polygon interior */
	};

	function TESShalfEdge(side) {
		this.next = null;		/* doubly-linked list (prev==Sym->next) */
		this.Sym = null;		/* same edge, opposite direction */
		this.Onext = null;		/* next edge CCW around origin */
		this.Lnext = null;		/* next edge CCW around left face */
		this.Org = null;		/* origin vertex (Overtex too long) */
		this.Lface = null;		/* left face */

		/* Internal data (keep hidden) */
		this.activeRegion = null;	/* a region with this upper edge (sweep.c) */
		this.winding = 0;			/* change in winding number when crossing
									   from the right face to the left face */
		this.side = side;
	};

	TESShalfEdge.prototype = {
		get Rface() { return this.Sym.Lface; },
		set Rface(v) { this.Sym.Lface = v; },
		get Dst() { return this.Sym.Org; },
		set Dst(v) { this.Sym.Org = v; },
		get Oprev() { return this.Sym.Lnext; },
		set Oprev(v) { this.Sym.Lnext = v; },
		get Lprev() { return this.Onext.Sym; },
		set Lprev(v) { this.Onext.Sym = v; },
		get Dprev() { return this.Lnext.Sym; },
		set Dprev(v) { this.Lnext.Sym = v; },
		get Rprev() { return this.Sym.Onext; },
		set Rprev(v) { this.Sym.Onext = v; },
		get Dnext() { return /*this.Rprev*/this.Sym.Onext.Sym; },  /* 3 pointers */
		set Dnext(v) { /*this.Rprev*/this.Sym.Onext.Sym = v; },  /* 3 pointers */
		get Rnext() { return /*this.Oprev*/this.Sym.Lnext.Sym; },  /* 3 pointers */
		set Rnext(v) { /*this.Oprev*/this.Sym.Lnext.Sym = v; },  /* 3 pointers */
	};



	function TESSmesh() {
		var v = new TESSvertex();
		var f = new TESSface();
		var e = new TESShalfEdge(0);
		var eSym = new TESShalfEdge(1);

		v.next = v.prev = v;
		v.anEdge = null;

		f.next = f.prev = f;
		f.anEdge = null;
		f.trail = null;
		f.marked = false;
		f.inside = false;

		e.next = e;
		e.Sym = eSym;
		e.Onext = null;
		e.Lnext = null;
		e.Org = null;
		e.Lface = null;
		e.winding = 0;
		e.activeRegion = null;

		eSym.next = eSym;
		eSym.Sym = e;
		eSym.Onext = null;
		eSym.Lnext = null;
		eSym.Org = null;
		eSym.Lface = null;
		eSym.winding = 0;
		eSym.activeRegion = null;

		this.vHead = v;		/* dummy header for vertex list */
		this.fHead = f;		/* dummy header for face list */
		this.eHead = e;		/* dummy header for edge list */
		this.eHeadSym = eSym;	/* and its symmetric counterpart */
	};

	/* The mesh operations below have three motivations: completeness,
	* convenience, and efficiency.  The basic mesh operations are MakeEdge,
	* Splice, and Delete.  All the other edge operations can be implemented
	* in terms of these.  The other operations are provided for convenience
	* and/or efficiency.
	*
	* When a face is split or a vertex is added, they are inserted into the
	* global list *before* the existing vertex or face (ie. e->Org or e->Lface).
	* This makes it easier to process all vertices or faces in the global lists
	* without worrying about processing the same data twice.  As a convenience,
	* when a face is split, the "inside" flag is copied from the old face.
	* Other internal data (v->data, v->activeRegion, f->data, f->marked,
	* f->trail, e->winding) is set to zero.
	*
	* ********************** Basic Edge Operations **************************
	*
	* tessMeshMakeEdge( mesh ) creates one edge, two vertices, and a loop.
	* The loop (face) consists of the two new half-edges.
	*
	* tessMeshSplice( eOrg, eDst ) is the basic operation for changing the
	* mesh connectivity and topology.  It changes the mesh so that
	*  eOrg->Onext <- OLD( eDst->Onext )
	*  eDst->Onext <- OLD( eOrg->Onext )
	* where OLD(...) means the value before the meshSplice operation.
	*
	* This can have two effects on the vertex structure:
	*  - if eOrg->Org != eDst->Org, the two vertices are merged together
	*  - if eOrg->Org == eDst->Org, the origin is split into two vertices
	* In both cases, eDst->Org is changed and eOrg->Org is untouched.
	*
	* Similarly (and independently) for the face structure,
	*  - if eOrg->Lface == eDst->Lface, one loop is split into two
	*  - if eOrg->Lface != eDst->Lface, two distinct loops are joined into one
	* In both cases, eDst->Lface is changed and eOrg->Lface is unaffected.
	*
	* tessMeshDelete( eDel ) removes the edge eDel.  There are several cases:
	* if (eDel->Lface != eDel->Rface), we join two loops into one; the loop
	* eDel->Lface is deleted.  Otherwise, we are splitting one loop into two;
	* the newly created loop will contain eDel->Dst.  If the deletion of eDel
	* would create isolated vertices, those are deleted as well.
	*
	* ********************** Other Edge Operations **************************
	*
	* tessMeshAddEdgeVertex( eOrg ) creates a new edge eNew such that
	* eNew == eOrg->Lnext, and eNew->Dst is a newly created vertex.
	* eOrg and eNew will have the same left face.
	*
	* tessMeshSplitEdge( eOrg ) splits eOrg into two edges eOrg and eNew,
	* such that eNew == eOrg->Lnext.  The new vertex is eOrg->Dst == eNew->Org.
	* eOrg and eNew will have the same left face.
	*
	* tessMeshConnect( eOrg, eDst ) creates a new edge from eOrg->Dst
	* to eDst->Org, and returns the corresponding half-edge eNew.
	* If eOrg->Lface == eDst->Lface, this splits one loop into two,
	* and the newly created loop is eNew->Lface.  Otherwise, two disjoint
	* loops are merged into one, and the loop eDst->Lface is destroyed.
	*
	* ************************ Other Operations *****************************
	*
	* tessMeshNewMesh() creates a new mesh with no edges, no vertices,
	* and no loops (what we usually call a "face").
	*
	* tessMeshUnion( mesh1, mesh2 ) forms the union of all structures in
	* both meshes, and returns the new mesh (the old meshes are destroyed).
	*
	* tessMeshDeleteMesh( mesh ) will free all storage for any valid mesh.
	*
	* tessMeshZapFace( fZap ) destroys a face and removes it from the
	* global face list.  All edges of fZap will have a NULL pointer as their
	* left face.  Any edges which also have a NULL pointer as their right face
	* are deleted entirely (along with any isolated vertices this produces).
	* An entire mesh can be deleted by zapping its faces, one at a time,
	* in any order.  Zapped faces cannot be used in further mesh operations!
	*
	* tessMeshCheckMesh( mesh ) checks a mesh for self-consistency.
	*/

	TESSmesh.prototype = {

		/* MakeEdge creates a new pair of half-edges which form their own loop.
		* No vertex or face structures are allocated, but these must be assigned
		* before the current edge operation is completed.
		*/
		//static TESShalfEdge *MakeEdge( TESSmesh* mesh, TESShalfEdge *eNext )
		makeEdge_: function(eNext) {
			var e = new TESShalfEdge(0);
			var eSym = new TESShalfEdge(1);

			/* Make sure eNext points to the first edge of the edge pair */
			if( eNext.Sym.side < eNext.side ) { eNext = eNext.Sym; }

			/* Insert in circular doubly-linked list before eNext.
			* Note that the prev pointer is stored in Sym->next.
			*/
			var ePrev = eNext.Sym.next;
			eSym.next = ePrev;
			ePrev.Sym.next = e;
			e.next = eNext;
			eNext.Sym.next = eSym;

			e.Sym = eSym;
			e.Onext = e;
			e.Lnext = eSym;
			e.Org = null;
			e.Lface = null;
			e.winding = 0;
			e.activeRegion = null;

			eSym.Sym = e;
			eSym.Onext = eSym;
			eSym.Lnext = e;
			eSym.Org = null;
			eSym.Lface = null;
			eSym.winding = 0;
			eSym.activeRegion = null;

			return e;
		},

		/* Splice( a, b ) is best described by the Guibas/Stolfi paper or the
		* CS348a notes (see mesh.h).  Basically it modifies the mesh so that
		* a->Onext and b->Onext are exchanged.  This can have various effects
		* depending on whether a and b belong to different face or vertex rings.
		* For more explanation see tessMeshSplice() below.
		*/
		// static void Splice( TESShalfEdge *a, TESShalfEdge *b )
		splice_: function(a, b) {
			var aOnext = a.Onext;
			var bOnext = b.Onext;
			aOnext.Sym.Lnext = b;
			bOnext.Sym.Lnext = a;
			a.Onext = bOnext;
			b.Onext = aOnext;
		},

		/* MakeVertex( newVertex, eOrig, vNext ) attaches a new vertex and makes it the
		* origin of all edges in the vertex loop to which eOrig belongs. "vNext" gives
		* a place to insert the new vertex in the global vertex list.  We insert
		* the new vertex *before* vNext so that algorithms which walk the vertex
		* list will not see the newly created vertices.
		*/
		//static void MakeVertex( TESSvertex *newVertex, TESShalfEdge *eOrig, TESSvertex *vNext )
		makeVertex_: function(newVertex, eOrig, vNext) {
			var vNew = newVertex;
			assert(vNew !== null);

			/* insert in circular doubly-linked list before vNext */
			var vPrev = vNext.prev;
			vNew.prev = vPrev;
			vPrev.next = vNew;
			vNew.next = vNext;
			vNext.prev = vNew;

			vNew.anEdge = eOrig;
			/* leave coords, s, t undefined */

			/* fix other edges on this vertex loop */
			var e = eOrig;
			do {
				e.Org = vNew;
				e = e.Onext;
			} while(e !== eOrig);
		},

		/* MakeFace( newFace, eOrig, fNext ) attaches a new face and makes it the left
		* face of all edges in the face loop to which eOrig belongs.  "fNext" gives
		* a place to insert the new face in the global face list.  We insert
		* the new face *before* fNext so that algorithms which walk the face
		* list will not see the newly created faces.
		*/
		// static void MakeFace( TESSface *newFace, TESShalfEdge *eOrig, TESSface *fNext )
		makeFace_: function(newFace, eOrig, fNext) {
			var fNew = newFace;
			assert(fNew !== null); 

			/* insert in circular doubly-linked list before fNext */
			var fPrev = fNext.prev;
			fNew.prev = fPrev;
			fPrev.next = fNew;
			fNew.next = fNext;
			fNext.prev = fNew;

			fNew.anEdge = eOrig;
			fNew.trail = null;
			fNew.marked = false;

			/* The new face is marked "inside" if the old one was.  This is a
			* convenience for the common case where a face has been split in two.
			*/
			fNew.inside = fNext.inside;

			/* fix other edges on this face loop */
			var e = eOrig;
			do {
				e.Lface = fNew;
				e = e.Lnext;
			} while(e !== eOrig);
		},

		/* KillEdge( eDel ) destroys an edge (the half-edges eDel and eDel->Sym),
		* and removes from the global edge list.
		*/
		//static void KillEdge( TESSmesh *mesh, TESShalfEdge *eDel )
		killEdge_: function(eDel) {
			/* Half-edges are allocated in pairs, see EdgePair above */
			if( eDel.Sym.side < eDel.side ) { eDel = eDel.Sym; }

			/* delete from circular doubly-linked list */
			var eNext = eDel.next;
			var ePrev = eDel.Sym.next;
			eNext.Sym.next = ePrev;
			ePrev.Sym.next = eNext;
		},


		/* KillVertex( vDel ) destroys a vertex and removes it from the global
		* vertex list.  It updates the vertex loop to point to a given new vertex.
		*/
		//static void KillVertex( TESSmesh *mesh, TESSvertex *vDel, TESSvertex *newOrg )
		killVertex_: function(vDel, newOrg) {
			var eStart = vDel.anEdge;
			/* change the origin of all affected edges */
			var e = eStart;
			do {
				e.Org = newOrg;
				e = e.Onext;
			} while(e !== eStart);

			/* delete from circular doubly-linked list */
			var vPrev = vDel.prev;
			var vNext = vDel.next;
			vNext.prev = vPrev;
			vPrev.next = vNext;
		},

		/* KillFace( fDel ) destroys a face and removes it from the global face
		* list.  It updates the face loop to point to a given new face.
		*/
		//static void KillFace( TESSmesh *mesh, TESSface *fDel, TESSface *newLface )
		killFace_: function(fDel, newLface) {
			var eStart = fDel.anEdge;

			/* change the left face of all affected edges */
			var e = eStart;
			do {
				e.Lface = newLface;
				e = e.Lnext;
			} while(e !== eStart);

			/* delete from circular doubly-linked list */
			var fPrev = fDel.prev;
			var fNext = fDel.next;
			fNext.prev = fPrev;
			fPrev.next = fNext;
		},

		/****************** Basic Edge Operations **********************/

		/* tessMeshMakeEdge creates one edge, two vertices, and a loop (face).
		* The loop consists of the two new half-edges.
		*/
		//TESShalfEdge *tessMeshMakeEdge( TESSmesh *mesh )
		makeEdge: function() {
			var newVertex1 = new TESSvertex();
			var newVertex2 = new TESSvertex();
			var newFace = new TESSface();
			var e = this.makeEdge_( this.eHead);
			this.makeVertex_( newVertex1, e, this.vHead );
			this.makeVertex_( newVertex2, e.Sym, this.vHead );
			this.makeFace_( newFace, e, this.fHead );
			return e;
		},

		/* tessMeshSplice( eOrg, eDst ) is the basic operation for changing the
		* mesh connectivity and topology.  It changes the mesh so that
		*	eOrg->Onext <- OLD( eDst->Onext )
		*	eDst->Onext <- OLD( eOrg->Onext )
		* where OLD(...) means the value before the meshSplice operation.
		*
		* This can have two effects on the vertex structure:
		*  - if eOrg->Org != eDst->Org, the two vertices are merged together
		*  - if eOrg->Org == eDst->Org, the origin is split into two vertices
		* In both cases, eDst->Org is changed and eOrg->Org is untouched.
		*
		* Similarly (and independently) for the face structure,
		*  - if eOrg->Lface == eDst->Lface, one loop is split into two
		*  - if eOrg->Lface != eDst->Lface, two distinct loops are joined into one
		* In both cases, eDst->Lface is changed and eOrg->Lface is unaffected.
		*
		* Some special cases:
		* If eDst == eOrg, the operation has no effect.
		* If eDst == eOrg->Lnext, the new face will have a single edge.
		* If eDst == eOrg->Lprev, the old face will have a single edge.
		* If eDst == eOrg->Onext, the new vertex will have a single edge.
		* If eDst == eOrg->Oprev, the old vertex will have a single edge.
		*/
		//int tessMeshSplice( TESSmesh* mesh, TESShalfEdge *eOrg, TESShalfEdge *eDst )
		splice: function(eOrg, eDst) {
			var joiningLoops = false;
			var joiningVertices = false;

			if( eOrg === eDst ) return;

			if( eDst.Org !== eOrg.Org ) {
				/* We are merging two disjoint vertices -- destroy eDst->Org */
				joiningVertices = true;
				this.killVertex_( eDst.Org, eOrg.Org );
			}
			if( eDst.Lface !== eOrg.Lface ) {
				/* We are connecting two disjoint loops -- destroy eDst->Lface */
				joiningLoops = true;
				this.killFace_( eDst.Lface, eOrg.Lface );
			}

			/* Change the edge structure */
			this.splice_( eDst, eOrg );

			if( ! joiningVertices ) {
				var newVertex = new TESSvertex();

				/* We split one vertex into two -- the new vertex is eDst->Org.
				* Make sure the old vertex points to a valid half-edge.
				*/
				this.makeVertex_( newVertex, eDst, eOrg.Org );
				eOrg.Org.anEdge = eOrg;
			}
			if( ! joiningLoops ) {
				var newFace = new TESSface();  

				/* We split one loop into two -- the new loop is eDst->Lface.
				* Make sure the old face points to a valid half-edge.
				*/
				this.makeFace_( newFace, eDst, eOrg.Lface );
				eOrg.Lface.anEdge = eOrg;
			}
		},

		/* tessMeshDelete( eDel ) removes the edge eDel.  There are several cases:
		* if (eDel->Lface != eDel->Rface), we join two loops into one; the loop
		* eDel->Lface is deleted.  Otherwise, we are splitting one loop into two;
		* the newly created loop will contain eDel->Dst.  If the deletion of eDel
		* would create isolated vertices, those are deleted as well.
		*
		* This function could be implemented as two calls to tessMeshSplice
		* plus a few calls to memFree, but this would allocate and delete
		* unnecessary vertices and faces.
		*/
		//int tessMeshDelete( TESSmesh *mesh, TESShalfEdge *eDel )
		delete: function(eDel) {
			var eDelSym = eDel.Sym;
			var joiningLoops = false;

			/* First step: disconnect the origin vertex eDel->Org.  We make all
			* changes to get a consistent mesh in this "intermediate" state.
			*/
			if( eDel.Lface !== eDel.Rface ) {
				/* We are joining two loops into one -- remove the left face */
				joiningLoops = true;
				this.killFace_( eDel.Lface, eDel.Rface );
			}

			if( eDel.Onext === eDel ) {
				this.killVertex_( eDel.Org, null );
			} else {
				/* Make sure that eDel->Org and eDel->Rface point to valid half-edges */
				eDel.Rface.anEdge = eDel.Oprev;
				eDel.Org.anEdge = eDel.Onext;

				this.splice_( eDel, eDel.Oprev );
				if( ! joiningLoops ) {
					var newFace = new TESSface();

					/* We are splitting one loop into two -- create a new loop for eDel. */
					this.makeFace_( newFace, eDel, eDel.Lface );
				}
			}

			/* Claim: the mesh is now in a consistent state, except that eDel->Org
			* may have been deleted.  Now we disconnect eDel->Dst.
			*/
			if( eDelSym.Onext === eDelSym ) {
				this.killVertex_( eDelSym.Org, null );
				this.killFace_( eDelSym.Lface, null );
			} else {
				/* Make sure that eDel->Dst and eDel->Lface point to valid half-edges */
				eDel.Lface.anEdge = eDelSym.Oprev;
				eDelSym.Org.anEdge = eDelSym.Onext;
				this.splice_( eDelSym, eDelSym.Oprev );
			}

			/* Any isolated vertices or faces have already been freed. */
			this.killEdge_( eDel );
		},

		/******************** Other Edge Operations **********************/

		/* All these routines can be implemented with the basic edge
		* operations above.  They are provided for convenience and efficiency.
		*/


		/* tessMeshAddEdgeVertex( eOrg ) creates a new edge eNew such that
		* eNew == eOrg->Lnext, and eNew->Dst is a newly created vertex.
		* eOrg and eNew will have the same left face.
		*/
		// TESShalfEdge *tessMeshAddEdgeVertex( TESSmesh *mesh, TESShalfEdge *eOrg );
		addEdgeVertex: function(eOrg) {
			var eNew = this.makeEdge_( eOrg );
			var eNewSym = eNew.Sym;

			/* Connect the new edge appropriately */
			this.splice_( eNew, eOrg.Lnext );

			/* Set the vertex and face information */
			eNew.Org = eOrg.Dst;

			var newVertex = new TESSvertex();
			this.makeVertex_( newVertex, eNewSym, eNew.Org );

			eNew.Lface = eNewSym.Lface = eOrg.Lface;

			return eNew;
		},


		/* tessMeshSplitEdge( eOrg ) splits eOrg into two edges eOrg and eNew,
		* such that eNew == eOrg->Lnext.  The new vertex is eOrg->Dst == eNew->Org.
		* eOrg and eNew will have the same left face.
		*/
		// TESShalfEdge *tessMeshSplitEdge( TESSmesh *mesh, TESShalfEdge *eOrg );
		splitEdge: function(eOrg, eDst) {
			var tempHalfEdge = this.addEdgeVertex( eOrg );
			var eNew = tempHalfEdge.Sym;

			/* Disconnect eOrg from eOrg->Dst and connect it to eNew->Org */
			this.splice_( eOrg.Sym, eOrg.Sym.Oprev );
			this.splice_( eOrg.Sym, eNew );

			/* Set the vertex and face information */
			eOrg.Dst = eNew.Org;
			eNew.Dst.anEdge = eNew.Sym;	/* may have pointed to eOrg->Sym */
			eNew.Rface = eOrg.Rface;
			eNew.winding = eOrg.winding;	/* copy old winding information */
			eNew.Sym.winding = eOrg.Sym.winding;

			return eNew;
		},


		/* tessMeshConnect( eOrg, eDst ) creates a new edge from eOrg->Dst
		* to eDst->Org, and returns the corresponding half-edge eNew.
		* If eOrg->Lface == eDst->Lface, this splits one loop into two,
		* and the newly created loop is eNew->Lface.  Otherwise, two disjoint
		* loops are merged into one, and the loop eDst->Lface is destroyed.
		*
		* If (eOrg == eDst), the new face will have only two edges.
		* If (eOrg->Lnext == eDst), the old face is reduced to a single edge.
		* If (eOrg->Lnext->Lnext == eDst), the old face is reduced to two edges.
		*/

		// TESShalfEdge *tessMeshConnect( TESSmesh *mesh, TESShalfEdge *eOrg, TESShalfEdge *eDst );
		connect: function(eOrg, eDst) {
			var joiningLoops = false;  
			var eNew = this.makeEdge_( eOrg );
			var eNewSym = eNew.Sym;

			if( eDst.Lface !== eOrg.Lface ) {
				/* We are connecting two disjoint loops -- destroy eDst->Lface */
				joiningLoops = true;
				this.killFace_( eDst.Lface, eOrg.Lface );
			}

			/* Connect the new edge appropriately */
			this.splice_( eNew, eOrg.Lnext );
			this.splice_( eNewSym, eDst );

			/* Set the vertex and face information */
			eNew.Org = eOrg.Dst;
			eNewSym.Org = eDst.Org;
			eNew.Lface = eNewSym.Lface = eOrg.Lface;

			/* Make sure the old face points to a valid half-edge */
			eOrg.Lface.anEdge = eNewSym;

			if( ! joiningLoops ) {
				var newFace = new TESSface();
				/* We split one loop into two -- the new loop is eNew->Lface */
				this.makeFace_( newFace, eNew, eOrg.Lface );
			}
			return eNew;
		},

		/* tessMeshZapFace( fZap ) destroys a face and removes it from the
		* global face list.  All edges of fZap will have a NULL pointer as their
		* left face.  Any edges which also have a NULL pointer as their right face
		* are deleted entirely (along with any isolated vertices this produces).
		* An entire mesh can be deleted by zapping its faces, one at a time,
		* in any order.  Zapped faces cannot be used in further mesh operations!
		*/
		zapFace: function( fZap )
		{
			var eStart = fZap.anEdge;
			var e, eNext, eSym;
			var fPrev, fNext;

			/* walk around face, deleting edges whose right face is also NULL */
			eNext = eStart.Lnext;
			do {
				e = eNext;
				eNext = e.Lnext;

				e.Lface = null;
				if( e.Rface === null ) {
					/* delete the edge -- see TESSmeshDelete above */

					if( e.Onext === e ) {
						this.killVertex_( e.Org, null );
					} else {
						/* Make sure that e->Org points to a valid half-edge */
						e.Org.anEdge = e.Onext;
						this.splice_( e, e.Oprev );
					}
					eSym = e.Sym;
					if( eSym.Onext === eSym ) {
						this.killVertex_( eSym.Org, null );
					} else {
						/* Make sure that eSym->Org points to a valid half-edge */
						eSym.Org.anEdge = eSym.Onext;
						this.splice_( eSym, eSym.Oprev );
					}
					this.killEdge_( e );
				}
			} while( e != eStart );

			/* delete from circular doubly-linked list */
			fPrev = fZap.prev;
			fNext = fZap.next;
			fNext.prev = fPrev;
			fPrev.next = fNext;
		},

		countFaceVerts_: function(f) {
			var eCur = f.anEdge;
			var n = 0;
			do
			{
				n++;
				eCur = eCur.Lnext;
			}
			while (eCur !== f.anEdge);
			return n;
		},

		//int tessMeshMergeConvexFaces( TESSmesh *mesh, int maxVertsPerFace )
		mergeConvexFaces: function(maxVertsPerFace) {
			var f;
			var eCur, eNext, eSym;
			var vStart;
			var curNv, symNv;

			for( f = this.fHead.next; f !== this.fHead; f = f.next )
			{
				// Skip faces which are outside the result.
				if( !f.inside )
					continue;

				eCur = f.anEdge;
				vStart = eCur.Org;
					
				while (true)
				{
					eNext = eCur.Lnext;
					eSym = eCur.Sym;

					// Try to merge if the neighbour face is valid.
					if( eSym && eSym.Lface && eSym.Lface.inside )
					{
						// Try to merge the neighbour faces if the resulting polygons
						// does not exceed maximum number of vertices.
						curNv = this.countFaceVerts_( f );
						symNv = this.countFaceVerts_( eSym.Lface );
						if( (curNv+symNv-2) <= maxVertsPerFace )
						{
							// Merge if the resulting poly is convex.
							if( Geom.vertCCW( eCur.Lprev.Org, eCur.Org, eSym.Lnext.Lnext.Org ) &&
								Geom.vertCCW( eSym.Lprev.Org, eSym.Org, eCur.Lnext.Lnext.Org ) )
							{
								eNext = eSym.Lnext;
								this.delete( eSym );
								eCur = null;
								eSym = null;
							}
						}
					}
					
					if( eCur && eCur.Lnext.Org === vStart )
						break;
						
					// Continue to next edge.
					eCur = eNext;
				}
			}
			
			return true;
		},

		/* tessMeshCheckMesh( mesh ) checks a mesh for self-consistency.
		*/
		check: function() {
			var fHead = this.fHead;
			var vHead = this.vHead;
			var eHead = this.eHead;
			var f, fPrev, v, vPrev, e, ePrev;

			fPrev = fHead;
			for( fPrev = fHead ; (f = fPrev.next) !== fHead; fPrev = f) {
				assert( f.prev === fPrev );
				e = f.anEdge;
				do {
					assert( e.Sym !== e );
					assert( e.Sym.Sym === e );
					assert( e.Lnext.Onext.Sym === e );
					assert( e.Onext.Sym.Lnext === e );
					assert( e.Lface === f );
					e = e.Lnext;
				} while( e !== f.anEdge );
			}
			assert( f.prev === fPrev && f.anEdge === null );

			vPrev = vHead;
			for( vPrev = vHead ; (v = vPrev.next) !== vHead; vPrev = v) {
				assert( v.prev === vPrev );
				e = v.anEdge;
				do {
					assert( e.Sym !== e );
					assert( e.Sym.Sym === e );
					assert( e.Lnext.Onext.Sym === e );
					assert( e.Onext.Sym.Lnext === e );
					assert( e.Org === v );
					e = e.Onext;
				} while( e !== v.anEdge );
			}
			assert( v.prev === vPrev && v.anEdge === null );

			ePrev = eHead;
			for( ePrev = eHead ; (e = ePrev.next) !== eHead; ePrev = e) {
				assert( e.Sym.next === ePrev.Sym );
				assert( e.Sym !== e );
				assert( e.Sym.Sym === e );
				assert( e.Org !== null );
				assert( e.Dst !== null );
				assert( e.Lnext.Onext.Sym === e );
				assert( e.Onext.Sym.Lnext === e );
			}
			assert( e.Sym.next === ePrev.Sym
				&& e.Sym === this.eHeadSym
				&& e.Sym.Sym === e
				&& e.Org === null && e.Dst === null
				&& e.Lface === null && e.Rface === null );
		}

	};

	var Geom = {};

	Geom.vertEq = function(u,v) {
		return (u.s === v.s && u.t === v.t);
	};

	/* Returns TRUE if u is lexicographically <= v. */
	Geom.vertLeq = function(u,v) {
		return ((u.s < v.s) || (u.s === v.s && u.t <= v.t));
	};

	/* Versions of VertLeq, EdgeSign, EdgeEval with s and t transposed. */
	Geom.transLeq = function(u,v) {
		return ((u.t < v.t) || (u.t === v.t && u.s <= v.s));
	};

	Geom.edgeGoesLeft = function(e) {
		return Geom.vertLeq( e.Dst, e.Org );
	};

	Geom.edgeGoesRight = function(e) {
		return Geom.vertLeq( e.Org, e.Dst );
	};

	Geom.vertL1dist = function(u,v) {
		return (Math.abs(u.s - v.s) + Math.abs(u.t - v.t));
	};

	//TESSreal tesedgeEval( TESSvertex *u, TESSvertex *v, TESSvertex *w )
	Geom.edgeEval = function( u, v, w ) {
		/* Given three vertices u,v,w such that VertLeq(u,v) && VertLeq(v,w),
		* evaluates the t-coord of the edge uw at the s-coord of the vertex v.
		* Returns v->t - (uw)(v->s), ie. the signed distance from uw to v.
		* If uw is vertical (and thus passes thru v), the result is zero.
		*
		* The calculation is extremely accurate and stable, even when v
		* is very close to u or w.  In particular if we set v->t = 0 and
		* let r be the negated result (this evaluates (uw)(v->s)), then
		* r is guaranteed to satisfy MIN(u->t,w->t) <= r <= MAX(u->t,w->t).
		*/
		assert( Geom.vertLeq( u, v ) && Geom.vertLeq( v, w ));

		var gapL = v.s - u.s;
		var gapR = w.s - v.s;

		if( gapL + gapR > 0.0 ) {
			if( gapL < gapR ) {
				return (v.t - u.t) + (u.t - w.t) * (gapL / (gapL + gapR));
			} else {
				return (v.t - w.t) + (w.t - u.t) * (gapR / (gapL + gapR));
			}
		}
		/* vertical line */
		return 0.0;
	};

	//TESSreal tesedgeSign( TESSvertex *u, TESSvertex *v, TESSvertex *w )
	Geom.edgeSign = function( u, v, w ) {
		/* Returns a number whose sign matches EdgeEval(u,v,w) but which
		* is cheaper to evaluate.  Returns > 0, == 0 , or < 0
		* as v is above, on, or below the edge uw.
		*/
		assert( Geom.vertLeq( u, v ) && Geom.vertLeq( v, w ));

		var gapL = v.s - u.s;
		var gapR = w.s - v.s;

		if( gapL + gapR > 0.0 ) {
			return (v.t - w.t) * gapL + (v.t - u.t) * gapR;
		}
		/* vertical line */
		return 0.0;
	};


	/***********************************************************************
	* Define versions of EdgeSign, EdgeEval with s and t transposed.
	*/

	//TESSreal testransEval( TESSvertex *u, TESSvertex *v, TESSvertex *w )
	Geom.transEval = function( u, v, w ) {
		/* Given three vertices u,v,w such that TransLeq(u,v) && TransLeq(v,w),
		* evaluates the t-coord of the edge uw at the s-coord of the vertex v.
		* Returns v->s - (uw)(v->t), ie. the signed distance from uw to v.
		* If uw is vertical (and thus passes thru v), the result is zero.
		*
		* The calculation is extremely accurate and stable, even when v
		* is very close to u or w.  In particular if we set v->s = 0 and
		* let r be the negated result (this evaluates (uw)(v->t)), then
		* r is guaranteed to satisfy MIN(u->s,w->s) <= r <= MAX(u->s,w->s).
		*/
		assert( Geom.transLeq( u, v ) && Geom.transLeq( v, w ));

		var gapL = v.t - u.t;
		var gapR = w.t - v.t;

		if( gapL + gapR > 0.0 ) {
			if( gapL < gapR ) {
				return (v.s - u.s) + (u.s - w.s) * (gapL / (gapL + gapR));
			} else {
				return (v.s - w.s) + (w.s - u.s) * (gapR / (gapL + gapR));
			}
		}
		/* vertical line */
		return 0.0;
	};

	//TESSreal testransSign( TESSvertex *u, TESSvertex *v, TESSvertex *w )
	Geom.transSign = function( u, v, w ) {
		/* Returns a number whose sign matches TransEval(u,v,w) but which
		* is cheaper to evaluate.  Returns > 0, == 0 , or < 0
		* as v is above, on, or below the edge uw.
		*/
		assert( Geom.transLeq( u, v ) && Geom.transLeq( v, w ));

		var gapL = v.t - u.t;
		var gapR = w.t - v.t;

		if( gapL + gapR > 0.0 ) {
			return (v.s - w.s) * gapL + (v.s - u.s) * gapR;
		}
		/* vertical line */
		return 0.0;
	};


	//int tesvertCCW( TESSvertex *u, TESSvertex *v, TESSvertex *w )
	Geom.vertCCW = function( u, v, w ) {
		/* For almost-degenerate situations, the results are not reliable.
		* Unless the floating-point arithmetic can be performed without
		* rounding errors, *any* implementation will give incorrect results
		* on some degenerate inputs, so the client must have some way to
		* handle this situation.
		*/
		return (u.s*(v.t - w.t) + v.s*(w.t - u.t) + w.s*(u.t - v.t)) >= 0.0;
	};

	/* Given parameters a,x,b,y returns the value (b*x+a*y)/(a+b),
	* or (x+y)/2 if a==b==0.  It requires that a,b >= 0, and enforces
	* this in the rare case that one argument is slightly negative.
	* The implementation is extremely stable numerically.
	* In particular it guarantees that the result r satisfies
	* MIN(x,y) <= r <= MAX(x,y), and the results are very accurate
	* even when a and b differ greatly in magnitude.
	*/
	Geom.interpolate = function(a,x,b,y) {
		return (a = (a < 0) ? 0 : a, b = (b < 0) ? 0 : b, ((a <= b) ? ((b == 0) ? ((x+y) / 2) : (x + (y-x) * (a/(a+b)))) : (y + (x-y) * (b/(a+b)))));
	};

	/*
	#ifndef FOR_TRITE_TEST_PROGRAM
	#define Interpolate(a,x,b,y)	RealInterpolate(a,x,b,y)
	#else

	// Claim: the ONLY property the sweep algorithm relies on is that
	// MIN(x,y) <= r <= MAX(x,y).  This is a nasty way to test that.
	#include <stdlib.h>
	extern int RandomInterpolate;

	double Interpolate( double a, double x, double b, double y)
	{
		printf("*********************%d\n",RandomInterpolate);
		if( RandomInterpolate ) {
			a = 1.2 * drand48() - 0.1;
			a = (a < 0) ? 0 : ((a > 1) ? 1 : a);
			b = 1.0 - a;
		}
		return RealInterpolate(a,x,b,y);
	}
	#endif*/

	Geom.intersect = function( o1, d1, o2, d2, v ) {
		/* Given edges (o1,d1) and (o2,d2), compute their point of intersection.
		* The computed point is guaranteed to lie in the intersection of the
		* bounding rectangles defined by each edge.
		*/
		var z1, z2;
		var t;

		/* This is certainly not the most efficient way to find the intersection
		* of two line segments, but it is very numerically stable.
		*
		* Strategy: find the two middle vertices in the VertLeq ordering,
		* and interpolate the intersection s-value from these.  Then repeat
		* using the TransLeq ordering to find the intersection t-value.
		*/

		if( ! Geom.vertLeq( o1, d1 )) { t = o1; o1 = d1; d1 = t; } //swap( o1, d1 ); }
		if( ! Geom.vertLeq( o2, d2 )) { t = o2; o2 = d2; d2 = t; } //swap( o2, d2 ); }
		if( ! Geom.vertLeq( o1, o2 )) { t = o1; o1 = o2; o2 = t; t = d1; d1 = d2; d2 = t; }//swap( o1, o2 ); swap( d1, d2 ); }

		if( ! Geom.vertLeq( o2, d1 )) {
			/* Technically, no intersection -- do our best */
			v.s = (o2.s + d1.s) / 2;
		} else if( Geom.vertLeq( d1, d2 )) {
			/* Interpolate between o2 and d1 */
			z1 = Geom.edgeEval( o1, o2, d1 );
			z2 = Geom.edgeEval( o2, d1, d2 );
			if( z1+z2 < 0 ) { z1 = -z1; z2 = -z2; }
			v.s = Geom.interpolate( z1, o2.s, z2, d1.s );
		} else {
			/* Interpolate between o2 and d2 */
			z1 = Geom.edgeSign( o1, o2, d1 );
			z2 = -Geom.edgeSign( o1, d2, d1 );
			if( z1+z2 < 0 ) { z1 = -z1; z2 = -z2; }
			v.s = Geom.interpolate( z1, o2.s, z2, d2.s );
		}

		/* Now repeat the process for t */

		if( ! Geom.transLeq( o1, d1 )) { t = o1; o1 = d1; d1 = t; } //swap( o1, d1 ); }
		if( ! Geom.transLeq( o2, d2 )) { t = o2; o2 = d2; d2 = t; } //swap( o2, d2 ); }
		if( ! Geom.transLeq( o1, o2 )) { t = o1; o1 = o2; o2 = t; t = d1; d1 = d2; d2 = t; } //swap( o1, o2 ); swap( d1, d2 ); }

		if( ! Geom.transLeq( o2, d1 )) {
			/* Technically, no intersection -- do our best */
			v.t = (o2.t + d1.t) / 2;
		} else if( Geom.transLeq( d1, d2 )) {
			/* Interpolate between o2 and d1 */
			z1 = Geom.transEval( o1, o2, d1 );
			z2 = Geom.transEval( o2, d1, d2 );
			if( z1+z2 < 0 ) { z1 = -z1; z2 = -z2; }
			v.t = Geom.interpolate( z1, o2.t, z2, d1.t );
		} else {
			/* Interpolate between o2 and d2 */
			z1 = Geom.transSign( o1, o2, d1 );
			z2 = -Geom.transSign( o1, d2, d1 );
			if( z1+z2 < 0 ) { z1 = -z1; z2 = -z2; }
			v.t = Geom.interpolate( z1, o2.t, z2, d2.t );
		}
	};



	function DictNode() {
		this.key = null;
		this.next = null;
		this.prev = null;
	};

	function Dict(frame, leq) {
		this.head = new DictNode();
		this.head.next = this.head;
		this.head.prev = this.head;
		this.frame = frame;
		this.leq = leq;
	};

	Dict.prototype = {
		min: function() {
			return this.head.next;
		},

		max: function() {
			return this.head.prev;
		},

		insert: function(k) {
			return this.insertBefore(this.head, k);
		},

		search: function(key) {
			/* Search returns the node with the smallest key greater than or equal
			* to the given key.  If there is no such key, returns a node whose
			* key is NULL.  Similarly, Succ(Max(d)) has a NULL key, etc.
			*/
			var node = this.head;
			do {
				node = node.next;
			} while( node.key !== null && ! this.leq(this.frame, key, node.key));

			return node;
		},

		insertBefore: function(node, key) {
			do {
				node = node.prev;
			} while( node.key !== null && ! this.leq(this.frame, node.key, key));

			var newNode = new DictNode();
			newNode.key = key;
			newNode.next = node.next;
			node.next.prev = newNode;
			newNode.prev = node;
			node.next = newNode;

			return newNode;
		},

		delete: function(node) {
			node.next.prev = node.prev;
			node.prev.next = node.next;
		}
	};


	function PQnode() {
		this.handle = null;
	}

	function PQhandleElem() {
		this.key = null;
		this.node = null;
	}

	function PriorityQ(size, leq) {
		this.size = 0;
		this.max = size;

		this.nodes = [];
		this.nodes.length = size+1;
		for (var i = 0; i < this.nodes.length; i++)
			this.nodes[i] = new PQnode();

		this.handles = [];
		this.handles.length = size+1;
		for (var i = 0; i < this.handles.length; i++)
			this.handles[i] = new PQhandleElem();

		this.initialized = false;
		this.freeList = 0;
		this.leq = leq;

		this.nodes[1].handle = 1;	/* so that Minimum() returns NULL */
		this.handles[1].key = null;
	};

	PriorityQ.prototype = {

		floatDown_: function( curr )
		{
			var n = this.nodes;
			var h = this.handles;
			var hCurr, hChild;
			var child;

			hCurr = n[curr].handle;
			for( ;; ) {
				child = curr << 1;
				if( child < this.size && this.leq( h[n[child+1].handle].key, h[n[child].handle].key )) {
					++child;
				}

				assert(child <= this.max);

				hChild = n[child].handle;
				if( child > this.size || this.leq( h[hCurr].key, h[hChild].key )) {
					n[curr].handle = hCurr;
					h[hCurr].node = curr;
					break;
				}
				n[curr].handle = hChild;
				h[hChild].node = curr;
				curr = child;
			}
		},

		floatUp_: function( curr )
		{
			var n = this.nodes;
			var h = this.handles;
			var hCurr, hParent;
			var parent;

			hCurr = n[curr].handle;
			for( ;; ) {
				parent = curr >> 1;
				hParent = n[parent].handle;
				if( parent == 0 || this.leq( h[hParent].key, h[hCurr].key )) {
					n[curr].handle = hCurr;
					h[hCurr].node = curr;
					break;
				}
				n[curr].handle = hParent;
				h[hParent].node = curr;
				curr = parent;
			}
		},

		init: function() {
			/* This method of building a heap is O(n), rather than O(n lg n). */
			for( var i = this.size; i >= 1; --i ) {
				this.floatDown_( i );
			}
			this.initialized = true;
		},

		min: function() {
			return this.handles[this.nodes[1].handle].key;
		},

		isEmpty: function() {
			this.size === 0;
		},

		/* really pqHeapInsert */
		/* returns INV_HANDLE iff out of memory */
		//PQhandle pqHeapInsert( TESSalloc* alloc, PriorityQHeap *pq, PQkey keyNew )
		insert: function(keyNew)
		{
			var curr;
			var free;

			curr = ++this.size;
			if( (curr*2) > this.max ) {
				this.max *= 2;
				var s;
				s = this.nodes.length;
				this.nodes.length = this.max+1;
				for (var i = s; i < this.nodes.length; i++)
					this.nodes[i] = new PQnode();

				s = this.handles.length;
				this.handles.length = this.max+1;
				for (var i = s; i < this.handles.length; i++)
					this.handles[i] = new PQhandleElem();
			}

			if( this.freeList === 0 ) {
				free = curr;
			} else {
				free = this.freeList;
				this.freeList = this.handles[free].node;
			}

			this.nodes[curr].handle = free;
			this.handles[free].node = curr;
			this.handles[free].key = keyNew;

			if( this.initialized ) {
				this.floatUp_( curr );
			}
			return free;
		},

		//PQkey pqHeapExtractMin( PriorityQHeap *pq )
		extractMin: function() {
			var n = this.nodes;
			var h = this.handles;
			var hMin = n[1].handle;
			var min = h[hMin].key;

			if( this.size > 0 ) {
				n[1].handle = n[this.size].handle;
				h[n[1].handle].node = 1;

				h[hMin].key = null;
				h[hMin].node = this.freeList;
				this.freeList = hMin;

				--this.size;
				if( this.size > 0 ) {
					this.floatDown_( 1 );
				}
			}
			return min;
		},

		delete: function( hCurr ) {
			var n = this.nodes;
			var h = this.handles;
			var curr;

			assert( hCurr >= 1 && hCurr <= this.max && h[hCurr].key !== null );

			curr = h[hCurr].node;
			n[curr].handle = n[this.size].handle;
			h[n[curr].handle].node = curr;

			--this.size;
			if( curr <= this.size ) {
				if( curr <= 1 || this.leq( h[n[curr>>1].handle].key, h[n[curr].handle].key )) {
					this.floatDown_( curr );
				} else {
					this.floatUp_( curr );
				}
			}
			h[hCurr].key = null;
			h[hCurr].node = this.freeList;
			this.freeList = hCurr;
		}
	};


	/* For each pair of adjacent edges crossing the sweep line, there is
	* an ActiveRegion to represent the region between them.  The active
	* regions are kept in sorted order in a dynamic dictionary.  As the
	* sweep line crosses each vertex, we update the affected regions.
	*/

	function ActiveRegion() {
		this.eUp = null;		/* upper edge, directed right to left */
		this.nodeUp = null;	/* dictionary node corresponding to eUp */
		this.windingNumber = 0;	/* used to determine which regions are
								* inside the polygon */
		this.inside = false;		/* is this region inside the polygon? */
		this.sentinel = false;	/* marks fake edges at t = +/-infinity */
		this.dirty = false;		/* marks regions where the upper or lower
						* edge has changed, but we haven't checked
						* whether they intersect yet */
		this.fixUpperEdge = false;	/* marks temporary edges introduced when
							* we process a "right vertex" (one without
							* any edges leaving to the right) */
	};

	var Sweep = {};

	Sweep.regionBelow = function(r) {
		return r.nodeUp.prev.key;
	}

	Sweep.regionAbove = function(r) {
		return r.nodeUp.next.key;
	}

	Sweep.debugEvent = function( tess ) {
		// empty
	}


	/*
	* Invariants for the Edge Dictionary.
	* - each pair of adjacent edges e2=Succ(e1) satisfies EdgeLeq(e1,e2)
	*   at any valid location of the sweep event
	* - if EdgeLeq(e2,e1) as well (at any valid sweep event), then e1 and e2
	*   share a common endpoint
	* - for each e, e->Dst has been processed, but not e->Org
	* - each edge e satisfies VertLeq(e->Dst,event) && VertLeq(event,e->Org)
	*   where "event" is the current sweep line event.
	* - no edge e has zero length
	*
	* Invariants for the Mesh (the processed portion).
	* - the portion of the mesh left of the sweep line is a planar graph,
	*   ie. there is *some* way to embed it in the plane
	* - no processed edge has zero length
	* - no two processed vertices have identical coordinates
	* - each "inside" region is monotone, ie. can be broken into two chains
	*   of monotonically increasing vertices according to VertLeq(v1,v2)
	*   - a non-invariant: these chains may intersect (very slightly)
	*
	* Invariants for the Sweep.
	* - if none of the edges incident to the event vertex have an activeRegion
	*   (ie. none of these edges are in the edge dictionary), then the vertex
	*   has only right-going edges.
	* - if an edge is marked "fixUpperEdge" (it is a temporary edge introduced
	*   by ConnectRightVertex), then it is the only right-going edge from
	*   its associated vertex.  (This says that these edges exist only
	*   when it is necessary.)
	*/

	/* When we merge two edges into one, we need to compute the combined
	* winding of the new edge.
	*/
	Sweep.addWinding = function(eDst,eSrc) {
		eDst.winding += eSrc.winding;
		eDst.Sym.winding += eSrc.Sym.winding;
	}


	//static int EdgeLeq( TESStesselator *tess, ActiveRegion *reg1, ActiveRegion *reg2 )
	Sweep.edgeLeq = function( tess, reg1, reg2 ) {
		/*
		* Both edges must be directed from right to left (this is the canonical
		* direction for the upper edge of each region).
		*
		* The strategy is to evaluate a "t" value for each edge at the
		* current sweep line position, given by tess->event.  The calculations
		* are designed to be very stable, but of course they are not perfect.
		*
		* Special case: if both edge destinations are at the sweep event,
		* we sort the edges by slope (they would otherwise compare equally).
		*/
		var ev = tess.event;
		var t1, t2;

		var e1 = reg1.eUp;
		var e2 = reg2.eUp;

		if( e1.Dst === ev ) {
			if( e2.Dst === ev ) {
				/* Two edges right of the sweep line which meet at the sweep event.
				* Sort them by slope.
				*/
				if( Geom.vertLeq( e1.Org, e2.Org )) {
					return Geom.edgeSign( e2.Dst, e1.Org, e2.Org ) <= 0;
				}
				return Geom.edgeSign( e1.Dst, e2.Org, e1.Org ) >= 0;
			}
			return Geom.edgeSign( e2.Dst, ev, e2.Org ) <= 0;
		}
		if( e2.Dst === ev ) {
			return Geom.edgeSign( e1.Dst, ev, e1.Org ) >= 0;
		}

		/* General case - compute signed distance *from* e1, e2 to event */
		var t1 = Geom.edgeEval( e1.Dst, ev, e1.Org );
		var t2 = Geom.edgeEval( e2.Dst, ev, e2.Org );
		return (t1 >= t2);
	}


	//static void DeleteRegion( TESStesselator *tess, ActiveRegion *reg )
	Sweep.deleteRegion = function( tess, reg ) {
		if( reg.fixUpperEdge ) {
			/* It was created with zero winding number, so it better be
			* deleted with zero winding number (ie. it better not get merged
			* with a real edge).
			*/
			assert( reg.eUp.winding === 0 );
		}
		reg.eUp.activeRegion = null;
		tess.dict.delete( reg.nodeUp );
	}

	//static int FixUpperEdge( TESStesselator *tess, ActiveRegion *reg, TESShalfEdge *newEdge )
	Sweep.fixUpperEdge = function( tess, reg, newEdge ) {
		/*
		* Replace an upper edge which needs fixing (see ConnectRightVertex).
		*/
		assert( reg.fixUpperEdge );
		tess.mesh.delete( reg.eUp );
		reg.fixUpperEdge = false;
		reg.eUp = newEdge;
		newEdge.activeRegion = reg;
	}

	//static ActiveRegion *TopLeftRegion( TESStesselator *tess, ActiveRegion *reg )
	Sweep.topLeftRegion = function( tess, reg ) {
		var org = reg.eUp.Org;
		var e;

		/* Find the region above the uppermost edge with the same origin */
		do {
			reg = Sweep.regionAbove( reg );
		} while( reg.eUp.Org === org );

		/* If the edge above was a temporary edge introduced by ConnectRightVertex,
		* now is the time to fix it.
		*/
		if( reg.fixUpperEdge ) {
			e = tess.mesh.connect( Sweep.regionBelow(reg).eUp.Sym, reg.eUp.Lnext );
			if (e === null) return null;
			Sweep.fixUpperEdge( tess, reg, e );
			reg = Sweep.regionAbove( reg );
		}
		return reg;
	}

	//static ActiveRegion *TopRightRegion( ActiveRegion *reg )
	Sweep.topRightRegion = function( reg )
	{
		var dst = reg.eUp.Dst;
		var reg = null;
		/* Find the region above the uppermost edge with the same destination */
		do {
			reg = Sweep.regionAbove( reg );
		} while( reg.eUp.Dst === dst );
		return reg;
	}

	//static ActiveRegion *AddRegionBelow( TESStesselator *tess, ActiveRegion *regAbove, TESShalfEdge *eNewUp )
	Sweep.addRegionBelow = function( tess, regAbove, eNewUp ) {
		/*
		* Add a new active region to the sweep line, *somewhere* below "regAbove"
		* (according to where the new edge belongs in the sweep-line dictionary).
		* The upper edge of the new region will be "eNewUp".
		* Winding number and "inside" flag are not updated.
		*/
		var regNew = new ActiveRegion();
		regNew.eUp = eNewUp;
		regNew.nodeUp = tess.dict.insertBefore( regAbove.nodeUp, regNew );
	//	if (regNew->nodeUp == NULL) longjmp(tess->env,1);
		regNew.fixUpperEdge = false;
		regNew.sentinel = false;
		regNew.dirty = false;

		eNewUp.activeRegion = regNew;
		return regNew;
	}

	//static int IsWindingInside( TESStesselator *tess, int n )
	Sweep.isWindingInside = function( tess, n ) {
		switch( tess.windingRule ) {
			case Tess2.WINDING_ODD:
				return (n & 1) != 0;
			case Tess2.WINDING_NONZERO:
				return (n != 0);
			case Tess2.WINDING_POSITIVE:
				return (n > 0);
			case Tess2.WINDING_NEGATIVE:
				return (n < 0);
			case Tess2.WINDING_ABS_GEQ_TWO:
				return (n >= 2) || (n <= -2);
		}
		assert( false );
		return false;
	}

	//static void ComputeWinding( TESStesselator *tess, ActiveRegion *reg )
	Sweep.computeWinding = function( tess, reg ) {
		reg.windingNumber = Sweep.regionAbove(reg).windingNumber + reg.eUp.winding;
		reg.inside = Sweep.isWindingInside( tess, reg.windingNumber );
	}


	//static void FinishRegion( TESStesselator *tess, ActiveRegion *reg )
	Sweep.finishRegion = function( tess, reg ) {
		/*
		* Delete a region from the sweep line.  This happens when the upper
		* and lower chains of a region meet (at a vertex on the sweep line).
		* The "inside" flag is copied to the appropriate mesh face (we could
		* not do this before -- since the structure of the mesh is always
		* changing, this face may not have even existed until now).
		*/
		var e = reg.eUp;
		var f = e.Lface;

		f.inside = reg.inside;
		f.anEdge = e;   /* optimization for tessMeshTessellateMonoRegion() */
		Sweep.deleteRegion( tess, reg );
	}


	//static TESShalfEdge *FinishLeftRegions( TESStesselator *tess, ActiveRegion *regFirst, ActiveRegion *regLast )
	Sweep.finishLeftRegions = function( tess, regFirst, regLast ) {
		/*
		* We are given a vertex with one or more left-going edges.  All affected
		* edges should be in the edge dictionary.  Starting at regFirst->eUp,
		* we walk down deleting all regions where both edges have the same
		* origin vOrg.  At the same time we copy the "inside" flag from the
		* active region to the face, since at this point each face will belong
		* to at most one region (this was not necessarily true until this point
		* in the sweep).  The walk stops at the region above regLast; if regLast
		* is NULL we walk as far as possible.  At the same time we relink the
		* mesh if necessary, so that the ordering of edges around vOrg is the
		* same as in the dictionary.
		*/
		var e, ePrev;
		var reg = null;
		var regPrev = regFirst;
		var ePrev = regFirst.eUp;
		while( regPrev !== regLast ) {
			regPrev.fixUpperEdge = false;	/* placement was OK */
			reg = Sweep.regionBelow( regPrev );
			e = reg.eUp;
			if( e.Org != ePrev.Org ) {
				if( ! reg.fixUpperEdge ) {
					/* Remove the last left-going edge.  Even though there are no further
					* edges in the dictionary with this origin, there may be further
					* such edges in the mesh (if we are adding left edges to a vertex
					* that has already been processed).  Thus it is important to call
					* FinishRegion rather than just DeleteRegion.
					*/
					Sweep.finishRegion( tess, regPrev );
					break;
				}
				/* If the edge below was a temporary edge introduced by
				* ConnectRightVertex, now is the time to fix it.
				*/
				e = tess.mesh.connect( ePrev.Lprev, e.Sym );
	//			if (e == NULL) longjmp(tess->env,1);
				Sweep.fixUpperEdge( tess, reg, e );
			}

			/* Relink edges so that ePrev->Onext == e */
			if( ePrev.Onext !== e ) {
				tess.mesh.splice( e.Oprev, e );
				tess.mesh.splice( ePrev, e );
			}
			Sweep.finishRegion( tess, regPrev );	/* may change reg->eUp */
			ePrev = reg.eUp;
			regPrev = reg;
		}
		return ePrev;
	}


	//static void AddRightEdges( TESStesselator *tess, ActiveRegion *regUp, TESShalfEdge *eFirst, TESShalfEdge *eLast, TESShalfEdge *eTopLeft, int cleanUp )
	Sweep.addRightEdges = function( tess, regUp, eFirst, eLast, eTopLeft, cleanUp ) {
		/*
		* Purpose: insert right-going edges into the edge dictionary, and update
		* winding numbers and mesh connectivity appropriately.  All right-going
		* edges share a common origin vOrg.  Edges are inserted CCW starting at
		* eFirst; the last edge inserted is eLast->Oprev.  If vOrg has any
		* left-going edges already processed, then eTopLeft must be the edge
		* such that an imaginary upward vertical segment from vOrg would be
		* contained between eTopLeft->Oprev and eTopLeft; otherwise eTopLeft
		* should be NULL.
		*/
		var reg, regPrev;
		var e, ePrev;
		var firstTime = true;

		/* Insert the new right-going edges in the dictionary */
		e = eFirst;
		do {
			assert( Geom.vertLeq( e.Org, e.Dst ));
			Sweep.addRegionBelow( tess, regUp, e.Sym );
			e = e.Onext;
		} while ( e !== eLast );

		/* Walk *all* right-going edges from e->Org, in the dictionary order,
		* updating the winding numbers of each region, and re-linking the mesh
		* edges to match the dictionary ordering (if necessary).
		*/
		if( eTopLeft === null ) {
			eTopLeft = Sweep.regionBelow( regUp ).eUp.Rprev;
		}
		regPrev = regUp;
		ePrev = eTopLeft;
		for( ;; ) {
			reg = Sweep.regionBelow( regPrev );
			e = reg.eUp.Sym;
			if( e.Org !== ePrev.Org ) break;

			if( e.Onext !== ePrev ) {
				/* Unlink e from its current position, and relink below ePrev */
				tess.mesh.splice( e.Oprev, e );
				tess.mesh.splice( ePrev.Oprev, e );
			}
			/* Compute the winding number and "inside" flag for the new regions */
			reg.windingNumber = regPrev.windingNumber - e.winding;
			reg.inside = Sweep.isWindingInside( tess, reg.windingNumber );

			/* Check for two outgoing edges with same slope -- process these
			* before any intersection tests (see example in tessComputeInterior).
			*/
			regPrev.dirty = true;
			if( ! firstTime && Sweep.checkForRightSplice( tess, regPrev )) {
				Sweep.addWinding( e, ePrev );
				Sweep.deleteRegion( tess, regPrev );
				tess.mesh.delete( ePrev );
			}
			firstTime = false;
			regPrev = reg;
			ePrev = e;
		}
		regPrev.dirty = true;
		assert( regPrev.windingNumber - e.winding === reg.windingNumber );

		if( cleanUp ) {
			/* Check for intersections between newly adjacent edges. */
			Sweep.walkDirtyRegions( tess, regPrev );
		}
	}


	//static void SpliceMergeVertices( TESStesselator *tess, TESShalfEdge *e1, TESShalfEdge *e2 )
	Sweep.spliceMergeVertices = function( tess, e1, e2 ) {
		/*
		* Two vertices with idential coordinates are combined into one.
		* e1->Org is kept, while e2->Org is discarded.
		*/
		tess.mesh.splice( e1, e2 ); 
	}

	//static void VertexWeights( TESSvertex *isect, TESSvertex *org, TESSvertex *dst, TESSreal *weights )
	Sweep.vertexWeights = function( isect, org, dst ) {
		/*
		* Find some weights which describe how the intersection vertex is
		* a linear combination of "org" and "dest".  Each of the two edges
		* which generated "isect" is allocated 50% of the weight; each edge
		* splits the weight between its org and dst according to the
		* relative distance to "isect".
		*/
		var t1 = Geom.vertL1dist( org, isect );
		var t2 = Geom.vertL1dist( dst, isect );
		var w0 = 0.5 * t2 / (t1 + t2);
		var w1 = 0.5 * t1 / (t1 + t2);
		isect.coords[0] += w0*org.coords[0] + w1*dst.coords[0];
		isect.coords[1] += w0*org.coords[1] + w1*dst.coords[1];
		isect.coords[2] += w0*org.coords[2] + w1*dst.coords[2];
	}


	//static void GetIntersectData( TESStesselator *tess, TESSvertex *isect, TESSvertex *orgUp, TESSvertex *dstUp, TESSvertex *orgLo, TESSvertex *dstLo )
	Sweep.getIntersectData = function( tess, isect, orgUp, dstUp, orgLo, dstLo ) {
		 /*
		 * We've computed a new intersection point, now we need a "data" pointer
		 * from the user so that we can refer to this new vertex in the
		 * rendering callbacks.
		 */
		isect.coords[0] = isect.coords[1] = isect.coords[2] = 0;
		isect.idx = -1;
		Sweep.vertexWeights( isect, orgUp, dstUp );
		Sweep.vertexWeights( isect, orgLo, dstLo );
	}

	//static int CheckForRightSplice( TESStesselator *tess, ActiveRegion *regUp )
	Sweep.checkForRightSplice = function( tess, regUp ) {
		/*
		* Check the upper and lower edge of "regUp", to make sure that the
		* eUp->Org is above eLo, or eLo->Org is below eUp (depending on which
		* origin is leftmost).
		*
		* The main purpose is to splice right-going edges with the same
		* dest vertex and nearly identical slopes (ie. we can't distinguish
		* the slopes numerically).  However the splicing can also help us
		* to recover from numerical errors.  For example, suppose at one
		* point we checked eUp and eLo, and decided that eUp->Org is barely
		* above eLo.  Then later, we split eLo into two edges (eg. from
		* a splice operation like this one).  This can change the result of
		* our test so that now eUp->Org is incident to eLo, or barely below it.
		* We must correct this condition to maintain the dictionary invariants.
		*
		* One possibility is to check these edges for intersection again
		* (ie. CheckForIntersect).  This is what we do if possible.  However
		* CheckForIntersect requires that tess->event lies between eUp and eLo,
		* so that it has something to fall back on when the intersection
		* calculation gives us an unusable answer.  So, for those cases where
		* we can't check for intersection, this routine fixes the problem
		* by just splicing the offending vertex into the other edge.
		* This is a guaranteed solution, no matter how degenerate things get.
		* Basically this is a combinatorial solution to a numerical problem.
		*/
		var regLo = Sweep.regionBelow(regUp);
		var eUp = regUp.eUp;
		var eLo = regLo.eUp;

		if( Geom.vertLeq( eUp.Org, eLo.Org )) {
			if( Geom.edgeSign( eLo.Dst, eUp.Org, eLo.Org ) > 0 ) return false;

			/* eUp->Org appears to be below eLo */
			if( ! Geom.vertEq( eUp.Org, eLo.Org )) {
				/* Splice eUp->Org into eLo */
				tess.mesh.splitEdge( eLo.Sym );
				tess.mesh.splice( eUp, eLo.Oprev );
				regUp.dirty = regLo.dirty = true;

			} else if( eUp.Org !== eLo.Org ) {
				/* merge the two vertices, discarding eUp->Org */
				tess.pq.delete( eUp.Org.pqHandle );
				Sweep.spliceMergeVertices( tess, eLo.Oprev, eUp );
			}
		} else {
			if( Geom.edgeSign( eUp.Dst, eLo.Org, eUp.Org ) < 0 ) return false;

			/* eLo->Org appears to be above eUp, so splice eLo->Org into eUp */
			Sweep.regionAbove(regUp).dirty = regUp.dirty = true;
			tess.mesh.splitEdge( eUp.Sym );
			tess.mesh.splice( eLo.Oprev, eUp );
		}
		return true;
	}

	//static int CheckForLeftSplice( TESStesselator *tess, ActiveRegion *regUp )
	Sweep.checkForLeftSplice = function( tess, regUp ) {
		/*
		* Check the upper and lower edge of "regUp", to make sure that the
		* eUp->Dst is above eLo, or eLo->Dst is below eUp (depending on which
		* destination is rightmost).
		*
		* Theoretically, this should always be true.  However, splitting an edge
		* into two pieces can change the results of previous tests.  For example,
		* suppose at one point we checked eUp and eLo, and decided that eUp->Dst
		* is barely above eLo.  Then later, we split eLo into two edges (eg. from
		* a splice operation like this one).  This can change the result of
		* the test so that now eUp->Dst is incident to eLo, or barely below it.
		* We must correct this condition to maintain the dictionary invariants
		* (otherwise new edges might get inserted in the wrong place in the
		* dictionary, and bad stuff will happen).
		*
		* We fix the problem by just splicing the offending vertex into the
		* other edge.
		*/
		var regLo = Sweep.regionBelow(regUp);
		var eUp = regUp.eUp;
		var eLo = regLo.eUp;
		var e;

		assert( ! Geom.vertEq( eUp.Dst, eLo.Dst ));

		if( Geom.vertLeq( eUp.Dst, eLo.Dst )) {
			if( Geom.edgeSign( eUp.Dst, eLo.Dst, eUp.Org ) < 0 ) return false;

			/* eLo->Dst is above eUp, so splice eLo->Dst into eUp */
			Sweep.regionAbove(regUp).dirty = regUp.dirty = true;
			e = tess.mesh.splitEdge( eUp );
			tess.mesh.splice( eLo.Sym, e );
			e.Lface.inside = regUp.inside;
		} else {
			if( Geom.edgeSign( eLo.Dst, eUp.Dst, eLo.Org ) > 0 ) return false;

			/* eUp->Dst is below eLo, so splice eUp->Dst into eLo */
			regUp.dirty = regLo.dirty = true;
			e = tess.mesh.splitEdge( eLo );
			tess.mesh.splice( eUp.Lnext, eLo.Sym );
			e.Rface.inside = regUp.inside;
		}
		return true;
	}


	//static int CheckForIntersect( TESStesselator *tess, ActiveRegion *regUp )
	Sweep.checkForIntersect = function( tess, regUp ) {
		/*
		* Check the upper and lower edges of the given region to see if
		* they intersect.  If so, create the intersection and add it
		* to the data structures.
		*
		* Returns TRUE if adding the new intersection resulted in a recursive
		* call to AddRightEdges(); in this case all "dirty" regions have been
		* checked for intersections, and possibly regUp has been deleted.
		*/
		var regLo = Sweep.regionBelow(regUp);
		var eUp = regUp.eUp;
		var eLo = regLo.eUp;
		var orgUp = eUp.Org;
		var orgLo = eLo.Org;
		var dstUp = eUp.Dst;
		var dstLo = eLo.Dst;
		var tMinUp, tMaxLo;
		var isect = new TESSvertex, orgMin;
		var e;

		assert( ! Geom.vertEq( dstLo, dstUp ));
		assert( Geom.edgeSign( dstUp, tess.event, orgUp ) <= 0 );
		assert( Geom.edgeSign( dstLo, tess.event, orgLo ) >= 0 );
		assert( orgUp !== tess.event && orgLo !== tess.event );
		assert( ! regUp.fixUpperEdge && ! regLo.fixUpperEdge );

		if( orgUp === orgLo ) return false;	/* right endpoints are the same */

		tMinUp = Math.min( orgUp.t, dstUp.t );
		tMaxLo = Math.max( orgLo.t, dstLo.t );
		if( tMinUp > tMaxLo ) return false;	/* t ranges do not overlap */

		if( Geom.vertLeq( orgUp, orgLo )) {
			if( Geom.edgeSign( dstLo, orgUp, orgLo ) > 0 ) return false;
		} else {
			if( Geom.edgeSign( dstUp, orgLo, orgUp ) < 0 ) return false;
		}

		/* At this point the edges intersect, at least marginally */
		Sweep.debugEvent( tess );

		Geom.intersect( dstUp, orgUp, dstLo, orgLo, isect );
		/* The following properties are guaranteed: */
		assert( Math.min( orgUp.t, dstUp.t ) <= isect.t );
		assert( isect.t <= Math.max( orgLo.t, dstLo.t ));
		assert( Math.min( dstLo.s, dstUp.s ) <= isect.s );
		assert( isect.s <= Math.max( orgLo.s, orgUp.s ));

		if( Geom.vertLeq( isect, tess.event )) {
			/* The intersection point lies slightly to the left of the sweep line,
			* so move it until it''s slightly to the right of the sweep line.
			* (If we had perfect numerical precision, this would never happen
			* in the first place).  The easiest and safest thing to do is
			* replace the intersection by tess->event.
			*/
			isect.s = tess.event.s;
			isect.t = tess.event.t;
		}
		/* Similarly, if the computed intersection lies to the right of the
		* rightmost origin (which should rarely happen), it can cause
		* unbelievable inefficiency on sufficiently degenerate inputs.
		* (If you have the test program, try running test54.d with the
		* "X zoom" option turned on).
		*/
		orgMin = Geom.vertLeq( orgUp, orgLo ) ? orgUp : orgLo;
		if( Geom.vertLeq( orgMin, isect )) {
			isect.s = orgMin.s;
			isect.t = orgMin.t;
		}

		if( Geom.vertEq( isect, orgUp ) || Geom.vertEq( isect, orgLo )) {
			/* Easy case -- intersection at one of the right endpoints */
			Sweep.checkForRightSplice( tess, regUp );
			return false;
		}

		if(    (! Geom.vertEq( dstUp, tess.event )
			&& Geom.edgeSign( dstUp, tess.event, isect ) >= 0)
			|| (! Geom.vertEq( dstLo, tess.event )
			&& Geom.edgeSign( dstLo, tess.event, isect ) <= 0 ))
		{
			/* Very unusual -- the new upper or lower edge would pass on the
			* wrong side of the sweep event, or through it.  This can happen
			* due to very small numerical errors in the intersection calculation.
			*/
			if( dstLo === tess.event ) {
				/* Splice dstLo into eUp, and process the new region(s) */
				tess.mesh.splitEdge( eUp.Sym );
				tess.mesh.splice( eLo.Sym, eUp );
				regUp = Sweep.topLeftRegion( tess, regUp );
	//			if (regUp == NULL) longjmp(tess->env,1);
				eUp = Sweep.regionBelow(regUp).eUp;
				Sweep.finishLeftRegions( tess, Sweep.regionBelow(regUp), regLo );
				Sweep.addRightEdges( tess, regUp, eUp.Oprev, eUp, eUp, true );
				return TRUE;
			}
			if( dstUp === tess.event ) {
				/* Splice dstUp into eLo, and process the new region(s) */
				tess.mesh.splitEdge( eLo.Sym );
				tess.mesh.splice( eUp.Lnext, eLo.Oprev ); 
				regLo = regUp;
				regUp = Sweep.topRightRegion( regUp );
				e = Sweep.regionBelow(regUp).eUp.Rprev;
				regLo.eUp = eLo.Oprev;
				eLo = Sweep.finishLeftRegions( tess, regLo, null );
				Sweep.addRightEdges( tess, regUp, eLo.Onext, eUp.Rprev, e, true );
				return true;
			}
			/* Special case: called from ConnectRightVertex.  If either
			* edge passes on the wrong side of tess->event, split it
			* (and wait for ConnectRightVertex to splice it appropriately).
			*/
			if( Geom.edgeSign( dstUp, tess.event, isect ) >= 0 ) {
				Sweep.regionAbove(regUp).dirty = regUp.dirty = true;
				tess.mesh.splitEdge( eUp.Sym );
				eUp.Org.s = tess.event.s;
				eUp.Org.t = tess.event.t;
			}
			if( Geom.edgeSign( dstLo, tess.event, isect ) <= 0 ) {
				regUp.dirty = regLo.dirty = true;
				tess.mesh.splitEdge( eLo.Sym );
				eLo.Org.s = tess.event.s;
				eLo.Org.t = tess.event.t;
			}
			/* leave the rest for ConnectRightVertex */
			return false;
		}

		/* General case -- split both edges, splice into new vertex.
		* When we do the splice operation, the order of the arguments is
		* arbitrary as far as correctness goes.  However, when the operation
		* creates a new face, the work done is proportional to the size of
		* the new face.  We expect the faces in the processed part of
		* the mesh (ie. eUp->Lface) to be smaller than the faces in the
		* unprocessed original contours (which will be eLo->Oprev->Lface).
		*/
		tess.mesh.splitEdge( eUp.Sym );
		tess.mesh.splitEdge( eLo.Sym );
		tess.mesh.splice( eLo.Oprev, eUp );
		eUp.Org.s = isect.s;
		eUp.Org.t = isect.t;
		eUp.Org.pqHandle = tess.pq.insert( eUp.Org );
		Sweep.getIntersectData( tess, eUp.Org, orgUp, dstUp, orgLo, dstLo );
		Sweep.regionAbove(regUp).dirty = regUp.dirty = regLo.dirty = true;
		return false;
	}

	//static void WalkDirtyRegions( TESStesselator *tess, ActiveRegion *regUp )
	Sweep.walkDirtyRegions = function( tess, regUp ) {
		/*
		* When the upper or lower edge of any region changes, the region is
		* marked "dirty".  This routine walks through all the dirty regions
		* and makes sure that the dictionary invariants are satisfied
		* (see the comments at the beginning of this file).  Of course
		* new dirty regions can be created as we make changes to restore
		* the invariants.
		*/
		var regLo = Sweep.regionBelow(regUp);
		var eUp, eLo;

		for( ;; ) {
			/* Find the lowest dirty region (we walk from the bottom up). */
			while( regLo.dirty ) {
				regUp = regLo;
				regLo = Sweep.regionBelow(regLo);
			}
			if( ! regUp.dirty ) {
				regLo = regUp;
				regUp = Sweep.regionAbove( regUp );
				if( regUp == null || ! regUp.dirty ) {
					/* We've walked all the dirty regions */
					return;
				}
			}
			regUp.dirty = false;
			eUp = regUp.eUp;
			eLo = regLo.eUp;

			if( eUp.Dst !== eLo.Dst ) {
				/* Check that the edge ordering is obeyed at the Dst vertices. */
				if( Sweep.checkForLeftSplice( tess, regUp )) {

					/* If the upper or lower edge was marked fixUpperEdge, then
					* we no longer need it (since these edges are needed only for
					* vertices which otherwise have no right-going edges).
					*/
					if( regLo.fixUpperEdge ) {
						Sweep.deleteRegion( tess, regLo );
						tess.mesh.delete( eLo );
						regLo = Sweep.regionBelow( regUp );
						eLo = regLo.eUp;
					} else if( regUp.fixUpperEdge ) {
						Sweep.deleteRegion( tess, regUp );
						tess.mesh.delete( eUp );
						regUp = Sweep.regionAbove( regLo );
						eUp = regUp.eUp;
					}
				}
			}
			if( eUp.Org !== eLo.Org ) {
				if(    eUp.Dst !== eLo.Dst
					&& ! regUp.fixUpperEdge && ! regLo.fixUpperEdge
					&& (eUp.Dst === tess.event || eLo.Dst === tess.event) )
				{
					/* When all else fails in CheckForIntersect(), it uses tess->event
					* as the intersection location.  To make this possible, it requires
					* that tess->event lie between the upper and lower edges, and also
					* that neither of these is marked fixUpperEdge (since in the worst
					* case it might splice one of these edges into tess->event, and
					* violate the invariant that fixable edges are the only right-going
					* edge from their associated vertex).
					*/
					if( Sweep.checkForIntersect( tess, regUp )) {
						/* WalkDirtyRegions() was called recursively; we're done */
						return;
					}
				} else {
					/* Even though we can't use CheckForIntersect(), the Org vertices
					* may violate the dictionary edge ordering.  Check and correct this.
					*/
					Sweep.checkForRightSplice( tess, regUp );
				}
			}
			if( eUp.Org === eLo.Org && eUp.Dst === eLo.Dst ) {
				/* A degenerate loop consisting of only two edges -- delete it. */
				Sweep.addWinding( eLo, eUp );
				Sweep.deleteRegion( tess, regUp );
				tess.mesh.delete( eUp );
				regUp = Sweep.regionAbove( regLo );
			}
		}
	}


	//static void ConnectRightVertex( TESStesselator *tess, ActiveRegion *regUp, TESShalfEdge *eBottomLeft )
	Sweep.connectRightVertex = function( tess, regUp, eBottomLeft ) {
		/*
		* Purpose: connect a "right" vertex vEvent (one where all edges go left)
		* to the unprocessed portion of the mesh.  Since there are no right-going
		* edges, two regions (one above vEvent and one below) are being merged
		* into one.  "regUp" is the upper of these two regions.
		*
		* There are two reasons for doing this (adding a right-going edge):
		*  - if the two regions being merged are "inside", we must add an edge
		*    to keep them separated (the combined region would not be monotone).
		*  - in any case, we must leave some record of vEvent in the dictionary,
		*    so that we can merge vEvent with features that we have not seen yet.
		*    For example, maybe there is a vertical edge which passes just to
		*    the right of vEvent; we would like to splice vEvent into this edge.
		*
		* However, we don't want to connect vEvent to just any vertex.  We don''t
		* want the new edge to cross any other edges; otherwise we will create
		* intersection vertices even when the input data had no self-intersections.
		* (This is a bad thing; if the user's input data has no intersections,
		* we don't want to generate any false intersections ourselves.)
		*
		* Our eventual goal is to connect vEvent to the leftmost unprocessed
		* vertex of the combined region (the union of regUp and regLo).
		* But because of unseen vertices with all right-going edges, and also
		* new vertices which may be created by edge intersections, we don''t
		* know where that leftmost unprocessed vertex is.  In the meantime, we
		* connect vEvent to the closest vertex of either chain, and mark the region
		* as "fixUpperEdge".  This flag says to delete and reconnect this edge
		* to the next processed vertex on the boundary of the combined region.
		* Quite possibly the vertex we connected to will turn out to be the
		* closest one, in which case we won''t need to make any changes.
		*/
		var eNew;
		var eTopLeft = eBottomLeft.Onext;
		var regLo = Sweep.regionBelow(regUp);
		var eUp = regUp.eUp;
		var eLo = regLo.eUp;
		var degenerate = false;

		if( eUp.Dst !== eLo.Dst ) {
			Sweep.checkForIntersect( tess, regUp );
		}

		/* Possible new degeneracies: upper or lower edge of regUp may pass
		* through vEvent, or may coincide with new intersection vertex
		*/
		if( Geom.vertEq( eUp.Org, tess.event )) {
			tess.mesh.splice( eTopLeft.Oprev, eUp );
			regUp = Sweep.topLeftRegion( tess, regUp );
			eTopLeft = Sweep.regionBelow( regUp ).eUp;
			Sweep.finishLeftRegions( tess, Sweep.regionBelow(regUp), regLo );
			degenerate = true;
		}
		if( Geom.vertEq( eLo.Org, tess.event )) {
			tess.mesh.splice( eBottomLeft, eLo.Oprev );
			eBottomLeft = Sweep.finishLeftRegions( tess, regLo, null );
			degenerate = true;
		}
		if( degenerate ) {
			Sweep.addRightEdges( tess, regUp, eBottomLeft.Onext, eTopLeft, eTopLeft, true );
			return;
		}

		/* Non-degenerate situation -- need to add a temporary, fixable edge.
		* Connect to the closer of eLo->Org, eUp->Org.
		*/
		if( Geom.vertLeq( eLo.Org, eUp.Org )) {
			eNew = eLo.Oprev;
		} else {
			eNew = eUp;
		}
		eNew = tess.mesh.connect( eBottomLeft.Lprev, eNew );

		/* Prevent cleanup, otherwise eNew might disappear before we've even
		* had a chance to mark it as a temporary edge.
		*/
		Sweep.addRightEdges( tess, regUp, eNew, eNew.Onext, eNew.Onext, false );
		eNew.Sym.activeRegion.fixUpperEdge = true;
		Sweep.walkDirtyRegions( tess, regUp );
	}

	/* Because vertices at exactly the same location are merged together
	* before we process the sweep event, some degenerate cases can't occur.
	* However if someone eventually makes the modifications required to
	* merge features which are close together, the cases below marked
	* TOLERANCE_NONZERO will be useful.  They were debugged before the
	* code to merge identical vertices in the main loop was added.
	*/
	//#define TOLERANCE_NONZERO	FALSE

	//static void ConnectLeftDegenerate( TESStesselator *tess, ActiveRegion *regUp, TESSvertex *vEvent )
	Sweep.connectLeftDegenerate = function( tess, regUp, vEvent ) {
		/*
		* The event vertex lies exacty on an already-processed edge or vertex.
		* Adding the new vertex involves splicing it into the already-processed
		* part of the mesh.
		*/
		var e, eTopLeft, eTopRight, eLast;
		var reg;

		e = regUp.eUp;
		if( Geom.vertEq( e.Org, vEvent )) {
			/* e->Org is an unprocessed vertex - just combine them, and wait
			* for e->Org to be pulled from the queue
			*/
			assert( false /*TOLERANCE_NONZERO*/ );
			Sweep.spliceMergeVertices( tess, e, vEvent.anEdge );
			return;
		}

		if( ! Geom.vertEq( e.Dst, vEvent )) {
			/* General case -- splice vEvent into edge e which passes through it */
			tess.mesh.splitEdge( e.Sym );
			if( regUp.fixUpperEdge ) {
				/* This edge was fixable -- delete unused portion of original edge */
				tess.mesh.delete( e.Onext );
				regUp.fixUpperEdge = false;
			}
			tess.mesh.splice( vEvent.anEdge, e );
			Sweep.sweepEvent( tess, vEvent );	/* recurse */
			return;
		}

		/* vEvent coincides with e->Dst, which has already been processed.
		* Splice in the additional right-going edges.
		*/
		assert( false /*TOLERANCE_NONZERO*/ );
		regUp = Sweep.topRightRegion( regUp );
		reg = Sweep.regionBelow( regUp );
		eTopRight = reg.eUp.Sym;
		eTopLeft = eLast = eTopRight.Onext;
		if( reg.fixUpperEdge ) {
			/* Here e->Dst has only a single fixable edge going right.
			* We can delete it since now we have some real right-going edges.
			*/
			assert( eTopLeft !== eTopRight );   /* there are some left edges too */
			Sweep.deleteRegion( tess, reg );
			tess.mesh.delete( eTopRight );
			eTopRight = eTopLeft.Oprev;
		}
		tess.mesh.splice( vEvent.anEdge, eTopRight );
		if( ! Geom.edgeGoesLeft( eTopLeft )) {
			/* e->Dst had no left-going edges -- indicate this to AddRightEdges() */
			eTopLeft = null;
		}
		Sweep.addRightEdges( tess, regUp, eTopRight.Onext, eLast, eTopLeft, true );
	}


	//static void ConnectLeftVertex( TESStesselator *tess, TESSvertex *vEvent )
	Sweep.connectLeftVertex = function( tess, vEvent ) {
		/*
		* Purpose: connect a "left" vertex (one where both edges go right)
		* to the processed portion of the mesh.  Let R be the active region
		* containing vEvent, and let U and L be the upper and lower edge
		* chains of R.  There are two possibilities:
		*
		* - the normal case: split R into two regions, by connecting vEvent to
		*   the rightmost vertex of U or L lying to the left of the sweep line
		*
		* - the degenerate case: if vEvent is close enough to U or L, we
		*   merge vEvent into that edge chain.  The subcases are:
		*	- merging with the rightmost vertex of U or L
		*	- merging with the active edge of U or L
		*	- merging with an already-processed portion of U or L
		*/
		var regUp, regLo, reg;
		var eUp, eLo, eNew;
		var tmp = new ActiveRegion();

		/* assert( vEvent->anEdge->Onext->Onext == vEvent->anEdge ); */

		/* Get a pointer to the active region containing vEvent */
		tmp.eUp = vEvent.anEdge.Sym;
		/* __GL_DICTLISTKEY */ /* tessDictListSearch */
		regUp = tess.dict.search( tmp ).key;
		regLo = Sweep.regionBelow( regUp );
		if( !regLo ) {
			// This may happen if the input polygon is coplanar.
			return;
		}
		eUp = regUp.eUp;
		eLo = regLo.eUp;

		/* Try merging with U or L first */
		if( Geom.edgeSign( eUp.Dst, vEvent, eUp.Org ) === 0.0 ) {
			Sweep.connectLeftDegenerate( tess, regUp, vEvent );
			return;
		}

		/* Connect vEvent to rightmost processed vertex of either chain.
		* e->Dst is the vertex that we will connect to vEvent.
		*/
		reg = Geom.vertLeq( eLo.Dst, eUp.Dst ) ? regUp : regLo;

		if( regUp.inside || reg.fixUpperEdge) {
			if( reg === regUp ) {
				eNew = tess.mesh.connect( vEvent.anEdge.Sym, eUp.Lnext );
			} else {
				var tempHalfEdge = tess.mesh.connect( eLo.Dnext, vEvent.anEdge);
				eNew = tempHalfEdge.Sym;
			}
			if( reg.fixUpperEdge ) {
				Sweep.fixUpperEdge( tess, reg, eNew );
			} else {
				Sweep.computeWinding( tess, Sweep.addRegionBelow( tess, regUp, eNew ));
			}
			Sweep.sweepEvent( tess, vEvent );
		} else {
			/* The new vertex is in a region which does not belong to the polygon.
			* We don''t need to connect this vertex to the rest of the mesh.
			*/
			Sweep.addRightEdges( tess, regUp, vEvent.anEdge, vEvent.anEdge, null, true );
		}
	};


	//static void SweepEvent( TESStesselator *tess, TESSvertex *vEvent )
	Sweep.sweepEvent = function( tess, vEvent ) {
		/*
		* Does everything necessary when the sweep line crosses a vertex.
		* Updates the mesh and the edge dictionary.
		*/

		tess.event = vEvent;		/* for access in EdgeLeq() */
		Sweep.debugEvent( tess );

		/* Check if this vertex is the right endpoint of an edge that is
		* already in the dictionary.  In this case we don't need to waste
		* time searching for the location to insert new edges.
		*/
		var e = vEvent.anEdge;
		while( e.activeRegion === null ) {
			e = e.Onext;
			if( e == vEvent.anEdge ) {
				/* All edges go right -- not incident to any processed edges */
				Sweep.connectLeftVertex( tess, vEvent );
				return;
			}
		}

		/* Processing consists of two phases: first we "finish" all the
		* active regions where both the upper and lower edges terminate
		* at vEvent (ie. vEvent is closing off these regions).
		* We mark these faces "inside" or "outside" the polygon according
		* to their winding number, and delete the edges from the dictionary.
		* This takes care of all the left-going edges from vEvent.
		*/
		var regUp = Sweep.topLeftRegion( tess, e.activeRegion );
		assert( regUp !== null );
	//	if (regUp == NULL) longjmp(tess->env,1);
		var reg = Sweep.regionBelow( regUp );
		var eTopLeft = reg.eUp;
		var eBottomLeft = Sweep.finishLeftRegions( tess, reg, null );

		/* Next we process all the right-going edges from vEvent.  This
		* involves adding the edges to the dictionary, and creating the
		* associated "active regions" which record information about the
		* regions between adjacent dictionary edges.
		*/
		if( eBottomLeft.Onext === eTopLeft ) {
			/* No right-going edges -- add a temporary "fixable" edge */
			Sweep.connectRightVertex( tess, regUp, eBottomLeft );
		} else {
			Sweep.addRightEdges( tess, regUp, eBottomLeft.Onext, eTopLeft, eTopLeft, true );
		}
	};


	/* Make the sentinel coordinates big enough that they will never be
	* merged with real input features.
	*/

	//static void AddSentinel( TESStesselator *tess, TESSreal smin, TESSreal smax, TESSreal t )
	Sweep.addSentinel = function( tess, smin, smax, t ) {
		/*
		* We add two sentinel edges above and below all other edges,
		* to avoid special cases at the top and bottom.
		*/
		var reg = new ActiveRegion();
		var e = tess.mesh.makeEdge();
	//	if (e == NULL) longjmp(tess->env,1);

		e.Org.s = smax;
		e.Org.t = t;
		e.Dst.s = smin;
		e.Dst.t = t;
		tess.event = e.Dst;		/* initialize it */

		reg.eUp = e;
		reg.windingNumber = 0;
		reg.inside = false;
		reg.fixUpperEdge = false;
		reg.sentinel = true;
		reg.dirty = false;
		reg.nodeUp = tess.dict.insert( reg );
	//	if (reg->nodeUp == NULL) longjmp(tess->env,1);
	}


	//static void InitEdgeDict( TESStesselator *tess )
	Sweep.initEdgeDict = function( tess ) {
		/*
		* We maintain an ordering of edge intersections with the sweep line.
		* This order is maintained in a dynamic dictionary.
		*/
		tess.dict = new Dict( tess, Sweep.edgeLeq );
	//	if (tess->dict == NULL) longjmp(tess->env,1);

		var w = (tess.bmax[0] - tess.bmin[0]);
		var h = (tess.bmax[1] - tess.bmin[1]);

		var smin = tess.bmin[0] - w;
		var smax = tess.bmax[0] + w;
		var tmin = tess.bmin[1] - h;
		var tmax = tess.bmax[1] + h;

		Sweep.addSentinel( tess, smin, smax, tmin );
		Sweep.addSentinel( tess, smin, smax, tmax );
	}


	Sweep.doneEdgeDict = function( tess )
	{
		var reg;
		var fixedEdges = 0;

		while( (reg = tess.dict.min().key) !== null ) {
			/*
			* At the end of all processing, the dictionary should contain
			* only the two sentinel edges, plus at most one "fixable" edge
			* created by ConnectRightVertex().
			*/
			if( ! reg.sentinel ) {
				assert( reg.fixUpperEdge );
				assert( ++fixedEdges == 1 );
			}
			assert( reg.windingNumber == 0 );
			Sweep.deleteRegion( tess, reg );
			/*    tessMeshDelete( reg->eUp );*/
		}
	//	dictDeleteDict( &tess->alloc, tess->dict );
	}


	Sweep.removeDegenerateEdges = function( tess ) {
		/*
		* Remove zero-length edges, and contours with fewer than 3 vertices.
		*/
		var e, eNext, eLnext;
		var eHead = tess.mesh.eHead;

		/*LINTED*/
		for( e = eHead.next; e !== eHead; e = eNext ) {
			eNext = e.next;
			eLnext = e.Lnext;

			if( Geom.vertEq( e.Org, e.Dst ) && e.Lnext.Lnext !== e ) {
				/* Zero-length edge, contour has at least 3 edges */
				Sweep.spliceMergeVertices( tess, eLnext, e );	/* deletes e->Org */
				tess.mesh.delete( e ); /* e is a self-loop */
				e = eLnext;
				eLnext = e.Lnext;
			}
			if( eLnext.Lnext === e ) {
				/* Degenerate contour (one or two edges) */
				if( eLnext !== e ) {
					if( eLnext === eNext || eLnext === eNext.Sym ) { eNext = eNext.next; }
					tess.mesh.delete( eLnext );
				}
				if( e === eNext || e === eNext.Sym ) { eNext = eNext.next; }
				tess.mesh.delete( e );
			}
		}
	}

	Sweep.initPriorityQ = function( tess ) {
		/*
		* Insert all vertices into the priority queue which determines the
		* order in which vertices cross the sweep line.
		*/
		var pq;
		var v, vHead;
		var vertexCount = 0;
		
		vHead = tess.mesh.vHead;
		for( v = vHead.next; v !== vHead; v = v.next ) {
			vertexCount++;
		}
		/* Make sure there is enough space for sentinels. */
		vertexCount += 8; //MAX( 8, tess->alloc.extraVertices );
		
		pq = tess.pq = new PriorityQ( vertexCount, Geom.vertLeq );
	//	if (pq == NULL) return 0;

		vHead = tess.mesh.vHead;
		for( v = vHead.next; v !== vHead; v = v.next ) {
			v.pqHandle = pq.insert( v );
	//		if (v.pqHandle == INV_HANDLE)
	//			break;
		}

		if (v !== vHead) {
			return false;
		}

		pq.init();

		return true;
	}


	Sweep.donePriorityQ = function( tess ) {
		tess.pq = null;
	}


	Sweep.removeDegenerateFaces = function( tess, mesh ) {
		/*
		* Delete any degenerate faces with only two edges.  WalkDirtyRegions()
		* will catch almost all of these, but it won't catch degenerate faces
		* produced by splice operations on already-processed edges.
		* The two places this can happen are in FinishLeftRegions(), when
		* we splice in a "temporary" edge produced by ConnectRightVertex(),
		* and in CheckForLeftSplice(), where we splice already-processed
		* edges to ensure that our dictionary invariants are not violated
		* by numerical errors.
		*
		* In both these cases it is *very* dangerous to delete the offending
		* edge at the time, since one of the routines further up the stack
		* will sometimes be keeping a pointer to that edge.
		*/
		var f, fNext;
		var e;

		/*LINTED*/
		for( f = mesh.fHead.next; f !== mesh.fHead; f = fNext ) {
			fNext = f.next;
			e = f.anEdge;
			assert( e.Lnext !== e );

			if( e.Lnext.Lnext === e ) {
				/* A face with only two edges */
				Sweep.addWinding( e.Onext, e );
				tess.mesh.delete( e );
			}
		}
		return true;
	}

	Sweep.computeInterior = function( tess ) {
		/*
		* tessComputeInterior( tess ) computes the planar arrangement specified
		* by the given contours, and further subdivides this arrangement
		* into regions.  Each region is marked "inside" if it belongs
		* to the polygon, according to the rule given by tess->windingRule.
		* Each interior region is guaranteed be monotone.
		*/
		var v, vNext;

		/* Each vertex defines an event for our sweep line.  Start by inserting
		* all the vertices in a priority queue.  Events are processed in
		* lexicographic order, ie.
		*
		*	e1 < e2  iff  e1.x < e2.x || (e1.x == e2.x && e1.y < e2.y)
		*/
		Sweep.removeDegenerateEdges( tess );
		if ( !Sweep.initPriorityQ( tess ) ) return false; /* if error */
		Sweep.initEdgeDict( tess );

		while( (v = tess.pq.extractMin()) !== null ) {
			for( ;; ) {
				vNext = tess.pq.min();
				if( vNext === null || ! Geom.vertEq( vNext, v )) break;

				/* Merge together all vertices at exactly the same location.
				* This is more efficient than processing them one at a time,
				* simplifies the code (see ConnectLeftDegenerate), and is also
				* important for correct handling of certain degenerate cases.
				* For example, suppose there are two identical edges A and B
				* that belong to different contours (so without this code they would
				* be processed by separate sweep events).  Suppose another edge C
				* crosses A and B from above.  When A is processed, we split it
				* at its intersection point with C.  However this also splits C,
				* so when we insert B we may compute a slightly different
				* intersection point.  This might leave two edges with a small
				* gap between them.  This kind of error is especially obvious
				* when using boundary extraction (TESS_BOUNDARY_ONLY).
				*/
				vNext = tess.pq.extractMin();
				Sweep.spliceMergeVertices( tess, v.anEdge, vNext.anEdge );
			}
			Sweep.sweepEvent( tess, v );
		}

		/* Set tess->event for debugging purposes */
		tess.event = tess.dict.min().key.eUp.Org;
		Sweep.debugEvent( tess );
		Sweep.doneEdgeDict( tess );
		Sweep.donePriorityQ( tess );

		if ( !Sweep.removeDegenerateFaces( tess, tess.mesh ) ) return false;
		tess.mesh.check();

		return true;
	}


	function Tesselator() {

		/*** state needed for collecting the input data ***/
		this.mesh = null;		/* stores the input contours, and eventually
							the tessellation itself */

		/*** state needed for projecting onto the sweep plane ***/

		this.normal = [0.0, 0.0, 0.0];	/* user-specified normal (if provided) */
		this.sUnit = [0.0, 0.0, 0.0];	/* unit vector in s-direction (debugging) */
		this.tUnit = [0.0, 0.0, 0.0];	/* unit vector in t-direction (debugging) */

		this.bmin = [0.0, 0.0];
		this.bmax = [0.0, 0.0];

		/*** state needed for the line sweep ***/
		this.windingRule = Tess2.WINDING_ODD;	/* rule for determining polygon interior */

		this.dict = null;		/* edge dictionary for sweep line */
		this.pq = null;		/* priority queue of vertex events */
		this.event = null;		/* current sweep event being processed */

		this.vertexIndexCounter = 0;
		
		this.vertices = [];
		this.vertexIndices = [];
		this.vertexCount = 0;
		this.elements = [];
		this.elementCount = 0;
	};

	Tesselator.prototype = {

		dot_: function(u, v) {
			return (u[0]*v[0] + u[1]*v[1] + u[2]*v[2]);
		},

		normalize_: function( v ) {
			var len = v[0]*v[0] + v[1]*v[1] + v[2]*v[2];
			assert( len > 0.0 );
			len = Math.sqrt( len );
			v[0] /= len;
			v[1] /= len;
			v[2] /= len;
		},

		longAxis_: function( v ) {
			var i = 0;
			if( Math.abs(v[1]) > Math.abs(v[0]) ) { i = 1; }
			if( Math.abs(v[2]) > Math.abs(v[i]) ) { i = 2; }
			return i;
		},

		computeNormal_: function( norm )
		{
			var v, v1, v2;
			var c, tLen2, maxLen2;
			var maxVal = [0,0,0], minVal = [0,0,0], d1 = [0,0,0], d2 = [0,0,0], tNorm = [0,0,0];
			var maxVert = [null,null,null], minVert = [null,null,null];
			var vHead = this.mesh.vHead;
			var i;

			v = vHead.next;
			for( i = 0; i < 3; ++i ) {
				c = v.coords[i];
				minVal[i] = c;
				minVert[i] = v;
				maxVal[i] = c;
				maxVert[i] = v;
			}

			for( v = vHead.next; v !== vHead; v = v.next ) {
				for( i = 0; i < 3; ++i ) {
					c = v.coords[i];
					if( c < minVal[i] ) { minVal[i] = c; minVert[i] = v; }
					if( c > maxVal[i] ) { maxVal[i] = c; maxVert[i] = v; }
				}
			}

			/* Find two vertices separated by at least 1/sqrt(3) of the maximum
			* distance between any two vertices
			*/
			i = 0;
			if( maxVal[1] - minVal[1] > maxVal[0] - minVal[0] ) { i = 1; }
			if( maxVal[2] - minVal[2] > maxVal[i] - minVal[i] ) { i = 2; }
			if( minVal[i] >= maxVal[i] ) {
				/* All vertices are the same -- normal doesn't matter */
				norm[0] = 0; norm[1] = 0; norm[2] = 1;
				return;
			}

			/* Look for a third vertex which forms the triangle with maximum area
			* (Length of normal == twice the triangle area)
			*/
			maxLen2 = 0;
			v1 = minVert[i];
			v2 = maxVert[i];
			d1[0] = v1.coords[0] - v2.coords[0];
			d1[1] = v1.coords[1] - v2.coords[1];
			d1[2] = v1.coords[2] - v2.coords[2];
			for( v = vHead.next; v !== vHead; v = v.next ) {
				d2[0] = v.coords[0] - v2.coords[0];
				d2[1] = v.coords[1] - v2.coords[1];
				d2[2] = v.coords[2] - v2.coords[2];
				tNorm[0] = d1[1]*d2[2] - d1[2]*d2[1];
				tNorm[1] = d1[2]*d2[0] - d1[0]*d2[2];
				tNorm[2] = d1[0]*d2[1] - d1[1]*d2[0];
				tLen2 = tNorm[0]*tNorm[0] + tNorm[1]*tNorm[1] + tNorm[2]*tNorm[2];
				if( tLen2 > maxLen2 ) {
					maxLen2 = tLen2;
					norm[0] = tNorm[0];
					norm[1] = tNorm[1];
					norm[2] = tNorm[2];
				}
			}

			if( maxLen2 <= 0 ) {
				/* All points lie on a single line -- any decent normal will do */
				norm[0] = norm[1] = norm[2] = 0;
				norm[this.longAxis_(d1)] = 1;
			}
		},

		checkOrientation_: function() {
			var area;
			var f, fHead = this.mesh.fHead;
			var v, vHead = this.mesh.vHead;
			var e;

			/* When we compute the normal automatically, we choose the orientation
			* so that the the sum of the signed areas of all contours is non-negative.
			*/
			area = 0;
			for( f = fHead.next; f !== fHead; f = f.next ) {
				e = f.anEdge;
				if( e.winding <= 0 ) continue;
				do {
					area += (e.Org.s - e.Dst.s) * (e.Org.t + e.Dst.t);
					e = e.Lnext;
				} while( e !== f.anEdge );
			}
			if( area < 0 ) {
				/* Reverse the orientation by flipping all the t-coordinates */
				for( v = vHead.next; v !== vHead; v = v.next ) {
					v.t = - v.t;
				}
				this.tUnit[0] = - this.tUnit[0];
				this.tUnit[1] = - this.tUnit[1];
				this.tUnit[2] = - this.tUnit[2];
			}
		},

	/*	#ifdef FOR_TRITE_TEST_PROGRAM
		#include <stdlib.h>
		extern int RandomSweep;
		#define S_UNIT_X	(RandomSweep ? (2*drand48()-1) : 1.0)
		#define S_UNIT_Y	(RandomSweep ? (2*drand48()-1) : 0.0)
		#else
		#if defined(SLANTED_SWEEP) */
		/* The "feature merging" is not intended to be complete.  There are
		* special cases where edges are nearly parallel to the sweep line
		* which are not implemented.  The algorithm should still behave
		* robustly (ie. produce a reasonable tesselation) in the presence
		* of such edges, however it may miss features which could have been
		* merged.  We could minimize this effect by choosing the sweep line
		* direction to be something unusual (ie. not parallel to one of the
		* coordinate axes).
		*/
	/*	#define S_UNIT_X	(TESSreal)0.50941539564955385	// Pre-normalized
		#define S_UNIT_Y	(TESSreal)0.86052074622010633
		#else
		#define S_UNIT_X	(TESSreal)1.0
		#define S_UNIT_Y	(TESSreal)0.0
		#endif
		#endif*/

		/* Determine the polygon normal and project vertices onto the plane
		* of the polygon.
		*/
		projectPolygon_: function() {
			var v, vHead = this.mesh.vHead;
			var norm = [0,0,0];
			var sUnit, tUnit;
			var i, first, computedNormal = false;

			norm[0] = this.normal[0];
			norm[1] = this.normal[1];
			norm[2] = this.normal[2];
			if( norm[0] === 0.0 && norm[1] === 0.0 && norm[2] === 0.0 ) {
				this.computeNormal_( norm );
				computedNormal = true;
			}
			sUnit = this.sUnit;
			tUnit = this.tUnit;
			i = this.longAxis_( norm );

	/*	#if defined(FOR_TRITE_TEST_PROGRAM) || defined(TRUE_PROJECT)
			// Choose the initial sUnit vector to be approximately perpendicular
			// to the normal.
			
			Normalize( norm );

			sUnit[i] = 0;
			sUnit[(i+1)%3] = S_UNIT_X;
			sUnit[(i+2)%3] = S_UNIT_Y;

			// Now make it exactly perpendicular 
			w = Dot( sUnit, norm );
			sUnit[0] -= w * norm[0];
			sUnit[1] -= w * norm[1];
			sUnit[2] -= w * norm[2];
			Normalize( sUnit );

			// Choose tUnit so that (sUnit,tUnit,norm) form a right-handed frame 
			tUnit[0] = norm[1]*sUnit[2] - norm[2]*sUnit[1];
			tUnit[1] = norm[2]*sUnit[0] - norm[0]*sUnit[2];
			tUnit[2] = norm[0]*sUnit[1] - norm[1]*sUnit[0];
			Normalize( tUnit );
		#else*/
			/* Project perpendicular to a coordinate axis -- better numerically */
			sUnit[i] = 0;
			sUnit[(i+1)%3] = 1.0;
			sUnit[(i+2)%3] = 0.0;

			tUnit[i] = 0;
			tUnit[(i+1)%3] = 0.0;
			tUnit[(i+2)%3] = (norm[i] > 0) ? 1.0 : -1.0;
	//	#endif

			/* Project the vertices onto the sweep plane */
			for( v = vHead.next; v !== vHead; v = v.next ) {
				v.s = this.dot_( v.coords, sUnit );
				v.t = this.dot_( v.coords, tUnit );
			}
			if( computedNormal ) {
				this.checkOrientation_();
			}

			/* Compute ST bounds. */
			first = true;
			for( v = vHead.next; v !== vHead; v = v.next ) {
				if (first) {
					this.bmin[0] = this.bmax[0] = v.s;
					this.bmin[1] = this.bmax[1] = v.t;
					first = false;
				} else {
					if (v.s < this.bmin[0]) this.bmin[0] = v.s;
					if (v.s > this.bmax[0]) this.bmax[0] = v.s;
					if (v.t < this.bmin[1]) this.bmin[1] = v.t;
					if (v.t > this.bmax[1]) this.bmax[1] = v.t;
				}
			}
		},

		addWinding_: function(eDst,eSrc) {
			eDst.winding += eSrc.winding;
			eDst.Sym.winding += eSrc.Sym.winding;
		},
		
		/* tessMeshTessellateMonoRegion( face ) tessellates a monotone region
		* (what else would it do??)  The region must consist of a single
		* loop of half-edges (see mesh.h) oriented CCW.  "Monotone" in this
		* case means that any vertical line intersects the interior of the
		* region in a single interval.  
		*
		* Tessellation consists of adding interior edges (actually pairs of
		* half-edges), to split the region into non-overlapping triangles.
		*
		* The basic idea is explained in Preparata and Shamos (which I don''t
		* have handy right now), although their implementation is more
		* complicated than this one.  The are two edge chains, an upper chain
		* and a lower chain.  We process all vertices from both chains in order,
		* from right to left.
		*
		* The algorithm ensures that the following invariant holds after each
		* vertex is processed: the untessellated region consists of two
		* chains, where one chain (say the upper) is a single edge, and
		* the other chain is concave.  The left vertex of the single edge
		* is always to the left of all vertices in the concave chain.
		*
		* Each step consists of adding the rightmost unprocessed vertex to one
		* of the two chains, and forming a fan of triangles from the rightmost
		* of two chain endpoints.  Determining whether we can add each triangle
		* to the fan is a simple orientation test.  By making the fan as large
		* as possible, we restore the invariant (check it yourself).
		*/
	//	int tessMeshTessellateMonoRegion( TESSmesh *mesh, TESSface *face )
		tessellateMonoRegion_: function( mesh, face ) {
			var up, lo;

			/* All edges are oriented CCW around the boundary of the region.
			* First, find the half-edge whose origin vertex is rightmost.
			* Since the sweep goes from left to right, face->anEdge should
			* be close to the edge we want.
			*/
			up = face.anEdge;
			assert( up.Lnext !== up && up.Lnext.Lnext !== up );

			for( ; Geom.vertLeq( up.Dst, up.Org ); up = up.Lprev )
				;
			for( ; Geom.vertLeq( up.Org, up.Dst ); up = up.Lnext )
				;
			lo = up.Lprev;

			while( up.Lnext !== lo ) {
				if( Geom.vertLeq( up.Dst, lo.Org )) {
					/* up->Dst is on the left.  It is safe to form triangles from lo->Org.
					* The EdgeGoesLeft test guarantees progress even when some triangles
					* are CW, given that the upper and lower chains are truly monotone.
					*/
					while( lo.Lnext !== up && (Geom.edgeGoesLeft( lo.Lnext )
						|| Geom.edgeSign( lo.Org, lo.Dst, lo.Lnext.Dst ) <= 0.0 )) {
							var tempHalfEdge = mesh.connect( lo.Lnext, lo );
							//if (tempHalfEdge == NULL) return 0;
							lo = tempHalfEdge.Sym;
					}
					lo = lo.Lprev;
				} else {
					/* lo->Org is on the left.  We can make CCW triangles from up->Dst. */
					while( lo.Lnext != up && (Geom.edgeGoesRight( up.Lprev )
						|| Geom.edgeSign( up.Dst, up.Org, up.Lprev.Org ) >= 0.0 )) {
							var tempHalfEdge = mesh.connect( up, up.Lprev );
							//if (tempHalfEdge == NULL) return 0;
							up = tempHalfEdge.Sym;
					}
					up = up.Lnext;
				}
			}

			/* Now lo->Org == up->Dst == the leftmost vertex.  The remaining region
			* can be tessellated in a fan from this leftmost vertex.
			*/
			assert( lo.Lnext !== up );
			while( lo.Lnext.Lnext !== up ) {
				var tempHalfEdge = mesh.connect( lo.Lnext, lo );
				//if (tempHalfEdge == NULL) return 0;
				lo = tempHalfEdge.Sym;
			}

			return true;
		},


		/* tessMeshTessellateInterior( mesh ) tessellates each region of
		* the mesh which is marked "inside" the polygon.  Each such region
		* must be monotone.
		*/
		//int tessMeshTessellateInterior( TESSmesh *mesh )
		tessellateInterior_: function( mesh ) {
			var f, next;

			/*LINTED*/
			for( f = mesh.fHead.next; f !== mesh.fHead; f = next ) {
				/* Make sure we don''t try to tessellate the new triangles. */
				next = f.next;
				if( f.inside ) {
					if ( !this.tessellateMonoRegion_( mesh, f ) ) return false;
				}
			}

			return true;
		},


		/* tessMeshDiscardExterior( mesh ) zaps (ie. sets to NULL) all faces
		* which are not marked "inside" the polygon.  Since further mesh operations
		* on NULL faces are not allowed, the main purpose is to clean up the
		* mesh so that exterior loops are not represented in the data structure.
		*/
		//void tessMeshDiscardExterior( TESSmesh *mesh )
		discardExterior_: function( mesh ) {
			var f, next;

			/*LINTED*/
			for( f = mesh.fHead.next; f !== mesh.fHead; f = next ) {
				/* Since f will be destroyed, save its next pointer. */
				next = f.next;
				if( ! f.inside ) {
					mesh.zapFace( f );
				}
			}
		},

		/* tessMeshSetWindingNumber( mesh, value, keepOnlyBoundary ) resets the
		* winding numbers on all edges so that regions marked "inside" the
		* polygon have a winding number of "value", and regions outside
		* have a winding number of 0.
		*
		* If keepOnlyBoundary is TRUE, it also deletes all edges which do not
		* separate an interior region from an exterior one.
		*/
	//	int tessMeshSetWindingNumber( TESSmesh *mesh, int value, int keepOnlyBoundary )
		setWindingNumber_: function( mesh, value, keepOnlyBoundary ) {
			var e, eNext;

			for( e = mesh.eHead.next; e !== mesh.eHead; e = eNext ) {
				eNext = e.next;
				if( e.Rface.inside !== e.Lface.inside ) {

					/* This is a boundary edge (one side is interior, one is exterior). */
					e.winding = (e.Lface.inside) ? value : -value;
				} else {

					/* Both regions are interior, or both are exterior. */
					if( ! keepOnlyBoundary ) {
						e.winding = 0;
					} else {
						mesh.delete( e );
					}
				}
			}
		},

		getNeighbourFace_: function(edge)
		{
			if (!edge.Rface)
				return -1;
			if (!edge.Rface.inside)
				return -1;
			return edge.Rface.n;
		},

		outputPolymesh_: function( mesh, elementType, polySize, vertexSize ) {
			var v;
			var f;
			var edge;
			var maxFaceCount = 0;
			var maxVertexCount = 0;
			var faceVerts, i;
			var elements = 0;
			var vert;

			// Assume that the input data is triangles now.
			// Try to merge as many polygons as possible
			if (polySize > 3)
			{
				mesh.mergeConvexFaces( polySize );
			}

			// Mark unused
			for ( v = mesh.vHead.next; v !== mesh.vHead; v = v.next )
				v.n = -1;

			// Create unique IDs for all vertices and faces.
			for ( f = mesh.fHead.next; f != mesh.fHead; f = f.next )
			{
				f.n = -1;
				if( !f.inside ) continue;

				edge = f.anEdge;
				faceVerts = 0;
				do
				{
					v = edge.Org;
					if ( v.n === -1 )
					{
						v.n = maxVertexCount;
						maxVertexCount++;
					}
					faceVerts++;
					edge = edge.Lnext;
				}
				while (edge !== f.anEdge);
				
				assert( faceVerts <= polySize );

				f.n = maxFaceCount;
				++maxFaceCount;
			}

			this.elementCount = maxFaceCount;
			if (elementType == Tess2.CONNECTED_POLYGONS)
				maxFaceCount *= 2;
	/*		tess.elements = (TESSindex*)tess->alloc.memalloc( tess->alloc.userData,
															  sizeof(TESSindex) * maxFaceCount * polySize );
			if (!tess->elements)
			{
				tess->outOfMemory = 1;
				return;
			}*/
			this.elements = [];
			this.elements.length = maxFaceCount * polySize;
			
			this.vertexCount = maxVertexCount;
	/*		tess->vertices = (TESSreal*)tess->alloc.memalloc( tess->alloc.userData,
															 sizeof(TESSreal) * tess->vertexCount * vertexSize );
			if (!tess->vertices)
			{
				tess->outOfMemory = 1;
				return;
			}*/
			this.vertices = [];
			this.vertices.length = maxVertexCount * vertexSize;

	/*		tess->vertexIndices = (TESSindex*)tess->alloc.memalloc( tess->alloc.userData,
																    sizeof(TESSindex) * tess->vertexCount );
			if (!tess->vertexIndices)
			{
				tess->outOfMemory = 1;
				return;
			}*/
			this.vertexIndices = [];
			this.vertexIndices.length = maxVertexCount;

			
			// Output vertices.
			for ( v = mesh.vHead.next; v !== mesh.vHead; v = v.next )
			{
				if ( v.n != -1 )
				{
					// Store coordinate
					var idx = v.n * vertexSize;
					this.vertices[idx+0] = v.coords[0];
					this.vertices[idx+1] = v.coords[1];
					if ( vertexSize > 2 )
						this.vertices[idx+2] = v.coords[2];
					// Store vertex index.
					this.vertexIndices[v.n] = v.idx;
				}
			}

			// Output indices.
			var nel = 0;
			for ( f = mesh.fHead.next; f !== mesh.fHead; f = f.next )
			{
				if ( !f.inside ) continue;
				
				// Store polygon
				edge = f.anEdge;
				faceVerts = 0;
				do
				{
					v = edge.Org;
					this.elements[nel++] = v.n;
					faceVerts++;
					edge = edge.Lnext;
				}
				while (edge !== f.anEdge);
				// Fill unused.
				for (i = faceVerts; i < polySize; ++i)
					this.elements[nel++] = -1;

				// Store polygon connectivity
				if ( elementType == Tess2.CONNECTED_POLYGONS )
				{
					edge = f.anEdge;
					do
					{
						this.elements[nel++] = this.getNeighbourFace_( edge );
						edge = edge.Lnext;
					}
					while (edge !== f.anEdge);
					// Fill unused.
					for (i = faceVerts; i < polySize; ++i)
						this.elements[nel++] = -1;
				}
			}
		},

	//	void OutputContours( TESStesselator *tess, TESSmesh *mesh, int vertexSize )
		outputContours_: function( mesh, vertexSize ) {
			var f;
			var edge;
			var start;
			var verts;
			var elements;
			var vertInds;
			var startVert = 0;
			var vertCount = 0;

			this.vertexCount = 0;
			this.elementCount = 0;

			for ( f = mesh.fHead.next; f !== mesh.fHead; f = f.next )
			{
				if ( !f.inside ) continue;

				start = edge = f.anEdge;
				do
				{
					this.vertexCount++;
					edge = edge.Lnext;
				}
				while ( edge !== start );

				this.elementCount++;
			}

	/*		tess->elements = (TESSindex*)tess->alloc.memalloc( tess->alloc.userData,
															  sizeof(TESSindex) * tess->elementCount * 2 );
			if (!tess->elements)
			{
				tess->outOfMemory = 1;
				return;
			}*/
			this.elements = [];
			this.elements.length = this.elementCount * 2;
			
	/*		tess->vertices = (TESSreal*)tess->alloc.memalloc( tess->alloc.userData,
															  sizeof(TESSreal) * tess->vertexCount * vertexSize );
			if (!tess->vertices)
			{
				tess->outOfMemory = 1;
				return;
			}*/
			this.vertices = [];
			this.vertices.length = this.vertexCount * vertexSize;

	/*		tess->vertexIndices = (TESSindex*)tess->alloc.memalloc( tess->alloc.userData,
																    sizeof(TESSindex) * tess->vertexCount );
			if (!tess->vertexIndices)
			{
				tess->outOfMemory = 1;
				return;
			}*/
			this.vertexIndices = [];
			this.vertexIndices.length = this.vertexCount;

			var nv = 0;
			var nvi = 0;
			var nel = 0;
			startVert = 0;

			for ( f = mesh.fHead.next; f !== mesh.fHead; f = f.next )
			{
				if ( !f.inside ) continue;

				vertCount = 0;
				start = edge = f.anEdge;
				do
				{
					this.vertices[nv++] = edge.Org.coords[0];
					this.vertices[nv++] = edge.Org.coords[1];
					if ( vertexSize > 2 )
						this.vertices[nv++] = edge.Org.coords[2];
					this.vertexIndices[nvi++] = edge.Org.idx;
					vertCount++;
					edge = edge.Lnext;
				}
				while ( edge !== start );

				this.elements[nel++] = startVert;
				this.elements[nel++] = vertCount;

				startVert += vertCount;
			}
		},

		addContour: function( size, vertices )
		{
			var e;
			var i;

			if ( this.mesh === null )
			  	this.mesh = new TESSmesh();
	/*	 	if ( tess->mesh == NULL ) {
				tess->outOfMemory = 1;
				return;
			}*/

			if ( size < 2 )
				size = 2;
			if ( size > 3 )
				size = 3;

			e = null;

			for( i = 0; i < vertices.length; i += size )
			{
				if( e == null ) {
					/* Make a self-loop (one vertex, one edge). */
					e = this.mesh.makeEdge();
	/*				if ( e == NULL ) {
						tess->outOfMemory = 1;
						return;
					}*/
					this.mesh.splice( e, e.Sym );
				} else {
					/* Create a new vertex and edge which immediately follow e
					* in the ordering around the left face.
					*/
					this.mesh.splitEdge( e );
					e = e.Lnext;
				}

				/* The new vertex is now e->Org. */
				e.Org.coords[0] = vertices[i+0];
				e.Org.coords[1] = vertices[i+1];
				if ( size > 2 )
					e.Org.coords[2] = vertices[i+2];
				else
					e.Org.coords[2] = 0.0;
				/* Store the insertion number so that the vertex can be later recognized. */
				e.Org.idx = this.vertexIndexCounter++;

				/* The winding of an edge says how the winding number changes as we
				* cross from the edge''s right face to its left face.  We add the
				* vertices in such an order that a CCW contour will add +1 to
				* the winding number of the region inside the contour.
				*/
				e.winding = 1;
				e.Sym.winding = -1;
			}
		},

	//	int tessTesselate( TESStesselator *tess, int windingRule, int elementType, int polySize, int vertexSize, const TESSreal* normal )
		tesselate: function( windingRule, elementType, polySize, vertexSize, normal ) {
			this.vertices = [];
			this.elements = [];
			this.vertexIndices = [];

			this.vertexIndexCounter = 0;
			
			if (normal)
			{
				this.normal[0] = normal[0];
				this.normal[1] = normal[1];
				this.normal[2] = normal[2];
			}

			this.windingRule = windingRule;

			if (vertexSize < 2)
				vertexSize = 2;
			if (vertexSize > 3)
				vertexSize = 3;

	/*		if (setjmp(tess->env) != 0) { 
				// come back here if out of memory
				return 0;
			}*/

			if (!this.mesh)
			{
				return false;
			}

			/* Determine the polygon normal and project vertices onto the plane
			* of the polygon.
			*/
			this.projectPolygon_();

			/* tessComputeInterior( tess ) computes the planar arrangement specified
			* by the given contours, and further subdivides this arrangement
			* into regions.  Each region is marked "inside" if it belongs
			* to the polygon, according to the rule given by tess->windingRule.
			* Each interior region is guaranteed be monotone.
			*/
			Sweep.computeInterior( this );

			var mesh = this.mesh;

			/* If the user wants only the boundary contours, we throw away all edges
			* except those which separate the interior from the exterior.
			* Otherwise we tessellate all the regions marked "inside".
			*/
			if (elementType == Tess2.BOUNDARY_CONTOURS) {
				this.setWindingNumber_( mesh, 1, true );
			} else {
				this.tessellateInterior_( mesh ); 
			}
	//		if (rc == 0) longjmp(tess->env,1);  /* could've used a label */

			mesh.check();

			if (elementType == Tess2.BOUNDARY_CONTOURS) {
				this.outputContours_( mesh, vertexSize );     /* output contours */
			}
			else
			{
				this.outputPolymesh_( mesh, elementType, polySize, vertexSize );     /* output polygons */
			}

//			tess.mesh = null;

			return true;
		}
	};
},{}],"/projects/blackice/node_modules/unlerp/index.js":[function(require,module,exports){
module.exports = function range(min, max, value) {
  return (value - min) / (max - min)
}
},{}],"/projects/blackice/node_modules/xtend/immutable.js":[function(require,module,exports){
module.exports=require("/projects/blackice/node_modules/three-sdf-text/node_modules/xtend/immutable.js")
},{"/projects/blackice/node_modules/three-sdf-text/node_modules/xtend/immutable.js":"/projects/blackice/node_modules/three-sdf-text/node_modules/xtend/immutable.js"}]},{},["./test.js"])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJ0ZXN0LmpzIiwiZm9udHMvRXhvMlNlbWlCb2xkLmpzb24iLCJpbmRleC5qcyIsImxpYi9SaWdTY2VuZS5qcyIsImxpYi9UZXh0UGFzcy5qcyIsImxpYi9hbmltYXRlLWxhYmVscy5qcyIsImxpYi9jcmVhdGUtZm9udC5qcyIsImxpYi9jcmVhdGUtdGV4dC1wYXNzLmpzIiwibGliL2dldC1wb2x5Z29uLmpzIiwibGliL2dldC1zdmcuanMiLCJsaWIvcmVuZGVyZXIuanMiLCJsaWIvc2V0dXAtZWZmZWN0cy5qcyIsImxpYi9zZXR1cC1mbG9vci5qcyIsImxpYi9zZXR1cC13YXRlci5qcyIsImxpYi9zaGFkZXJzL2JsdXIuanMiLCJsaWIvc2hhZGVycy9jcmVhdGUuanMiLCJsaWIvc2hhZGVycy9sZW5zLmpzIiwibGliL3NoYWRlcnMvcGFzcy5qcyIsImxpYi90ZXh0LWRhdGEuanMiLCJsaWIvdGhyZWUtb3JiaXQtY2FtZXJhL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2FzLW51bWJlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnVmZmVyL25vZGVfbW9kdWxlcy9iYXNlNjQtanMvbGliL2I2NC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9idWZmZXIvbm9kZV9tb2R1bGVzL2llZWU3NTQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnVmZmVyL25vZGVfbW9kdWxlcy9pcy1hcnJheS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jYW52YXMtYXBwL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NhbnZhcy1hcHAvbm9kZV9tb2R1bGVzL2FkZC1ldmVudC1saXN0ZW5lci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jYW52YXMtYXBwL25vZGVfbW9kdWxlcy9kZWJvdW5jZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jYW52YXMtYXBwL25vZGVfbW9kdWxlcy9kZWJvdW5jZS9ub2RlX21vZHVsZXMvZGF0ZS1ub3cvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY2FudmFzLWFwcC9ub2RlX21vZHVsZXMvaXMtd2ViZ2wtY29udGV4dC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jYW52YXMtYXBwL25vZGVfbW9kdWxlcy93ZWJnbC1jb250ZXh0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NsYW1wL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2RvbXJlYWR5L3JlYWR5LmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdDQvaWRlbnRpdHkuanMiLCJub2RlX21vZHVsZXMvZ2wtbWF0NC9tdWx0aXBseS5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXQ0L3NjYWxlLmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdDQvdHJhbnNsYXRlLmpzIiwibm9kZV9tb2R1bGVzL2dsLXRleHR1cmUyZC9ub2RlX21vZHVsZXMvbmRhcnJheS1vcHMvbmRhcnJheS1vcHMuanMiLCJub2RlX21vZHVsZXMvZ2wtdGV4dHVyZTJkL25vZGVfbW9kdWxlcy9uZGFycmF5LW9wcy9ub2RlX21vZHVsZXMvY3dpc2UtY29tcGlsZXIvY29tcGlsZXIuanMiLCJub2RlX21vZHVsZXMvZ2wtdGV4dHVyZTJkL25vZGVfbW9kdWxlcy9uZGFycmF5LW9wcy9ub2RlX21vZHVsZXMvY3dpc2UtY29tcGlsZXIvbGliL2NvbXBpbGUuanMiLCJub2RlX21vZHVsZXMvZ2wtdGV4dHVyZTJkL25vZGVfbW9kdWxlcy9uZGFycmF5LW9wcy9ub2RlX21vZHVsZXMvY3dpc2UtY29tcGlsZXIvbGliL3RodW5rLmpzIiwibm9kZV9tb2R1bGVzL2dsLXRleHR1cmUyZC9ub2RlX21vZHVsZXMvbmRhcnJheS1vcHMvbm9kZV9tb2R1bGVzL2N3aXNlLWNvbXBpbGVyL25vZGVfbW9kdWxlcy91bmlxL3VuaXEuanMiLCJub2RlX21vZHVsZXMvZ2wtdGV4dHVyZTJkL25vZGVfbW9kdWxlcy9uZGFycmF5L25kYXJyYXkuanMiLCJub2RlX21vZHVsZXMvZ2wtdGV4dHVyZTJkL25vZGVfbW9kdWxlcy9uZGFycmF5L25vZGVfbW9kdWxlcy9pb3RhLWFycmF5L2lvdGEuanMiLCJub2RlX21vZHVsZXMvZ2wtdGV4dHVyZTJkL25vZGVfbW9kdWxlcy90eXBlZGFycmF5LXBvb2wvbm9kZV9tb2R1bGVzL2JpdC10d2lkZGxlL3R3aWRkbGUuanMiLCJub2RlX21vZHVsZXMvZ2wtdGV4dHVyZTJkL25vZGVfbW9kdWxlcy90eXBlZGFycmF5LXBvb2wvbm9kZV9tb2R1bGVzL2R1cC9kdXAuanMiLCJub2RlX21vZHVsZXMvZ2wtdGV4dHVyZTJkL25vZGVfbW9kdWxlcy90eXBlZGFycmF5LXBvb2wvcG9vbC5qcyIsIm5vZGVfbW9kdWxlcy9nbC10ZXh0dXJlMmQvbm9kZV9tb2R1bGVzL3dlYmdsZXcvbm9kZV9tb2R1bGVzL3dlYWttYXAvd2Vha21hcC5qcyIsIm5vZGVfbW9kdWxlcy9nbC10ZXh0dXJlMmQvbm9kZV9tb2R1bGVzL3dlYmdsZXcvd2ViZ2xldy5qcyIsIm5vZGVfbW9kdWxlcy9nbC10ZXh0dXJlMmQvdGV4dHVyZS5qcyIsIm5vZGVfbW9kdWxlcy9nbC12ZWMzL3NldC5qcyIsIm5vZGVfbW9kdWxlcy9nbHNsaWZ5L2FkYXB0ZXIuanMiLCJub2RlX21vZHVsZXMvZ2xzbGlmeS9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2dsc2xpZnkvbm9kZV9tb2R1bGVzL2dsLXNoYWRlci1jb3JlL2xpYi9jcmVhdGUtYXR0cmlidXRlcy5qcyIsIm5vZGVfbW9kdWxlcy9nbHNsaWZ5L25vZGVfbW9kdWxlcy9nbC1zaGFkZXItY29yZS9saWIvY3JlYXRlLXVuaWZvcm1zLmpzIiwibm9kZV9tb2R1bGVzL2dsc2xpZnkvbm9kZV9tb2R1bGVzL2dsLXNoYWRlci1jb3JlL2xpYi9yZWZsZWN0LmpzIiwibm9kZV9tb2R1bGVzL2dsc2xpZnkvbm9kZV9tb2R1bGVzL2dsLXNoYWRlci1jb3JlL25vZGVfbW9kdWxlcy9kdXAvZHVwLmpzIiwibm9kZV9tb2R1bGVzL2dsc2xpZnkvbm9kZV9tb2R1bGVzL2dsLXNoYWRlci1jb3JlL3NoYWRlci1jb3JlLmpzIiwibm9kZV9tb2R1bGVzL2dsc2xpZnkvc2ltcGxlLWFkYXB0ZXIuanMiLCJub2RlX21vZHVsZXMvaW1nL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2luaGVyaXRzL2luaGVyaXRzX2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvbGVycC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9taXhlcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9ub3JtYWxpemUtcGF0aC1zY2FsZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9ub3JtYWxpemUtcGF0aC1zY2FsZS9ub2RlX21vZHVsZXMvZ2V0Ym91bmRpbmdib3gvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcGFyc2Utc3ZnLXBhdGgvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcGx1Y2tlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9yYWYuanMvcmFmLmpzIiwibm9kZV9tb2R1bGVzL3JhbmRmL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3NpbXBsaWZ5LXBhdGgvZG91Z2xhcy1wZXVja2VyLmpzIiwibm9kZV9tb2R1bGVzL3NpbXBsaWZ5LXBhdGgvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc2ltcGxpZnktcGF0aC9yYWRpYWwtZGlzdGFuY2UuanMiLCJub2RlX21vZHVsZXMvc21vb3Roc3RlcC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zdmctcGF0aC1jb250b3Vycy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zdmctcGF0aC1jb250b3Vycy9ub2RlX21vZHVsZXMvYWJzLXN2Zy1wYXRoL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3N2Zy1wYXRoLWNvbnRvdXJzL25vZGVfbW9kdWxlcy9hZGFwdGl2ZS1iZXppZXItY3VydmUvZnVuY3Rpb24uanMiLCJub2RlX21vZHVsZXMvc3ZnLXBhdGgtY29udG91cnMvbm9kZV9tb2R1bGVzL2FkYXB0aXZlLWJlemllci1jdXJ2ZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zdmctcGF0aC1jb250b3Vycy9ub2RlX21vZHVsZXMvbm9ybWFsaXplLXN2Zy1wYXRoL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3N2Zy1wYXRoLWNvbnRvdXJzL25vZGVfbW9kdWxlcy92ZWMyLWNvcHkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdGhyZWUtZWZmZWN0Y29tcG9zZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdGhyZWUtZWZmZWN0Y29tcG9zZXIvbGliL2NsZWFybWFza3Bhc3MuanMiLCJub2RlX21vZHVsZXMvdGhyZWUtZWZmZWN0Y29tcG9zZXIvbGliL21hc2twYXNzLmpzIiwibm9kZV9tb2R1bGVzL3RocmVlLWVmZmVjdGNvbXBvc2VyL2xpYi9yZW5kZXJwYXNzLmpzIiwibm9kZV9tb2R1bGVzL3RocmVlLWVmZmVjdGNvbXBvc2VyL2xpYi9zaGFkZXJwYXNzLmpzIiwibm9kZV9tb2R1bGVzL3RocmVlLWVmZmVjdGNvbXBvc2VyL25vZGVfbW9kdWxlcy90aHJlZS1jb3B5c2hhZGVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3RocmVlLWdsc2xpZnkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdGhyZWUtZ2xzbGlmeS90eXBlcy5qcyIsIm5vZGVfbW9kdWxlcy90aHJlZS1zZGYtdGV4dC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy90aHJlZS1zZGYtdGV4dC9saWIvcmVuZGVyZXIuanMiLCJub2RlX21vZHVsZXMvdGhyZWUtc2RmLXRleHQvbGliL3RleHR1cmUtd3JhcC5qcyIsIm5vZGVfbW9kdWxlcy90aHJlZS1zZGYtdGV4dC9ub2RlX21vZHVsZXMvYXMtbnVtYmVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3RocmVlLXNkZi10ZXh0L25vZGVfbW9kdWxlcy9nbC1tYXQ0L2NyZWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy90aHJlZS1zZGYtdGV4dC9ub2RlX21vZHVsZXMvZ2wtbWF0NC9tdWx0aXBseS5qcyIsIm5vZGVfbW9kdWxlcy90aHJlZS1zZGYtdGV4dC9ub2RlX21vZHVsZXMvZ2wtbWF0NC9zY2FsZS5qcyIsIm5vZGVfbW9kdWxlcy90aHJlZS1zZGYtdGV4dC9ub2RlX21vZHVsZXMvZ2wtc2hhZGVyLWNvcmUvc2hhZGVyLWNvcmUuanMiLCJub2RlX21vZHVsZXMvdGhyZWUtc2RmLXRleHQvbm9kZV9tb2R1bGVzL2dsLXNwcml0ZS10ZXh0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3RocmVlLXNkZi10ZXh0L25vZGVfbW9kdWxlcy9nbC1zcHJpdGUtdGV4dC9ub2RlX21vZHVsZXMvZm9udHBhdGgtYm1mb250L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3RocmVlLXNkZi10ZXh0L25vZGVfbW9kdWxlcy9nbC1zcHJpdGUtdGV4dC9ub2RlX21vZHVsZXMvZm9udHBhdGgtc2ltcGxlLXJlbmRlcmVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3RocmVlLXNkZi10ZXh0L25vZGVfbW9kdWxlcy9nbC1zcHJpdGUtdGV4dC9ub2RlX21vZHVsZXMvZm9udHBhdGgtc2ltcGxlLXJlbmRlcmVyL25vZGVfbW9kdWxlcy9mb250cGF0aC1yZW5kZXJlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy90aHJlZS1zZGYtdGV4dC9ub2RlX21vZHVsZXMvZ2wtc3ByaXRlLXRleHQvbm9kZV9tb2R1bGVzL2ZvbnRwYXRoLXNpbXBsZS1yZW5kZXJlci9ub2RlX21vZHVsZXMvZm9udHBhdGgtcmVuZGVyZXIvbm9kZV9tb2R1bGVzL2ZvbnRwYXRoLWdseXBoLWl0ZXJhdG9yL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3RocmVlLXNkZi10ZXh0L25vZGVfbW9kdWxlcy9nbC1zcHJpdGUtdGV4dC9ub2RlX21vZHVsZXMvZm9udHBhdGgtc2ltcGxlLXJlbmRlcmVyL25vZGVfbW9kdWxlcy9mb250cGF0aC1yZW5kZXJlci9ub2RlX21vZHVsZXMvZm9udHBhdGgtdXRpbC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy90aHJlZS1zZGYtdGV4dC9ub2RlX21vZHVsZXMvZ2wtc3ByaXRlLXRleHQvbm9kZV9tb2R1bGVzL2ZvbnRwYXRoLXNpbXBsZS1yZW5kZXJlci9ub2RlX21vZHVsZXMvZm9udHBhdGgtcmVuZGVyZXIvbm9kZV9tb2R1bGVzL2ZvbnRwYXRoLXdvcmR3cmFwL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3RocmVlLXNkZi10ZXh0L25vZGVfbW9kdWxlcy9nbC1zcHJpdGUtdGV4dC9ub2RlX21vZHVsZXMvZ2wtc3ByaXRlLWJhdGNoL2NvbW1vbi5qcyIsIm5vZGVfbW9kdWxlcy90aHJlZS1zZGYtdGV4dC9ub2RlX21vZHVsZXMvZ2wtc3ByaXRlLXRleHQvbm9kZV9tb2R1bGVzL2dsLXNwcml0ZS1iYXRjaC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy90aHJlZS1zZGYtdGV4dC9ub2RlX21vZHVsZXMvZ2wtc3ByaXRlLXRleHQvbm9kZV9tb2R1bGVzL2dsLXNwcml0ZS1iYXRjaC9ub2RlX21vZHVsZXMvZ2wtYWxpYXNlZC12YW8vaW5kZXguanMiLCJub2RlX21vZHVsZXMvdGhyZWUtc2RmLXRleHQvbm9kZV9tb2R1bGVzL2dsLXNwcml0ZS10ZXh0L25vZGVfbW9kdWxlcy9nbC1zcHJpdGUtYmF0Y2gvbm9kZV9tb2R1bGVzL2dsLWFsaWFzZWQtdmFvL2xpYi9kby1iaW5kLmpzIiwibm9kZV9tb2R1bGVzL3RocmVlLXNkZi10ZXh0L25vZGVfbW9kdWxlcy9nbC1zcHJpdGUtdGV4dC9ub2RlX21vZHVsZXMvZ2wtc3ByaXRlLWJhdGNoL25vZGVfbW9kdWxlcy9nbC1hbGlhc2VkLXZhby9saWIvdmFvLWVtdWxhdGVkLmpzIiwibm9kZV9tb2R1bGVzL3RocmVlLXNkZi10ZXh0L25vZGVfbW9kdWxlcy9nbC1zcHJpdGUtdGV4dC9ub2RlX21vZHVsZXMvZ2wtc3ByaXRlLWJhdGNoL25vZGVfbW9kdWxlcy9nbC1idWZmZXIvYnVmZmVyLmpzIiwibm9kZV9tb2R1bGVzL3RocmVlLXNkZi10ZXh0L25vZGVfbW9kdWxlcy9nbC1zcHJpdGUtdGV4dC9ub2RlX21vZHVsZXMvZ2wtc3ByaXRlLWJhdGNoL25vZGVfbW9kdWxlcy9nbC1idWZmZXIvbm9kZV9tb2R1bGVzL25kYXJyYXktb3BzL25kYXJyYXktb3BzLmpzIiwibm9kZV9tb2R1bGVzL3RocmVlLXNkZi10ZXh0L25vZGVfbW9kdWxlcy9nbC1zcHJpdGUtdGV4dC9ub2RlX21vZHVsZXMvZ2wtc3ByaXRlLWJhdGNoL25vZGVfbW9kdWxlcy9nbC1idWZmZXIvbm9kZV9tb2R1bGVzL25kYXJyYXkvbmRhcnJheS5qcyIsIm5vZGVfbW9kdWxlcy90aHJlZS1zZGYtdGV4dC9ub2RlX21vZHVsZXMvZ2wtc3ByaXRlLXRleHQvbm9kZV9tb2R1bGVzL2dsLXNwcml0ZS1iYXRjaC9ub2RlX21vZHVsZXMvZ2wtYnVmZmVyL25vZGVfbW9kdWxlcy9uZGFycmF5L25vZGVfbW9kdWxlcy9pb3RhLWFycmF5L2lvdGEuanMiLCJub2RlX21vZHVsZXMvdGhyZWUtc2RmLXRleHQvbm9kZV9tb2R1bGVzL2dsLXNwcml0ZS10ZXh0L25vZGVfbW9kdWxlcy9nbC1zcHJpdGUtYmF0Y2gvbm9kZV9tb2R1bGVzL2dsLWJ1ZmZlci9ub2RlX21vZHVsZXMvdHlwZWRhcnJheS1wb29sL3Bvb2wuanMiLCJub2RlX21vZHVsZXMvdGhyZWUtc2RmLXRleHQvbm9kZV9tb2R1bGVzL2dsLXNwcml0ZS10ZXh0L25vZGVfbW9kdWxlcy9nbC1zcHJpdGUtYmF0Y2gvbm9kZV9tb2R1bGVzL2dsLWJ1ZmZlci9ub2RlX21vZHVsZXMvd2ViZ2xldy9ub2RlX21vZHVsZXMvd2Vhay1tYXAvd2Vhay1tYXAuanMiLCJub2RlX21vZHVsZXMvdGhyZWUtc2RmLXRleHQvbm9kZV9tb2R1bGVzL2dsLXNwcml0ZS10ZXh0L25vZGVfbW9kdWxlcy9nbC1zcHJpdGUtYmF0Y2gvbm9kZV9tb2R1bGVzL2dsLWJ1ZmZlci9ub2RlX21vZHVsZXMvd2ViZ2xldy93ZWJnbGV3LmpzIiwibm9kZV9tb2R1bGVzL3RocmVlLXNkZi10ZXh0L25vZGVfbW9kdWxlcy9nbC1zcHJpdGUtdGV4dC9ub2RlX21vZHVsZXMvZ2wtc3ByaXRlLWJhdGNoL25vZGVfbW9kdWxlcy9nbC13aGl0ZS10ZXh0dXJlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3RocmVlLXNkZi10ZXh0L25vZGVfbW9kdWxlcy9nbC1zcHJpdGUtdGV4dC9ub2RlX21vZHVsZXMvZ2wtc3ByaXRlLWJhdGNoL25vZGVfbW9kdWxlcy9nbC13aGl0ZS10ZXh0dXJlL25vZGVfbW9kdWxlcy9uZGFycmF5L25kYXJyYXkuanMiLCJub2RlX21vZHVsZXMvdGhyZWUtc2RmLXRleHQvbm9kZV9tb2R1bGVzL2dsLXNwcml0ZS10ZXh0L25vZGVfbW9kdWxlcy9nbC1zcHJpdGUtYmF0Y2gvbm9kZV9tb2R1bGVzL21peGVzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3RocmVlLXNkZi10ZXh0L25vZGVfbW9kdWxlcy9nbC1zcHJpdGUtdGV4dC9ub2RlX21vZHVsZXMvZ2wtc3ByaXRlLWJhdGNoL25vZGVfbW9kdWxlcy9udW1iZXItdXRpbC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy90aHJlZS1zZGYtdGV4dC9ub2RlX21vZHVsZXMvZ2wtc3ByaXRlLXRleHQvbm9kZV9tb2R1bGVzL2dsLXNwcml0ZS1iYXRjaC9ub2RlX21vZHVsZXMvcHJlbXVsdGlwbGllZC1yZ2JhL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3RocmVlLXNkZi10ZXh0L25vZGVfbW9kdWxlcy9nbC1zcHJpdGUtdGV4dC9ub2RlX21vZHVsZXMvZ2wtc3ByaXRlLWJhdGNoL3BhY2stcmdiYS1mbG9hdC5qcyIsIm5vZGVfbW9kdWxlcy90aHJlZS1zZGYtdGV4dC9ub2RlX21vZHVsZXMvZ2wtc3ByaXRlLXRleHQvbm9kZV9tb2R1bGVzL2luaGVyaXRzL2luaGVyaXRzX2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvdGhyZWUtc2RmLXRleHQvbm9kZV9tb2R1bGVzL2dsLXNwcml0ZS10ZXh0L25vZGVfbW9kdWxlcy90ZXhjb29yZC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy90aHJlZS1zZGYtdGV4dC9ub2RlX21vZHVsZXMvZ2wtdGV4dHVyZTJkL3RleHR1cmUuanMiLCJub2RlX21vZHVsZXMvdGhyZWUtc2RmLXRleHQvbm9kZV9tb2R1bGVzL3h0ZW5kL2ltbXV0YWJsZS5qcyIsIm5vZGVfbW9kdWxlcy90aHJlZS1zaGFkZXItZnhhYS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy90aHJlZS1zaW1wbGljaWFsLWNvbXBsZXgvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdHJpYW5ndWxhdGUtY29udG91cnMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdHJpYW5ndWxhdGUtY29udG91cnMvbm9kZV9tb2R1bGVzL3Rlc3MyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3RyaWFuZ3VsYXRlLWNvbnRvdXJzL25vZGVfbW9kdWxlcy90ZXNzMi9zcmMvdGVzczIuanMiLCJub2RlX21vZHVsZXMvdW5sZXJwL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3h0ZW5kL2ltbXV0YWJsZS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0hBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3cEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN2NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOVJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5WUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaFBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlpQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeERBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyTUE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RIQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7O0FDQUE7O0FDQUE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDelJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxSkE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxVkE7O0FDQUE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3cUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7O0FDQUE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdERBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaDJHQTtBQUNBO0FBQ0E7O0FDRkEiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwidmFyIGJsYWNraWNlID0gcmVxdWlyZSgnLi8nKVxuXG5yZXF1aXJlKCdkb21yZWFkeScpKGZ1bmN0aW9uKCkge1xuICAgIGRvY3VtZW50LmJvZHkuc3R5bGUubWFyZ2luID0gJzAnXG4gICAgZG9jdW1lbnQuYm9keS5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nXG5cbiAgICAvL3lvdXIgY2FudmFzLi4uXG4gICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpXG4gICAgY2FudmFzLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snXG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChjYW52YXMpXG5cbiAgICB2YXIgYXBwID0gYmxhY2tpY2UoeyBcbiAgICAgICAgY2FudmFzOiBjYW52YXNcbiAgICB9KVxuXG4gICAgYXBwLmxvYWQoZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgIGlmIChlcnIpXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycilcbiAgICAgICAgYXBwLnN0YXJ0KClcbiAgICB9KVxufSkiLCJtb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz17XCJwYWdlc1wiOltcIkV4bzJTZW1pQm9sZC5wbmdcIl0sXCJjaGFyc1wiOlt7XCJpZFwiOjMyLFwieFwiOjAsXCJ5XCI6MCxcIndpZHRoXCI6MCxcImhlaWdodFwiOjAsXCJ4b2Zmc2V0XCI6MCxcInlvZmZzZXRcIjozMyxcInhhZHZhbmNlXCI6NyxcInBhZ2VcIjowLFwiY2hubFwiOjB9LHtcImlkXCI6NDEsXCJ4XCI6MCxcInlcIjowLFwid2lkdGhcIjoyMCxcImhlaWdodFwiOjQxLFwieG9mZnNldFwiOi00LFwieW9mZnNldFwiOjMsXCJ4YWR2YW5jZVwiOjEyLFwicGFnZVwiOjAsXCJjaG5sXCI6MH0se1wiaWRcIjo0MCxcInhcIjoyMCxcInlcIjowLFwid2lkdGhcIjoxOSxcImhlaWdodFwiOjQxLFwieG9mZnNldFwiOi0zLFwieW9mZnNldFwiOjMsXCJ4YWR2YW5jZVwiOjEyLFwicGFnZVwiOjAsXCJjaG5sXCI6MH0se1wiaWRcIjoxMjQsXCJ4XCI6MzksXCJ5XCI6MCxcIndpZHRoXCI6MTMsXCJoZWlnaHRcIjo0MCxcInhvZmZzZXRcIjotMixcInlvZmZzZXRcIjozLFwieGFkdmFuY2VcIjo4LFwicGFnZVwiOjAsXCJjaG5sXCI6MH0se1wiaWRcIjoxMjUsXCJ4XCI6NTIsXCJ5XCI6MCxcIndpZHRoXCI6MTgsXCJoZWlnaHRcIjo0MCxcInhvZmZzZXRcIjotMyxcInlvZmZzZXRcIjo0LFwieGFkdmFuY2VcIjoxMSxcInBhZ2VcIjowLFwiY2hubFwiOjB9LHtcImlkXCI6MTIzLFwieFwiOjcwLFwieVwiOjAsXCJ3aWR0aFwiOjE4LFwiaGVpZ2h0XCI6NDAsXCJ4b2Zmc2V0XCI6LTMsXCJ5b2Zmc2V0XCI6NCxcInhhZHZhbmNlXCI6MTEsXCJwYWdlXCI6MCxcImNobmxcIjowfSx7XCJpZFwiOjM2LFwieFwiOjg4LFwieVwiOjAsXCJ3aWR0aFwiOjI1LFwiaGVpZ2h0XCI6MzksXCJ4b2Zmc2V0XCI6LTMsXCJ5b2Zmc2V0XCI6MyxcInhhZHZhbmNlXCI6MTgsXCJwYWdlXCI6MCxcImNobmxcIjowfSx7XCJpZFwiOjkzLFwieFwiOjExMyxcInlcIjowLFwid2lkdGhcIjoxNyxcImhlaWdodFwiOjM5LFwieG9mZnNldFwiOi0zLFwieW9mZnNldFwiOjQsXCJ4YWR2YW5jZVwiOjExLFwicGFnZVwiOjAsXCJjaG5sXCI6MH0se1wiaWRcIjo5MSxcInhcIjoxMzAsXCJ5XCI6MCxcIndpZHRoXCI6MTcsXCJoZWlnaHRcIjozOSxcInhvZmZzZXRcIjotMixcInlvZmZzZXRcIjo0LFwieGFkdmFuY2VcIjoxMSxcInBhZ2VcIjowLFwiY2hubFwiOjB9LHtcImlkXCI6ODEsXCJ4XCI6MTQ3LFwieVwiOjAsXCJ3aWR0aFwiOjI4LFwiaGVpZ2h0XCI6MzksXCJ4b2Zmc2V0XCI6LTMsXCJ5b2Zmc2V0XCI6NixcInhhZHZhbmNlXCI6MjIsXCJwYWdlXCI6MCxcImNobmxcIjowfSx7XCJpZFwiOjEwNixcInhcIjoxNzUsXCJ5XCI6MCxcIndpZHRoXCI6MTYsXCJoZWlnaHRcIjozOCxcInhvZmZzZXRcIjotNCxcInlvZmZzZXRcIjo2LFwieGFkdmFuY2VcIjo5LFwicGFnZVwiOjAsXCJjaG5sXCI6MH0se1wiaWRcIjo5MixcInhcIjoxOTEsXCJ5XCI6MCxcIndpZHRoXCI6MjYsXCJoZWlnaHRcIjozNCxcInhvZmZzZXRcIjotNCxcInlvZmZzZXRcIjo2LFwieGFkdmFuY2VcIjoxNyxcInBhZ2VcIjowLFwiY2hubFwiOjB9LHtcImlkXCI6NDcsXCJ4XCI6MjE3LFwieVwiOjAsXCJ3aWR0aFwiOjI2LFwiaGVpZ2h0XCI6MzQsXCJ4b2Zmc2V0XCI6LTQsXCJ5b2Zmc2V0XCI6NixcInhhZHZhbmNlXCI6MTcsXCJwYWdlXCI6MCxcImNobmxcIjowfSx7XCJpZFwiOjEwMixcInhcIjoyNDMsXCJ5XCI6MCxcIndpZHRoXCI6MjMsXCJoZWlnaHRcIjozMyxcInhvZmZzZXRcIjotNCxcInlvZmZzZXRcIjo1LFwieGFkdmFuY2VcIjoxMyxcInBhZ2VcIjowLFwiY2hubFwiOjB9LHtcImlkXCI6MzgsXCJ4XCI6MjY2LFwieVwiOjAsXCJ3aWR0aFwiOjMyLFwiaGVpZ2h0XCI6MzIsXCJ4b2Zmc2V0XCI6LTMsXCJ5b2Zmc2V0XCI6NixcInhhZHZhbmNlXCI6MjUsXCJwYWdlXCI6MCxcImNobmxcIjowfSx7XCJpZFwiOjM1LFwieFwiOjI5OCxcInlcIjowLFwid2lkdGhcIjozMCxcImhlaWdodFwiOjMyLFwieG9mZnNldFwiOi0zLFwieW9mZnNldFwiOjYsXCJ4YWR2YW5jZVwiOjIyLFwicGFnZVwiOjAsXCJjaG5sXCI6MH0se1wiaWRcIjozNyxcInhcIjozMjgsXCJ5XCI6MCxcIndpZHRoXCI6MzYsXCJoZWlnaHRcIjozMixcInhvZmZzZXRcIjotMyxcInlvZmZzZXRcIjo2LFwieGFkdmFuY2VcIjoyOSxcInBhZ2VcIjowLFwiY2hubFwiOjB9LHtcImlkXCI6NjMsXCJ4XCI6MzY0LFwieVwiOjAsXCJ3aWR0aFwiOjI0LFwiaGVpZ2h0XCI6MzIsXCJ4b2Zmc2V0XCI6LTMsXCJ5b2Zmc2V0XCI6NixcInhhZHZhbmNlXCI6MTYsXCJwYWdlXCI6MCxcImNobmxcIjowfSx7XCJpZFwiOjMzLFwieFwiOjM4OCxcInlcIjowLFwid2lkdGhcIjoxNCxcImhlaWdodFwiOjMyLFwieG9mZnNldFwiOi0yLFwieW9mZnNldFwiOjYsXCJ4YWR2YW5jZVwiOjksXCJwYWdlXCI6MCxcImNobmxcIjowfSx7XCJpZFwiOjQ4LFwieFwiOjQwMixcInlcIjowLFwid2lkdGhcIjoyNixcImhlaWdodFwiOjMyLFwieG9mZnNldFwiOi0zLFwieW9mZnNldFwiOjYsXCJ4YWR2YW5jZVwiOjIwLFwicGFnZVwiOjAsXCJjaG5sXCI6MH0se1wiaWRcIjo1NyxcInhcIjo0MjgsXCJ5XCI6MCxcIndpZHRoXCI6MjUsXCJoZWlnaHRcIjozMixcInhvZmZzZXRcIjotMyxcInlvZmZzZXRcIjo2LFwieGFkdmFuY2VcIjoxOSxcInBhZ2VcIjowLFwiY2hubFwiOjB9LHtcImlkXCI6NTYsXCJ4XCI6NDUzLFwieVwiOjAsXCJ3aWR0aFwiOjI2LFwiaGVpZ2h0XCI6MzIsXCJ4b2Zmc2V0XCI6LTMsXCJ5b2Zmc2V0XCI6NixcInhhZHZhbmNlXCI6MjAsXCJwYWdlXCI6MCxcImNobmxcIjowfSx7XCJpZFwiOjU1LFwieFwiOjQ3OSxcInlcIjowLFwid2lkdGhcIjoyNCxcImhlaWdodFwiOjMyLFwieG9mZnNldFwiOi0zLFwieW9mZnNldFwiOjYsXCJ4YWR2YW5jZVwiOjE3LFwicGFnZVwiOjAsXCJjaG5sXCI6MH0se1wiaWRcIjo1NCxcInhcIjowLFwieVwiOjQxLFwid2lkdGhcIjoyNixcImhlaWdodFwiOjMyLFwieG9mZnNldFwiOi0zLFwieW9mZnNldFwiOjYsXCJ4YWR2YW5jZVwiOjE5LFwicGFnZVwiOjAsXCJjaG5sXCI6MH0se1wiaWRcIjo1MyxcInhcIjoyNixcInlcIjo0MSxcIndpZHRoXCI6MjQsXCJoZWlnaHRcIjozMixcInhvZmZzZXRcIjotMyxcInlvZmZzZXRcIjo2LFwieGFkdmFuY2VcIjoxNyxcInBhZ2VcIjowLFwiY2hubFwiOjB9LHtcImlkXCI6NTIsXCJ4XCI6NTAsXCJ5XCI6NDEsXCJ3aWR0aFwiOjI3LFwiaGVpZ2h0XCI6MzIsXCJ4b2Zmc2V0XCI6LTMsXCJ5b2Zmc2V0XCI6NixcInhhZHZhbmNlXCI6MjAsXCJwYWdlXCI6MCxcImNobmxcIjowfSx7XCJpZFwiOjUxLFwieFwiOjc3LFwieVwiOjQxLFwid2lkdGhcIjoyNSxcImhlaWdodFwiOjMyLFwieG9mZnNldFwiOi0zLFwieW9mZnNldFwiOjYsXCJ4YWR2YW5jZVwiOjE4LFwicGFnZVwiOjAsXCJjaG5sXCI6MH0se1wiaWRcIjo1MCxcInhcIjoxMDIsXCJ5XCI6NDEsXCJ3aWR0aFwiOjI1LFwiaGVpZ2h0XCI6MzIsXCJ4b2Zmc2V0XCI6LTMsXCJ5b2Zmc2V0XCI6NixcInhhZHZhbmNlXCI6MTgsXCJwYWdlXCI6MCxcImNobmxcIjowfSx7XCJpZFwiOjQ5LFwieFwiOjEyNyxcInlcIjo0MSxcIndpZHRoXCI6MTksXCJoZWlnaHRcIjozMixcInhvZmZzZXRcIjotNCxcInlvZmZzZXRcIjo2LFwieGFkdmFuY2VcIjoxMyxcInBhZ2VcIjowLFwiY2hubFwiOjB9LHtcImlkXCI6MTIxLFwieFwiOjE0NixcInlcIjo0MSxcIndpZHRoXCI6MjcsXCJoZWlnaHRcIjozMixcInhvZmZzZXRcIjotNCxcInlvZmZzZXRcIjoxMixcInhhZHZhbmNlXCI6MTcsXCJwYWdlXCI6MCxcImNobmxcIjowfSx7XCJpZFwiOjExMyxcInhcIjoxNzMsXCJ5XCI6NDEsXCJ3aWR0aFwiOjI1LFwiaGVpZ2h0XCI6MzIsXCJ4b2Zmc2V0XCI6LTMsXCJ5b2Zmc2V0XCI6MTIsXCJ4YWR2YW5jZVwiOjE5LFwicGFnZVwiOjAsXCJjaG5sXCI6MH0se1wiaWRcIjoxMTIsXCJ4XCI6MTk4LFwieVwiOjQxLFwid2lkdGhcIjoyNSxcImhlaWdodFwiOjMyLFwieG9mZnNldFwiOi0yLFwieW9mZnNldFwiOjEyLFwieGFkdmFuY2VcIjoxOSxcInBhZ2VcIjowLFwiY2hubFwiOjB9LHtcImlkXCI6MTA4LFwieFwiOjIyMyxcInlcIjo0MSxcIndpZHRoXCI6MTcsXCJoZWlnaHRcIjozMixcInhvZmZzZXRcIjotMixcInlvZmZzZXRcIjo2LFwieGFkdmFuY2VcIjoxMCxcInBhZ2VcIjowLFwiY2hubFwiOjB9LHtcImlkXCI6MTA3LFwieFwiOjI0MCxcInlcIjo0MSxcIndpZHRoXCI6MjQsXCJoZWlnaHRcIjozMixcInhvZmZzZXRcIjotMixcInlvZmZzZXRcIjo2LFwieGFkdmFuY2VcIjoxNyxcInBhZ2VcIjowLFwiY2hubFwiOjB9LHtcImlkXCI6MTA1LFwieFwiOjI2NCxcInlcIjo0MSxcIndpZHRoXCI6MTQsXCJoZWlnaHRcIjozMixcInhvZmZzZXRcIjotMixcInlvZmZzZXRcIjo2LFwieGFkdmFuY2VcIjo4LFwicGFnZVwiOjAsXCJjaG5sXCI6MH0se1wiaWRcIjoxMDQsXCJ4XCI6Mjc4LFwieVwiOjQxLFwid2lkdGhcIjoyNCxcImhlaWdodFwiOjMyLFwieG9mZnNldFwiOi0yLFwieW9mZnNldFwiOjYsXCJ4YWR2YW5jZVwiOjE5LFwicGFnZVwiOjAsXCJjaG5sXCI6MH0se1wiaWRcIjoxMDMsXCJ4XCI6MzAyLFwieVwiOjQxLFwid2lkdGhcIjoyNyxcImhlaWdodFwiOjMyLFwieG9mZnNldFwiOi00LFwieW9mZnNldFwiOjEyLFwieGFkdmFuY2VcIjoxOCxcInBhZ2VcIjowLFwiY2hubFwiOjB9LHtcImlkXCI6MTAwLFwieFwiOjMyOSxcInlcIjo0MSxcIndpZHRoXCI6MjUsXCJoZWlnaHRcIjozMixcInhvZmZzZXRcIjotMyxcInlvZmZzZXRcIjo2LFwieGFkdmFuY2VcIjoxOSxcInBhZ2VcIjowLFwiY2hubFwiOjB9LHtcImlkXCI6OTgsXCJ4XCI6MzU0LFwieVwiOjQxLFwid2lkdGhcIjoyNSxcImhlaWdodFwiOjMyLFwieG9mZnNldFwiOi0yLFwieW9mZnNldFwiOjYsXCJ4YWR2YW5jZVwiOjE5LFwicGFnZVwiOjAsXCJjaG5sXCI6MH0se1wiaWRcIjo5MCxcInhcIjozNzksXCJ5XCI6NDEsXCJ3aWR0aFwiOjI1LFwiaGVpZ2h0XCI6MzIsXCJ4b2Zmc2V0XCI6LTMsXCJ5b2Zmc2V0XCI6NixcInhhZHZhbmNlXCI6MTgsXCJwYWdlXCI6MCxcImNobmxcIjowfSx7XCJpZFwiOjg5LFwieFwiOjQwNCxcInlcIjo0MSxcIndpZHRoXCI6MjgsXCJoZWlnaHRcIjozMixcInhvZmZzZXRcIjotNCxcInlvZmZzZXRcIjo2LFwieGFkdmFuY2VcIjoxOSxcInBhZ2VcIjowLFwiY2hubFwiOjB9LHtcImlkXCI6ODgsXCJ4XCI6NDMyLFwieVwiOjQxLFwid2lkdGhcIjoyOSxcImhlaWdodFwiOjMyLFwieG9mZnNldFwiOi00LFwieW9mZnNldFwiOjYsXCJ4YWR2YW5jZVwiOjIwLFwicGFnZVwiOjAsXCJjaG5sXCI6MH0se1wiaWRcIjo4NyxcInhcIjo0NjEsXCJ5XCI6NDEsXCJ3aWR0aFwiOjM5LFwiaGVpZ2h0XCI6MzIsXCJ4b2Zmc2V0XCI6LTQsXCJ5b2Zmc2V0XCI6NixcInhhZHZhbmNlXCI6MzEsXCJwYWdlXCI6MCxcImNobmxcIjowfSx7XCJpZFwiOjg2LFwieFwiOjAsXCJ5XCI6NzMsXCJ3aWR0aFwiOjI5LFwiaGVpZ2h0XCI6MzIsXCJ4b2Zmc2V0XCI6LTQsXCJ5b2Zmc2V0XCI6NixcInhhZHZhbmNlXCI6MjAsXCJwYWdlXCI6MCxcImNobmxcIjowfSx7XCJpZFwiOjg1LFwieFwiOjI5LFwieVwiOjczLFwid2lkdGhcIjoyNyxcImhlaWdodFwiOjMyLFwieG9mZnNldFwiOi0yLFwieW9mZnNldFwiOjYsXCJ4YWR2YW5jZVwiOjIxLFwicGFnZVwiOjAsXCJjaG5sXCI6MH0se1wiaWRcIjo4NCxcInhcIjo1NixcInlcIjo3MyxcIndpZHRoXCI6MjgsXCJoZWlnaHRcIjozMixcInhvZmZzZXRcIjotNCxcInlvZmZzZXRcIjo2LFwieGFkdmFuY2VcIjoxOSxcInBhZ2VcIjowLFwiY2hubFwiOjB9LHtcImlkXCI6ODMsXCJ4XCI6ODQsXCJ5XCI6NzMsXCJ3aWR0aFwiOjI1LFwiaGVpZ2h0XCI6MzIsXCJ4b2Zmc2V0XCI6LTMsXCJ5b2Zmc2V0XCI6NixcInhhZHZhbmNlXCI6MTgsXCJwYWdlXCI6MCxcImNobmxcIjowfSx7XCJpZFwiOjgyLFwieFwiOjEwOSxcInlcIjo3MyxcIndpZHRoXCI6MjYsXCJoZWlnaHRcIjozMixcInhvZmZzZXRcIjotMixcInlvZmZzZXRcIjo2LFwieGFkdmFuY2VcIjoyMCxcInBhZ2VcIjowLFwiY2hubFwiOjB9LHtcImlkXCI6ODAsXCJ4XCI6MTM1LFwieVwiOjczLFwid2lkdGhcIjoyNixcImhlaWdodFwiOjMyLFwieG9mZnNldFwiOi0yLFwieW9mZnNldFwiOjYsXCJ4YWR2YW5jZVwiOjE5LFwicGFnZVwiOjAsXCJjaG5sXCI6MH0se1wiaWRcIjo3OSxcInhcIjoxNjEsXCJ5XCI6NzMsXCJ3aWR0aFwiOjI4LFwiaGVpZ2h0XCI6MzIsXCJ4b2Zmc2V0XCI6LTMsXCJ5b2Zmc2V0XCI6NixcInhhZHZhbmNlXCI6MjIsXCJwYWdlXCI6MCxcImNobmxcIjowfSx7XCJpZFwiOjc4LFwieFwiOjE4OSxcInlcIjo3MyxcIndpZHRoXCI6MjgsXCJoZWlnaHRcIjozMixcInhvZmZzZXRcIjotMixcInlvZmZzZXRcIjo2LFwieGFkdmFuY2VcIjoyMyxcInBhZ2VcIjowLFwiY2hubFwiOjB9LHtcImlkXCI6NzcsXCJ4XCI6MjE3LFwieVwiOjczLFwid2lkdGhcIjozNCxcImhlaWdodFwiOjMyLFwieG9mZnNldFwiOi0yLFwieW9mZnNldFwiOjYsXCJ4YWR2YW5jZVwiOjI5LFwicGFnZVwiOjAsXCJjaG5sXCI6MH0se1wiaWRcIjo3NixcInhcIjoyNTEsXCJ5XCI6NzMsXCJ3aWR0aFwiOjI0LFwiaGVpZ2h0XCI6MzIsXCJ4b2Zmc2V0XCI6LTIsXCJ5b2Zmc2V0XCI6NixcInhhZHZhbmNlXCI6MTcsXCJwYWdlXCI6MCxcImNobmxcIjowfSx7XCJpZFwiOjc1LFwieFwiOjI3NSxcInlcIjo3MyxcIndpZHRoXCI6MjcsXCJoZWlnaHRcIjozMixcInhvZmZzZXRcIjotMixcInlvZmZzZXRcIjo2LFwieGFkdmFuY2VcIjoyMCxcInBhZ2VcIjowLFwiY2hubFwiOjB9LHtcImlkXCI6NzQsXCJ4XCI6MzAyLFwieVwiOjczLFwid2lkdGhcIjoxOCxcImhlaWdodFwiOjMyLFwieG9mZnNldFwiOi00LFwieW9mZnNldFwiOjYsXCJ4YWR2YW5jZVwiOjExLFwicGFnZVwiOjAsXCJjaG5sXCI6MH0se1wiaWRcIjo3MyxcInhcIjozMjAsXCJ5XCI6NzMsXCJ3aWR0aFwiOjE0LFwiaGVpZ2h0XCI6MzIsXCJ4b2Zmc2V0XCI6LTIsXCJ5b2Zmc2V0XCI6NixcInhhZHZhbmNlXCI6OSxcInBhZ2VcIjowLFwiY2hubFwiOjB9LHtcImlkXCI6NzIsXCJ4XCI6MzM0LFwieVwiOjczLFwid2lkdGhcIjoyNyxcImhlaWdodFwiOjMyLFwieG9mZnNldFwiOi0yLFwieW9mZnNldFwiOjYsXCJ4YWR2YW5jZVwiOjIyLFwicGFnZVwiOjAsXCJjaG5sXCI6MH0se1wiaWRcIjo3MSxcInhcIjozNjEsXCJ5XCI6NzMsXCJ3aWR0aFwiOjI3LFwiaGVpZ2h0XCI6MzIsXCJ4b2Zmc2V0XCI6LTMsXCJ5b2Zmc2V0XCI6NixcInhhZHZhbmNlXCI6MjAsXCJwYWdlXCI6MCxcImNobmxcIjowfSx7XCJpZFwiOjcwLFwieFwiOjM4OCxcInlcIjo3MyxcIndpZHRoXCI6MjQsXCJoZWlnaHRcIjozMixcInhvZmZzZXRcIjotMixcInlvZmZzZXRcIjo2LFwieGFkdmFuY2VcIjoxNyxcInBhZ2VcIjowLFwiY2hubFwiOjB9LHtcImlkXCI6NjksXCJ4XCI6NDEyLFwieVwiOjczLFwid2lkdGhcIjoyNCxcImhlaWdodFwiOjMyLFwieG9mZnNldFwiOi0yLFwieW9mZnNldFwiOjYsXCJ4YWR2YW5jZVwiOjE4LFwicGFnZVwiOjAsXCJjaG5sXCI6MH0se1wiaWRcIjo2OCxcInhcIjo0MzYsXCJ5XCI6NzMsXCJ3aWR0aFwiOjI3LFwiaGVpZ2h0XCI6MzIsXCJ4b2Zmc2V0XCI6LTIsXCJ5b2Zmc2V0XCI6NixcInhhZHZhbmNlXCI6MjEsXCJwYWdlXCI6MCxcImNobmxcIjowfSx7XCJpZFwiOjY3LFwieFwiOjQ2MyxcInlcIjo3MyxcIndpZHRoXCI6MjYsXCJoZWlnaHRcIjozMixcInhvZmZzZXRcIjotMyxcInlvZmZzZXRcIjo2LFwieGFkdmFuY2VcIjoxOSxcInBhZ2VcIjowLFwiY2hubFwiOjB9LHtcImlkXCI6NjYsXCJ4XCI6MCxcInlcIjoxMDUsXCJ3aWR0aFwiOjI2LFwiaGVpZ2h0XCI6MzIsXCJ4b2Zmc2V0XCI6LTIsXCJ5b2Zmc2V0XCI6NixcInhhZHZhbmNlXCI6MjAsXCJwYWdlXCI6MCxcImNobmxcIjowfSx7XCJpZFwiOjY1LFwieFwiOjI2LFwieVwiOjEwNSxcIndpZHRoXCI6MzAsXCJoZWlnaHRcIjozMixcInhvZmZzZXRcIjotNCxcInlvZmZzZXRcIjo2LFwieGFkdmFuY2VcIjoyMCxcInBhZ2VcIjowLFwiY2hubFwiOjB9LHtcImlkXCI6NjQsXCJ4XCI6NTYsXCJ5XCI6MTA1LFwid2lkdGhcIjoyOSxcImhlaWdodFwiOjMxLFwieG9mZnNldFwiOi0yLFwieW9mZnNldFwiOjksXCJ4YWR2YW5jZVwiOjI0LFwicGFnZVwiOjAsXCJjaG5sXCI6MH0se1wiaWRcIjoxMTYsXCJ4XCI6ODUsXCJ5XCI6MTA1LFwid2lkdGhcIjoyMixcImhlaWdodFwiOjMwLFwieG9mZnNldFwiOi00LFwieW9mZnNldFwiOjgsXCJ4YWR2YW5jZVwiOjEzLFwicGFnZVwiOjAsXCJjaG5sXCI6MH0se1wiaWRcIjo1OSxcInhcIjoxMDcsXCJ5XCI6MTA1LFwid2lkdGhcIjoxNCxcImhlaWdodFwiOjI5LFwieG9mZnNldFwiOi0yLFwieW9mZnNldFwiOjE0LFwieGFkdmFuY2VcIjo4LFwicGFnZVwiOjAsXCJjaG5sXCI6MH0se1wiaWRcIjoxMjIsXCJ4XCI6MTIxLFwieVwiOjEwNSxcIndpZHRoXCI6MjQsXCJoZWlnaHRcIjoyNixcInhvZmZzZXRcIjotMyxcInlvZmZzZXRcIjoxMixcInhhZHZhbmNlXCI6MTcsXCJwYWdlXCI6MCxcImNobmxcIjowfSx7XCJpZFwiOjEyMCxcInhcIjoxNDUsXCJ5XCI6MTA1LFwid2lkdGhcIjoyNixcImhlaWdodFwiOjI2LFwieG9mZnNldFwiOi00LFwieW9mZnNldFwiOjEyLFwieGFkdmFuY2VcIjoxNyxcInBhZ2VcIjowLFwiY2hubFwiOjB9LHtcImlkXCI6MTE5LFwieFwiOjE3MSxcInlcIjoxMDUsXCJ3aWR0aFwiOjM2LFwiaGVpZ2h0XCI6MjYsXCJ4b2Zmc2V0XCI6LTQsXCJ5b2Zmc2V0XCI6MTIsXCJ4YWR2YW5jZVwiOjI3LFwicGFnZVwiOjAsXCJjaG5sXCI6MH0se1wiaWRcIjoxMTgsXCJ4XCI6MjA3LFwieVwiOjEwNSxcIndpZHRoXCI6MjcsXCJoZWlnaHRcIjoyNixcInhvZmZzZXRcIjotNCxcInlvZmZzZXRcIjoxMixcInhhZHZhbmNlXCI6MTcsXCJwYWdlXCI6MCxcImNobmxcIjowfSx7XCJpZFwiOjExNyxcInhcIjoyMzQsXCJ5XCI6MTA1LFwid2lkdGhcIjoyNCxcImhlaWdodFwiOjI2LFwieG9mZnNldFwiOi0yLFwieW9mZnNldFwiOjEyLFwieGFkdmFuY2VcIjoxOSxcInBhZ2VcIjowLFwiY2hubFwiOjB9LHtcImlkXCI6MTE1LFwieFwiOjI1OCxcInlcIjoxMDUsXCJ3aWR0aFwiOjI0LFwiaGVpZ2h0XCI6MjYsXCJ4b2Zmc2V0XCI6LTMsXCJ5b2Zmc2V0XCI6MTIsXCJ4YWR2YW5jZVwiOjE3LFwicGFnZVwiOjAsXCJjaG5sXCI6MH0se1wiaWRcIjoxMTQsXCJ4XCI6MjgyLFwieVwiOjEwNSxcIndpZHRoXCI6MjAsXCJoZWlnaHRcIjoyNixcInhvZmZzZXRcIjotMixcInlvZmZzZXRcIjoxMixcInhhZHZhbmNlXCI6MTMsXCJwYWdlXCI6MCxcImNobmxcIjowfSx7XCJpZFwiOjExMSxcInhcIjozMDIsXCJ5XCI6MTA1LFwid2lkdGhcIjoyNSxcImhlaWdodFwiOjI2LFwieG9mZnNldFwiOi0zLFwieW9mZnNldFwiOjEyLFwieGFkdmFuY2VcIjoxOCxcInBhZ2VcIjowLFwiY2hubFwiOjB9LHtcImlkXCI6MTEwLFwieFwiOjMyNyxcInlcIjoxMDUsXCJ3aWR0aFwiOjI0LFwiaGVpZ2h0XCI6MjYsXCJ4b2Zmc2V0XCI6LTIsXCJ5b2Zmc2V0XCI6MTIsXCJ4YWR2YW5jZVwiOjE5LFwicGFnZVwiOjAsXCJjaG5sXCI6MH0se1wiaWRcIjoxMDksXCJ4XCI6MzUxLFwieVwiOjEwNSxcIndpZHRoXCI6MzMsXCJoZWlnaHRcIjoyNixcInhvZmZzZXRcIjotMixcInlvZmZzZXRcIjoxMixcInhhZHZhbmNlXCI6MjgsXCJwYWdlXCI6MCxcImNobmxcIjowfSx7XCJpZFwiOjEwMSxcInhcIjozODQsXCJ5XCI6MTA1LFwid2lkdGhcIjoyNSxcImhlaWdodFwiOjI2LFwieG9mZnNldFwiOi0zLFwieW9mZnNldFwiOjEyLFwieGFkdmFuY2VcIjoxOCxcInBhZ2VcIjowLFwiY2hubFwiOjB9LHtcImlkXCI6OTksXCJ4XCI6NDA5LFwieVwiOjEwNSxcIndpZHRoXCI6MjMsXCJoZWlnaHRcIjoyNixcInhvZmZzZXRcIjotMyxcInlvZmZzZXRcIjoxMixcInhhZHZhbmNlXCI6MTYsXCJwYWdlXCI6MCxcImNobmxcIjowfSx7XCJpZFwiOjk3LFwieFwiOjQzMixcInlcIjoxMDUsXCJ3aWR0aFwiOjI0LFwiaGVpZ2h0XCI6MjYsXCJ4b2Zmc2V0XCI6LTMsXCJ5b2Zmc2V0XCI6MTIsXCJ4YWR2YW5jZVwiOjE4LFwicGFnZVwiOjAsXCJjaG5sXCI6MH0se1wiaWRcIjo0MyxcInhcIjo0NTYsXCJ5XCI6MTA1LFwid2lkdGhcIjoyNCxcImhlaWdodFwiOjI0LFwieG9mZnNldFwiOi0zLFwieW9mZnNldFwiOjExLFwieGFkdmFuY2VcIjoxNyxcInBhZ2VcIjowLFwiY2hubFwiOjB9LHtcImlkXCI6NjIsXCJ4XCI6NDgwLFwieVwiOjEwNSxcIndpZHRoXCI6MjMsXCJoZWlnaHRcIjoyNCxcInhvZmZzZXRcIjotMixcInlvZmZzZXRcIjoxMixcInhhZHZhbmNlXCI6MTcsXCJwYWdlXCI6MCxcImNobmxcIjowfSx7XCJpZFwiOjYwLFwieFwiOjAsXCJ5XCI6MTM3LFwid2lkdGhcIjoyMyxcImhlaWdodFwiOjI0LFwieG9mZnNldFwiOi0zLFwieW9mZnNldFwiOjEyLFwieGFkdmFuY2VcIjoxNyxcInBhZ2VcIjowLFwiY2hubFwiOjB9LHtcImlkXCI6NTgsXCJ4XCI6MjMsXCJ5XCI6MTM3LFwid2lkdGhcIjoxNCxcImhlaWdodFwiOjI0LFwieG9mZnNldFwiOi0zLFwieW9mZnNldFwiOjE0LFwieGFkdmFuY2VcIjo4LFwicGFnZVwiOjAsXCJjaG5sXCI6MH0se1wiaWRcIjo0MixcInhcIjozNyxcInlcIjoxMzcsXCJ3aWR0aFwiOjIxLFwiaGVpZ2h0XCI6MjEsXCJ4b2Zmc2V0XCI6LTMsXCJ5b2Zmc2V0XCI6NixcInhhZHZhbmNlXCI6MTQsXCJwYWdlXCI6MCxcImNobmxcIjowfSx7XCJpZFwiOjYxLFwieFwiOjU4LFwieVwiOjEzNyxcIndpZHRoXCI6MjQsXCJoZWlnaHRcIjoyMCxcInhvZmZzZXRcIjotMixcInlvZmZzZXRcIjoxMyxcInhhZHZhbmNlXCI6MTksXCJwYWdlXCI6MCxcImNobmxcIjowfSx7XCJpZFwiOjk0LFwieFwiOjgyLFwieVwiOjEzNyxcIndpZHRoXCI6MjMsXCJoZWlnaHRcIjoxOSxcInhvZmZzZXRcIjotNCxcInlvZmZzZXRcIjo4LFwieGFkdmFuY2VcIjoxNCxcInBhZ2VcIjowLFwiY2hubFwiOjB9LHtcImlkXCI6NDQsXCJ4XCI6MTA1LFwieVwiOjEzNyxcIndpZHRoXCI6MTQsXCJoZWlnaHRcIjoxOSxcInhvZmZzZXRcIjotMyxcInlvZmZzZXRcIjoyNCxcInhhZHZhbmNlXCI6OCxcInBhZ2VcIjowLFwiY2hubFwiOjB9LHtcImlkXCI6MzksXCJ4XCI6MTE5LFwieVwiOjEzNyxcIndpZHRoXCI6MTMsXCJoZWlnaHRcIjoxNyxcInhvZmZzZXRcIjotMyxcInlvZmZzZXRcIjo2LFwieGFkdmFuY2VcIjo3LFwicGFnZVwiOjAsXCJjaG5sXCI6MH0se1wiaWRcIjo5NixcInhcIjoxMzIsXCJ5XCI6MTM3LFwid2lkdGhcIjoxOCxcImhlaWdodFwiOjE3LFwieG9mZnNldFwiOi00LFwieW9mZnNldFwiOjUsXCJ4YWR2YW5jZVwiOjExLFwicGFnZVwiOjAsXCJjaG5sXCI6MH0se1wiaWRcIjozNCxcInhcIjoxNTAsXCJ5XCI6MTM3LFwid2lkdGhcIjoxOCxcImhlaWdodFwiOjE3LFwieG9mZnNldFwiOi0zLFwieW9mZnNldFwiOjYsXCJ4YWR2YW5jZVwiOjEyLFwicGFnZVwiOjAsXCJjaG5sXCI6MH0se1wiaWRcIjoxMjYsXCJ4XCI6MTY4LFwieVwiOjEzNyxcIndpZHRoXCI6MjIsXCJoZWlnaHRcIjoxNCxcInhvZmZzZXRcIjotMixcInlvZmZzZXRcIjoxNyxcInhhZHZhbmNlXCI6MTcsXCJwYWdlXCI6MCxcImNobmxcIjowfSx7XCJpZFwiOjQ2LFwieFwiOjE5MCxcInlcIjoxMzcsXCJ3aWR0aFwiOjE0LFwiaGVpZ2h0XCI6MTQsXCJ4b2Zmc2V0XCI6LTMsXCJ5b2Zmc2V0XCI6MjQsXCJ4YWR2YW5jZVwiOjgsXCJwYWdlXCI6MCxcImNobmxcIjowfSx7XCJpZFwiOjk1LFwieFwiOjIwNCxcInlcIjoxMzcsXCJ3aWR0aFwiOjI0LFwiaGVpZ2h0XCI6MTMsXCJ4b2Zmc2V0XCI6LTIsXCJ5b2Zmc2V0XCI6MjgsXCJ4YWR2YW5jZVwiOjE4LFwicGFnZVwiOjAsXCJjaG5sXCI6MH0se1wiaWRcIjo0NSxcInhcIjoyMjgsXCJ5XCI6MTM3LFwid2lkdGhcIjoxOSxcImhlaWdodFwiOjEzLFwieG9mZnNldFwiOi0yLFwieW9mZnNldFwiOjE4LFwieGFkdmFuY2VcIjoxNCxcInBhZ2VcIjowLFwiY2hubFwiOjB9XSxcImtlcm5pbmdzXCI6W10sXCJpbmZvXCI6e1wiZmFjZVwiOlwiRXhvIDIgU2VtaSBCb2xkXCIsXCJzaXplXCI6MzIsXCJib2xkXCI6MCxcIml0YWxpY1wiOjAsXCJjaGFyc2V0XCI6XCJcIixcInVuaWNvZGVcIjowLFwic3RyZXRjaEhcIjoxMDAsXCJzbW9vdGhcIjoxLFwiYWFcIjoxLFwicGFkZGluZ1wiOls0LDQsNCw0XSxcInNwYWNpbmdcIjpbLTgsLThdfSxcImNvbW1vblwiOntcImxpbmVIZWlnaHRcIjo0MCxcImJhc2VcIjozMyxcInNjYWxlV1wiOjUxMixcInNjYWxlSFwiOjUxMixcInBhZ2VzXCI6MSxcInBhY2tlZFwiOjB9fSIsIihmdW5jdGlvbiAoZ2xvYmFsKXtcbnJlcXVpcmUoJ3JhZi5qcycpXG5cbnZhciBUSFJFRSA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93LlRIUkVFIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbC5USFJFRSA6IG51bGwpXG52YXIgUmVuZGVyZXIgPSByZXF1aXJlKCcuL2xpYi9yZW5kZXJlcicpXG52YXIgY3JlYXRlRm9udCA9IHJlcXVpcmUoJy4vbGliL2NyZWF0ZS1mb250JylcbnZhciB4dGVuZCA9IHJlcXVpcmUoJ3h0ZW5kJylcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvcHQpIHtcbiAgICBvcHQgPSBvcHR8fHt9XG4gICAgdmFyIGFwcCA9IHJlcXVpcmUoJ2NhbnZhcy1hcHAnKShyZW5kZXIsIHh0ZW5kKHtcbiAgICAgICAgY29udGV4dDogJ3dlYmdsJyxcbiAgICAgICAgY29udGV4dEF0dHJpYnV0ZXM6IHsgYW50aWFsaWFzOiBmYWxzZSwgYWxwaGE6IGZhbHNlIH0sXG4gICAgICAgIHJldGluYTogdHJ1ZSxcbiAgICAgICAgb25SZXNpemU6IGhhbmRsZVJlc2l6ZVxuICAgIH0sIG9wdCkpXG5cbiAgICBcbiAgICB2YXIgcmVuZGVyZXJcblxuICAgIGFwcC5sb2FkID0gZnVuY3Rpb24oY2IpIHtcbiAgICAgICAgY2IgPSBjYiB8fCBmdW5jdGlvbigpIHt9XG4gICAgICAgIHZhciBnbCA9IGFwcC5jb250ZXh0XG4gICAgICAgIGNyZWF0ZUZvbnQoZ2wsIGZ1bmN0aW9uKGVyciwgZm9udCkge1xuICAgICAgICAgICAgcmVuZGVyZXIgPSBSZW5kZXJlcih7XG4gICAgICAgICAgICAgICAgZ2w6IGdsLCBcbiAgICAgICAgICAgICAgICB3aWR0aDogYXBwLndpZHRoLCBcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGFwcC5oZWlnaHQsXG4gICAgICAgICAgICAgICAgZm9udDogZm9udFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIGNiKGVycilcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICByZXR1cm4gYXBwXG5cbiAgICBmdW5jdGlvbiByZW5kZXIoZ2wsIHdpZHRoLCBoZWlnaHQsIGR0KSB7XG4gICAgICAgIGlmIChyZW5kZXJlcilcbiAgICAgICAgICAgIHJlbmRlcmVyLmRyYXcoZHQpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFuZGxlUmVzaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgaWYgKHJlbmRlcmVyKVxuICAgICAgICAgICAgcmVuZGVyZXIucmVzaXplKHdpZHRoLCBoZWlnaHQpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0dXBTbW9vdGhUZXgoZ2wsIHQpIHtcbiAgICAgICAgdC5taW5GaWx0ZXIgPSBnbC5MSU5FQVJfTUlQTUFQX0xJTkVBUlxuICAgICAgICB0Lm1hZ0ZpbHRlciA9IGdsLkxJTkVBUlxuXG4gICAgICAgIHZhciBleHQgPSAoZ2wuZ2V0RXh0ZW5zaW9uKCdFWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWMnKSBcbiAgICAgICAgICAgICAgICAgICAgICAgIHx8IGdsLmdldEV4dGVuc2lvbihcIk1PWl9FWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWNcIikpO1xuICAgICAgICBpZiAoZXh0KSB7XG4gICAgICAgICAgICB2YXIgbWF4QW5pc3Ryb3BoeSA9IGdsLmdldFBhcmFtZXRlcihleHQuTUFYX1RFWFRVUkVfTUFYX0FOSVNPVFJPUFlfRVhUKTtcbiAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmYoZ2wuVEVYVFVSRV8yRCwgZXh0LlRFWFRVUkVfTUFYX0FOSVNPVFJPUFlfRVhULCBNYXRoLm1pbigxNiwgbWF4QW5pc3Ryb3BoeSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdC5nZW5lcmF0ZU1pcG1hcCgpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0dXBOZWFyZXN0VGV4KGdsLCB0KSB7XG4gICAgICAgIHQubWluRmlsdGVyID0gdC5tYWdGaWx0ZXIgPSBnbC5ORUFSRVNUXG4gICAgfVxufVxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pIiwiKGZ1bmN0aW9uIChnbG9iYWwpe1xudmFyIFRIUkVFID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cuVEhSRUUgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsLlRIUkVFIDogbnVsbClcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBtaXhlcyA9IHJlcXVpcmUoJ21peGVzJylcbnZhciBCYXNlID0gVEhSRUUuU2NlbmVcblxudmFyIFlPRkYgPSAyLjVcblxuZnVuY3Rpb24gUmlnU2NlbmUob3B0KSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJpZ1NjZW5lKSlcbiAgICAgICAgcmV0dXJuIG5ldyBSaWdTY2VuZShvcHQpXG4gICAgQmFzZS5jYWxsKHRoaXMpXG4gICAgdGhpcy5mb2cgPSBuZXcgVEhSRUUuRm9nRXhwMiggMHgwYjA1MTYsIDAuMDAwMTUgKTtcblxuXG4gICAgLy8gdmFyIGJveCA9IG5ldyBUSFJFRS5NZXNoKFxuICAgIC8vICAgICBuZXcgVEhSRUUuQm94R2VvbWV0cnkoMjAsIDIwLCAxMCksXG4gICAgLy8gICAgIG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCh7IGNvbG9yOiAweGFhYWFhYSwgd2lyZWZyYW1lOiBmYWxzZSB9KVxuICAgIC8vIClcblxuICAgIC8vIHRoaXMuYWRkKGJveClcblxuXG4gICAgdGhpcy50aW1lID0gMFxuICAgIHRoaXMuY3ViZU1hcCA9IG51bGxcbiAgICB0aGlzLnVwZGF0ZU1hdGVyaWFsKClcblxuICAgIHZhciBsb2FkZXIgPSBuZXcgVEhSRUUuT0JKTVRMTG9hZGVyKClcbiAgICBsb2FkZXIubG9hZCgnbW9kZWwvUHJpcmF6bG9tbmF5YXdpdGhwaXBlczMub2JqJywgJ21vZGVsL1ByaXJhemxvbW5heWF3aXRocGlwZXMzLm10bCcsIGZ1bmN0aW9uKG9iamVjdCwgbWF0ZXJpYWxzKSB7XG4gICAgICAgIHZhciBzID0gMC4zXG4gICAgICAgIGNvbnNvbGUubG9nKG9iamVjdCwgbWF0ZXJpYWxzKVxuICAgICAgICBvYmplY3Quc2NhbGUuc2V0KHMscyxzKVxuICAgICAgICBvYmplY3QucG9zaXRpb24ueSAtPSBZT0ZGXG4gICAgICAgIHRoaXMubWVzaCA9IG9iamVjdFxuXG4gICAgICAgIHRoaXMubWVzaC50cmF2ZXJzZShmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgIGlmIChvYmogaW5zdGFuY2VvZiBUSFJFRS5NZXNoKSB7XG4gICAgICAgICAgICAgICAgb2JqLmNhc3RTaGFkb3cgPSB0cnVlXG4gICAgICAgICAgICAgICAgb2JqLnJlY2VpdmVTaGFkb3cgPSB0cnVlXG4gICAgICAgICAgICAgICAgb2JqLm1hdGVyaWFsLnNoaW5pbmVzcyA9IDFcbiAgICAgICAgICAgICAgICBpZiAob2JqLm1hdGVyaWFsLm1hcCkge1xuICAgICAgICAgICAgICAgICAgICBvYmoubWF0ZXJpYWwudHJhbnNwYXJlbnQgPSB0cnVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKG9iai5tYXRlcmlhbC51bmlmb3JtcylcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcblxuICAgICAgICB0aGlzLmFkZChvYmplY3QpXG4gICAgfS5iaW5kKHRoaXMpKVxuICAgIFxuXG4gICAgLy8gdmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLlRvcnVzS25vdEdlb21ldHJ5KCAxMCwgMywgMTAwLCAxNiApO1xuICAgIC8vIHZhciBtYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogMHhmZmZmMDAgfSApO1xuICAgIC8vIHZhciB0b3J1c0tub3QgPSBuZXcgVEhSRUUuTWVzaCggZ2VvbWV0cnksIG1hdGVyaWFsICk7XG4gICAgLy8gdGhpcy5hZGQoIHRvcnVzS25vdCApO1xuICAgIC8vIHRvcnVzS25vdC5jYXN0U2hhZG93ID0gdHJ1ZVxuICAgIC8vIHRvcnVzS25vdC5yZWNlaXZlU2hhZG93ID0gdHJ1ZVxuXG4gICAgdGhpcy5saWdodHMgPSBbXG4gICAgICAgIFsgbmV3IFRIUkVFLlZlY3RvcjMoLTEwLCAyMCwgLTIwKSwgMSBdLFxuICAgICAgICBbIG5ldyBUSFJFRS5WZWN0b3IzKDE1LCAxMCwgMTUpLCAwLjUgXVxuICAgIF0ubWFwKGZ1bmN0aW9uKGFyZ3MsIGkpIHtcbiAgICAgICAgdmFyIGxpZ2h0ID0gbmV3IFRIUkVFLkRpcmVjdGlvbmFsTGlnaHQoIDB4ZGRmNGZkLCBhcmdzWzFdIClcbiAgICAgICAgbGlnaHQucG9zaXRpb24uY29weShhcmdzWzBdKVxuICAgICAgICBsaWdodC5jYXN0U2hhZG93ID0gdHJ1ZVxuICAgICAgICBsaWdodC5zaGFkb3dNYXBXaWR0aCA9IDEwMjRcbiAgICAgICAgbGlnaHQuc2hhZG93TWFwSGVpZ2h0ID0gMTAyNFxuICAgICAgICBsaWdodC5zaGFkb3dDYW1lcmFOZWFyID0gMVxuICAgICAgICBsaWdodC5zaGFkb3dDYW1lcmFGYXIgPSAxMDBcblxuICAgICAgICAvLyBsaWdodC5oZWxwZXIgPSBuZXcgVEhSRUUuRGlyZWN0aW9uYWxMaWdodEhlbHBlcihsaWdodCwgNClcbiAgICAgICAgLy8gdGhpcy5hZGQobGlnaHQuaGVscGVyKVxuICAgICAgICB0aGlzLmFkZChsaWdodClcbiAgICAgICAgcmV0dXJuIGxpZ2h0XG4gICAgfSx0aGlzKVxufVxuXG5pbmhlcml0cyhSaWdTY2VuZSwgQmFzZSlcblxubWl4ZXMoUmlnU2NlbmUsIHtcblxuICAgIHVwZGF0ZU1hdGVyaWFsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5tYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoTGFtYmVydE1hdGVyaWFsKHtcbiAgICAgICAgICAgIGNvbG9yOiAweGFhYWFhYSxcbiAgICAgICAgICAgIHJlZmxlY3Rpdml0eTogMC40LFxuICAgICAgICAgICAgZW52TWFwOiB0aGlzLmN1YmVNYXBcbiAgICAgICAgfSlcblxuICAgIH0sXG5cbiAgICB1cGRhdGU6IGZ1bmN0aW9uKGR0KSB7XG4gICAgICAgIHRoaXMudGltZSArPSBNYXRoLm1pbihkdCwgMzApLzEwMDBcbiAgICAgICAgdmFyIG0gPSB0aGlzLm1lc2hcbiAgICAgICAgaWYgKCFtKVxuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIHZhciBhbmltID0gTWF0aC5zaW4odGhpcy50aW1lKVxuXG4gICAgICAgIC8vIHRoaXMubGlnaHRzLmZvckVhY2goZnVuY3Rpb24obGlnaHQpIHsgbGlnaHQuaGVscGVyLnVwZGF0ZSgpIH0pXG4gICAgICAgIC8vIG0ucG9zaXRpb24ueSA9IFlPRkYgKyBhbmltKjAuMlxuICAgICAgICAvLyBtLnBvc2l0aW9uLnggPSBNYXRoLnNpbih0aGlzLnRpbWUqMC4xKSowLjA1XG4gICAgICAgIC8vIG0ucG9zaXRpb24ueiA9IE1hdGguc2luKHRoaXMudGltZSowLjIpKjAuMVxuICAgICAgICAvLyBtLnJvdGF0aW9uLnggPSBhbmltKjAuMDNcbiAgICAgICAgLy8gbS5yb3RhdGlvbi55ID0gTWF0aC5zaW4odGhpcy50aW1lKk1hdGguY29zKHRoaXMudGltZSowLjEpKSowLjAwNVxuICAgIH1cbn0pXG5cbm1vZHVsZS5leHBvcnRzID0gUmlnU2NlbmVcbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KSIsIihmdW5jdGlvbiAoZ2xvYmFsKXtcbnZhciBUSFJFRSA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93LlRIUkVFIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbC5USFJFRSA6IG51bGwpO1xudmFyIEVmZmVjdENvbXBvc2VyID0gcmVxdWlyZShcInRocmVlLWVmZmVjdGNvbXBvc2VyXCIpKFRIUkVFKTtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoXCJpbmhlcml0c1wiKTtcbnZhciBCYXNlID0gRWZmZWN0Q29tcG9zZXIuUmVuZGVyUGFzcztcbnZhciBwbHVja2VyID0gcmVxdWlyZShcInBsdWNrZXJcIik7XG52YXIgbnVtYmVyID0gcmVxdWlyZShcImFzLW51bWJlclwiKTtcbnZhciBUZXh0RWxlbWVudCA9IHJlcXVpcmUoXCJ0aHJlZS1zZGYtdGV4dFwiKShUSFJFRSk7XG52YXIgeHRlbmQgPSByZXF1aXJlKFwieHRlbmRcIik7XG52YXIgVU5JVF9TQ0FMRSA9IDAuMTtcbnZhciBTQ0FMRSA9IFtVTklUX1NDQUxFLCBVTklUX1NDQUxFLCBVTklUX1NDQUxFXTtcblxudmFyIG1hdDQgPSB7XG4gICAgc2NhbGU6IHJlcXVpcmUoXCJnbC1tYXQ0L3NjYWxlXCIpLFxuICAgIGlkZW50aXR5OiByZXF1aXJlKFwiZ2wtbWF0NC9pZGVudGl0eVwiKSxcbiAgICBtdWx0aXBseTogcmVxdWlyZShcImdsLW1hdDQvbXVsdGlwbHlcIiksXG4gICAgdHJhbnNsYXRlOiByZXF1aXJlKFwiZ2wtbWF0NC90cmFuc2xhdGVcIilcbn07XG5cbnZhciBzZXRWZWMzID0gcmVxdWlyZShcImdsLXZlYzMvc2V0XCIpO1xudmFyIHRtcFZlYzMgPSBbMCwgMCwgMF07XG52YXIgcGx1Y2tQYW5lbHMgPSBwbHVja2VyKFwicGFuZWxzXCIpO1xudmFyIGdsc2xpZnkgPSByZXF1aXJlKFwiZ2xzbGlmeVwiKTtcbnZhciBjcmVhdGVTREZTaGFkZXIgPSByZXF1aXJlKFwiZ2xzbGlmeS9hZGFwdGVyLmpzXCIpKFwiXFxuI2RlZmluZSBHTFNMSUZZIDFcXG5cXG5hdHRyaWJ1dGUgdmVjNCBwb3NpdGlvbjtcXG5hdHRyaWJ1dGUgdmVjNCBjb2xvcjtcXG5hdHRyaWJ1dGUgdmVjMiB0ZXhjb29yZDA7XFxudW5pZm9ybSBtYXQ0IHByb2plY3Rpb247XFxudW5pZm9ybSBtYXQ0IHZpZXc7XFxudW5pZm9ybSBtYXQ0IG1vZGVsO1xcbnZhcnlpbmcgdmVjNCB2X2NvbDtcXG52YXJ5aW5nIHZlYzIgdl90ZXgwO1xcbnZhcnlpbmcgZmxvYXQgYW5pbU9mZnNldDtcXG52b2lkIG1haW4oKSB7XFxuICBnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb24gKiB2aWV3ICogbW9kZWwgKiBwb3NpdGlvbjtcXG4gIHZfY29sID0gY29sb3I7XFxuICB2X3RleDAgPSB0ZXhjb29yZDA7XFxuICBnbF9Qb2ludFNpemUgPSAxLjA7XFxuICBhbmltT2Zmc2V0ID0gcG9zaXRpb24ueCAvIDEwMC4wO1xcbn1cIiwgXCJcXG4jZGVmaW5lIEdMU0xJRlkgMVxcblxcbiNpZmRlZiBHTF9FU1xcblxcbnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbiNlbmRpZlxcblxcbnZhcnlpbmcgdmVjNCB2X2NvbDtcXG52YXJ5aW5nIHZlYzIgdl90ZXgwO1xcbnZhcnlpbmcgZmxvYXQgYW5pbU9mZnNldDtcXG51bmlmb3JtIHNhbXBsZXIyRCB0ZXh0dXJlMDtcXG51bmlmb3JtIHNhbXBsZXIyRCB0ZXh0dXJlMTtcXG51bmlmb3JtIGZsb2F0IHNtb290aGluZztcXG51bmlmb3JtIGZsb2F0IGZhZGU7XFxuY29uc3QgdmVjMiBzaGFkb3dPZmZzZXQgPSB2ZWMyKC0xLjAgLyA1MTIuMCk7XFxuY29uc3QgdmVjNCBnbG93Q29sb3IgPSB2ZWM0KHZlYzMoMC4xKSwgMS4wKTtcXG5jb25zdCBmbG9hdCBnbG93TWluID0gMC40O1xcbmNvbnN0IGZsb2F0IGdsb3dNYXggPSAwLjg7XFxudm9pZCBtYWluKCkge1xcbiAgZmxvYXQgYW5pbSA9IGZhZGUgKiBhbmltT2Zmc2V0O1xcbiAgYW5pbSA9IGNsYW1wKG1peChhbmltLCAxLjAsIGZhZGUgKiBmYWRlKSwgMC4wLCAxLjApO1xcbiAgdmVjNCBzbW9vdGhDb2xvciA9IHZlYzQoMC4wKTtcXG4gIHZlYzQgdGV4Q29sb3IgPSB0ZXh0dXJlMkQodGV4dHVyZTAsIHZfdGV4MCk7XFxuICBmbG9hdCBkc3QgPSB0ZXhDb2xvci5hO1xcbiAgZmxvYXQgc21vb3RoQW10ID0gbWl4KDEuNSwgc21vb3RoaW5nLCBhbmltKTtcXG4gIGZsb2F0IGFscGhhID0gc21vb3Roc3RlcCgwLjUgLSBzbW9vdGhBbXQsIDAuNSArIHNtb290aEFtdCwgZHN0KTtcXG4gIHZlYzQgYmFzZSA9IHZfY29sICogdmVjNChhbHBoYSk7XFxuICBmbG9hdCBnbG93RHN0ID0gdGV4dHVyZTJEKHRleHR1cmUwLCB2X3RleDAgKyBzaGFkb3dPZmZzZXQpLmE7XFxuICB2ZWM0IGdsb3cgPSBnbG93Q29sb3IgKiBzbW9vdGhzdGVwKGdsb3dNaW4sIGdsb3dNYXgsIGdsb3dEc3QpO1xcbiAgZmxvYXQgbWFzayA9IDEuMCAtIGFscGhhO1xcbiAgZ2xfRnJhZ0NvbG9yID0gbWl4KHZlYzQoMC4wKSwgYmFzZSwgYW5pbSk7XFxuICBpZihnbF9GcmFnQ29sb3IuYSA8IDAuMSlcXG4gICAgZGlzY2FyZDtcXG4gIFxcbn1cIiwgW3tcIm5hbWVcIjpcInByb2plY3Rpb25cIixcInR5cGVcIjpcIm1hdDRcIn0se1wibmFtZVwiOlwidmlld1wiLFwidHlwZVwiOlwibWF0NFwifSx7XCJuYW1lXCI6XCJtb2RlbFwiLFwidHlwZVwiOlwibWF0NFwifSx7XCJuYW1lXCI6XCJ0ZXh0dXJlMFwiLFwidHlwZVwiOlwic2FtcGxlcjJEXCJ9LHtcIm5hbWVcIjpcInRleHR1cmUxXCIsXCJ0eXBlXCI6XCJzYW1wbGVyMkRcIn0se1wibmFtZVwiOlwic21vb3RoaW5nXCIsXCJ0eXBlXCI6XCJmbG9hdFwifSx7XCJuYW1lXCI6XCJmYWRlXCIsXCJ0eXBlXCI6XCJmbG9hdFwifV0sIFt7XCJuYW1lXCI6XCJwb3NpdGlvblwiLFwidHlwZVwiOlwidmVjNFwifSx7XCJuYW1lXCI6XCJjb2xvclwiLFwidHlwZVwiOlwidmVjNFwifSx7XCJuYW1lXCI6XCJ0ZXhjb29yZDBcIixcInR5cGVcIjpcInZlYzJcIn1dKTtcbnZhciBzZGZTaGFkZXI7XG5cbmZ1bmN0aW9uIFRleHRQYXNzKG9wdCkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBUZXh0UGFzcykpXG4gICAgICAgIHJldHVybiBuZXcgVGV4dFBhc3Mob3B0KTtcblxuICAgIG9wdCA9IG9wdCB8fCB7fTtcbiAgICB2YXIgcmVuZGVyZXIgPSBvcHQucmVuZGVyZXI7XG4gICAgdmFyIGNhbWVyYSA9IG9wdC5jYW1lcmE7XG4gICAgdmFyIHNjZW5lID0gb3B0LnNjZW5lO1xuICAgIEJhc2UuY2FsbCh0aGlzLCBzY2VuZSwgY2FtZXJhKTtcbiAgICB2YXIgZm9udCA9IG9wdC5mb250O1xuXG4gICAgaWYgKCFzZGZTaGFkZXIpXG4gICAgICAgIHNkZlNoYWRlciA9IGNyZWF0ZVNERlNoYWRlcihyZW5kZXJlci5nZXRDb250ZXh0KCkpO1xuXG4gICAgdGhpcy5ncm91cHMgPSAob3B0Lmdyb3VwcyB8fCBbXSkubWFwKGNyZWF0ZUdyb3VwcyhyZW5kZXJlciwgZm9udCkpO1xuICAgIHdpbmRvdy5ncm91cHMgPSB0aGlzLmdyb3Vwcztcbn1cblxuZnVuY3Rpb24gY3JlYXRlR3JvdXBzKHJlbmRlcmVyLCBmb250KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGdyb3VwLCBncm91cEluZGV4KSB7XG4gICAgICAgIGdyb3VwLmVsZW1lbnRzID0gZ3JvdXAucGFuZWxzLm1hcChmdW5jdGlvbihwYW5lbCwgaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBzaWRlID0gKGluZGV4ID09PSAwID8gMSA6IC0xKTtcblxuICAgICAgICAgICAgcmV0dXJuIHBhbmVsLmxhYmVscy5tYXAoZnVuY3Rpb24obGFiZWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlRWxlbWVudChsYWJlbCwgc2lkZSwgcmVuZGVyZXIsIGZvbnQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pLnJlZHVjZShmdW5jdGlvbihwcmV2LCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJldi5jb25jYXQoYik7XG4gICAgICAgIH0sIFtdKTtcblxuICAgICAgICBncm91cC5fb3BhY2l0eSA9IDE7XG4gICAgICAgIGdyb3VwLmZhZGUgPSAxO1xuICAgICAgICBncm91cC5zaG93aW5nID0gdHJ1ZTtcbiAgICAgICAgZ3JvdXAuYW5pbWF0aW5nT3V0ID0gZmFsc2U7XG5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGdyb3VwLCBcIm9wYWNpdHlcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ3JvdXAuX29wYWNpdHk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICAgICAgICAgIGdyb3VwLl9vcGFjaXR5ID0gdmFsO1xuXG4gICAgICAgICAgICAgICAgZ3JvdXAuZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgIGUudGV4dC5vcGFjaXR5ID0gdmFsO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgZ3JvdXAucGFuZWxzLmZvckVhY2goZnVuY3Rpb24ocCkge1xuICAgICAgICAgICAgICAgICAgICBwLmNvbnRhaW5lci52aXNpYmxlID0gdmFsID4gMC4wMTtcblxuICAgICAgICAgICAgICAgICAgICBwLnNoYXBlcy5mb3JFYWNoKGZ1bmN0aW9uKHNoYXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaGFwZS5tYXRlcmlhbC5vcGFjaXR5ID0gdmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2hhcGUudmlzaWJsZSA9IHZhbCA+IDAuMDE7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gZ3JvdXA7XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudChsYWJlbCwgc2lkZSwgcmVuZGVyZXIsIGZvbnQpIHtcbiAgICB2YXIgdGV4dE9wdCA9IHh0ZW5kKGxhYmVsLCB7XG4gICAgICAgIGZvbnQ6IGZvbnQsXG4gICAgICAgIHRleHR1cmVzOiBmb250LnRleHR1cmVzLFxuICAgICAgICBzaGFkZXI6IHNkZlNoYWRlclxuICAgIH0pO1xuXG4gICAgdmFyIHRleHRFbCA9IFRleHRFbGVtZW50KHJlbmRlcmVyLCB0ZXh0T3B0KTtcblxuICAgIHJldHVybiB4dGVuZChsYWJlbCwge1xuICAgICAgICB0ZXh0OiB0ZXh0RWwsXG4gICAgICAgIHNpZGU6IHNpZGVcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyRWxlbWVudChjYW1lcmEsIGUsIGZhZGUpIHtcbiAgICBlLm9iamVjdDNkLnVwZGF0ZU1hdHJpeFdvcmxkKHRydWUpO1xuICAgIHZhciB0cmFuc2Zvcm0gPSBlLnRleHQudHJhbnNmb3JtO1xuICAgIG1hdDQuaWRlbnRpdHkodHJhbnNmb3JtKTtcbiAgICBtYXQ0LnNjYWxlKHRyYW5zZm9ybSwgdHJhbnNmb3JtLCBTQ0FMRSk7XG4gICAgc2V0VmVjMyh0bXBWZWMzLCBlLnRyYW5zbGF0aW9uWzBdLCBlLnRyYW5zbGF0aW9uWzFdLCBlLnRyYW5zbGF0aW9uWzJdKTtcbiAgICBtYXQ0LnRyYW5zbGF0ZSh0cmFuc2Zvcm0sIHRyYW5zZm9ybSwgdG1wVmVjMyk7XG4gICAgc2V0VmVjMyh0bXBWZWMzLCBlLnNpemUsIGUuc2l6ZSwgZS5zaXplKTtcbiAgICBtYXQ0LnNjYWxlKHRyYW5zZm9ybSwgdHJhbnNmb3JtLCB0bXBWZWMzKTtcbiAgICBlLnRleHQuc2hhZGVyLmJpbmQoKTtcbiAgICBlLnRleHQuc2hhZGVyLnVuaWZvcm1zLmZhZGUgPSBmYWRlO1xuICAgIGUudGV4dC5kcmF3KGNhbWVyYSwgZS5vYmplY3QzZCk7XG59XG5cbmluaGVyaXRzKFRleHRQYXNzLCBCYXNlKTtcblxuVGV4dFBhc3MucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKHJlbmRlcmVyLCB3cml0ZUJ1ZmZlciwgcmVhZEJ1ZmZlciwgZGVsdGEpIHtcbiAgICBCYXNlLnByb3RvdHlwZS5yZW5kZXIuY2FsbCh0aGlzLCByZW5kZXJlciwgd3JpdGVCdWZmZXIsIHJlYWRCdWZmZXIsIGRlbHRhKTtcbiAgICB2YXIgY2FtZXJhID0gdGhpcy5jYW1lcmE7XG5cbiAgICB0aGlzLmdyb3Vwcy5mb3JFYWNoKGZ1bmN0aW9uKGcpIHtcbiAgICAgICAgZy5lbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGlmICghZy5zaG93aW5nKVxuICAgICAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgICAgcmVuZGVyRWxlbWVudChjYW1lcmEsIGUsIGcuZmFkZSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgcmVuZGVyZXIucmVzZXRHTFN0YXRlKCk7XG4gICAgcmVuZGVyZXIucmVzZXRBdHRyaWJ1dGVzKCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRleHRQYXNzO1xufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pIiwiKGZ1bmN0aW9uIChnbG9iYWwpe1xudmFyIFR3ZWVuTWF4ID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cuVHdlZW5NYXggOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsLlR3ZWVuTWF4IDogbnVsbClcbnZhciBjbGFtcCA9IHJlcXVpcmUoJ2NsYW1wJylcbnZhciBzbW9vdGhzdGVwID0gcmVxdWlyZSgnc21vb3Roc3RlcCcpXG5cbnZhciBsYXN0SW5kZXggPSAtMVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGNvbnRyb2xsZXIsIGxhYmVscykge1xuICAgIHZhciBjbG9zZUluZGV4ID0gY2xvc2VzdChjb250cm9sbGVyLCBsYWJlbHMpXG5cbiAgICAvLyBjb25zb2xlLmxvZyhjb250cm9sbGVyLnRoZXRhKVxuICAgIGxhYmVscy5mb3JFYWNoKGZ1bmN0aW9uKGxhYmVsLCBpKSB7XG4gICAgICAgIC8vIHNldFNob3dpbmcobGFiZWwsIHRydWUpXG4gICAgICAgIHZhciB2aXNpYmxlID0gaT09PWNsb3NlSW5kZXhcbiAgICAgICAgaWYgKHZpc2libGUgJiYgIWxhYmVsLnNob3dpbmcpIHtcbiAgICAgICAgICAgIGFuaW1hdGVJbkZlYXR1cmUobGFiZWwpXG4gICAgICAgIH0gZWxzZSBpZiAoIXZpc2libGUgJiYgbGFiZWwuc2hvd2luZykge1xuICAgICAgICAgICAgYW5pbWF0ZU91dEZlYXR1cmUobGFiZWwpXG4gICAgICAgIH1cbiAgICB9KVxufVxuXG5tb2R1bGUuZXhwb3J0cy5oaWRlQWxsID0gZnVuY3Rpb24oZmVhdHVyZXMpIHtcbiAgICBmZWF0dXJlcy5mb3JFYWNoKGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgc2V0U2hvd2luZyhmLCBmYWxzZSlcbiAgICB9KVxufVxuXG5mdW5jdGlvbiBkaXN0YW5jZShjb250cm9sbGVyLCBsYWJlbCkge1xuICAgIC8vc2lnbmVkIGRpc3RhbmNlXG4gICAgdmFyIHggPSAtbGFiZWwudGhldGEsIFxuICAgICAgICB5ID0gY29udHJvbGxlci50aGV0YVxuXG4gICAgdmFyIGFiZGlzdCA9IE1hdGguYWJzKHggLSB5KVxuICAgIHJldHVybiBNYXRoLm1pbigoMiAqIE1hdGguUEkpIC0gYWJkaXN0LCBhYmRpc3QpXG5cbn1cblxuZnVuY3Rpb24gY2xvc2VzdChjb250cm9sbGVyLCBsYWJlbHMpIHtcbiAgICB2YXIgbWluRGlzdCA9IE51bWJlci5NQVhfVkFMVUVcbiAgICB2YXIgcmV0ID0gLTFcbiAgICBsYWJlbHMuZm9yRWFjaChmdW5jdGlvbihsYWJlbCwgaW5kZXgpIHtcbiAgICAgICAgdmFyIGRpc3QgPSBkaXN0YW5jZShjb250cm9sbGVyLCBsYWJlbClcbiAgICAgICAgXG4gICAgICAgIGlmIChkaXN0IDwgbWluRGlzdCkge1xuICAgICAgICAgICAgbWluRGlzdCA9IGRpc3RcbiAgICAgICAgICAgIHJldCA9IGluZGV4XG4gICAgICAgIH1cbiAgICB9KVxuICAgIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gc2V0U2hvd2luZyhmZWF0dXJlLCBzaG93aW5nKSB7XG4gICAgZmVhdHVyZS5zaG93aW5nID0gc2hvd2luZ1xufVxuXG5mdW5jdGlvbiBhbmltYXRlSW5GZWF0dXJlKGZlYXR1cmUpIHtcbiAgICBmZWF0dXJlLnNob3dpbmcgPSB0cnVlXG4gICAgZmVhdHVyZS5mYWRlID0gMFxuICAgIFR3ZWVuTWF4LmtpbGxUd2VlbnNPZihmZWF0dXJlKVxuICAgIFR3ZWVuTWF4LnRvKGZlYXR1cmUsIDAuNSwge1xuICAgICAgICBmYWRlOiAxLjAsXG4gICAgICAgIGVhc2U6IFwiZWFzZU91dFF1YWRcIlxuICAgIH0pXG59XG5cbmZ1bmN0aW9uIGFuaW1hdGVPdXRGZWF0dXJlKGZlYXR1cmUpIHtcbiAgICBpZiAoZmVhdHVyZS5hbmltYXRpbmdPdXQpXG4gICAgICAgIHJldHVyblxuXG4gICAgZmVhdHVyZS5hbmltYXRpbmdPdXQgPSB0cnVlXG4gICAgVHdlZW5NYXgudG8oZmVhdHVyZSwgMC41LCB7XG4gICAgICAgIGZhZGU6IDAsXG4gICAgICAgIGVhc2U6ICdlYXNlT3V0UXVhZCcsXG4gICAgICAgIG9uQ29tcGxldGU6IGhpZGVGZWF0dXJlLmJpbmQobnVsbCwgZmVhdHVyZSlcbiAgICB9KVxufVxuXG5mdW5jdGlvbiBoaWRlRmVhdHVyZShmZWF0dXJlKSB7XG4gICAgZmVhdHVyZS5hbmltYXRpbmdPdXQgPSBmYWxzZVxuICAgIGZlYXR1cmUuc2hvd2luZyA9IGZhbHNlXG59XG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSkiLCJ2YXIgRm9udCA9IHJlcXVpcmUoJy4uL2ZvbnRzL0V4bzJTZW1pQm9sZC5qc29uJylcbnZhciBmb250SW1hZ2UgPSAnZm9udHMvRXhvMlNlbWlCb2xkLnBuZydcbnZhciBpbWcgPSByZXF1aXJlKCdpbWcnKVxudmFyIGNyZWF0ZVRleHR1cmUgPSByZXF1aXJlKCdnbC10ZXh0dXJlMmQnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGdsLCBjYikge1xuICAgIGltZyhmb250SW1hZ2UsIGZ1bmN0aW9uKGVyciwgcmVzKSB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIGNiKGVycilcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgRm9udC50ZXh0dXJlcyA9IFtyZXNdLm1hcChmdW5jdGlvbihpKSB7XG4gICAgICAgICAgICB2YXIgdCA9IGNyZWF0ZVRleHR1cmUoZ2wsIGkpXG5cbiAgICAgICAgICAgIHQubWluRmlsdGVyID0gZ2wuTElORUFSX01JUE1BUF9MSU5FQVJcbiAgICAgICAgICAgIHQubWFnRmlsdGVyID0gZ2wuTElORUFSXG5cbiAgICAgICAgICAgIHZhciBleHQgPSAoZ2wuZ2V0RXh0ZW5zaW9uKCdFWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWMnKSBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB8fCBnbC5nZXRFeHRlbnNpb24oXCJNT1pfRVhUX3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljXCIpKTtcbiAgICAgICAgICAgIGlmIChleHQpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWF4QW5pc3Ryb3BoeSA9IGdsLmdldFBhcmFtZXRlcihleHQuTUFYX1RFWFRVUkVfTUFYX0FOSVNPVFJPUFlfRVhUKTtcbiAgICAgICAgICAgICAgICBnbC50ZXhQYXJhbWV0ZXJmKGdsLlRFWFRVUkVfMkQsIGV4dC5URVhUVVJFX01BWF9BTklTT1RST1BZX0VYVCwgTWF0aC5taW4oMTYsIG1heEFuaXN0cm9waHkpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdC5nZW5lcmF0ZU1pcG1hcCgpXG4gICAgICAgICAgICByZXR1cm4gdFxuICAgICAgICB9KVxuICAgICAgICBcbiAgICAgICAgY2IobnVsbCwgRm9udClcbiAgICB9KVxufSIsIihmdW5jdGlvbiAoZ2xvYmFsKXtcbnZhciBUZXh0UGFzcyA9IHJlcXVpcmUoJy4vVGV4dFBhc3MnKVxudmFyIFRIUkVFID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cuVEhSRUUgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsLlRIUkVFIDogbnVsbClcbnZhciB4dGVuZCA9IHJlcXVpcmUoJ3h0ZW5kJylcbnZhciBnZXRTVkcgPSByZXF1aXJlKCcuL2dldC1zdmcnKVxudmFyIGdldFBvbHkgPSByZXF1aXJlKCcuL2dldC1wb2x5Z29uJylcbnZhciBDb21wbGV4ID0gcmVxdWlyZSgndGhyZWUtc2ltcGxpY2lhbC1jb21wbGV4JykoVEhSRUUpXG5cbnZhciBVTklUX1NDQUxFID0gMC4xXG5cbnZhciBkYXRhID0gcmVxdWlyZSgnLi90ZXh0LWRhdGEnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9wdCkge1xuICAgIHZhciBncm91cHMgPSBjcmVhdGVHcm91cHMoKVxuICAgIFxuICAgIGdyb3Vwcy5mb3JFYWNoKGZ1bmN0aW9uKGdyb3VwKSB7XG4gICAgICAgIC8vIHZhciBsZW4gPSAxMDBcbiAgICAgICAgLy8gdmFyIGRpciA9IG5ldyBUSFJFRS5WZWN0b3IzKE1hdGguY29zKGdyb3VwLnRoZXRhKSwgMCwgTWF0aC5zaW4oZ3JvdXAudGhldGEpKVxuICAgICAgICAvLyB2YXIgYXJyb3cgPSBuZXcgVEhSRUUuQXJyb3dIZWxwZXIoZGlyLCBuZXcgVEhSRUUuVmVjdG9yMygpLCBsZW4pXG4gICAgICAgIC8vIG9wdC5zY2VuZS5hZGQoYXJyb3cpXG5cbiAgICAgICAgZ3JvdXAucGFuZWxzLmZvckVhY2goZnVuY3Rpb24ocGFuZWwpIHtcbiAgICAgICAgICAgIG9wdC5zY2VuZS5hZGQocGFuZWwuY29udGFpbmVyKVxuICAgICAgICB9KVxuICAgIH0pXG5cbiAgICByZXR1cm4gVGV4dFBhc3MoeHRlbmQob3B0LCB7XG4gICAgICAgIGdyb3VwczogZ3JvdXBzXG4gICAgfSkpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUdyb3VwcygpIHtcbiAgICByZXR1cm4gZGF0YS5tYXAoZnVuY3Rpb24oZ3JvdXAsIGksIGxpc3QpIHtcbiAgICAgICAgdmFyIHRoZXRhID0gaS8obGlzdC5sZW5ndGgrMSkgKiBNYXRoLlBJICogMlxuICAgICAgICBncm91cCA9IHh0ZW5kKGdyb3VwLCB7XG4gICAgICAgICAgICBwYW5lbHM6IGdyb3VwLnBhbmVscy5tYXAoZnVuY3Rpb24ocGFuZWwsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVBhbmVsKHBhbmVsLCBpbmRleCwgdGhldGEpXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHRoZXRhOiB0aGV0YVxuICAgICAgICB9KVxuICAgICAgICByZXR1cm4gZ3JvdXBcbiAgICB9KVxufVxuXG5mdW5jdGlvbiBjcmVhdGVQYW5lbChkYXRhLCBpbmRleCwgcm90YXRpb24pIHtcbiAgICB2YXIgY29udGFpbmVyID0gbmV3IFRIUkVFLk9iamVjdDNEKClcbiAgICB2YXIgbWlycm9yID0gaW5kZXggPT09IDFcblxuICAgIHZhciByYWRpdXMgPSAyMFxuICAgIGlmIChtaXJyb3IpIHtcbiAgICAgICAgcm90YXRpb24gKz0gTWF0aC5QSSoyXG4gICAgICAgIHJhZGl1cyAqPSAtMVxuICAgIH1cblxuICAgIC8vbWFrZSB0ZXh0IHBlcnBlbmRpY3VsYXIgdG8gdGhldGEgcm90YXRpb25cbiAgICAvLyByb3RhdGlvbiAtPSBNYXRoLlBJLzIgXG5cbiAgICBjb250YWluZXIucG9zaXRpb24uc2V0KFxuICAgICAgICBNYXRoLmNvcyhyb3RhdGlvbikgKiByYWRpdXMsXG4gICAgICAgIDE1LFxuICAgICAgICBNYXRoLnNpbihyb3RhdGlvbikgKiByYWRpdXNcbiAgICApXG4gICAgXG5cbiAgICAvLyBjb250YWluZXIucG9zaXRpb24uY29weShkYXRhLm9yaWdpbilcblxuICAgIHZhciBwb3MgPSBjb250YWluZXIucG9zaXRpb25cbiAgICB2YXIgZGlyID0gcG9zLmNsb25lKCkuc3ViKG5ldyBUSFJFRS5WZWN0b3IzKDAscG9zLnksMCkpLm5vcm1hbGl6ZSgpXG5cbiAgICB2YXIgcm90T2ZmID0gMC8vTWF0aC5QSS8xMCAqIChtaXJyb3IgPyAtMSA6IDEpXG5cbiAgICB2YXIgZHggPSBwb3MueCxcbiAgICAgICAgZHogPSBwb3MueixcbiAgICAgICAgdGhldGEgPSAtTWF0aC5hdGFuMihkeiwgZHgpIC0gcm90T2ZmXG4gICAgLy8gY29udGFpbmVyLnJvdGF0aW9uLnkgPSB0aGV0YVxuICAgIGNvbnRhaW5lci5yb3RhdGlvbi55ID0gdGhldGFcbiAgICBjb250YWluZXIucm90YXRpb24ueCA9IDBcbiAgICBcbiAgICBpZiAobWlycm9yKSB7XG4gICAgICAgIGNvbnRhaW5lci5zY2FsZS54ICo9IC0xXG4gICAgfVxuXG4gICAgdmFyIGxhYmVscyA9IGRhdGEubGFiZWxzLm1hcChmdW5jdGlvbihsYWJlbCkge1xuICAgICAgICB2YXIgb2JqID0gbmV3IFRIUkVFLk9iamVjdDNEKClcbiAgICAgICAgY29udGFpbmVyLmFkZChvYmopXG4gICAgICAgIGlmIChtaXJyb3IpXG4gICAgICAgICAgICBvYmoucG9zaXRpb24ueCA9IC1kYXRhLndpZHRofHwwXG4gICAgICAgIHJldHVybiB4dGVuZCh7IHNpemU6IDEsIHRyYW5zbGF0aW9uOiBbMCwgMCwgMF0gfSwgbGFiZWwsIHsgXG4gICAgICAgICAgICBvYmplY3QzZDogb2JqLCBcbiAgICAgICAgICAgIC8vIHRoZXRhOiB0aGV0YVxuICAgICAgICB9KVxuICAgIH0pXG5cbiAgICB2YXIgc2hhcGVzID0gKGRhdGEuc2hhcGVzfHxbXSkubWFwKGZ1bmN0aW9uKHNoYXBlKSB7XG4gICAgICAgIHZhciBjb21wbGV4ID0gc2hhcGUucGF0aCA/IGdldFNWRyhzaGFwZS5wYXRoKSA6IGdldFBvbHkoc2hhcGUucG9pbnRzKVxuICAgICAgICB2YXIgZ2VvID0gQ29tcGxleChjb21wbGV4KVxuICAgICAgICB2YXIgbWVzaCA9IG5ldyBUSFJFRS5NZXNoKGdlbywgbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKHsgXG4gICAgICAgICAgICBjb2xvcjogMHhmZmZmZmYsXG4gICAgICAgICAgICBzaWRlOiBUSFJFRS5Eb3VibGVTaWRlLFxuICAgICAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgICAgIHRyYW5zcGFyZW50OiB0cnVlXG4gICAgICAgIH0pKVxuICAgICAgICBcbiAgICAgICAgaWYgKHNoYXBlLnBvc2l0aW9uKSBtZXNoLnBvc2l0aW9uLmZyb21BcnJheShzaGFwZS5wb3NpdGlvbilcbiAgICAgICAgaWYgKHNoYXBlLnNjYWxlKSBtZXNoLnNjYWxlLmZyb21BcnJheShzaGFwZS5zY2FsZSlcblxuICAgICAgICBjb250YWluZXIuYWRkKG1lc2gpXG4gICAgICAgIHJldHVybiBtZXNoXG4gICAgfSlcblxuICAgIHJldHVybiB7XG4gICAgICAgIGxhYmVsczogbGFiZWxzLFxuICAgICAgICBzaGFwZXM6IHNoYXBlcyxcbiAgICAgICAgY29udGFpbmVyOiBjb250YWluZXJcbiAgICB9XG59XG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSkiLCJ2YXIgdHJpYW5ndWxhdGUgPSByZXF1aXJlKCd0cmlhbmd1bGF0ZS1jb250b3VycycpXG52YXIgbm9ybWFsaXplID0gcmVxdWlyZSgnbm9ybWFsaXplLXBhdGgtc2NhbGUnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHBvaW50cykge1xuICAgIHBvaW50cyA9IHBvaW50cy5zcGxpdCgnICcpLm1hcChmdW5jdGlvbihwKSB7XG4gICAgICAgIHJldHVybiBwLnNwbGl0KCcsJykubWFwKGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUZsb2F0KG4sIDEwKVxuICAgICAgICB9KVxuICAgIH0pXG5cbiAgICBwb2ludHMgPSBub3JtYWxpemUocG9pbnRzKVxuXG4gICAgdmFyIHRyaWFuZ3VsYXRlZCA9IHRyaWFuZ3VsYXRlKFsgcG9pbnRzIF0pXG4gICAgdHJpYW5ndWxhdGVkLnBvc2l0aW9ucyA9IHRyaWFuZ3VsYXRlZC5wb3NpdGlvbnMubWFwKGZ1bmN0aW9uKHApIHtcbiAgICAgICAgcmV0dXJuIFtwWzBdLCBwWzFdLCAwXVxuICAgIH0pXG4gICAgcmV0dXJuIHRyaWFuZ3VsYXRlZFxufSIsInZhciBwYXJzZSA9IHJlcXVpcmUoJ3BhcnNlLXN2Zy1wYXRoJylcbnZhciBjb250b3VycyA9IHJlcXVpcmUoJ3N2Zy1wYXRoLWNvbnRvdXJzJylcbnZhciBzaW1wbGlmeSA9IHJlcXVpcmUoJ3NpbXBsaWZ5LXBhdGgnKVxudmFyIHRyaWFuZ3VsYXRlID0gcmVxdWlyZSgndHJpYW5ndWxhdGUtY29udG91cnMnKVxudmFyIG5vcm1hbGl6ZSA9IHJlcXVpcmUoJ25vcm1hbGl6ZS1wYXRoLXNjYWxlJylcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihjb250ZW50cykge1xuICAgIHZhciBwYXJzZWQgPSBwYXJzZShjb250ZW50cylcbiAgICBjb25zb2xlLmxvZyhwYXJzZWQsIGNvbnRlbnRzKVxuICAgIC8vZ2V0IGEgbGlzdCBvZiBwb2x5bGluZXMvY29udG91cnMgZnJvbSBzdmcgY29udGVudHNcbiAgICB2YXIgbGluZXMgPSBjb250b3VycyhwYXJzZWQpXG5cbiAgICAvL3NpbXBsaWZ5IHRoZSBjb250b3VycyBiZWZvcmUgdHJpYW5ndWxhdGlvblxuICAgIC8vIGxpbmVzID0gbGluZXMubWFwKGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAvLyAgICAgcmV0dXJuIHNpbXBsaWZ5KHBhdGgsIHRocmVzaG9sZClcbiAgICAvLyB9KVxuICAgIFxuICAgIC8vdHVybnMgaW50byB0cmlhbmdsZXMsIHJldHVybnMgeyBwb3NpdGlvbnMsIGNlbGxzIH1cbiAgICB2YXIgc2hhcGUgPSB0cmlhbmd1bGF0ZShsaW5lcylcblxuICAgIC8vbm9ybWFsaXplKHNoYXBlLnBvc2l0aW9ucylcblxuICAgIHNoYXBlLnBvc2l0aW9ucyA9IHNoYXBlLnBvc2l0aW9ucy5tYXAoZnVuY3Rpb24ocCkge1xuICAgICAgICByZXR1cm4gW3BbMF0sIHBbMV0sIDBdXG4gICAgfSlcbiAgICByZXR1cm4gc2hhcGVcbn0iLCIoZnVuY3Rpb24gKGdsb2JhbCl7XG52YXIgVEhSRUUgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdy5USFJFRSA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwuVEhSRUUgOiBudWxsKVxuXG52YXIgUmlnU2NlbmUgPSByZXF1aXJlKCcuL1JpZ1NjZW5lJylcbnZhciBPcmJpdENvbnRyb2xsZXIgPSByZXF1aXJlKCcuL3RocmVlLW9yYml0LWNhbWVyYScpKFRIUkVFKVxudmFyIEVmZmVjdHMgPSByZXF1aXJlKCcuL3NldHVwLWVmZmVjdHMnKVxuXG52YXIgVHdlZW5NYXggPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdy5Ud2Vlbk1heCA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwuVHdlZW5NYXggOiBudWxsKVxudmFyIGFuaW1hdGVMYWJlbHMgPSByZXF1aXJlKCcuL2FuaW1hdGUtbGFiZWxzJylcbnZhciBoaWRlTGFiZWxzID0gYW5pbWF0ZUxhYmVscy5oaWRlQWxsXG5cbnZhciBjbGFtcCA9IHJlcXVpcmUoJ2NsYW1wJylcbnZhciBwbHVjayA9IHJlcXVpcmUoJ3BsdWNrZXInKVxudmFyIG51bWJlciA9IHJlcXVpcmUoJ2FzLW51bWJlcicpXG52YXIgc21vb3Roc3RlcCA9IHJlcXVpcmUoJ3Ntb290aHN0ZXAnKVxudmFyIGxlcnAgPSByZXF1aXJlKCdsZXJwJylcbnZhciB1bmxlcnAgPSByZXF1aXJlKCd1bmxlcnAnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9wdCkge1xuICAgIG9wdCA9IG9wdHx8e31cblxuICAgIHZhciBGb250ID0gb3B0LmZvbnRcblxuICAgIGlmICghRm9udCB8fCAhRm9udC50ZXh0dXJlcylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtdXN0IHNwZWNpZnkgZm9udCB3aXRoIHRleHR1cmVzJylcblxuICAgIHZhciByZW5kZXJlcixcbiAgICAgICAgc2NlbmUsXG4gICAgICAgIHRleHRQYXNzLFxuICAgICAgICBjYW1lcmEsXG4gICAgICAgIGNvbnRyb2xsZXIsXG4gICAgICAgIGZlYXR1cmVzLFxuICAgICAgICB3YXRlcixcbiAgICAgICAgZWZmZWN0cyxcbiAgICAgICAgbGFiZWxzID0gW10sXG4gICAgICAgIHRpbWUgPSAwXG5cbiAgICBpZiAoIW9wdC5nbClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtdXN0IHNwZWNpZnkgR0wgY29udGV4dCcpXG5cbiAgICBzZXR1cChvcHQuZ2wsIG9wdC53aWR0aHx8MCwgb3B0LmhlaWdodHx8MClcblxuICAgIGZ1bmN0aW9uIGRyYXcoZHQpIHtcbiAgICAgICAgdGltZSArPSAgTWF0aC5taW4oZHQsIDMwKSAvIDEwMDBcbiAgICAgICAgcmVuZGVyZXIucmVzZXRBdHRyaWJ1dGVzKClcbiAgICAgICAgcmVuZGVyZXIucmVzZXRHTFN0YXRlKClcblxuICAgICAgICB3YXRlci5tYXRlcmlhbC51bmlmb3Jtcy50aW1lLnZhbHVlID0gdGltZSAqIDAuMVxuICAgICAgICB3YXRlci5yZW5kZXIoKVxuXG4gICAgICAgIGNvbnRyb2xsZXIudXBkYXRlKClcbiAgICAgICAgXG4gICAgICAgIHNjZW5lLnVwZGF0ZShkdClcbiAgICAgICAgaWYgKGVmZmVjdHMpXG4gICAgICAgICAgICBlZmZlY3RzLnJlbmRlcihkdClcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0ZXh0UGFzcy5yZW5kZXIocmVuZGVyZXIpXG4gICAgICAgIH1cblxuICAgICAgICBhbmltYXRlTGFiZWxzKGNvbnRyb2xsZXIsIGxhYmVscylcblxuICAgICAgICB2YXIgdCA9IHVubGVycCgwLjYsIDEuNCwgY29udHJvbGxlci5waGkpXG4gICAgICAgIHQgPSBzbW9vdGhzdGVwKDEuNCwgMC40NSwgdClcbiAgICAgICAgdmFyIHJhbmdlID0gY2xhbXAodCwgMCwgMSlcbiAgICAgICAgd2F0ZXIuYWxwaGEgPSByYW5nZXx8MFxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldHVwKGdsLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHJlbmRlcmVyID0gbmV3IFRIUkVFLldlYkdMUmVuZGVyZXIoeyBcbiAgICAgICAgICAgIGNhbnZhczogZ2wuY2FudmFzLFxuICAgICAgICAgICAgYW50aWFsaWFzOiBmYWxzZSxcbiAgICAgICAgICAgIGFscGhhOiBmYWxzZVxuICAgICAgICB9KVxuICAgICAgICByZW5kZXJlci5zZXRDbGVhckNvbG9yKDB4ZmZmZmZmLCAwKVxuICAgICAgICByZW5kZXJlci5zaGFkb3dNYXBUeXBlID0gVEhSRUUuQmFzaWNTaGFkb3dNYXBcbiAgICAgICAgLy8gcmVuZGVyZXIuc2hhZG93TWFwRW5hYmxlZCA9IHRydWVcblxuICAgICAgICBvcHQuZm92ID0gbnVtYmVyKG9wdC5mb3YsIDUwKVxuICAgICAgICBjYW1lcmEgPSBuZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEob3B0LmZvdiwgd2lkdGgvaGVpZ2h0LCAwLjUsIDIwMDAwKVxuICAgICAgICBjYW1lcmEucG9zaXRpb24ueCA9IC02MFxuICAgICAgICBjYW1lcmEucG9zaXRpb24ueiA9IC00MFxuICAgICAgICBjYW1lcmEucG9zaXRpb24ueSA9IDM4XG4gICAgICAgIGNhbWVyYS5sb29rQXQobmV3IFRIUkVFLlZlY3RvcjMoKSlcblxuICAgICAgICBjb250cm9sbGVyID0gbmV3IE9yYml0Q29udHJvbGxlcihjYW1lcmEpXG4gICAgICAgIGNvbnRyb2xsZXIudXNlclBhbiA9IGZhbHNlXG4gICAgICAgIGNvbnRyb2xsZXIudXNlclBhblNwZWVkID0gMC4wXG4gICAgICAgIGNvbnRyb2xsZXIuem9vbVNwZWVkID0gMC4xXG4gICAgICAgIGNvbnRyb2xsZXIucm90YXRlU3BlZWQgPSAwLjJcbiAgICAgICAgY29udHJvbGxlci5taW5EaXN0YW5jZSA9IDMwXG4gICAgICAgIGNvbnRyb2xsZXIubWF4RGlzdGFuY2UgPSAyMDAuMFxuICAgICAgICBjb250cm9sbGVyLm1heFBvbGFyQW5nbGUgPSA5MCAqIE1hdGguUEkvMTgwXG4gICAgICAgIGNvbnRyb2xsZXIubWluUG9sYXJBbmdsZSA9IDQwICogTWF0aC5QSS8xODBcbiAgICAgICAgY29udHJvbGxlci5jZW50ZXIuc2V0KCAwLCA1LCAwIClcbiAgICAgICAgc2NlbmUgPSBSaWdTY2VuZSgpXG5cbiAgICAgICAgcmVxdWlyZSgnLi9zZXR1cC1mbG9vcicpKHNjZW5lKVxuXG4gICAgICAgIHdhdGVyID0gcmVxdWlyZSgnLi9zZXR1cC13YXRlcicpKHJlbmRlcmVyLCBjYW1lcmEsIHNjZW5lKVxuICAgICAgICBcbiAgICAgICAgc2NlbmUuY3ViZU1hcCA9IHdhdGVyLmN1YmVNYXBcbiAgICAgICAgc2NlbmUudXBkYXRlTWF0ZXJpYWwoKVxuXG4gICAgICAgIHZhciBwYXNzID0gcmVxdWlyZSgnLi9jcmVhdGUtdGV4dC1wYXNzJykoe1xuICAgICAgICAgICAgcmVuZGVyZXI6IHJlbmRlcmVyLFxuICAgICAgICAgICAgc2NlbmU6IHNjZW5lLFxuICAgICAgICAgICAgY2FtZXJhOiBjYW1lcmEsXG4gICAgICAgICAgICBmb250OiBGb250XG4gICAgICAgIH0pXG5cbiAgICAgICAgdGV4dFBhc3MgPSBwYXNzXG4gICAgICAgIGxhYmVscyA9IHBhc3MuZ3JvdXBzXG5cbiAgICAgICAgZWZmZWN0cyA9IEVmZmVjdHMoe1xuICAgICAgICAgICAgcmVuZGVyZXI6IHJlbmRlcmVyLFxuICAgICAgICAgICAgc2NlbmU6IHNjZW5lLFxuICAgICAgICAgICAgY2FtZXJhOiBjYW1lcmEsXG4gICAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgICBibHVyOiBmYWxzZSxcbiAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICAgICAgcmVuZGVyUGFzczogcGFzc1xuICAgICAgICB9KVxuXG4gICAgICAgIGhpZGVMYWJlbHMobGFiZWxzKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhbmRsZVJlc2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHJlbmRlcmVyLnNldFNpemUod2lkdGgsIGhlaWdodClcbiAgICAgICAgY2FtZXJhLmFzcGVjdCA9IHdpZHRoL2hlaWdodFxuICAgICAgICBjYW1lcmEudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpXG5cbiAgICAgICAgaWYgKGVmZmVjdHMpXG4gICAgICAgICAgICBlZmZlY3RzLnJlc2l6ZSh3aWR0aCwgaGVpZ2h0KVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIGRyYXc6IGRyYXcsXG4gICAgICAgIHJlc2l6ZTogaGFuZGxlUmVzaXplXG4gICAgfVxufVxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pIiwiKGZ1bmN0aW9uIChnbG9iYWwpe1xudmFyIFRIUkVFID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cuVEhSRUUgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsLlRIUkVFIDogbnVsbClcbnZhciBFZmZlY3RDb21wb3NlciA9IHJlcXVpcmUoJ3RocmVlLWVmZmVjdGNvbXBvc2VyJykoVEhSRUUpXG52YXIgY3JlYXRlRlhBQSA9IHJlcXVpcmUoJ3RocmVlLXNoYWRlci1meGFhJykoVEhSRUUpXG52YXIgY3JlYXRlQmx1ciA9IHJlcXVpcmUoJy4vc2hhZGVycy9ibHVyJylcbnZhciBjcmVhdGVMZW5zID0gcmVxdWlyZSgnLi9zaGFkZXJzL2xlbnMnKVxudmFyIGNyZWF0ZUVtcHR5ID0gcmVxdWlyZSgnLi9zaGFkZXJzL3Bhc3MnKVxuLy8gdmFyIFRleHRQYXNzID0gcmVxdWlyZSgnLi9UZXh0UGFzcycpXG5cbm1vZHVsZS5leHBvcnRzID0gRWZmZWN0c1xuXG5mdW5jdGlvbiBFZmZlY3RzKG9wdCkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBFZmZlY3RzKSkgXG4gICAgICAgIHJldHVybiBuZXcgRWZmZWN0cyhvcHQpXG4gICAgb3B0ID0gb3B0fHx7fVxuXG4gICAgdmFyIHBhcmFtZXRlcnMgPSB7IFxuICAgICAgICBtaW5GaWx0ZXI6IFRIUkVFLkxpbmVhckZpbHRlciwgXG4gICAgICAgIG1hZ0ZpbHRlcjogVEhSRUUuTGluZWFyRmlsdGVyLCBcbiAgICAgICAgZm9ybWF0OiBUSFJFRS5SR0JGb3JtYXQsIFxuICAgICAgICBzdGVuY2lsQnVmZmVyOiBmYWxzZSBcbiAgICB9XG4gICAgdmFyIHdpZHRoID0gb3B0LndpZHRoXG4gICAgdmFyIGhlaWdodCA9IG9wdC5oZWlnaHRcbiAgICB2YXIgcmVuZGVyVGFyZ2V0ID0gbmV3IFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0KHdpZHRoLCBoZWlnaHQsIHBhcmFtZXRlcnMpO1xuXG4gICAgdGhpcy5jb21wb3NlciA9IG5ldyBFZmZlY3RDb21wb3NlcihvcHQucmVuZGVyZXIsIHJlbmRlclRhcmdldClcbiAgICB0aGlzLmNvbXBvc2VyLmFkZFBhc3Mob3B0LnJlbmRlclBhc3MpXG4gICAgXG4gICAgdGhpcy5zaGFkZXJzID0gW11cbiAgICB0aGlzLm5vaXNlRGVsYXkgPSAzM1xuICAgIHRoaXMubm9pc2VUaW1lID0gMFxuXG4gICAgLy8gdGhpcy5zaGFkZXJzLnB1c2gobmV3IEVmZmVjdENvbXBvc2VyLlNoYWRlclBhc3MoY3JlYXRlRW1wdHkoKSkpXG5cblxuICAgIHZhciBmeGFhU2hhZGVyID0gbmV3IEVmZmVjdENvbXBvc2VyLlNoYWRlclBhc3MoY3JlYXRlRlhBQSgpKVxuICAgIHRoaXMuc2hhZGVycy5wdXNoKGZ4YWFTaGFkZXIpXG5cbiAgICBpZiAob3B0LmJsdXIgIT09IGZhbHNlKSB7XG4gICAgICAgIHZhciBibHVyID0gY3JlYXRlQmx1cigpXG4gICAgICAgIHZhciBpdGVyYXRpb25zID0gMTtcbiAgICAgICAgZm9yICh2YXIgaT0wOyBpPGl0ZXJhdGlvbnM7IGkrKykge1xuICAgICAgICAgICAgdmFyIHIgPSAoaSsxKSoyO1xuXG4gICAgICAgICAgICB2YXIgaG9yaXogPSBuZXcgRWZmZWN0Q29tcG9zZXIuU2hhZGVyUGFzcyggYmx1ciApO1xuICAgICAgICAgICAgaG9yaXoudW5pZm9ybXMucmFkaXVzLnZhbHVlID0gclxuICAgICAgICAgICAgaG9yaXoudW5pZm9ybXMuc3RyZW5ndGgudmFsdWUgPSAxXG4gICAgICAgICAgICBob3Jpei51bmlmb3Jtcy5kaXIudmFsdWUuc2V0KDEsMClcblxuICAgICAgICAgICAgdmFyIHZlcnQgPSBuZXcgRWZmZWN0Q29tcG9zZXIuU2hhZGVyUGFzcyggYmx1ciApO1xuICAgICAgICAgICAgdmVydC51bmlmb3Jtcy5yYWRpdXMudmFsdWUgPSByXG4gICAgICAgICAgICB2ZXJ0LnVuaWZvcm1zLnN0cmVuZ3RoLnZhbHVlID0gMVxuICAgICAgICAgICAgdmVydC51bmlmb3Jtcy5kaXIudmFsdWUuc2V0KDAsMSlcblxuICAgICAgICAgICAgdGhpcy5zaGFkZXJzLnB1c2goaG9yaXosIHZlcnQpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbGVuc1Bhc3MgPSBuZXcgRWZmZWN0Q29tcG9zZXIuU2hhZGVyUGFzcyhjcmVhdGVMZW5zKCkpXG4gICAgdGhpcy5zaGFkZXJzLnB1c2gobGVuc1Bhc3MpXG5cbiAgICAvL2RlZmF1bHQgdmFsdWVzIHRvIGF2b2lkIGRpdiBieSB6ZXJvXG4gICAgbGVuc1Bhc3MudW5pZm9ybXMub3ZlcmxheVJlc29sdXRpb24udmFsdWUuc2V0KDEsIDEpXG4gICAgbGVuc1Bhc3MudW5pZm9ybXMudExvb2t1cC52YWx1ZSA9IGxvYWRUZXh0dXJlKCdpbWcvbG9va3VwLnBuZycsIHsgXG4gICAgICAgIGdlbmVyYXRlTWlwbWFwczogZmFsc2UsXG4gICAgICAgIGZpbHRlcjogVEhSRUUuTGluZWFyRmlsdGVyIFxuICAgIH0pXG4gICAgbGVuc1Bhc3MudW5pZm9ybXMudE92ZXJsYXkudmFsdWUgPSBsb2FkVGV4dHVyZSgnaW1nL2R1c3QuanBnJywge1xuICAgICAgICBnZW5lcmF0ZU1pcG1hcHM6IGZhbHNlLFxuICAgICAgICBmaWx0ZXI6IFRIUkVFLkxpbmVhckZpbHRlclxuICAgIH0sIGZ1bmN0aW9uKGVyciwgdGV4KSB7XG4gICAgICAgIGxlbnNQYXNzLnVuaWZvcm1zLm92ZXJsYXlSZXNvbHV0aW9uLnZhbHVlLnNldCh0ZXguaW1hZ2Uud2lkdGgsIHRleC5pbWFnZS5oZWlnaHQpXG4gICAgfSlcblxuICAgIHRoaXMuc2hhZGVycy5mb3JFYWNoKGZ1bmN0aW9uKHBhc3MsIGksIHNlbGYpIHtcbiAgICAgICAgdGhpcy5jb21wb3Nlci5hZGRQYXNzKHBhc3MpXG4gICAgICAgIGlmIChpID09PSBzZWxmLmxlbmd0aC0xKVxuICAgICAgICAgICAgcGFzcy5yZW5kZXJUb1NjcmVlbiA9IHRydWVcbiAgICB9LCB0aGlzKSAgXG4gICAgaWYgKG9wdC53aWR0aCAmJiBvcHQuaGVpZ2h0KSBcbiAgICAgICAgdGhpcy5yZXNpemUob3B0LndpZHRoLCBvcHQuaGVpZ2h0KVxufVxuXG5cbmZ1bmN0aW9uIGxvYWRUZXh0dXJlKHBhdGgsIG9wdCwgY2IpIHtcbiAgICBpZiAodHlwZW9mIG9wdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjYiA9IG9wdFxuICAgICAgICBvcHQgPSB7fVxuICAgIH1cblxuICAgIHJldHVybiBUSFJFRS5JbWFnZVV0aWxzLmxvYWRUZXh0dXJlKHBhdGgsIHVuZGVmaW5lZCwgZnVuY3Rpb24odGV4KSB7XG4gICAgICAgIGlmIChvcHQuZmlsdGVyKSB0ZXgubWluRmlsdGVyID0gdGV4Lm1hZ0ZpbHRlciA9IG9wdC5maWx0ZXJcbiAgICAgICAgaWYgKG9wdC53cmFwKSB0ZXgud3JhcFMgPSB0ZXgud3JhcFQgPSBvcHQud3JhcFxuICAgICAgICB0ZXguZ2VuZXJhdGVNaXBtYXBzID0gb3B0LmdlbmVyYXRlTWlwbWFwc1xuICAgICAgICBpZiAodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKSBcbiAgICAgICAgICAgIGNiKG51bGwsIHRleClcbiAgICB9KVxufVxuXG5yZXF1aXJlKCdtaXhlcycpKEVmZmVjdHMsIHtcblxuICAgIHJlbmRlcjogZnVuY3Rpb24oZHQpIHtcbiAgICAgICAgdGhpcy5ub2lzZVRpbWUgKz0gZHRcbiAgICAgICAgaWYgKHRoaXMubm9pc2VUaW1lID4gdGhpcy5ub2lzZURlbGF5KSB7XG4gICAgICAgICAgICB0aGlzLm5vaXNlVGltZSA9IDBcbiAgICAgICAgICAgIHRoaXMuc2hhZGVycy5mb3JFYWNoKGZ1bmN0aW9uKHBhc3MpIHtcbiAgICAgICAgICAgICAgICBpZiAocGFzcy51bmlmb3Jtcy50aWNrKVxuICAgICAgICAgICAgICAgICAgICBwYXNzLnVuaWZvcm1zLnRpY2sudmFsdWUgKz0gMC4wMDVcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNvbXBvc2VyLnJlbmRlcigpXG4gICAgfSxcblxuICAgIHJlc2l6ZTogZnVuY3Rpb24od2lkdGgsIGhlaWdodCkge1xuICAgICAgICB3aWR0aCAqPSAyXG4gICAgICAgIGhlaWdodCAqPSAyXG4gICAgICAgIHRoaXMuY29tcG9zZXIuc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KVxuICAgICAgICB0aGlzLnNoYWRlcnMuZm9yRWFjaChmdW5jdGlvbihwYXNzKSB7XG4gICAgICAgICAgICB2YXIgZHByID0gMVxuICAgICAgICAgICAgLy8gdmFyIGRwciA9ICh3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpb3x8MSlcbiAgICAgICAgICAgIGlmIChwYXNzLnVuaWZvcm1zLnJlc29sdXRpb24pXG4gICAgICAgICAgICAgICAgcGFzcy51bmlmb3Jtcy5yZXNvbHV0aW9uLnZhbHVlLnNldCh3aWR0aCpkcHIsIGhlaWdodCpkcHIpXG4gICAgICAgICAgICBcbiAgICAgICAgfSlcbiAgICB9XG59KVxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pIiwiKGZ1bmN0aW9uIChnbG9iYWwpe1xudmFyIHJhbmRvbSA9IHJlcXVpcmUoJ3JhbmRmJylcbnZhciBUSFJFRSA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93LlRIUkVFIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbC5USFJFRSA6IG51bGwpXG52YXIgc21vb3Roc3RlcCA9IHJlcXVpcmUoJ3Ntb290aHN0ZXAnKVxudmFyIGxlcnAgPSByZXF1aXJlKCdsZXJwJylcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihzY2VuZSkge1xuICAgIHZhciBnZW8gPSBuZXcgVEhSRUUuUGxhbmVHZW9tZXRyeSgxMDAsIDEwMCwgNDAsIDQwKVxuICAgIHZhciB2ZWMyID0gbmV3IFRIUkVFLlZlY3RvcjIoKVxuICAgIGdlby52ZXJ0aWNlcy5mb3JFYWNoKGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgdmFyIGxlbiA9IHZlYzIuc2V0KHYueCwgdi55KS5sZW5ndGgoKSAvIDUwXG4gICAgICAgIHZhciBzbGVuID0gc21vb3Roc3RlcCgwLjQsIDEuMCwgbGVuKVxuICAgICAgICB2LnogPSByYW5kb20oLTIwLCAzNSkgKiBzbGVuIFxuXG4gICAgICAgIHNsZW4gPSBzbW9vdGhzdGVwKDAuNywgMS4wLCBsZW4pXG4gICAgICAgIHZhciBMID0gbGVycCgwLjIsIDEuMCwgc2xlbilcbiAgICAgICAgdmFyIGNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKEwsIEwsIEwpXG4gICAgICAgIGdlby5jb2xvcnMucHVzaChjb2xvcilcbiAgICB9KVxuXG4gICAgZ2VvLmZhY2VzLmZvckVhY2goZnVuY3Rpb24oZmFjZSkge1xuICAgICAgICBmYWNlLnZlcnRleENvbG9yc1swXSA9IGdlby5jb2xvcnNbZmFjZS5hXVxuICAgICAgICBmYWNlLnZlcnRleENvbG9yc1sxXSA9IGdlby5jb2xvcnNbZmFjZS5iXVxuICAgICAgICBmYWNlLnZlcnRleENvbG9yc1syXSA9IGdlby5jb2xvcnNbZmFjZS5jXVxuICAgIH0pXG5cbiAgICB2YXIgdGV4ID0gVEhSRUUuSW1hZ2VVdGlscy5sb2FkVGV4dHVyZSgnaW1nL3Nub3cuanBnJylcbiAgICB0ZXgucmVwZWF0LnNldCgxLCAxKVxuICAgIHRleC53cmFwUyA9IHRleC53cmFwVCA9IFRIUkVFLlJlcGVhdFdyYXBwaW5nXG5cbiAgICB2YXIgbWF0ID0gbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKHsgXG4gICAgICAgIG1hcDogdGV4LFxuICAgICAgICB2ZXJ0ZXhDb2xvcnM6IFRIUkVFLlZlcnRleENvbG9ycyBcbiAgICAgICAgLy8gY29sb3I6IFwicmdiKDE1MCwxNTAsMTUwKVwiXG4gICAgfSlcbiAgICB2YXIgbWVzaCA9IG5ldyBUSFJFRS5NZXNoKGdlbywgbWF0KVxuICAgIG1lc2gucm90YXRpb24ueCA9IC1NYXRoLlBJLzJcbiAgICBtZXNoLnBvc2l0aW9uLnkgPSAtMjVcbiAgICB2YXIgc3RyZXRjaCA9IDEwXG4gICAgbWVzaC5zY2FsZS54ID0gbWVzaC5zY2FsZS55ID0gc3RyZXRjaFxuICAgIHNjZW5lLmFkZChtZXNoKVxuXG4gICAgd2luZG93LmZsb29yID0gbWVzaFxufVxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pIiwidmFyIGN1YmVTaGFkZXIgPSB7XG5cbiAgICB1bmlmb3JtczogVEhSRUUuVW5pZm9ybXNVdGlscy5tZXJnZSggW1xuICAgICAgICB7IFwidEN1YmVcIjogeyB0eXBlOiBcInRcIiwgdmFsdWU6IG51bGwgfSxcbiAgICAgICAgXCJ0RmxpcFwiOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogLSAxIH0gfSxcbiAgICAgICAgVEhSRUUuVW5pZm9ybXNMaWJbIFwiZm9nXCIgXVxuICAgIF0gKSxcblxuICAgIHZlcnRleFNoYWRlcjogW1xuXG4gICAgICAgIFwidmFyeWluZyB2ZWMzIHZXb3JsZFBvc2l0aW9uO1wiLFxuXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4XCIgXSxcblxuICAgICAgICBcInZvaWQgbWFpbigpIHtcIixcblxuICAgICAgICBcIiAgIHZlYzQgd29ybGRQb3NpdGlvbiA9IG1vZGVsTWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApO1wiLFxuICAgICAgICBcIiAgIHZXb3JsZFBvc2l0aW9uID0gd29ybGRQb3NpdGlvbi54eXo7XCIsXG5cbiAgICAgICAgXCIgICBnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XCIsXG5cbiAgICAgICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3ZlcnRleFwiIF0sXG5cbiAgICAgICAgXCJ9XCJcblxuICAgIF0uam9pbihcIlxcblwiKSxcblxuICAgIGZyYWdtZW50U2hhZGVyOiBbXG5cbiAgICAgICAgXCJ1bmlmb3JtIHNhbXBsZXJDdWJlIHRDdWJlO1wiLFxuICAgICAgICBcInVuaWZvcm0gZmxvYXQgdEZsaXA7XCIsXG5cbiAgICAgICAgXCJ2YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247XCIsXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnRcIiBdLFxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJmb2dfcGFyc19mcmFnbWVudFwiIF0sXG4gICAgICAgIFwidm9pZCBtYWluKCkge1wiLFxuICAgICAgICBcIiAgIGdsX0ZyYWdDb2xvciA9IHRleHR1cmVDdWJlKCB0Q3ViZSwgdmVjMyggdEZsaXAgKiB2V29ybGRQb3NpdGlvbi54LCB2V29ybGRQb3NpdGlvbi55eiApICk7XCIsXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9mcmFnbWVudFwiIF0sXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJmb2dfZnJhZ21lbnRcIiBdLFxuICAgICAgICBcIn1cIlxuXG4gICAgXS5qb2luKFwiXFxuXCIpXG5cbn1cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ocmVuZGVyZXIsIGNhbWVyYSwgc2NlbmUpIHtcbiAgICB2YXIgbGlnaHQgPSBuZXcgVEhSRUUuSGVtaXNwaGVyZUxpZ2h0KDB4YmJlOWZmLCAweDA4MDgyMCwgMSlcbiAgICBsaWdodC5wb3NpdGlvbi5zZXQoLTEsIDEsIC0xKVxuICAgIHNjZW5lLmFkZChsaWdodClcblxuICAgIHZhciB3YXRlck5vcm1hbHMgPSBuZXcgVEhSRUUuSW1hZ2VVdGlscy5sb2FkVGV4dHVyZSgnaW1nL3dhdGVybm9ybWFsczUuanBnJylcbiAgICB3YXRlck5vcm1hbHMud3JhcFMgPSB3YXRlck5vcm1hbHMud3JhcFQgPSBUSFJFRS5SZXBlYXRXcmFwcGluZ1xuXG4gICAgdmFyIHdhdGVyID0gbmV3IFRIUkVFLldhdGVyKHJlbmRlcmVyLCBjYW1lcmEsIHNjZW5lLCB7XG4gICAgICAgIHRleHR1cmVXaWR0aDogNTEyLFxuICAgICAgICB0ZXh0dXJlSGVpZ2h0OiA1MTIsXG4gICAgICAgIHdhdGVyTm9ybWFsczogd2F0ZXJOb3JtYWxzLFxuICAgICAgICBhbHBoYTogMC45LFxuICAgICAgICBzdW5EaXJlY3Rpb246IGxpZ2h0LnBvc2l0aW9uLmNsb25lKCkubm9ybWFsaXplKCksXG4gICAgICAgIHN1bkNvbG9yOiAweGZmZmZmZixcbiAgICAgICAgd2F0ZXJDb2xvcjogMHgwMjBkMTUsXG4gICAgICAgIGRpc3RvcnRpb25TY2FsZTogODAuMCxcbiAgICB9KVxuXG4gICAgdmFyIG1pcnJvck1lc2ggPSBuZXcgVEhSRUUuTWVzaChcbiAgICAgICAgbmV3IFRIUkVFLlBsYW5lQnVmZmVyR2VvbWV0cnkoNTAwMCwgNTAwMCksXG4gICAgICAgIHdhdGVyLm1hdGVyaWFsXG4gICAgKVxuXG4gICAgbWlycm9yTWVzaC5hZGQod2F0ZXIpXG4gICAgbWlycm9yTWVzaC5yb3RhdGlvbi54ID0gLU1hdGguUEkgKiAwLjVcbiAgICBzY2VuZS5hZGQobWlycm9yTWVzaClcblxuXG4gICAgLy8gbG9hZCBza3lib3hcblxuICAgIHZhciBjdWJlTWFwID0gbmV3IFRIUkVFLkN1YmVUZXh0dXJlKFtdKVxuICAgIGN1YmVNYXAuZm9ybWF0ID0gVEhSRUUuUkdCRm9ybWF0XG4gICAgY3ViZU1hcC5mbGlwWSA9IGZhbHNlXG5cbiAgICB2YXIgbG9hZGVyID0gbmV3IFRIUkVFLkltYWdlTG9hZGVyKClcbiAgICBsb2FkZXIubG9hZCgnaW1nL2Nsb3VkeV9uaWdodDIuanBnJywgZnVuY3Rpb24oaW1hZ2UpIHtcblxuICAgICAgICB2YXIgZ2V0U2lkZSA9IGZ1bmN0aW9uKHgsIHkpIHtcblxuICAgICAgICAgICAgdmFyIHNpemUgPSAxMDI0XG5cbiAgICAgICAgICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKVxuICAgICAgICAgICAgY2FudmFzLndpZHRoID0gc2l6ZVxuICAgICAgICAgICAgY2FudmFzLmhlaWdodCA9IHNpemVcblxuICAgICAgICAgICAgdmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKVxuICAgICAgICAgICAgY29udGV4dC5kcmF3SW1hZ2UoaW1hZ2UsIC14ICogc2l6ZSwgLXkgKiBzaXplKVxuXG4gICAgICAgICAgICByZXR1cm4gY2FudmFzXG5cbiAgICAgICAgfVxuXG4gICAgICAgIGN1YmVNYXAuaW1hZ2VzWzBdID0gZ2V0U2lkZSgyLCAxKSAvLyBweFxuICAgICAgICBjdWJlTWFwLmltYWdlc1sxXSA9IGdldFNpZGUoMCwgMSkgLy8gbnhcbiAgICAgICAgY3ViZU1hcC5pbWFnZXNbMl0gPSBnZXRTaWRlKDEsIDApIC8vIHB5XG4gICAgICAgIGN1YmVNYXAuaW1hZ2VzWzNdID0gZ2V0U2lkZSgxLCAyKSAvLyBueVxuICAgICAgICBjdWJlTWFwLmltYWdlc1s0XSA9IGdldFNpZGUoMSwgMSkgLy8gcHpcbiAgICAgICAgY3ViZU1hcC5pbWFnZXNbNV0gPSBnZXRTaWRlKDMsIDEpIC8vIG56XG4gICAgICAgIGN1YmVNYXAubmVlZHNVcGRhdGUgPSB0cnVlXG5cbiAgICB9KVxuXG4gICAgY3ViZVNoYWRlci51bmlmb3Jtcy50Q3ViZS52YWx1ZSA9IGN1YmVNYXBcblxuICAgIHZhciBza3lCb3hNYXRlcmlhbCA9IG5ldyBUSFJFRS5TaGFkZXJNYXRlcmlhbCh7XG4gICAgICAgIGZyYWdtZW50U2hhZGVyOiBjdWJlU2hhZGVyLmZyYWdtZW50U2hhZGVyLFxuICAgICAgICB2ZXJ0ZXhTaGFkZXI6IGN1YmVTaGFkZXIudmVydGV4U2hhZGVyLFxuICAgICAgICB1bmlmb3JtczogY3ViZVNoYWRlci51bmlmb3JtcyxcbiAgICAgICAgLy8gZGVwdGhXcml0ZTogZmFsc2UsXG4gICAgICAgIHNpZGU6IFRIUkVFLkJhY2tTaWRlLFxuICAgICAgICBmb2c6IHRydWUsXG4gICAgfSlcblxuICAgIHZhciBza3lCb3ggPSBuZXcgVEhSRUUuTWVzaChcbiAgICAgICAgbmV3IFRIUkVFLkJveEdlb21ldHJ5KDUwMDAsIDUwMDAsIDUwMDApLFxuICAgICAgICBza3lCb3hNYXRlcmlhbFxuICAgIClcbiAgICBcbiAgICB3YXRlci5jdWJlTWFwID0gY3ViZU1hcFxuXG4gICAgc2NlbmUuYWRkKHNreUJveClcbiAgICByZXR1cm4gd2F0ZXJcbn0iLCJ2YXIgZ2xzbGlmeSA9IHJlcXVpcmUoXCJnbHNsaWZ5XCIpO1xudmFyIHNvdXJjZSA9IHJlcXVpcmUoXCJnbHNsaWZ5L3NpbXBsZS1hZGFwdGVyLmpzXCIpKFwiXFxuI2RlZmluZSBHTFNMSUZZIDFcXG5cXG52YXJ5aW5nIHZlYzIgdlV2O1xcbnZvaWQgbWFpbigpIHtcXG4gIHZVdiA9IHV2O1xcbiAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNChwb3NpdGlvbiwgMS4wKTtcXG59XCIsIFwiXFxuI2RlZmluZSBHTFNMSUZZIDFcXG5cXG51bmlmb3JtIHZlYzIgcmVzb2x1dGlvbjtcXG51bmlmb3JtIGZsb2F0IHJhZGl1cztcXG51bmlmb3JtIHZlYzIgZGlyO1xcbnVuaWZvcm0gZmxvYXQgc3RyZW5ndGg7XFxudW5pZm9ybSBzYW1wbGVyMkQgdERpZmZ1c2U7XFxudmFyeWluZyB2ZWMyIHZVdjtcXG52ZWM0IGFfeF9ibHVyKHNhbXBsZXIyRCB0ZXgsIHZlYzIgdXYsIHZlYzIgYmx1ciwgdmVjMiBkaXJlY3Rpb24pIHtcXG4gIHZlYzQgc3VtID0gdmVjNCgwLjApO1xcbiAgc3VtICs9IHRleHR1cmUyRCh0ZXgsIHZlYzIodXYueCAtIDQuMCAqIGJsdXIueCAqIGRpcmVjdGlvbi54LCB1di55IC0gNC4wICogYmx1ci55ICogZGlyZWN0aW9uLnkpKSAqIDAuMDE2MjE2MjE2MjtcXG4gIHN1bSArPSB0ZXh0dXJlMkQodGV4LCB2ZWMyKHV2LnggLSAzLjAgKiBibHVyLnggKiBkaXJlY3Rpb24ueCwgdXYueSAtIDMuMCAqIGJsdXIueSAqIGRpcmVjdGlvbi55KSkgKiAwLjA1NDA1NDA1NDE7XFxuICBzdW0gKz0gdGV4dHVyZTJEKHRleCwgdmVjMih1di54IC0gMi4wICogYmx1ci54ICogZGlyZWN0aW9uLngsIHV2LnkgLSAyLjAgKiBibHVyLnkgKiBkaXJlY3Rpb24ueSkpICogMC4xMjE2MjE2MjE2O1xcbiAgc3VtICs9IHRleHR1cmUyRCh0ZXgsIHZlYzIodXYueCAtIDEuMCAqIGJsdXIueCAqIGRpcmVjdGlvbi54LCB1di55IC0gMS4wICogYmx1ci55ICogZGlyZWN0aW9uLnkpKSAqIDAuMTk0NTk0NTk0NjtcXG4gIHN1bSArPSB0ZXh0dXJlMkQodGV4LCB2ZWMyKHV2LngsIHV2LnkpKSAqIDAuMjI3MDI3MDI3MDtcXG4gIHN1bSArPSB0ZXh0dXJlMkQodGV4LCB2ZWMyKHV2LnggKyAxLjAgKiBibHVyLnggKiBkaXJlY3Rpb24ueCwgdXYueSArIDEuMCAqIGJsdXIueSAqIGRpcmVjdGlvbi55KSkgKiAwLjE5NDU5NDU5NDY7XFxuICBzdW0gKz0gdGV4dHVyZTJEKHRleCwgdmVjMih1di54ICsgMi4wICogYmx1ci54ICogZGlyZWN0aW9uLngsIHV2LnkgKyAyLjAgKiBibHVyLnkgKiBkaXJlY3Rpb24ueSkpICogMC4xMjE2MjE2MjE2O1xcbiAgc3VtICs9IHRleHR1cmUyRCh0ZXgsIHZlYzIodXYueCArIDMuMCAqIGJsdXIueCAqIGRpcmVjdGlvbi54LCB1di55ICsgMy4wICogYmx1ci55ICogZGlyZWN0aW9uLnkpKSAqIDAuMDU0MDU0MDU0MTtcXG4gIHN1bSArPSB0ZXh0dXJlMkQodGV4LCB2ZWMyKHV2LnggKyA0LjAgKiBibHVyLnggKiBkaXJlY3Rpb24ueCwgdXYueSArIDQuMCAqIGJsdXIueSAqIGRpcmVjdGlvbi55KSkgKiAwLjAxNjIxNjIxNjI7XFxuICByZXR1cm4gc3VtO1xcbn1cXG52b2lkIG1haW4oKSB7XFxuICB2ZWMyIGJsdXJBbXQgPSB2ZWMyKHJhZGl1cykgLyByZXNvbHV0aW9uO1xcbiAgdmVjNCBzdW0gPSBhX3hfYmx1cih0RGlmZnVzZSwgdlV2LCBibHVyQW10LCBkaXIpO1xcbiAgdmVjMiBwID0gKGdsX0ZyYWdDb29yZC54eSAvIHJlc29sdXRpb24ueHkgLSAwLjUpO1xcbiAgcC54ICo9IHJlc29sdXRpb24ueCAvIHJlc29sdXRpb24ueTtcXG4gIGZsb2F0IGxlbiA9IHNtb290aHN0ZXAoMC41LCAxLjIsIGxlbmd0aChwKSk7XFxuICB2ZWMzIG9yaWcgPSB0ZXh0dXJlMkQodERpZmZ1c2UsIHZVdikucmdiO1xcbiAgZ2xfRnJhZ0NvbG9yLnJnYiA9IG1peChvcmlnLCBzdW0ucmdiLCBsZW4gKyAwLjEpO1xcbiAgZ2xfRnJhZ0NvbG9yLmEgPSAxLjA7XFxufVwiLCBbe1wibmFtZVwiOlwicmVzb2x1dGlvblwiLFwidHlwZVwiOlwidmVjMlwifSx7XCJuYW1lXCI6XCJyYWRpdXNcIixcInR5cGVcIjpcImZsb2F0XCJ9LHtcIm5hbWVcIjpcImRpclwiLFwidHlwZVwiOlwidmVjMlwifSx7XCJuYW1lXCI6XCJzdHJlbmd0aFwiLFwidHlwZVwiOlwiZmxvYXRcIn0se1wibmFtZVwiOlwidERpZmZ1c2VcIixcInR5cGVcIjpcInNhbXBsZXIyRFwifV0sIFtdKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vY3JlYXRlXCIpKHNvdXJjZSk7IiwiKGZ1bmN0aW9uIChnbG9iYWwpe1xudmFyIFRIUkVFID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cuVEhSRUUgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsLlRIUkVFIDogbnVsbClcbnZhciB0aHJlZWlmeSA9IHJlcXVpcmUoJ3RocmVlLWdsc2xpZnknKShUSFJFRSlcbnZhciB4dGVuZCA9IHJlcXVpcmUoJ3h0ZW5kJykgXG4gXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHNvdXJjZSkge1xuICAgIHJldHVybiBmdW5jdGlvbihvcHQpIHtcbiAgICAgICAgcmV0dXJuIHh0ZW5kKHRocmVlaWZ5KHNvdXJjZSksIG9wdClcbiAgICB9XG59XG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSkiLCJ2YXIgZ2xzbGlmeSA9IHJlcXVpcmUoXCJnbHNsaWZ5XCIpO1xudmFyIHNvdXJjZSA9IHJlcXVpcmUoXCJnbHNsaWZ5L3NpbXBsZS1hZGFwdGVyLmpzXCIpKFwiXFxuI2RlZmluZSBHTFNMSUZZIDFcXG5cXG51bmlmb3JtIHZlYzIgb3ZlcmxheVJlc29sdXRpb247XFxudW5pZm9ybSB2ZWMyIHJlc29sdXRpb247XFxudmFyeWluZyB2ZWMyIHZVdjtcXG52YXJ5aW5nIHZlYzIgb3ZlcmxheVVWO1xcbnZvaWQgbWFpbigpIHtcXG4gIHZVdiA9IHV2O1xcbiAgZmxvYXQgYXNwZWN0ID0gb3ZlcmxheVJlc29sdXRpb24ueCAvIG92ZXJsYXlSZXNvbHV0aW9uLnk7XFxuICBmbG9hdCByYXRpbyA9IHJlc29sdXRpb24ueCAvIHJlc29sdXRpb24ueTtcXG4gIG92ZXJsYXlVViA9IHV2O1xcbiAgZmxvYXQgdEFzcGVjdCA9IG92ZXJsYXlSZXNvbHV0aW9uLnggLyBvdmVybGF5UmVzb2x1dGlvbi55O1xcbiAgZmxvYXQgcEFzcGVjdCA9IHJlc29sdXRpb24ueCAvIHJlc29sdXRpb24ueTtcXG4gIG92ZXJsYXlVViA9IHV2O1xcbiAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNChwb3NpdGlvbiwgMS4wKTtcXG59XCIsIFwiXFxuI2RlZmluZSBHTFNMSUZZIDFcXG5cXG51bmlmb3JtIGZsb2F0IHRpY2s7XFxudW5pZm9ybSBzYW1wbGVyMkQgdERpZmZ1c2U7XFxudW5pZm9ybSBzYW1wbGVyMkQgdExvb2t1cDtcXG51bmlmb3JtIHNhbXBsZXIyRCB0T3ZlcmxheTtcXG52YXJ5aW5nIHZlYzIgdlV2O1xcbnZhcnlpbmcgdmVjMiBvdmVybGF5VVY7XFxuaGlnaHAgZmxvYXQgYV94X3JhbmRvbSh2ZWMyIGNvKSB7XFxuICBoaWdocCBmbG9hdCBhID0gMTIuOTg5ODtcXG4gIGhpZ2hwIGZsb2F0IGIgPSA3OC4yMzM7XFxuICBoaWdocCBmbG9hdCBjID0gNDM3NTguNTQ1MztcXG4gIGhpZ2hwIGZsb2F0IGR0ID0gZG90KGNvLnh5LCB2ZWMyKGEsIGIpKTtcXG4gIGhpZ2hwIGZsb2F0IHNuID0gbW9kKGR0LCAzLjE0KTtcXG4gIHJldHVybiBmcmFjdChzaW4oc24pICogYyk7XFxufVxcbnZlYzMgYl94X2JsZW5kT3ZlcmxheSh2ZWMzIGJhc2UsIHZlYzMgYmxlbmQpIHtcXG4gIHJldHVybiB2ZWMzKGJhc2UuciA8IDAuNSA/ICgyLjAgKiBiYXNlLnIgKiBibGVuZC5yKSA6ICgxLjAgLSAyLjAgKiAoMS4wIC0gYmFzZS5yKSAqICgxLjAgLSBibGVuZC5yKSksIGJhc2UuZyA8IDAuNSA/ICgyLjAgKiBiYXNlLmcgKiBibGVuZC5nKSA6ICgxLjAgLSAyLjAgKiAoMS4wIC0gYmFzZS5nKSAqICgxLjAgLSBibGVuZC5nKSksIGJhc2UuYiA8IDAuNSA/ICgyLjAgKiBiYXNlLmIgKiBibGVuZC5iKSA6ICgxLjAgLSAyLjAgKiAoMS4wIC0gYmFzZS5iKSAqICgxLjAgLSBibGVuZC5iKSkpO1xcbn1cXG5mbG9hdCBjX3hfbHVtYSh2ZWMzIGNvbG9yKSB7XFxuICByZXR1cm4gZG90KGNvbG9yLCB2ZWMzKDAuMjk5LCAwLjU4NywgMC4xMTQpKTtcXG59XFxuZmxvYXQgY194X2x1bWEodmVjNCBjb2xvcikge1xcbiAgcmV0dXJuIGRvdChjb2xvci5yZ2IsIHZlYzMoMC4yOTksIDAuNTg3LCAwLjExNCkpO1xcbn1cXG4jZGVmaW5lIExVVF9GTElQX1lcXG5cXG52ZWM0IGVfeF9sb29rdXAoaW4gdmVjNCB0ZXh0dXJlQ29sb3IsIGluIHNhbXBsZXIyRCBsb29rdXBUYWJsZSkge1xcbiAgXFxuICAjaWZuZGVmIExVVF9OT19DTEFNUFxcbiAgdGV4dHVyZUNvbG9yID0gY2xhbXAodGV4dHVyZUNvbG9yLCAwLjAsIDEuMCk7XFxuICAjZW5kaWZcXG4gIG1lZGl1bXAgZmxvYXQgYmx1ZUNvbG9yID0gdGV4dHVyZUNvbG9yLmIgKiA2My4wO1xcbiAgbWVkaXVtcCB2ZWMyIHF1YWQxO1xcbiAgcXVhZDEueSA9IGZsb29yKGZsb29yKGJsdWVDb2xvcikgLyA4LjApO1xcbiAgcXVhZDEueCA9IGZsb29yKGJsdWVDb2xvcikgLSAocXVhZDEueSAqIDguMCk7XFxuICBtZWRpdW1wIHZlYzIgcXVhZDI7XFxuICBxdWFkMi55ID0gZmxvb3IoY2VpbChibHVlQ29sb3IpIC8gOC4wKTtcXG4gIHF1YWQyLnggPSBjZWlsKGJsdWVDb2xvcikgLSAocXVhZDIueSAqIDguMCk7XFxuICBoaWdocCB2ZWMyIHRleFBvczE7XFxuICB0ZXhQb3MxLnggPSAocXVhZDEueCAqIDAuMTI1KSArIDAuNSAvIDUxMi4wICsgKCgwLjEyNSAtIDEuMCAvIDUxMi4wKSAqIHRleHR1cmVDb2xvci5yKTtcXG4gIHRleFBvczEueSA9IChxdWFkMS55ICogMC4xMjUpICsgMC41IC8gNTEyLjAgKyAoKDAuMTI1IC0gMS4wIC8gNTEyLjApICogdGV4dHVyZUNvbG9yLmcpO1xcbiAgI2lmZGVmIExVVF9GTElQX1lcXG4gIHRleFBvczEueSA9IDEuMCAtIHRleFBvczEueTtcXG4gICNlbmRpZlxcbiAgaGlnaHAgdmVjMiB0ZXhQb3MyO1xcbiAgdGV4UG9zMi54ID0gKHF1YWQyLnggKiAwLjEyNSkgKyAwLjUgLyA1MTIuMCArICgoMC4xMjUgLSAxLjAgLyA1MTIuMCkgKiB0ZXh0dXJlQ29sb3Iucik7XFxuICB0ZXhQb3MyLnkgPSAocXVhZDIueSAqIDAuMTI1KSArIDAuNSAvIDUxMi4wICsgKCgwLjEyNSAtIDEuMCAvIDUxMi4wKSAqIHRleHR1cmVDb2xvci5nKTtcXG4gICNpZmRlZiBMVVRfRkxJUF9ZXFxuICB0ZXhQb3MyLnkgPSAxLjAgLSB0ZXhQb3MyLnk7XFxuICAjZW5kaWZcXG4gIGxvd3AgdmVjNCBuZXdDb2xvcjEgPSB0ZXh0dXJlMkQobG9va3VwVGFibGUsIHRleFBvczEpO1xcbiAgbG93cCB2ZWM0IG5ld0NvbG9yMiA9IHRleHR1cmUyRChsb29rdXBUYWJsZSwgdGV4UG9zMik7XFxuICBsb3dwIHZlYzQgbmV3Q29sb3IgPSBtaXgobmV3Q29sb3IxLCBuZXdDb2xvcjIsIGZyYWN0KGJsdWVDb2xvcikpO1xcbiAgcmV0dXJuIG5ld0NvbG9yO1xcbn1cXG52b2lkIG1haW4oKSB7XFxuICB2ZWMzIHRleENvbG9yID0gdGV4dHVyZTJEKHREaWZmdXNlLCB2VXYpLnJnYjtcXG4gIGZsb2F0IGx1bWluYW5jZSA9IGNfeF9sdW1hKHRleENvbG9yKTtcXG4gIGZsb2F0IG5vaXNlTWFwID0gc21vb3Roc3RlcChsdW1pbmFuY2UsIDAuNSwgMC4wKTtcXG4gIHZlYzIgdFV2ID0gdlV2ICsgdGljaztcXG4gIHZlYzMgbm9pc2UgPSB2ZWMzKGFfeF9yYW5kb20odFV2KSwgYV94X3JhbmRvbSh0VXYgKiAxLjUpLCBhX3hfcmFuZG9tKHRVdiAqIDAuNSkpO1xcbiAgdmVjMyBub2lzZUNvbG9yID0gbWl4KG5vaXNlLCB2ZWMzKDAuNSksIG5vaXNlTWFwKTtcXG4gIHZlYzMgY29sb3IgPSBtaXgodGV4Q29sb3IsIGJfeF9ibGVuZE92ZXJsYXkodGV4Q29sb3IsIG5vaXNlKSwgMC4xNSk7XFxuICB2ZWMzIGNvcnJlY3RlZCA9IGVfeF9sb29rdXAodmVjNChjb2xvciwgMS4wKSwgdExvb2t1cCkucmdiO1xcbiAgY29sb3IgPSBtaXgoY29sb3IsIGNvcnJlY3RlZCwgMC45KTtcXG4gIGdsX0ZyYWdDb2xvciA9IHZlYzQoY29sb3IsIDEuMCk7XFxuICB2ZWM0IHNjcmF0Y2hlcyA9IHRleHR1cmUyRCh0T3ZlcmxheSwgb3ZlcmxheVVWKTtcXG4gIHZlYzMgc2NyYXRjaEJsZW5kID0gZ2xfRnJhZ0NvbG9yLnJnYiArIHNjcmF0Y2hlcy5yZ2I7XFxuICBmbG9hdCBjZW50ZXIgPSBzbW9vdGhzdGVwKDAuMCwgMC42LCBsZW5ndGgodlV2IC0gMC41KSk7XFxuICBmbG9hdCBkaXJ0TWFwID0gc21vb3Roc3RlcCgwLjEsIDAuNCwgbHVtaW5hbmNlICogY2VudGVyKTtcXG4gIGdsX0ZyYWdDb2xvci5yZ2IgPSBtaXgoZ2xfRnJhZ0NvbG9yLnJnYiwgc2NyYXRjaEJsZW5kLCBkaXJ0TWFwKTtcXG59XCIsIFt7XCJuYW1lXCI6XCJvdmVybGF5UmVzb2x1dGlvblwiLFwidHlwZVwiOlwidmVjMlwifSx7XCJuYW1lXCI6XCJyZXNvbHV0aW9uXCIsXCJ0eXBlXCI6XCJ2ZWMyXCJ9LHtcIm5hbWVcIjpcInRpY2tcIixcInR5cGVcIjpcImZsb2F0XCJ9LHtcIm5hbWVcIjpcInREaWZmdXNlXCIsXCJ0eXBlXCI6XCJzYW1wbGVyMkRcIn0se1wibmFtZVwiOlwidExvb2t1cFwiLFwidHlwZVwiOlwic2FtcGxlcjJEXCJ9LHtcIm5hbWVcIjpcInRPdmVybGF5XCIsXCJ0eXBlXCI6XCJzYW1wbGVyMkRcIn1dLCBbXSk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL2NyZWF0ZVwiKShzb3VyY2UpOyIsInZhciBnbHNsaWZ5ID0gcmVxdWlyZShcImdsc2xpZnlcIik7XG52YXIgc291cmNlID0gcmVxdWlyZShcImdsc2xpZnkvc2ltcGxlLWFkYXB0ZXIuanNcIikoXCJcXG4jZGVmaW5lIEdMU0xJRlkgMVxcblxcbnZhcnlpbmcgdmVjMiB2VXY7XFxudm9pZCBtYWluKCkge1xcbiAgdlV2ID0gdXY7XFxuICBnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KHBvc2l0aW9uLCAxLjApO1xcbn1cIiwgXCJcXG4jZGVmaW5lIEdMU0xJRlkgMVxcblxcbnVuaWZvcm0gc2FtcGxlcjJEIHREaWZmdXNlO1xcbnZhcnlpbmcgdmVjMiB2VXY7XFxudm9pZCBtYWluKCkge1xcbiAgZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKHREaWZmdXNlLCB2VXYpO1xcbn1cIiwgW3tcIm5hbWVcIjpcInREaWZmdXNlXCIsXCJ0eXBlXCI6XCJzYW1wbGVyMkRcIn1dLCBbXSk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL2NyZWF0ZVwiKShzb3VyY2UpOyIsIihmdW5jdGlvbiAoZ2xvYmFsKXtcbnZhciBUSFJFRSA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93LlRIUkVFIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbC5USFJFRSA6IG51bGwpXG52YXIgbGluZUhlaWdodCA9IDIyXG52YXIgYmlnID0gMC43XG52YXIgc21hbGwgPSAwLjVcblxudmFyIHBhbmVsV2lkdGggPSAyMFxubW9kdWxlLmV4cG9ydHMgPSBbXG4gICAgXG4gICAge1xuICAgICAgICBuYW1lOiAndG9ubmVzJyxcbiAgICAgICAgcGFuZWxzOiBbIHtcbiAgICAgICAgICAgIC8vIG9yaWdpbjogbmV3IFRIUkVFLlZlY3RvcjMoMTgsIDEwLCAyKSxcbiAgICAgICAgICAgIGxhYmVsczogW1xuICAgICAgICAgICAgICAgIHsgdGV4dDogJzUgbWlsbGlvbiB0b25uZXMnLCBzaXplOiBiaWcgfSxcbiAgICAgICAgICAgICAgICB7IHRleHQ6ICdlc3RpbWF0ZWQgb2lsIHNwaWx0IGluIFJ1c3NpYSBlYWNoIHllYXInLCBzaXplOiBzbWFsbCwgdHJhbnNsYXRpb246IFstMiwgLWxpbmVIZWlnaHQsIDBdIH0sXG4gICAgICAgICAgICBdXG4gICAgICAgIH0sIFxuICAgICAgICB7XG4gICAgICAgICAgICAvLyBvcmlnaW46IG5ldyBUSFJFRS5WZWN0b3IzKC0yMCwgMTAsIDIpLFxuICAgICAgICAgICAgd2lkdGg6IHBhbmVsV2lkdGgsXG4gICAgICAgICAgICBsYWJlbHM6IFtcbiAgICAgICAgICAgICAgICB7IHRleHQ6ICc2IG1pbGxpb24gdG9ubmVzJywgc2l6ZTogYmlnIH0sXG4gICAgICAgICAgICAgICAgeyB0ZXh0OiAnZXhwZWN0ZWQgeWVhcmx5IG91dHB1dCBvZiB0aGlzIHBsYXRmb3JtJywgc2l6ZTogc21hbGwsIHRyYW5zbGF0aW9uOiBbMCwgLWxpbmVIZWlnaHQsIDBdIH0sXG4gICAgICAgICAgICBdXG4gICAgICAgIH0gXG4gICAgICAgIF1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogJ3RvcCcsXG4gICAgICAgIHBhbmVsczogWyB7XG4gICAgICAgICAgICBsYWJlbHM6IFtcbiAgICAgICAgICAgICAgICB7IHRleHQ6ICdUZWNobm9sb2dpY2FsbHkgb3V0ZGF0ZWQnLCBzaXplOiBiaWcgfSxcbiAgICAgICAgICAgICAgICB7IHRleHQ6ICd1c2luZyBzZWNvbmRoYW5kIGNvbXBvbmVudHMnLCBzaXplOiBzbWFsbCwgdHJhbnNsYXRpb246IFswLCAtbGluZUhlaWdodCwgMF0gfSxcbiAgICAgICAgICAgIF1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgd2lkdGg6IHBhbmVsV2lkdGgsXG4gICAgICAgICAgICBsYWJlbHM6IFtcbiAgICAgICAgICAgICAgICB7IHRleHQ6ICckMy4yIGJpbGxpb24gb3ZlciBidWRnZXQnLCBzaXplOiBiaWcgfSxcbiAgICAgICAgICAgICAgICB7IHRleHQ6ICcxOCB5ZWFycyB0byBjb25zdHJ1Y3QnLCBzaXplOiBzbWFsbCwgdHJhbnNsYXRpb246IFswLCAtbGluZUhlaWdodCwgMF0gfSxcbiAgICAgICAgICAgIF1cbiAgICAgICAgfSBdXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6ICduYXR1cmUnLFxuICAgICAgICBwYW5lbHM6IFsge1xuICAgICAgICAgICAgbGFiZWxzOiBbXG4gICAgICAgICAgICAgICAgeyB0ZXh0OiAnNTAga20gZnJvbSBOYXR1cmUgcmVzZXJ2ZScsIHNpemU6IGJpZyB9LFxuICAgICAgICAgICAgICAgIHsgdGV4dDogJ0xlc3MgdGhhbiAyMGhycyBmb3Igb2lsIHRvIHJlYWNoJywgc2l6ZTogc21hbGwsIHRyYW5zbGF0aW9uOiBbMCwgLWxpbmVIZWlnaHQsIDBdIH0sXG4gICAgICAgICAgICBdXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIHdpZHRoOiBwYW5lbFdpZHRoLFxuICAgICAgICAgICAgbGFiZWxzOiBbXG4gICAgICAgICAgICAgICAgeyB0ZXh0OiAnQ3J1Y2lhbCBicmVlZGluZyBncm91bmRzJywgc2l6ZTogYmlnIH0sXG4gICAgICAgICAgICAgICAgeyB0ZXh0OiAnZm9yIHdhbHJ1cywgd2hhbGVzICYgcG9sYXIgYmVhcnMnLCBzaXplOiBzbWFsbCwgdHJhbnNsYXRpb246IFswLCAtbGluZUhlaWdodCwgMF0gfSxcbiAgICAgICAgICAgIF1cbiAgICAgICAgfSBdXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6ICdyZXNwb25zZScsXG4gICAgICAgIHBhbmVsczogWyB7XG4gICAgICAgICAgICBsYWJlbHM6IFtcbiAgICAgICAgICAgICAgICB7IHRleHQ6ICdMYXJnZSBzY2FsZSBzcGlsbCBlcXVpcG1lbnQgJywgc2l6ZTogYmlnIH0sXG4gICAgICAgICAgICAgICAgeyB0ZXh0OiAnMTAwMGttICgzIGRheXMgc2FpbGluZykgYXdheScsIHNpemU6IHNtYWxsLCB0cmFuc2xhdGlvbjogWzAsIC1saW5lSGVpZ2h0LCAwXSB9LFxuICAgICAgICAgICAgXVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICB3aWR0aDogcGFuZWxXaWR0aCoxLjUsXG4gICAgICAgICAgICBsYWJlbHM6IFtcbiAgICAgICAgICAgICAgICB7IHRleHQ6ICcxNSBidWNrZXRzIGFuZCAzIGF4ZXMnLCBzaXplOiBiaWcgfSxcbiAgICAgICAgICAgICAgICB7IHRleHQ6ICdpbmNsdWRlZCBpbiBwcmV2aW91cyByZXNwb25zZSBwbGFuJywgc2l6ZTogc21hbGwsIHRyYW5zbGF0aW9uOiBbMCwgLWxpbmVIZWlnaHQsIDBdIH0sXG4gICAgICAgICAgICBdXG4gICAgICAgIH0gXVxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiAnc3BpbGwnLFxuICAgICAgICBwYW5lbHM6IFsge1xuICAgICAgICAgICAgbGFiZWxzOiBbXG4gICAgICAgICAgICAgICAgeyB0ZXh0OiAnQXJjdGljIE9pbCBzcGlsbHMnLCBzaXplOiBiaWcgfSxcbiAgICAgICAgICAgICAgICB7IHRleHQ6ICdhcmUgY2xvc2UgdG8gaW1wb3NzaWJsZSB0byBjbGVhbiB1cCcsIHNpemU6IHNtYWxsLCB0cmFuc2xhdGlvbjogWzAsIC1saW5lSGVpZ2h0LCAwXSB9LFxuICAgICAgICAgICAgXVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICB3aWR0aDogcGFuZWxXaWR0aCxcbiAgICAgICAgICAgIGxhYmVsczogW1xuICAgICAgICAgICAgICAgIHsgdGV4dDogJ09mZnNob3JlIGRyaWxsaW5nIGZvciBhcmN0aWMgb2lsJywgc2l6ZTogYmlnIH0sXG4gICAgICAgICAgICAgICAgeyB0ZXh0OiAnc3BpbGxzIGFyZSB2aXJ0dWFsbHkgaW5ldml0YWJsZScsIHNpemU6IHNtYWxsLCB0cmFuc2xhdGlvbjogWzAsIC1saW5lSGVpZ2h0LCAwXSB9LFxuICAgICAgICAgICAgXVxuICAgICAgICB9IF1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogJ3dlYXRoZXInLFxuICAgICAgICBwYW5lbHM6IFsge1xuICAgICAgICAgICAgbGFiZWxzOiBbXG4gICAgICAgICAgICAgICAgeyB0ZXh0OiAnQXMgY29sZCBhcyAtNTDLmmMgLzEyMsuaZicsIHNpemU6IGJpZyB9LFxuICAgICAgICAgICAgICAgIHsgdGV4dDogJ3R3byB0aGlyZHMgb2YgdGhlIHllYXIgc3Vycm91bmRlZCBieSBpY2UnLCBzaXplOiBzbWFsbCwgdHJhbnNsYXRpb246IFswLCAtbGluZUhlaWdodCwgMF0gfSxcbiAgICAgICAgICAgIF1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgd2lkdGg6IHBhbmVsV2lkdGgsXG4gICAgICAgICAgICBsYWJlbHM6IFtcbiAgICAgICAgICAgICAgICB7IHRleHQ6ICdQbGFndWVkIGJ5IGJhZCB3ZWF0aGVyJywgc2l6ZTogYmlnIH0sXG4gICAgICAgICAgICAgICAgeyB0ZXh0OiAnd2F2ZXMgYXMgaGlnaCBhcyAxMm0nLCBzaXplOiBzbWFsbCwgdHJhbnNsYXRpb246IFswLCAtbGluZUhlaWdodCwgMF0gfSxcbiAgICAgICAgICAgIF1cbiAgICAgICAgfSBdXG4gICAgfSxcbl1cblxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pIiwiKGZ1bmN0aW9uIChnbG9iYWwpe1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIFR3ZWVuTWF4ID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cuVHdlZW5NYXggOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsLlR3ZWVuTWF4IDogbnVsbClcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihUSFJFRSkge1xuICAgIGlmICghVEhSRUUuTU9VU0UpXG4gICAgICAgIFRIUkVFLk1PVVNFID0geyBMRUZUOiAwLCBNSURETEU6IDEsIFJJR0hUOiAyIH07XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIHFpYW8gLyBodHRwczovL2dpdGh1Yi5jb20vcWlhb1xuICAgICAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb21cbiAgICAgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICAgICAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxuICAgICAqIEBhdXRob3IgZXJpY2g2NjYgLyBodHRwOi8vZXJpY2hhaW5lcy5jb21cbiAgICAgKi9cbiAgICAvKmdsb2JhbCBUSFJFRSwgY29uc29sZSAqL1xuXG4gICAgLy8gVGhpcyBzZXQgb2YgY29udHJvbHMgcGVyZm9ybXMgb3JiaXRpbmcsIGRvbGx5aW5nICh6b29taW5nKSwgYW5kIHBhbm5pbmcuIEl0IG1haW50YWluc1xuICAgIC8vIHRoZSBcInVwXCIgZGlyZWN0aW9uIGFzICtZLCB1bmxpa2UgdGhlIFRyYWNrYmFsbENvbnRyb2xzLiBUb3VjaCBvbiB0YWJsZXQgYW5kIHBob25lcyBpc1xuICAgIC8vIHN1cHBvcnRlZC5cbiAgICAvL1xuICAgIC8vICAgIE9yYml0IC0gbGVmdCBtb3VzZSAvIHRvdWNoOiBvbmUgZmluZ2VyIG1vdmVcbiAgICAvLyAgICBab29tIC0gbWlkZGxlIG1vdXNlLCBvciBtb3VzZXdoZWVsIC8gdG91Y2g6IHR3byBmaW5nZXIgc3ByZWFkIG9yIHNxdWlzaFxuICAgIC8vICAgIFBhbiAtIHJpZ2h0IG1vdXNlLCBvciBhcnJvdyBrZXlzIC8gdG91Y2g6IHRocmVlIGZpbnRlciBzd2lwZVxuICAgIC8vXG4gICAgLy8gVGhpcyBpcyBhIGRyb3AtaW4gcmVwbGFjZW1lbnQgZm9yIChtb3N0KSBUcmFja2JhbGxDb250cm9scyB1c2VkIGluIGV4YW1wbGVzLlxuICAgIC8vIFRoYXQgaXMsIGluY2x1ZGUgdGhpcyBqcyBmaWxlIGFuZCB3aGVyZXZlciB5b3Ugc2VlOlxuICAgIC8vICAgICAgY29udHJvbHMgPSBuZXcgVEhSRUUuVHJhY2tiYWxsQ29udHJvbHMoIGNhbWVyYSApO1xuICAgIC8vICAgICAgY29udHJvbHMudGFyZ2V0LnogPSAxNTA7XG4gICAgLy8gU2ltcGxlIHN1YnN0aXR1dGUgXCJPcmJpdENvbnRyb2xzXCIgYW5kIHRoZSBjb250cm9sIHNob3VsZCB3b3JrIGFzLWlzLlxuXG4gICAgZnVuY3Rpb24gT3JiaXRDb250cm9scyggb2JqZWN0LCBkb21FbGVtZW50ICkge1xuXG4gICAgICAgIHRoaXMub2JqZWN0ID0gb2JqZWN0O1xuICAgICAgICB0aGlzLmRvbUVsZW1lbnQgPSAoIGRvbUVsZW1lbnQgIT09IHVuZGVmaW5lZCApID8gZG9tRWxlbWVudCA6IGRvY3VtZW50O1xuXG4gICAgICAgIC8vIEFQSVxuXG4gICAgICAgIC8vIFNldCB0byBmYWxzZSB0byBkaXNhYmxlIHRoaXMgY29udHJvbFxuICAgICAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xuXG4gICAgICAgIC8vIFwidGFyZ2V0XCIgc2V0cyB0aGUgbG9jYXRpb24gb2YgZm9jdXMsIHdoZXJlIHRoZSBjb250cm9sIG9yYml0cyBhcm91bmRcbiAgICAgICAgLy8gYW5kIHdoZXJlIGl0IHBhbnMgd2l0aCByZXNwZWN0IHRvLlxuICAgICAgICB0aGlzLnRhcmdldCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICAgICAgLy8gY2VudGVyIGlzIG9sZCwgZGVwcmVjYXRlZDsgdXNlIFwidGFyZ2V0XCIgaW5zdGVhZFxuICAgICAgICB0aGlzLmNlbnRlciA9IHRoaXMudGFyZ2V0O1xuXG4gICAgICAgIC8vIFRoaXMgb3B0aW9uIGFjdHVhbGx5IGVuYWJsZXMgZG9sbHlpbmcgaW4gYW5kIG91dDsgbGVmdCBhcyBcInpvb21cIiBmb3JcbiAgICAgICAgLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgICAgICAgdGhpcy5ub1pvb20gPSBmYWxzZTtcbiAgICAgICAgdGhpcy56b29tU3BlZWQgPSAxLjA7XG5cbiAgICAgICAgLy8gTGltaXRzIHRvIGhvdyBmYXIgeW91IGNhbiBkb2xseSBpbiBhbmQgb3V0XG4gICAgICAgIHRoaXMubWluRGlzdGFuY2UgPSAwO1xuICAgICAgICB0aGlzLm1heERpc3RhbmNlID0gSW5maW5pdHk7XG5cbiAgICAgICAgLy8gU2V0IHRvIHRydWUgdG8gZGlzYWJsZSB0aGlzIGNvbnRyb2xcbiAgICAgICAgdGhpcy5ub1JvdGF0ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnJvdGF0ZVNwZWVkID0gMS4wO1xuXG4gICAgICAgIC8vIFNldCB0byB0cnVlIHRvIGRpc2FibGUgdGhpcyBjb250cm9sXG4gICAgICAgIHRoaXMubm9QYW4gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5rZXlQYW5TcGVlZCA9IDcuMDsgLy8gcGl4ZWxzIG1vdmVkIHBlciBhcnJvdyBrZXkgcHVzaFxuXG4gICAgICAgIC8vIFNldCB0byB0cnVlIHRvIGF1dG9tYXRpY2FsbHkgcm90YXRlIGFyb3VuZCB0aGUgdGFyZ2V0XG4gICAgICAgIHRoaXMuYXV0b1JvdGF0ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmF1dG9Sb3RhdGVTcGVlZCA9IDIuMDsgLy8gMzAgc2Vjb25kcyBwZXIgcm91bmQgd2hlbiBmcHMgaXMgNjBcblxuICAgICAgICAvLyBIb3cgZmFyIHlvdSBjYW4gb3JiaXQgdmVydGljYWxseSwgdXBwZXIgYW5kIGxvd2VyIGxpbWl0cy5cbiAgICAgICAgLy8gUmFuZ2UgaXMgMCB0byBNYXRoLlBJIHJhZGlhbnMuXG4gICAgICAgIHRoaXMubWluUG9sYXJBbmdsZSA9IDA7IC8vIHJhZGlhbnNcbiAgICAgICAgdGhpcy5tYXhQb2xhckFuZ2xlID0gTWF0aC5QSTsgLy8gcmFkaWFuc1xuXG4gICAgICAgIC8vIFNldCB0byB0cnVlIHRvIGRpc2FibGUgdXNlIG9mIHRoZSBrZXlzXG4gICAgICAgIHRoaXMubm9LZXlzID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5waGkgPSAwXG4gICAgICAgIHRoaXMudGhldGEgPSAwIFxuXG4gICAgICAgIC8vIFRoZSBmb3VyIGFycm93IGtleXNcbiAgICAgICAgdGhpcy5rZXlzID0geyBMRUZUOiAzNywgVVA6IDM4LCBSSUdIVDogMzksIEJPVFRPTTogNDAgfTtcblxuICAgICAgICB0aGlzLmNvbnN0cmFpbkRlbHRhID0geyB4OiAwLCB5OiAwIH07XG5cbiAgICAgICAgLy8vLy8vLy8vLy8vXG4gICAgICAgIC8vIGludGVybmFsc1xuXG4gICAgICAgIHZhciBzY29wZSA9IHRoaXM7XG5cbiAgICAgICAgdmFyIEVQUyA9IDAuMDAwMDAxO1xuXG4gICAgICAgIHZhciByb3RhdGVTdGFydCA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG4gICAgICAgIHZhciByb3RhdGVFbmQgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xuICAgICAgICB2YXIgcm90YXRlRGVsdGEgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xuXG4gICAgICAgIHZhciBwYW5TdGFydCA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG4gICAgICAgIHZhciBwYW5FbmQgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xuICAgICAgICB2YXIgcGFuRGVsdGEgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xuICAgICAgICB2YXIgcGFuT2Zmc2V0ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgICAgICB2YXIgb2Zmc2V0ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgICAgICB2YXIgZG9sbHlTdGFydCA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG4gICAgICAgIHZhciBkb2xseUVuZCA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG4gICAgICAgIHZhciBkb2xseURlbHRhID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcblxuICAgICAgICB2YXIgcGhpRGVsdGEgPSAwO1xuICAgICAgICB2YXIgdGhldGFEZWx0YSA9IDA7XG4gICAgICAgIHZhciBzY2FsZSA9IDE7XG4gICAgICAgIHZhciBwYW4gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgICAgIHZhciBsYXN0UG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgICAgIHZhciBTVEFURSA9IHsgTk9ORSA6IC0xLCBST1RBVEUgOiAwLCBET0xMWSA6IDEsIFBBTiA6IDIsIFRPVUNIX1JPVEFURSA6IDMsIFRPVUNIX0RPTExZIDogNCwgVE9VQ0hfUEFOIDogNSB9O1xuXG4gICAgICAgIHZhciBzdGF0ZSA9IFNUQVRFLk5PTkU7XG5cbiAgICAgICAgLy8gZm9yIHJlc2V0XG5cbiAgICAgICAgdGhpcy50YXJnZXQwID0gdGhpcy50YXJnZXQuY2xvbmUoKTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbjAgPSB0aGlzLm9iamVjdC5wb3NpdGlvbi5jbG9uZSgpO1xuXG4gICAgICAgIC8vIHNvIGNhbWVyYS51cCBpcyB0aGUgb3JiaXQgYXhpc1xuXG4gICAgICAgIHZhciBxdWF0ID0gbmV3IFRIUkVFLlF1YXRlcm5pb24oKS5zZXRGcm9tVW5pdFZlY3RvcnMoIG9iamVjdC51cCwgbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDEsIDAgKSApO1xuICAgICAgICB2YXIgcXVhdEludmVyc2UgPSBxdWF0LmNsb25lKCkuaW52ZXJzZSgpO1xuXG4gICAgICAgIC8vIGV2ZW50c1xuXG4gICAgICAgIHZhciBjaGFuZ2VFdmVudCA9IHsgdHlwZTogJ2NoYW5nZScgfTtcbiAgICAgICAgdmFyIHN0YXJ0RXZlbnQgPSB7IHR5cGU6ICdzdGFydCd9O1xuICAgICAgICB2YXIgZW5kRXZlbnQgPSB7IHR5cGU6ICdlbmQnfTtcblxuICAgICAgICB0aGlzLnJvdGF0ZUxlZnQgPSBmdW5jdGlvbiAoIGFuZ2xlICkge1xuXG4gICAgICAgICAgICBpZiAoIGFuZ2xlID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgICAgICBhbmdsZSA9IGdldEF1dG9Sb3RhdGlvbkFuZ2xlKCk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhldGFEZWx0YSAtPSBhbmdsZTtcblxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMucm90YXRlVXAgPSBmdW5jdGlvbiAoIGFuZ2xlICkge1xuXG4gICAgICAgICAgICBpZiAoIGFuZ2xlID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgICAgICBhbmdsZSA9IGdldEF1dG9Sb3RhdGlvbkFuZ2xlKCk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcGhpRGVsdGEgLT0gYW5nbGU7XG5cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBwYXNzIGluIGRpc3RhbmNlIGluIHdvcmxkIHNwYWNlIHRvIG1vdmUgbGVmdFxuICAgICAgICB0aGlzLnBhbkxlZnQgPSBmdW5jdGlvbiAoIGRpc3RhbmNlICkge1xuXG4gICAgICAgICAgICB2YXIgdGUgPSB0aGlzLm9iamVjdC5tYXRyaXguZWxlbWVudHM7XG5cbiAgICAgICAgICAgIC8vIGdldCBYIGNvbHVtbiBvZiBtYXRyaXhcbiAgICAgICAgICAgIHBhbk9mZnNldC5zZXQoIHRlWyAwIF0sIHRlWyAxIF0sIHRlWyAyIF0gKTtcbiAgICAgICAgICAgIHBhbk9mZnNldC5tdWx0aXBseVNjYWxhciggLSBkaXN0YW5jZSApO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBwYW4uYWRkKCBwYW5PZmZzZXQgKTtcblxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIHBhc3MgaW4gZGlzdGFuY2UgaW4gd29ybGQgc3BhY2UgdG8gbW92ZSB1cFxuICAgICAgICB0aGlzLnBhblVwID0gZnVuY3Rpb24gKCBkaXN0YW5jZSApIHtcblxuICAgICAgICAgICAgdmFyIHRlID0gdGhpcy5vYmplY3QubWF0cml4LmVsZW1lbnRzO1xuXG4gICAgICAgICAgICAvLyBnZXQgWSBjb2x1bW4gb2YgbWF0cml4XG4gICAgICAgICAgICBwYW5PZmZzZXQuc2V0KCB0ZVsgNCBdLCB0ZVsgNSBdLCB0ZVsgNiBdICk7XG4gICAgICAgICAgICBwYW5PZmZzZXQubXVsdGlwbHlTY2FsYXIoIGRpc3RhbmNlICk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHBhbi5hZGQoIHBhbk9mZnNldCApO1xuXG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICAvLyBwYXNzIGluIHgseSBvZiBjaGFuZ2UgZGVzaXJlZCBpbiBwaXhlbCBzcGFjZSxcbiAgICAgICAgLy8gcmlnaHQgYW5kIGRvd24gYXJlIHBvc2l0aXZlXG4gICAgICAgIHRoaXMucGFuID0gZnVuY3Rpb24gKCBkZWx0YVgsIGRlbHRhWSApIHtcblxuICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBzY29wZS5kb21FbGVtZW50ID09PSBkb2N1bWVudCA/IHNjb3BlLmRvbUVsZW1lbnQuYm9keSA6IHNjb3BlLmRvbUVsZW1lbnQ7XG5cbiAgICAgICAgICAgIGlmICggc2NvcGUub2JqZWN0LmZvdiAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgLy8gcGVyc3BlY3RpdmVcbiAgICAgICAgICAgICAgICB2YXIgcG9zaXRpb24gPSBzY29wZS5vYmplY3QucG9zaXRpb247XG4gICAgICAgICAgICAgICAgdmFyIG9mZnNldCA9IHBvc2l0aW9uLmNsb25lKCkuc3ViKCBzY29wZS50YXJnZXQgKTtcbiAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0RGlzdGFuY2UgPSBvZmZzZXQubGVuZ3RoKCk7XG5cbiAgICAgICAgICAgICAgICAvLyBoYWxmIG9mIHRoZSBmb3YgaXMgY2VudGVyIHRvIHRvcCBvZiBzY3JlZW5cbiAgICAgICAgICAgICAgICB0YXJnZXREaXN0YW5jZSAqPSBNYXRoLnRhbiggKCBzY29wZS5vYmplY3QuZm92IC8gMiApICogTWF0aC5QSSAvIDE4MC4wICk7XG5cbiAgICAgICAgICAgICAgICAvLyB3ZSBhY3R1YWxseSBkb24ndCB1c2Ugc2NyZWVuV2lkdGgsIHNpbmNlIHBlcnNwZWN0aXZlIGNhbWVyYSBpcyBmaXhlZCB0byBzY3JlZW4gaGVpZ2h0XG4gICAgICAgICAgICAgICAgc2NvcGUucGFuTGVmdCggMiAqIGRlbHRhWCAqIHRhcmdldERpc3RhbmNlIC8gZWxlbWVudC5jbGllbnRIZWlnaHQgKTtcbiAgICAgICAgICAgICAgICBzY29wZS5wYW5VcCggMiAqIGRlbHRhWSAqIHRhcmdldERpc3RhbmNlIC8gZWxlbWVudC5jbGllbnRIZWlnaHQgKTtcblxuICAgICAgICAgICAgfSBlbHNlIGlmICggc2NvcGUub2JqZWN0LnRvcCAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgLy8gb3J0aG9ncmFwaGljXG4gICAgICAgICAgICAgICAgc2NvcGUucGFuTGVmdCggZGVsdGFYICogKHNjb3BlLm9iamVjdC5yaWdodCAtIHNjb3BlLm9iamVjdC5sZWZ0KSAvIGVsZW1lbnQuY2xpZW50V2lkdGggKTtcbiAgICAgICAgICAgICAgICBzY29wZS5wYW5VcCggZGVsdGFZICogKHNjb3BlLm9iamVjdC50b3AgLSBzY29wZS5vYmplY3QuYm90dG9tKSAvIGVsZW1lbnQuY2xpZW50SGVpZ2h0ICk7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAvLyBjYW1lcmEgbmVpdGhlciBvcnRob2dyYXBoaWMgb3IgcGVyc3BlY3RpdmVcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oICdXQVJOSU5HOiBPcmJpdENvbnRyb2xzLmpzIGVuY291bnRlcmVkIGFuIHVua25vd24gY2FtZXJhIHR5cGUgLSBwYW4gZGlzYWJsZWQuJyApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmRvbGx5SW4gPSBmdW5jdGlvbiAoIGRvbGx5U2NhbGUgKSB7XG5cbiAgICAgICAgICAgIGlmICggZG9sbHlTY2FsZSA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgZG9sbHlTY2FsZSA9IGdldFpvb21TY2FsZSgpO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNjYWxlIC89IGRvbGx5U2NhbGU7XG5cbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmRvbGx5T3V0ID0gZnVuY3Rpb24gKCBkb2xseVNjYWxlICkge1xuXG4gICAgICAgICAgICBpZiAoIGRvbGx5U2NhbGUgPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgIGRvbGx5U2NhbGUgPSBnZXRab29tU2NhbGUoKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzY2FsZSAqPSBkb2xseVNjYWxlO1xuXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIHZhciBwb3NpdGlvbiA9IHRoaXMub2JqZWN0LnBvc2l0aW9uO1xuXG4gICAgICAgICAgICAvLyAvLyByb3RhdGluZyBhY3Jvc3Mgd2hvbGUgc2NyZWVuIGdvZXMgMzYwIGRlZ3JlZXMgYXJvdW5kXG4gICAgICAgICAgICBzY29wZS5yb3RhdGVMZWZ0KCAyICogTWF0aC5QSSAqIHNjb3BlLmNvbnN0cmFpbkRlbHRhLnggLyB3aW5kb3cuaW5uZXJXaWR0aCAqIHNjb3BlLnJvdGF0ZVNwZWVkICk7XG5cbiAgICAgICAgICAgIC8vIC8vIHJvdGF0aW5nIHVwIGFuZCBkb3duIGFsb25nIHdob2xlIHNjcmVlbiBhdHRlbXB0cyB0byBnbyAzNjAsIGJ1dCBsaW1pdGVkIHRvIDE4MFxuICAgICAgICAgICAgc2NvcGUucm90YXRlVXAoIDIgKiBNYXRoLlBJICogc2NvcGUuY29uc3RyYWluRGVsdGEueSAvIHdpbmRvdy5pbm5lckhlaWdodCAqIHNjb3BlLnJvdGF0ZVNwZWVkICk7XG5cbiAgICAgICAgICAgIG9mZnNldC5jb3B5KCBwb3NpdGlvbiApLnN1YiggdGhpcy50YXJnZXQgKTtcblxuICAgICAgICAgICAgLy8gcm90YXRlIG9mZnNldCB0byBcInktYXhpcy1pcy11cFwiIHNwYWNlXG4gICAgICAgICAgICBvZmZzZXQuYXBwbHlRdWF0ZXJuaW9uKCBxdWF0ICk7XG5cbiAgICAgICAgICAgIC8vIGFuZ2xlIGZyb20gei1heGlzIGFyb3VuZCB5LWF4aXNcblxuICAgICAgICAgICAgdmFyIHRoZXRhID0gTWF0aC5hdGFuMiggb2Zmc2V0LngsIG9mZnNldC56ICk7XG5cbiAgICAgICAgICAgIC8vIGFuZ2xlIGZyb20geS1heGlzXG5cbiAgICAgICAgICAgIHZhciBwaGkgPSBNYXRoLmF0YW4yKCBNYXRoLnNxcnQoIG9mZnNldC54ICogb2Zmc2V0LnggKyBvZmZzZXQueiAqIG9mZnNldC56ICksIG9mZnNldC55ICk7XG5cbiAgICAgICAgICAgIGlmICggdGhpcy5hdXRvUm90YXRlICkge1xuXG4gICAgICAgICAgICAgICAgdGhpcy5yb3RhdGVMZWZ0KCBnZXRBdXRvUm90YXRpb25BbmdsZSgpICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhldGEgKz0gdGhldGFEZWx0YTtcbiAgICAgICAgICAgIHBoaSArPSBwaGlEZWx0YTtcblxuICAgICAgICAgICAgLy8gcmVzdHJpY3QgcGhpIHRvIGJlIGJldHdlZW4gZGVzaXJlZCBsaW1pdHNcbiAgICAgICAgICAgIHBoaSA9IE1hdGgubWF4KCB0aGlzLm1pblBvbGFyQW5nbGUsIE1hdGgubWluKCB0aGlzLm1heFBvbGFyQW5nbGUsIHBoaSApICk7XG5cbiAgICAgICAgICAgIC8vIHJlc3RyaWN0IHBoaSB0byBiZSBiZXR3ZWUgRVBTIGFuZCBQSS1FUFNcbiAgICAgICAgICAgIHBoaSA9IE1hdGgubWF4KCBFUFMsIE1hdGgubWluKCBNYXRoLlBJIC0gRVBTLCBwaGkgKSApO1xuXG4gICAgICAgICAgICB2YXIgcmFkaXVzID0gb2Zmc2V0Lmxlbmd0aCgpICogc2NhbGU7XG5cbiAgICAgICAgICAgIC8vIHJlc3RyaWN0IHJhZGl1cyB0byBiZSBiZXR3ZWVuIGRlc2lyZWQgbGltaXRzXG4gICAgICAgICAgICByYWRpdXMgPSBNYXRoLm1heCggdGhpcy5taW5EaXN0YW5jZSwgTWF0aC5taW4oIHRoaXMubWF4RGlzdGFuY2UsIHJhZGl1cyApICk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIG1vdmUgdGFyZ2V0IHRvIHBhbm5lZCBsb2NhdGlvblxuICAgICAgICAgICAgdGhpcy50YXJnZXQuYWRkKCBwYW4gKTtcblxuICAgICAgICAgICAgc2NvcGUucGhpID0gcGhpXG4gICAgICAgICAgICBzY29wZS50aGV0YSA9IHRoZXRhXG5cbiAgICAgICAgICAgIG9mZnNldC54ID0gcmFkaXVzICogTWF0aC5zaW4oIHBoaSApICogTWF0aC5zaW4oIHRoZXRhICk7XG4gICAgICAgICAgICBvZmZzZXQueSA9IHJhZGl1cyAqIE1hdGguY29zKCBwaGkgKTtcbiAgICAgICAgICAgIG9mZnNldC56ID0gcmFkaXVzICogTWF0aC5zaW4oIHBoaSApICogTWF0aC5jb3MoIHRoZXRhICk7XG5cbiAgICAgICAgICAgIC8vIHJvdGF0ZSBvZmZzZXQgYmFjayB0byBcImNhbWVyYS11cC12ZWN0b3ItaXMtdXBcIiBzcGFjZVxuICAgICAgICAgICAgb2Zmc2V0LmFwcGx5UXVhdGVybmlvbiggcXVhdEludmVyc2UgKTtcblxuICAgICAgICAgICAgcG9zaXRpb24uY29weSggdGhpcy50YXJnZXQgKS5hZGQoIG9mZnNldCApO1xuXG4gICAgICAgICAgICB0aGlzLm9iamVjdC5sb29rQXQoIHRoaXMudGFyZ2V0ICk7XG5cbiAgICAgICAgICAgIHRoZXRhRGVsdGEgPSAwO1xuICAgICAgICAgICAgcGhpRGVsdGEgPSAwO1xuICAgICAgICAgICAgc2NhbGUgPSAxO1xuICAgICAgICAgICAgcGFuLnNldCggMCwgMCwgMCApO1xuXG4gICAgICAgICAgICBpZiAoIGxhc3RQb3NpdGlvbi5kaXN0YW5jZVRvU3F1YXJlZCggdGhpcy5vYmplY3QucG9zaXRpb24gKSA+IEVQUyApIHtcblxuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudCggY2hhbmdlRXZlbnQgKTtcblxuICAgICAgICAgICAgICAgIGxhc3RQb3NpdGlvbi5jb3B5KCB0aGlzLm9iamVjdC5wb3NpdGlvbiApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfTtcblxuXG4gICAgICAgIHRoaXMucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIHN0YXRlID0gU1RBVEUuTk9ORTtcblxuICAgICAgICAgICAgdGhpcy50YXJnZXQuY29weSggdGhpcy50YXJnZXQwICk7XG4gICAgICAgICAgICB0aGlzLm9iamVjdC5wb3NpdGlvbi5jb3B5KCB0aGlzLnBvc2l0aW9uMCApO1xuXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuXG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0QXV0b1JvdGF0aW9uQW5nbGUoKSB7XG5cbiAgICAgICAgICAgIHJldHVybiAyICogTWF0aC5QSSAvIDYwIC8gNjAgKiBzY29wZS5hdXRvUm90YXRlU3BlZWQ7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdldFpvb21TY2FsZSgpIHtcblxuICAgICAgICAgICAgcmV0dXJuIE1hdGgucG93KCAwLjk1LCBzY29wZS56b29tU3BlZWQgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gb25Nb3VzZURvd24oIGV2ZW50ICkge1xuXG4gICAgICAgICAgICBpZiAoIHNjb3BlLmVuYWJsZWQgPT09IGZhbHNlICkgcmV0dXJuO1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgICAgaWYgKCBldmVudC5idXR0b24gPT09IDAgKSB7XG4gICAgICAgICAgICAgICAgaWYgKCBzY29wZS5ub1JvdGF0ZSA9PT0gdHJ1ZSApIHJldHVybjtcblxuICAgICAgICAgICAgICAgIHN0YXRlID0gU1RBVEUuUk9UQVRFO1xuXG4gICAgICAgICAgICAgICAgcm90YXRlU3RhcnQuc2V0KCBldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZICk7XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIGV2ZW50LmJ1dHRvbiA9PT0gMSApIHtcbiAgICAgICAgICAgICAgICBpZiAoIHNjb3BlLm5vWm9vbSA9PT0gdHJ1ZSApIHJldHVybjtcblxuICAgICAgICAgICAgICAgIHN0YXRlID0gU1RBVEUuRE9MTFk7XG5cbiAgICAgICAgICAgICAgICBkb2xseVN0YXJ0LnNldCggZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSApO1xuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCBldmVudC5idXR0b24gPT09IDIgKSB7XG4gICAgICAgICAgICAgICAgaWYgKCBzY29wZS5ub1BhbiA9PT0gdHJ1ZSApIHJldHVybjtcblxuICAgICAgICAgICAgICAgIHN0YXRlID0gU1RBVEUuUEFOO1xuXG4gICAgICAgICAgICAgICAgcGFuU3RhcnQuc2V0KCBldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2NvcGUuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCAnbW91c2Vtb3ZlJywgb25Nb3VzZU1vdmUsIGZhbHNlICk7XG4gICAgICAgICAgICBzY29wZS5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoICdtb3VzZXVwJywgb25Nb3VzZVVwLCBmYWxzZSApO1xuICAgICAgICAgICAgc2NvcGUuZGlzcGF0Y2hFdmVudCggc3RhcnRFdmVudCApO1xuXG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBvbk1vdXNlTW92ZSggZXZlbnQgKSB7XG5cbiAgICAgICAgICAgIGlmICggc2NvcGUuZW5hYmxlZCA9PT0gZmFsc2UgKSByZXR1cm47XG5cbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICAgIHZhciBlbGVtZW50ID0gc2NvcGUuZG9tRWxlbWVudCA9PT0gZG9jdW1lbnQgPyBzY29wZS5kb21FbGVtZW50LmJvZHkgOiBzY29wZS5kb21FbGVtZW50O1xuXG4gICAgICAgICAgICBpZiAoIHN0YXRlID09PSBTVEFURS5ST1RBVEUgKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoIHNjb3BlLm5vUm90YXRlID09PSB0cnVlICkgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgcm90YXRlRW5kLnNldCggZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSApO1xuICAgICAgICAgICAgICAgIHJvdGF0ZURlbHRhLnN1YlZlY3RvcnMoIHJvdGF0ZUVuZCwgcm90YXRlU3RhcnQgKTtcblxuICAgICAgICAgICAgICAgIHNjb3BlLmNvbnN0cmFpbkRlbHRhLnggPSByb3RhdGVEZWx0YS54O1xuICAgICAgICAgICAgICAgIHNjb3BlLmNvbnN0cmFpbkRlbHRhLnkgPSByb3RhdGVEZWx0YS55O1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIFR3ZWVuTWF4LmtpbGxUd2VlbnNPZihzY29wZS5jb25zdHJhaW5EZWx0YSk7XG4gICAgICAgICAgICAgICAgVHdlZW5NYXgudG8oc2NvcGUuY29uc3RyYWluRGVsdGEsIDAuNTAsIHtcbiAgICAgICAgICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgICAgICAgICAgeTogMCxcbiAgICAgICAgICAgICAgICAgICAgZWFzZTogJ2Vhc2VPdXRRdWFkJyxcbiAgICAgICAgICAgICAgICAgICAgZGVsYXk6IDAuMFxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgcm90YXRlU3RhcnQuY29weSggcm90YXRlRW5kICk7XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIHN0YXRlID09PSBTVEFURS5ET0xMWSApIHtcblxuICAgICAgICAgICAgICAgIGlmICggc2NvcGUubm9ab29tID09PSB0cnVlICkgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgZG9sbHlFbmQuc2V0KCBldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZICk7XG4gICAgICAgICAgICAgICAgZG9sbHlEZWx0YS5zdWJWZWN0b3JzKCBkb2xseUVuZCwgZG9sbHlTdGFydCApO1xuXG4gICAgICAgICAgICAgICAgaWYgKCBkb2xseURlbHRhLnkgPiAwICkge1xuXG4gICAgICAgICAgICAgICAgICAgIHNjb3BlLmRvbGx5SW4oKTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgc2NvcGUuZG9sbHlPdXQoKTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGRvbGx5U3RhcnQuY29weSggZG9sbHlFbmQgKTtcblxuICAgICAgICAgICAgfSBlbHNlIGlmICggc3RhdGUgPT09IFNUQVRFLlBBTiApIHtcblxuICAgICAgICAgICAgICAgIGlmICggc2NvcGUubm9QYW4gPT09IHRydWUgKSByZXR1cm47XG5cbiAgICAgICAgICAgICAgICBwYW5FbmQuc2V0KCBldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZICk7XG4gICAgICAgICAgICAgICAgcGFuRGVsdGEuc3ViVmVjdG9ycyggcGFuRW5kLCBwYW5TdGFydCApO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHNjb3BlLnBhbiggcGFuRGVsdGEueCwgcGFuRGVsdGEueSApO1xuXG4gICAgICAgICAgICAgICAgcGFuU3RhcnQuY29weSggcGFuRW5kICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2NvcGUudXBkYXRlKCk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIG9uTW91c2VVcCggLyogZXZlbnQgKi8gKSB7XG5cbiAgICAgICAgICAgIGlmICggc2NvcGUuZW5hYmxlZCA9PT0gZmFsc2UgKSByZXR1cm47XG5cbiAgICAgICAgICAgIHNjb3BlLmRvbUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ21vdXNlbW92ZScsIG9uTW91c2VNb3ZlLCBmYWxzZSApO1xuICAgICAgICAgICAgc2NvcGUuZG9tRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCAnbW91c2V1cCcsIG9uTW91c2VVcCwgZmFsc2UgKTtcbiAgICAgICAgICAgIHNjb3BlLmRpc3BhdGNoRXZlbnQoIGVuZEV2ZW50ICk7XG4gICAgICAgICAgICBzdGF0ZSA9IFNUQVRFLk5PTkU7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIG9uTW91c2VXaGVlbCggZXZlbnQgKSB7XG5cbiAgICAgICAgICAgIGlmICggc2NvcGUuZW5hYmxlZCA9PT0gZmFsc2UgfHwgc2NvcGUubm9ab29tID09PSB0cnVlICkgcmV0dXJuO1xuXG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICAgICAgICAgIHZhciBkZWx0YSA9IDA7XG5cbiAgICAgICAgICAgIGlmICggZXZlbnQud2hlZWxEZWx0YSAhPT0gdW5kZWZpbmVkICkgeyAvLyBXZWJLaXQgLyBPcGVyYSAvIEV4cGxvcmVyIDlcblxuICAgICAgICAgICAgICAgIGRlbHRhID0gZXZlbnQud2hlZWxEZWx0YTtcblxuICAgICAgICAgICAgfSBlbHNlIGlmICggZXZlbnQuZGV0YWlsICE9PSB1bmRlZmluZWQgKSB7IC8vIEZpcmVmb3hcblxuICAgICAgICAgICAgICAgIGRlbHRhID0gLSBldmVudC5kZXRhaWw7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCBkZWx0YSA+IDAgKSB7XG5cbiAgICAgICAgICAgICAgICBzY29wZS5kb2xseU91dCgpO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgc2NvcGUuZG9sbHlJbigpO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNjb3BlLnVwZGF0ZSgpO1xuICAgICAgICAgICAgc2NvcGUuZGlzcGF0Y2hFdmVudCggc3RhcnRFdmVudCApO1xuICAgICAgICAgICAgc2NvcGUuZGlzcGF0Y2hFdmVudCggZW5kRXZlbnQgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gb25LZXlEb3duKCBldmVudCApIHtcblxuICAgICAgICAgICAgaWYgKCBzY29wZS5lbmFibGVkID09PSBmYWxzZSB8fCBzY29wZS5ub0tleXMgPT09IHRydWUgfHwgc2NvcGUubm9QYW4gPT09IHRydWUgKSByZXR1cm47XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHN3aXRjaCAoIGV2ZW50LmtleUNvZGUgKSB7XG5cbiAgICAgICAgICAgICAgICBjYXNlIHNjb3BlLmtleXMuVVA6XG4gICAgICAgICAgICAgICAgICAgIHNjb3BlLnBhbiggMCwgc2NvcGUua2V5UGFuU3BlZWQgKTtcbiAgICAgICAgICAgICAgICAgICAgc2NvcGUudXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSBzY29wZS5rZXlzLkJPVFRPTTpcbiAgICAgICAgICAgICAgICAgICAgc2NvcGUucGFuKCAwLCAtIHNjb3BlLmtleVBhblNwZWVkICk7XG4gICAgICAgICAgICAgICAgICAgIHNjb3BlLnVwZGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2Ugc2NvcGUua2V5cy5MRUZUOlxuICAgICAgICAgICAgICAgICAgICBzY29wZS5wYW4oIHNjb3BlLmtleVBhblNwZWVkLCAwICk7XG4gICAgICAgICAgICAgICAgICAgIHNjb3BlLnVwZGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2Ugc2NvcGUua2V5cy5SSUdIVDpcbiAgICAgICAgICAgICAgICAgICAgc2NvcGUucGFuKCAtIHNjb3BlLmtleVBhblNwZWVkLCAwICk7XG4gICAgICAgICAgICAgICAgICAgIHNjb3BlLnVwZGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiB0b3VjaHN0YXJ0KCBldmVudCApIHtcblxuICAgICAgICAgICAgaWYgKCBzY29wZS5lbmFibGVkID09PSBmYWxzZSApIHJldHVybjtcblxuICAgICAgICAgICAgc3dpdGNoICggZXZlbnQudG91Y2hlcy5sZW5ndGggKSB7XG5cbiAgICAgICAgICAgICAgICBjYXNlIDE6IC8vIG9uZS1maW5nZXJlZCB0b3VjaDogcm90YXRlXG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBzY29wZS5ub1JvdGF0ZSA9PT0gdHJ1ZSApIHJldHVybjtcblxuICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IFNUQVRFLlRPVUNIX1JPVEFURTtcblxuICAgICAgICAgICAgICAgICAgICByb3RhdGVTdGFydC5zZXQoIGV2ZW50LnRvdWNoZXNbIDAgXS5wYWdlWCwgZXZlbnQudG91Y2hlc1sgMCBdLnBhZ2VZICk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAyOiAvLyB0d28tZmluZ2VyZWQgdG91Y2g6IGRvbGx5XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBzY29wZS5ub1pvb20gPT09IHRydWUgKSByZXR1cm47XG5cbiAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSBTVEFURS5UT1VDSF9ET0xMWTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgZHggPSBldmVudC50b3VjaGVzWyAwIF0ucGFnZVggLSBldmVudC50b3VjaGVzWyAxIF0ucGFnZVg7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkeSA9IGV2ZW50LnRvdWNoZXNbIDAgXS5wYWdlWSAtIGV2ZW50LnRvdWNoZXNbIDEgXS5wYWdlWTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRpc3RhbmNlID0gTWF0aC5zcXJ0KCBkeCAqIGR4ICsgZHkgKiBkeSApO1xuICAgICAgICAgICAgICAgICAgICBkb2xseVN0YXJ0LnNldCggMCwgZGlzdGFuY2UgKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlIDM6IC8vIHRocmVlLWZpbmdlcmVkIHRvdWNoOiBwYW5cblxuICAgICAgICAgICAgICAgICAgICBpZiAoIHNjb3BlLm5vUGFuID09PSB0cnVlICkgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlID0gU1RBVEUuVE9VQ0hfUEFOO1xuXG4gICAgICAgICAgICAgICAgICAgIHBhblN0YXJ0LnNldCggZXZlbnQudG91Y2hlc1sgMCBdLnBhZ2VYLCBldmVudC50b3VjaGVzWyAwIF0ucGFnZVkgKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlID0gU1RBVEUuTk9ORTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzY29wZS5kaXNwYXRjaEV2ZW50KCBzdGFydEV2ZW50ICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHRvdWNobW92ZSggZXZlbnQgKSB7XG5cbiAgICAgICAgICAgIGlmICggc2NvcGUuZW5hYmxlZCA9PT0gZmFsc2UgKSByZXR1cm47XG5cbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBzY29wZS5kb21FbGVtZW50ID09PSBkb2N1bWVudCA/IHNjb3BlLmRvbUVsZW1lbnQuYm9keSA6IHNjb3BlLmRvbUVsZW1lbnQ7XG5cbiAgICAgICAgICAgIHN3aXRjaCAoIGV2ZW50LnRvdWNoZXMubGVuZ3RoICkge1xuXG4gICAgICAgICAgICAgICAgY2FzZSAxOiAvLyBvbmUtZmluZ2VyZWQgdG91Y2g6IHJvdGF0ZVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICggc2NvcGUubm9Sb3RhdGUgPT09IHRydWUgKSByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIGlmICggc3RhdGUgIT09IFNUQVRFLlRPVUNIX1JPVEFURSApIHJldHVybjtcblxuICAgICAgICAgICAgICAgICAgICByb3RhdGVFbmQuc2V0KCBldmVudC50b3VjaGVzWyAwIF0ucGFnZVgsIGV2ZW50LnRvdWNoZXNbIDAgXS5wYWdlWSApO1xuICAgICAgICAgICAgICAgICAgICByb3RhdGVEZWx0YS5zdWJWZWN0b3JzKCByb3RhdGVFbmQsIHJvdGF0ZVN0YXJ0ICk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gcm90YXRpbmcgYWNyb3NzIHdob2xlIHNjcmVlbiBnb2VzIDM2MCBkZWdyZWVzIGFyb3VuZFxuICAgICAgICAgICAgICAgICAgICBzY29wZS5yb3RhdGVMZWZ0KCAyICogTWF0aC5QSSAqIHJvdGF0ZURlbHRhLnggLyBlbGVtZW50LmNsaWVudFdpZHRoICogc2NvcGUucm90YXRlU3BlZWQgKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gcm90YXRpbmcgdXAgYW5kIGRvd24gYWxvbmcgd2hvbGUgc2NyZWVuIGF0dGVtcHRzIHRvIGdvIDM2MCwgYnV0IGxpbWl0ZWQgdG8gMTgwXG4gICAgICAgICAgICAgICAgICAgIHNjb3BlLnJvdGF0ZVVwKCAyICogTWF0aC5QSSAqIHJvdGF0ZURlbHRhLnkgLyBlbGVtZW50LmNsaWVudEhlaWdodCAqIHNjb3BlLnJvdGF0ZVNwZWVkICk7XG5cbiAgICAgICAgICAgICAgICAgICAgcm90YXRlU3RhcnQuY29weSggcm90YXRlRW5kICk7XG5cbiAgICAgICAgICAgICAgICAgICAgc2NvcGUudXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAyOiAvLyB0d28tZmluZ2VyZWQgdG91Y2g6IGRvbGx5XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBzY29wZS5ub1pvb20gPT09IHRydWUgKSByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIGlmICggc3RhdGUgIT09IFNUQVRFLlRPVUNIX0RPTExZICkgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBkeCA9IGV2ZW50LnRvdWNoZXNbIDAgXS5wYWdlWCAtIGV2ZW50LnRvdWNoZXNbIDEgXS5wYWdlWDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGR5ID0gZXZlbnQudG91Y2hlc1sgMCBdLnBhZ2VZIC0gZXZlbnQudG91Y2hlc1sgMSBdLnBhZ2VZO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGlzdGFuY2UgPSBNYXRoLnNxcnQoIGR4ICogZHggKyBkeSAqIGR5ICk7XG5cbiAgICAgICAgICAgICAgICAgICAgZG9sbHlFbmQuc2V0KCAwLCBkaXN0YW5jZSApO1xuICAgICAgICAgICAgICAgICAgICBkb2xseURlbHRhLnN1YlZlY3RvcnMoIGRvbGx5RW5kLCBkb2xseVN0YXJ0ICk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBkb2xseURlbHRhLnkgPiAwICkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBzY29wZS5kb2xseU91dCgpO1xuXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlLmRvbGx5SW4oKTtcblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZG9sbHlTdGFydC5jb3B5KCBkb2xseUVuZCApO1xuXG4gICAgICAgICAgICAgICAgICAgIHNjb3BlLnVwZGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgMzogLy8gdGhyZWUtZmluZ2VyZWQgdG91Y2g6IHBhblxuXG4gICAgICAgICAgICAgICAgICAgIGlmICggc2NvcGUubm9QYW4gPT09IHRydWUgKSByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIGlmICggc3RhdGUgIT09IFNUQVRFLlRPVUNIX1BBTiApIHJldHVybjtcblxuICAgICAgICAgICAgICAgICAgICBwYW5FbmQuc2V0KCBldmVudC50b3VjaGVzWyAwIF0ucGFnZVgsIGV2ZW50LnRvdWNoZXNbIDAgXS5wYWdlWSApO1xuICAgICAgICAgICAgICAgICAgICBwYW5EZWx0YS5zdWJWZWN0b3JzKCBwYW5FbmQsIHBhblN0YXJ0ICk7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBzY29wZS5wYW4oIHBhbkRlbHRhLngsIHBhbkRlbHRhLnkgKTtcblxuICAgICAgICAgICAgICAgICAgICBwYW5TdGFydC5jb3B5KCBwYW5FbmQgKTtcblxuICAgICAgICAgICAgICAgICAgICBzY29wZS51cGRhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlID0gU1RBVEUuTk9ORTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiB0b3VjaGVuZCggLyogZXZlbnQgKi8gKSB7XG5cbiAgICAgICAgICAgIGlmICggc2NvcGUuZW5hYmxlZCA9PT0gZmFsc2UgKSByZXR1cm47XG5cbiAgICAgICAgICAgIHNjb3BlLmRpc3BhdGNoRXZlbnQoIGVuZEV2ZW50ICk7XG4gICAgICAgICAgICBzdGF0ZSA9IFNUQVRFLk5PTkU7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCAnY29udGV4dG1lbnUnLCBmdW5jdGlvbiAoIGV2ZW50ICkgeyBldmVudC5wcmV2ZW50RGVmYXVsdCgpOyB9LCBmYWxzZSApO1xuICAgICAgICB0aGlzLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggJ21vdXNlZG93bicsIG9uTW91c2VEb3duLCBmYWxzZSApO1xuICAgICAgICB0aGlzLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggJ21vdXNld2hlZWwnLCBvbk1vdXNlV2hlZWwsIGZhbHNlICk7XG4gICAgICAgIHRoaXMuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCAnRE9NTW91c2VTY3JvbGwnLCBvbk1vdXNlV2hlZWwsIGZhbHNlICk7IC8vIGZpcmVmb3hcblxuICAgICAgICB0aGlzLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggJ3RvdWNoc3RhcnQnLCB0b3VjaHN0YXJ0LCBmYWxzZSApO1xuICAgICAgICB0aGlzLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggJ3RvdWNoZW5kJywgdG91Y2hlbmQsIGZhbHNlICk7XG4gICAgICAgIHRoaXMuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCAndG91Y2htb3ZlJywgdG91Y2htb3ZlLCBmYWxzZSApO1xuXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCAna2V5ZG93bicsIG9uS2V5RG93biwgZmFsc2UgKTtcblxuICAgICAgICAvLyBmb3JjZSBhbiB1cGRhdGUgYXQgc3RhcnRcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcblxuICAgIH07XG5cbiAgICBpbmhlcml0cyhPcmJpdENvbnRyb2xzLCBUSFJFRS5FdmVudERpc3BhdGNoZXIpXG4gICAgcmV0dXJuIE9yYml0Q29udHJvbHNcbn1cbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KSIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbnVtdHlwZShudW0sIGRlZikge1xuXHRyZXR1cm4gdHlwZW9mIG51bSA9PT0gJ251bWJlcidcblx0XHQ/IG51bSBcblx0XHQ6ICh0eXBlb2YgZGVmID09PSAnbnVtYmVyJyA/IGRlZiA6IDApXG59IiwiLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8ZmVyb3NzQGZlcm9zcy5vcmc+IDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcbnZhciBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzLWFycmF5JylcblxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyIC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cblxudmFyIGtNYXhMZW5ndGggPSAweDNmZmZmZmZmXG5cbi8qKlxuICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFVzZSBPYmplY3QgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gKlxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICpcbiAqIE5vdGU6XG4gKlxuICogLSBJbXBsZW1lbnRhdGlvbiBtdXN0IHN1cHBvcnQgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YCBpbnN0YW5jZXMuXG4gKiAgIEZpcmVmb3ggNC0yOSBsYWNrZWQgc3VwcG9ydCwgZml4ZWQgaW4gRmlyZWZveCAzMCsuXG4gKiAgIFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4LlxuICpcbiAqICAtIENocm9tZSA5LTEwIGlzIG1pc3NpbmcgdGhlIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24uXG4gKlxuICogIC0gSUUxMCBoYXMgYSBicm9rZW4gYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFycmF5cyBvZlxuICogICAgaW5jb3JyZWN0IGxlbmd0aCBpbiBzb21lIHNpdHVhdGlvbnMuXG4gKlxuICogV2UgZGV0ZWN0IHRoZXNlIGJ1Z2d5IGJyb3dzZXJzIGFuZCBzZXQgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYCB0byBgZmFsc2VgIHNvIHRoZXkgd2lsbFxuICogZ2V0IHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24sIHdoaWNoIGlzIHNsb3dlciBidXQgd2lsbCB3b3JrIGNvcnJlY3RseS5cbiAqL1xuQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgPSAoZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIHZhciBidWYgPSBuZXcgQXJyYXlCdWZmZXIoMClcbiAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoYnVmKVxuICAgIGFyci5mb28gPSBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9XG4gICAgcmV0dXJuIDQyID09PSBhcnIuZm9vKCkgJiYgLy8gdHlwZWQgYXJyYXkgaW5zdGFuY2VzIGNhbiBiZSBhdWdtZW50ZWRcbiAgICAgICAgdHlwZW9mIGFyci5zdWJhcnJheSA9PT0gJ2Z1bmN0aW9uJyAmJiAvLyBjaHJvbWUgOS0xMCBsYWNrIGBzdWJhcnJheWBcbiAgICAgICAgbmV3IFVpbnQ4QXJyYXkoMSkuc3ViYXJyYXkoMSwgMSkuYnl0ZUxlbmd0aCA9PT0gMCAvLyBpZTEwIGhhcyBicm9rZW4gYHN1YmFycmF5YFxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn0pKClcblxuLyoqXG4gKiBDbGFzczogQnVmZmVyXG4gKiA9PT09PT09PT09PT09XG4gKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBhcmUgYXVnbWVudGVkXG4gKiB3aXRoIGZ1bmN0aW9uIHByb3BlcnRpZXMgZm9yIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBBUEkgZnVuY3Rpb25zLiBXZSB1c2VcbiAqIGBVaW50OEFycmF5YCBzbyB0aGF0IHNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0IHJldHVybnNcbiAqIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIEJ5IGF1Z21lbnRpbmcgdGhlIGluc3RhbmNlcywgd2UgY2FuIGF2b2lkIG1vZGlmeWluZyB0aGUgYFVpbnQ4QXJyYXlgXG4gKiBwcm90b3R5cGUuXG4gKi9cbmZ1bmN0aW9uIEJ1ZmZlciAoc3ViamVjdCwgZW5jb2RpbmcsIG5vWmVybykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQnVmZmVyKSlcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcihzdWJqZWN0LCBlbmNvZGluZywgbm9aZXJvKVxuXG4gIHZhciB0eXBlID0gdHlwZW9mIHN1YmplY3RcblxuICAvLyBGaW5kIHRoZSBsZW5ndGhcbiAgdmFyIGxlbmd0aFxuICBpZiAodHlwZSA9PT0gJ251bWJlcicpXG4gICAgbGVuZ3RoID0gc3ViamVjdCA+IDAgPyBzdWJqZWN0ID4+PiAwIDogMFxuICBlbHNlIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuICAgIGlmIChlbmNvZGluZyA9PT0gJ2Jhc2U2NCcpXG4gICAgICBzdWJqZWN0ID0gYmFzZTY0Y2xlYW4oc3ViamVjdClcbiAgICBsZW5ndGggPSBCdWZmZXIuYnl0ZUxlbmd0aChzdWJqZWN0LCBlbmNvZGluZylcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnb2JqZWN0JyAmJiBzdWJqZWN0ICE9PSBudWxsKSB7IC8vIGFzc3VtZSBvYmplY3QgaXMgYXJyYXktbGlrZVxuICAgIGlmIChzdWJqZWN0LnR5cGUgPT09ICdCdWZmZXInICYmIGlzQXJyYXkoc3ViamVjdC5kYXRhKSlcbiAgICAgIHN1YmplY3QgPSBzdWJqZWN0LmRhdGFcbiAgICBsZW5ndGggPSArc3ViamVjdC5sZW5ndGggPiAwID8gTWF0aC5mbG9vcigrc3ViamVjdC5sZW5ndGgpIDogMFxuICB9IGVsc2VcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtdXN0IHN0YXJ0IHdpdGggbnVtYmVyLCBidWZmZXIsIGFycmF5IG9yIHN0cmluZycpXG5cbiAgaWYgKHRoaXMubGVuZ3RoID4ga01heExlbmd0aClcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICtcbiAgICAgICdzaXplOiAweCcgKyBrTWF4TGVuZ3RoLnRvU3RyaW5nKDE2KSArICcgYnl0ZXMnKVxuXG4gIHZhciBidWZcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUHJlZmVycmVkOiBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIGJ1ZiA9IEJ1ZmZlci5fYXVnbWVudChuZXcgVWludDhBcnJheShsZW5ndGgpKVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gVEhJUyBpbnN0YW5jZSBvZiBCdWZmZXIgKGNyZWF0ZWQgYnkgYG5ld2ApXG4gICAgYnVmID0gdGhpc1xuICAgIGJ1Zi5sZW5ndGggPSBsZW5ndGhcbiAgICBidWYuX2lzQnVmZmVyID0gdHJ1ZVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmIHR5cGVvZiBzdWJqZWN0LmJ5dGVMZW5ndGggPT09ICdudW1iZXInKSB7XG4gICAgLy8gU3BlZWQgb3B0aW1pemF0aW9uIC0tIHVzZSBzZXQgaWYgd2UncmUgY29weWluZyBmcm9tIGEgdHlwZWQgYXJyYXlcbiAgICBidWYuX3NldChzdWJqZWN0KVxuICB9IGVsc2UgaWYgKGlzQXJyYXlpc2goc3ViamVjdCkpIHtcbiAgICAvLyBUcmVhdCBhcnJheS1pc2ggb2JqZWN0cyBhcyBhIGJ5dGUgYXJyYXlcbiAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKHN1YmplY3QpKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspXG4gICAgICAgIGJ1ZltpXSA9IHN1YmplY3QucmVhZFVJbnQ4KGkpXG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKylcbiAgICAgICAgYnVmW2ldID0gKChzdWJqZWN0W2ldICUgMjU2KSArIDI1NikgJSAyNTZcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICBidWYud3JpdGUoc3ViamVjdCwgMCwgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ251bWJlcicgJiYgIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmICFub1plcm8pIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGJ1ZltpXSA9IDBcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnVmXG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIChiKSB7XG4gIHJldHVybiAhIShiICE9IG51bGwgJiYgYi5faXNCdWZmZXIpXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSlcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgbXVzdCBiZSBCdWZmZXJzJylcblxuICB2YXIgeCA9IGEubGVuZ3RoXG4gIHZhciB5ID0gYi5sZW5ndGhcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuICYmIGFbaV0gPT09IGJbaV07IGkrKykge31cbiAgaWYgKGkgIT09IGxlbikge1xuICAgIHggPSBhW2ldXG4gICAgeSA9IGJbaV1cbiAgfVxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICdyYXcnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gKGxpc3QsIHRvdGFsTGVuZ3RoKSB7XG4gIGlmICghaXNBcnJheShsaXN0KSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVXNhZ2U6IEJ1ZmZlci5jb25jYXQobGlzdFssIGxlbmd0aF0pJylcblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcigwKVxuICB9IGVsc2UgaWYgKGxpc3QubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIGxpc3RbMF1cbiAgfVxuXG4gIHZhciBpXG4gIGlmICh0b3RhbExlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdG90YWxMZW5ndGggPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRvdGFsTGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgdmFyIGJ1ZiA9IG5ldyBCdWZmZXIodG90YWxMZW5ndGgpXG4gIHZhciBwb3MgPSAwXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSBsaXN0W2ldXG4gICAgaXRlbS5jb3B5KGJ1ZiwgcG9zKVxuICAgIHBvcyArPSBpdGVtLmxlbmd0aFxuICB9XG4gIHJldHVybiBidWZcbn1cblxuQnVmZmVyLmJ5dGVMZW5ndGggPSBmdW5jdGlvbiAoc3RyLCBlbmNvZGluZykge1xuICB2YXIgcmV0XG4gIHN0ciA9IHN0ciArICcnXG4gIHN3aXRjaCAoZW5jb2RpbmcgfHwgJ3V0ZjgnKSB7XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAncmF3JzpcbiAgICAgIHJldCA9IHN0ci5sZW5ndGhcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldCA9IHN0ci5sZW5ndGggKiAyXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2hleCc6XG4gICAgICByZXQgPSBzdHIubGVuZ3RoID4+PiAxXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIHJldCA9IHV0ZjhUb0J5dGVzKHN0cikubGVuZ3RoXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICByZXQgPSBiYXNlNjRUb0J5dGVzKHN0cikubGVuZ3RoXG4gICAgICBicmVha1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXQgPSBzdHIubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG4vLyBwcmUtc2V0IGZvciB2YWx1ZXMgdGhhdCBtYXkgZXhpc3QgaW4gdGhlIGZ1dHVyZVxuQnVmZmVyLnByb3RvdHlwZS5sZW5ndGggPSB1bmRlZmluZWRcbkJ1ZmZlci5wcm90b3R5cGUucGFyZW50ID0gdW5kZWZpbmVkXG5cbi8vIHRvU3RyaW5nKGVuY29kaW5nLCBzdGFydD0wLCBlbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcblxuICBzdGFydCA9IHN0YXJ0ID4+PiAwXG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA9PT0gSW5maW5pdHkgPyB0aGlzLmxlbmd0aCA6IGVuZCA+Pj4gMFxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG4gIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmIChlbmQgPD0gc3RhcnQpIHJldHVybiAnJ1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGJpbmFyeVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSlcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKGIpIHtcbiAgaWYoIUJ1ZmZlci5pc0J1ZmZlcihiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdHIgPSAnJ1xuICB2YXIgbWF4ID0gZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFU1xuICBpZiAodGhpcy5sZW5ndGggPiAwKSB7XG4gICAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5tYXRjaCgvLnsyfS9nKS5qb2luKCcgJylcbiAgICBpZiAodGhpcy5sZW5ndGggPiBtYXgpXG4gICAgICBzdHIgKz0gJyAuLi4gJ1xuICB9XG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpXG59XG5cbi8vIGBnZXRgIHdpbGwgYmUgcmVtb3ZlZCBpbiBOb2RlIDAuMTMrXG5CdWZmZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgY29uc29sZS5sb2coJy5nZXQoKSBpcyBkZXByZWNhdGVkLiBBY2Nlc3MgdXNpbmcgYXJyYXkgaW5kZXhlcyBpbnN0ZWFkLicpXG4gIHJldHVybiB0aGlzLnJlYWRVSW50OChvZmZzZXQpXG59XG5cbi8vIGBzZXRgIHdpbGwgYmUgcmVtb3ZlZCBpbiBOb2RlIDAuMTMrXG5CdWZmZXIucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh2LCBvZmZzZXQpIHtcbiAgY29uc29sZS5sb2coJy5zZXQoKSBpcyBkZXByZWNhdGVkLiBBY2Nlc3MgdXNpbmcgYXJyYXkgaW5kZXhlcyBpbnN0ZWFkLicpXG4gIHJldHVybiB0aGlzLndyaXRlVUludDgodiwgb2Zmc2V0KVxufVxuXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgdmFyIHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuXG4gIC8vIG11c3QgYmUgYW4gZXZlbiBudW1iZXIgb2YgZGlnaXRzXG4gIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChzdHJMZW4gJSAyICE9PSAwKSB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZycpXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIHZhciBieXRlID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxuICAgIGlmIChpc05hTihieXRlKSkgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGhleCBzdHJpbmcnKVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IGJ5dGVcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgY2hhcnNXcml0dGVuID0gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxuICByZXR1cm4gY2hhcnNXcml0dGVuXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgY2hhcnNXcml0dGVuID0gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbiAgcmV0dXJuIGNoYXJzV3JpdHRlblxufVxuXG5mdW5jdGlvbiBiaW5hcnlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBhc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgY2hhcnNXcml0dGVuID0gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG4gIHJldHVybiBjaGFyc1dyaXR0ZW5cbn1cblxuZnVuY3Rpb24gdXRmMTZsZVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIGNoYXJzV3JpdHRlbiA9IGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbiAgcmV0dXJuIGNoYXJzV3JpdHRlblxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIFN1cHBvcnQgYm90aCAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpXG4gIC8vIGFuZCB0aGUgbGVnYWN5IChzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBpZiAoIWlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIH0gZWxzZSB7ICAvLyBsZWdhY3lcbiAgICB2YXIgc3dhcCA9IGVuY29kaW5nXG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBvZmZzZXQgPSBsZW5ndGhcbiAgICBsZW5ndGggPSBzd2FwXG4gIH1cblxuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG4gIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nIHx8ICd1dGY4JykudG9Mb3dlckNhc2UoKVxuXG4gIHZhciByZXRcbiAgc3dpdGNoIChlbmNvZGluZykge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgICByZXQgPSBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgICByZXQgPSB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYXNjaWknOlxuICAgICAgcmV0ID0gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdiaW5hcnknOlxuICAgICAgcmV0ID0gYmluYXJ5V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIHJldCA9IGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXQgPSB1dGYxNmxlV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmVzID0gJydcbiAgdmFyIHRtcCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIGlmIChidWZbaV0gPD0gMHg3Rikge1xuICAgICAgcmVzICs9IGRlY29kZVV0ZjhDaGFyKHRtcCkgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgICAgIHRtcCA9ICcnXG4gICAgfSBlbHNlIHtcbiAgICAgIHRtcCArPSAnJScgKyBidWZbaV0udG9TdHJpbmcoMTYpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlcyArIGRlY29kZVV0ZjhDaGFyKHRtcClcbn1cblxuZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBiaW5hcnlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHJldHVybiBhc2NpaVNsaWNlKGJ1Ziwgc3RhcnQsIGVuZClcbn1cblxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxuXG4gIHZhciBvdXQgPSAnJ1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIG91dCArPSB0b0hleChidWZbaV0pXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgdmFyIHJlcyA9ICcnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIGJ5dGVzW2kgKyAxXSAqIDI1NilcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgc3RhcnQgPSB+fnN0YXJ0XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmRcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgKz0gbGVuO1xuICAgIGlmIChzdGFydCA8IDApXG4gICAgICBzdGFydCA9IDBcbiAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikge1xuICAgIHN0YXJ0ID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5cbiAgICBpZiAoZW5kIDwgMClcbiAgICAgIGVuZCA9IDBcbiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcbiAgICBlbmQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydClcbiAgICBlbmQgPSBzdGFydFxuXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHJldHVybiBCdWZmZXIuX2F1Z21lbnQodGhpcy5zdWJhcnJheShzdGFydCwgZW5kKSlcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2xpY2VMZW4gPSBlbmQgLSBzdGFydFxuICAgIHZhciBuZXdCdWYgPSBuZXcgQnVmZmVyKHNsaWNlTGVuLCB1bmRlZmluZWQsIHRydWUpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzbGljZUxlbjsgaSsrKSB7XG4gICAgICBuZXdCdWZbaV0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gICAgcmV0dXJuIG5ld0J1ZlxuICB9XG59XG5cbi8qXG4gKiBOZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGJ1ZmZlciBpc24ndCB0cnlpbmcgdG8gd3JpdGUgb3V0IG9mIGJvdW5kcy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tPZmZzZXQgKG9mZnNldCwgZXh0LCBsZW5ndGgpIHtcbiAgaWYgKChvZmZzZXQgJSAxKSAhPT0gMCB8fCBvZmZzZXQgPCAwKVxuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKVxuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgOCkgfCB0aGlzW29mZnNldCArIDFdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAoKHRoaXNbb2Zmc2V0XSkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpKSArXG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSAqIDB4MTAwMDAwMClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gKiAweDEwMDAwMDApICtcbiAgICAgICgodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICAgdGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgaWYgKCEodGhpc1tvZmZzZXRdICYgMHg4MCkpXG4gICAgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8ICh0aGlzW29mZnNldF0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn1cblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdidWZmZXIgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpXG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsdWUgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICB0aGlzW29mZnNldF0gPSB2YWx1ZVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQxNiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCAyKTsgaSA8IGo7IGkrKykge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSAmICgweGZmIDw8ICg4ICogKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkpKSkgPj4+XG4gICAgICAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSAqIDhcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSB2YWx1ZVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9IHZhbHVlXG4gIH0gZWxzZSBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MzIgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDQpOyBpIDwgajsgaSsrKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlID4+PiAobGl0dGxlRW5kaWFuID8gaSA6IDMgLSBpKSAqIDgpICYgMHhmZlxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0XSA9IHZhbHVlXG4gIH0gZWxzZSBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSB2YWx1ZVxuICB9IGVsc2Ugb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSB2YWx1ZVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9IHZhbHVlXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSB2YWx1ZVxuICB9IGVsc2Ugb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSB2YWx1ZVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIH0gZWxzZSBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gdmFsdWVcbiAgfSBlbHNlIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5mdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbHVlIGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFR5cGVFcnJvcignaW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG9hdCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAodGFyZ2V0LCB0YXJnZXRfc3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHNvdXJjZSA9IHRoaXNcblxuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAoIXRhcmdldF9zdGFydCkgdGFyZ2V0X3N0YXJ0ID0gMFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHNvdXJjZS5sZW5ndGggPT09IDApIHJldHVyblxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgaWYgKGVuZCA8IHN0YXJ0KSB0aHJvdyBuZXcgVHlwZUVycm9yKCdzb3VyY2VFbmQgPCBzb3VyY2VTdGFydCcpXG4gIGlmICh0YXJnZXRfc3RhcnQgPCAwIHx8IHRhcmdldF9zdGFydCA+PSB0YXJnZXQubGVuZ3RoKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHNvdXJjZS5sZW5ndGgpIHRocm93IG5ldyBUeXBlRXJyb3IoJ3NvdXJjZVN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBpZiAoZW5kIDwgMCB8fCBlbmQgPiBzb3VyY2UubGVuZ3RoKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKVxuICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0X3N0YXJ0IDwgZW5kIC0gc3RhcnQpXG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldF9zdGFydCArIHN0YXJ0XG5cbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0XG5cbiAgaWYgKGxlbiA8IDEwMDAgfHwgIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRfc3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRhcmdldC5fc2V0KHRoaXMuc3ViYXJyYXkoc3RhcnQsIHN0YXJ0ICsgbGVuKSwgdGFyZ2V0X3N0YXJ0KVxuICB9XG59XG5cbi8vIGZpbGwodmFsdWUsIHN0YXJ0PTAsIGVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gKHZhbHVlLCBzdGFydCwgZW5kKSB7XG4gIGlmICghdmFsdWUpIHZhbHVlID0gMFxuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQpIGVuZCA9IHRoaXMubGVuZ3RoXG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmQgPCBzdGFydCcpXG5cbiAgLy8gRmlsbCAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm5cbiAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm5cblxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdzdGFydCBvdXQgb2YgYm91bmRzJylcbiAgaWYgKGVuZCA8IDAgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuZCBvdXQgb2YgYm91bmRzJylcblxuICB2YXIgaVxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgIHRoaXNbaV0gPSB2YWx1ZVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgYnl0ZXMgPSB1dGY4VG9CeXRlcyh2YWx1ZS50b1N0cmluZygpKVxuICAgIHZhciBsZW4gPSBieXRlcy5sZW5ndGhcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICB0aGlzW2ldID0gYnl0ZXNbaSAlIGxlbl1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgYEFycmF5QnVmZmVyYCB3aXRoIHRoZSAqY29waWVkKiBtZW1vcnkgb2YgdGhlIGJ1ZmZlciBpbnN0YW5jZS5cbiAqIEFkZGVkIGluIE5vZGUgMC4xMi4gT25seSBhdmFpbGFibGUgaW4gYnJvd3NlcnMgdGhhdCBzdXBwb3J0IEFycmF5QnVmZmVyLlxuICovXG5CdWZmZXIucHJvdG90eXBlLnRvQXJyYXlCdWZmZXIgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAgIHJldHVybiAobmV3IEJ1ZmZlcih0aGlzKSkuYnVmZmVyXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBidWYgPSBuZXcgVWludDhBcnJheSh0aGlzLmxlbmd0aClcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBidWYubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgYnVmW2ldID0gdGhpc1tpXVxuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1Zi5idWZmZXJcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQnVmZmVyLnRvQXJyYXlCdWZmZXIgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXInKVxuICB9XG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxudmFyIEJQID0gQnVmZmVyLnByb3RvdHlwZVxuXG4vKipcbiAqIEF1Z21lbnQgYSBVaW50OEFycmF5ICppbnN0YW5jZSogKG5vdCB0aGUgVWludDhBcnJheSBjbGFzcyEpIHdpdGggQnVmZmVyIG1ldGhvZHNcbiAqL1xuQnVmZmVyLl9hdWdtZW50ID0gZnVuY3Rpb24gKGFycikge1xuICBhcnIuY29uc3RydWN0b3IgPSBCdWZmZXJcbiAgYXJyLl9pc0J1ZmZlciA9IHRydWVcblxuICAvLyBzYXZlIHJlZmVyZW5jZSB0byBvcmlnaW5hbCBVaW50OEFycmF5IGdldC9zZXQgbWV0aG9kcyBiZWZvcmUgb3ZlcndyaXRpbmdcbiAgYXJyLl9nZXQgPSBhcnIuZ2V0XG4gIGFyci5fc2V0ID0gYXJyLnNldFxuXG4gIC8vIGRlcHJlY2F0ZWQsIHdpbGwgYmUgcmVtb3ZlZCBpbiBub2RlIDAuMTMrXG4gIGFyci5nZXQgPSBCUC5nZXRcbiAgYXJyLnNldCA9IEJQLnNldFxuXG4gIGFyci53cml0ZSA9IEJQLndyaXRlXG4gIGFyci50b1N0cmluZyA9IEJQLnRvU3RyaW5nXG4gIGFyci50b0xvY2FsZVN0cmluZyA9IEJQLnRvU3RyaW5nXG4gIGFyci50b0pTT04gPSBCUC50b0pTT05cbiAgYXJyLmVxdWFscyA9IEJQLmVxdWFsc1xuICBhcnIuY29tcGFyZSA9IEJQLmNvbXBhcmVcbiAgYXJyLmNvcHkgPSBCUC5jb3B5XG4gIGFyci5zbGljZSA9IEJQLnNsaWNlXG4gIGFyci5yZWFkVUludDggPSBCUC5yZWFkVUludDhcbiAgYXJyLnJlYWRVSW50MTZMRSA9IEJQLnJlYWRVSW50MTZMRVxuICBhcnIucmVhZFVJbnQxNkJFID0gQlAucmVhZFVJbnQxNkJFXG4gIGFyci5yZWFkVUludDMyTEUgPSBCUC5yZWFkVUludDMyTEVcbiAgYXJyLnJlYWRVSW50MzJCRSA9IEJQLnJlYWRVSW50MzJCRVxuICBhcnIucmVhZEludDggPSBCUC5yZWFkSW50OFxuICBhcnIucmVhZEludDE2TEUgPSBCUC5yZWFkSW50MTZMRVxuICBhcnIucmVhZEludDE2QkUgPSBCUC5yZWFkSW50MTZCRVxuICBhcnIucmVhZEludDMyTEUgPSBCUC5yZWFkSW50MzJMRVxuICBhcnIucmVhZEludDMyQkUgPSBCUC5yZWFkSW50MzJCRVxuICBhcnIucmVhZEZsb2F0TEUgPSBCUC5yZWFkRmxvYXRMRVxuICBhcnIucmVhZEZsb2F0QkUgPSBCUC5yZWFkRmxvYXRCRVxuICBhcnIucmVhZERvdWJsZUxFID0gQlAucmVhZERvdWJsZUxFXG4gIGFyci5yZWFkRG91YmxlQkUgPSBCUC5yZWFkRG91YmxlQkVcbiAgYXJyLndyaXRlVUludDggPSBCUC53cml0ZVVJbnQ4XG4gIGFyci53cml0ZVVJbnQxNkxFID0gQlAud3JpdGVVSW50MTZMRVxuICBhcnIud3JpdGVVSW50MTZCRSA9IEJQLndyaXRlVUludDE2QkVcbiAgYXJyLndyaXRlVUludDMyTEUgPSBCUC53cml0ZVVJbnQzMkxFXG4gIGFyci53cml0ZVVJbnQzMkJFID0gQlAud3JpdGVVSW50MzJCRVxuICBhcnIud3JpdGVJbnQ4ID0gQlAud3JpdGVJbnQ4XG4gIGFyci53cml0ZUludDE2TEUgPSBCUC53cml0ZUludDE2TEVcbiAgYXJyLndyaXRlSW50MTZCRSA9IEJQLndyaXRlSW50MTZCRVxuICBhcnIud3JpdGVJbnQzMkxFID0gQlAud3JpdGVJbnQzMkxFXG4gIGFyci53cml0ZUludDMyQkUgPSBCUC53cml0ZUludDMyQkVcbiAgYXJyLndyaXRlRmxvYXRMRSA9IEJQLndyaXRlRmxvYXRMRVxuICBhcnIud3JpdGVGbG9hdEJFID0gQlAud3JpdGVGbG9hdEJFXG4gIGFyci53cml0ZURvdWJsZUxFID0gQlAud3JpdGVEb3VibGVMRVxuICBhcnIud3JpdGVEb3VibGVCRSA9IEJQLndyaXRlRG91YmxlQkVcbiAgYXJyLmZpbGwgPSBCUC5maWxsXG4gIGFyci5pbnNwZWN0ID0gQlAuaW5zcGVjdFxuICBhcnIudG9BcnJheUJ1ZmZlciA9IEJQLnRvQXJyYXlCdWZmZXJcblxuICByZXR1cm4gYXJyXG59XG5cbnZhciBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXitcXC8wLTlBLXpdL2dcblxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xuICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXFxuIGFuZCBcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgc3RyID0gc3RyaW5ndHJpbShzdHIpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxuICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgd2hpbGUgKHN0ci5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgc3RyID0gc3RyICsgJz0nXG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG5mdW5jdGlvbiBzdHJpbmd0cmltIChzdHIpIHtcbiAgaWYgKHN0ci50cmltKSByZXR1cm4gc3RyLnRyaW0oKVxuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKVxufVxuXG5mdW5jdGlvbiBpc0FycmF5aXNoIChzdWJqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5KHN1YmplY3QpIHx8IEJ1ZmZlci5pc0J1ZmZlcihzdWJqZWN0KSB8fFxuICAgICAgc3ViamVjdCAmJiB0eXBlb2Ygc3ViamVjdCA9PT0gJ29iamVjdCcgJiZcbiAgICAgIHR5cGVvZiBzdWJqZWN0Lmxlbmd0aCA9PT0gJ251bWJlcidcbn1cblxuZnVuY3Rpb24gdG9IZXggKG4pIHtcbiAgaWYgKG4gPCAxNikgcmV0dXJuICcwJyArIG4udG9TdHJpbmcoMTYpXG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KVxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIHZhciBiID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBpZiAoYiA8PSAweDdGKSB7XG4gICAgICBieXRlQXJyYXkucHVzaChiKVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgc3RhcnQgPSBpXG4gICAgICBpZiAoYiA+PSAweEQ4MDAgJiYgYiA8PSAweERGRkYpIGkrK1xuICAgICAgdmFyIGggPSBlbmNvZGVVUklDb21wb25lbnQoc3RyLnNsaWNlKHN0YXJ0LCBpKzEpKS5zdWJzdHIoMSkuc3BsaXQoJyUnKVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBoLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGJ5dGVBcnJheS5wdXNoKHBhcnNlSW50KGhbal0sIDE2KSlcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBjLCBoaSwgbG9cbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoc3RyKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSlcbiAgICAgIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gZGVjb2RlVXRmOENoYXIgKHN0cikge1xuICB0cnkge1xuICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoc3RyKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSgweEZGRkQpIC8vIFVURiA4IGludmFsaWQgY2hhclxuICB9XG59XG4iLCJ2YXIgbG9va3VwID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nO1xuXG47KGZ1bmN0aW9uIChleHBvcnRzKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuICB2YXIgQXJyID0gKHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJylcbiAgICA/IFVpbnQ4QXJyYXlcbiAgICA6IEFycmF5XG5cblx0dmFyIFBMVVMgICA9ICcrJy5jaGFyQ29kZUF0KDApXG5cdHZhciBTTEFTSCAgPSAnLycuY2hhckNvZGVBdCgwKVxuXHR2YXIgTlVNQkVSID0gJzAnLmNoYXJDb2RlQXQoMClcblx0dmFyIExPV0VSICA9ICdhJy5jaGFyQ29kZUF0KDApXG5cdHZhciBVUFBFUiAgPSAnQScuY2hhckNvZGVBdCgwKVxuXG5cdGZ1bmN0aW9uIGRlY29kZSAoZWx0KSB7XG5cdFx0dmFyIGNvZGUgPSBlbHQuY2hhckNvZGVBdCgwKVxuXHRcdGlmIChjb2RlID09PSBQTFVTKVxuXHRcdFx0cmV0dXJuIDYyIC8vICcrJ1xuXHRcdGlmIChjb2RlID09PSBTTEFTSClcblx0XHRcdHJldHVybiA2MyAvLyAnLydcblx0XHRpZiAoY29kZSA8IE5VTUJFUilcblx0XHRcdHJldHVybiAtMSAvL25vIG1hdGNoXG5cdFx0aWYgKGNvZGUgPCBOVU1CRVIgKyAxMClcblx0XHRcdHJldHVybiBjb2RlIC0gTlVNQkVSICsgMjYgKyAyNlxuXHRcdGlmIChjb2RlIDwgVVBQRVIgKyAyNilcblx0XHRcdHJldHVybiBjb2RlIC0gVVBQRVJcblx0XHRpZiAoY29kZSA8IExPV0VSICsgMjYpXG5cdFx0XHRyZXR1cm4gY29kZSAtIExPV0VSICsgMjZcblx0fVxuXG5cdGZ1bmN0aW9uIGI2NFRvQnl0ZUFycmF5IChiNjQpIHtcblx0XHR2YXIgaSwgaiwgbCwgdG1wLCBwbGFjZUhvbGRlcnMsIGFyclxuXG5cdFx0aWYgKGI2NC5sZW5ndGggJSA0ID4gMCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0Jylcblx0XHR9XG5cblx0XHQvLyB0aGUgbnVtYmVyIG9mIGVxdWFsIHNpZ25zIChwbGFjZSBob2xkZXJzKVxuXHRcdC8vIGlmIHRoZXJlIGFyZSB0d28gcGxhY2Vob2xkZXJzLCB0aGFuIHRoZSB0d28gY2hhcmFjdGVycyBiZWZvcmUgaXRcblx0XHQvLyByZXByZXNlbnQgb25lIGJ5dGVcblx0XHQvLyBpZiB0aGVyZSBpcyBvbmx5IG9uZSwgdGhlbiB0aGUgdGhyZWUgY2hhcmFjdGVycyBiZWZvcmUgaXQgcmVwcmVzZW50IDIgYnl0ZXNcblx0XHQvLyB0aGlzIGlzIGp1c3QgYSBjaGVhcCBoYWNrIHRvIG5vdCBkbyBpbmRleE9mIHR3aWNlXG5cdFx0dmFyIGxlbiA9IGI2NC5sZW5ndGhcblx0XHRwbGFjZUhvbGRlcnMgPSAnPScgPT09IGI2NC5jaGFyQXQobGVuIC0gMikgPyAyIDogJz0nID09PSBiNjQuY2hhckF0KGxlbiAtIDEpID8gMSA6IDBcblxuXHRcdC8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuXHRcdGFyciA9IG5ldyBBcnIoYjY0Lmxlbmd0aCAqIDMgLyA0IC0gcGxhY2VIb2xkZXJzKVxuXG5cdFx0Ly8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuXHRcdGwgPSBwbGFjZUhvbGRlcnMgPiAwID8gYjY0Lmxlbmd0aCAtIDQgOiBiNjQubGVuZ3RoXG5cblx0XHR2YXIgTCA9IDBcblxuXHRcdGZ1bmN0aW9uIHB1c2ggKHYpIHtcblx0XHRcdGFycltMKytdID0gdlxuXHRcdH1cblxuXHRcdGZvciAoaSA9IDAsIGogPSAwOyBpIDwgbDsgaSArPSA0LCBqICs9IDMpIHtcblx0XHRcdHRtcCA9IChkZWNvZGUoYjY0LmNoYXJBdChpKSkgPDwgMTgpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAxKSkgPDwgMTIpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAyKSkgPDwgNikgfCBkZWNvZGUoYjY0LmNoYXJBdChpICsgMykpXG5cdFx0XHRwdXNoKCh0bXAgJiAweEZGMDAwMCkgPj4gMTYpXG5cdFx0XHRwdXNoKCh0bXAgJiAweEZGMDApID4+IDgpXG5cdFx0XHRwdXNoKHRtcCAmIDB4RkYpXG5cdFx0fVxuXG5cdFx0aWYgKHBsYWNlSG9sZGVycyA9PT0gMikge1xuXHRcdFx0dG1wID0gKGRlY29kZShiNjQuY2hhckF0KGkpKSA8PCAyKSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMSkpID4+IDQpXG5cdFx0XHRwdXNoKHRtcCAmIDB4RkYpXG5cdFx0fSBlbHNlIGlmIChwbGFjZUhvbGRlcnMgPT09IDEpIHtcblx0XHRcdHRtcCA9IChkZWNvZGUoYjY0LmNoYXJBdChpKSkgPDwgMTApIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAxKSkgPDwgNCkgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDIpKSA+PiAyKVxuXHRcdFx0cHVzaCgodG1wID4+IDgpICYgMHhGRilcblx0XHRcdHB1c2godG1wICYgMHhGRilcblx0XHR9XG5cblx0XHRyZXR1cm4gYXJyXG5cdH1cblxuXHRmdW5jdGlvbiB1aW50OFRvQmFzZTY0ICh1aW50OCkge1xuXHRcdHZhciBpLFxuXHRcdFx0ZXh0cmFCeXRlcyA9IHVpbnQ4Lmxlbmd0aCAlIDMsIC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG5cdFx0XHRvdXRwdXQgPSBcIlwiLFxuXHRcdFx0dGVtcCwgbGVuZ3RoXG5cblx0XHRmdW5jdGlvbiBlbmNvZGUgKG51bSkge1xuXHRcdFx0cmV0dXJuIGxvb2t1cC5jaGFyQXQobnVtKVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XG5cdFx0XHRyZXR1cm4gZW5jb2RlKG51bSA+PiAxOCAmIDB4M0YpICsgZW5jb2RlKG51bSA+PiAxMiAmIDB4M0YpICsgZW5jb2RlKG51bSA+PiA2ICYgMHgzRikgKyBlbmNvZGUobnVtICYgMHgzRilcblx0XHR9XG5cblx0XHQvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG5cdFx0Zm9yIChpID0gMCwgbGVuZ3RoID0gdWludDgubGVuZ3RoIC0gZXh0cmFCeXRlczsgaSA8IGxlbmd0aDsgaSArPSAzKSB7XG5cdFx0XHR0ZW1wID0gKHVpbnQ4W2ldIDw8IDE2KSArICh1aW50OFtpICsgMV0gPDwgOCkgKyAodWludDhbaSArIDJdKVxuXHRcdFx0b3V0cHV0ICs9IHRyaXBsZXRUb0Jhc2U2NCh0ZW1wKVxuXHRcdH1cblxuXHRcdC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcblx0XHRzd2l0Y2ggKGV4dHJhQnl0ZXMpIHtcblx0XHRcdGNhc2UgMTpcblx0XHRcdFx0dGVtcCA9IHVpbnQ4W3VpbnQ4Lmxlbmd0aCAtIDFdXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUodGVtcCA+PiAyKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKCh0ZW1wIDw8IDQpICYgMHgzRilcblx0XHRcdFx0b3V0cHV0ICs9ICc9PSdcblx0XHRcdFx0YnJlYWtcblx0XHRcdGNhc2UgMjpcblx0XHRcdFx0dGVtcCA9ICh1aW50OFt1aW50OC5sZW5ndGggLSAyXSA8PCA4KSArICh1aW50OFt1aW50OC5sZW5ndGggLSAxXSlcblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSh0ZW1wID4+IDEwKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKCh0ZW1wID4+IDQpICYgMHgzRilcblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSgodGVtcCA8PCAyKSAmIDB4M0YpXG5cdFx0XHRcdG91dHB1dCArPSAnPSdcblx0XHRcdFx0YnJlYWtcblx0XHR9XG5cblx0XHRyZXR1cm4gb3V0cHV0XG5cdH1cblxuXHRleHBvcnRzLnRvQnl0ZUFycmF5ID0gYjY0VG9CeXRlQXJyYXlcblx0ZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gdWludDhUb0Jhc2U2NFxufSh0eXBlb2YgZXhwb3J0cyA9PT0gJ3VuZGVmaW5lZCcgPyAodGhpcy5iYXNlNjRqcyA9IHt9KSA6IGV4cG9ydHMpKVxuIiwiZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24oYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSxcbiAgICAgIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDEsXG4gICAgICBlTWF4ID0gKDEgPDwgZUxlbikgLSAxLFxuICAgICAgZUJpYXMgPSBlTWF4ID4+IDEsXG4gICAgICBuQml0cyA9IC03LFxuICAgICAgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwLFxuICAgICAgZCA9IGlzTEUgPyAtMSA6IDEsXG4gICAgICBzID0gYnVmZmVyW29mZnNldCArIGldO1xuXG4gIGkgKz0gZDtcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKTtcbiAgcyA+Pj0gKC1uQml0cyk7XG4gIG5CaXRzICs9IGVMZW47XG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSBlICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpO1xuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpO1xuICBlID4+PSAoLW5CaXRzKTtcbiAgbkJpdHMgKz0gbUxlbjtcbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IG0gKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCk7XG5cbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzO1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSk7XG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKTtcbiAgICBlID0gZSAtIGVCaWFzO1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pO1xufTtcblxuZXhwb3J0cy53cml0ZSA9IGZ1bmN0aW9uKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjLFxuICAgICAgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMSxcbiAgICAgIGVNYXggPSAoMSA8PCBlTGVuKSAtIDEsXG4gICAgICBlQmlhcyA9IGVNYXggPj4gMSxcbiAgICAgIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKSxcbiAgICAgIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKSxcbiAgICAgIGQgPSBpc0xFID8gMSA6IC0xLFxuICAgICAgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMDtcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKTtcblxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMDtcbiAgICBlID0gZU1heDtcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMik7XG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tO1xuICAgICAgYyAqPSAyO1xuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gYztcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrKztcbiAgICAgIGMgLz0gMjtcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwO1xuICAgICAgZSA9IGVNYXg7XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICh2YWx1ZSAqIGMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pO1xuICAgICAgZSA9IGUgKyBlQmlhcztcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pO1xuICAgICAgZSA9IDA7XG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCk7XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbTtcbiAgZUxlbiArPSBtTGVuO1xuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpO1xuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyODtcbn07XG4iLCJcbi8qKlxuICogaXNBcnJheVxuICovXG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxuLyoqXG4gKiB0b1N0cmluZ1xuICovXG5cbnZhciBzdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKipcbiAqIFdoZXRoZXIgb3Igbm90IHRoZSBnaXZlbiBgdmFsYFxuICogaXMgYW4gYXJyYXkuXG4gKlxuICogZXhhbXBsZTpcbiAqXG4gKiAgICAgICAgaXNBcnJheShbXSk7XG4gKiAgICAgICAgLy8gPiB0cnVlXG4gKiAgICAgICAgaXNBcnJheShhcmd1bWVudHMpO1xuICogICAgICAgIC8vID4gZmFsc2VcbiAqICAgICAgICBpc0FycmF5KCcnKTtcbiAqICAgICAgICAvLyA+IGZhbHNlXG4gKlxuICogQHBhcmFtIHttaXhlZH0gdmFsXG4gKiBAcmV0dXJuIHtib29sfVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcnJheSB8fCBmdW5jdGlvbiAodmFsKSB7XG4gIHJldHVybiAhISB2YWwgJiYgJ1tvYmplY3QgQXJyYXldJyA9PSBzdHIuY2FsbCh2YWwpO1xufTtcbiIsInZhciBpc0dMID0gcmVxdWlyZSgnaXMtd2ViZ2wtY29udGV4dCcpO1xudmFyIGdldEdMID0gcmVxdWlyZSgnd2ViZ2wtY29udGV4dCcpO1xudmFyIGRlYm91bmNlID0gcmVxdWlyZSgnZGVib3VuY2UnKTtcbnZhciBhZGRFdmVudCA9IHJlcXVpcmUoJ2FkZC1ldmVudC1saXN0ZW5lcicpO1xuXG5mdW5jdGlvbiBpc0NhbnZhc0NvbnRleHQob2JqKSB7XG4gICAgdmFyIGN0eDJkID0gdHlwZW9mIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCAhPT0gJ3VuZGVmaW5lZCcgJiYgb2JqIGluc3RhbmNlb2YgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEO1xuICAgIHJldHVybiBvYmogJiYgKGN0eDJkIHx8IGlzR0wob2JqKSk7XG59XG5cbmZ1bmN0aW9uIENhbnZhc0FwcChyZW5kZXIsIG9wdGlvbnMpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQ2FudmFzQXBwKSlcbiAgICAgICAgcmV0dXJuIG5ldyBDYW52YXNBcHAocmVuZGVyLCBvcHRpb25zKTtcblxuICAgIC8vYWxsb3cgb3B0aW9ucyB0byBiZSBwYXNzZWQgYXMgZmlyc3QgYXJndW1lbnRcbiAgICBpZiAodHlwZW9mIHJlbmRlciA9PT0gJ29iamVjdCcgJiYgcmVuZGVyKSB7XG4gICAgICAgIG9wdGlvbnMgPSByZW5kZXI7XG4gICAgICAgIHJlbmRlciA9IG51bGw7XG4gICAgfVxuXG4gICAgcmVuZGVyID0gdHlwZW9mIHJlbmRlciA9PT0gJ2Z1bmN0aW9uJyA/IHJlbmRlciA6IG9wdGlvbnMub25SZW5kZXI7XG5cbiAgICBvcHRpb25zID0gb3B0aW9uc3x8e307XG4gICAgb3B0aW9ucy5yZXRpbmEgPSB0eXBlb2Ygb3B0aW9ucy5yZXRpbmEgPT09IFwiYm9vbGVhblwiID8gb3B0aW9ucy5yZXRpbmEgOiB0cnVlO1xuICAgIFxuICAgIHZhciBoYXNXaWR0aCA9IHR5cGVvZiBvcHRpb25zLndpZHRoID09PSBcIm51bWJlclwiLCBcbiAgICAgICAgaGFzSGVpZ2h0ID0gdHlwZW9mIG9wdGlvbnMuaGVpZ2h0ID09PSBcIm51bWJlclwiO1xuXG4gICAgLy9pZiBlaXRoZXIgd2lkdGggb3IgaGVpZ2h0IGlzIHNwZWNpZmllZCwgZG9uJ3QgYXV0by1yZXNpemUgdG8gdGhlIHdpbmRvdy4uLlxuICAgIGlmIChoYXNXaWR0aCB8fCBoYXNIZWlnaHQpIFxuICAgICAgICBvcHRpb25zLmlnbm9yZVJlc2l6ZSA9IHRydWU7XG5cbiAgICBvcHRpb25zLndpZHRoID0gaGFzV2lkdGggPyBvcHRpb25zLndpZHRoIDogd2luZG93LmlubmVyV2lkdGg7XG4gICAgb3B0aW9ucy5oZWlnaHQgPSBoYXNIZWlnaHQgPyBvcHRpb25zLmhlaWdodCA6IHdpbmRvdy5pbm5lckhlaWdodDtcblxuICAgIHZhciBEUFIgPSBvcHRpb25zLnJldGluYSA/ICh3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpb3x8MSkgOiAxOyBcblxuICAgIC8vc2V0dXAgdGhlIGNhbnZhc1xuICAgIHZhciBjYW52YXMsXG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGF0dHJpYnMgPSBvcHRpb25zLmNvbnRleHRBdHRyaWJ1dGVzfHx7fTtcblxuICAgIHRoaXMuaXNXZWJHTCA9IGZhbHNlO1xuXG4gICAgLy9pZiB1c2VyIHByb3ZpZGVkIGEgY29udGV4dCBvYmplY3RcbiAgICBpZiAoaXNDYW52YXNDb250ZXh0KG9wdGlvbnMuY29udGV4dCkpIHtcbiAgICAgICAgY29udGV4dCA9IG9wdGlvbnMuY29udGV4dDtcbiAgICAgICAgY2FudmFzID0gY29udGV4dC5jYW52YXM7XG4gICAgfVxuXG4gICAgLy9vdGhlcndpc2UgYWxsb3cgZm9yIGEgc3RyaW5nIHRvIHNldCBvbmUgdXBcbiAgICBpZiAoIWNhbnZhcylcbiAgICAgICAgY2FudmFzID0gb3B0aW9ucy5jYW52YXMgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcblxuICAgIGNhbnZhcy53aWR0aCA9IG9wdGlvbnMud2lkdGggKiBEUFI7XG4gICAgY2FudmFzLmhlaWdodCA9IG9wdGlvbnMuaGVpZ2h0ICogRFBSO1xuXG4gICAgaWYgKCFjb250ZXh0KSB7XG4gICAgICAgIGlmIChvcHRpb25zLmNvbnRleHQgPT09IFwid2ViZ2xcIiB8fCBvcHRpb25zLmNvbnRleHQgPT09IFwiZXhwZXJpbWVudGFsLXdlYmdsXCIpIHtcbiAgICAgICAgICAgIGNvbnRleHQgPSBnZXRHTCh7IGNhbnZhczogY2FudmFzLCBhdHRyaWJ1dGVzOiBhdHRyaWJzIH0pO1xuICAgICAgICAgICAgaWYgKCFjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgXCJXZWJHTCBDb250ZXh0IE5vdCBTdXBwb3J0ZWQgLS0gdHJ5IGVuYWJsaW5nIGl0IG9yIHVzaW5nIGEgZGlmZmVyZW50IGJyb3dzZXJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChvcHRpb25zLmNvbnRleHR8fFwiMmRcIiwgYXR0cmlicyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmlzV2ViR0wgPSBpc0dMKGNvbnRleHQpO1xuXG4gICAgaWYgKG9wdGlvbnMucmV0aW5hKSB7XG4gICAgICAgIGNhbnZhcy5zdHlsZS53aWR0aCA9IG9wdGlvbnMud2lkdGggKyAncHgnO1xuICAgICAgICBjYW52YXMuc3R5bGUuaGVpZ2h0ID0gb3B0aW9ucy5oZWlnaHQgKyAncHgnO1xuICAgIH1cblxuICAgIHRoaXMucnVubmluZyA9IGZhbHNlO1xuICAgIHRoaXMud2lkdGggPSBvcHRpb25zLndpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gb3B0aW9ucy5oZWlnaHQ7XG4gICAgdGhpcy5jYW52YXMgPSBjYW52YXM7XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICB0aGlzLm9uUmVzaXplID0gb3B0aW9ucy5vblJlc2l6ZTtcbiAgICB0aGlzLl9EUFIgPSBEUFI7XG4gICAgdGhpcy5fcmV0aW5hID0gb3B0aW9ucy5yZXRpbmE7XG4gICAgdGhpcy5fb25jZSA9IG9wdGlvbnMub25jZTtcbiAgICB0aGlzLl9pZ25vcmVSZXNpemUgPSBvcHRpb25zLmlnbm9yZVJlc2l6ZTtcbiAgICB0aGlzLl9sYXN0RnJhbWUgPSBudWxsO1xuICAgIHRoaXMuX3RoZW4gPSBEYXRlLm5vdygpO1xuXG4gICAgLy9GUFMgY291bnRlclxuICAgIHRoaXMuZnBzID0gNjA7XG4gICAgdGhpcy5fZnJhbWVzID0gMDtcbiAgICB0aGlzLl9wcmV2VGltZSA9IHRoaXMuX3RoZW47XG5cbiAgICBpZiAoIXRoaXMuX2lnbm9yZVJlc2l6ZSkge1xuICAgICAgICBvcHRpb25zLnJlc2l6ZURlYm91bmNlID0gdHlwZW9mIG9wdGlvbnMucmVzaXplRGVib3VuY2UgPT09ICdudW1iZXInXG4gICAgICAgICAgICAgICAgICAgID8gb3B0aW9ucy5yZXNpemVEZWJvdW5jZSA6IDUwO1xuICAgICAgICBhZGRFdmVudCh3aW5kb3csIFwicmVzaXplXCIsIGRlYm91bmNlKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5yZXNpemUod2luZG93LmlubmVyV2lkdGgsIHdpbmRvdy5pbm5lckhlaWdodCk7XG4gICAgICAgIH0uYmluZCh0aGlzKSwgb3B0aW9ucy5yZXNpemVEZWJvdW5jZSwgZmFsc2UpKTtcblxuICAgICAgICBhZGRFdmVudCh3aW5kb3csIFwib3JpZW50YXRpb25jaGFuZ2VcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLnJlc2l6ZSh3aW5kb3cuaW5uZXJXaWR0aCwgd2luZG93LmlubmVySGVpZ2h0KTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHJlbmRlciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRoaXMub25SZW5kZXIgPSByZW5kZXIuYmluZCh0aGlzKTsgICBcbiAgICB9IGVsc2Uge1xuICAgICAgICAvL2R1bW15IHJlbmRlciBmdW5jdGlvblxuICAgICAgICB0aGlzLm9uUmVuZGVyID0gZnVuY3Rpb24gKGNvbnRleHQsIHdpZHRoLCBoZWlnaHQsIGR0KSB7IH07XG4gICAgfVxuXG4gICAgdGhpcy5yZW5kZXJPbmNlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICB2YXIgZHQgPSAobm93LXRoaXMuX3RoZW4pO1xuXG4gICAgICAgIHRoaXMuX2ZyYW1lcysrO1xuICAgICAgICBpZiAobm93ID4gdGhpcy5fcHJldlRpbWUgKyAxMDAwKSB7XG4gICAgICAgICAgICB0aGlzLmZwcyA9IE1hdGgucm91bmQoKHRoaXMuX2ZyYW1lcyAqIDEwMDApIC8gKG5vdyAtIHRoaXMuX3ByZXZUaW1lKSk7XG5cbiAgICAgICAgICAgIHRoaXMuX3ByZXZUaW1lID0gbm93O1xuICAgICAgICAgICAgdGhpcy5fZnJhbWVzID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5pc1dlYkdMKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHQuc2F2ZSgpO1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0LnNjYWxlKHRoaXMuX0RQUiwgdGhpcy5fRFBSKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC52aWV3cG9ydCgwLCAwLCB0aGlzLndpZHRoICogdGhpcy5fRFBSLCB0aGlzLmhlaWdodCAqIHRoaXMuX0RQUik7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHRoaXMub25SZW5kZXIodGhpcy5jb250ZXh0LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgZHQpO1xuXG4gICAgICAgIGlmICghdGhpcy5pc1dlYkdMKVxuICAgICAgICAgICAgdGhpcy5jb250ZXh0LnJlc3RvcmUoKTtcblxuICAgICAgICB0aGlzLl90aGVuID0gbm93O1xuICAgIH07XG5cbiAgICB0aGlzLl9yZW5kZXJIYW5kbGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5ydW5uaW5nKSBcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgXG4gICAgICAgIGlmICghdGhpcy5fb25jZSkge1xuICAgICAgICAgICAgdGhpcy5fbGFzdEZyYW1lID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuX3JlbmRlckhhbmRsZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5yZW5kZXJPbmNlKCk7XG4gICAgfS5iaW5kKHRoaXMpO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLm9uUmVhZHkgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBvcHRpb25zLm9uUmVhZHkuY2FsbCh0aGlzLCBjb250ZXh0LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQ2FudmFzQXBwLnByb3RvdHlwZSwgJ3JldGluYUVuYWJsZWQnLCB7XG5cbiAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgdGhpcy5fcmV0aW5hID0gdjtcbiAgICAgICAgdGhpcy5fRFBSID0gdGhpcy5fcmV0aW5hID8gKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvfHwxKSA6IDE7XG4gICAgICAgIHRoaXMucmVzaXplKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICB9LFxuXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JldGluYTtcbiAgICB9XG59KTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KENhbnZhc0FwcC5wcm90b3R5cGUsICdkZXZpY2VXaWR0aCcsIHtcblxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpZHRoICogdGhpcy5fRFBSO1xuICAgIH1cbn0pO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQ2FudmFzQXBwLnByb3RvdHlwZSwgJ2RldmljZUhlaWdodCcsIHtcblxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhlaWdodCAqIHRoaXMuX0RQUjtcbiAgICB9XG59KTtcblxuQ2FudmFzQXBwLnByb3RvdHlwZS5yZXNldEZQUyA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2ZyYW1lcyA9IDA7XG4gICAgdGhpcy5fcHJldlRpbWUgPSBEYXRlLm5vdygpO1xuICAgIHRoaXMuX3RoZW4gPSB0aGlzLl9wcmV2VGltZTtcbiAgICB0aGlzLmZwcyA9IDYwO1xufTtcblxuQ2FudmFzQXBwLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLnJ1bm5pbmcpXG4gICAgICAgIHJldHVybjtcbiAgICBcbiAgICBpZiAodGhpcy5fbGFzdEZyYW1lKSBcbiAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5fbGFzdEZyYW1lKTtcblxuICAgIC8vcmVzZXQgRlBTIGNvdW50ZXJcbiAgICB0aGlzLnJlc2V0RlBTKCk7XG5cbiAgICB0aGlzLnJ1bm5pbmcgPSB0cnVlO1xuICAgIHRoaXMuX2xhc3RGcmFtZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLl9yZW5kZXJIYW5kbGVyKTtcbn07XG5cbkNhbnZhc0FwcC5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9sYXN0RnJhbWUpIHtcbiAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5fbGFzdEZyYW1lKTtcbiAgICAgICAgdGhpcy5fbGFzdEZyYW1lID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5ydW5uaW5nID0gZmFsc2U7XG59O1xuXG5DYW52YXNBcHAucHJvdG90eXBlLnJlc2l6ZSA9IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcbiAgICB2YXIgY2FudmFzID0gdGhpcy5jYW52YXM7XG5cbiAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgY2FudmFzLndpZHRoID0gdGhpcy53aWR0aCAqIHRoaXMuX0RQUjtcbiAgICBjYW52YXMuaGVpZ2h0ID0gdGhpcy5oZWlnaHQgKiB0aGlzLl9EUFI7XG5cbiAgICBpZiAodGhpcy5fcmV0aW5hKSB7XG4gICAgICAgIGNhbnZhcy5zdHlsZS53aWR0aCA9IHRoaXMud2lkdGggKyAncHgnO1xuICAgICAgICBjYW52YXMuc3R5bGUuaGVpZ2h0ID0gdGhpcy5oZWlnaHQgKyAncHgnO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9vbmNlKVxuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5fcmVuZGVySGFuZGxlcik7XG4gICAgaWYgKHR5cGVvZiB0aGlzLm9uUmVzaXplID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIHRoaXMub25SZXNpemUodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDYW52YXNBcHA7IiwiYWRkRXZlbnRMaXN0ZW5lci5yZW1vdmVFdmVudExpc3RlbmVyID0gcmVtb3ZlRXZlbnRMaXN0ZW5lclxuYWRkRXZlbnRMaXN0ZW5lci5hZGRFdmVudExpc3RlbmVyID0gYWRkRXZlbnRMaXN0ZW5lclxuXG5tb2R1bGUuZXhwb3J0cyA9IGFkZEV2ZW50TGlzdGVuZXJcblxudmFyIEV2ZW50cyA9IG51bGxcblxuZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcihlbCwgZXZlbnROYW1lLCBsaXN0ZW5lciwgdXNlQ2FwdHVyZSkge1xuICBFdmVudHMgPSBFdmVudHMgfHwgKFxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIgP1xuICAgIHthZGQ6IHN0ZEF0dGFjaCwgcm06IHN0ZERldGFjaH0gOlxuICAgIHthZGQ6IG9sZElFQXR0YWNoLCBybTogb2xkSUVEZXRhY2h9XG4gIClcbiAgXG4gIHJldHVybiBFdmVudHMuYWRkKGVsLCBldmVudE5hbWUsIGxpc3RlbmVyLCB1c2VDYXB0dXJlKVxufVxuXG5mdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVyKGVsLCBldmVudE5hbWUsIGxpc3RlbmVyLCB1c2VDYXB0dXJlKSB7XG4gIEV2ZW50cyA9IEV2ZW50cyB8fCAoXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lciA/XG4gICAge2FkZDogc3RkQXR0YWNoLCBybTogc3RkRGV0YWNofSA6XG4gICAge2FkZDogb2xkSUVBdHRhY2gsIHJtOiBvbGRJRURldGFjaH1cbiAgKVxuICBcbiAgcmV0dXJuIEV2ZW50cy5ybShlbCwgZXZlbnROYW1lLCBsaXN0ZW5lciwgdXNlQ2FwdHVyZSlcbn1cblxuZnVuY3Rpb24gc3RkQXR0YWNoKGVsLCBldmVudE5hbWUsIGxpc3RlbmVyLCB1c2VDYXB0dXJlKSB7XG4gIGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lciwgdXNlQ2FwdHVyZSlcbn1cblxuZnVuY3Rpb24gc3RkRGV0YWNoKGVsLCBldmVudE5hbWUsIGxpc3RlbmVyLCB1c2VDYXB0dXJlKSB7XG4gIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lciwgdXNlQ2FwdHVyZSlcbn1cblxuZnVuY3Rpb24gb2xkSUVBdHRhY2goZWwsIGV2ZW50TmFtZSwgbGlzdGVuZXIsIHVzZUNhcHR1cmUpIHtcbiAgaWYodXNlQ2FwdHVyZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IHVzZUNhcHR1cmUgaW4gb2xkSUUnKVxuICB9XG5cbiAgZWwuYXR0YWNoRXZlbnQoJ29uJyArIGV2ZW50TmFtZSwgbGlzdGVuZXIpXG59XG5cbmZ1bmN0aW9uIG9sZElFRGV0YWNoKGVsLCBldmVudE5hbWUsIGxpc3RlbmVyLCB1c2VDYXB0dXJlKSB7XG4gIGVsLmRldGFjaEV2ZW50KCdvbicgKyBldmVudE5hbWUsIGxpc3RlbmVyKVxufVxuIiwiXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIG5vdyA9IHJlcXVpcmUoJ2RhdGUtbm93Jyk7XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uLCB0aGF0LCBhcyBsb25nIGFzIGl0IGNvbnRpbnVlcyB0byBiZSBpbnZva2VkLCB3aWxsIG5vdFxuICogYmUgdHJpZ2dlcmVkLiBUaGUgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgaXQgc3RvcHMgYmVpbmcgY2FsbGVkIGZvclxuICogTiBtaWxsaXNlY29uZHMuIElmIGBpbW1lZGlhdGVgIGlzIHBhc3NlZCwgdHJpZ2dlciB0aGUgZnVuY3Rpb24gb24gdGhlXG4gKiBsZWFkaW5nIGVkZ2UsIGluc3RlYWQgb2YgdGhlIHRyYWlsaW5nLlxuICpcbiAqIEBzb3VyY2UgdW5kZXJzY29yZS5qc1xuICogQHNlZSBodHRwOi8vdW5zY3JpcHRhYmxlLmNvbS8yMDA5LzAzLzIwL2RlYm91bmNpbmctamF2YXNjcmlwdC1tZXRob2RzL1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuY3Rpb24gdG8gd3JhcFxuICogQHBhcmFtIHtOdW1iZXJ9IHRpbWVvdXQgaW4gbXMgKGAxMDBgKVxuICogQHBhcmFtIHtCb29sZWFufSB3aGV0aGVyIHRvIGV4ZWN1dGUgYXQgdGhlIGJlZ2lubmluZyAoYGZhbHNlYClcbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkZWJvdW5jZShmdW5jLCB3YWl0LCBpbW1lZGlhdGUpe1xuICB2YXIgdGltZW91dCwgYXJncywgY29udGV4dCwgdGltZXN0YW1wLCByZXN1bHQ7XG4gIGlmIChudWxsID09IHdhaXQpIHdhaXQgPSAxMDA7XG5cbiAgZnVuY3Rpb24gbGF0ZXIoKSB7XG4gICAgdmFyIGxhc3QgPSBub3coKSAtIHRpbWVzdGFtcDtcblxuICAgIGlmIChsYXN0IDwgd2FpdCAmJiBsYXN0ID4gMCkge1xuICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQgLSBsYXN0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICBpZiAoIWltbWVkaWF0ZSkge1xuICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICBpZiAoIXRpbWVvdXQpIGNvbnRleHQgPSBhcmdzID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIGRlYm91bmNlZCgpIHtcbiAgICBjb250ZXh0ID0gdGhpcztcbiAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgIHRpbWVzdGFtcCA9IG5vdygpO1xuICAgIHZhciBjYWxsTm93ID0gaW1tZWRpYXRlICYmICF0aW1lb3V0O1xuICAgIGlmICghdGltZW91dCkgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQpO1xuICAgIGlmIChjYWxsTm93KSB7XG4gICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBEYXRlLm5vdyB8fCBub3dcblxuZnVuY3Rpb24gbm93KCkge1xuICAgIHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihjdHgpIHtcblx0aWYgKCFjdHgpIHJldHVybiBmYWxzZVxuXHR2YXIgZ2wgPSBjdHhcblx0Ly9jb21wYXRpYmlsaXR5IHdpdGggQ2hyb21lIFdlYkdMIEluc3BlY3RvciBBZGRvblxuXHRpZiAodHlwZW9mIGN0eC5yYXdnbCAhPT0gJ3VuZGVmaW5lZCcpXG5cdFx0Z2wgPSBjdHgucmF3Z2xcblx0aWYgKHR5cGVvZiBXZWJHTFJlbmRlcmluZ0NvbnRleHQgIT09ICd1bmRlZmluZWQnICYmIGdsIGluc3RhbmNlb2YgV2ViR0xSZW5kZXJpbmdDb250ZXh0KVxuXHRcdHJldHVybiB0cnVlXG5cdHJldHVybiBmYWxzZVxufSIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob3B0cykge1xuICAgIG9wdHMgPSBvcHRzfHx7fTtcbiAgICB2YXIgY2FudmFzID0gb3B0cy5jYW52YXMgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICBpZiAodHlwZW9mIG9wdHMud2lkdGggPT09IFwibnVtYmVyXCIpXG4gICAgICAgIGNhbnZhcy53aWR0aCA9IG9wdHMud2lkdGg7XG4gICAgaWYgKHR5cGVvZiBvcHRzLmhlaWdodCA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IG9wdHMuaGVpZ2h0O1xuICAgIFxuICAgIHZhciBhdHRyaWJzID0gKG9wdHMuYXR0cmlidXRlcyB8fCBvcHRzLmF0dHJpYnMgfHwge30pO1xuICAgIHRyeSB7XG4gICAgICAgIGdsID0gKGNhbnZhcy5nZXRDb250ZXh0KCd3ZWJnbCcsIGF0dHJpYnMpIHx8IGNhbnZhcy5nZXRDb250ZXh0KCdleHBlcmltZW50YWwtd2ViZ2wnLCBhdHRyaWJzKSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBnbCA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiBnbDtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBjbGFtcFxuXG5mdW5jdGlvbiBjbGFtcCh2YWx1ZSwgbWluLCBtYXgpIHtcbiAgcmV0dXJuIG1pbiA8IG1heFxuICAgID8gKHZhbHVlIDwgbWluID8gbWluIDogdmFsdWUgPiBtYXggPyBtYXggOiB2YWx1ZSlcbiAgICA6ICh2YWx1ZSA8IG1heCA/IG1heCA6IHZhbHVlID4gbWluID8gbWluIDogdmFsdWUpXG59XG4iLCIvKiFcbiAgKiBkb21yZWFkeSAoYykgRHVzdGluIERpYXogMjAxNCAtIExpY2Vuc2UgTUlUXG4gICovXG4hZnVuY3Rpb24gKG5hbWUsIGRlZmluaXRpb24pIHtcblxuICBpZiAodHlwZW9mIG1vZHVsZSAhPSAndW5kZWZpbmVkJykgbW9kdWxlLmV4cG9ydHMgPSBkZWZpbml0aW9uKClcbiAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBkZWZpbmUuYW1kID09ICdvYmplY3QnKSBkZWZpbmUoZGVmaW5pdGlvbilcbiAgZWxzZSB0aGlzW25hbWVdID0gZGVmaW5pdGlvbigpXG5cbn0oJ2RvbXJlYWR5JywgZnVuY3Rpb24gKCkge1xuXG4gIHZhciBmbnMgPSBbXSwgbGlzdGVuZXJcbiAgICAsIGRvYyA9IGRvY3VtZW50XG4gICAgLCBoYWNrID0gZG9jLmRvY3VtZW50RWxlbWVudC5kb1Njcm9sbFxuICAgICwgZG9tQ29udGVudExvYWRlZCA9ICdET01Db250ZW50TG9hZGVkJ1xuICAgICwgbG9hZGVkID0gKGhhY2sgPyAvXmxvYWRlZHxeYy8gOiAvXmxvYWRlZHxeaXxeYy8pLnRlc3QoZG9jLnJlYWR5U3RhdGUpXG5cblxuICBpZiAoIWxvYWRlZClcbiAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoZG9tQ29udGVudExvYWRlZCwgbGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoZG9tQ29udGVudExvYWRlZCwgbGlzdGVuZXIpXG4gICAgbG9hZGVkID0gMVxuICAgIHdoaWxlIChsaXN0ZW5lciA9IGZucy5zaGlmdCgpKSBsaXN0ZW5lcigpXG4gIH0pXG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChmbikge1xuICAgIGxvYWRlZCA/IGZuKCkgOiBmbnMucHVzaChmbilcbiAgfVxuXG59KTtcbiIsIm1vZHVsZS5leHBvcnRzID0gaWRlbnRpdHk7XG5cbi8qKlxuICogU2V0IGEgbWF0NCB0byB0aGUgaWRlbnRpdHkgbWF0cml4XG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZnVuY3Rpb24gaWRlbnRpdHkob3V0KSB7XG4gICAgb3V0WzBdID0gMTtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSAwO1xuICAgIG91dFs1XSA9IDE7XG4gICAgb3V0WzZdID0gMDtcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9IDA7XG4gICAgb3V0WzldID0gMDtcbiAgICBvdXRbMTBdID0gMTtcbiAgICBvdXRbMTFdID0gMDtcbiAgICBvdXRbMTJdID0gMDtcbiAgICBvdXRbMTNdID0gMDtcbiAgICBvdXRbMTRdID0gMDtcbiAgICBvdXRbMTVdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IG11bHRpcGx5O1xuXG4vKipcbiAqIE11bHRpcGxpZXMgdHdvIG1hdDQnc1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7bWF0NH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZnVuY3Rpb24gbXVsdGlwbHkob3V0LCBhLCBiKSB7XG4gICAgdmFyIGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sIGEwMyA9IGFbM10sXG4gICAgICAgIGExMCA9IGFbNF0sIGExMSA9IGFbNV0sIGExMiA9IGFbNl0sIGExMyA9IGFbN10sXG4gICAgICAgIGEyMCA9IGFbOF0sIGEyMSA9IGFbOV0sIGEyMiA9IGFbMTBdLCBhMjMgPSBhWzExXSxcbiAgICAgICAgYTMwID0gYVsxMl0sIGEzMSA9IGFbMTNdLCBhMzIgPSBhWzE0XSwgYTMzID0gYVsxNV07XG5cbiAgICAvLyBDYWNoZSBvbmx5IHRoZSBjdXJyZW50IGxpbmUgb2YgdGhlIHNlY29uZCBtYXRyaXhcbiAgICB2YXIgYjAgID0gYlswXSwgYjEgPSBiWzFdLCBiMiA9IGJbMl0sIGIzID0gYlszXTsgIFxuICAgIG91dFswXSA9IGIwKmEwMCArIGIxKmExMCArIGIyKmEyMCArIGIzKmEzMDtcbiAgICBvdXRbMV0gPSBiMCphMDEgKyBiMSphMTEgKyBiMiphMjEgKyBiMyphMzE7XG4gICAgb3V0WzJdID0gYjAqYTAyICsgYjEqYTEyICsgYjIqYTIyICsgYjMqYTMyO1xuICAgIG91dFszXSA9IGIwKmEwMyArIGIxKmExMyArIGIyKmEyMyArIGIzKmEzMztcblxuICAgIGIwID0gYls0XTsgYjEgPSBiWzVdOyBiMiA9IGJbNl07IGIzID0gYls3XTtcbiAgICBvdXRbNF0gPSBiMCphMDAgKyBiMSphMTAgKyBiMiphMjAgKyBiMyphMzA7XG4gICAgb3V0WzVdID0gYjAqYTAxICsgYjEqYTExICsgYjIqYTIxICsgYjMqYTMxO1xuICAgIG91dFs2XSA9IGIwKmEwMiArIGIxKmExMiArIGIyKmEyMiArIGIzKmEzMjtcbiAgICBvdXRbN10gPSBiMCphMDMgKyBiMSphMTMgKyBiMiphMjMgKyBiMyphMzM7XG5cbiAgICBiMCA9IGJbOF07IGIxID0gYls5XTsgYjIgPSBiWzEwXTsgYjMgPSBiWzExXTtcbiAgICBvdXRbOF0gPSBiMCphMDAgKyBiMSphMTAgKyBiMiphMjAgKyBiMyphMzA7XG4gICAgb3V0WzldID0gYjAqYTAxICsgYjEqYTExICsgYjIqYTIxICsgYjMqYTMxO1xuICAgIG91dFsxMF0gPSBiMCphMDIgKyBiMSphMTIgKyBiMiphMjIgKyBiMyphMzI7XG4gICAgb3V0WzExXSA9IGIwKmEwMyArIGIxKmExMyArIGIyKmEyMyArIGIzKmEzMztcblxuICAgIGIwID0gYlsxMl07IGIxID0gYlsxM107IGIyID0gYlsxNF07IGIzID0gYlsxNV07XG4gICAgb3V0WzEyXSA9IGIwKmEwMCArIGIxKmExMCArIGIyKmEyMCArIGIzKmEzMDtcbiAgICBvdXRbMTNdID0gYjAqYTAxICsgYjEqYTExICsgYjIqYTIxICsgYjMqYTMxO1xuICAgIG91dFsxNF0gPSBiMCphMDIgKyBiMSphMTIgKyBiMiphMjIgKyBiMyphMzI7XG4gICAgb3V0WzE1XSA9IGIwKmEwMyArIGIxKmExMyArIGIyKmEyMyArIGIzKmEzMztcbiAgICByZXR1cm4gb3V0O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IHNjYWxlO1xuXG4vKipcbiAqIFNjYWxlcyB0aGUgbWF0NCBieSB0aGUgZGltZW5zaW9ucyBpbiB0aGUgZ2l2ZW4gdmVjM1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIG1hdHJpeCB0byBzY2FsZVxuICogQHBhcmFtIHt2ZWMzfSB2IHRoZSB2ZWMzIHRvIHNjYWxlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqKi9cbmZ1bmN0aW9uIHNjYWxlKG91dCwgYSwgdikge1xuICAgIHZhciB4ID0gdlswXSwgeSA9IHZbMV0sIHogPSB2WzJdO1xuXG4gICAgb3V0WzBdID0gYVswXSAqIHg7XG4gICAgb3V0WzFdID0gYVsxXSAqIHg7XG4gICAgb3V0WzJdID0gYVsyXSAqIHg7XG4gICAgb3V0WzNdID0gYVszXSAqIHg7XG4gICAgb3V0WzRdID0gYVs0XSAqIHk7XG4gICAgb3V0WzVdID0gYVs1XSAqIHk7XG4gICAgb3V0WzZdID0gYVs2XSAqIHk7XG4gICAgb3V0WzddID0gYVs3XSAqIHk7XG4gICAgb3V0WzhdID0gYVs4XSAqIHo7XG4gICAgb3V0WzldID0gYVs5XSAqIHo7XG4gICAgb3V0WzEwXSA9IGFbMTBdICogejtcbiAgICBvdXRbMTFdID0gYVsxMV0gKiB6O1xuICAgIG91dFsxMl0gPSBhWzEyXTtcbiAgICBvdXRbMTNdID0gYVsxM107XG4gICAgb3V0WzE0XSA9IGFbMTRdO1xuICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgICByZXR1cm4gb3V0O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IHRyYW5zbGF0ZTtcblxuLyoqXG4gKiBUcmFuc2xhdGUgYSBtYXQ0IGJ5IHRoZSBnaXZlbiB2ZWN0b3JcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBtYXRyaXggdG8gdHJhbnNsYXRlXG4gKiBAcGFyYW0ge3ZlYzN9IHYgdmVjdG9yIHRvIHRyYW5zbGF0ZSBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5mdW5jdGlvbiB0cmFuc2xhdGUob3V0LCBhLCB2KSB7XG4gICAgdmFyIHggPSB2WzBdLCB5ID0gdlsxXSwgeiA9IHZbMl0sXG4gICAgICAgIGEwMCwgYTAxLCBhMDIsIGEwMyxcbiAgICAgICAgYTEwLCBhMTEsIGExMiwgYTEzLFxuICAgICAgICBhMjAsIGEyMSwgYTIyLCBhMjM7XG5cbiAgICBpZiAoYSA9PT0gb3V0KSB7XG4gICAgICAgIG91dFsxMl0gPSBhWzBdICogeCArIGFbNF0gKiB5ICsgYVs4XSAqIHogKyBhWzEyXTtcbiAgICAgICAgb3V0WzEzXSA9IGFbMV0gKiB4ICsgYVs1XSAqIHkgKyBhWzldICogeiArIGFbMTNdO1xuICAgICAgICBvdXRbMTRdID0gYVsyXSAqIHggKyBhWzZdICogeSArIGFbMTBdICogeiArIGFbMTRdO1xuICAgICAgICBvdXRbMTVdID0gYVszXSAqIHggKyBhWzddICogeSArIGFbMTFdICogeiArIGFbMTVdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGEwMCA9IGFbMF07IGEwMSA9IGFbMV07IGEwMiA9IGFbMl07IGEwMyA9IGFbM107XG4gICAgICAgIGExMCA9IGFbNF07IGExMSA9IGFbNV07IGExMiA9IGFbNl07IGExMyA9IGFbN107XG4gICAgICAgIGEyMCA9IGFbOF07IGEyMSA9IGFbOV07IGEyMiA9IGFbMTBdOyBhMjMgPSBhWzExXTtcblxuICAgICAgICBvdXRbMF0gPSBhMDA7IG91dFsxXSA9IGEwMTsgb3V0WzJdID0gYTAyOyBvdXRbM10gPSBhMDM7XG4gICAgICAgIG91dFs0XSA9IGExMDsgb3V0WzVdID0gYTExOyBvdXRbNl0gPSBhMTI7IG91dFs3XSA9IGExMztcbiAgICAgICAgb3V0WzhdID0gYTIwOyBvdXRbOV0gPSBhMjE7IG91dFsxMF0gPSBhMjI7IG91dFsxMV0gPSBhMjM7XG5cbiAgICAgICAgb3V0WzEyXSA9IGEwMCAqIHggKyBhMTAgKiB5ICsgYTIwICogeiArIGFbMTJdO1xuICAgICAgICBvdXRbMTNdID0gYTAxICogeCArIGExMSAqIHkgKyBhMjEgKiB6ICsgYVsxM107XG4gICAgICAgIG91dFsxNF0gPSBhMDIgKiB4ICsgYTEyICogeSArIGEyMiAqIHogKyBhWzE0XTtcbiAgICAgICAgb3V0WzE1XSA9IGEwMyAqIHggKyBhMTMgKiB5ICsgYTIzICogeiArIGFbMTVdO1xuICAgIH1cblxuICAgIHJldHVybiBvdXQ7XG59OyIsIlwidXNlIHN0cmljdFwiXG5cbnZhciBjb21waWxlID0gcmVxdWlyZShcImN3aXNlLWNvbXBpbGVyXCIpXG5cbnZhciBFbXB0eVByb2MgPSB7XG4gIGJvZHk6IFwiXCIsXG4gIGFyZ3M6IFtdLFxuICB0aGlzVmFyczogW10sXG4gIGxvY2FsVmFyczogW11cbn1cblxuZnVuY3Rpb24gZml4dXAoeCkge1xuICBpZigheCkge1xuICAgIHJldHVybiBFbXB0eVByb2NcbiAgfVxuICBmb3IodmFyIGk9MDsgaTx4LmFyZ3MubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYSA9IHguYXJnc1tpXVxuICAgIGlmKGkgPT09IDApIHtcbiAgICAgIHguYXJnc1tpXSA9IHtuYW1lOiBhLCBsdmFsdWU6dHJ1ZSwgcnZhbHVlOiAhIXgucnZhbHVlLCBjb3VudDp4LmNvdW50fHwxIH1cbiAgICB9IGVsc2Uge1xuICAgICAgeC5hcmdzW2ldID0ge25hbWU6IGEsIGx2YWx1ZTpmYWxzZSwgcnZhbHVlOnRydWUsIGNvdW50OiAxfVxuICAgIH1cbiAgfVxuICBpZigheC50aGlzVmFycykge1xuICAgIHgudGhpc1ZhcnMgPSBbXVxuICB9XG4gIGlmKCF4LmxvY2FsVmFycykge1xuICAgIHgubG9jYWxWYXJzID0gW11cbiAgfVxuICByZXR1cm4geFxufVxuXG5mdW5jdGlvbiBwY29tcGlsZSh1c2VyX2FyZ3MpIHtcbiAgcmV0dXJuIGNvbXBpbGUoe1xuICAgIGFyZ3M6ICAgICB1c2VyX2FyZ3MuYXJncyxcbiAgICBwcmU6ICAgICAgZml4dXAodXNlcl9hcmdzLnByZSksXG4gICAgYm9keTogICAgIGZpeHVwKHVzZXJfYXJncy5ib2R5KSxcbiAgICBwb3N0OiAgICAgZml4dXAodXNlcl9hcmdzLnByb2MpLFxuICAgIGZ1bmNOYW1lOiB1c2VyX2FyZ3MuZnVuY05hbWVcbiAgfSlcbn1cblxuZnVuY3Rpb24gbWFrZU9wKHVzZXJfYXJncykge1xuICB2YXIgYXJncyA9IFtdXG4gIGZvcih2YXIgaT0wOyBpPHVzZXJfYXJncy5hcmdzLmxlbmd0aDsgKytpKSB7XG4gICAgYXJncy5wdXNoKFwiYVwiK2kpXG4gIH1cbiAgdmFyIHdyYXBwZXIgPSBuZXcgRnVuY3Rpb24oXCJQXCIsIFtcbiAgICBcInJldHVybiBmdW5jdGlvbiBcIiwgdXNlcl9hcmdzLmZ1bmNOYW1lLCBcIl9uZGFycmF5b3BzKFwiLCBhcmdzLmpvaW4oXCIsXCIpLCBcIikge1AoXCIsIGFyZ3Muam9pbihcIixcIiksIFwiKTtyZXR1cm4gYTB9XCJcbiAgXS5qb2luKFwiXCIpKVxuICByZXR1cm4gd3JhcHBlcihwY29tcGlsZSh1c2VyX2FyZ3MpKVxufVxuXG52YXIgYXNzaWduX29wcyA9IHtcbiAgYWRkOiAgXCIrXCIsXG4gIHN1YjogIFwiLVwiLFxuICBtdWw6ICBcIipcIixcbiAgZGl2OiAgXCIvXCIsXG4gIG1vZDogIFwiJVwiLFxuICBiYW5kOiBcIiZcIixcbiAgYm9yOiAgXCJ8XCIsXG4gIGJ4b3I6IFwiXlwiLFxuICBsc2hpZnQ6IFwiPDxcIixcbiAgcnNoaWZ0OiBcIj4+XCIsXG4gIHJyc2hpZnQ6IFwiPj4+XCJcbn1cbjsoZnVuY3Rpb24oKXtcbiAgZm9yKHZhciBpZCBpbiBhc3NpZ25fb3BzKSB7XG4gICAgdmFyIG9wID0gYXNzaWduX29wc1tpZF1cbiAgICBleHBvcnRzW2lkXSA9IG1ha2VPcCh7XG4gICAgICBhcmdzOiBbXCJhcnJheVwiLFwiYXJyYXlcIixcImFycmF5XCJdLFxuICAgICAgYm9keToge2FyZ3M6W1wiYVwiLFwiYlwiLFwiY1wiXSxcbiAgICAgICAgICAgICBib2R5OiBcImE9YlwiK29wK1wiY1wifSxcbiAgICAgIGZ1bmNOYW1lOiBpZFxuICAgIH0pXG4gICAgZXhwb3J0c1tpZCtcImVxXCJdID0gbWFrZU9wKHtcbiAgICAgIGFyZ3M6IFtcImFycmF5XCIsXCJhcnJheVwiXSxcbiAgICAgIGJvZHk6IHthcmdzOltcImFcIixcImJcIl0sXG4gICAgICAgICAgICAgYm9keTpcImFcIitvcCtcIj1iXCJ9LFxuICAgICAgcnZhbHVlOiB0cnVlLFxuICAgICAgZnVuY05hbWU6IGlkK1wiZXFcIlxuICAgIH0pXG4gICAgZXhwb3J0c1tpZCtcInNcIl0gPSBtYWtlT3Aoe1xuICAgICAgYXJnczogW1wiYXJyYXlcIiwgXCJhcnJheVwiLCBcInNjYWxhclwiXSxcbiAgICAgIGJvZHk6IHthcmdzOltcImFcIixcImJcIixcInNcIl0sXG4gICAgICAgICAgICAgYm9keTpcImE9YlwiK29wK1wic1wifSxcbiAgICAgIGZ1bmNOYW1lOiBpZCtcInNcIlxuICAgIH0pXG4gICAgZXhwb3J0c1tpZCtcInNlcVwiXSA9IG1ha2VPcCh7XG4gICAgICBhcmdzOiBbXCJhcnJheVwiLFwic2NhbGFyXCJdLFxuICAgICAgYm9keToge2FyZ3M6W1wiYVwiLFwic1wiXSxcbiAgICAgICAgICAgICBib2R5OlwiYVwiK29wK1wiPXNcIn0sXG4gICAgICBydmFsdWU6IHRydWUsXG4gICAgICBmdW5jTmFtZTogaWQrXCJzZXFcIlxuICAgIH0pXG4gIH1cbn0pKCk7XG5cbnZhciB1bmFyeV9vcHMgPSB7XG4gIG5vdDogXCIhXCIsXG4gIGJub3Q6IFwiflwiLFxuICBuZWc6IFwiLVwiLFxuICByZWNpcDogXCIxLjAvXCJcbn1cbjsoZnVuY3Rpb24oKXtcbiAgZm9yKHZhciBpZCBpbiB1bmFyeV9vcHMpIHtcbiAgICB2YXIgb3AgPSB1bmFyeV9vcHNbaWRdXG4gICAgZXhwb3J0c1tpZF0gPSBtYWtlT3Aoe1xuICAgICAgYXJnczogW1wiYXJyYXlcIiwgXCJhcnJheVwiXSxcbiAgICAgIGJvZHk6IHthcmdzOltcImFcIixcImJcIl0sXG4gICAgICAgICAgICAgYm9keTpcImE9XCIrb3ArXCJiXCJ9LFxuICAgICAgZnVuY05hbWU6IGlkXG4gICAgfSlcbiAgICBleHBvcnRzW2lkK1wiZXFcIl0gPSBtYWtlT3Aoe1xuICAgICAgYXJnczogW1wiYXJyYXlcIl0sXG4gICAgICBib2R5OiB7YXJnczpbXCJhXCJdLFxuICAgICAgICAgICAgIGJvZHk6XCJhPVwiK29wK1wiYVwifSxcbiAgICAgIHJ2YWx1ZTogdHJ1ZSxcbiAgICAgIGNvdW50OiAyLFxuICAgICAgZnVuY05hbWU6IGlkK1wiZXFcIlxuICAgIH0pXG4gIH1cbn0pKCk7XG5cbnZhciBiaW5hcnlfb3BzID0ge1xuICBhbmQ6IFwiJiZcIixcbiAgb3I6IFwifHxcIixcbiAgZXE6IFwiPT09XCIsXG4gIG5lcTogXCIhPT1cIixcbiAgbHQ6IFwiPFwiLFxuICBndDogXCI+XCIsXG4gIGxlcTogXCI8PVwiLFxuICBnZXE6IFwiPj1cIlxufVxuOyhmdW5jdGlvbigpIHtcbiAgZm9yKHZhciBpZCBpbiBiaW5hcnlfb3BzKSB7XG4gICAgdmFyIG9wID0gYmluYXJ5X29wc1tpZF1cbiAgICBleHBvcnRzW2lkXSA9IG1ha2VPcCh7XG4gICAgICBhcmdzOiBbXCJhcnJheVwiLFwiYXJyYXlcIixcImFycmF5XCJdLFxuICAgICAgYm9keToge2FyZ3M6W1wiYVwiLCBcImJcIiwgXCJjXCJdLFxuICAgICAgICAgICAgIGJvZHk6XCJhPWJcIitvcCtcImNcIn0sXG4gICAgICBmdW5jTmFtZTogaWRcbiAgICB9KVxuICAgIGV4cG9ydHNbaWQrXCJzXCJdID0gbWFrZU9wKHtcbiAgICAgIGFyZ3M6IFtcImFycmF5XCIsXCJhcnJheVwiLFwic2NhbGFyXCJdLFxuICAgICAgYm9keToge2FyZ3M6W1wiYVwiLCBcImJcIiwgXCJzXCJdLFxuICAgICAgICAgICAgIGJvZHk6XCJhPWJcIitvcCtcInNcIn0sXG4gICAgICBmdW5jTmFtZTogaWQrXCJzXCJcbiAgICB9KVxuICAgIGV4cG9ydHNbaWQrXCJlcVwiXSA9IG1ha2VPcCh7XG4gICAgICBhcmdzOiBbXCJhcnJheVwiLCBcImFycmF5XCJdLFxuICAgICAgYm9keToge2FyZ3M6W1wiYVwiLCBcImJcIl0sXG4gICAgICAgICAgICAgYm9keTpcImE9YVwiK29wK1wiYlwifSxcbiAgICAgIHJ2YWx1ZTp0cnVlLFxuICAgICAgY291bnQ6MixcbiAgICAgIGZ1bmNOYW1lOiBpZCtcImVxXCJcbiAgICB9KVxuICAgIGV4cG9ydHNbaWQrXCJzZXFcIl0gPSBtYWtlT3Aoe1xuICAgICAgYXJnczogW1wiYXJyYXlcIiwgXCJzY2FsYXJcIl0sXG4gICAgICBib2R5OiB7YXJnczpbXCJhXCIsXCJzXCJdLFxuICAgICAgICAgICAgIGJvZHk6XCJhPWFcIitvcCtcInNcIn0sXG4gICAgICBydmFsdWU6dHJ1ZSxcbiAgICAgIGNvdW50OjIsXG4gICAgICBmdW5jTmFtZTogaWQrXCJzZXFcIlxuICAgIH0pXG4gIH1cbn0pKCk7XG5cbnZhciBtYXRoX3VuYXJ5ID0gW1xuICBcImFic1wiLFxuICBcImFjb3NcIixcbiAgXCJhc2luXCIsXG4gIFwiYXRhblwiLFxuICBcImNlaWxcIixcbiAgXCJjb3NcIixcbiAgXCJleHBcIixcbiAgXCJmbG9vclwiLFxuICBcImxvZ1wiLFxuICBcInJvdW5kXCIsXG4gIFwic2luXCIsXG4gIFwic3FydFwiLFxuICBcInRhblwiXG5dXG47KGZ1bmN0aW9uKCkge1xuICBmb3IodmFyIGk9MDsgaTxtYXRoX3VuYXJ5Lmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGYgPSBtYXRoX3VuYXJ5W2ldXG4gICAgZXhwb3J0c1tmXSA9IG1ha2VPcCh7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtcImFycmF5XCIsIFwiYXJyYXlcIl0sXG4gICAgICAgICAgICAgICAgICAgIHByZToge2FyZ3M6W10sIGJvZHk6XCJ0aGlzX2Y9TWF0aC5cIitmLCB0aGlzVmFyczpbXCJ0aGlzX2ZcIl19LFxuICAgICAgICAgICAgICAgICAgICBib2R5OiB7YXJnczpbXCJhXCIsXCJiXCJdLCBib2R5OlwiYT10aGlzX2YoYilcIiwgdGhpc1ZhcnM6W1widGhpc19mXCJdfSxcbiAgICAgICAgICAgICAgICAgICAgZnVuY05hbWU6IGZcbiAgICAgICAgICAgICAgICAgIH0pXG4gICAgZXhwb3J0c1tmK1wiZXFcIl0gPSBtYWtlT3Aoe1xuICAgICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtcImFycmF5XCJdLFxuICAgICAgICAgICAgICAgICAgICAgIHByZToge2FyZ3M6W10sIGJvZHk6XCJ0aGlzX2Y9TWF0aC5cIitmLCB0aGlzVmFyczpbXCJ0aGlzX2ZcIl19LFxuICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IHthcmdzOiBbXCJhXCJdLCBib2R5OlwiYT10aGlzX2YoYSlcIiwgdGhpc1ZhcnM6W1widGhpc19mXCJdfSxcbiAgICAgICAgICAgICAgICAgICAgICBydmFsdWU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgY291bnQ6IDIsXG4gICAgICAgICAgICAgICAgICAgICAgZnVuY05hbWU6IGYrXCJlcVwiXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gIH1cbn0pKCk7XG5cbnZhciBtYXRoX2NvbW0gPSBbXG4gIFwibWF4XCIsXG4gIFwibWluXCIsXG4gIFwiYXRhbjJcIixcbiAgXCJwb3dcIlxuXVxuOyhmdW5jdGlvbigpe1xuICBmb3IodmFyIGk9MDsgaTxtYXRoX2NvbW0ubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgZj0gbWF0aF9jb21tW2ldXG4gICAgZXhwb3J0c1tmXSA9IG1ha2VPcCh7XG4gICAgICAgICAgICAgICAgICBhcmdzOltcImFycmF5XCIsIFwiYXJyYXlcIiwgXCJhcnJheVwiXSxcbiAgICAgICAgICAgICAgICAgIHByZToge2FyZ3M6W10sIGJvZHk6XCJ0aGlzX2Y9TWF0aC5cIitmLCB0aGlzVmFyczpbXCJ0aGlzX2ZcIl19LFxuICAgICAgICAgICAgICAgICAgYm9keToge2FyZ3M6W1wiYVwiLFwiYlwiLFwiY1wiXSwgYm9keTpcImE9dGhpc19mKGIsYylcIiwgdGhpc1ZhcnM6W1widGhpc19mXCJdfSxcbiAgICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiBmXG4gICAgICAgICAgICAgICAgfSlcbiAgICBleHBvcnRzW2YrXCJzXCJdID0gbWFrZU9wKHtcbiAgICAgICAgICAgICAgICAgIGFyZ3M6W1wiYXJyYXlcIiwgXCJhcnJheVwiLCBcInNjYWxhclwiXSxcbiAgICAgICAgICAgICAgICAgIHByZToge2FyZ3M6W10sIGJvZHk6XCJ0aGlzX2Y9TWF0aC5cIitmLCB0aGlzVmFyczpbXCJ0aGlzX2ZcIl19LFxuICAgICAgICAgICAgICAgICAgYm9keToge2FyZ3M6W1wiYVwiLFwiYlwiLFwiY1wiXSwgYm9keTpcImE9dGhpc19mKGIsYylcIiwgdGhpc1ZhcnM6W1widGhpc19mXCJdfSxcbiAgICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiBmK1wic1wiXG4gICAgICAgICAgICAgICAgICB9KVxuICAgIGV4cG9ydHNbZitcImVxXCJdID0gbWFrZU9wKHsgYXJnczpbXCJhcnJheVwiLCBcImFycmF5XCJdLFxuICAgICAgICAgICAgICAgICAgcHJlOiB7YXJnczpbXSwgYm9keTpcInRoaXNfZj1NYXRoLlwiK2YsIHRoaXNWYXJzOltcInRoaXNfZlwiXX0sXG4gICAgICAgICAgICAgICAgICBib2R5OiB7YXJnczpbXCJhXCIsXCJiXCJdLCBib2R5OlwiYT10aGlzX2YoYSxiKVwiLCB0aGlzVmFyczpbXCJ0aGlzX2ZcIl19LFxuICAgICAgICAgICAgICAgICAgcnZhbHVlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgY291bnQ6IDIsXG4gICAgICAgICAgICAgICAgICBmdW5jTmFtZTogZitcImVxXCJcbiAgICAgICAgICAgICAgICAgIH0pXG4gICAgZXhwb3J0c1tmK1wic2VxXCJdID0gbWFrZU9wKHsgYXJnczpbXCJhcnJheVwiLCBcInNjYWxhclwiXSxcbiAgICAgICAgICAgICAgICAgIHByZToge2FyZ3M6W10sIGJvZHk6XCJ0aGlzX2Y9TWF0aC5cIitmLCB0aGlzVmFyczpbXCJ0aGlzX2ZcIl19LFxuICAgICAgICAgICAgICAgICAgYm9keToge2FyZ3M6W1wiYVwiLFwiYlwiXSwgYm9keTpcImE9dGhpc19mKGEsYilcIiwgdGhpc1ZhcnM6W1widGhpc19mXCJdfSxcbiAgICAgICAgICAgICAgICAgIHJ2YWx1ZTp0cnVlLFxuICAgICAgICAgICAgICAgICAgY291bnQ6MixcbiAgICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiBmK1wic2VxXCJcbiAgICAgICAgICAgICAgICAgIH0pXG4gIH1cbn0pKCk7XG5cbnZhciBtYXRoX25vbmNvbW0gPSBbXG4gIFwiYXRhbjJcIixcbiAgXCJwb3dcIlxuXVxuOyhmdW5jdGlvbigpe1xuICBmb3IodmFyIGk9MDsgaTxtYXRoX25vbmNvbW0ubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgZj0gbWF0aF9ub25jb21tW2ldXG4gICAgZXhwb3J0c1tmK1wib3BcIl0gPSBtYWtlT3Aoe1xuICAgICAgICAgICAgICAgICAgYXJnczpbXCJhcnJheVwiLCBcImFycmF5XCIsIFwiYXJyYXlcIl0sXG4gICAgICAgICAgICAgICAgICBwcmU6IHthcmdzOltdLCBib2R5OlwidGhpc19mPU1hdGguXCIrZiwgdGhpc1ZhcnM6W1widGhpc19mXCJdfSxcbiAgICAgICAgICAgICAgICAgIGJvZHk6IHthcmdzOltcImFcIixcImJcIixcImNcIl0sIGJvZHk6XCJhPXRoaXNfZihjLGIpXCIsIHRoaXNWYXJzOltcInRoaXNfZlwiXX0sXG4gICAgICAgICAgICAgICAgICBmdW5jTmFtZTogZitcIm9wXCJcbiAgICAgICAgICAgICAgICB9KVxuICAgIGV4cG9ydHNbZitcIm9wc1wiXSA9IG1ha2VPcCh7XG4gICAgICAgICAgICAgICAgICBhcmdzOltcImFycmF5XCIsIFwiYXJyYXlcIiwgXCJzY2FsYXJcIl0sXG4gICAgICAgICAgICAgICAgICBwcmU6IHthcmdzOltdLCBib2R5OlwidGhpc19mPU1hdGguXCIrZiwgdGhpc1ZhcnM6W1widGhpc19mXCJdfSxcbiAgICAgICAgICAgICAgICAgIGJvZHk6IHthcmdzOltcImFcIixcImJcIixcImNcIl0sIGJvZHk6XCJhPXRoaXNfZihjLGIpXCIsIHRoaXNWYXJzOltcInRoaXNfZlwiXX0sXG4gICAgICAgICAgICAgICAgICBmdW5jTmFtZTogZitcIm9wc1wiXG4gICAgICAgICAgICAgICAgICB9KVxuICAgIGV4cG9ydHNbZitcIm9wZXFcIl0gPSBtYWtlT3AoeyBhcmdzOltcImFycmF5XCIsIFwiYXJyYXlcIl0sXG4gICAgICAgICAgICAgICAgICBwcmU6IHthcmdzOltdLCBib2R5OlwidGhpc19mPU1hdGguXCIrZiwgdGhpc1ZhcnM6W1widGhpc19mXCJdfSxcbiAgICAgICAgICAgICAgICAgIGJvZHk6IHthcmdzOltcImFcIixcImJcIl0sIGJvZHk6XCJhPXRoaXNfZihiLGEpXCIsIHRoaXNWYXJzOltcInRoaXNfZlwiXX0sXG4gICAgICAgICAgICAgICAgICBydmFsdWU6IHRydWUsXG4gICAgICAgICAgICAgICAgICBjb3VudDogMixcbiAgICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiBmK1wib3BlcVwiXG4gICAgICAgICAgICAgICAgICB9KVxuICAgIGV4cG9ydHNbZitcIm9wc2VxXCJdID0gbWFrZU9wKHsgYXJnczpbXCJhcnJheVwiLCBcInNjYWxhclwiXSxcbiAgICAgICAgICAgICAgICAgIHByZToge2FyZ3M6W10sIGJvZHk6XCJ0aGlzX2Y9TWF0aC5cIitmLCB0aGlzVmFyczpbXCJ0aGlzX2ZcIl19LFxuICAgICAgICAgICAgICAgICAgYm9keToge2FyZ3M6W1wiYVwiLFwiYlwiXSwgYm9keTpcImE9dGhpc19mKGIsYSlcIiwgdGhpc1ZhcnM6W1widGhpc19mXCJdfSxcbiAgICAgICAgICAgICAgICAgIHJ2YWx1ZTp0cnVlLFxuICAgICAgICAgICAgICAgICAgY291bnQ6MixcbiAgICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiBmK1wib3BzZXFcIlxuICAgICAgICAgICAgICAgICAgfSlcbiAgfVxufSkoKTtcblxuZXhwb3J0cy5hbnkgPSBjb21waWxlKHtcbiAgYXJnczpbXCJhcnJheVwiXSxcbiAgcHJlOiBFbXB0eVByb2MsXG4gIGJvZHk6IHthcmdzOlt7bmFtZTpcImFcIiwgbHZhbHVlOmZhbHNlLCBydmFsdWU6dHJ1ZSwgY291bnQ6MX1dLCBib2R5OiBcImlmKGEpe3JldHVybiB0cnVlfVwiLCBsb2NhbFZhcnM6IFtdLCB0aGlzVmFyczogW119LFxuICBwb3N0OiB7YXJnczpbXSwgbG9jYWxWYXJzOltdLCB0aGlzVmFyczpbXSwgYm9keTpcInJldHVybiBmYWxzZVwifSxcbiAgZnVuY05hbWU6IFwiYW55XCJcbn0pXG5cbmV4cG9ydHMuYWxsID0gY29tcGlsZSh7XG4gIGFyZ3M6W1wiYXJyYXlcIl0sXG4gIHByZTogRW1wdHlQcm9jLFxuICBib2R5OiB7YXJnczpbe25hbWU6XCJ4XCIsIGx2YWx1ZTpmYWxzZSwgcnZhbHVlOnRydWUsIGNvdW50OjF9XSwgYm9keTogXCJpZigheCl7cmV0dXJuIGZhbHNlfVwiLCBsb2NhbFZhcnM6IFtdLCB0aGlzVmFyczogW119LFxuICBwb3N0OiB7YXJnczpbXSwgbG9jYWxWYXJzOltdLCB0aGlzVmFyczpbXSwgYm9keTpcInJldHVybiB0cnVlXCJ9LFxuICBmdW5jTmFtZTogXCJhbGxcIlxufSlcblxuZXhwb3J0cy5zdW0gPSBjb21waWxlKHtcbiAgYXJnczpbXCJhcnJheVwiXSxcbiAgcHJlOiB7YXJnczpbXSwgbG9jYWxWYXJzOltdLCB0aGlzVmFyczpbXCJ0aGlzX3NcIl0sIGJvZHk6XCJ0aGlzX3M9MFwifSxcbiAgYm9keToge2FyZ3M6W3tuYW1lOlwiYVwiLCBsdmFsdWU6ZmFsc2UsIHJ2YWx1ZTp0cnVlLCBjb3VudDoxfV0sIGJvZHk6IFwidGhpc19zKz1hXCIsIGxvY2FsVmFyczogW10sIHRoaXNWYXJzOiBbXCJ0aGlzX3NcIl19LFxuICBwb3N0OiB7YXJnczpbXSwgbG9jYWxWYXJzOltdLCB0aGlzVmFyczpbXCJ0aGlzX3NcIl0sIGJvZHk6XCJyZXR1cm4gdGhpc19zXCJ9LFxuICBmdW5jTmFtZTogXCJzdW1cIlxufSlcblxuZXhwb3J0cy5wcm9kID0gY29tcGlsZSh7XG4gIGFyZ3M6W1wiYXJyYXlcIl0sXG4gIHByZToge2FyZ3M6W10sIGxvY2FsVmFyczpbXSwgdGhpc1ZhcnM6W1widGhpc19zXCJdLCBib2R5OlwidGhpc19zPTFcIn0sXG4gIGJvZHk6IHthcmdzOlt7bmFtZTpcImFcIiwgbHZhbHVlOmZhbHNlLCBydmFsdWU6dHJ1ZSwgY291bnQ6MX1dLCBib2R5OiBcInRoaXNfcyo9YVwiLCBsb2NhbFZhcnM6IFtdLCB0aGlzVmFyczogW1widGhpc19zXCJdfSxcbiAgcG9zdDoge2FyZ3M6W10sIGxvY2FsVmFyczpbXSwgdGhpc1ZhcnM6W1widGhpc19zXCJdLCBib2R5OlwicmV0dXJuIHRoaXNfc1wifSxcbiAgZnVuY05hbWU6IFwicHJvZFwiXG59KVxuXG5leHBvcnRzLm5vcm0yc3F1YXJlZCA9IGNvbXBpbGUoe1xuICBhcmdzOltcImFycmF5XCJdLFxuICBwcmU6IHthcmdzOltdLCBsb2NhbFZhcnM6W10sIHRoaXNWYXJzOltcInRoaXNfc1wiXSwgYm9keTpcInRoaXNfcz0wXCJ9LFxuICBib2R5OiB7YXJnczpbe25hbWU6XCJhXCIsIGx2YWx1ZTpmYWxzZSwgcnZhbHVlOnRydWUsIGNvdW50OjJ9XSwgYm9keTogXCJ0aGlzX3MrPWEqYVwiLCBsb2NhbFZhcnM6IFtdLCB0aGlzVmFyczogW1widGhpc19zXCJdfSxcbiAgcG9zdDoge2FyZ3M6W10sIGxvY2FsVmFyczpbXSwgdGhpc1ZhcnM6W1widGhpc19zXCJdLCBib2R5OlwicmV0dXJuIHRoaXNfc1wifSxcbiAgZnVuY05hbWU6IFwibm9ybTJzcXVhcmVkXCJcbn0pXG4gIFxuZXhwb3J0cy5ub3JtMiA9IGNvbXBpbGUoe1xuICBhcmdzOltcImFycmF5XCJdLFxuICBwcmU6IHthcmdzOltdLCBsb2NhbFZhcnM6W10sIHRoaXNWYXJzOltcInRoaXNfc1wiXSwgYm9keTpcInRoaXNfcz0wXCJ9LFxuICBib2R5OiB7YXJnczpbe25hbWU6XCJhXCIsIGx2YWx1ZTpmYWxzZSwgcnZhbHVlOnRydWUsIGNvdW50OjJ9XSwgYm9keTogXCJ0aGlzX3MrPWEqYVwiLCBsb2NhbFZhcnM6IFtdLCB0aGlzVmFyczogW1widGhpc19zXCJdfSxcbiAgcG9zdDoge2FyZ3M6W10sIGxvY2FsVmFyczpbXSwgdGhpc1ZhcnM6W1widGhpc19zXCJdLCBib2R5OlwicmV0dXJuIE1hdGguc3FydCh0aGlzX3MpXCJ9LFxuICBmdW5jTmFtZTogXCJub3JtMlwiXG59KVxuICBcblxuZXhwb3J0cy5ub3JtaW5mID0gY29tcGlsZSh7XG4gIGFyZ3M6W1wiYXJyYXlcIl0sXG4gIHByZToge2FyZ3M6W10sIGxvY2FsVmFyczpbXSwgdGhpc1ZhcnM6W1widGhpc19zXCJdLCBib2R5OlwidGhpc19zPTBcIn0sXG4gIGJvZHk6IHthcmdzOlt7bmFtZTpcImFcIiwgbHZhbHVlOmZhbHNlLCBydmFsdWU6dHJ1ZSwgY291bnQ6NH1dLCBib2R5OlwiaWYoLWE+dGhpc19zKXt0aGlzX3M9LWF9ZWxzZSBpZihhPnRoaXNfcyl7dGhpc19zPWF9XCIsIGxvY2FsVmFyczogW10sIHRoaXNWYXJzOiBbXCJ0aGlzX3NcIl19LFxuICBwb3N0OiB7YXJnczpbXSwgbG9jYWxWYXJzOltdLCB0aGlzVmFyczpbXCJ0aGlzX3NcIl0sIGJvZHk6XCJyZXR1cm4gdGhpc19zXCJ9LFxuICBmdW5jTmFtZTogXCJub3JtaW5mXCJcbn0pXG5cbmV4cG9ydHMubm9ybTEgPSBjb21waWxlKHtcbiAgYXJnczpbXCJhcnJheVwiXSxcbiAgcHJlOiB7YXJnczpbXSwgbG9jYWxWYXJzOltdLCB0aGlzVmFyczpbXCJ0aGlzX3NcIl0sIGJvZHk6XCJ0aGlzX3M9MFwifSxcbiAgYm9keToge2FyZ3M6W3tuYW1lOlwiYVwiLCBsdmFsdWU6ZmFsc2UsIHJ2YWx1ZTp0cnVlLCBjb3VudDozfV0sIGJvZHk6IFwidGhpc19zKz1hPDA/LWE6YVwiLCBsb2NhbFZhcnM6IFtdLCB0aGlzVmFyczogW1widGhpc19zXCJdfSxcbiAgcG9zdDoge2FyZ3M6W10sIGxvY2FsVmFyczpbXSwgdGhpc1ZhcnM6W1widGhpc19zXCJdLCBib2R5OlwicmV0dXJuIHRoaXNfc1wifSxcbiAgZnVuY05hbWU6IFwibm9ybTFcIlxufSlcblxuZXhwb3J0cy5zdXAgPSBjb21waWxlKHtcbiAgYXJnczogWyBcImFycmF5XCIgXSxcbiAgcHJlOlxuICAgeyBib2R5OiBcInRoaXNfaD0tSW5maW5pdHlcIixcbiAgICAgYXJnczogW10sXG4gICAgIHRoaXNWYXJzOiBbIFwidGhpc19oXCIgXSxcbiAgICAgbG9jYWxWYXJzOiBbXSB9LFxuICBib2R5OlxuICAgeyBib2R5OiBcImlmKF9pbmxpbmVfMV9hcmcwXz50aGlzX2gpdGhpc19oPV9pbmxpbmVfMV9hcmcwX1wiLFxuICAgICBhcmdzOiBbe1wibmFtZVwiOlwiX2lubGluZV8xX2FyZzBfXCIsXCJsdmFsdWVcIjpmYWxzZSxcInJ2YWx1ZVwiOnRydWUsXCJjb3VudFwiOjJ9IF0sXG4gICAgIHRoaXNWYXJzOiBbIFwidGhpc19oXCIgXSxcbiAgICAgbG9jYWxWYXJzOiBbXSB9LFxuICBwb3N0OlxuICAgeyBib2R5OiBcInJldHVybiB0aGlzX2hcIixcbiAgICAgYXJnczogW10sXG4gICAgIHRoaXNWYXJzOiBbIFwidGhpc19oXCIgXSxcbiAgICAgbG9jYWxWYXJzOiBbXSB9XG4gfSlcblxuZXhwb3J0cy5pbmYgPSBjb21waWxlKHtcbiAgYXJnczogWyBcImFycmF5XCIgXSxcbiAgcHJlOlxuICAgeyBib2R5OiBcInRoaXNfaD1JbmZpbml0eVwiLFxuICAgICBhcmdzOiBbXSxcbiAgICAgdGhpc1ZhcnM6IFsgXCJ0aGlzX2hcIiBdLFxuICAgICBsb2NhbFZhcnM6IFtdIH0sXG4gIGJvZHk6XG4gICB7IGJvZHk6IFwiaWYoX2lubGluZV8xX2FyZzBfPHRoaXNfaCl0aGlzX2g9X2lubGluZV8xX2FyZzBfXCIsXG4gICAgIGFyZ3M6IFt7XCJuYW1lXCI6XCJfaW5saW5lXzFfYXJnMF9cIixcImx2YWx1ZVwiOmZhbHNlLFwicnZhbHVlXCI6dHJ1ZSxcImNvdW50XCI6Mn0gXSxcbiAgICAgdGhpc1ZhcnM6IFsgXCJ0aGlzX2hcIiBdLFxuICAgICBsb2NhbFZhcnM6IFtdIH0sXG4gIHBvc3Q6XG4gICB7IGJvZHk6IFwicmV0dXJuIHRoaXNfaFwiLFxuICAgICBhcmdzOiBbXSxcbiAgICAgdGhpc1ZhcnM6IFsgXCJ0aGlzX2hcIiBdLFxuICAgICBsb2NhbFZhcnM6IFtdIH1cbiB9KVxuXG5leHBvcnRzLmFyZ21pbiA9IGNvbXBpbGUoe1xuICBhcmdzOltcImluZGV4XCIsXCJhcnJheVwiLFwic2hhcGVcIl0sXG4gIHByZTp7XG4gICAgYm9keTpcInt0aGlzX3Y9SW5maW5pdHk7dGhpc19pPV9pbmxpbmVfMF9hcmcyXy5zbGljZSgwKX1cIixcbiAgICBhcmdzOltcbiAgICAgIHtuYW1lOlwiX2lubGluZV8wX2FyZzBfXCIsbHZhbHVlOmZhbHNlLHJ2YWx1ZTpmYWxzZSxjb3VudDowfSxcbiAgICAgIHtuYW1lOlwiX2lubGluZV8wX2FyZzFfXCIsbHZhbHVlOmZhbHNlLHJ2YWx1ZTpmYWxzZSxjb3VudDowfSxcbiAgICAgIHtuYW1lOlwiX2lubGluZV8wX2FyZzJfXCIsbHZhbHVlOmZhbHNlLHJ2YWx1ZTp0cnVlLGNvdW50OjF9XG4gICAgICBdLFxuICAgIHRoaXNWYXJzOltcInRoaXNfaVwiLFwidGhpc192XCJdLFxuICAgIGxvY2FsVmFyczpbXX0sXG4gIGJvZHk6e1xuICAgIGJvZHk6XCJ7aWYoX2lubGluZV8xX2FyZzFfPHRoaXNfdil7dGhpc192PV9pbmxpbmVfMV9hcmcxXztmb3IodmFyIF9pbmxpbmVfMV9rPTA7X2lubGluZV8xX2s8X2lubGluZV8xX2FyZzBfLmxlbmd0aDsrK19pbmxpbmVfMV9rKXt0aGlzX2lbX2lubGluZV8xX2tdPV9pbmxpbmVfMV9hcmcwX1tfaW5saW5lXzFfa119fX1cIixcbiAgICBhcmdzOltcbiAgICAgIHtuYW1lOlwiX2lubGluZV8xX2FyZzBfXCIsbHZhbHVlOmZhbHNlLHJ2YWx1ZTp0cnVlLGNvdW50OjJ9LFxuICAgICAge25hbWU6XCJfaW5saW5lXzFfYXJnMV9cIixsdmFsdWU6ZmFsc2UscnZhbHVlOnRydWUsY291bnQ6Mn1dLFxuICAgIHRoaXNWYXJzOltcInRoaXNfaVwiLFwidGhpc192XCJdLFxuICAgIGxvY2FsVmFyczpbXCJfaW5saW5lXzFfa1wiXX0sXG4gIHBvc3Q6e1xuICAgIGJvZHk6XCJ7cmV0dXJuIHRoaXNfaX1cIixcbiAgICBhcmdzOltdLFxuICAgIHRoaXNWYXJzOltcInRoaXNfaVwiXSxcbiAgICBsb2NhbFZhcnM6W119XG59KVxuXG5leHBvcnRzLmFyZ21heCA9IGNvbXBpbGUoe1xuICBhcmdzOltcImluZGV4XCIsXCJhcnJheVwiLFwic2hhcGVcIl0sXG4gIHByZTp7XG4gICAgYm9keTpcInt0aGlzX3Y9LUluZmluaXR5O3RoaXNfaT1faW5saW5lXzBfYXJnMl8uc2xpY2UoMCl9XCIsXG4gICAgYXJnczpbXG4gICAgICB7bmFtZTpcIl9pbmxpbmVfMF9hcmcwX1wiLGx2YWx1ZTpmYWxzZSxydmFsdWU6ZmFsc2UsY291bnQ6MH0sXG4gICAgICB7bmFtZTpcIl9pbmxpbmVfMF9hcmcxX1wiLGx2YWx1ZTpmYWxzZSxydmFsdWU6ZmFsc2UsY291bnQ6MH0sXG4gICAgICB7bmFtZTpcIl9pbmxpbmVfMF9hcmcyX1wiLGx2YWx1ZTpmYWxzZSxydmFsdWU6dHJ1ZSxjb3VudDoxfVxuICAgICAgXSxcbiAgICB0aGlzVmFyczpbXCJ0aGlzX2lcIixcInRoaXNfdlwiXSxcbiAgICBsb2NhbFZhcnM6W119LFxuICBib2R5OntcbiAgICBib2R5Olwie2lmKF9pbmxpbmVfMV9hcmcxXz50aGlzX3Ype3RoaXNfdj1faW5saW5lXzFfYXJnMV87Zm9yKHZhciBfaW5saW5lXzFfaz0wO19pbmxpbmVfMV9rPF9pbmxpbmVfMV9hcmcwXy5sZW5ndGg7KytfaW5saW5lXzFfayl7dGhpc19pW19pbmxpbmVfMV9rXT1faW5saW5lXzFfYXJnMF9bX2lubGluZV8xX2tdfX19XCIsXG4gICAgYXJnczpbXG4gICAgICB7bmFtZTpcIl9pbmxpbmVfMV9hcmcwX1wiLGx2YWx1ZTpmYWxzZSxydmFsdWU6dHJ1ZSxjb3VudDoyfSxcbiAgICAgIHtuYW1lOlwiX2lubGluZV8xX2FyZzFfXCIsbHZhbHVlOmZhbHNlLHJ2YWx1ZTp0cnVlLGNvdW50OjJ9XSxcbiAgICB0aGlzVmFyczpbXCJ0aGlzX2lcIixcInRoaXNfdlwiXSxcbiAgICBsb2NhbFZhcnM6W1wiX2lubGluZV8xX2tcIl19LFxuICBwb3N0OntcbiAgICBib2R5Olwie3JldHVybiB0aGlzX2l9XCIsXG4gICAgYXJnczpbXSxcbiAgICB0aGlzVmFyczpbXCJ0aGlzX2lcIl0sXG4gICAgbG9jYWxWYXJzOltdfVxufSkgIFxuXG5leHBvcnRzLnJhbmRvbSA9IG1ha2VPcCh7XG4gIGFyZ3M6IFtcImFycmF5XCJdLFxuICBwcmU6IHthcmdzOltdLCBib2R5OlwidGhpc19mPU1hdGgucmFuZG9tXCIsIHRoaXNWYXJzOltcInRoaXNfZlwiXX0sXG4gIGJvZHk6IHthcmdzOiBbXCJhXCJdLCBib2R5OlwiYT10aGlzX2YoKVwiLCB0aGlzVmFyczpbXCJ0aGlzX2ZcIl19LFxuICBmdW5jTmFtZTogXCJyYW5kb21cIlxufSlcblxuZXhwb3J0cy5hc3NpZ24gPSBtYWtlT3Aoe1xuICBhcmdzOltcImFycmF5XCIsIFwiYXJyYXlcIl0sXG4gIGJvZHk6IHthcmdzOltcImFcIiwgXCJiXCJdLCBib2R5OlwiYT1iXCJ9LFxuICBmdW5jTmFtZTogXCJhc3NpZ25cIiB9KVxuXG5leHBvcnRzLmFzc2lnbnMgPSBtYWtlT3Aoe1xuICBhcmdzOltcImFycmF5XCIsIFwic2NhbGFyXCJdLFxuICBib2R5OiB7YXJnczpbXCJhXCIsIFwiYlwiXSwgYm9keTpcImE9YlwifSxcbiAgZnVuY05hbWU6IFwiYXNzaWduc1wiIH0pXG5cblxuZXhwb3J0cy5lcXVhbHMgPSBjb21waWxlKHtcbiAgYXJnczpbXCJhcnJheVwiLCBcImFycmF5XCJdLFxuICBwcmU6IEVtcHR5UHJvYyxcbiAgYm9keToge2FyZ3M6W3tuYW1lOlwieFwiLCBsdmFsdWU6ZmFsc2UsIHJ2YWx1ZTp0cnVlLCBjb3VudDoxfSxcbiAgICAgICAgICAgICAgIHtuYW1lOlwieVwiLCBsdmFsdWU6ZmFsc2UsIHJ2YWx1ZTp0cnVlLCBjb3VudDoxfV0sIFxuICAgICAgICBib2R5OiBcImlmKHghPT15KXtyZXR1cm4gZmFsc2V9XCIsIFxuICAgICAgICBsb2NhbFZhcnM6IFtdLCBcbiAgICAgICAgdGhpc1ZhcnM6IFtdfSxcbiAgcG9zdDoge2FyZ3M6W10sIGxvY2FsVmFyczpbXSwgdGhpc1ZhcnM6W10sIGJvZHk6XCJyZXR1cm4gdHJ1ZVwifSxcbiAgZnVuY05hbWU6IFwiZXF1YWxzXCJcbn0pXG5cblxuIiwiXCJ1c2Ugc3RyaWN0XCJcblxudmFyIGNyZWF0ZVRodW5rID0gcmVxdWlyZShcIi4vbGliL3RodW5rLmpzXCIpXG5cbmZ1bmN0aW9uIFByb2NlZHVyZSgpIHtcbiAgdGhpcy5hcmdUeXBlcyA9IFtdXG4gIHRoaXMuc2hpbUFyZ3MgPSBbXVxuICB0aGlzLmFycmF5QXJncyA9IFtdXG4gIHRoaXMuc2NhbGFyQXJncyA9IFtdXG4gIHRoaXMub2Zmc2V0QXJncyA9IFtdXG4gIHRoaXMub2Zmc2V0QXJnSW5kZXggPSBbXVxuICB0aGlzLmluZGV4QXJncyA9IFtdXG4gIHRoaXMuc2hhcGVBcmdzID0gW11cbiAgdGhpcy5mdW5jTmFtZSA9IFwiXCJcbiAgdGhpcy5wcmUgPSBudWxsXG4gIHRoaXMuYm9keSA9IG51bGxcbiAgdGhpcy5wb3N0ID0gbnVsbFxuICB0aGlzLmRlYnVnID0gZmFsc2Vcbn1cblxuZnVuY3Rpb24gY29tcGlsZUN3aXNlKHVzZXJfYXJncykge1xuICAvL0NyZWF0ZSBwcm9jZWR1cmVcbiAgdmFyIHByb2MgPSBuZXcgUHJvY2VkdXJlKClcbiAgXG4gIC8vUGFyc2UgYmxvY2tzXG4gIHByb2MucHJlICAgID0gdXNlcl9hcmdzLnByZVxuICBwcm9jLmJvZHkgICA9IHVzZXJfYXJncy5ib2R5XG4gIHByb2MucG9zdCAgID0gdXNlcl9hcmdzLnBvc3RcblxuICAvL1BhcnNlIGFyZ3VtZW50c1xuICB2YXIgcHJvY19hcmdzID0gdXNlcl9hcmdzLmFyZ3Muc2xpY2UoMClcbiAgcHJvYy5hcmdUeXBlcyA9IHByb2NfYXJnc1xuICBmb3IodmFyIGk9MDsgaTxwcm9jX2FyZ3MubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYXJnX3R5cGUgPSBwcm9jX2FyZ3NbaV1cbiAgICBpZihhcmdfdHlwZSA9PT0gXCJhcnJheVwiKSB7XG4gICAgICBwcm9jLmFycmF5QXJncy5wdXNoKGkpXG4gICAgICBwcm9jLnNoaW1BcmdzLnB1c2goXCJhcnJheVwiICsgaSlcbiAgICAgIGlmKGkgPCBwcm9jLnByZS5hcmdzLmxlbmd0aCAmJiBwcm9jLnByZS5hcmdzW2ldLmNvdW50PjApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY3dpc2U6IHByZSgpIGJsb2NrIG1heSBub3QgcmVmZXJlbmNlIGFycmF5IGFyZ3NcIilcbiAgICAgIH1cbiAgICAgIGlmKGkgPCBwcm9jLnBvc3QuYXJncy5sZW5ndGggJiYgcHJvYy5wb3N0LmFyZ3NbaV0uY291bnQ+MCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjd2lzZTogcG9zdCgpIGJsb2NrIG1heSBub3QgcmVmZXJlbmNlIGFycmF5IGFyZ3NcIilcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYoYXJnX3R5cGUgPT09IFwic2NhbGFyXCIpIHtcbiAgICAgIHByb2Muc2NhbGFyQXJncy5wdXNoKGkpXG4gICAgICBwcm9jLnNoaW1BcmdzLnB1c2goXCJzY2FsYXJcIiArIGkpXG4gICAgfSBlbHNlIGlmKGFyZ190eXBlID09PSBcImluZGV4XCIpIHtcbiAgICAgIHByb2MuaW5kZXhBcmdzLnB1c2goaSlcbiAgICAgIGlmKGkgPCBwcm9jLnByZS5hcmdzLmxlbmd0aCAmJiBwcm9jLnByZS5hcmdzW2ldLmNvdW50ID4gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjd2lzZTogcHJlKCkgYmxvY2sgbWF5IG5vdCByZWZlcmVuY2UgYXJyYXkgaW5kZXhcIilcbiAgICAgIH1cbiAgICAgIGlmKGkgPCBwcm9jLmJvZHkuYXJncy5sZW5ndGggJiYgcHJvYy5ib2R5LmFyZ3NbaV0ubHZhbHVlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImN3aXNlOiBib2R5KCkgYmxvY2sgbWF5IG5vdCB3cml0ZSB0byBhcnJheSBpbmRleFwiKVxuICAgICAgfVxuICAgICAgaWYoaSA8IHByb2MucG9zdC5hcmdzLmxlbmd0aCAmJiBwcm9jLnBvc3QuYXJnc1tpXS5jb3VudCA+IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY3dpc2U6IHBvc3QoKSBibG9jayBtYXkgbm90IHJlZmVyZW5jZSBhcnJheSBpbmRleFwiKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZihhcmdfdHlwZSA9PT0gXCJzaGFwZVwiKSB7XG4gICAgICBwcm9jLnNoYXBlQXJncy5wdXNoKGkpXG4gICAgICBpZihpIDwgcHJvYy5wcmUuYXJncy5sZW5ndGggJiYgcHJvYy5wcmUuYXJnc1tpXS5sdmFsdWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY3dpc2U6IHByZSgpIGJsb2NrIG1heSBub3Qgd3JpdGUgdG8gYXJyYXkgc2hhcGVcIilcbiAgICAgIH1cbiAgICAgIGlmKGkgPCBwcm9jLmJvZHkuYXJncy5sZW5ndGggJiYgcHJvYy5ib2R5LmFyZ3NbaV0ubHZhbHVlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImN3aXNlOiBib2R5KCkgYmxvY2sgbWF5IG5vdCB3cml0ZSB0byBhcnJheSBzaGFwZVwiKVxuICAgICAgfVxuICAgICAgaWYoaSA8IHByb2MucG9zdC5hcmdzLmxlbmd0aCAmJiBwcm9jLnBvc3QuYXJnc1tpXS5sdmFsdWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY3dpc2U6IHBvc3QoKSBibG9jayBtYXkgbm90IHdyaXRlIHRvIGFycmF5IHNoYXBlXCIpXG4gICAgICB9XG4gICAgfSBlbHNlIGlmKHR5cGVvZiBhcmdfdHlwZSA9PT0gXCJvYmplY3RcIiAmJiBhcmdfdHlwZS5vZmZzZXQpIHtcbiAgICAgIHByb2MuYXJnVHlwZXNbaV0gPSBcIm9mZnNldFwiXG4gICAgICBwcm9jLm9mZnNldEFyZ3MucHVzaCh7IGFycmF5OiBhcmdfdHlwZS5hcnJheSwgb2Zmc2V0OmFyZ190eXBlLm9mZnNldCB9KVxuICAgICAgcHJvYy5vZmZzZXRBcmdJbmRleC5wdXNoKGkpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImN3aXNlOiBVbmtub3duIGFyZ3VtZW50IHR5cGUgXCIgKyBwcm9jX2FyZ3NbaV0pXG4gICAgfVxuICB9XG4gIFxuICAvL01ha2Ugc3VyZSBhdCBsZWFzdCBvbmUgYXJyYXkgYXJndW1lbnQgd2FzIHNwZWNpZmllZFxuICBpZihwcm9jLmFycmF5QXJncy5sZW5ndGggPD0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImN3aXNlOiBObyBhcnJheSBhcmd1bWVudHMgc3BlY2lmaWVkXCIpXG4gIH1cbiAgXG4gIC8vTWFrZSBzdXJlIGFyZ3VtZW50cyBhcmUgY29ycmVjdFxuICBpZihwcm9jLnByZS5hcmdzLmxlbmd0aCA+IHByb2NfYXJncy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJjd2lzZTogVG9vIG1hbnkgYXJndW1lbnRzIGluIHByZSgpIGJsb2NrXCIpXG4gIH1cbiAgaWYocHJvYy5ib2R5LmFyZ3MubGVuZ3RoID4gcHJvY19hcmdzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImN3aXNlOiBUb28gbWFueSBhcmd1bWVudHMgaW4gYm9keSgpIGJsb2NrXCIpXG4gIH1cbiAgaWYocHJvYy5wb3N0LmFyZ3MubGVuZ3RoID4gcHJvY19hcmdzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImN3aXNlOiBUb28gbWFueSBhcmd1bWVudHMgaW4gcG9zdCgpIGJsb2NrXCIpXG4gIH1cblxuICAvL0NoZWNrIGRlYnVnIGZsYWdcbiAgcHJvYy5kZWJ1ZyA9ICEhdXNlcl9hcmdzLnByaW50Q29kZSB8fCAhIXVzZXJfYXJncy5kZWJ1Z1xuICBcbiAgLy9SZXRyaWV2ZSBuYW1lXG4gIHByb2MuZnVuY05hbWUgPSB1c2VyX2FyZ3MuZnVuY05hbWUgfHwgXCJjd2lzZVwiXG4gIFxuICAvL1JlYWQgaW4gYmxvY2sgc2l6ZVxuICBwcm9jLmJsb2NrU2l6ZSA9IHVzZXJfYXJncy5ibG9ja1NpemUgfHwgNjRcblxuICByZXR1cm4gY3JlYXRlVGh1bmsocHJvYylcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb21waWxlQ3dpc2VcbiIsIlwidXNlIHN0cmljdFwiXG5cbnZhciB1bmlxID0gcmVxdWlyZShcInVuaXFcIilcblxuZnVuY3Rpb24gaW5uZXJGaWxsKG9yZGVyLCBwcm9jLCBib2R5KSB7XG4gIHZhciBkaW1lbnNpb24gPSBvcmRlci5sZW5ndGhcbiAgICAsIG5hcmdzID0gcHJvYy5hcnJheUFyZ3MubGVuZ3RoXG4gICAgLCBoYXNfaW5kZXggPSBwcm9jLmluZGV4QXJncy5sZW5ndGg+MFxuICAgICwgY29kZSA9IFtdXG4gICAgLCB2YXJzID0gW11cbiAgICAsIGlkeD0wLCBwaWR4PTAsIGksIGpcbiAgZm9yKGk9MDsgaTxkaW1lbnNpb247ICsraSkge1xuICAgIHZhcnMucHVzaChbXCJpXCIsaSxcIj0wXCJdLmpvaW4oXCJcIikpXG4gIH1cbiAgLy9Db21wdXRlIHNjYW4gZGVsdGFzXG4gIGZvcihqPTA7IGo8bmFyZ3M7ICsraikge1xuICAgIGZvcihpPTA7IGk8ZGltZW5zaW9uOyArK2kpIHtcbiAgICAgIHBpZHggPSBpZHhcbiAgICAgIGlkeCA9IG9yZGVyW2ldXG4gICAgICBpZihpID09PSAwKSB7XG4gICAgICAgIHZhcnMucHVzaChbXCJkXCIsaixcInNcIixpLFwiPXRcIixqLFwicFwiLGlkeF0uam9pbihcIlwiKSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhcnMucHVzaChbXCJkXCIsaixcInNcIixpLFwiPSh0XCIsaixcInBcIixpZHgsXCItc1wiLHBpZHgsXCIqdFwiLGosXCJwXCIscGlkeCxcIilcIl0uam9pbihcIlwiKSlcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY29kZS5wdXNoKFwidmFyIFwiICsgdmFycy5qb2luKFwiLFwiKSlcbiAgLy9TY2FuIGxvb3BcbiAgZm9yKGk9ZGltZW5zaW9uLTE7IGk+PTA7IC0taSkge1xuICAgIGlkeCA9IG9yZGVyW2ldXG4gICAgY29kZS5wdXNoKFtcImZvcihpXCIsaSxcIj0wO2lcIixpLFwiPHNcIixpZHgsXCI7KytpXCIsaSxcIil7XCJdLmpvaW4oXCJcIikpXG4gIH1cbiAgLy9QdXNoIGJvZHkgb2YgaW5uZXIgbG9vcFxuICBjb2RlLnB1c2goYm9keSlcbiAgLy9BZHZhbmNlIHNjYW4gcG9pbnRlcnNcbiAgZm9yKGk9MDsgaTxkaW1lbnNpb247ICsraSkge1xuICAgIHBpZHggPSBpZHhcbiAgICBpZHggPSBvcmRlcltpXVxuICAgIGZvcihqPTA7IGo8bmFyZ3M7ICsraikge1xuICAgICAgY29kZS5wdXNoKFtcInBcIixqLFwiKz1kXCIsaixcInNcIixpXS5qb2luKFwiXCIpKVxuICAgIH1cbiAgICBpZihoYXNfaW5kZXgpIHtcbiAgICAgIGlmKGkgPiAwKSB7XG4gICAgICAgIGNvZGUucHVzaChbXCJpbmRleFtcIixwaWR4LFwiXS09c1wiLHBpZHhdLmpvaW4oXCJcIikpXG4gICAgICB9XG4gICAgICBjb2RlLnB1c2goW1wiKytpbmRleFtcIixpZHgsXCJdXCJdLmpvaW4oXCJcIikpXG4gICAgfVxuICAgIGNvZGUucHVzaChcIn1cIilcbiAgfVxuICByZXR1cm4gY29kZS5qb2luKFwiXFxuXCIpXG59XG5cbmZ1bmN0aW9uIG91dGVyRmlsbChtYXRjaGVkLCBvcmRlciwgcHJvYywgYm9keSkge1xuICB2YXIgZGltZW5zaW9uID0gb3JkZXIubGVuZ3RoXG4gICAgLCBuYXJncyA9IHByb2MuYXJyYXlBcmdzLmxlbmd0aFxuICAgICwgYmxvY2tTaXplID0gcHJvYy5ibG9ja1NpemVcbiAgICAsIGhhc19pbmRleCA9IHByb2MuaW5kZXhBcmdzLmxlbmd0aCA+IDBcbiAgICAsIGNvZGUgPSBbXVxuICBmb3IodmFyIGk9MDsgaTxuYXJnczsgKytpKSB7XG4gICAgY29kZS5wdXNoKFtcInZhciBvZmZzZXRcIixpLFwiPXBcIixpXS5qb2luKFwiXCIpKVxuICB9XG4gIC8vR2VuZXJhdGUgbWF0Y2hlZCBsb29wc1xuICBmb3IodmFyIGk9bWF0Y2hlZDsgaTxkaW1lbnNpb247ICsraSkge1xuICAgIGNvZGUucHVzaChbXCJmb3IodmFyIGpcIitpK1wiPVNTW1wiLCBvcmRlcltpXSwgXCJdfDA7alwiLCBpLCBcIj4wOyl7XCJdLmpvaW4oXCJcIikpXG4gICAgY29kZS5wdXNoKFtcImlmKGpcIixpLFwiPFwiLGJsb2NrU2l6ZSxcIil7XCJdLmpvaW4oXCJcIikpXG4gICAgY29kZS5wdXNoKFtcInNcIixvcmRlcltpXSxcIj1qXCIsaV0uam9pbihcIlwiKSlcbiAgICBjb2RlLnB1c2goW1wialwiLGksXCI9MFwiXS5qb2luKFwiXCIpKVxuICAgIGNvZGUucHVzaChbXCJ9ZWxzZXtzXCIsb3JkZXJbaV0sXCI9XCIsYmxvY2tTaXplXS5qb2luKFwiXCIpKVxuICAgIGNvZGUucHVzaChbXCJqXCIsaSxcIi09XCIsYmxvY2tTaXplLFwifVwiXS5qb2luKFwiXCIpKVxuICAgIGlmKGhhc19pbmRleCkge1xuICAgICAgY29kZS5wdXNoKFtcImluZGV4W1wiLG9yZGVyW2ldLFwiXT1qXCIsaV0uam9pbihcIlwiKSlcbiAgICB9XG4gIH1cbiAgZm9yKHZhciBpPTA7IGk8bmFyZ3M7ICsraSkge1xuICAgIHZhciBpbmRleFN0ciA9IFtcIm9mZnNldFwiK2ldXG4gICAgZm9yKHZhciBqPW1hdGNoZWQ7IGo8ZGltZW5zaW9uOyArK2opIHtcbiAgICAgIGluZGV4U3RyLnB1c2goW1wialwiLGosXCIqdFwiLGksXCJwXCIsb3JkZXJbal1dLmpvaW4oXCJcIikpXG4gICAgfVxuICAgIGNvZGUucHVzaChbXCJwXCIsaSxcIj0oXCIsaW5kZXhTdHIuam9pbihcIitcIiksXCIpXCJdLmpvaW4oXCJcIikpXG4gIH1cbiAgY29kZS5wdXNoKGlubmVyRmlsbChvcmRlciwgcHJvYywgYm9keSkpXG4gIGZvcih2YXIgaT1tYXRjaGVkOyBpPGRpbWVuc2lvbjsgKytpKSB7XG4gICAgY29kZS5wdXNoKFwifVwiKVxuICB9XG4gIHJldHVybiBjb2RlLmpvaW4oXCJcXG5cIilcbn1cblxuLy9Db3VudCB0aGUgbnVtYmVyIG9mIGNvbXBhdGlibGUgaW5uZXIgb3JkZXJzXG5mdW5jdGlvbiBjb3VudE1hdGNoZXMob3JkZXJzKSB7XG4gIHZhciBtYXRjaGVkID0gMCwgZGltZW5zaW9uID0gb3JkZXJzWzBdLmxlbmd0aFxuICB3aGlsZShtYXRjaGVkIDwgZGltZW5zaW9uKSB7XG4gICAgZm9yKHZhciBqPTE7IGo8b3JkZXJzLmxlbmd0aDsgKytqKSB7XG4gICAgICBpZihvcmRlcnNbal1bbWF0Y2hlZF0gIT09IG9yZGVyc1swXVttYXRjaGVkXSkge1xuICAgICAgICByZXR1cm4gbWF0Y2hlZFxuICAgICAgfVxuICAgIH1cbiAgICArK21hdGNoZWRcbiAgfVxuICByZXR1cm4gbWF0Y2hlZFxufVxuXG4vL1Byb2Nlc3NlcyBhIGJsb2NrIGFjY29yZGluZyB0byB0aGUgZ2l2ZW4gZGF0YSB0eXBlc1xuZnVuY3Rpb24gcHJvY2Vzc0Jsb2NrKGJsb2NrLCBwcm9jLCBkdHlwZXMpIHtcbiAgdmFyIGNvZGUgPSBibG9jay5ib2R5XG4gIHZhciBwcmUgPSBbXVxuICB2YXIgcG9zdCA9IFtdXG4gIGZvcih2YXIgaT0wOyBpPGJsb2NrLmFyZ3MubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgY2FyZyA9IGJsb2NrLmFyZ3NbaV1cbiAgICBpZihjYXJnLmNvdW50IDw9IDApIHtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIHZhciByZSA9IG5ldyBSZWdFeHAoY2FyZy5uYW1lLCBcImdcIilcbiAgICB2YXIgcHRyU3RyID0gXCJcIlxuICAgIHZhciBhcnJOdW0gPSBwcm9jLmFycmF5QXJncy5pbmRleE9mKGkpXG4gICAgc3dpdGNoKHByb2MuYXJnVHlwZXNbaV0pIHtcbiAgICAgIGNhc2UgXCJvZmZzZXRcIjpcbiAgICAgICAgdmFyIG9mZkFyZ0luZGV4ID0gcHJvYy5vZmZzZXRBcmdJbmRleC5pbmRleE9mKGkpXG4gICAgICAgIHZhciBvZmZBcmcgPSBwcm9jLm9mZnNldEFyZ3Nbb2ZmQXJnSW5kZXhdXG4gICAgICAgIGFyck51bSA9IG9mZkFyZy5hcnJheVxuICAgICAgICBwdHJTdHIgPSBcIitxXCIgKyBvZmZBcmdJbmRleFxuICAgICAgY2FzZSBcImFycmF5XCI6XG4gICAgICAgIHB0clN0ciA9IFwicFwiICsgYXJyTnVtICsgcHRyU3RyXG4gICAgICAgIHZhciBsb2NhbFN0ciA9IFwibFwiICsgaVxuICAgICAgICB2YXIgYXJyU3RyID0gXCJhXCIgKyBhcnJOdW1cbiAgICAgICAgaWYoY2FyZy5jb3VudCA9PT0gMSkge1xuICAgICAgICAgIGlmKGR0eXBlc1thcnJOdW1dID09PSBcImdlbmVyaWNcIikge1xuICAgICAgICAgICAgaWYoY2FyZy5sdmFsdWUpIHtcbiAgICAgICAgICAgICAgcHJlLnB1c2goW1widmFyIFwiLCBsb2NhbFN0ciwgXCI9XCIsIGFyclN0ciwgXCIuZ2V0KFwiLCBwdHJTdHIsIFwiKVwiXS5qb2luKFwiXCIpKVxuICAgICAgICAgICAgICBjb2RlID0gY29kZS5yZXBsYWNlKHJlLCBsb2NhbFN0cilcbiAgICAgICAgICAgICAgcG9zdC5wdXNoKFthcnJTdHIsIFwiLnNldChcIiwgcHRyU3RyLCBcIixcIiwgbG9jYWxTdHIsXCIpXCJdLmpvaW4oXCJcIikpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb2RlID0gY29kZS5yZXBsYWNlKHJlLCBbYXJyU3RyLCBcIi5nZXQoXCIsIHB0clN0ciwgXCIpXCJdLmpvaW4oXCJcIikpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvZGUgPSBjb2RlLnJlcGxhY2UocmUsIFthcnJTdHIsIFwiW1wiLCBwdHJTdHIsIFwiXVwiXS5qb2luKFwiXCIpKVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmKGR0eXBlc1thcnJOdW1dID09PSBcImdlbmVyaWNcIikge1xuICAgICAgICAgIHByZS5wdXNoKFtcInZhciBcIiwgbG9jYWxTdHIsIFwiPVwiLCBhcnJTdHIsIFwiLmdldChcIiwgcHRyU3RyLCBcIilcIl0uam9pbihcIlwiKSlcbiAgICAgICAgICBjb2RlID0gY29kZS5yZXBsYWNlKHJlLCBsb2NhbFN0cilcbiAgICAgICAgICBpZihjYXJnLmx2YWx1ZSkge1xuICAgICAgICAgICAgcG9zdC5wdXNoKFthcnJTdHIsIFwiLnNldChcIiwgcHRyU3RyLCBcIixcIiwgbG9jYWxTdHIsXCIpXCJdLmpvaW4oXCJcIikpXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByZS5wdXNoKFtcInZhciBcIiwgbG9jYWxTdHIsIFwiPVwiLCBhcnJTdHIsIFwiW1wiLCBwdHJTdHIsIFwiXVwiXS5qb2luKFwiXCIpKVxuICAgICAgICAgIGNvZGUgPSBjb2RlLnJlcGxhY2UocmUsIGxvY2FsU3RyKVxuICAgICAgICAgIGlmKGNhcmcubHZhbHVlKSB7XG4gICAgICAgICAgICBwb3N0LnB1c2goW2FyclN0ciwgXCJbXCIsIHB0clN0ciwgXCJdPVwiLCBsb2NhbFN0cl0uam9pbihcIlwiKSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIGJyZWFrXG4gICAgICBjYXNlIFwic2NhbGFyXCI6XG4gICAgICAgIGNvZGUgPSBjb2RlLnJlcGxhY2UocmUsIFwiWVwiICsgcHJvYy5zY2FsYXJBcmdzLmluZGV4T2YoaSkpXG4gICAgICBicmVha1xuICAgICAgY2FzZSBcImluZGV4XCI6XG4gICAgICAgIGNvZGUgPSBjb2RlLnJlcGxhY2UocmUsIFwiaW5kZXhcIilcbiAgICAgIGJyZWFrXG4gICAgICBjYXNlIFwic2hhcGVcIjpcbiAgICAgICAgY29kZSA9IGNvZGUucmVwbGFjZShyZSwgXCJzaGFwZVwiKVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFtwcmUuam9pbihcIlxcblwiKSwgY29kZSwgcG9zdC5qb2luKFwiXFxuXCIpXS5qb2luKFwiXFxuXCIpLnRyaW0oKVxufVxuXG5mdW5jdGlvbiB0eXBlU3VtbWFyeShkdHlwZXMpIHtcbiAgdmFyIHN1bW1hcnkgPSBuZXcgQXJyYXkoZHR5cGVzLmxlbmd0aClcbiAgdmFyIGFsbEVxdWFsID0gdHJ1ZVxuICBmb3IodmFyIGk9MDsgaTxkdHlwZXMubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgdCA9IGR0eXBlc1tpXVxuICAgIHZhciBkaWdpdHMgPSB0Lm1hdGNoKC9cXGQrLylcbiAgICBpZighZGlnaXRzKSB7XG4gICAgICBkaWdpdHMgPSBcIlwiXG4gICAgfSBlbHNlIHtcbiAgICAgIGRpZ2l0cyA9IGRpZ2l0c1swXVxuICAgIH1cbiAgICBpZih0LmNoYXJBdCgwKSA9PT0gMCkge1xuICAgICAgc3VtbWFyeVtpXSA9IFwidVwiICsgdC5jaGFyQXQoMSkgKyBkaWdpdHNcbiAgICB9IGVsc2Uge1xuICAgICAgc3VtbWFyeVtpXSA9IHQuY2hhckF0KDApICsgZGlnaXRzXG4gICAgfVxuICAgIGlmKGkgPiAwKSB7XG4gICAgICBhbGxFcXVhbCA9IGFsbEVxdWFsICYmIHN1bW1hcnlbaV0gPT09IHN1bW1hcnlbaS0xXVxuICAgIH1cbiAgfVxuICBpZihhbGxFcXVhbCkge1xuICAgIHJldHVybiBzdW1tYXJ5WzBdXG4gIH1cbiAgcmV0dXJuIHN1bW1hcnkuam9pbihcIlwiKVxufVxuXG4vL0dlbmVyYXRlcyBhIGN3aXNlIG9wZXJhdG9yXG5mdW5jdGlvbiBnZW5lcmF0ZUNXaXNlT3AocHJvYywgdHlwZXNpZykge1xuXG4gIC8vQ29tcHV0ZSBkaW1lbnNpb25cbiAgdmFyIGRpbWVuc2lvbiA9IHR5cGVzaWdbMV0ubGVuZ3RofDBcbiAgdmFyIG9yZGVycyA9IG5ldyBBcnJheShwcm9jLmFycmF5QXJncy5sZW5ndGgpXG4gIHZhciBkdHlwZXMgPSBuZXcgQXJyYXkocHJvYy5hcnJheUFyZ3MubGVuZ3RoKVxuXG4gIC8vRmlyc3QgY3JlYXRlIGFyZ3VtZW50cyBmb3IgcHJvY2VkdXJlXG4gIHZhciBhcmdsaXN0ID0gW1wiU1NcIl1cbiAgdmFyIGNvZGUgPSBbXCIndXNlIHN0cmljdCdcIl1cbiAgdmFyIHZhcnMgPSBbXVxuICBcbiAgZm9yKHZhciBqPTA7IGo8ZGltZW5zaW9uOyArK2opIHtcbiAgICB2YXJzLnB1c2goW1wic1wiLCBqLCBcIj1TU1tcIiwgaiwgXCJdXCJdLmpvaW4oXCJcIikpXG4gIH1cbiAgZm9yKHZhciBpPTA7IGk8cHJvYy5hcnJheUFyZ3MubGVuZ3RoOyArK2kpIHtcbiAgICBhcmdsaXN0LnB1c2goXCJhXCIraSlcbiAgICBhcmdsaXN0LnB1c2goXCJ0XCIraSlcbiAgICBhcmdsaXN0LnB1c2goXCJwXCIraSlcbiAgICBkdHlwZXNbaV0gPSB0eXBlc2lnWzIqaV1cbiAgICBvcmRlcnNbaV0gPSB0eXBlc2lnWzIqaSsxXVxuICAgIFxuICAgIGZvcih2YXIgaj0wOyBqPGRpbWVuc2lvbjsgKytqKSB7XG4gICAgICB2YXJzLnB1c2goW1widFwiLGksXCJwXCIsaixcIj10XCIsaSxcIltcIixqLFwiXVwiXS5qb2luKFwiXCIpKVxuICAgIH1cbiAgfVxuICBmb3IodmFyIGk9MDsgaTxwcm9jLnNjYWxhckFyZ3MubGVuZ3RoOyArK2kpIHtcbiAgICBhcmdsaXN0LnB1c2goXCJZXCIgKyBpKVxuICB9XG4gIGlmKHByb2Muc2hhcGVBcmdzLmxlbmd0aCA+IDApIHtcbiAgICB2YXJzLnB1c2goXCJzaGFwZT1TUy5zbGljZSgwKVwiKVxuICB9XG4gIGlmKHByb2MuaW5kZXhBcmdzLmxlbmd0aCA+IDApIHtcbiAgICB2YXIgemVyb3MgPSBuZXcgQXJyYXkoZGltZW5zaW9uKVxuICAgIGZvcih2YXIgaT0wOyBpPGRpbWVuc2lvbjsgKytpKSB7XG4gICAgICB6ZXJvc1tpXSA9IFwiMFwiXG4gICAgfVxuICAgIHZhcnMucHVzaChbXCJpbmRleD1bXCIsIHplcm9zLmpvaW4oXCIsXCIpLCBcIl1cIl0uam9pbihcIlwiKSlcbiAgfVxuICBmb3IodmFyIGk9MDsgaTxwcm9jLm9mZnNldEFyZ3MubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgb2ZmX2FyZyA9IHByb2Mub2Zmc2V0QXJnc1tpXVxuICAgIHZhciBpbml0X3N0cmluZyA9IFtdXG4gICAgZm9yKHZhciBqPTA7IGo8b2ZmX2FyZy5vZmZzZXQubGVuZ3RoOyArK2opIHtcbiAgICAgIGlmKG9mZl9hcmcub2Zmc2V0W2pdID09PSAwKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9IGVsc2UgaWYob2ZmX2FyZy5vZmZzZXRbal0gPT09IDEpIHtcbiAgICAgICAgaW5pdF9zdHJpbmcucHVzaChbXCJ0XCIsIG9mZl9hcmcuYXJyYXksIFwicFwiLCBqXS5qb2luKFwiXCIpKSAgICAgIFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5pdF9zdHJpbmcucHVzaChbb2ZmX2FyZy5vZmZzZXRbal0sIFwiKnRcIiwgb2ZmX2FyZy5hcnJheSwgXCJwXCIsIGpdLmpvaW4oXCJcIikpXG4gICAgICB9XG4gICAgfVxuICAgIGlmKGluaXRfc3RyaW5nLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdmFycy5wdXNoKFwicVwiICsgaSArIFwiPTBcIilcbiAgICB9IGVsc2Uge1xuICAgICAgdmFycy5wdXNoKFtcInFcIiwgaSwgXCI9XCIsIGluaXRfc3RyaW5nLmpvaW4oXCIrXCIpXS5qb2luKFwiXCIpKVxuICAgIH1cbiAgfVxuXG4gIC8vUHJlcGFyZSB0aGlzIHZhcmlhYmxlc1xuICB2YXIgdGhpc1ZhcnMgPSB1bmlxKFtdLmNvbmNhdChwcm9jLnByZS50aGlzVmFycylcbiAgICAgICAgICAgICAgICAgICAgICAuY29uY2F0KHByb2MuYm9keS50aGlzVmFycylcbiAgICAgICAgICAgICAgICAgICAgICAuY29uY2F0KHByb2MucG9zdC50aGlzVmFycykpXG4gIHZhcnMgPSB2YXJzLmNvbmNhdCh0aGlzVmFycylcbiAgY29kZS5wdXNoKFwidmFyIFwiICsgdmFycy5qb2luKFwiLFwiKSlcbiAgZm9yKHZhciBpPTA7IGk8cHJvYy5hcnJheUFyZ3MubGVuZ3RoOyArK2kpIHtcbiAgICBjb2RlLnB1c2goXCJwXCIraStcInw9MFwiKVxuICB9XG4gIFxuICAvL0lubGluZSBwcmVsdWRlXG4gIGlmKHByb2MucHJlLmJvZHkubGVuZ3RoID4gMykge1xuICAgIGNvZGUucHVzaChwcm9jZXNzQmxvY2socHJvYy5wcmUsIHByb2MsIGR0eXBlcykpXG4gIH1cblxuICAvL1Byb2Nlc3MgYm9keVxuICB2YXIgYm9keSA9IHByb2Nlc3NCbG9jayhwcm9jLmJvZHksIHByb2MsIGR0eXBlcylcbiAgdmFyIG1hdGNoZWQgPSBjb3VudE1hdGNoZXMob3JkZXJzKVxuICBpZihtYXRjaGVkIDwgZGltZW5zaW9uKSB7XG4gICAgY29kZS5wdXNoKG91dGVyRmlsbChtYXRjaGVkLCBvcmRlcnNbMF0sIHByb2MsIGJvZHkpKVxuICB9IGVsc2Uge1xuICAgIGNvZGUucHVzaChpbm5lckZpbGwob3JkZXJzWzBdLCBwcm9jLCBib2R5KSlcbiAgfVxuXG4gIC8vSW5saW5lIGVwaWxvZ1xuICBpZihwcm9jLnBvc3QuYm9keS5sZW5ndGggPiAzKSB7XG4gICAgY29kZS5wdXNoKHByb2Nlc3NCbG9jayhwcm9jLnBvc3QsIHByb2MsIGR0eXBlcykpXG4gIH1cbiAgXG4gIGlmKHByb2MuZGVidWcpIHtcbiAgICBjb25zb2xlLmxvZyhcIkdlbmVyYXRlZCBjd2lzZSByb3V0aW5lIGZvciBcIiwgdHlwZXNpZywgXCI6XFxuXFxuXCIsIGNvZGUuam9pbihcIlxcblwiKSlcbiAgfVxuICBcbiAgdmFyIGxvb3BOYW1lID0gWyhwcm9jLmZ1bmNOYW1lfHxcInVubmFtZWRcIiksIFwiX2N3aXNlX2xvb3BfXCIsIG9yZGVyc1swXS5qb2luKFwic1wiKSxcIm1cIixtYXRjaGVkLHR5cGVTdW1tYXJ5KGR0eXBlcyldLmpvaW4oXCJcIilcbiAgdmFyIGYgPSBuZXcgRnVuY3Rpb24oW1wiZnVuY3Rpb24gXCIsbG9vcE5hbWUsXCIoXCIsIGFyZ2xpc3Quam9pbihcIixcIiksXCIpe1wiLCBjb2RlLmpvaW4oXCJcXG5cIiksXCJ9IHJldHVybiBcIiwgbG9vcE5hbWVdLmpvaW4oXCJcIikpXG4gIHJldHVybiBmKClcbn1cbm1vZHVsZS5leHBvcnRzID0gZ2VuZXJhdGVDV2lzZU9wIiwiXCJ1c2Ugc3RyaWN0XCJcblxudmFyIGNvbXBpbGUgPSByZXF1aXJlKFwiLi9jb21waWxlLmpzXCIpXG5cbmZ1bmN0aW9uIGNyZWF0ZVRodW5rKHByb2MpIHtcbiAgdmFyIGNvZGUgPSBbXCIndXNlIHN0cmljdCdcIiwgXCJ2YXIgQ0FDSEVEPXt9XCJdXG4gIHZhciB2YXJzID0gW11cbiAgdmFyIHRodW5rTmFtZSA9IHByb2MuZnVuY05hbWUgKyBcIl9jd2lzZV90aHVua1wiXG4gIFxuICAvL0J1aWxkIHRodW5rXG4gIGNvZGUucHVzaChbXCJyZXR1cm4gZnVuY3Rpb24gXCIsIHRodW5rTmFtZSwgXCIoXCIsIHByb2Muc2hpbUFyZ3Muam9pbihcIixcIiksIFwiKXtcIl0uam9pbihcIlwiKSlcbiAgdmFyIHR5cGVzaWcgPSBbXVxuICB2YXIgc3RyaW5nX3R5cGVzaWcgPSBbXVxuICB2YXIgcHJvY19hcmdzID0gW1tcImFycmF5XCIscHJvYy5hcnJheUFyZ3NbMF0sXCIuc2hhcGVcIl0uam9pbihcIlwiKV1cbiAgZm9yKHZhciBpPTA7IGk8cHJvYy5hcnJheUFyZ3MubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgaiA9IHByb2MuYXJyYXlBcmdzW2ldXG4gICAgdmFycy5wdXNoKFtcInRcIiwgaiwgXCI9YXJyYXlcIiwgaiwgXCIuZHR5cGUsXCIsXG4gICAgICAgICAgICAgICBcInJcIiwgaiwgXCI9YXJyYXlcIiwgaiwgXCIub3JkZXJcIl0uam9pbihcIlwiKSlcbiAgICB0eXBlc2lnLnB1c2goXCJ0XCIgKyBqKVxuICAgIHR5cGVzaWcucHVzaChcInJcIiArIGopXG4gICAgc3RyaW5nX3R5cGVzaWcucHVzaChcInRcIitqKVxuICAgIHN0cmluZ190eXBlc2lnLnB1c2goXCJyXCIraitcIi5qb2luKClcIilcbiAgICBwcm9jX2FyZ3MucHVzaChcImFycmF5XCIgKyBqICsgXCIuZGF0YVwiKVxuICAgIHByb2NfYXJncy5wdXNoKFwiYXJyYXlcIiArIGogKyBcIi5zdHJpZGVcIilcbiAgICBwcm9jX2FyZ3MucHVzaChcImFycmF5XCIgKyBqICsgXCIub2Zmc2V0fDBcIilcbiAgfVxuICBmb3IodmFyIGk9MDsgaTxwcm9jLnNjYWxhckFyZ3MubGVuZ3RoOyArK2kpIHtcbiAgICBwcm9jX2FyZ3MucHVzaChcInNjYWxhclwiICsgcHJvYy5zY2FsYXJBcmdzW2ldKVxuICB9XG4gIHZhcnMucHVzaChbXCJ0eXBlPVtcIiwgc3RyaW5nX3R5cGVzaWcuam9pbihcIixcIiksIFwiXS5qb2luKClcIl0uam9pbihcIlwiKSlcbiAgdmFycy5wdXNoKFwicHJvYz1DQUNIRURbdHlwZV1cIilcbiAgY29kZS5wdXNoKFwidmFyIFwiICsgdmFycy5qb2luKFwiLFwiKSlcbiAgXG4gIGNvZGUucHVzaChbXCJpZighcHJvYyl7XCIsXG4gICAgICAgICAgICAgXCJDQUNIRURbdHlwZV09cHJvYz1jb21waWxlKFtcIiwgdHlwZXNpZy5qb2luKFwiLFwiKSwgXCJdKX1cIixcbiAgICAgICAgICAgICBcInJldHVybiBwcm9jKFwiLCBwcm9jX2FyZ3Muam9pbihcIixcIiksIFwiKX1cIl0uam9pbihcIlwiKSlcblxuICBpZihwcm9jLmRlYnVnKSB7XG4gICAgY29uc29sZS5sb2coXCJHZW5lcmF0ZWQgdGh1bms6XCIsIGNvZGUuam9pbihcIlxcblwiKSlcbiAgfVxuICBcbiAgLy9Db21waWxlIHRodW5rXG4gIHZhciB0aHVuayA9IG5ldyBGdW5jdGlvbihcImNvbXBpbGVcIiwgY29kZS5qb2luKFwiXFxuXCIpKVxuICByZXR1cm4gdGh1bmsoY29tcGlsZS5iaW5kKHVuZGVmaW5lZCwgcHJvYykpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlVGh1bmtcbiIsIlwidXNlIHN0cmljdFwiXG5cbmZ1bmN0aW9uIHVuaXF1ZV9wcmVkKGxpc3QsIGNvbXBhcmUpIHtcbiAgdmFyIHB0ciA9IDFcbiAgICAsIGxlbiA9IGxpc3QubGVuZ3RoXG4gICAgLCBhPWxpc3RbMF0sIGI9bGlzdFswXVxuICBmb3IodmFyIGk9MTsgaTxsZW47ICsraSkge1xuICAgIGIgPSBhXG4gICAgYSA9IGxpc3RbaV1cbiAgICBpZihjb21wYXJlKGEsIGIpKSB7XG4gICAgICBpZihpID09PSBwdHIpIHtcbiAgICAgICAgcHRyKytcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cbiAgICAgIGxpc3RbcHRyKytdID0gYVxuICAgIH1cbiAgfVxuICBsaXN0Lmxlbmd0aCA9IHB0clxuICByZXR1cm4gbGlzdFxufVxuXG5mdW5jdGlvbiB1bmlxdWVfZXEobGlzdCkge1xuICB2YXIgcHRyID0gMVxuICAgICwgbGVuID0gbGlzdC5sZW5ndGhcbiAgICAsIGE9bGlzdFswXSwgYiA9IGxpc3RbMF1cbiAgZm9yKHZhciBpPTE7IGk8bGVuOyArK2ksIGI9YSkge1xuICAgIGIgPSBhXG4gICAgYSA9IGxpc3RbaV1cbiAgICBpZihhICE9PSBiKSB7XG4gICAgICBpZihpID09PSBwdHIpIHtcbiAgICAgICAgcHRyKytcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cbiAgICAgIGxpc3RbcHRyKytdID0gYVxuICAgIH1cbiAgfVxuICBsaXN0Lmxlbmd0aCA9IHB0clxuICByZXR1cm4gbGlzdFxufVxuXG5mdW5jdGlvbiB1bmlxdWUobGlzdCwgY29tcGFyZSwgc29ydGVkKSB7XG4gIGlmKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGxpc3RcbiAgfVxuICBpZihjb21wYXJlKSB7XG4gICAgaWYoIXNvcnRlZCkge1xuICAgICAgbGlzdC5zb3J0KGNvbXBhcmUpXG4gICAgfVxuICAgIHJldHVybiB1bmlxdWVfcHJlZChsaXN0LCBjb21wYXJlKVxuICB9XG4gIGlmKCFzb3J0ZWQpIHtcbiAgICBsaXN0LnNvcnQoKVxuICB9XG4gIHJldHVybiB1bmlxdWVfZXEobGlzdClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB1bmlxdWVcbiIsIihmdW5jdGlvbiAoQnVmZmVyKXtcbnZhciBpb3RhID0gcmVxdWlyZShcImlvdGEtYXJyYXlcIilcblxudmFyIGFycmF5TWV0aG9kcyA9IFtcbiAgXCJjb25jYXRcIixcbiAgXCJqb2luXCIsXG4gIFwic2xpY2VcIixcbiAgXCJ0b1N0cmluZ1wiLFxuICBcImluZGV4T2ZcIixcbiAgXCJsYXN0SW5kZXhPZlwiLFxuICBcImZvckVhY2hcIixcbiAgXCJldmVyeVwiLFxuICBcInNvbWVcIixcbiAgXCJmaWx0ZXJcIixcbiAgXCJtYXBcIixcbiAgXCJyZWR1Y2VcIixcbiAgXCJyZWR1Y2VSaWdodFwiXG5dXG5cbnZhciBoYXNUeXBlZEFycmF5cyAgPSAoKHR5cGVvZiBGbG9hdDY0QXJyYXkpICE9PSBcInVuZGVmaW5lZFwiKVxudmFyIGhhc0J1ZmZlciAgICAgICA9ICgodHlwZW9mIEJ1ZmZlcikgIT09IFwidW5kZWZpbmVkXCIpXG5cbmZ1bmN0aW9uIGNvbXBhcmUxc3QoYSwgYikge1xuICByZXR1cm4gYVswXSAtIGJbMF1cbn1cblxuZnVuY3Rpb24gb3JkZXIoKSB7XG4gIHZhciBzdHJpZGUgPSB0aGlzLnN0cmlkZVxuICB2YXIgdGVybXMgPSBuZXcgQXJyYXkoc3RyaWRlLmxlbmd0aClcbiAgdmFyIGlcbiAgZm9yKGk9MDsgaTx0ZXJtcy5sZW5ndGg7ICsraSkge1xuICAgIHRlcm1zW2ldID0gW01hdGguYWJzKHN0cmlkZVtpXSksIGldXG4gIH1cbiAgdGVybXMuc29ydChjb21wYXJlMXN0KVxuICB2YXIgcmVzdWx0ID0gbmV3IEFycmF5KHRlcm1zLmxlbmd0aClcbiAgZm9yKGk9MDsgaTxyZXN1bHQubGVuZ3RoOyArK2kpIHtcbiAgICByZXN1bHRbaV0gPSB0ZXJtc1tpXVsxXVxuICB9XG4gIHJldHVybiByZXN1bHRcbn1cblxuZnVuY3Rpb24gY29tcGlsZUNvbnN0cnVjdG9yKGR0eXBlLCBkaW1lbnNpb24pIHtcbiAgdmFyIGNsYXNzTmFtZSA9IFtcIlZpZXdcIiwgZGltZW5zaW9uLCBcImRcIiwgZHR5cGVdLmpvaW4oXCJcIilcbiAgaWYoZGltZW5zaW9uIDwgMCkge1xuICAgIGNsYXNzTmFtZSA9IFwiVmlld19OaWxcIiArIGR0eXBlXG4gIH1cbiAgdmFyIHVzZUdldHRlcnMgPSAoZHR5cGUgPT09IFwiZ2VuZXJpY1wiKVxuICBcbiAgaWYoZGltZW5zaW9uID09PSAtMSkge1xuICAgIC8vU3BlY2lhbCBjYXNlIGZvciB0cml2aWFsIGFycmF5c1xuICAgIHZhciBjb2RlID0gXG4gICAgICBcImZ1bmN0aW9uIFwiK2NsYXNzTmFtZStcIihhKXt0aGlzLmRhdGE9YTt9O1xcXG52YXIgcHJvdG89XCIrY2xhc3NOYW1lK1wiLnByb3RvdHlwZTtcXFxucHJvdG8uZHR5cGU9J1wiK2R0eXBlK1wiJztcXFxucHJvdG8uaW5kZXg9ZnVuY3Rpb24oKXtyZXR1cm4gLTF9O1xcXG5wcm90by5zaXplPTA7XFxcbnByb3RvLmRpbWVuc2lvbj0tMTtcXFxucHJvdG8uc2hhcGU9cHJvdG8uc3RyaWRlPXByb3RvLm9yZGVyPVtdO1xcXG5wcm90by5sbz1wcm90by5oaT1wcm90by50cmFuc3Bvc2U9cHJvdG8uc3RlcD1cXFxuZnVuY3Rpb24oKXtyZXR1cm4gbmV3IFwiK2NsYXNzTmFtZStcIih0aGlzLmRhdGEpO307XFxcbnByb3RvLmdldD1wcm90by5zZXQ9ZnVuY3Rpb24oKXt9O1xcXG5wcm90by5waWNrPWZ1bmN0aW9uKCl7cmV0dXJuIG51bGx9O1xcXG5yZXR1cm4gZnVuY3Rpb24gY29uc3RydWN0X1wiK2NsYXNzTmFtZStcIihhKXtyZXR1cm4gbmV3IFwiK2NsYXNzTmFtZStcIihhKTt9XCJcbiAgICB2YXIgcHJvY2VkdXJlID0gbmV3IEZ1bmN0aW9uKGNvZGUpXG4gICAgcmV0dXJuIHByb2NlZHVyZSgpXG4gIH0gZWxzZSBpZihkaW1lbnNpb24gPT09IDApIHtcbiAgICAvL1NwZWNpYWwgY2FzZSBmb3IgMGQgYXJyYXlzXG4gICAgdmFyIGNvZGUgPVxuICAgICAgXCJmdW5jdGlvbiBcIitjbGFzc05hbWUrXCIoYSxkKSB7XFxcbnRoaXMuZGF0YSA9IGE7XFxcbnRoaXMub2Zmc2V0ID0gZFxcXG59O1xcXG52YXIgcHJvdG89XCIrY2xhc3NOYW1lK1wiLnByb3RvdHlwZTtcXFxucHJvdG8uZHR5cGU9J1wiK2R0eXBlK1wiJztcXFxucHJvdG8uaW5kZXg9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5vZmZzZXR9O1xcXG5wcm90by5kaW1lbnNpb249MDtcXFxucHJvdG8uc2l6ZT0xO1xcXG5wcm90by5zaGFwZT1cXFxucHJvdG8uc3RyaWRlPVxcXG5wcm90by5vcmRlcj1bXTtcXFxucHJvdG8ubG89XFxcbnByb3RvLmhpPVxcXG5wcm90by50cmFuc3Bvc2U9XFxcbnByb3RvLnN0ZXA9ZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiX2NvcHkoKSB7XFxcbnJldHVybiBuZXcgXCIrY2xhc3NOYW1lK1wiKHRoaXMuZGF0YSx0aGlzLm9mZnNldClcXFxufTtcXFxucHJvdG8ucGljaz1mdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfcGljaygpe1xcXG5yZXR1cm4gVHJpdmlhbEFycmF5KHRoaXMuZGF0YSk7XFxcbn07XFxcbnByb3RvLnZhbHVlT2Y9cHJvdG8uZ2V0PWZ1bmN0aW9uIFwiK2NsYXNzTmFtZStcIl9nZXQoKXtcXFxucmV0dXJuIFwiKyh1c2VHZXR0ZXJzID8gXCJ0aGlzLmRhdGEuZ2V0KHRoaXMub2Zmc2V0KVwiIDogXCJ0aGlzLmRhdGFbdGhpcy5vZmZzZXRdXCIpK1xuXCJ9O1xcXG5wcm90by5zZXQ9ZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiX3NldCh2KXtcXFxucmV0dXJuIFwiKyh1c2VHZXR0ZXJzID8gXCJ0aGlzLmRhdGEuc2V0KHRoaXMub2Zmc2V0LHYpXCIgOiBcInRoaXMuZGF0YVt0aGlzLm9mZnNldF09dlwiKStcIlxcXG59O1xcXG5yZXR1cm4gZnVuY3Rpb24gY29uc3RydWN0X1wiK2NsYXNzTmFtZStcIihhLGIsYyxkKXtyZXR1cm4gbmV3IFwiK2NsYXNzTmFtZStcIihhLGQpfVwiXG4gICAgdmFyIHByb2NlZHVyZSA9IG5ldyBGdW5jdGlvbihcIlRyaXZpYWxBcnJheVwiLCBjb2RlKVxuICAgIHJldHVybiBwcm9jZWR1cmUoQ0FDSEVEX0NPTlNUUlVDVE9SU1tkdHlwZV1bMF0pXG4gIH1cblxuICB2YXIgY29kZSA9IFtcIid1c2Ugc3RyaWN0J1wiXVxuICAgIFxuICAvL0NyZWF0ZSBjb25zdHJ1Y3RvciBmb3Igdmlld1xuICB2YXIgaW5kaWNlcyA9IGlvdGEoZGltZW5zaW9uKVxuICB2YXIgYXJncyA9IGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHsgcmV0dXJuIFwiaVwiK2kgfSlcbiAgdmFyIGluZGV4X3N0ciA9IFwidGhpcy5vZmZzZXQrXCIgKyBpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7XG4gICAgICAgIHJldHVybiBcInRoaXMuX3N0cmlkZVwiICsgaSArIFwiKmlcIiArIGlcbiAgICAgIH0pLmpvaW4oXCIrXCIpXG4gIGNvZGUucHVzaChcImZ1bmN0aW9uIFwiK2NsYXNzTmFtZStcIihhLFwiK1xuICAgIGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBcImJcIitpXG4gICAgfSkuam9pbihcIixcIikgKyBcIixcIiArXG4gICAgaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIFwiY1wiK2lcbiAgICB9KS5qb2luKFwiLFwiKSArIFwiLGQpe3RoaXMuZGF0YT1hXCIpXG4gIGZvcih2YXIgaT0wOyBpPGRpbWVuc2lvbjsgKytpKSB7XG4gICAgY29kZS5wdXNoKFwidGhpcy5fc2hhcGVcIitpK1wiPWJcIitpK1wifDBcIilcbiAgfVxuICBmb3IodmFyIGk9MDsgaTxkaW1lbnNpb247ICsraSkge1xuICAgIGNvZGUucHVzaChcInRoaXMuX3N0cmlkZVwiK2krXCI9Y1wiK2krXCJ8MFwiKVxuICB9XG4gIGNvZGUucHVzaChcInRoaXMub2Zmc2V0PWR8MH1cIixcbiAgICBcInZhciBwcm90bz1cIitjbGFzc05hbWUrXCIucHJvdG90eXBlXCIsXG4gICAgXCJwcm90by5kdHlwZT0nXCIrZHR5cGUrXCInXCIsXG4gICAgXCJwcm90by5kaW1lbnNpb249XCIrZGltZW5zaW9uKVxuICBcbiAgLy92aWV3LnN0cmlkZSBhbmQgdmlldy5zaGFwZVxuICB2YXIgc3RyaWRlQ2xhc3NOYW1lID0gXCJWU3RyaWRlXCIgKyBkaW1lbnNpb24gKyBcImRcIiArIGR0eXBlXG4gIHZhciBzaGFwZUNsYXNzTmFtZSA9IFwiVlNoYXBlXCIgKyBkaW1lbnNpb24gKyBcImRcIiArIGR0eXBlXG4gIHZhciBwcm9wcyA9IHtcInN0cmlkZVwiOnN0cmlkZUNsYXNzTmFtZSwgXCJzaGFwZVwiOnNoYXBlQ2xhc3NOYW1lfVxuICBmb3IodmFyIHByb3AgaW4gcHJvcHMpIHtcbiAgICB2YXIgYXJyYXlOYW1lID0gcHJvcHNbcHJvcF1cbiAgICBjb2RlLnB1c2goXG4gICAgICBcImZ1bmN0aW9uIFwiICsgYXJyYXlOYW1lICsgXCIodikge3RoaXMuX3Y9dn0gdmFyIGFwcm90bz1cIiArIGFycmF5TmFtZSArIFwiLnByb3RvdHlwZVwiLFxuICAgICAgXCJhcHJvdG8ubGVuZ3RoPVwiK2RpbWVuc2lvbilcbiAgICBcbiAgICB2YXIgYXJyYXlfZWxlbWVudHMgPSBbXVxuICAgIGZvcih2YXIgaT0wOyBpPGRpbWVuc2lvbjsgKytpKSB7XG4gICAgICBhcnJheV9lbGVtZW50cy5wdXNoKFtcInRoaXMuX3YuX1wiLCBwcm9wLCBpXS5qb2luKFwiXCIpKVxuICAgIH1cbiAgICBjb2RlLnB1c2goXG4gICAgICBcImFwcm90by50b0pTT049ZnVuY3Rpb24gXCIgKyBhcnJheU5hbWUgKyBcIl90b0pTT04oKXtyZXR1cm4gW1wiICsgYXJyYXlfZWxlbWVudHMuam9pbihcIixcIikgKyBcIl19XCIsXG4gICAgICBcImFwcm90by52YWx1ZU9mPWFwcm90by50b1N0cmluZz1mdW5jdGlvbiBcIiArIGFycmF5TmFtZSArIFwiX3RvU3RyaW5nKCl7cmV0dXJuIFtcIiArIGFycmF5X2VsZW1lbnRzLmpvaW4oXCIsXCIpICsgXCJdLmpvaW4oKX1cIilcbiAgICBcbiAgICBmb3IodmFyIGk9MDsgaTxkaW1lbnNpb247ICsraSkge1xuICAgICAgY29kZS5wdXNoKFwiT2JqZWN0LmRlZmluZVByb3BlcnR5KGFwcm90byxcIitpK1wiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fdi5fXCIrcHJvcCtpK1wifSxzZXQ6ZnVuY3Rpb24odil7cmV0dXJuIHRoaXMuX3YuX1wiK3Byb3AraStcIj12fDB9LGVudW1lcmFibGU6dHJ1ZX0pXCIpXG4gICAgfVxuICAgIGZvcih2YXIgaT0wOyBpPGFycmF5TWV0aG9kcy5sZW5ndGg7ICsraSkge1xuICAgICAgaWYoYXJyYXlNZXRob2RzW2ldIGluIEFycmF5LnByb3RvdHlwZSkge1xuICAgICAgICBjb2RlLnB1c2goXCJhcHJvdG8uXCIrYXJyYXlNZXRob2RzW2ldK1wiPUFycmF5LnByb3RvdHlwZS5cIithcnJheU1ldGhvZHNbaV0pXG4gICAgICB9XG4gICAgfVxuICAgIGNvZGUucHVzaChbXCJPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG8sJ1wiLHByb3AsXCInLHtnZXQ6ZnVuY3Rpb24gXCIsIGFycmF5TmFtZSwgXCJfZ2V0KCl7cmV0dXJuIG5ldyBcIiwgYXJyYXlOYW1lLCBcIih0aGlzKX0sc2V0OiBmdW5jdGlvbiBcIiwgYXJyYXlOYW1lLCBcIl9zZXQodil7XCJdLmpvaW4oXCJcIikpXG4gICAgZm9yKHZhciBpPTA7IGk8ZGltZW5zaW9uOyArK2kpIHtcbiAgICAgIGNvZGUucHVzaChcInRoaXMuX1wiK3Byb3AraStcIj12W1wiK2krXCJdfDBcIilcbiAgICB9XG4gICAgY29kZS5wdXNoKFwicmV0dXJuIHZ9fSlcIilcbiAgfVxuICBcbiAgLy92aWV3LnNpemU6XG4gIGNvZGUucHVzaChcIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90bywnc2l6ZScse2dldDpmdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfc2l6ZSgpe1xcXG5yZXR1cm4gXCIraW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkgeyByZXR1cm4gXCJ0aGlzLl9zaGFwZVwiK2kgfSkuam9pbihcIipcIiksXG5cIn19KVwiKVxuXG4gIC8vdmlldy5vcmRlcjpcbiAgaWYoZGltZW5zaW9uID09PSAxKSB7XG4gICAgY29kZS5wdXNoKFwicHJvdG8ub3JkZXI9WzBdXCIpXG4gIH0gZWxzZSB7XG4gICAgY29kZS5wdXNoKFwiT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvLCdvcmRlcicse2dldDpcIilcbiAgICBpZihkaW1lbnNpb24gPCA0KSB7XG4gICAgICBjb2RlLnB1c2goXCJmdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfb3JkZXIoKXtcIilcbiAgICAgIGlmKGRpbWVuc2lvbiA9PT0gMikge1xuICAgICAgICBjb2RlLnB1c2goXCJyZXR1cm4gKE1hdGguYWJzKHRoaXMuX3N0cmlkZTApPk1hdGguYWJzKHRoaXMuX3N0cmlkZTEpKT9bMSwwXTpbMCwxXX19KVwiKVxuICAgICAgfSBlbHNlIGlmKGRpbWVuc2lvbiA9PT0gMykge1xuICAgICAgICBjb2RlLnB1c2goXG5cInZhciBzMD1NYXRoLmFicyh0aGlzLl9zdHJpZGUwKSxzMT1NYXRoLmFicyh0aGlzLl9zdHJpZGUxKSxzMj1NYXRoLmFicyh0aGlzLl9zdHJpZGUyKTtcXFxuaWYoczA+czEpe1xcXG5pZihzMT5zMil7XFxcbnJldHVybiBbMiwxLDBdO1xcXG59ZWxzZSBpZihzMD5zMil7XFxcbnJldHVybiBbMSwyLDBdO1xcXG59ZWxzZXtcXFxucmV0dXJuIFsxLDAsMl07XFxcbn1cXFxufWVsc2UgaWYoczA+czIpe1xcXG5yZXR1cm4gWzIsMCwxXTtcXFxufWVsc2UgaWYoczI+czEpe1xcXG5yZXR1cm4gWzAsMSwyXTtcXFxufWVsc2V7XFxcbnJldHVybiBbMCwyLDFdO1xcXG59fX0pXCIpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvZGUucHVzaChcIk9SREVSfSlcIilcbiAgICB9XG4gIH1cbiAgXG4gIC8vdmlldy5zZXQoaTAsIC4uLiwgdik6XG4gIGNvZGUucHVzaChcblwicHJvdG8uc2V0PWZ1bmN0aW9uIFwiK2NsYXNzTmFtZStcIl9zZXQoXCIrYXJncy5qb2luKFwiLFwiKStcIix2KXtcIilcbiAgaWYodXNlR2V0dGVycykge1xuICAgIGNvZGUucHVzaChcInJldHVybiB0aGlzLmRhdGEuc2V0KFwiK2luZGV4X3N0citcIix2KX1cIilcbiAgfSBlbHNlIHtcbiAgICBjb2RlLnB1c2goXCJyZXR1cm4gdGhpcy5kYXRhW1wiK2luZGV4X3N0citcIl09dn1cIilcbiAgfVxuICBcbiAgLy92aWV3LmdldChpMCwgLi4uKTpcbiAgY29kZS5wdXNoKFwicHJvdG8uZ2V0PWZ1bmN0aW9uIFwiK2NsYXNzTmFtZStcIl9nZXQoXCIrYXJncy5qb2luKFwiLFwiKStcIil7XCIpXG4gIGlmKHVzZUdldHRlcnMpIHtcbiAgICBjb2RlLnB1c2goXCJyZXR1cm4gdGhpcy5kYXRhLmdldChcIitpbmRleF9zdHIrXCIpfVwiKVxuICB9IGVsc2Uge1xuICAgIGNvZGUucHVzaChcInJldHVybiB0aGlzLmRhdGFbXCIraW5kZXhfc3RyK1wiXX1cIilcbiAgfVxuICBcbiAgLy92aWV3LmluZGV4OlxuICBjb2RlLnB1c2goXG4gICAgXCJwcm90by5pbmRleD1mdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfaW5kZXgoXCIsIGFyZ3Muam9pbigpLCBcIil7cmV0dXJuIFwiK2luZGV4X3N0citcIn1cIilcblxuICAvL3ZpZXcuaGkoKTpcbiAgY29kZS5wdXNoKFwicHJvdG8uaGk9ZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiX2hpKFwiK2FyZ3Muam9pbihcIixcIikrXCIpe3JldHVybiBuZXcgXCIrY2xhc3NOYW1lK1wiKHRoaXMuZGF0YSxcIitcbiAgICBpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gW1wiKHR5cGVvZiBpXCIsaSxcIiE9PSdudW1iZXInfHxpXCIsaSxcIjwwKT90aGlzLl9zaGFwZVwiLCBpLCBcIjppXCIsIGksXCJ8MFwiXS5qb2luKFwiXCIpXG4gICAgfSkuam9pbihcIixcIikrXCIsXCIrXG4gICAgaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIFwidGhpcy5fc3RyaWRlXCIraVxuICAgIH0pLmpvaW4oXCIsXCIpK1wiLHRoaXMub2Zmc2V0KX1cIilcbiAgXG4gIC8vdmlldy5sbygpOlxuICB2YXIgYV92YXJzID0gaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkgeyByZXR1cm4gXCJhXCIraStcIj10aGlzLl9zaGFwZVwiK2kgfSlcbiAgdmFyIGNfdmFycyA9IGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHsgcmV0dXJuIFwiY1wiK2krXCI9dGhpcy5fc3RyaWRlXCIraSB9KVxuICBjb2RlLnB1c2goXCJwcm90by5sbz1mdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfbG8oXCIrYXJncy5qb2luKFwiLFwiKStcIil7dmFyIGI9dGhpcy5vZmZzZXQsZD0wLFwiK2FfdmFycy5qb2luKFwiLFwiKStcIixcIitjX3ZhcnMuam9pbihcIixcIikpXG4gIGZvcih2YXIgaT0wOyBpPGRpbWVuc2lvbjsgKytpKSB7XG4gICAgY29kZS5wdXNoKFxuXCJpZih0eXBlb2YgaVwiK2krXCI9PT0nbnVtYmVyJyYmaVwiK2krXCI+PTApe1xcXG5kPWlcIitpK1wifDA7XFxcbmIrPWNcIitpK1wiKmQ7XFxcbmFcIitpK1wiLT1kfVwiKVxuICB9XG4gIGNvZGUucHVzaChcInJldHVybiBuZXcgXCIrY2xhc3NOYW1lK1wiKHRoaXMuZGF0YSxcIitcbiAgICBpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gXCJhXCIraVxuICAgIH0pLmpvaW4oXCIsXCIpK1wiLFwiK1xuICAgIGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBcImNcIitpXG4gICAgfSkuam9pbihcIixcIikrXCIsYil9XCIpXG4gIFxuICAvL3ZpZXcuc3RlcCgpOlxuICBjb2RlLnB1c2goXCJwcm90by5zdGVwPWZ1bmN0aW9uIFwiK2NsYXNzTmFtZStcIl9zdGVwKFwiK2FyZ3Muam9pbihcIixcIikrXCIpe3ZhciBcIitcbiAgICBpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gXCJhXCIraStcIj10aGlzLl9zaGFwZVwiK2lcbiAgICB9KS5qb2luKFwiLFwiKStcIixcIitcbiAgICBpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gXCJiXCIraStcIj10aGlzLl9zdHJpZGVcIitpXG4gICAgfSkuam9pbihcIixcIikrXCIsYz10aGlzLm9mZnNldCxkPTAsY2VpbD1NYXRoLmNlaWxcIilcbiAgZm9yKHZhciBpPTA7IGk8ZGltZW5zaW9uOyArK2kpIHtcbiAgICBjb2RlLnB1c2goXG5cImlmKHR5cGVvZiBpXCIraStcIj09PSdudW1iZXInKXtcXFxuZD1pXCIraStcInwwO1xcXG5pZihkPDApe1xcXG5jKz1iXCIraStcIiooYVwiK2krXCItMSk7XFxcbmFcIitpK1wiPWNlaWwoLWFcIitpK1wiL2QpXFxcbn1lbHNle1xcXG5hXCIraStcIj1jZWlsKGFcIitpK1wiL2QpXFxcbn1cXFxuYlwiK2krXCIqPWRcXFxufVwiKVxuICB9XG4gIGNvZGUucHVzaChcInJldHVybiBuZXcgXCIrY2xhc3NOYW1lK1wiKHRoaXMuZGF0YSxcIitcbiAgICBpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gXCJhXCIgKyBpXG4gICAgfSkuam9pbihcIixcIikrXCIsXCIrXG4gICAgaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIFwiYlwiICsgaVxuICAgIH0pLmpvaW4oXCIsXCIpK1wiLGMpfVwiKVxuICBcbiAgLy92aWV3LnRyYW5zcG9zZSgpOlxuICB2YXIgdFNoYXBlID0gbmV3IEFycmF5KGRpbWVuc2lvbilcbiAgdmFyIHRTdHJpZGUgPSBuZXcgQXJyYXkoZGltZW5zaW9uKVxuICBmb3IodmFyIGk9MDsgaTxkaW1lbnNpb247ICsraSkge1xuICAgIHRTaGFwZVtpXSA9IFwiYVtpXCIraStcIl1cIlxuICAgIHRTdHJpZGVbaV0gPSBcImJbaVwiK2krXCJdXCJcbiAgfVxuICBjb2RlLnB1c2goXCJwcm90by50cmFuc3Bvc2U9ZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiX3RyYW5zcG9zZShcIithcmdzK1wiKXtcIitcbiAgICBhcmdzLm1hcChmdW5jdGlvbihuLGlkeCkgeyByZXR1cm4gbiArIFwiPShcIiArIG4gKyBcIj09PXVuZGVmaW5lZD9cIiArIGlkeCArIFwiOlwiICsgbiArIFwifDApXCJ9KS5qb2luKFwiO1wiKSxcbiAgICBcInZhciBhPXRoaXMuc2hhcGUsYj10aGlzLnN0cmlkZTtyZXR1cm4gbmV3IFwiK2NsYXNzTmFtZStcIih0aGlzLmRhdGEsXCIrdFNoYXBlLmpvaW4oXCIsXCIpK1wiLFwiK3RTdHJpZGUuam9pbihcIixcIikrXCIsdGhpcy5vZmZzZXQpfVwiKVxuICBcbiAgLy92aWV3LnBpY2soKTpcbiAgY29kZS5wdXNoKFwicHJvdG8ucGljaz1mdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfcGljayhcIithcmdzK1wiKXt2YXIgYT1bXSxiPVtdLGM9dGhpcy5vZmZzZXRcIilcbiAgZm9yKHZhciBpPTA7IGk8ZGltZW5zaW9uOyArK2kpIHtcbiAgICBjb2RlLnB1c2goXCJpZih0eXBlb2YgaVwiK2krXCI9PT0nbnVtYmVyJyYmaVwiK2krXCI+PTApe2M9KGMrdGhpcy5fc3RyaWRlXCIraStcIippXCIraStcIil8MH1lbHNle2EucHVzaCh0aGlzLl9zaGFwZVwiK2krXCIpO2IucHVzaCh0aGlzLl9zdHJpZGVcIitpK1wiKX1cIilcbiAgfVxuICBjb2RlLnB1c2goXCJ2YXIgY3Rvcj1DVE9SX0xJU1RbYS5sZW5ndGgrMV07cmV0dXJuIGN0b3IodGhpcy5kYXRhLGEsYixjKX1cIilcbiAgICBcbiAgLy9BZGQgcmV0dXJuIHN0YXRlbWVudFxuICBjb2RlLnB1c2goXCJyZXR1cm4gZnVuY3Rpb24gY29uc3RydWN0X1wiK2NsYXNzTmFtZStcIihkYXRhLHNoYXBlLHN0cmlkZSxvZmZzZXQpe3JldHVybiBuZXcgXCIrY2xhc3NOYW1lK1wiKGRhdGEsXCIrXG4gICAgaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIFwic2hhcGVbXCIraStcIl1cIlxuICAgIH0pLmpvaW4oXCIsXCIpK1wiLFwiK1xuICAgIGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBcInN0cmlkZVtcIitpK1wiXVwiXG4gICAgfSkuam9pbihcIixcIikrXCIsb2Zmc2V0KX1cIilcblxuICAvL0NvbXBpbGUgcHJvY2VkdXJlXG4gIHZhciBwcm9jZWR1cmUgPSBuZXcgRnVuY3Rpb24oXCJDVE9SX0xJU1RcIiwgXCJPUkRFUlwiLCBjb2RlLmpvaW4oXCJcXG5cIikpXG4gIHJldHVybiBwcm9jZWR1cmUoQ0FDSEVEX0NPTlNUUlVDVE9SU1tkdHlwZV0sIG9yZGVyKVxufVxuXG5mdW5jdGlvbiBhcnJheURUeXBlKGRhdGEpIHtcbiAgaWYoaGFzQnVmZmVyKSB7XG4gICAgaWYoQnVmZmVyLmlzQnVmZmVyKGRhdGEpKSB7XG4gICAgICByZXR1cm4gXCJidWZmZXJcIlxuICAgIH1cbiAgfVxuICBpZihoYXNUeXBlZEFycmF5cykge1xuICAgIHN3aXRjaChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZGF0YSkpIHtcbiAgICAgIGNhc2UgXCJbb2JqZWN0IEZsb2F0NjRBcnJheV1cIjpcbiAgICAgICAgcmV0dXJuIFwiZmxvYXQ2NFwiXG4gICAgICBjYXNlIFwiW29iamVjdCBGbG9hdDMyQXJyYXldXCI6XG4gICAgICAgIHJldHVybiBcImZsb2F0MzJcIlxuICAgICAgY2FzZSBcIltvYmplY3QgSW50OEFycmF5XVwiOlxuICAgICAgICByZXR1cm4gXCJpbnQ4XCJcbiAgICAgIGNhc2UgXCJbb2JqZWN0IEludDE2QXJyYXldXCI6XG4gICAgICAgIHJldHVybiBcImludDE2XCJcbiAgICAgIGNhc2UgXCJbb2JqZWN0IEludDMyQXJyYXldXCI6XG4gICAgICAgIHJldHVybiBcImludDMyXCJcbiAgICAgIGNhc2UgXCJbb2JqZWN0IFVpbnQ4QXJyYXldXCI6XG4gICAgICAgIHJldHVybiBcInVpbnQ4XCJcbiAgICAgIGNhc2UgXCJbb2JqZWN0IFVpbnQxNkFycmF5XVwiOlxuICAgICAgICByZXR1cm4gXCJ1aW50MTZcIlxuICAgICAgY2FzZSBcIltvYmplY3QgVWludDMyQXJyYXldXCI6XG4gICAgICAgIHJldHVybiBcInVpbnQzMlwiXG4gICAgICBjYXNlIFwiW29iamVjdCBVaW50OENsYW1wZWRBcnJheV1cIjpcbiAgICAgICAgcmV0dXJuIFwidWludDhfY2xhbXBlZFwiXG4gICAgfVxuICB9XG4gIGlmKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICByZXR1cm4gXCJhcnJheVwiXG4gIH1cbiAgcmV0dXJuIFwiZ2VuZXJpY1wiXG59XG5cbnZhciBDQUNIRURfQ09OU1RSVUNUT1JTID0ge1xuICBcImZsb2F0MzJcIjpbXSxcbiAgXCJmbG9hdDY0XCI6W10sXG4gIFwiaW50OFwiOltdLFxuICBcImludDE2XCI6W10sXG4gIFwiaW50MzJcIjpbXSxcbiAgXCJ1aW50OFwiOltdLFxuICBcInVpbnQxNlwiOltdLFxuICBcInVpbnQzMlwiOltdLFxuICBcImFycmF5XCI6W10sXG4gIFwidWludDhfY2xhbXBlZFwiOltdLFxuICBcImJ1ZmZlclwiOltdLFxuICBcImdlbmVyaWNcIjpbXVxufVxuXG47KGZ1bmN0aW9uKCkge1xuICBmb3IodmFyIGlkIGluIENBQ0hFRF9DT05TVFJVQ1RPUlMpIHtcbiAgICBDQUNIRURfQ09OU1RSVUNUT1JTW2lkXS5wdXNoKGNvbXBpbGVDb25zdHJ1Y3RvcihpZCwgLTEpKVxuICB9XG59KTtcblxuZnVuY3Rpb24gd3JhcHBlZE5EQXJyYXlDdG9yKGRhdGEsIHNoYXBlLCBzdHJpZGUsIG9mZnNldCkge1xuICBpZihkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgY3RvciA9IENBQ0hFRF9DT05TVFJVQ1RPUlMuYXJyYXlbMF1cbiAgICByZXR1cm4gY3RvcihbXSlcbiAgfSBlbHNlIGlmKHR5cGVvZiBkYXRhID09PSBcIm51bWJlclwiKSB7XG4gICAgZGF0YSA9IFtkYXRhXVxuICB9XG4gIGlmKHNoYXBlID09PSB1bmRlZmluZWQpIHtcbiAgICBzaGFwZSA9IFsgZGF0YS5sZW5ndGggXVxuICB9XG4gIHZhciBkID0gc2hhcGUubGVuZ3RoXG4gIGlmKHN0cmlkZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RyaWRlID0gbmV3IEFycmF5KGQpXG4gICAgZm9yKHZhciBpPWQtMSwgc3o9MTsgaT49MDsgLS1pKSB7XG4gICAgICBzdHJpZGVbaV0gPSBzelxuICAgICAgc3ogKj0gc2hhcGVbaV1cbiAgICB9XG4gIH1cbiAgaWYob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICBvZmZzZXQgPSAwXG4gICAgZm9yKHZhciBpPTA7IGk8ZDsgKytpKSB7XG4gICAgICBpZihzdHJpZGVbaV0gPCAwKSB7XG4gICAgICAgIG9mZnNldCAtPSAoc2hhcGVbaV0tMSkqc3RyaWRlW2ldXG4gICAgICB9XG4gICAgfVxuICB9XG4gIHZhciBkdHlwZSA9IGFycmF5RFR5cGUoZGF0YSlcbiAgdmFyIGN0b3JfbGlzdCA9IENBQ0hFRF9DT05TVFJVQ1RPUlNbZHR5cGVdXG4gIHdoaWxlKGN0b3JfbGlzdC5sZW5ndGggPD0gZCsxKSB7XG4gICAgY3Rvcl9saXN0LnB1c2goY29tcGlsZUNvbnN0cnVjdG9yKGR0eXBlLCBjdG9yX2xpc3QubGVuZ3RoLTEpKVxuICB9XG4gIHZhciBjdG9yID0gY3Rvcl9saXN0W2QrMV1cbiAgcmV0dXJuIGN0b3IoZGF0YSwgc2hhcGUsIHN0cmlkZSwgb2Zmc2V0KVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHdyYXBwZWROREFycmF5Q3RvclxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyKSIsIlwidXNlIHN0cmljdFwiXG5cbmZ1bmN0aW9uIGlvdGEobikge1xuICB2YXIgcmVzdWx0ID0gbmV3IEFycmF5KG4pXG4gIGZvcih2YXIgaT0wOyBpPG47ICsraSkge1xuICAgIHJlc3VsdFtpXSA9IGlcbiAgfVxuICByZXR1cm4gcmVzdWx0XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW90YSIsIi8qKlxuICogQml0IHR3aWRkbGluZyBoYWNrcyBmb3IgSmF2YVNjcmlwdC5cbiAqXG4gKiBBdXRob3I6IE1pa29sYSBMeXNlbmtvXG4gKlxuICogUG9ydGVkIGZyb20gU3RhbmZvcmQgYml0IHR3aWRkbGluZyBoYWNrIGxpYnJhcnk6XG4gKiAgICBodHRwOi8vZ3JhcGhpY3Muc3RhbmZvcmQuZWR1L35zZWFuZGVyL2JpdGhhY2tzLmh0bWxcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjsgXCJ1c2UgcmVzdHJpY3RcIjtcblxuLy9OdW1iZXIgb2YgYml0cyBpbiBhbiBpbnRlZ2VyXG52YXIgSU5UX0JJVFMgPSAzMjtcblxuLy9Db25zdGFudHNcbmV4cG9ydHMuSU5UX0JJVFMgID0gSU5UX0JJVFM7XG5leHBvcnRzLklOVF9NQVggICA9ICAweDdmZmZmZmZmO1xuZXhwb3J0cy5JTlRfTUlOICAgPSAtMTw8KElOVF9CSVRTLTEpO1xuXG4vL1JldHVybnMgLTEsIDAsICsxIGRlcGVuZGluZyBvbiBzaWduIG9mIHhcbmV4cG9ydHMuc2lnbiA9IGZ1bmN0aW9uKHYpIHtcbiAgcmV0dXJuICh2ID4gMCkgLSAodiA8IDApO1xufVxuXG4vL0NvbXB1dGVzIGFic29sdXRlIHZhbHVlIG9mIGludGVnZXJcbmV4cG9ydHMuYWJzID0gZnVuY3Rpb24odikge1xuICB2YXIgbWFzayA9IHYgPj4gKElOVF9CSVRTLTEpO1xuICByZXR1cm4gKHYgXiBtYXNrKSAtIG1hc2s7XG59XG5cbi8vQ29tcHV0ZXMgbWluaW11bSBvZiBpbnRlZ2VycyB4IGFuZCB5XG5leHBvcnRzLm1pbiA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgcmV0dXJuIHkgXiAoKHggXiB5KSAmIC0oeCA8IHkpKTtcbn1cblxuLy9Db21wdXRlcyBtYXhpbXVtIG9mIGludGVnZXJzIHggYW5kIHlcbmV4cG9ydHMubWF4ID0gZnVuY3Rpb24oeCwgeSkge1xuICByZXR1cm4geCBeICgoeCBeIHkpICYgLSh4IDwgeSkpO1xufVxuXG4vL0NoZWNrcyBpZiBhIG51bWJlciBpcyBhIHBvd2VyIG9mIHR3b1xuZXhwb3J0cy5pc1BvdzIgPSBmdW5jdGlvbih2KSB7XG4gIHJldHVybiAhKHYgJiAodi0xKSkgJiYgKCEhdik7XG59XG5cbi8vQ29tcHV0ZXMgbG9nIGJhc2UgMiBvZiB2XG5leHBvcnRzLmxvZzIgPSBmdW5jdGlvbih2KSB7XG4gIHZhciByLCBzaGlmdDtcbiAgciA9ICAgICAodiA+IDB4RkZGRikgPDwgNDsgdiA+Pj49IHI7XG4gIHNoaWZ0ID0gKHYgPiAweEZGICApIDw8IDM7IHYgPj4+PSBzaGlmdDsgciB8PSBzaGlmdDtcbiAgc2hpZnQgPSAodiA+IDB4RiAgICkgPDwgMjsgdiA+Pj49IHNoaWZ0OyByIHw9IHNoaWZ0O1xuICBzaGlmdCA9ICh2ID4gMHgzICAgKSA8PCAxOyB2ID4+Pj0gc2hpZnQ7IHIgfD0gc2hpZnQ7XG4gIHJldHVybiByIHwgKHYgPj4gMSk7XG59XG5cbi8vQ29tcHV0ZXMgbG9nIGJhc2UgMTAgb2YgdlxuZXhwb3J0cy5sb2cxMCA9IGZ1bmN0aW9uKHYpIHtcbiAgcmV0dXJuICAodiA+PSAxMDAwMDAwMDAwKSA/IDkgOiAodiA+PSAxMDAwMDAwMDApID8gOCA6ICh2ID49IDEwMDAwMDAwKSA/IDcgOlxuICAgICAgICAgICh2ID49IDEwMDAwMDApID8gNiA6ICh2ID49IDEwMDAwMCkgPyA1IDogKHYgPj0gMTAwMDApID8gNCA6XG4gICAgICAgICAgKHYgPj0gMTAwMCkgPyAzIDogKHYgPj0gMTAwKSA/IDIgOiAodiA+PSAxMCkgPyAxIDogMDtcbn1cblxuLy9Db3VudHMgbnVtYmVyIG9mIGJpdHNcbmV4cG9ydHMucG9wQ291bnQgPSBmdW5jdGlvbih2KSB7XG4gIHYgPSB2IC0gKCh2ID4+PiAxKSAmIDB4NTU1NTU1NTUpO1xuICB2ID0gKHYgJiAweDMzMzMzMzMzKSArICgodiA+Pj4gMikgJiAweDMzMzMzMzMzKTtcbiAgcmV0dXJuICgodiArICh2ID4+PiA0KSAmIDB4RjBGMEYwRikgKiAweDEwMTAxMDEpID4+PiAyNDtcbn1cblxuLy9Db3VudHMgbnVtYmVyIG9mIHRyYWlsaW5nIHplcm9zXG5mdW5jdGlvbiBjb3VudFRyYWlsaW5nWmVyb3Modikge1xuICB2YXIgYyA9IDMyO1xuICB2ICY9IC12O1xuICBpZiAodikgYy0tO1xuICBpZiAodiAmIDB4MDAwMEZGRkYpIGMgLT0gMTY7XG4gIGlmICh2ICYgMHgwMEZGMDBGRikgYyAtPSA4O1xuICBpZiAodiAmIDB4MEYwRjBGMEYpIGMgLT0gNDtcbiAgaWYgKHYgJiAweDMzMzMzMzMzKSBjIC09IDI7XG4gIGlmICh2ICYgMHg1NTU1NTU1NSkgYyAtPSAxO1xuICByZXR1cm4gYztcbn1cbmV4cG9ydHMuY291bnRUcmFpbGluZ1plcm9zID0gY291bnRUcmFpbGluZ1plcm9zO1xuXG4vL1JvdW5kcyB0byBuZXh0IHBvd2VyIG9mIDJcbmV4cG9ydHMubmV4dFBvdzIgPSBmdW5jdGlvbih2KSB7XG4gIHYgKz0gdiA9PT0gMDtcbiAgLS12O1xuICB2IHw9IHYgPj4+IDE7XG4gIHYgfD0gdiA+Pj4gMjtcbiAgdiB8PSB2ID4+PiA0O1xuICB2IHw9IHYgPj4+IDg7XG4gIHYgfD0gdiA+Pj4gMTY7XG4gIHJldHVybiB2ICsgMTtcbn1cblxuLy9Sb3VuZHMgZG93biB0byBwcmV2aW91cyBwb3dlciBvZiAyXG5leHBvcnRzLnByZXZQb3cyID0gZnVuY3Rpb24odikge1xuICB2IHw9IHYgPj4+IDE7XG4gIHYgfD0gdiA+Pj4gMjtcbiAgdiB8PSB2ID4+PiA0O1xuICB2IHw9IHYgPj4+IDg7XG4gIHYgfD0gdiA+Pj4gMTY7XG4gIHJldHVybiB2IC0gKHY+Pj4xKTtcbn1cblxuLy9Db21wdXRlcyBwYXJpdHkgb2Ygd29yZFxuZXhwb3J0cy5wYXJpdHkgPSBmdW5jdGlvbih2KSB7XG4gIHYgXj0gdiA+Pj4gMTY7XG4gIHYgXj0gdiA+Pj4gODtcbiAgdiBePSB2ID4+PiA0O1xuICB2ICY9IDB4ZjtcbiAgcmV0dXJuICgweDY5OTYgPj4+IHYpICYgMTtcbn1cblxudmFyIFJFVkVSU0VfVEFCTEUgPSBuZXcgQXJyYXkoMjU2KTtcblxuKGZ1bmN0aW9uKHRhYikge1xuICBmb3IodmFyIGk9MDsgaTwyNTY7ICsraSkge1xuICAgIHZhciB2ID0gaSwgciA9IGksIHMgPSA3O1xuICAgIGZvciAodiA+Pj49IDE7IHY7IHYgPj4+PSAxKSB7XG4gICAgICByIDw8PSAxO1xuICAgICAgciB8PSB2ICYgMTtcbiAgICAgIC0tcztcbiAgICB9XG4gICAgdGFiW2ldID0gKHIgPDwgcykgJiAweGZmO1xuICB9XG59KShSRVZFUlNFX1RBQkxFKTtcblxuLy9SZXZlcnNlIGJpdHMgaW4gYSAzMiBiaXQgd29yZFxuZXhwb3J0cy5yZXZlcnNlID0gZnVuY3Rpb24odikge1xuICByZXR1cm4gIChSRVZFUlNFX1RBQkxFWyB2ICAgICAgICAgJiAweGZmXSA8PCAyNCkgfFxuICAgICAgICAgIChSRVZFUlNFX1RBQkxFWyh2ID4+PiA4KSAgJiAweGZmXSA8PCAxNikgfFxuICAgICAgICAgIChSRVZFUlNFX1RBQkxFWyh2ID4+PiAxNikgJiAweGZmXSA8PCA4KSAgfFxuICAgICAgICAgICBSRVZFUlNFX1RBQkxFWyh2ID4+PiAyNCkgJiAweGZmXTtcbn1cblxuLy9JbnRlcmxlYXZlIGJpdHMgb2YgMiBjb29yZGluYXRlcyB3aXRoIDE2IGJpdHMuICBVc2VmdWwgZm9yIGZhc3QgcXVhZHRyZWUgY29kZXNcbmV4cG9ydHMuaW50ZXJsZWF2ZTIgPSBmdW5jdGlvbih4LCB5KSB7XG4gIHggJj0gMHhGRkZGO1xuICB4ID0gKHggfCAoeCA8PCA4KSkgJiAweDAwRkYwMEZGO1xuICB4ID0gKHggfCAoeCA8PCA0KSkgJiAweDBGMEYwRjBGO1xuICB4ID0gKHggfCAoeCA8PCAyKSkgJiAweDMzMzMzMzMzO1xuICB4ID0gKHggfCAoeCA8PCAxKSkgJiAweDU1NTU1NTU1O1xuXG4gIHkgJj0gMHhGRkZGO1xuICB5ID0gKHkgfCAoeSA8PCA4KSkgJiAweDAwRkYwMEZGO1xuICB5ID0gKHkgfCAoeSA8PCA0KSkgJiAweDBGMEYwRjBGO1xuICB5ID0gKHkgfCAoeSA8PCAyKSkgJiAweDMzMzMzMzMzO1xuICB5ID0gKHkgfCAoeSA8PCAxKSkgJiAweDU1NTU1NTU1O1xuXG4gIHJldHVybiB4IHwgKHkgPDwgMSk7XG59XG5cbi8vRXh0cmFjdHMgdGhlIG50aCBpbnRlcmxlYXZlZCBjb21wb25lbnRcbmV4cG9ydHMuZGVpbnRlcmxlYXZlMiA9IGZ1bmN0aW9uKHYsIG4pIHtcbiAgdiA9ICh2ID4+PiBuKSAmIDB4NTU1NTU1NTU7XG4gIHYgPSAodiB8ICh2ID4+PiAxKSkgICYgMHgzMzMzMzMzMztcbiAgdiA9ICh2IHwgKHYgPj4+IDIpKSAgJiAweDBGMEYwRjBGO1xuICB2ID0gKHYgfCAodiA+Pj4gNCkpICAmIDB4MDBGRjAwRkY7XG4gIHYgPSAodiB8ICh2ID4+PiAxNikpICYgMHgwMDBGRkZGO1xuICByZXR1cm4gKHYgPDwgMTYpID4+IDE2O1xufVxuXG5cbi8vSW50ZXJsZWF2ZSBiaXRzIG9mIDMgY29vcmRpbmF0ZXMsIGVhY2ggd2l0aCAxMCBiaXRzLiAgVXNlZnVsIGZvciBmYXN0IG9jdHJlZSBjb2Rlc1xuZXhwb3J0cy5pbnRlcmxlYXZlMyA9IGZ1bmN0aW9uKHgsIHksIHopIHtcbiAgeCAmPSAweDNGRjtcbiAgeCAgPSAoeCB8ICh4PDwxNikpICYgNDI3ODE5MDMzNTtcbiAgeCAgPSAoeCB8ICh4PDw4KSkgICYgMjUxNzE5Njk1O1xuICB4ICA9ICh4IHwgKHg8PDQpKSAgJiAzMjcyMzU2MDM1O1xuICB4ICA9ICh4IHwgKHg8PDIpKSAgJiAxMjI3MTMzNTEzO1xuXG4gIHkgJj0gMHgzRkY7XG4gIHkgID0gKHkgfCAoeTw8MTYpKSAmIDQyNzgxOTAzMzU7XG4gIHkgID0gKHkgfCAoeTw8OCkpICAmIDI1MTcxOTY5NTtcbiAgeSAgPSAoeSB8ICh5PDw0KSkgICYgMzI3MjM1NjAzNTtcbiAgeSAgPSAoeSB8ICh5PDwyKSkgICYgMTIyNzEzMzUxMztcbiAgeCB8PSAoeSA8PCAxKTtcbiAgXG4gIHogJj0gMHgzRkY7XG4gIHogID0gKHogfCAoejw8MTYpKSAmIDQyNzgxOTAzMzU7XG4gIHogID0gKHogfCAoejw8OCkpICAmIDI1MTcxOTY5NTtcbiAgeiAgPSAoeiB8ICh6PDw0KSkgICYgMzI3MjM1NjAzNTtcbiAgeiAgPSAoeiB8ICh6PDwyKSkgICYgMTIyNzEzMzUxMztcbiAgXG4gIHJldHVybiB4IHwgKHogPDwgMik7XG59XG5cbi8vRXh0cmFjdHMgbnRoIGludGVybGVhdmVkIGNvbXBvbmVudCBvZiBhIDMtdHVwbGVcbmV4cG9ydHMuZGVpbnRlcmxlYXZlMyA9IGZ1bmN0aW9uKHYsIG4pIHtcbiAgdiA9ICh2ID4+PiBuKSAgICAgICAmIDEyMjcxMzM1MTM7XG4gIHYgPSAodiB8ICh2Pj4+MikpICAgJiAzMjcyMzU2MDM1O1xuICB2ID0gKHYgfCAodj4+PjQpKSAgICYgMjUxNzE5Njk1O1xuICB2ID0gKHYgfCAodj4+PjgpKSAgICYgNDI3ODE5MDMzNTtcbiAgdiA9ICh2IHwgKHY+Pj4xNikpICAmIDB4M0ZGO1xuICByZXR1cm4gKHY8PDIyKT4+MjI7XG59XG5cbi8vQ29tcHV0ZXMgbmV4dCBjb21iaW5hdGlvbiBpbiBjb2xleGljb2dyYXBoaWMgb3JkZXIgKHRoaXMgaXMgbWlzdGFrZW5seSBjYWxsZWQgbmV4dFBlcm11dGF0aW9uIG9uIHRoZSBiaXQgdHdpZGRsaW5nIGhhY2tzIHBhZ2UpXG5leHBvcnRzLm5leHRDb21iaW5hdGlvbiA9IGZ1bmN0aW9uKHYpIHtcbiAgdmFyIHQgPSB2IHwgKHYgLSAxKTtcbiAgcmV0dXJuICh0ICsgMSkgfCAoKCh+dCAmIC1+dCkgLSAxKSA+Pj4gKGNvdW50VHJhaWxpbmdaZXJvcyh2KSArIDEpKTtcbn1cblxuIiwiXCJ1c2Ugc3RyaWN0XCJcblxuZnVuY3Rpb24gZHVwZV9hcnJheShjb3VudCwgdmFsdWUsIGkpIHtcbiAgdmFyIGMgPSBjb3VudFtpXXwwXG4gIGlmKGMgPD0gMCkge1xuICAgIHJldHVybiBbXVxuICB9XG4gIHZhciByZXN1bHQgPSBuZXcgQXJyYXkoYyksIGpcbiAgaWYoaSA9PT0gY291bnQubGVuZ3RoLTEpIHtcbiAgICBmb3Ioaj0wOyBqPGM7ICsraikge1xuICAgICAgcmVzdWx0W2pdID0gdmFsdWVcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yKGo9MDsgajxjOyArK2opIHtcbiAgICAgIHJlc3VsdFtqXSA9IGR1cGVfYXJyYXkoY291bnQsIHZhbHVlLCBpKzEpXG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHRcbn1cblxuZnVuY3Rpb24gZHVwZV9udW1iZXIoY291bnQsIHZhbHVlKSB7XG4gIHZhciByZXN1bHQsIGlcbiAgcmVzdWx0ID0gbmV3IEFycmF5KGNvdW50KVxuICBmb3IoaT0wOyBpPGNvdW50OyArK2kpIHtcbiAgICByZXN1bHRbaV0gPSB2YWx1ZVxuICB9XG4gIHJldHVybiByZXN1bHRcbn1cblxuZnVuY3Rpb24gZHVwZShjb3VudCwgdmFsdWUpIHtcbiAgaWYodHlwZW9mIHZhbHVlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdmFsdWUgPSAwXG4gIH1cbiAgc3dpdGNoKHR5cGVvZiBjb3VudCkge1xuICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgIGlmKGNvdW50ID4gMCkge1xuICAgICAgICByZXR1cm4gZHVwZV9udW1iZXIoY291bnR8MCwgdmFsdWUpXG4gICAgICB9XG4gICAgYnJlYWtcbiAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICBpZih0eXBlb2YgKGNvdW50Lmxlbmd0aCkgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgcmV0dXJuIGR1cGVfYXJyYXkoY291bnQsIHZhbHVlLCAwKVxuICAgICAgfVxuICAgIGJyZWFrXG4gIH1cbiAgcmV0dXJuIFtdXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZHVwZSIsIihmdW5jdGlvbiAoZ2xvYmFsLEJ1ZmZlcil7XG4ndXNlIHN0cmljdCdcblxudmFyIGJpdHMgPSByZXF1aXJlKCdiaXQtdHdpZGRsZScpXG52YXIgZHVwID0gcmVxdWlyZSgnZHVwJylcblxuLy9MZWdhY3kgcG9vbCBzdXBwb3J0XG5pZighZ2xvYmFsLl9fVFlQRURBUlJBWV9QT09MKSB7XG4gIGdsb2JhbC5fX1RZUEVEQVJSQVlfUE9PTCA9IHtcbiAgICAgIFVJTlQ4ICAgOiBkdXAoWzMyLCAwXSlcbiAgICAsIFVJTlQxNiAgOiBkdXAoWzMyLCAwXSlcbiAgICAsIFVJTlQzMiAgOiBkdXAoWzMyLCAwXSlcbiAgICAsIElOVDggICAgOiBkdXAoWzMyLCAwXSlcbiAgICAsIElOVDE2ICAgOiBkdXAoWzMyLCAwXSlcbiAgICAsIElOVDMyICAgOiBkdXAoWzMyLCAwXSlcbiAgICAsIEZMT0FUICAgOiBkdXAoWzMyLCAwXSlcbiAgICAsIERPVUJMRSAgOiBkdXAoWzMyLCAwXSlcbiAgICAsIERBVEEgICAgOiBkdXAoWzMyLCAwXSlcbiAgICAsIFVJTlQ4QyAgOiBkdXAoWzMyLCAwXSlcbiAgICAsIEJVRkZFUiAgOiBkdXAoWzMyLCAwXSlcbiAgfVxufVxuXG52YXIgaGFzVWludDhDID0gKHR5cGVvZiBVaW50OENsYW1wZWRBcnJheSkgIT09ICd1bmRlZmluZWQnXG52YXIgUE9PTCA9IGdsb2JhbC5fX1RZUEVEQVJSQVlfUE9PTFxuXG4vL1VwZ3JhZGUgcG9vbFxuaWYoIVBPT0wuVUlOVDhDKSB7XG4gIFBPT0wuVUlOVDhDID0gZHVwKFszMiwgMF0pXG59XG5pZighUE9PTC5CVUZGRVIpIHtcbiAgUE9PTC5CVUZGRVIgPSBkdXAoWzMyLCAwXSlcbn1cblxuLy9OZXcgdGVjaG5pcXVlOiBPbmx5IGFsbG9jYXRlIGZyb20gQXJyYXlCdWZmZXJWaWV3IGFuZCBCdWZmZXJcbnZhciBEQVRBICAgID0gUE9PTC5EQVRBXG4gICwgQlVGRkVSICA9IFBPT0wuQlVGRkVSXG5cbmV4cG9ydHMuZnJlZSA9IGZ1bmN0aW9uIGZyZWUoYXJyYXkpIHtcbiAgaWYoQnVmZmVyLmlzQnVmZmVyKGFycmF5KSkge1xuICAgIEJVRkZFUltiaXRzLmxvZzIoYXJyYXkubGVuZ3RoKV0ucHVzaChhcnJheSlcbiAgfSBlbHNlIHtcbiAgICBpZihPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJyYXkpICE9PSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nKSB7XG4gICAgICBhcnJheSA9IGFycmF5LmJ1ZmZlclxuICAgIH1cbiAgICBpZighYXJyYXkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB2YXIgbiA9IGFycmF5Lmxlbmd0aCB8fCBhcnJheS5ieXRlTGVuZ3RoXG4gICAgdmFyIGxvZ19uID0gYml0cy5sb2cyKG4pfDBcbiAgICBEQVRBW2xvZ19uXS5wdXNoKGFycmF5KVxuICB9XG59XG5cbmZ1bmN0aW9uIGZyZWVBcnJheUJ1ZmZlcihidWZmZXIpIHtcbiAgaWYoIWJ1ZmZlcikge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBuID0gYnVmZmVyLmxlbmd0aCB8fCBidWZmZXIuYnl0ZUxlbmd0aFxuICB2YXIgbG9nX24gPSBiaXRzLmxvZzIobilcbiAgREFUQVtsb2dfbl0ucHVzaChidWZmZXIpXG59XG5cbmZ1bmN0aW9uIGZyZWVUeXBlZEFycmF5KGFycmF5KSB7XG4gIGZyZWVBcnJheUJ1ZmZlcihhcnJheS5idWZmZXIpXG59XG5cbmV4cG9ydHMuZnJlZVVpbnQ4ID1cbmV4cG9ydHMuZnJlZVVpbnQxNiA9XG5leHBvcnRzLmZyZWVVaW50MzIgPVxuZXhwb3J0cy5mcmVlSW50OCA9XG5leHBvcnRzLmZyZWVJbnQxNiA9XG5leHBvcnRzLmZyZWVJbnQzMiA9XG5leHBvcnRzLmZyZWVGbG9hdDMyID0gXG5leHBvcnRzLmZyZWVGbG9hdCA9XG5leHBvcnRzLmZyZWVGbG9hdDY0ID0gXG5leHBvcnRzLmZyZWVEb3VibGUgPSBcbmV4cG9ydHMuZnJlZVVpbnQ4Q2xhbXBlZCA9IFxuZXhwb3J0cy5mcmVlRGF0YVZpZXcgPSBmcmVlVHlwZWRBcnJheVxuXG5leHBvcnRzLmZyZWVBcnJheUJ1ZmZlciA9IGZyZWVBcnJheUJ1ZmZlclxuXG5leHBvcnRzLmZyZWVCdWZmZXIgPSBmdW5jdGlvbiBmcmVlQnVmZmVyKGFycmF5KSB7XG4gIEJVRkZFUltiaXRzLmxvZzIoYXJyYXkubGVuZ3RoKV0ucHVzaChhcnJheSlcbn1cblxuZXhwb3J0cy5tYWxsb2MgPSBmdW5jdGlvbiBtYWxsb2MobiwgZHR5cGUpIHtcbiAgaWYoZHR5cGUgPT09IHVuZGVmaW5lZCB8fCBkdHlwZSA9PT0gJ2FycmF5YnVmZmVyJykge1xuICAgIHJldHVybiBtYWxsb2NBcnJheUJ1ZmZlcihuKVxuICB9IGVsc2Uge1xuICAgIHN3aXRjaChkdHlwZSkge1xuICAgICAgY2FzZSAndWludDgnOlxuICAgICAgICByZXR1cm4gbWFsbG9jVWludDgobilcbiAgICAgIGNhc2UgJ3VpbnQxNic6XG4gICAgICAgIHJldHVybiBtYWxsb2NVaW50MTYobilcbiAgICAgIGNhc2UgJ3VpbnQzMic6XG4gICAgICAgIHJldHVybiBtYWxsb2NVaW50MzIobilcbiAgICAgIGNhc2UgJ2ludDgnOlxuICAgICAgICByZXR1cm4gbWFsbG9jSW50OChuKVxuICAgICAgY2FzZSAnaW50MTYnOlxuICAgICAgICByZXR1cm4gbWFsbG9jSW50MTYobilcbiAgICAgIGNhc2UgJ2ludDMyJzpcbiAgICAgICAgcmV0dXJuIG1hbGxvY0ludDMyKG4pXG4gICAgICBjYXNlICdmbG9hdCc6XG4gICAgICBjYXNlICdmbG9hdDMyJzpcbiAgICAgICAgcmV0dXJuIG1hbGxvY0Zsb2F0KG4pXG4gICAgICBjYXNlICdkb3VibGUnOlxuICAgICAgY2FzZSAnZmxvYXQ2NCc6XG4gICAgICAgIHJldHVybiBtYWxsb2NEb3VibGUobilcbiAgICAgIGNhc2UgJ3VpbnQ4X2NsYW1wZWQnOlxuICAgICAgICByZXR1cm4gbWFsbG9jVWludDhDbGFtcGVkKG4pXG4gICAgICBjYXNlICdidWZmZXInOlxuICAgICAgICByZXR1cm4gbWFsbG9jQnVmZmVyKG4pXG4gICAgICBjYXNlICdkYXRhJzpcbiAgICAgIGNhc2UgJ2RhdGF2aWV3JzpcbiAgICAgICAgcmV0dXJuIG1hbGxvY0RhdGFWaWV3KG4pXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsXG59XG5cbmZ1bmN0aW9uIG1hbGxvY0FycmF5QnVmZmVyKG4pIHtcbiAgdmFyIG4gPSBiaXRzLm5leHRQb3cyKG4pXG4gIHZhciBsb2dfbiA9IGJpdHMubG9nMihuKVxuICB2YXIgZCA9IERBVEFbbG9nX25dXG4gIGlmKGQubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBkLnBvcCgpXG4gIH1cbiAgcmV0dXJuIG5ldyBBcnJheUJ1ZmZlcihuKVxufVxuZXhwb3J0cy5tYWxsb2NBcnJheUJ1ZmZlciA9IG1hbGxvY0FycmF5QnVmZmVyXG5cbmZ1bmN0aW9uIG1hbGxvY1VpbnQ4KG4pIHtcbiAgcmV0dXJuIG5ldyBVaW50OEFycmF5KG1hbGxvY0FycmF5QnVmZmVyKG4pLCAwLCBuKVxufVxuZXhwb3J0cy5tYWxsb2NVaW50OCA9IG1hbGxvY1VpbnQ4XG5cbmZ1bmN0aW9uIG1hbGxvY1VpbnQxNihuKSB7XG4gIHJldHVybiBuZXcgVWludDE2QXJyYXkobWFsbG9jQXJyYXlCdWZmZXIoMipuKSwgMCwgbilcbn1cbmV4cG9ydHMubWFsbG9jVWludDE2ID0gbWFsbG9jVWludDE2XG5cbmZ1bmN0aW9uIG1hbGxvY1VpbnQzMihuKSB7XG4gIHJldHVybiBuZXcgVWludDMyQXJyYXkobWFsbG9jQXJyYXlCdWZmZXIoNCpuKSwgMCwgbilcbn1cbmV4cG9ydHMubWFsbG9jVWludDMyID0gbWFsbG9jVWludDMyXG5cbmZ1bmN0aW9uIG1hbGxvY0ludDgobikge1xuICByZXR1cm4gbmV3IEludDhBcnJheShtYWxsb2NBcnJheUJ1ZmZlcihuKSwgMCwgbilcbn1cbmV4cG9ydHMubWFsbG9jSW50OCA9IG1hbGxvY0ludDhcblxuZnVuY3Rpb24gbWFsbG9jSW50MTYobikge1xuICByZXR1cm4gbmV3IEludDE2QXJyYXkobWFsbG9jQXJyYXlCdWZmZXIoMipuKSwgMCwgbilcbn1cbmV4cG9ydHMubWFsbG9jSW50MTYgPSBtYWxsb2NJbnQxNlxuXG5mdW5jdGlvbiBtYWxsb2NJbnQzMihuKSB7XG4gIHJldHVybiBuZXcgSW50MzJBcnJheShtYWxsb2NBcnJheUJ1ZmZlcig0Km4pLCAwLCBuKVxufVxuZXhwb3J0cy5tYWxsb2NJbnQzMiA9IG1hbGxvY0ludDMyXG5cbmZ1bmN0aW9uIG1hbGxvY0Zsb2F0KG4pIHtcbiAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkobWFsbG9jQXJyYXlCdWZmZXIoNCpuKSwgMCwgbilcbn1cbmV4cG9ydHMubWFsbG9jRmxvYXQzMiA9IGV4cG9ydHMubWFsbG9jRmxvYXQgPSBtYWxsb2NGbG9hdFxuXG5mdW5jdGlvbiBtYWxsb2NEb3VibGUobikge1xuICByZXR1cm4gbmV3IEZsb2F0NjRBcnJheShtYWxsb2NBcnJheUJ1ZmZlcig4Km4pLCAwLCBuKVxufVxuZXhwb3J0cy5tYWxsb2NGbG9hdDY0ID0gZXhwb3J0cy5tYWxsb2NEb3VibGUgPSBtYWxsb2NEb3VibGVcblxuZnVuY3Rpb24gbWFsbG9jVWludDhDbGFtcGVkKG4pIHtcbiAgaWYoaGFzVWludDhDKSB7XG4gICAgcmV0dXJuIG5ldyBVaW50OENsYW1wZWRBcnJheShtYWxsb2NBcnJheUJ1ZmZlcihuKSwgMCwgbilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbWFsbG9jVWludDgobilcbiAgfVxufVxuZXhwb3J0cy5tYWxsb2NVaW50OENsYW1wZWQgPSBtYWxsb2NVaW50OENsYW1wZWRcblxuZnVuY3Rpb24gbWFsbG9jRGF0YVZpZXcobikge1xuICByZXR1cm4gbmV3IERhdGFWaWV3KG1hbGxvY0FycmF5QnVmZmVyKG4pLCAwLCBuKVxufVxuZXhwb3J0cy5tYWxsb2NEYXRhVmlldyA9IG1hbGxvY0RhdGFWaWV3XG5cbmZ1bmN0aW9uIG1hbGxvY0J1ZmZlcihuKSB7XG4gIG4gPSBiaXRzLm5leHRQb3cyKG4pXG4gIHZhciBsb2dfbiA9IGJpdHMubG9nMihuKVxuICB2YXIgY2FjaGUgPSBCVUZGRVJbbG9nX25dXG4gIGlmKGNhY2hlLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gY2FjaGUucG9wKClcbiAgfVxuICByZXR1cm4gbmV3IEJ1ZmZlcihuKVxufVxuZXhwb3J0cy5tYWxsb2NCdWZmZXIgPSBtYWxsb2NCdWZmZXJcblxuZXhwb3J0cy5jbGVhckNhY2hlID0gZnVuY3Rpb24gY2xlYXJDYWNoZSgpIHtcbiAgZm9yKHZhciBpPTA7IGk8MzI7ICsraSkge1xuICAgIFBPT0wuVUlOVDhbaV0ubGVuZ3RoID0gMFxuICAgIFBPT0wuVUlOVDE2W2ldLmxlbmd0aCA9IDBcbiAgICBQT09MLlVJTlQzMltpXS5sZW5ndGggPSAwXG4gICAgUE9PTC5JTlQ4W2ldLmxlbmd0aCA9IDBcbiAgICBQT09MLklOVDE2W2ldLmxlbmd0aCA9IDBcbiAgICBQT09MLklOVDMyW2ldLmxlbmd0aCA9IDBcbiAgICBQT09MLkZMT0FUW2ldLmxlbmd0aCA9IDBcbiAgICBQT09MLkRPVUJMRVtpXS5sZW5ndGggPSAwXG4gICAgUE9PTC5VSU5UOENbaV0ubGVuZ3RoID0gMFxuICAgIERBVEFbaV0ubGVuZ3RoID0gMFxuICAgIEJVRkZFUltpXS5sZW5ndGggPSAwXG4gIH1cbn1cbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyKSIsIi8qIChUaGUgTUlUIExpY2Vuc2UpXHJcbiAqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxMiBCcmFuZG9uIEJlbnZpZSA8aHR0cDovL2JiZW52aWUuY29tPlxyXG4gKlxyXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kXHJcbiAqIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlICdTb2Z0d2FyZScpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxyXG4gKiBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLFxyXG4gKiBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcclxuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcclxuICpcclxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgd2l0aCBhbGwgY29waWVzIG9yXHJcbiAqIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cclxuICpcclxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEICdBUyBJUycsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HXHJcbiAqIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxyXG4gKiBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZICBDTEFJTSxcclxuICogREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxyXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cclxuICovXHJcblxyXG4vLyBPcmlnaW5hbCBXZWFrTWFwIGltcGxlbWVudGF0aW9uIGJ5IEdvemFsYSBAIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tLzEyNjk5OTFcclxuLy8gVXBkYXRlZCBhbmQgYnVnZml4ZWQgYnkgUmF5bm9zIEAgaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vMTYzODA1OVxyXG4vLyBFeHBhbmRlZCBieSBCZW52aWUgQCBodHRwczovL2dpdGh1Yi5jb20vQmVudmllL2hhcm1vbnktY29sbGVjdGlvbnNcclxuXHJcbnZvaWQgZnVuY3Rpb24oZ2xvYmFsLCB1bmRlZmluZWRfLCB1bmRlZmluZWQpe1xyXG4gIHZhciBnZXRQcm9wcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzLFxyXG4gICAgICBkZWZQcm9wICA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSxcclxuICAgICAgdG9Tb3VyY2UgPSBGdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmcsXHJcbiAgICAgIGNyZWF0ZSAgID0gT2JqZWN0LmNyZWF0ZSxcclxuICAgICAgaGFzT3duICAgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LFxyXG4gICAgICBmdW5jTmFtZSA9IC9eXFxuP2Z1bmN0aW9uXFxzPyhcXHcqKT9fP1xcKC87XHJcblxyXG5cclxuICBmdW5jdGlvbiBkZWZpbmUob2JqZWN0LCBrZXksIHZhbHVlKXtcclxuICAgIGlmICh0eXBlb2Yga2V5ID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgIHZhbHVlID0ga2V5O1xyXG4gICAgICBrZXkgPSBuYW1lT2YodmFsdWUpLnJlcGxhY2UoL18kLywgJycpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRlZlByb3Aob2JqZWN0LCBrZXksIHsgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gbmFtZU9mKGZ1bmMpe1xyXG4gICAgcmV0dXJuIHR5cGVvZiBmdW5jICE9PSAnZnVuY3Rpb24nXHJcbiAgICAgICAgICA/ICcnIDogJ25hbWUnIGluIGZ1bmNcclxuICAgICAgICAgID8gZnVuYy5uYW1lIDogdG9Tb3VyY2UuY2FsbChmdW5jKS5tYXRjaChmdW5jTmFtZSlbMV07XHJcbiAgfVxyXG5cclxuICAvLyAjIyMjIyMjIyMjIyNcclxuICAvLyAjIyMgRGF0YSAjIyNcclxuICAvLyAjIyMjIyMjIyMjIyNcclxuXHJcbiAgdmFyIERhdGEgPSAoZnVuY3Rpb24oKXtcclxuICAgIHZhciBkYXRhRGVzYyA9IHsgdmFsdWU6IHsgd3JpdGFibGU6IHRydWUsIHZhbHVlOiB1bmRlZmluZWQgfSB9LFxyXG4gICAgICAgIGRhdGFsb2NrID0gJ3JldHVybiBmdW5jdGlvbihrKXtpZihrPT09cylyZXR1cm4gbH0nLFxyXG4gICAgICAgIHVpZHMgICAgID0gY3JlYXRlKG51bGwpLFxyXG5cclxuICAgICAgICBjcmVhdGVVSUQgPSBmdW5jdGlvbigpe1xyXG4gICAgICAgICAgdmFyIGtleSA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIpO1xyXG4gICAgICAgICAgcmV0dXJuIGtleSBpbiB1aWRzID8gY3JlYXRlVUlEKCkgOiB1aWRzW2tleV0gPSBrZXk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgZ2xvYmFsSUQgPSBjcmVhdGVVSUQoKSxcclxuXHJcbiAgICAgICAgc3RvcmFnZSA9IGZ1bmN0aW9uKG9iail7XHJcbiAgICAgICAgICBpZiAoaGFzT3duLmNhbGwob2JqLCBnbG9iYWxJRCkpXHJcbiAgICAgICAgICAgIHJldHVybiBvYmpbZ2xvYmFsSURdO1xyXG5cclxuICAgICAgICAgIGlmICghT2JqZWN0LmlzRXh0ZW5zaWJsZShvYmopKVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiT2JqZWN0IG11c3QgYmUgZXh0ZW5zaWJsZVwiKTtcclxuXHJcbiAgICAgICAgICB2YXIgc3RvcmUgPSBjcmVhdGUobnVsbCk7XHJcbiAgICAgICAgICBkZWZQcm9wKG9iaiwgZ2xvYmFsSUQsIHsgdmFsdWU6IHN0b3JlIH0pO1xyXG4gICAgICAgICAgcmV0dXJuIHN0b3JlO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgLy8gY29tbW9uIHBlci1vYmplY3Qgc3RvcmFnZSBhcmVhIG1hZGUgdmlzaWJsZSBieSBwYXRjaGluZyBnZXRPd25Qcm9wZXJ0eU5hbWVzJ1xyXG4gICAgZGVmaW5lKE9iamVjdCwgZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhvYmope1xyXG4gICAgICB2YXIgcHJvcHMgPSBnZXRQcm9wcyhvYmopO1xyXG4gICAgICBpZiAoaGFzT3duLmNhbGwob2JqLCBnbG9iYWxJRCkpXHJcbiAgICAgICAgcHJvcHMuc3BsaWNlKHByb3BzLmluZGV4T2YoZ2xvYmFsSUQpLCAxKTtcclxuICAgICAgcmV0dXJuIHByb3BzO1xyXG4gICAgfSk7XHJcblxyXG4gICAgZnVuY3Rpb24gRGF0YSgpe1xyXG4gICAgICB2YXIgcHVpZCA9IGNyZWF0ZVVJRCgpLFxyXG4gICAgICAgICAgc2VjcmV0ID0ge307XHJcblxyXG4gICAgICB0aGlzLnVubG9jayA9IGZ1bmN0aW9uKG9iail7XHJcbiAgICAgICAgdmFyIHN0b3JlID0gc3RvcmFnZShvYmopO1xyXG4gICAgICAgIGlmIChoYXNPd24uY2FsbChzdG9yZSwgcHVpZCkpXHJcbiAgICAgICAgICByZXR1cm4gc3RvcmVbcHVpZF0oc2VjcmV0KTtcclxuXHJcbiAgICAgICAgdmFyIGRhdGEgPSBjcmVhdGUobnVsbCwgZGF0YURlc2MpO1xyXG4gICAgICAgIGRlZlByb3Aoc3RvcmUsIHB1aWQsIHtcclxuICAgICAgICAgIHZhbHVlOiBuZXcgRnVuY3Rpb24oJ3MnLCAnbCcsIGRhdGFsb2NrKShzZWNyZXQsIGRhdGEpXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBkZWZpbmUoRGF0YS5wcm90b3R5cGUsIGZ1bmN0aW9uIGdldChvKXsgcmV0dXJuIHRoaXMudW5sb2NrKG8pLnZhbHVlIH0pO1xyXG4gICAgZGVmaW5lKERhdGEucHJvdG90eXBlLCBmdW5jdGlvbiBzZXQobywgdil7IHRoaXMudW5sb2NrKG8pLnZhbHVlID0gdiB9KTtcclxuXHJcbiAgICByZXR1cm4gRGF0YTtcclxuICB9KCkpO1xyXG5cclxuXHJcbiAgdmFyIFdNID0gKGZ1bmN0aW9uKGRhdGEpe1xyXG4gICAgdmFyIHZhbGlkYXRlID0gZnVuY3Rpb24oa2V5KXtcclxuICAgICAgaWYgKGtleSA9PSBudWxsIHx8IHR5cGVvZiBrZXkgIT09ICdvYmplY3QnICYmIHR5cGVvZiBrZXkgIT09ICdmdW5jdGlvbicpXHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgV2Vha01hcCBrZXlcIik7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHdyYXAgPSBmdW5jdGlvbihjb2xsZWN0aW9uLCB2YWx1ZSl7XHJcbiAgICAgIHZhciBzdG9yZSA9IGRhdGEudW5sb2NrKGNvbGxlY3Rpb24pO1xyXG4gICAgICBpZiAoc3RvcmUudmFsdWUpXHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk9iamVjdCBpcyBhbHJlYWR5IGEgV2Vha01hcFwiKTtcclxuICAgICAgc3RvcmUudmFsdWUgPSB2YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgdW53cmFwID0gZnVuY3Rpb24oY29sbGVjdGlvbil7XHJcbiAgICAgIHZhciBzdG9yYWdlID0gZGF0YS51bmxvY2soY29sbGVjdGlvbikudmFsdWU7XHJcbiAgICAgIGlmICghc3RvcmFnZSlcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiV2Vha01hcCBpcyBub3QgZ2VuZXJpY1wiKTtcclxuICAgICAgcmV0dXJuIHN0b3JhZ2U7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGluaXRpYWxpemUgPSBmdW5jdGlvbih3ZWFrbWFwLCBpdGVyYWJsZSl7XHJcbiAgICAgIGlmIChpdGVyYWJsZSAhPT0gbnVsbCAmJiB0eXBlb2YgaXRlcmFibGUgPT09ICdvYmplY3QnICYmIHR5cGVvZiBpdGVyYWJsZS5mb3JFYWNoID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgaXRlcmFibGUuZm9yRWFjaChmdW5jdGlvbihpdGVtLCBpKXtcclxuICAgICAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgQXJyYXkgJiYgaXRlbS5sZW5ndGggPT09IDIpXHJcbiAgICAgICAgICAgIHNldC5jYWxsKHdlYWttYXAsIGl0ZXJhYmxlW2ldWzBdLCBpdGVyYWJsZVtpXVsxXSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcblxyXG4gICAgZnVuY3Rpb24gV2Vha01hcChpdGVyYWJsZSl7XHJcbiAgICAgIGlmICh0aGlzID09PSBnbG9iYWwgfHwgdGhpcyA9PSBudWxsIHx8IHRoaXMgPT09IFdlYWtNYXAucHJvdG90eXBlKVxyXG4gICAgICAgIHJldHVybiBuZXcgV2Vha01hcChpdGVyYWJsZSk7XHJcblxyXG4gICAgICB3cmFwKHRoaXMsIG5ldyBEYXRhKTtcclxuICAgICAgaW5pdGlhbGl6ZSh0aGlzLCBpdGVyYWJsZSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0KGtleSl7XHJcbiAgICAgIHZhbGlkYXRlKGtleSk7XHJcbiAgICAgIHZhciB2YWx1ZSA9IHVud3JhcCh0aGlzKS5nZXQoa2V5KTtcclxuICAgICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWRfID8gdW5kZWZpbmVkIDogdmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpe1xyXG4gICAgICB2YWxpZGF0ZShrZXkpO1xyXG4gICAgICAvLyBzdG9yZSBhIHRva2VuIGZvciBleHBsaWNpdCB1bmRlZmluZWQgc28gdGhhdCBcImhhc1wiIHdvcmtzIGNvcnJlY3RseVxyXG4gICAgICB1bndyYXAodGhpcykuc2V0KGtleSwgdmFsdWUgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZF8gOiB2YWx1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaGFzKGtleSl7XHJcbiAgICAgIHZhbGlkYXRlKGtleSk7XHJcbiAgICAgIHJldHVybiB1bndyYXAodGhpcykuZ2V0KGtleSkgIT09IHVuZGVmaW5lZDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBkZWxldGVfKGtleSl7XHJcbiAgICAgIHZhbGlkYXRlKGtleSk7XHJcbiAgICAgIHZhciBkYXRhID0gdW53cmFwKHRoaXMpLFxyXG4gICAgICAgICAgaGFkID0gZGF0YS5nZXQoa2V5KSAhPT0gdW5kZWZpbmVkO1xyXG4gICAgICBkYXRhLnNldChrZXksIHVuZGVmaW5lZCk7XHJcbiAgICAgIHJldHVybiBoYWQ7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gdG9TdHJpbmcoKXtcclxuICAgICAgdW53cmFwKHRoaXMpO1xyXG4gICAgICByZXR1cm4gJ1tvYmplY3QgV2Vha01hcF0nO1xyXG4gICAgfVxyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgIHZhciBzcmMgPSAoJ3JldHVybiAnK2RlbGV0ZV8pLnJlcGxhY2UoJ2VfJywgJ1xcXFx1MDA2NScpLFxyXG4gICAgICAgICAgZGVsID0gbmV3IEZ1bmN0aW9uKCd1bndyYXAnLCAndmFsaWRhdGUnLCBzcmMpKHVud3JhcCwgdmFsaWRhdGUpO1xyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICB2YXIgZGVsID0gZGVsZXRlXztcclxuICAgIH1cclxuXHJcbiAgICB2YXIgc3JjID0gKCcnK09iamVjdCkuc3BsaXQoJ09iamVjdCcpO1xyXG4gICAgdmFyIHN0cmluZ2lmaWVyID0gZnVuY3Rpb24gdG9TdHJpbmcoKXtcclxuICAgICAgcmV0dXJuIHNyY1swXSArIG5hbWVPZih0aGlzKSArIHNyY1sxXTtcclxuICAgIH07XHJcblxyXG4gICAgZGVmaW5lKHN0cmluZ2lmaWVyLCBzdHJpbmdpZmllcik7XHJcblxyXG4gICAgdmFyIHByZXAgPSB7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5XHJcbiAgICAgID8gZnVuY3Rpb24oZil7IGYuX19wcm90b19fID0gc3RyaW5naWZpZXIgfVxyXG4gICAgICA6IGZ1bmN0aW9uKGYpeyBkZWZpbmUoZiwgc3RyaW5naWZpZXIpIH07XHJcblxyXG4gICAgcHJlcChXZWFrTWFwKTtcclxuXHJcbiAgICBbdG9TdHJpbmcsIGdldCwgc2V0LCBoYXMsIGRlbF0uZm9yRWFjaChmdW5jdGlvbihtZXRob2Qpe1xyXG4gICAgICBkZWZpbmUoV2Vha01hcC5wcm90b3R5cGUsIG1ldGhvZCk7XHJcbiAgICAgIHByZXAobWV0aG9kKTtcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiBXZWFrTWFwO1xyXG4gIH0obmV3IERhdGEpKTtcclxuXHJcbiAgdmFyIGRlZmF1bHRDcmVhdG9yID0gT2JqZWN0LmNyZWF0ZVxyXG4gICAgPyBmdW5jdGlvbigpeyByZXR1cm4gT2JqZWN0LmNyZWF0ZShudWxsKSB9XHJcbiAgICA6IGZ1bmN0aW9uKCl7IHJldHVybiB7fSB9O1xyXG5cclxuICBmdW5jdGlvbiBjcmVhdGVTdG9yYWdlKGNyZWF0b3Ipe1xyXG4gICAgdmFyIHdlYWttYXAgPSBuZXcgV007XHJcbiAgICBjcmVhdG9yIHx8IChjcmVhdG9yID0gZGVmYXVsdENyZWF0b3IpO1xyXG5cclxuICAgIGZ1bmN0aW9uIHN0b3JhZ2Uob2JqZWN0LCB2YWx1ZSl7XHJcbiAgICAgIGlmICh2YWx1ZSB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XHJcbiAgICAgICAgd2Vha21hcC5zZXQob2JqZWN0LCB2YWx1ZSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdmFsdWUgPSB3ZWFrbWFwLmdldChvYmplY3QpO1xyXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICB2YWx1ZSA9IGNyZWF0b3Iob2JqZWN0KTtcclxuICAgICAgICAgIHdlYWttYXAuc2V0KG9iamVjdCwgdmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHN0b3JhZ2U7XHJcbiAgfVxyXG5cclxuXHJcbiAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IFdNO1xyXG4gIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICBleHBvcnRzLldlYWtNYXAgPSBXTTtcclxuICB9IGVsc2UgaWYgKCEoJ1dlYWtNYXAnIGluIGdsb2JhbCkpIHtcclxuICAgIGdsb2JhbC5XZWFrTWFwID0gV007XHJcbiAgfVxyXG5cclxuICBXTS5jcmVhdGVTdG9yYWdlID0gY3JlYXRlU3RvcmFnZTtcclxuICBpZiAoZ2xvYmFsLldlYWtNYXApXHJcbiAgICBnbG9iYWwuV2Vha01hcC5jcmVhdGVTdG9yYWdlID0gY3JlYXRlU3RvcmFnZTtcclxufSgoMCwgZXZhbCkoJ3RoaXMnKSk7XHJcbiIsIid1c2Ugc3RyaWN0J1xuXG52YXIgd2Vha01hcCA9IHR5cGVvZiBXZWFrTWFwID09PSAndW5kZWZpbmVkJyA/IHJlcXVpcmUoJ3dlYWttYXAnKSA6IFdlYWtNYXBcblxudmFyIFdlYkdMRVdTdHJ1Y3QgPSBuZXcgd2Vha01hcCgpXG5cbmZ1bmN0aW9uIGJhc2VOYW1lKGV4dF9uYW1lKSB7XG4gIHJldHVybiBleHRfbmFtZS5yZXBsYWNlKC9eW0EtWl0rXy8sICcnKVxufVxuXG5mdW5jdGlvbiBpbml0V2ViR0xFVyhnbCkge1xuICB2YXIgc3RydWN0ID0gV2ViR0xFV1N0cnVjdC5nZXQoZ2wpXG4gIGlmKHN0cnVjdCkge1xuICAgIHJldHVybiBzdHJ1Y3RcbiAgfVxuICB2YXIgZXh0ZW5zaW9ucyA9IHt9XG4gIHZhciBzdXBwb3J0ZWQgPSBnbC5nZXRTdXBwb3J0ZWRFeHRlbnNpb25zKClcbiAgZm9yKHZhciBpPTA7IGk8c3VwcG9ydGVkLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGV4dE5hbWUgPSBzdXBwb3J0ZWRbaV1cblxuICAgIC8vU2tpcCBNT1pfIGV4dGVuc2lvbnNcbiAgICBpZihleHROYW1lLmluZGV4T2YoJ01PWl8nKSA9PT0gMCkge1xuICAgICAgY29udGludWVcbiAgICB9XG4gICAgdmFyIGV4dCA9IGdsLmdldEV4dGVuc2lvbihzdXBwb3J0ZWRbaV0pXG4gICAgaWYoIWV4dCkge1xuICAgICAgY29udGludWVcbiAgICB9XG4gICAgd2hpbGUodHJ1ZSkge1xuICAgICAgZXh0ZW5zaW9uc1tleHROYW1lXSA9IGV4dFxuICAgICAgdmFyIGJhc2UgPSBiYXNlTmFtZShleHROYW1lKVxuICAgICAgaWYoYmFzZSA9PT0gZXh0TmFtZSkge1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgZXh0TmFtZSA9IGJhc2VcbiAgICB9XG4gIH1cbiAgV2ViR0xFV1N0cnVjdC5zZXQoZ2wsIGV4dGVuc2lvbnMpXG4gIHJldHVybiBleHRlbnNpb25zXG59XG5tb2R1bGUuZXhwb3J0cyA9IGluaXRXZWJHTEVXIiwiJ3VzZSBzdHJpY3QnXG5cbnZhciBuZGFycmF5ID0gcmVxdWlyZSgnbmRhcnJheScpXG52YXIgb3BzICAgICA9IHJlcXVpcmUoJ25kYXJyYXktb3BzJylcbnZhciBwb29sICAgID0gcmVxdWlyZSgndHlwZWRhcnJheS1wb29sJylcbnZhciB3ZWJnbGV3ID0gcmVxdWlyZSgnd2ViZ2xldycpXG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlVGV4dHVyZTJEXG5cbnZhciBsaW5lYXJUeXBlcyA9IG51bGxcbnZhciBmaWx0ZXJUeXBlcyA9IG51bGxcbnZhciB3cmFwVHlwZXMgICA9IG51bGxcblxuZnVuY3Rpb24gbGF6eUluaXRMaW5lYXJUeXBlcyhnbCkge1xuICBsaW5lYXJUeXBlcyA9IFtcbiAgICBnbC5MSU5FQVIsXG4gICAgZ2wuTkVBUkVTVF9NSVBNQVBfTElORUFSLFxuICAgIGdsLkxJTkVBUl9NSVBNQVBfTkVBUkVTVCxcbiAgICBnbC5MSU5FQVJfTUlQTUFQX05FQVJFU1RcbiAgXVxuICBmaWx0ZXJUeXBlcyA9IFtcbiAgICBnbC5ORUFSRVNULFxuICAgIGdsLkxJTkVBUixcbiAgICBnbC5ORUFSRVNUX01JUE1BUF9ORUFSRVNULFxuICAgIGdsLk5FQVJFU1RfTUlQTUFQX0xJTkVBUixcbiAgICBnbC5MSU5FQVJfTUlQTUFQX05FQVJFU1QsXG4gICAgZ2wuTElORUFSX01JUE1BUF9MSU5FQVJcbiAgXVxuICB3cmFwVHlwZXMgPSBbXG4gICAgZ2wuUkVQRUFULFxuICAgIGdsLkNMQU1QX1RPX0VER0UsXG4gICAgZ2wuTUlSUk9SRURfUkVQRUFUXG4gIF1cbn1cblxudmFyIGNvbnZlcnRGbG9hdFRvVWludDggPSBmdW5jdGlvbihvdXQsIGlucCkge1xuICBvcHMubXVscyhvdXQsIGlucCwgMjU1LjApXG59XG5cbmZ1bmN0aW9uIHJlc2hhcGVUZXh0dXJlKHRleCwgdywgaCkge1xuICB2YXIgZ2wgPSB0ZXguZ2xcbiAgdmFyIG1heFNpemUgPSBnbC5nZXRQYXJhbWV0ZXIoZ2wuTUFYX1RFWFRVUkVfU0laRSlcbiAgaWYodyA8IDAgfHwgdyA+IG1heFNpemUgfHwgaCA8IDAgfHwgaCA+IG1heFNpemUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2dsLXRleHR1cmUyZDogSW52YWxpZCB0ZXh0dXJlIHNpemUnKVxuICB9XG4gIHRleC5fc2hhcGUgPSBbdywgaF1cbiAgdGV4LmJpbmQoKVxuICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIHRleC5mb3JtYXQsIHcsIGgsIDAsIHRleC5mb3JtYXQsIHRleC50eXBlLCBudWxsKVxuICB0ZXguX21pcExldmVscyA9IFswXVxuICByZXR1cm4gdGV4XG59XG5cbmZ1bmN0aW9uIFRleHR1cmUyRChnbCwgaGFuZGxlLCB3aWR0aCwgaGVpZ2h0LCBmb3JtYXQsIHR5cGUpIHtcbiAgdGhpcy5nbCA9IGdsXG4gIHRoaXMuaGFuZGxlID0gaGFuZGxlXG4gIHRoaXMuZm9ybWF0ID0gZm9ybWF0XG4gIHRoaXMudHlwZSA9IHR5cGVcbiAgdGhpcy5fc2hhcGUgPSBbd2lkdGgsIGhlaWdodF1cbiAgdGhpcy5fbWlwTGV2ZWxzID0gWzBdXG4gIHRoaXMuX21hZ0ZpbHRlciA9IGdsLk5FQVJFU1RcbiAgdGhpcy5fbWluRmlsdGVyID0gZ2wuTkVBUkVTVFxuICB0aGlzLl93cmFwUyA9IGdsLkNMQU1QX1RPX0VER0VcbiAgdGhpcy5fd3JhcFQgPSBnbC5DTEFNUF9UT19FREdFXG4gIHRoaXMuX2FuaXNvU2FtcGxlcyA9IDFcblxuICB2YXIgcGFyZW50ID0gdGhpc1xuICB2YXIgd3JhcFZlY3RvciA9IFt0aGlzLl93cmFwUywgdGhpcy5fd3JhcFRdXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHdyYXBWZWN0b3IsIFtcbiAgICB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gcGFyZW50Ll93cmFwU1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24odikge1xuICAgICAgICByZXR1cm4gcGFyZW50LndyYXBTID0gdlxuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHBhcmVudC5fd3JhcFRcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgcmV0dXJuIHBhcmVudC53cmFwVCA9IHZcbiAgICAgIH1cbiAgICB9XG4gIF0pXG4gIHRoaXMuX3dyYXBWZWN0b3IgPSB3cmFwVmVjdG9yXG5cbiAgdmFyIHNoYXBlVmVjdG9yID0gW3RoaXMuX3NoYXBlWzBdLCB0aGlzLl9zaGFwZVsxXV1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoc2hhcGVWZWN0b3IsIFtcbiAgICB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gcGFyZW50Ll9zaGFwZVswXVxuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24odikge1xuICAgICAgICByZXR1cm4gcGFyZW50LndpZHRoID0gdlxuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHBhcmVudC5fc2hhcGVbMV1cbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgcmV0dXJuIHBhcmVudC5oZWlnaHQgPSB2XG4gICAgICB9XG4gICAgfVxuICBdKVxuICB0aGlzLl9zaGFwZVZlY3RvciA9IHNoYXBlVmVjdG9yXG59XG5cbnZhciBwcm90byA9IFRleHR1cmUyRC5wcm90b3R5cGVcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMocHJvdG8sIHtcbiAgbWluRmlsdGVyOiB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9taW5GaWx0ZXJcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24odikge1xuICAgICAgdGhpcy5iaW5kKClcbiAgICAgIHZhciBnbCA9IHRoaXMuZ2xcbiAgICAgIGlmKHRoaXMudHlwZSA9PT0gZ2wuRkxPQVQgJiYgbGluZWFyVHlwZXMuaW5kZXhPZih2KSA+PSAwKSB7XG4gICAgICAgIGlmKCF3ZWJnbGV3KGdsKS50ZXh0dXJlX2Zsb2F0X2xpbmVhcikge1xuICAgICAgICAgIHYgPSBnbC5ORUFSRVNUXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmKGZpbHRlclR5cGVzLmluZGV4T2YodikgPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZ2wtdGV4dHVyZTJkOiBVbmtub3duIGZpbHRlciBtb2RlICcgKyB2KVxuICAgICAgfVxuICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIHYpXG4gICAgICByZXR1cm4gdGhpcy5fbWluRmlsdGVyID0gdlxuICAgIH1cbiAgfSxcbiAgbWFnRmlsdGVyOiB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9tYWdGaWx0ZXJcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24odikge1xuICAgICAgdGhpcy5iaW5kKClcbiAgICAgIHZhciBnbCA9IHRoaXMuZ2xcbiAgICAgIGlmKHRoaXMudHlwZSA9PT0gZ2wuRkxPQVQgJiYgbGluZWFyVHlwZXMuaW5kZXhPZih2KSA+PSAwKSB7XG4gICAgICAgIGlmKCF3ZWJnbGV3KGdsKS50ZXh0dXJlX2Zsb2F0X2xpbmVhcikge1xuICAgICAgICAgIHYgPSBnbC5ORUFSRVNUXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmKGZpbHRlclR5cGVzLmluZGV4T2YodikgPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZ2wtdGV4dHVyZTJkOiBVbmtub3duIGZpbHRlciBtb2RlICcgKyB2KVxuICAgICAgfVxuICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIHYpXG4gICAgICByZXR1cm4gdGhpcy5fbWFnRmlsdGVyID0gdlxuICAgIH1cbiAgfSxcbiAgbWlwU2FtcGxlczoge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYW5pc29TYW1wbGVzXG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKGkpIHtcbiAgICAgIHZhciBwc2FtcGxlcyA9IHRoaXMuX2FuaXNvU2FtcGxlc1xuICAgICAgdGhpcy5fYW5pc29TYW1wbGVzID0gTWF0aC5tYXgoaSwgMSl8MFxuICAgICAgaWYocHNhbXBsZXMgIT09IHRoaXMuX2FuaXNvU2FtcGxlcykge1xuICAgICAgICB2YXIgZXh0ID0gd2ViZ2xldyh0aGlzLmdsKS5FWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWNcbiAgICAgICAgaWYoZXh0KSB7XG4gICAgICAgICAgdGhpcy5nbC50ZXhQYXJhbWV0ZXJmKHRoaXMuZ2wuVEVYVFVSRV8yRCwgZXh0LlRFWFRVUkVfTUFYX0FOSVNPVFJPUFlfRVhULCB0aGlzLl9hbmlzb1NhbXBsZXMpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9hbmlzb1NhbXBsZXNcbiAgICB9XG4gIH0sXG4gIHdyYXBTOiB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl93cmFwU1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbih2KSB7XG4gICAgICB0aGlzLmJpbmQoKVxuICAgICAgaWYod3JhcFR5cGVzLmluZGV4T2YodikgPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZ2wtdGV4dHVyZTJkOiBVbmtub3duIHdyYXAgbW9kZSAnICsgdilcbiAgICAgIH1cbiAgICAgIHRoaXMuZ2wudGV4UGFyYW1ldGVyaSh0aGlzLmdsLlRFWFRVUkVfMkQsIHRoaXMuZ2wuVEVYVFVSRV9XUkFQX1MsIHYpXG4gICAgICByZXR1cm4gdGhpcy5fd3JhcFMgPSB2XG4gICAgfVxuICB9LFxuICB3cmFwVDoge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fd3JhcFRcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24odikge1xuICAgICAgdGhpcy5iaW5kKClcbiAgICAgIGlmKHdyYXBUeXBlcy5pbmRleE9mKHYpIDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dsLXRleHR1cmUyZDogVW5rbm93biB3cmFwIG1vZGUgJyArIHYpXG4gICAgICB9XG4gICAgICB0aGlzLmdsLnRleFBhcmFtZXRlcmkodGhpcy5nbC5URVhUVVJFXzJELCB0aGlzLmdsLlRFWFRVUkVfV1JBUF9ULCB2KVxuICAgICAgcmV0dXJuIHRoaXMuX3dyYXBUID0gdlxuICAgIH1cbiAgfSxcbiAgd3JhcDoge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fd3JhcFZlY3RvclxuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbih2KSB7XG4gICAgICBpZighQXJyYXkuaXNBcnJheSh2KSkge1xuICAgICAgICB2ID0gW3Ysdl1cbiAgICAgIH1cbiAgICAgIGlmKHYubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZ2wtdGV4dHVyZTJkOiBNdXN0IHNwZWNpZnkgd3JhcCBtb2RlIGZvciByb3dzIGFuZCBjb2x1bW5zJylcbiAgICAgIH1cbiAgICAgIGZvcih2YXIgaT0wOyBpPDI7ICsraSkge1xuICAgICAgICBpZih3cmFwVHlwZXMuaW5kZXhPZih2W2ldKSA8IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dsLXRleHR1cmUyZDogVW5rbm93biB3cmFwIG1vZGUgJyArIHYpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuX3dyYXBTID0gdlswXVxuICAgICAgdGhpcy5fd3JhcFQgPSB2WzFdXG5cbiAgICAgIHZhciBnbCA9IHRoaXMuZ2xcbiAgICAgIHRoaXMuYmluZCgpXG4gICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCB0aGlzLl93cmFwUylcbiAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIHRoaXMuX3dyYXBUKVxuXG4gICAgICByZXR1cm4gdlxuICAgIH1cbiAgfSxcbiAgc2hhcGU6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3NoYXBlVmVjdG9yXG4gICAgfSwgXG4gICAgc2V0OiBmdW5jdGlvbih4KSB7XG4gICAgICBpZighQXJyYXkuaXNBcnJheSh4KSkge1xuICAgICAgICB4ID0gW3h8MCx4fDBdXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZih4Lmxlbmd0aCAhPT0gMikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZ2wtdGV4dHVyZTJkOiBJbnZhbGlkIHRleHR1cmUgc2hhcGUnKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXNoYXBlVGV4dHVyZSh0aGlzLCB4WzBdfDAsIHhbMV18MClcbiAgICAgIHJldHVybiBbeFswXXwwLCB4WzFdfDBdXG4gICAgfVxuICB9LFxuICB3aWR0aDoge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc2hhcGVbMF1cbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24odykge1xuICAgICAgdyA9IHd8MFxuICAgICAgcmVzaGFwZVRleHR1cmUodGhpcywgdywgdGhpcy5fc2hhcGVbMV0pXG4gICAgICByZXR1cm4gd1xuICAgIH1cbiAgfSxcbiAgaGVpZ2h0OiB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zaGFwZVsxXVxuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbihoKSB7XG4gICAgICBoID0gaHwwXG4gICAgICByZXNoYXBlVGV4dHVyZSh0aGlzLCB0aGlzLl9zaGFwZVswXSwgaClcbiAgICAgIHJldHVybiBoXG4gICAgfVxuICB9XG59KVxuXG5wcm90by5iaW5kID0gZnVuY3Rpb24odW5pdCkge1xuICB2YXIgZ2wgPSB0aGlzLmdsXG4gIGlmKHVuaXQgIT09IHVuZGVmaW5lZCkge1xuICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTAgKyAodW5pdHwwKSlcbiAgfVxuICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLmhhbmRsZSlcbiAgaWYodW5pdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuICh1bml0fDApXG4gIH1cbiAgcmV0dXJuIGdsLmdldFBhcmFtZXRlcihnbC5BQ1RJVkVfVEVYVFVSRSkgLSBnbC5URVhUVVJFMFxufVxuXG5wcm90by5kaXNwb3NlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZ2wuZGVsZXRlVGV4dHVyZSh0aGlzLmhhbmRsZSlcbn1cblxucHJvdG8uZ2VuZXJhdGVNaXBtYXAgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5iaW5kKClcbiAgdGhpcy5nbC5nZW5lcmF0ZU1pcG1hcCh0aGlzLmdsLlRFWFRVUkVfMkQpXG4gIFxuICAvL1VwZGF0ZSBtaXAgbGV2ZWxzXG4gIHZhciBsID0gTWF0aC5taW4odGhpcy5fc2hhcGVbMF0sIHRoaXMuX3NoYXBlWzFdKVxuICBmb3IodmFyIGk9MDsgbD4wOyArK2ksIGw+Pj49MSkge1xuICAgIGlmKHRoaXMuX21pcExldmVscy5pbmRleE9mKGkpIDwgMCkge1xuICAgICAgdGhpcy5fbWlwTGV2ZWxzLnB1c2goaSlcbiAgICB9XG4gIH1cbn1cblxucHJvdG8uc2V0UGl4ZWxzID0gZnVuY3Rpb24oZGF0YSwgeF9vZmYsIHlfb2ZmLCBtaXBfbGV2ZWwpIHtcbiAgdmFyIGdsID0gdGhpcy5nbFxuICB0aGlzLmJpbmQoKVxuICBpZihBcnJheS5pc0FycmF5KHhfb2ZmKSkge1xuICAgIG1pcF9sZXZlbCA9IHlfb2ZmXG4gICAgeV9vZmYgPSB4X29mZlsxXXwwXG4gICAgeF9vZmYgPSB4X29mZlswXXwwXG4gIH0gZWxzZSB7XG4gICAgeF9vZmYgPSB4X29mZiB8fCAwXG4gICAgeV9vZmYgPSB5X29mZiB8fCAwXG4gIH1cbiAgbWlwX2xldmVsID0gbWlwX2xldmVsIHx8IDBcbiAgaWYoZGF0YSBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50IHx8XG4gICAgIGRhdGEgaW5zdGFuY2VvZiBJbWFnZURhdGEgfHxcbiAgICAgZGF0YSBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQgfHxcbiAgICAgZGF0YSBpbnN0YW5jZW9mIEhUTUxWaWRlb0VsZW1lbnQpIHtcbiAgICB2YXIgbmVlZHNNaXAgPSB0aGlzLl9taXBMZXZlbHMuaW5kZXhPZihtaXBfbGV2ZWwpIDwgMFxuICAgIGlmKG5lZWRzTWlwKSB7XG4gICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIHRoaXMuZm9ybWF0LCB0aGlzLmZvcm1hdCwgdGhpcy50eXBlLCBkYXRhKVxuICAgICAgdGhpcy5fbWlwTGV2ZWxzLnB1c2gobWlwX2xldmVsKVxuICAgIH0gZWxzZSB7XG4gICAgICBnbC50ZXhTdWJJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIG1pcF9sZXZlbCwgeF9vZmYsIHlfb2ZmLCB0aGlzLmZvcm1hdCwgdGhpcy50eXBlLCBkYXRhKVxuICAgIH1cbiAgfSBlbHNlIGlmKGRhdGEuc2hhcGUgJiYgZGF0YS5zdHJpZGUgJiYgZGF0YS5kYXRhKSB7XG4gICAgaWYoZGF0YS5zaGFwZS5sZW5ndGggPCAyIHx8XG4gICAgICAgeF9vZmYgKyBkYXRhLnNoYXBlWzFdID4gdGhpcy5fc2hhcGVbMV0+Pj5taXBfbGV2ZWwgfHxcbiAgICAgICB5X29mZiArIGRhdGEuc2hhcGVbMF0gPiB0aGlzLl9zaGFwZVswXT4+Pm1pcF9sZXZlbCB8fFxuICAgICAgIHhfb2ZmIDwgMCB8fFxuICAgICAgIHlfb2ZmIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdnbC10ZXh0dXJlMmQ6IFRleHR1cmUgZGltZW5zaW9ucyBhcmUgb3V0IG9mIGJvdW5kcycpXG4gICAgfVxuICAgIHRleFN1YkltYWdlQXJyYXkoZ2wsIHhfb2ZmLCB5X29mZiwgbWlwX2xldmVsLCB0aGlzLmZvcm1hdCwgdGhpcy50eXBlLCB0aGlzLl9taXBMZXZlbHMsIGRhdGEpXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdnbC10ZXh0dXJlMmQ6IFVuc3VwcG9ydGVkIGRhdGEgdHlwZScpXG4gIH1cbn1cblxuXG5mdW5jdGlvbiBpc1BhY2tlZChzaGFwZSwgc3RyaWRlKSB7XG4gIGlmKHNoYXBlLmxlbmd0aCA9PT0gMykge1xuICAgIHJldHVybiAgKHN0cmlkZVsyXSA9PT0gMSkgJiYgXG4gICAgICAgICAgICAoc3RyaWRlWzFdID09PSBzaGFwZVswXSpzaGFwZVsyXSkgJiZcbiAgICAgICAgICAgIChzdHJpZGVbMF0gPT09IHNoYXBlWzJdKVxuICB9XG4gIHJldHVybiAgKHN0cmlkZVswXSA9PT0gMSkgJiYgXG4gICAgICAgICAgKHN0cmlkZVsxXSA9PT0gc2hhcGVbMF0pXG59XG5cbmZ1bmN0aW9uIHRleFN1YkltYWdlQXJyYXkoZ2wsIHhfb2ZmLCB5X29mZiwgbWlwX2xldmVsLCBjZm9ybWF0LCBjdHlwZSwgbWlwTGV2ZWxzLCBhcnJheSkge1xuICB2YXIgZHR5cGUgPSBhcnJheS5kdHlwZVxuICB2YXIgc2hhcGUgPSBhcnJheS5zaGFwZS5zbGljZSgpXG4gIGlmKHNoYXBlLmxlbmd0aCA8IDIgfHwgc2hhcGUubGVuZ3RoID4gMykge1xuICAgIHRocm93IG5ldyBFcnJvcignZ2wtdGV4dHVyZTJkOiBJbnZhbGlkIG5kYXJyYXksIG11c3QgYmUgMmQgb3IgM2QnKVxuICB9XG4gIHZhciB0eXBlID0gMCwgZm9ybWF0ID0gMFxuICB2YXIgcGFja2VkID0gaXNQYWNrZWQoc2hhcGUsIGFycmF5LnN0cmlkZS5zbGljZSgpKVxuICBpZihkdHlwZSA9PT0gJ2Zsb2F0MzInKSB7XG4gICAgdHlwZSA9IGdsLkZMT0FUXG4gIH0gZWxzZSBpZihkdHlwZSA9PT0gJ2Zsb2F0NjQnKSB7XG4gICAgdHlwZSA9IGdsLkZMT0FUXG4gICAgcGFja2VkID0gZmFsc2VcbiAgICBkdHlwZSA9ICdmbG9hdDMyJ1xuICB9IGVsc2UgaWYoZHR5cGUgPT09ICd1aW50OCcpIHtcbiAgICB0eXBlID0gZ2wuVU5TSUdORURfQllURVxuICB9IGVsc2Uge1xuICAgIHR5cGUgPSBnbC5VTlNJR05FRF9CWVRFXG4gICAgcGFja2VkID0gZmFsc2VcbiAgICBkdHlwZSA9ICd1aW50OCdcbiAgfVxuICB2YXIgY2hhbm5lbHMgPSAxXG4gIGlmKHNoYXBlLmxlbmd0aCA9PT0gMikge1xuICAgIGZvcm1hdCA9IGdsLkxVTUlOQU5DRVxuICAgIHNoYXBlID0gW3NoYXBlWzBdLCBzaGFwZVsxXSwgMV1cbiAgICBhcnJheSA9IG5kYXJyYXkoYXJyYXkuZGF0YSwgc2hhcGUsIFthcnJheS5zdHJpZGVbMF0sIGFycmF5LnN0cmlkZVsxXSwgMV0sIGFycmF5Lm9mZnNldClcbiAgfSBlbHNlIGlmKHNoYXBlLmxlbmd0aCA9PT0gMykge1xuICAgIGlmKHNoYXBlWzJdID09PSAxKSB7XG4gICAgICBmb3JtYXQgPSBnbC5BTFBIQVxuICAgIH0gZWxzZSBpZihzaGFwZVsyXSA9PT0gMikge1xuICAgICAgZm9ybWF0ID0gZ2wuTFVNSU5BTkNFX0FMUEhBXG4gICAgfSBlbHNlIGlmKHNoYXBlWzJdID09PSAzKSB7XG4gICAgICBmb3JtYXQgPSBnbC5SR0JcbiAgICB9IGVsc2UgaWYoc2hhcGVbMl0gPT09IDQpIHtcbiAgICAgIGZvcm1hdCA9IGdsLlJHQkFcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdnbC10ZXh0dXJlMmQ6IEludmFsaWQgc2hhcGUgZm9yIHBpeGVsIGNvb3JkcycpXG4gICAgfVxuICAgIGNoYW5uZWxzID0gc2hhcGVbMl1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2dsLXRleHR1cmUyZDogSW52YWxpZCBzaGFwZSBmb3IgdGV4dHVyZScpXG4gIH1cbiAgLy9Gb3IgMS1jaGFubmVsIHRleHR1cmVzIGFsbG93IGNvbnZlcnNpb24gYmV0d2VlbiBmb3JtYXRzXG4gIGlmKChmb3JtYXQgID09PSBnbC5MVU1JTkFOQ0UgfHwgZm9ybWF0ICA9PT0gZ2wuQUxQSEEpICYmXG4gICAgIChjZm9ybWF0ID09PSBnbC5MVU1JTkFOQ0UgfHwgY2Zvcm1hdCA9PT0gZ2wuQUxQSEEpKSB7XG4gICAgZm9ybWF0ID0gY2Zvcm1hdFxuICB9XG4gIGlmKGZvcm1hdCAhPT0gY2Zvcm1hdCkge1xuICAgIHRocm93IG5ldyBFcnJvcignZ2wtdGV4dHVyZTJkOiBJbmNvbXBhdGlibGUgdGV4dHVyZSBmb3JtYXQgZm9yIHNldFBpeGVscycpXG4gIH1cbiAgdmFyIHNpemUgPSBhcnJheS5zaXplXG4gIHZhciBuZWVkc01pcCA9IG1pcExldmVscy5pbmRleE9mKG1pcF9sZXZlbCkgPCAwXG4gIGlmKG5lZWRzTWlwKSB7XG4gICAgbWlwTGV2ZWxzLnB1c2gobWlwX2xldmVsKVxuICB9XG4gIGlmKHR5cGUgPT09IGN0eXBlICYmIHBhY2tlZCkge1xuICAgIC8vQXJyYXkgZGF0YSB0eXBlcyBhcmUgY29tcGF0aWJsZSwgY2FuIGRpcmVjdGx5IGNvcHkgaW50byB0ZXh0dXJlXG4gICAgaWYoYXJyYXkub2Zmc2V0ID09PSAwICYmIGFycmF5LmRhdGEubGVuZ3RoID09PSBzaXplKSB7XG4gICAgICBpZihuZWVkc01pcCkge1xuICAgICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIG1pcF9sZXZlbCwgY2Zvcm1hdCwgc2hhcGVbMF0sIHNoYXBlWzFdLCAwLCBjZm9ybWF0LCBjdHlwZSwgYXJyYXkuZGF0YSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdsLnRleFN1YkltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgbWlwX2xldmVsLCB4X29mZiwgeV9vZmYsIHNoYXBlWzBdLCBzaGFwZVsxXSwgY2Zvcm1hdCwgY3R5cGUsIGFycmF5LmRhdGEpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmKG5lZWRzTWlwKSB7XG4gICAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgbWlwX2xldmVsLCBjZm9ybWF0LCBzaGFwZVswXSwgc2hhcGVbMV0sIDAsIGNmb3JtYXQsIGN0eXBlLCBhcnJheS5kYXRhLnN1YmFycmF5KGFycmF5Lm9mZnNldCwgYXJyYXkub2Zmc2V0K3NpemUpKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ2wudGV4U3ViSW1hZ2UyRChnbC5URVhUVVJFXzJELCBtaXBfbGV2ZWwsIHhfb2ZmLCB5X29mZiwgc2hhcGVbMF0sIHNoYXBlWzFdLCBjZm9ybWF0LCBjdHlwZSwgYXJyYXkuZGF0YS5zdWJhcnJheShhcnJheS5vZmZzZXQsIGFycmF5Lm9mZnNldCtzaXplKSlcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy9OZWVkIHRvIGRvIHR5cGUgY29udmVyc2lvbiB0byBwYWNrIGRhdGEgaW50byBidWZmZXJcbiAgICB2YXIgcGFja19idWZmZXJcbiAgICBpZihjdHlwZSA9PT0gZ2wuRkxPQVQpIHtcbiAgICAgIHBhY2tfYnVmZmVyID0gcG9vbC5tYWxsb2NGbG9hdDMyKHNpemUpXG4gICAgfSBlbHNlIHtcbiAgICAgIHBhY2tfYnVmZmVyID0gcG9vbC5tYWxsb2NVaW50OChzaXplKVxuICAgIH1cbiAgICB2YXIgcGFja192aWV3ID0gbmRhcnJheShwYWNrX2J1ZmZlciwgc2hhcGUsIFtzaGFwZVsyXSwgc2hhcGVbMl0qc2hhcGVbMF0sIDFdKVxuICAgIGlmKHR5cGUgPT09IGdsLkZMT0FUICYmIGN0eXBlID09PSBnbC5VTlNJR05FRF9CWVRFKSB7XG4gICAgICBjb252ZXJ0RmxvYXRUb1VpbnQ4KHBhY2tfdmlldywgYXJyYXkpXG4gICAgfSBlbHNlIHtcbiAgICAgIG9wcy5hc3NpZ24ocGFja192aWV3LCBhcnJheSlcbiAgICB9XG4gICAgaWYobmVlZHNNaXApIHtcbiAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgbWlwX2xldmVsLCBjZm9ybWF0LCBzaGFwZVswXSwgc2hhcGVbMV0sIDAsIGNmb3JtYXQsIGN0eXBlLCBwYWNrX2J1ZmZlci5zdWJhcnJheSgwLCBzaXplKSlcbiAgICB9IGVsc2Uge1xuICAgICAgZ2wudGV4U3ViSW1hZ2UyRChnbC5URVhUVVJFXzJELCBtaXBfbGV2ZWwsIHhfb2ZmLCB5X29mZiwgc2hhcGVbMF0sIHNoYXBlWzFdLCBjZm9ybWF0LCBjdHlwZSwgcGFja19idWZmZXIuc3ViYXJyYXkoMCwgc2l6ZSkpXG4gICAgfVxuICAgIGlmKGN0eXBlID09PSBnbC5GTE9BVCkge1xuICAgICAgcG9vbC5mcmVlRmxvYXQzMihwYWNrX2J1ZmZlcilcbiAgICB9IGVsc2Uge1xuICAgICAgcG9vbC5mcmVlVWludDgocGFja19idWZmZXIpXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRUZXh0dXJlKGdsKSB7XG4gIHZhciB0ZXggPSBnbC5jcmVhdGVUZXh0dXJlKClcbiAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4KVxuICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTkVBUkVTVClcbiAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLk5FQVJFU1QpXG4gIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLkNMQU1QX1RPX0VER0UpXG4gIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UpXG4gIHJldHVybiB0ZXhcbn1cblxuZnVuY3Rpb24gY3JlYXRlVGV4dHVyZVNoYXBlKGdsLCB3aWR0aCwgaGVpZ2h0LCBmb3JtYXQsIHR5cGUpIHtcbiAgdmFyIG1heFRleHR1cmVTaXplID0gZ2wuZ2V0UGFyYW1ldGVyKGdsLk1BWF9URVhUVVJFX1NJWkUpXG4gIGlmKHdpZHRoIDwgMCB8fCB3aWR0aCA+IG1heFRleHR1cmVTaXplIHx8IGhlaWdodCA8IDAgfHwgaGVpZ2h0ICA+IG1heFRleHR1cmVTaXplKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdnbC10ZXh0dXJlMmQ6IEludmFsaWQgdGV4dHVyZSBzaGFwZScpXG4gIH1cbiAgaWYodHlwZSA9PT0gZ2wuRkxPQVQgJiYgIXdlYmdsZXcoZ2wpLnRleHR1cmVfZmxvYXQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2dsLXRleHR1cmUyZDogRmxvYXRpbmcgcG9pbnQgdGV4dHVyZXMgbm90IHN1cHBvcnRlZCBvbiB0aGlzIHBsYXRmb3JtJylcbiAgfVxuICB2YXIgdGV4ID0gaW5pdFRleHR1cmUoZ2wpXG4gIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZm9ybWF0LCB3aWR0aCwgaGVpZ2h0LCAwLCBmb3JtYXQsIHR5cGUsIG51bGwpXG4gIHJldHVybiBuZXcgVGV4dHVyZTJEKGdsLCB0ZXgsIHdpZHRoLCBoZWlnaHQsIGZvcm1hdCwgdHlwZSlcbn1cblxuZnVuY3Rpb24gY3JlYXRlVGV4dHVyZURPTShnbCwgZWxlbWVudCwgZm9ybWF0LCB0eXBlKSB7XG4gIHZhciB0ZXggPSBpbml0VGV4dHVyZShnbClcbiAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBmb3JtYXQsIGZvcm1hdCwgdHlwZSwgZWxlbWVudClcbiAgcmV0dXJuIG5ldyBUZXh0dXJlMkQoZ2wsIHRleCwgZWxlbWVudC53aWR0aHwwLCBlbGVtZW50LmhlaWdodHwwLCBmb3JtYXQsIHR5cGUpXG59XG5cbi8vQ3JlYXRlcyBhIHRleHR1cmUgZnJvbSBhbiBuZGFycmF5XG5mdW5jdGlvbiBjcmVhdGVUZXh0dXJlQXJyYXkoZ2wsIGFycmF5KSB7XG4gIHZhciBkdHlwZSA9IGFycmF5LmR0eXBlXG4gIHZhciBzaGFwZSA9IGFycmF5LnNoYXBlLnNsaWNlKClcbiAgdmFyIG1heFNpemUgPSBnbC5nZXRQYXJhbWV0ZXIoZ2wuTUFYX1RFWFRVUkVfU0laRSlcbiAgaWYoc2hhcGVbMF0gPCAwIHx8IHNoYXBlWzBdID4gbWF4U2l6ZSB8fCBzaGFwZVsxXSA8IDAgfHwgc2hhcGVbMV0gPiBtYXhTaXplKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdnbC10ZXh0dXJlMmQ6IEludmFsaWQgdGV4dHVyZSBzaXplJylcbiAgfVxuICB2YXIgcGFja2VkID0gaXNQYWNrZWQoc2hhcGUsIGFycmF5LnN0cmlkZS5zbGljZSgpKVxuICB2YXIgdHlwZSA9IDBcbiAgaWYoZHR5cGUgPT09ICdmbG9hdDMyJykge1xuICAgIHR5cGUgPSBnbC5GTE9BVFxuICB9IGVsc2UgaWYoZHR5cGUgPT09ICdmbG9hdDY0Jykge1xuICAgIHR5cGUgPSBnbC5GTE9BVFxuICAgIHBhY2tlZCA9IGZhbHNlXG4gICAgZHR5cGUgPSAnZmxvYXQzMidcbiAgfSBlbHNlIGlmKGR0eXBlID09PSAndWludDgnKSB7XG4gICAgdHlwZSA9IGdsLlVOU0lHTkVEX0JZVEVcbiAgfSBlbHNlIHtcbiAgICB0eXBlID0gZ2wuVU5TSUdORURfQllURVxuICAgIHBhY2tlZCA9IGZhbHNlXG4gICAgZHR5cGUgPSAndWludDgnXG4gIH1cbiAgdmFyIGZvcm1hdCA9IDBcbiAgaWYoc2hhcGUubGVuZ3RoID09PSAyKSB7XG4gICAgZm9ybWF0ID0gZ2wuTFVNSU5BTkNFXG4gICAgc2hhcGUgPSBbc2hhcGVbMF0sIHNoYXBlWzFdLCAxXVxuICAgIGFycmF5ID0gbmRhcnJheShhcnJheS5kYXRhLCBzaGFwZSwgW2FycmF5LnN0cmlkZVswXSwgYXJyYXkuc3RyaWRlWzFdLCAxXSwgYXJyYXkub2Zmc2V0KVxuICB9IGVsc2UgaWYoc2hhcGUubGVuZ3RoID09PSAzKSB7XG4gICAgaWYoc2hhcGVbMl0gPT09IDEpIHtcbiAgICAgIGZvcm1hdCA9IGdsLkFMUEhBXG4gICAgfSBlbHNlIGlmKHNoYXBlWzJdID09PSAyKSB7XG4gICAgICBmb3JtYXQgPSBnbC5MVU1JTkFOQ0VfQUxQSEFcbiAgICB9IGVsc2UgaWYoc2hhcGVbMl0gPT09IDMpIHtcbiAgICAgIGZvcm1hdCA9IGdsLlJHQlxuICAgIH0gZWxzZSBpZihzaGFwZVsyXSA9PT0gNCkge1xuICAgICAgZm9ybWF0ID0gZ2wuUkdCQVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dsLXRleHR1cmUyZDogSW52YWxpZCBzaGFwZSBmb3IgcGl4ZWwgY29vcmRzJylcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdnbC10ZXh0dXJlMmQ6IEludmFsaWQgc2hhcGUgZm9yIHRleHR1cmUnKVxuICB9XG4gIGlmKHR5cGUgPT09IGdsLkZMT0FUICYmICF3ZWJnbGV3KGdsKS50ZXh0dXJlX2Zsb2F0KSB7XG4gICAgdHlwZSA9IGdsLlVOU0lHTkVEX0JZVEVcbiAgICBwYWNrZWQgPSBmYWxzZVxuICB9XG4gIHZhciBidWZmZXIsIGJ1Zl9zdG9yZVxuICB2YXIgc2l6ZSA9IGFycmF5LnNpemVcbiAgaWYoIXBhY2tlZCkge1xuICAgIHZhciBzdHJpZGUgPSBbc2hhcGVbMl0sIHNoYXBlWzJdKnNoYXBlWzBdLCAxXVxuICAgIGJ1Zl9zdG9yZSA9IHBvb2wubWFsbG9jKHNpemUsIGR0eXBlKVxuICAgIHZhciBidWZfYXJyYXkgPSBuZGFycmF5KGJ1Zl9zdG9yZSwgc2hhcGUsIHN0cmlkZSwgMClcbiAgICBpZigoZHR5cGUgPT09ICdmbG9hdDMyJyB8fCBkdHlwZSA9PT0gJ2Zsb2F0NjQnKSAmJiB0eXBlID09PSBnbC5VTlNJR05FRF9CWVRFKSB7XG4gICAgICBjb252ZXJ0RmxvYXRUb1VpbnQ4KGJ1Zl9hcnJheSwgYXJyYXkpXG4gICAgfSBlbHNlIHtcbiAgICAgIG9wcy5hc3NpZ24oYnVmX2FycmF5LCBhcnJheSlcbiAgICB9XG4gICAgYnVmZmVyID0gYnVmX3N0b3JlLnN1YmFycmF5KDAsIHNpemUpXG4gIH0gZWxzZSBpZiAoYXJyYXkub2Zmc2V0ID09PSAwICYmIGFycmF5LmRhdGEubGVuZ3RoID09PSBzaXplKSB7XG4gICAgYnVmZmVyID0gYXJyYXkuZGF0YVxuICB9IGVsc2Uge1xuICAgIGJ1ZmZlciA9IGFycmF5LmRhdGEuc3ViYXJyYXkoYXJyYXkub2Zmc2V0LCBhcnJheS5vZmZzZXQgKyBzaXplKVxuICB9XG4gIHZhciB0ZXggPSBpbml0VGV4dHVyZShnbClcbiAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBmb3JtYXQsIHNoYXBlWzBdLCBzaGFwZVsxXSwgMCwgZm9ybWF0LCB0eXBlLCBidWZmZXIpXG4gIGlmKCFwYWNrZWQpIHtcbiAgICBwb29sLmZyZWUoYnVmX3N0b3JlKVxuICB9XG4gIHJldHVybiBuZXcgVGV4dHVyZTJEKGdsLCB0ZXgsIHNoYXBlWzBdLCBzaGFwZVsxXSwgZm9ybWF0LCB0eXBlKVxufVxuXG5mdW5jdGlvbiBjcmVhdGVUZXh0dXJlMkQoZ2wpIHtcbiAgaWYoYXJndW1lbnRzLmxlbmd0aCA8PSAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdnbC10ZXh0dXJlMmQ6IE1pc3NpbmcgYXJndW1lbnRzIGZvciB0ZXh0dXJlMmQgY29uc3RydWN0b3InKVxuICB9XG4gIGlmKCFsaW5lYXJUeXBlcykge1xuICAgIGxhenlJbml0TGluZWFyVHlwZXMoZ2wpXG4gIH1cbiAgaWYodHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gY3JlYXRlVGV4dHVyZVNoYXBlKGdsLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSwgYXJndW1lbnRzWzNdfHxnbC5SR0JBLCBhcmd1bWVudHNbNF18fGdsLlVOU0lHTkVEX0JZVEUpXG4gIH1cbiAgaWYoQXJyYXkuaXNBcnJheShhcmd1bWVudHNbMV0pKSB7XG4gICAgcmV0dXJuIGNyZWF0ZVRleHR1cmVTaGFwZShnbCwgYXJndW1lbnRzWzFdWzBdfDAsIGFyZ3VtZW50c1sxXVsxXXwwLCBhcmd1bWVudHNbMl18fGdsLlJHQkEsIGFyZ3VtZW50c1szXXx8Z2wuVU5TSUdORURfQllURSlcbiAgfVxuICBpZih0eXBlb2YgYXJndW1lbnRzWzFdID09PSAnb2JqZWN0Jykge1xuICAgIHZhciBvYmogPSBhcmd1bWVudHNbMV1cbiAgICBpZihvYmogaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudCB8fFxuICAgICAgIG9iaiBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQgfHxcbiAgICAgICBvYmogaW5zdGFuY2VvZiBIVE1MVmlkZW9FbGVtZW50IHx8XG4gICAgICAgb2JqIGluc3RhbmNlb2YgSW1hZ2VEYXRhKSB7XG4gICAgICByZXR1cm4gY3JlYXRlVGV4dHVyZURPTShnbCwgb2JqLCBhcmd1bWVudHNbMl18fGdsLlJHQkEsIGFyZ3VtZW50c1szXXx8Z2wuVU5TSUdORURfQllURSlcbiAgICB9IGVsc2UgaWYob2JqLnNoYXBlICYmIG9iai5kYXRhICYmIG9iai5zdHJpZGUpIHtcbiAgICAgIHJldHVybiBjcmVhdGVUZXh0dXJlQXJyYXkoZ2wsIG9iailcbiAgICB9XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKCdnbC10ZXh0dXJlMmQ6IEludmFsaWQgYXJndW1lbnRzIGZvciB0ZXh0dXJlMmQgY29uc3RydWN0b3InKVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBzZXQ7XG5cbi8qKlxuICogU2V0IHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMyB0byB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHogWiBjb21wb25lbnRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gc2V0KG91dCwgeCwgeSwgeikge1xuICAgIG91dFswXSA9IHhcbiAgICBvdXRbMV0gPSB5XG4gICAgb3V0WzJdID0gelxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IHByb2dyYW1pZnlcblxudmFyIHNoYWRlciA9IHJlcXVpcmUoJ2dsLXNoYWRlci1jb3JlJylcblxuZnVuY3Rpb24gcHJvZ3JhbWlmeSh2ZXJ0ZXgsIGZyYWdtZW50LCB1bmlmb3JtcywgYXR0cmlidXRlcykge1xuICByZXR1cm4gZnVuY3Rpb24oZ2wpIHtcbiAgICByZXR1cm4gc2hhZGVyKGdsLCB2ZXJ0ZXgsIGZyYWdtZW50LCB1bmlmb3JtcywgYXR0cmlidXRlcylcbiAgfVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBub29wXG5cbmZ1bmN0aW9uIG5vb3AoKSB7XG4gIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdZb3Ugc2hvdWxkIGJ1bmRsZSB5b3VyIGNvZGUgJyArXG4gICAgICAndXNpbmcgYGdsc2xpZnlgIGFzIGEgdHJhbnNmb3JtLidcbiAgKVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlQXR0cmlidXRlV3JhcHBlclxuXG4vL1NoYWRlciBhdHRyaWJ1dGUgY2xhc3NcbmZ1bmN0aW9uIFNoYWRlckF0dHJpYnV0ZShnbCwgcHJvZ3JhbSwgbG9jYXRpb24sIGRpbWVuc2lvbiwgbmFtZSwgY29uc3RGdW5jLCByZWxpbmspIHtcbiAgdGhpcy5fZ2wgPSBnbFxuICB0aGlzLl9wcm9ncmFtID0gcHJvZ3JhbVxuICB0aGlzLl9sb2NhdGlvbiA9IGxvY2F0aW9uXG4gIHRoaXMuX2RpbWVuc2lvbiA9IGRpbWVuc2lvblxuICB0aGlzLl9uYW1lID0gbmFtZVxuICB0aGlzLl9jb25zdEZ1bmMgPSBjb25zdEZ1bmNcbiAgdGhpcy5fcmVsaW5rID0gcmVsaW5rXG59XG5cbnZhciBwcm90byA9IFNoYWRlckF0dHJpYnV0ZS5wcm90b3R5cGVcblxucHJvdG8ucG9pbnRlciA9IGZ1bmN0aW9uIHNldEF0dHJpYlBvaW50ZXIodHlwZSwgbm9ybWFsaXplZCwgc3RyaWRlLCBvZmZzZXQpIHtcbiAgdmFyIGdsID0gdGhpcy5fZ2xcbiAgZ2wudmVydGV4QXR0cmliUG9pbnRlcih0aGlzLl9sb2NhdGlvbiwgdGhpcy5fZGltZW5zaW9uLCB0eXBlfHxnbC5GTE9BVCwgISFub3JtYWxpemVkLCBzdHJpZGV8fDAsIG9mZnNldHx8MClcbiAgdGhpcy5fZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkodGhpcy5fbG9jYXRpb24pXG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90bywgJ2xvY2F0aW9uJywge1xuICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9sb2NhdGlvblxuICB9XG4gICwgc2V0OiBmdW5jdGlvbih2KSB7XG4gICAgaWYodiAhPT0gdGhpcy5fbG9jYXRpb24pIHtcbiAgICAgIHRoaXMuX2xvY2F0aW9uID0gdlxuICAgICAgdGhpcy5fZ2wuYmluZEF0dHJpYkxvY2F0aW9uKHRoaXMuX3Byb2dyYW0sIHYsIHRoaXMuX25hbWUpXG4gICAgICB0aGlzLl9nbC5saW5rUHJvZ3JhbSh0aGlzLl9wcm9ncmFtKVxuICAgICAgdGhpcy5fcmVsaW5rKClcbiAgICB9XG4gIH1cbn0pXG5cblxuLy9BZGRzIGEgdmVjdG9yIGF0dHJpYnV0ZSB0byBvYmpcbmZ1bmN0aW9uIGFkZFZlY3RvckF0dHJpYnV0ZShnbCwgcHJvZ3JhbSwgbG9jYXRpb24sIGRpbWVuc2lvbiwgb2JqLCBuYW1lLCBkb0xpbmspIHtcbiAgdmFyIGNvbnN0RnVuY0FyZ3MgPSBbICdnbCcsICd2JyBdXG4gIHZhciB2YXJOYW1lcyA9IFtdXG4gIGZvcih2YXIgaT0wOyBpPGRpbWVuc2lvbjsgKytpKSB7XG4gICAgY29uc3RGdW5jQXJncy5wdXNoKCd4JytpKVxuICAgIHZhck5hbWVzLnB1c2goJ3gnK2kpXG4gIH1cbiAgY29uc3RGdW5jQXJncy5wdXNoKFtcbiAgICAnaWYoeDAubGVuZ3RoPT09dm9pZCAwKXtyZXR1cm4gZ2wudmVydGV4QXR0cmliJywgZGltZW5zaW9uLCAnZih2LCcsIHZhck5hbWVzLmpvaW4oKSwgJyl9ZWxzZXtyZXR1cm4gZ2wudmVydGV4QXR0cmliJywgZGltZW5zaW9uLCAnZnYodix4MCl9J1xuICBdLmpvaW4oJycpKVxuICB2YXIgY29uc3RGdW5jID0gRnVuY3Rpb24uYXBwbHkodW5kZWZpbmVkLCBjb25zdEZ1bmNBcmdzKVxuICB2YXIgYXR0ciA9IG5ldyBTaGFkZXJBdHRyaWJ1dGUoZ2wsIHByb2dyYW0sIGxvY2F0aW9uLCBkaW1lbnNpb24sIG5hbWUsIGNvbnN0RnVuYywgZG9MaW5rKVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBuYW1lLCB7XG4gICAgc2V0OiBmdW5jdGlvbih4KSB7XG4gICAgICBnbC5kaXNhYmxlVmVydGV4QXR0cmliQXJyYXkoYXR0ci5fbG9jYXRpb24pXG4gICAgICBjb25zdEZ1bmMoZ2wsIGF0dHIuX2xvY2F0aW9uLCB4KVxuICAgICAgcmV0dXJuIHhcbiAgICB9XG4gICAgLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGF0dHJcbiAgICB9XG4gICAgLCBlbnVtZXJhYmxlOiB0cnVlXG4gIH0pXG59XG5cbi8vQ3JlYXRlIHNoaW1zIGZvciBhdHRyaWJ1dGVzXG5mdW5jdGlvbiBjcmVhdGVBdHRyaWJ1dGVXcmFwcGVyKGdsLCBwcm9ncmFtLCBhdHRyaWJ1dGVzLCBkb0xpbmspIHtcbiAgdmFyIG9iaiA9IHt9XG4gIGZvcih2YXIgaT0wLCBuPWF0dHJpYnV0ZXMubGVuZ3RoOyBpPG47ICsraSkge1xuICAgIHZhciBhID0gYXR0cmlidXRlc1tpXVxuICAgIHZhciBuYW1lID0gYS5uYW1lXG4gICAgdmFyIHR5cGUgPSBhLnR5cGVcbiAgICB2YXIgbG9jYXRpb24gPSBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCBuYW1lKVxuICAgIFxuICAgIHN3aXRjaCh0eXBlKSB7XG4gICAgICBjYXNlICdib29sJzpcbiAgICAgIGNhc2UgJ2ludCc6XG4gICAgICBjYXNlICdmbG9hdCc6XG4gICAgICAgIGFkZFZlY3RvckF0dHJpYnV0ZShnbCwgcHJvZ3JhbSwgbG9jYXRpb24sIDEsIG9iaiwgbmFtZSwgZG9MaW5rKVxuICAgICAgYnJlYWtcbiAgICAgIFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYodHlwZS5pbmRleE9mKCd2ZWMnKSA+PSAwKSB7XG4gICAgICAgICAgdmFyIGQgPSB0eXBlLmNoYXJDb2RlQXQodHlwZS5sZW5ndGgtMSkgLSA0OFxuICAgICAgICAgIGlmKGQgPCAyIHx8IGQgPiA0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dsLXNoYWRlcjogSW52YWxpZCBkYXRhIHR5cGUgZm9yIGF0dHJpYnV0ZSAnICsgbmFtZSArICc6ICcgKyB0eXBlKVxuICAgICAgICAgIH1cbiAgICAgICAgICBhZGRWZWN0b3JBdHRyaWJ1dGUoZ2wsIHByb2dyYW0sIGxvY2F0aW9uLCBkLCBvYmosIG5hbWUsIGRvTGluaylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dsLXNoYWRlcjogVW5rbm93biBkYXRhIHR5cGUgZm9yIGF0dHJpYnV0ZSAnICsgbmFtZSArICc6ICcgKyB0eXBlKVxuICAgICAgICB9XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuICByZXR1cm4gb2JqXG59IiwiJ3VzZSBzdHJpY3QnXG5cbnZhciBkdXAgPSByZXF1aXJlKCdkdXAnKVxudmFyIGNvYWxsZXNjZVVuaWZvcm1zID0gcmVxdWlyZSgnLi9yZWZsZWN0JylcblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVVbmlmb3JtV3JhcHBlclxuXG4vL0JpbmRzIGEgZnVuY3Rpb24gYW5kIHJldHVybnMgYSB2YWx1ZVxuZnVuY3Rpb24gaWRlbnRpdHkoeCkge1xuICB2YXIgYyA9IG5ldyBGdW5jdGlvbigneScsICdyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4geX0nKVxuICByZXR1cm4gYyh4KVxufVxuXG4vL0NyZWF0ZSBzaGltcyBmb3IgdW5pZm9ybXNcbmZ1bmN0aW9uIGNyZWF0ZVVuaWZvcm1XcmFwcGVyKGdsLCBwcm9ncmFtLCB1bmlmb3JtcywgbG9jYXRpb25zKSB7XG5cbiAgZnVuY3Rpb24gbWFrZUdldHRlcihpbmRleCkge1xuICAgIHZhciBwcm9jID0gbmV3IEZ1bmN0aW9uKCdnbCcsICdwcm9nJywgJ2xvY2F0aW9ucycsIFxuICAgICAgJ3JldHVybiBmdW5jdGlvbigpe3JldHVybiBnbC5nZXRVbmlmb3JtKHByb2csbG9jYXRpb25zWycgKyBpbmRleCArICddKX0nKSBcbiAgICByZXR1cm4gcHJvYyhnbCwgcHJvZ3JhbSwgbG9jYXRpb25zKVxuICB9XG5cbiAgZnVuY3Rpb24gbWFrZVByb3BTZXR0ZXIocGF0aCwgaW5kZXgsIHR5cGUpIHtcbiAgICBzd2l0Y2godHlwZSkge1xuICAgICAgY2FzZSAnYm9vbCc6XG4gICAgICBjYXNlICdpbnQnOlxuICAgICAgY2FzZSAnc2FtcGxlcjJEJzpcbiAgICAgIGNhc2UgJ3NhbXBsZXJDdWJlJzpcbiAgICAgICAgcmV0dXJuICdnbC51bmlmb3JtMWkobG9jYXRpb25zWycgKyBpbmRleCArICddLG9iaicgKyBwYXRoICsgJyknXG4gICAgICBjYXNlICdmbG9hdCc6XG4gICAgICAgIHJldHVybiAnZ2wudW5pZm9ybTFmKGxvY2F0aW9uc1snICsgaW5kZXggKyAnXSxvYmonICsgcGF0aCArICcpJ1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdmFyIHZpZHggPSB0eXBlLmluZGV4T2YoJ3ZlYycpXG4gICAgICAgIGlmKDAgPD0gdmlkeCAmJiB2aWR4IDw9IDEgJiYgdHlwZS5sZW5ndGggPT09IDQgKyB2aWR4KSB7XG4gICAgICAgICAgdmFyIGQgPSB0eXBlLmNoYXJDb2RlQXQodHlwZS5sZW5ndGgtMSkgLSA0OFxuICAgICAgICAgIGlmKGQgPCAyIHx8IGQgPiA0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dsLXNoYWRlcjogSW52YWxpZCBkYXRhIHR5cGUnKVxuICAgICAgICAgIH1cbiAgICAgICAgICBzd2l0Y2godHlwZS5jaGFyQXQoMCkpIHtcbiAgICAgICAgICAgIGNhc2UgJ2InOlxuICAgICAgICAgICAgY2FzZSAnaSc6XG4gICAgICAgICAgICAgIHJldHVybiAnZ2wudW5pZm9ybScgKyBkICsgJ2l2KGxvY2F0aW9uc1snICsgaW5kZXggKyAnXSxvYmonICsgcGF0aCArICcpJ1xuICAgICAgICAgICAgY2FzZSAndic6XG4gICAgICAgICAgICAgIHJldHVybiAnZ2wudW5pZm9ybScgKyBkICsgJ2Z2KGxvY2F0aW9uc1snICsgaW5kZXggKyAnXSxvYmonICsgcGF0aCArICcpJ1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdnbC1zaGFkZXI6IFVucmVjb2duaXplZCBkYXRhIHR5cGUgZm9yIHZlY3RvciAnICsgbmFtZSArICc6ICcgKyB0eXBlKVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmKHR5cGUuaW5kZXhPZignbWF0JykgPT09IDAgJiYgdHlwZS5sZW5ndGggPT09IDQpIHtcbiAgICAgICAgICB2YXIgZCA9IHR5cGUuY2hhckNvZGVBdCh0eXBlLmxlbmd0aC0xKSAtIDQ4XG4gICAgICAgICAgaWYoZCA8IDIgfHwgZCA+IDQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZ2wtc2hhZGVyOiBJbnZhbGlkIHVuaWZvcm0gZGltZW5zaW9uIHR5cGUgZm9yIG1hdHJpeCAnICsgbmFtZSArICc6ICcgKyB0eXBlKVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gJ2dsLnVuaWZvcm1NYXRyaXgnICsgZCArICdmdihsb2NhdGlvbnNbJyArIGluZGV4ICsgJ10sZmFsc2Usb2JqJyArIHBhdGggKyAnKSdcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dsLXNoYWRlcjogVW5rbm93biB1bmlmb3JtIGRhdGEgdHlwZSBmb3IgJyArIG5hbWUgKyAnOiAnICsgdHlwZSlcbiAgICAgICAgfVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBlbnVtZXJhdGVJbmRpY2VzKHByZWZpeCwgdHlwZSkge1xuICAgIGlmKHR5cGVvZiB0eXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIFsgW3ByZWZpeCwgdHlwZV0gXVxuICAgIH1cbiAgICB2YXIgaW5kaWNlcyA9IFtdXG4gICAgZm9yKHZhciBpZCBpbiB0eXBlKSB7XG4gICAgICB2YXIgcHJvcCA9IHR5cGVbaWRdXG4gICAgICB2YXIgdHByZWZpeCA9IHByZWZpeFxuICAgICAgaWYocGFyc2VJbnQoaWQpICsgJycgPT09IGlkKSB7XG4gICAgICAgIHRwcmVmaXggKz0gJ1snICsgaWQgKyAnXSdcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRwcmVmaXggKz0gJy4nICsgaWRcbiAgICAgIH1cbiAgICAgIGlmKHR5cGVvZiBwcm9wID09PSAnb2JqZWN0Jykge1xuICAgICAgICBpbmRpY2VzLnB1c2guYXBwbHkoaW5kaWNlcywgZW51bWVyYXRlSW5kaWNlcyh0cHJlZml4LCBwcm9wKSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluZGljZXMucHVzaChbdHByZWZpeCwgcHJvcF0pXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpbmRpY2VzXG4gIH1cblxuICBmdW5jdGlvbiBtYWtlU2V0dGVyKHR5cGUpIHtcbiAgICB2YXIgY29kZSA9IFsgJ3JldHVybiBmdW5jdGlvbiB1cGRhdGVQcm9wZXJ0eShvYmopeycgXVxuICAgIHZhciBpbmRpY2VzID0gZW51bWVyYXRlSW5kaWNlcygnJywgdHlwZSlcbiAgICBmb3IodmFyIGk9MDsgaTxpbmRpY2VzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgaXRlbSA9IGluZGljZXNbaV1cbiAgICAgIHZhciBwYXRoID0gaXRlbVswXVxuICAgICAgdmFyIGlkeCAgPSBpdGVtWzFdXG4gICAgICBpZihsb2NhdGlvbnNbaWR4XSkge1xuICAgICAgICBjb2RlLnB1c2gobWFrZVByb3BTZXR0ZXIocGF0aCwgaWR4LCB1bmlmb3Jtc1tpZHhdLnR5cGUpKVxuICAgICAgfVxuICAgIH1cbiAgICBjb2RlLnB1c2goJ3JldHVybiBvYmp9JylcbiAgICB2YXIgcHJvYyA9IG5ldyBGdW5jdGlvbignZ2wnLCAncHJvZycsICdsb2NhdGlvbnMnLCBjb2RlLmpvaW4oJ1xcbicpKVxuICAgIHJldHVybiBwcm9jKGdsLCBwcm9ncmFtLCBsb2NhdGlvbnMpXG4gIH1cblxuICBmdW5jdGlvbiBkZWZhdWx0VmFsdWUodHlwZSkge1xuICAgIHN3aXRjaCh0eXBlKSB7XG4gICAgICBjYXNlICdib29sJzpcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICBjYXNlICdpbnQnOlxuICAgICAgY2FzZSAnc2FtcGxlcjJEJzpcbiAgICAgIGNhc2UgJ3NhbXBsZXJDdWJlJzpcbiAgICAgICAgcmV0dXJuIDBcbiAgICAgIGNhc2UgJ2Zsb2F0JzpcbiAgICAgICAgcmV0dXJuIDAuMFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdmFyIHZpZHggPSB0eXBlLmluZGV4T2YoJ3ZlYycpXG4gICAgICAgIGlmKDAgPD0gdmlkeCAmJiB2aWR4IDw9IDEgJiYgdHlwZS5sZW5ndGggPT09IDQgKyB2aWR4KSB7XG4gICAgICAgICAgdmFyIGQgPSB0eXBlLmNoYXJDb2RlQXQodHlwZS5sZW5ndGgtMSkgLSA0OFxuICAgICAgICAgIGlmKGQgPCAyIHx8IGQgPiA0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dsLXNoYWRlcjogSW52YWxpZCBkYXRhIHR5cGUnKVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZih0eXBlLmNoYXJBdCgwKSA9PT0gJ2InKSB7XG4gICAgICAgICAgICByZXR1cm4gZHVwKGQsIGZhbHNlKVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZHVwKGQpXG4gICAgICAgIH0gZWxzZSBpZih0eXBlLmluZGV4T2YoJ21hdCcpID09PSAwICYmIHR5cGUubGVuZ3RoID09PSA0KSB7XG4gICAgICAgICAgdmFyIGQgPSB0eXBlLmNoYXJDb2RlQXQodHlwZS5sZW5ndGgtMSkgLSA0OFxuICAgICAgICAgIGlmKGQgPCAyIHx8IGQgPiA0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dsLXNoYWRlcjogSW52YWxpZCB1bmlmb3JtIGRpbWVuc2lvbiB0eXBlIGZvciBtYXRyaXggJyArIG5hbWUgKyAnOiAnICsgdHlwZSlcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGR1cChbZCxkXSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dsLXNoYWRlcjogVW5rbm93biB1bmlmb3JtIGRhdGEgdHlwZSBmb3IgJyArIG5hbWUgKyAnOiAnICsgdHlwZSlcbiAgICAgICAgfVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzdG9yZVByb3BlcnR5KG9iaiwgcHJvcCwgdHlwZSkge1xuICAgIGlmKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgdmFyIGNoaWxkID0gcHJvY2Vzc09iamVjdCh0eXBlKVxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgcHJvcCwge1xuICAgICAgICBnZXQ6IGlkZW50aXR5KGNoaWxkKSxcbiAgICAgICAgc2V0OiBtYWtlU2V0dGVyKHR5cGUpLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlXG4gICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICBpZihsb2NhdGlvbnNbdHlwZV0pIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgcHJvcCwge1xuICAgICAgICAgIGdldDogbWFrZUdldHRlcih0eXBlKSxcbiAgICAgICAgICBzZXQ6IG1ha2VTZXR0ZXIodHlwZSksXG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvYmpbcHJvcF0gPSBkZWZhdWx0VmFsdWUodW5pZm9ybXNbdHlwZV0udHlwZSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwcm9jZXNzT2JqZWN0KG9iaikge1xuICAgIHZhciByZXN1bHRcbiAgICBpZihBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgIHJlc3VsdCA9IG5ldyBBcnJheShvYmoubGVuZ3RoKVxuICAgICAgZm9yKHZhciBpPTA7IGk8b2JqLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHN0b3JlUHJvcGVydHkocmVzdWx0LCBpLCBvYmpbaV0pXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IHt9XG4gICAgICBmb3IodmFyIGlkIGluIG9iaikge1xuICAgICAgICBzdG9yZVByb3BlcnR5KHJlc3VsdCwgaWQsIG9ialtpZF0pXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIC8vUmV0dXJuIGRhdGFcbiAgdmFyIGNvYWxsZXNjZWQgPSBjb2FsbGVzY2VVbmlmb3Jtcyh1bmlmb3JtcywgdHJ1ZSlcbiAgcmV0dXJuIHtcbiAgICBnZXQ6IGlkZW50aXR5KHByb2Nlc3NPYmplY3QoY29hbGxlc2NlZCkpLFxuICAgIHNldDogbWFrZVNldHRlcihjb2FsbGVzY2VkKSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9XG59XG4iLCIndXNlIHN0cmljdCdcblxubW9kdWxlLmV4cG9ydHMgPSBtYWtlUmVmbGVjdFR5cGVzXG5cbi8vQ29uc3RydWN0IHR5cGUgaW5mbyBmb3IgcmVmbGVjdGlvbi5cbi8vXG4vLyBUaGlzIGl0ZXJhdGVzIG92ZXIgdGhlIGZsYXR0ZW5lZCBsaXN0IG9mIHVuaWZvcm0gdHlwZSB2YWx1ZXMgYW5kIHNtYXNoZXMgdGhlbSBpbnRvIGEgSlNPTiBvYmplY3QuXG4vL1xuLy8gVGhlIGxlYXZlcyBvZiB0aGUgcmVzdWx0aW5nIG9iamVjdCBhcmUgZWl0aGVyIGluZGljZXMgb3IgdHlwZSBzdHJpbmdzIHJlcHJlc2VudGluZyBwcmltaXRpdmUgZ2xzbGlmeSB0eXBlc1xuZnVuY3Rpb24gbWFrZVJlZmxlY3RUeXBlcyh1bmlmb3JtcywgdXNlSW5kZXgpIHtcbiAgdmFyIG9iaiA9IHt9XG4gIGZvcih2YXIgaT0wOyBpPHVuaWZvcm1zLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIG4gPSB1bmlmb3Jtc1tpXS5uYW1lXG4gICAgdmFyIHBhcnRzID0gbi5zcGxpdChcIi5cIilcbiAgICB2YXIgbyA9IG9ialxuICAgIGZvcih2YXIgaj0wOyBqPHBhcnRzLmxlbmd0aDsgKytqKSB7XG4gICAgICB2YXIgeCA9IHBhcnRzW2pdLnNwbGl0KFwiW1wiKVxuICAgICAgaWYoeC5sZW5ndGggPiAxKSB7XG4gICAgICAgIGlmKCEoeFswXSBpbiBvKSkge1xuICAgICAgICAgIG9beFswXV0gPSBbXVxuICAgICAgICB9XG4gICAgICAgIG8gPSBvW3hbMF1dXG4gICAgICAgIGZvcih2YXIgaz0xOyBrPHgubGVuZ3RoOyArK2spIHtcbiAgICAgICAgICB2YXIgeSA9IHBhcnNlSW50KHhba10pXG4gICAgICAgICAgaWYoazx4Lmxlbmd0aC0xIHx8IGo8cGFydHMubGVuZ3RoLTEpIHtcbiAgICAgICAgICAgIGlmKCEoeSBpbiBvKSkge1xuICAgICAgICAgICAgICBpZihrIDwgeC5sZW5ndGgtMSkge1xuICAgICAgICAgICAgICAgIG9beV0gPSBbXVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG9beV0gPSB7fVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvID0gb1t5XVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZih1c2VJbmRleCkge1xuICAgICAgICAgICAgICBvW3ldID0gaVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgb1t5XSA9IHVuaWZvcm1zW2ldLnR5cGVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZihqIDwgcGFydHMubGVuZ3RoLTEpIHtcbiAgICAgICAgaWYoISh4WzBdIGluIG8pKSB7XG4gICAgICAgICAgb1t4WzBdXSA9IHt9XG4gICAgICAgIH1cbiAgICAgICAgbyA9IG9beFswXV1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmKHVzZUluZGV4KSB7XG4gICAgICAgICAgb1t4WzBdXSA9IGlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvW3hbMF1dID0gdW5pZm9ybXNbaV0udHlwZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBvYmpcbn0iLCJtb2R1bGUuZXhwb3J0cz1yZXF1aXJlKFwiL3Byb2plY3RzL2JsYWNraWNlL25vZGVfbW9kdWxlcy9nbC10ZXh0dXJlMmQvbm9kZV9tb2R1bGVzL3R5cGVkYXJyYXktcG9vbC9ub2RlX21vZHVsZXMvZHVwL2R1cC5qc1wiKSIsIid1c2Ugc3RyaWN0J1xuXG52YXIgY3JlYXRlVW5pZm9ybVdyYXBwZXIgPSByZXF1aXJlKCcuL2xpYi9jcmVhdGUtdW5pZm9ybXMnKVxudmFyIGNyZWF0ZUF0dHJpYnV0ZVdyYXBwZXIgPSByZXF1aXJlKCcuL2xpYi9jcmVhdGUtYXR0cmlidXRlcycpXG52YXIgbWFrZVJlZmxlY3QgPSByZXF1aXJlKCcuL2xpYi9yZWZsZWN0JylcblxuLy9TaGFkZXIgb2JqZWN0XG5mdW5jdGlvbiBTaGFkZXIoZ2wsIHByb2csIHZlcnRTaGFkZXIsIGZyYWdTaGFkZXIpIHtcbiAgdGhpcy5nbCA9IGdsXG4gIHRoaXMuaGFuZGxlID0gcHJvZ1xuICB0aGlzLmF0dHJpYnV0ZXMgPSBudWxsXG4gIHRoaXMudW5pZm9ybXMgPSBudWxsXG4gIHRoaXMudHlwZXMgPSBudWxsXG4gIHRoaXMudmVydGV4U2hhZGVyID0gdmVydFNoYWRlclxuICB0aGlzLmZyYWdtZW50U2hhZGVyID0gZnJhZ1NoYWRlclxufVxuXG4vL0JpbmRzIHRoZSBzaGFkZXJcblNoYWRlci5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmdsLnVzZVByb2dyYW0odGhpcy5oYW5kbGUpXG59XG5cbi8vRGVzdHJveSBzaGFkZXIsIHJlbGVhc2UgcmVzb3VyY2VzXG5TaGFkZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGdsID0gdGhpcy5nbFxuICBnbC5kZWxldGVTaGFkZXIodGhpcy52ZXJ0ZXhTaGFkZXIpXG4gIGdsLmRlbGV0ZVNoYWRlcih0aGlzLmZyYWdtZW50U2hhZGVyKVxuICBnbC5kZWxldGVQcm9ncmFtKHRoaXMuaGFuZGxlKVxufVxuXG5TaGFkZXIucHJvdG90eXBlLnVwZGF0ZUV4cG9ydHMgPSBmdW5jdGlvbih1bmlmb3JtcywgYXR0cmlidXRlcykge1xuICB2YXIgbG9jYXRpb25zID0gbmV3IEFycmF5KHVuaWZvcm1zLmxlbmd0aClcbiAgdmFyIHByb2dyYW0gPSB0aGlzLmhhbmRsZVxuICB2YXIgZ2wgPSB0aGlzLmdsXG5cbiAgdmFyIGRvTGluayA9IHJlbGlua1VuaWZvcm1zLmJpbmQodm9pZCAwLFxuICAgIGdsLFxuICAgIHByb2dyYW0sXG4gICAgbG9jYXRpb25zLFxuICAgIHVuaWZvcm1zXG4gIClcbiAgZG9MaW5rKClcblxuICB0aGlzLnR5cGVzID0ge1xuICAgIHVuaWZvcm1zOiBtYWtlUmVmbGVjdCh1bmlmb3JtcyksXG4gICAgYXR0cmlidXRlczogbWFrZVJlZmxlY3QoYXR0cmlidXRlcylcbiAgfVxuXG4gIHRoaXMuYXR0cmlidXRlcyA9IGNyZWF0ZUF0dHJpYnV0ZVdyYXBwZXIoXG4gICAgZ2wsXG4gICAgcHJvZ3JhbSxcbiAgICBhdHRyaWJ1dGVzLFxuICAgIGRvTGlua1xuICApXG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICd1bmlmb3JtcycsIGNyZWF0ZVVuaWZvcm1XcmFwcGVyKFxuICAgIGdsLFxuICAgIHByb2dyYW0sXG4gICAgdW5pZm9ybXMsXG4gICAgbG9jYXRpb25zXG4gICkpXG59XG5cbi8vUmVsaW5rcyBhbGwgdW5pZm9ybXNcbmZ1bmN0aW9uIHJlbGlua1VuaWZvcm1zKGdsLCBwcm9ncmFtLCBsb2NhdGlvbnMsIHVuaWZvcm1zKSB7XG4gIGZvcih2YXIgaT0wOyBpPHVuaWZvcm1zLmxlbmd0aDsgKytpKSB7XG4gICAgbG9jYXRpb25zW2ldID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIHVuaWZvcm1zW2ldLm5hbWUpXG4gIH1cbn1cblxuLy9Db21waWxlcyBhbmQgbGlua3MgYSBzaGFkZXIgcHJvZ3JhbSB3aXRoIHRoZSBnaXZlbiBhdHRyaWJ1dGUgYW5kIHZlcnRleCBsaXN0XG5mdW5jdGlvbiBjcmVhdGVTaGFkZXIoXG4gICAgZ2xcbiAgLCB2ZXJ0U291cmNlXG4gICwgZnJhZ1NvdXJjZVxuICAsIHVuaWZvcm1zXG4gICwgYXR0cmlidXRlcykge1xuICBcbiAgLy9Db21waWxlIHZlcnRleCBzaGFkZXJcbiAgdmFyIHZlcnRTaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIoZ2wuVkVSVEVYX1NIQURFUilcbiAgZ2wuc2hhZGVyU291cmNlKHZlcnRTaGFkZXIsIHZlcnRTb3VyY2UpXG4gIGdsLmNvbXBpbGVTaGFkZXIodmVydFNoYWRlcilcbiAgaWYoIWdsLmdldFNoYWRlclBhcmFtZXRlcih2ZXJ0U2hhZGVyLCBnbC5DT01QSUxFX1NUQVRVUykpIHtcbiAgICB2YXIgZXJyTG9nID0gZ2wuZ2V0U2hhZGVySW5mb0xvZyh2ZXJ0U2hhZGVyKVxuICAgIGNvbnNvbGUuZXJyb3IoJ2dsLXNoYWRlcjogRXJyb3IgY29tcGxpbmcgdmVydGV4IHNoYWRlcjonLCBlcnJMb2cpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdnbC1zaGFkZXI6IEVycm9yIGNvbXBpbGluZyB2ZXJ0ZXggc2hhZGVyOicgKyBlcnJMb2cpXG4gIH1cbiAgXG4gIC8vQ29tcGlsZSBmcmFnbWVudCBzaGFkZXJcbiAgdmFyIGZyYWdTaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIoZ2wuRlJBR01FTlRfU0hBREVSKVxuICBnbC5zaGFkZXJTb3VyY2UoZnJhZ1NoYWRlciwgZnJhZ1NvdXJjZSlcbiAgZ2wuY29tcGlsZVNoYWRlcihmcmFnU2hhZGVyKVxuICBpZighZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKGZyYWdTaGFkZXIsIGdsLkNPTVBJTEVfU1RBVFVTKSkge1xuICAgIHZhciBlcnJMb2cgPSBnbC5nZXRTaGFkZXJJbmZvTG9nKGZyYWdTaGFkZXIpXG4gICAgY29uc29sZS5lcnJvcignZ2wtc2hhZGVyOiBFcnJvciBjb21waWxpbmcgZnJhZ21lbnQgc2hhZGVyOicsIGVyckxvZylcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2dsLXNoYWRlcjogRXJyb3IgY29tcGlsaW5nIGZyYWdtZW50IHNoYWRlcjonICsgZXJyTG9nKVxuICB9XG4gIFxuICAvL0xpbmsgcHJvZ3JhbVxuICB2YXIgcHJvZ3JhbSA9IGdsLmNyZWF0ZVByb2dyYW0oKVxuICBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgZnJhZ1NoYWRlcilcbiAgZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIHZlcnRTaGFkZXIpXG5cbiAgLy9PcHRpb25hbCBkZWZhdWx0IGF0dHJpdWJ0ZSBsb2NhdGlvbnNcbiAgYXR0cmlidXRlcy5mb3JFYWNoKGZ1bmN0aW9uKGEpIHtcbiAgICBpZiAodHlwZW9mIGEubG9jYXRpb24gPT09ICdudW1iZXInKSBcbiAgICAgIGdsLmJpbmRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCBhLmxvY2F0aW9uLCBhLm5hbWUpXG4gIH0pXG5cbiAgZ2wubGlua1Byb2dyYW0ocHJvZ3JhbSlcbiAgaWYoIWdsLmdldFByb2dyYW1QYXJhbWV0ZXIocHJvZ3JhbSwgZ2wuTElOS19TVEFUVVMpKSB7XG4gICAgdmFyIGVyckxvZyA9IGdsLmdldFByb2dyYW1JbmZvTG9nKHByb2dyYW0pXG4gICAgY29uc29sZS5lcnJvcignZ2wtc2hhZGVyOiBFcnJvciBsaW5raW5nIHNoYWRlciBwcm9ncmFtOicsIGVyckxvZylcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2dsLXNoYWRlcjogRXJyb3IgbGlua2luZyBzaGFkZXIgcHJvZ3JhbTonICsgZXJyTG9nKVxuICB9XG4gIFxuICAvL1JldHVybiBmaW5hbCBsaW5rZWQgc2hhZGVyIG9iamVjdFxuICB2YXIgc2hhZGVyID0gbmV3IFNoYWRlcihcbiAgICBnbCxcbiAgICBwcm9ncmFtLFxuICAgIHZlcnRTaGFkZXIsXG4gICAgZnJhZ1NoYWRlclxuICApXG4gIHNoYWRlci51cGRhdGVFeHBvcnRzKHVuaWZvcm1zLCBhdHRyaWJ1dGVzKVxuXG4gIHJldHVybiBzaGFkZXJcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVTaGFkZXJcbiIsIm1vZHVsZS5leHBvcnRzID0gcHJvZ3JhbWlmeVxuXG5mdW5jdGlvbiBwcm9ncmFtaWZ5KHZlcnRleCwgZnJhZ21lbnQsIHVuaWZvcm1zLCBhdHRyaWJ1dGVzKSB7XG4gIHJldHVybiB7XG4gICAgdmVydGV4OiB2ZXJ0ZXgsIFxuICAgIGZyYWdtZW50OiBmcmFnbWVudCxcbiAgICB1bmlmb3JtczogdW5pZm9ybXMsIFxuICAgIGF0dHJpYnV0ZXM6IGF0dHJpYnV0ZXNcbiAgfTtcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gaW1nO1xuXG5mdW5jdGlvbiBpbWcgKHNyYywgb3B0LCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIG9wdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gb3B0XG4gICAgb3B0ID0gbnVsbFxuICB9XG5cblxuICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcbiAgdmFyIGxvY2tlZDtcblxuICBlbC5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGxvY2tlZCkgcmV0dXJuO1xuICAgIGxvY2tlZCA9IHRydWU7XG5cbiAgICBjYWxsYmFjayAmJiBjYWxsYmFjayh1bmRlZmluZWQsIGVsKTtcbiAgfTtcblxuICBlbC5vbmVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgIGlmIChsb2NrZWQpIHJldHVybjtcbiAgICBsb2NrZWQgPSB0cnVlO1xuXG4gICAgY2FsbGJhY2sgJiYgY2FsbGJhY2sobmV3IEVycm9yKCdVbmFibGUgdG8gbG9hZCBcIicgKyBzcmMgKyAnXCInKSwgZWwpO1xuICB9O1xuICBcbiAgaWYgKG9wdCAmJiBvcHQuY3Jvc3NPcmlnaW4pXG4gICAgZWwuY3Jvc3NPcmlnaW4gPSBvcHQuY3Jvc3NPcmlnaW47XG5cbiAgZWwuc3JjID0gc3JjO1xuXG4gIHJldHVybiBlbDtcbn1cbiIsImlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAvLyBpbXBsZW1lbnRhdGlvbiBmcm9tIHN0YW5kYXJkIG5vZGUuanMgJ3V0aWwnIG1vZHVsZVxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHtcbiAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICB9O1xufSBlbHNlIHtcbiAgLy8gb2xkIHNjaG9vbCBzaGltIGZvciBvbGQgYnJvd3NlcnNcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9XG4gICAgVGVtcEN0b3IucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZVxuICAgIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKClcbiAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3JcbiAgfVxufVxuIiwiZnVuY3Rpb24gbGVycCh2MCwgdjEsIHQpIHtcbiAgICByZXR1cm4gdjAqKDEtdCkrdjEqdFxufVxubW9kdWxlLmV4cG9ydHMgPSBsZXJwIiwidmFyIHh0ZW5kID0gcmVxdWlyZSgneHRlbmQnKVxuXG52YXIgZGVmYXVsdHMgPSB7XG5cdGVudW1lcmFibGU6IHRydWUsXG5cdGNvbmZpZ3VyYWJsZTogdHJ1ZVxufVxuXG5mdW5jdGlvbiBtaXgob2JqLCBlbnRyaWVzKSB7XG5cdGZvciAodmFyIGsgaW4gZW50cmllcykge1xuXHRcdGlmICghZW50cmllcy5oYXNPd25Qcm9wZXJ0eShrKSlcblx0XHRcdGNvbnRpbnVlXG5cdFx0dmFyIGYgPSBlbnRyaWVzW2tdXG5cdFx0aWYgKHR5cGVvZiBmID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRvYmpba10gPSBmXG5cdFx0fSBlbHNlIGlmIChmICYmIHR5cGVvZiBmID09PSAnb2JqZWN0Jykge1xuXHRcdFx0dmFyIGRlZiA9IHh0ZW5kKGRlZmF1bHRzLCBmKVxuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgaywgZGVmKTtcblx0XHR9XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBtaXhlcyhjdG9yLCBlbnRyaWVzKSB7XG5cdG1peChjdG9yLnByb3RvdHlwZSwgZW50cmllcylcbn1cblxubW9kdWxlLmV4cG9ydHMubWl4ID0gbWl4IiwidmFyIGJvdW5kcyA9IHJlcXVpcmUoJ2dldGJvdW5kaW5nYm94JylcbnZhciB1bmxlcnAgPSByZXF1aXJlKCd1bmxlcnAnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG5vcm1hbGl6ZShwYXRoLCBib3gpIHtcbiAgICB2YXIgYlxuICAgIGlmIChib3ggJiYgdHlwZW9mIGJveCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgYiA9IGJveFxuICAgIH0gZWxzZVxuICAgICAgICBiID0gYm91bmRzKHBhdGgpXG5cbiAgICAvL1RPRE86IGhtbSwgZG9lc24ndCByZWFsbHkgaGFuZGxlIGRpdiBieSB6ZXJvXG4gICAgLy9pbiBhbnkgc2FuZSBtYW5uZXJcblxuICAgIHZhciB3ID0gKGIubWF4WC1iLm1pblgpLFxuICAgICAgICBoID0gKGIubWF4WS1iLm1pblkpXG5cbiAgICB2YXIgYXNwZWN0WCA9IHc+aCA/IDEgOiBoL3csXG4gICAgICAgIGFzcGVjdFkgPSB3PmggPyB3L2ggOiAxXG5cbiAgICByZXR1cm4gcGF0aC5tYXAoZnVuY3Rpb24ocCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgcmFuZ2UoYi5taW5YLCBiLm1heFgsIHBbMF0pKjEvYXNwZWN0WCxcbiAgICAgICAgICAgIHJhbmdlKGIubWluWSwgYi5tYXhZLCBwWzFdKSoxL2FzcGVjdFlcbiAgICAgICAgXVxuICAgIH0pXG59XG5cbmZ1bmN0aW9uIHJhbmdlKG1pbiwgbWF4LCB2YWx1ZSkge1xuICAgIHJldHVybiAoKG1heC1taW49PT0wKSA/IDAgOiB1bmxlcnAobWluLCBtYXgsIHZhbHVlKSkqMi0xXG59IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiggcGF0aCwgYm94LCB4S2V5LCB5S2V5ICkge1xuICAgIHhLZXkgPSB0eXBlb2YgeEtleSA9PT0gJ3N0cmluZycgPyB4S2V5IDogMDtcbiAgICB5S2V5ID0gdHlwZW9mIHlLZXkgPT09ICdzdHJpbmcnID8geUtleSA6IDE7XG4gICAgaWYgKCFib3ggfHwgdHlwZW9mIGJveCA9PT0gJ251bWJlcicpXG4gICAgICAgIGJveCA9IHt9O1xuXG4gICAgYm94Lm1pblggPSBJbmZpbml0eTtcbiAgICBib3gubWluWSA9IEluZmluaXR5O1xuICAgIGJveC5tYXhYID0gLUluZmluaXR5O1xuICAgIGJveC5tYXhZID0gLUluZmluaXR5O1xuXG4gICAgZm9yICh2YXIgaT0wOyBpPHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHggPSBwYXRoW2ldWyB4S2V5IF0sXG4gICAgICAgICAgICB5ID0gcGF0aFtpXVsgeUtleSBdO1xuICAgICAgICBib3gubWluWCA9IE1hdGgubWluKCBib3gubWluWCwgeCApO1xuICAgICAgICBib3gubWluWSA9IE1hdGgubWluKCBib3gubWluWSwgeSApO1xuICAgICAgICBib3gubWF4WCA9IE1hdGgubWF4KCBib3gubWF4WCwgeCApO1xuICAgICAgICBib3gubWF4WSA9IE1hdGgubWF4KCBib3gubWF4WSwgeSApO1xuICAgIH1cbiAgICBcbiAgICBpZiAocGF0aC5sZW5ndGggPT09IDApIFxuICAgICAgICBib3gubWluWCA9IGJveC5tYXhYID0gYm94Lm1pblkgPSBib3gubWF4WSA9IDBcbiAgICByZXR1cm4gYm94O1xufTsiLCJcbm1vZHVsZS5leHBvcnRzID0gcGFyc2VcblxuLyoqXG4gKiBleHBlY3RlZCBhcmd1bWVudCBsZW5ndGhzXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5cbnZhciBsZW5ndGggPSB7YTogNywgYzogNiwgaDogMSwgbDogMiwgbTogMiwgcTogNCwgczogNCwgdDogMiwgdjogMSwgejogMH1cblxuLyoqXG4gKiBzZWdtZW50IHBhdHRlcm5cbiAqIEB0eXBlIHtSZWdFeHB9XG4gKi9cblxudmFyIHNlZ21lbnQgPSAvKFthc3R2enFtaGxjXSkoW15hc3R2enFtaGxjXSopL2lnXG5cbi8qKlxuICogcGFyc2UgYW4gc3ZnIHBhdGggZGF0YSBzdHJpbmcuIEdlbmVyYXRlcyBhbiBBcnJheVxuICogb2YgY29tbWFuZHMgd2hlcmUgZWFjaCBjb21tYW5kIGlzIGFuIEFycmF5IG9mIHRoZVxuICogZm9ybSBgW2NvbW1hbmQsIGFyZzEsIGFyZzIsIC4uLl1gXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlKHBhdGgpIHtcblx0dmFyIGRhdGEgPSBbXVxuXHRwYXRoLnJlcGxhY2Uoc2VnbWVudCwgZnVuY3Rpb24oXywgY29tbWFuZCwgYXJncyl7XG5cdFx0dmFyIHR5cGUgPSBjb21tYW5kLnRvTG93ZXJDYXNlKClcblx0XHRhcmdzID0gcGFyc2VWYWx1ZXMoYXJncylcblxuXHRcdC8vIG92ZXJsb2FkZWQgbW92ZVRvXG5cdFx0aWYgKHR5cGUgPT0gJ20nICYmIGFyZ3MubGVuZ3RoID4gMikge1xuXHRcdFx0ZGF0YS5wdXNoKFtjb21tYW5kXS5jb25jYXQoYXJncy5zcGxpY2UoMCwgMikpKVxuXHRcdFx0dHlwZSA9ICdsJ1xuXHRcdFx0Y29tbWFuZCA9IGNvbW1hbmQgPT0gJ20nID8gJ2wnIDogJ0wnXG5cdFx0fVxuXG5cdFx0d2hpbGUgKHRydWUpIHtcblx0XHRcdGlmIChhcmdzLmxlbmd0aCA9PSBsZW5ndGhbdHlwZV0pIHtcblx0XHRcdFx0YXJncy51bnNoaWZ0KGNvbW1hbmQpXG5cdFx0XHRcdHJldHVybiBkYXRhLnB1c2goYXJncylcblx0XHRcdH1cblx0XHRcdGlmIChhcmdzLmxlbmd0aCA8IGxlbmd0aFt0eXBlXSkgdGhyb3cgbmV3IEVycm9yKCdtYWxmb3JtZWQgcGF0aCBkYXRhJylcblx0XHRcdGRhdGEucHVzaChbY29tbWFuZF0uY29uY2F0KGFyZ3Muc3BsaWNlKDAsIGxlbmd0aFt0eXBlXSkpKVxuXHRcdH1cblx0fSlcblx0cmV0dXJuIGRhdGFcbn1cblxuZnVuY3Rpb24gcGFyc2VWYWx1ZXMoYXJncyl7XG5cdGFyZ3MgPSBhcmdzLm1hdGNoKC8tP1suMC05XSsoPzplWy0rXT9cXGQrKT8vaWcpXG5cdHJldHVybiBhcmdzID8gYXJncy5tYXAoTnVtYmVyKSA6IFtdXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHBsdWNrZXJcblxuZnVuY3Rpb24gcGx1Y2tlcihwYXRoLCBvYmplY3QpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPj0gMlxuICAgID8gcGx1Y2socGF0aCkob2JqZWN0KVxuICAgIDogcGx1Y2socGF0aClcbn1cblxuZnVuY3Rpb24gcGx1Y2socGF0aCkge1xuICBwYXRoID0gdHlwZW9mIHBhdGggPT09ICdzdHJpbmcnXG4gICAgPyBTdHJpbmcocGF0aCkudHJpbSgpLnNwbGl0KCcuJylcbiAgICA6IHBhdGhcblxuICBpZiAocGF0aC5sZW5ndGggPCAyKSB7XG4gICAgcGF0aCA9IHBhdGhbMF1cbiAgICByZXR1cm4gcGx1Y2tTaW5nbGVcbiAgfSBlbHNlIHtcbiAgICB2YXIgbCA9IHBhdGgubGVuZ3RoXG4gICAgcmV0dXJuIHBsdWNrUGF0aFxuICB9XG5cbiAgZnVuY3Rpb24gcGx1Y2tTaW5nbGUob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdFtwYXRoXVxuICB9XG5cbiAgZnVuY3Rpb24gcGx1Y2tQYXRoKG9iamVjdCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICBpZiAodHlwZW9mIG9iamVjdCA9PT0gJ3VuZGVmaW5lZCcpIGJyZWFrXG5cbiAgICAgIG9iamVjdCA9IG9iamVjdFtwYXRoW2ldXVxuICAgIH1cblxuICAgIHJldHVybiBvYmplY3RcbiAgfVxufVxuIiwiLypcclxuICogcmFmLmpzXHJcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9uZ3J5bWFuL3JhZi5qc1xyXG4gKlxyXG4gKiBvcmlnaW5hbCByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgcG9seWZpbGwgYnkgRXJpayBNw7ZsbGVyXHJcbiAqIGluc3BpcmVkIGZyb20gcGF1bF9pcmlzaCBnaXN0IGFuZCBwb3N0XHJcbiAqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxMyBuZ3J5bWFuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cclxuICovXHJcblxyXG4oZnVuY3Rpb24od2luZG93KSB7XHJcblx0dmFyIGxhc3RUaW1lID0gMCxcclxuXHRcdHZlbmRvcnMgPSBbJ3dlYmtpdCcsICdtb3onXSxcclxuXHRcdHJlcXVlc3RBbmltYXRpb25GcmFtZSA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUsXHJcblx0XHRjYW5jZWxBbmltYXRpb25GcmFtZSA9IHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSxcclxuXHRcdGkgPSB2ZW5kb3JzLmxlbmd0aDtcclxuXHJcblx0Ly8gdHJ5IHRvIHVuLXByZWZpeCBleGlzdGluZyByYWZcclxuXHR3aGlsZSAoLS1pID49IDAgJiYgIXJlcXVlc3RBbmltYXRpb25GcmFtZSkge1xyXG5cdFx0cmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gd2luZG93W3ZlbmRvcnNbaV0gKyAnUmVxdWVzdEFuaW1hdGlvbkZyYW1lJ107XHJcblx0XHRjYW5jZWxBbmltYXRpb25GcmFtZSA9IHdpbmRvd1t2ZW5kb3JzW2ldICsgJ0NhbmNlbEFuaW1hdGlvbkZyYW1lJ107XHJcblx0fVxyXG5cclxuXHQvLyBwb2x5ZmlsbCB3aXRoIHNldFRpbWVvdXQgZmFsbGJhY2tcclxuXHQvLyBoZWF2aWx5IGluc3BpcmVkIGZyb20gQGRhcml1cyBnaXN0IG1vZDogaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vcGF1bGlyaXNoLzE1Nzk2NzEjY29tbWVudC04Mzc5NDVcclxuXHRpZiAoIXJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCAhY2FuY2VsQW5pbWF0aW9uRnJhbWUpIHtcclxuXHRcdHJlcXVlc3RBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XHJcblx0XHRcdHZhciBub3cgPSArbmV3IERhdGUoKSwgbmV4dFRpbWUgPSBNYXRoLm1heChsYXN0VGltZSArIDE2LCBub3cpO1xyXG5cdFx0XHRyZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRjYWxsYmFjayhsYXN0VGltZSA9IG5leHRUaW1lKTtcclxuXHRcdFx0fSwgbmV4dFRpbWUgLSBub3cpO1xyXG5cdFx0fTtcclxuXHJcblx0XHRjYW5jZWxBbmltYXRpb25GcmFtZSA9IGNsZWFyVGltZW91dDtcclxuXHR9XHJcblxyXG5cdC8vIGV4cG9ydCB0byB3aW5kb3dcclxuXHR3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lO1xyXG5cdHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSA9IGNhbmNlbEFuaW1hdGlvbkZyYW1lO1xyXG59KHdpbmRvdykpO1xyXG4iLCJmdW5jdGlvbiByYW5kb20oc3RhcnQsIGVuZCkge1xuICAgIHZhciBuMCA9IHR5cGVvZiBzdGFydCA9PT0gJ251bWJlcicsXG4gICAgICAgIG4xID0gdHlwZW9mIGVuZCA9PT0gJ251bWJlcidcblxuICAgIGlmIChuMCAmJiAhbjEpIHtcbiAgICAgICAgZW5kID0gc3RhcnRcbiAgICAgICAgc3RhcnQgPSAwXG4gICAgfSBlbHNlIGlmICghbjAgJiYgIW4xKSB7XG4gICAgICAgIHN0YXJ0ID0gMFxuICAgICAgICBlbmQgPSAxXG4gICAgfVxuICAgIHJldHVybiBzdGFydCArIE1hdGgucmFuZG9tKCkgKiAoZW5kIC0gc3RhcnQpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmFuZG9tIiwiLy8gc3F1YXJlIGRpc3RhbmNlIGZyb20gYSBwb2ludCB0byBhIHNlZ21lbnRcbmZ1bmN0aW9uIGdldFNxU2VnRGlzdChwLCBwMSwgcDIpIHtcbiAgICB2YXIgeCA9IHAxWzBdLFxuICAgICAgICB5ID0gcDFbMV0sXG4gICAgICAgIGR4ID0gcDJbMF0gLSB4LFxuICAgICAgICBkeSA9IHAyWzFdIC0geTtcblxuICAgIGlmIChkeCAhPT0gMCB8fCBkeSAhPT0gMCkge1xuXG4gICAgICAgIHZhciB0ID0gKChwWzBdIC0geCkgKiBkeCArIChwWzFdIC0geSkgKiBkeSkgLyAoZHggKiBkeCArIGR5ICogZHkpO1xuXG4gICAgICAgIGlmICh0ID4gMSkge1xuICAgICAgICAgICAgeCA9IHAyWzBdO1xuICAgICAgICAgICAgeSA9IHAyWzFdO1xuXG4gICAgICAgIH0gZWxzZSBpZiAodCA+IDApIHtcbiAgICAgICAgICAgIHggKz0gZHggKiB0O1xuICAgICAgICAgICAgeSArPSBkeSAqIHQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkeCA9IHBbMF0gLSB4O1xuICAgIGR5ID0gcFsxXSAtIHk7XG5cbiAgICByZXR1cm4gZHggKiBkeCArIGR5ICogZHk7XG59XG5cbi8vIHNpbXBsaWZpY2F0aW9uIHVzaW5nIG9wdGltaXplZCBEb3VnbGFzLVBldWNrZXIgYWxnb3JpdGhtIHdpdGggcmVjdXJzaW9uIGVsaW1pbmF0aW9uXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNpbXBsaWZ5RG91Z2xhc1BldWNrZXIocG9pbnRzLCB0b2xlcmFuY2UpIHtcbiAgICBpZiAocG9pbnRzLmxlbmd0aDw9MSlcbiAgICAgICAgcmV0dXJuIHBvaW50cztcbiAgICB0b2xlcmFuY2UgPSB0eXBlb2YgdG9sZXJhbmNlID09PSAnbnVtYmVyJyA/IHRvbGVyYW5jZSA6IDE7XG4gICAgdmFyIHNxVG9sZXJhbmNlID0gdG9sZXJhbmNlICogdG9sZXJhbmNlO1xuXG4gICAgdmFyIGxlbiA9IHBvaW50cy5sZW5ndGgsXG4gICAgICAgIE1hcmtlckFycmF5ID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnID8gVWludDhBcnJheSA6IEFycmF5LFxuICAgICAgICBtYXJrZXJzID0gbmV3IE1hcmtlckFycmF5KGxlbiksXG4gICAgICAgIGZpcnN0ID0gMCxcbiAgICAgICAgbGFzdCA9IGxlbiAtIDEsXG4gICAgICAgIHN0YWNrID0gW10sXG4gICAgICAgIG5ld1BvaW50cyA9IFtdLFxuICAgICAgICBpLCBtYXhTcURpc3QsIHNxRGlzdCwgaW5kZXg7XG5cbiAgICBtYXJrZXJzW2ZpcnN0XSA9IG1hcmtlcnNbbGFzdF0gPSAxO1xuXG4gICAgd2hpbGUgKGxhc3QpIHtcblxuICAgICAgICBtYXhTcURpc3QgPSAwO1xuXG4gICAgICAgIGZvciAoaSA9IGZpcnN0ICsgMTsgaSA8IGxhc3Q7IGkrKykge1xuICAgICAgICAgICAgc3FEaXN0ID0gZ2V0U3FTZWdEaXN0KHBvaW50c1tpXSwgcG9pbnRzW2ZpcnN0XSwgcG9pbnRzW2xhc3RdKTtcblxuICAgICAgICAgICAgaWYgKHNxRGlzdCA+IG1heFNxRGlzdCkge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICBtYXhTcURpc3QgPSBzcURpc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWF4U3FEaXN0ID4gc3FUb2xlcmFuY2UpIHtcbiAgICAgICAgICAgIG1hcmtlcnNbaW5kZXhdID0gMTtcbiAgICAgICAgICAgIHN0YWNrLnB1c2goZmlyc3QsIGluZGV4LCBpbmRleCwgbGFzdCk7XG4gICAgICAgIH1cblxuICAgICAgICBsYXN0ID0gc3RhY2sucG9wKCk7XG4gICAgICAgIGZpcnN0ID0gc3RhY2sucG9wKCk7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmIChtYXJrZXJzW2ldKSBuZXdQb2ludHMucHVzaChwb2ludHNbaV0pO1xuICAgIH1cblxuICAgIHJldHVybiBuZXdQb2ludHM7XG59IiwidmFyIHNpbXBsaWZ5UmFkaWFsRGlzdCA9IHJlcXVpcmUoJy4vcmFkaWFsLWRpc3RhbmNlJylcbnZhciBzaW1wbGlmeURvdWdsYXNQZXVja2VyID0gcmVxdWlyZSgnLi9kb3VnbGFzLXBldWNrZXInKVxuXG4vL3NpbXBsaWZpZXMgdXNpbmcgYm90aCBhbGdvcml0aG1zXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNpbXBsaWZ5KHBvaW50cywgdG9sZXJhbmNlKSB7XG4gICAgcG9pbnRzID0gc2ltcGxpZnlSYWRpYWxEaXN0KHBvaW50cywgdG9sZXJhbmNlKTtcbiAgICBwb2ludHMgPSBzaW1wbGlmeURvdWdsYXNQZXVja2VyKHBvaW50cywgdG9sZXJhbmNlKTtcbiAgICByZXR1cm4gcG9pbnRzO1xufVxuXG5tb2R1bGUuZXhwb3J0cy5yYWRpYWxEaXN0YW5jZSA9IHNpbXBsaWZ5UmFkaWFsRGlzdDtcbm1vZHVsZS5leHBvcnRzLmRvdWdsYXNQZXVja2VyID0gc2ltcGxpZnlEb3VnbGFzUGV1Y2tlcjsiLCJmdW5jdGlvbiBnZXRTcURpc3QocDEsIHAyKSB7XG4gICAgdmFyIGR4ID0gcDFbMF0gLSBwMlswXSxcbiAgICAgICAgZHkgPSBwMVsxXSAtIHAyWzFdO1xuXG4gICAgcmV0dXJuIGR4ICogZHggKyBkeSAqIGR5O1xufVxuXG4vLyBiYXNpYyBkaXN0YW5jZS1iYXNlZCBzaW1wbGlmaWNhdGlvblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzaW1wbGlmeVJhZGlhbERpc3QocG9pbnRzLCB0b2xlcmFuY2UpIHtcbiAgICBpZiAocG9pbnRzLmxlbmd0aDw9MSlcbiAgICAgICAgcmV0dXJuIHBvaW50cztcbiAgICB0b2xlcmFuY2UgPSB0eXBlb2YgdG9sZXJhbmNlID09PSAnbnVtYmVyJyA/IHRvbGVyYW5jZSA6IDE7XG4gICAgdmFyIHNxVG9sZXJhbmNlID0gdG9sZXJhbmNlICogdG9sZXJhbmNlO1xuICAgIFxuICAgIHZhciBwcmV2UG9pbnQgPSBwb2ludHNbMF0sXG4gICAgICAgIG5ld1BvaW50cyA9IFtwcmV2UG9pbnRdLFxuICAgICAgICBwb2ludDtcblxuICAgIGZvciAodmFyIGkgPSAxLCBsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgcG9pbnQgPSBwb2ludHNbaV07XG5cbiAgICAgICAgaWYgKGdldFNxRGlzdChwb2ludCwgcHJldlBvaW50KSA+IHNxVG9sZXJhbmNlKSB7XG4gICAgICAgICAgICBuZXdQb2ludHMucHVzaChwb2ludCk7XG4gICAgICAgICAgICBwcmV2UG9pbnQgPSBwb2ludDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwcmV2UG9pbnQgIT09IHBvaW50KSBuZXdQb2ludHMucHVzaChwb2ludCk7XG5cbiAgICByZXR1cm4gbmV3UG9pbnRzO1xufSIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc21vb3Roc3RlcCAobWluLCBtYXgsIHZhbHVlKSB7XG4gIHZhciB4ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgKHZhbHVlLW1pbikvKG1heC1taW4pKSk7XG4gIHJldHVybiB4KngqKDMgLSAyKngpO1xufTtcbiIsInZhciBiZXppZXIgPSByZXF1aXJlKCdhZGFwdGl2ZS1iZXppZXItY3VydmUnKVxudmFyIGFicyA9IHJlcXVpcmUoJ2Ficy1zdmctcGF0aCcpXG52YXIgbm9ybSA9IHJlcXVpcmUoJ25vcm1hbGl6ZS1zdmctcGF0aCcpXG52YXIgY29weSA9IHJlcXVpcmUoJ3ZlYzItY29weScpXG5cbmZ1bmN0aW9uIHNldChvdXQsIHgsIHkpIHtcbiAgICBvdXRbMF0gPSB4XG4gICAgb3V0WzFdID0geVxuICAgIHJldHVybiBvdXRcbn1cblxudmFyIHRtcDEgPSBbMCwwXSxcbiAgICB0bXAyID0gWzAsMF0sXG4gICAgdG1wMyA9IFswLDBdXG5cbmZ1bmN0aW9uIGJlemllclRvKHBvaW50cywgc2NhbGUsIHN0YXJ0LCBzZWcpIHtcbiAgICBiZXppZXIoc3RhcnQsIFxuICAgICAgICBzZXQodG1wMSwgc2VnWzFdLCBzZWdbMl0pLCBcbiAgICAgICAgc2V0KHRtcDIsIHNlZ1szXSwgc2VnWzRdKSxcbiAgICAgICAgc2V0KHRtcDMsIHNlZ1s1XSwgc2VnWzZdKSwgc2NhbGUsIHBvaW50cylcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjb250b3VycyhzdmcsIHNjYWxlKSB7XG4gICAgdmFyIHBhdGhzID0gW11cblxuICAgIHZhciBwb2ludHMgPSBbXVxuICAgIHZhciBwZW4gPSBbMCwgMF1cbiAgICBub3JtKGFicyhzdmcpKS5mb3JFYWNoKGZ1bmN0aW9uKHNlZ21lbnQsIGksIHNlbGYpIHtcbiAgICAgICAgaWYgKHNlZ21lbnRbMF0gPT09ICdNJykge1xuICAgICAgICAgICAgY29weShwZW4sIHNlZ21lbnQuc2xpY2UoMSkpXG4gICAgICAgICAgICBpZiAocG9pbnRzLmxlbmd0aD4wKSB7XG4gICAgICAgICAgICAgICAgcGF0aHMucHVzaChwb2ludHMpXG4gICAgICAgICAgICAgICAgcG9pbnRzID0gW11cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvaW50cy5wdXNoKHBlbilcbiAgICAgICAgfSBlbHNlIGlmIChzZWdtZW50WzBdID09PSAnQycpIHtcbiAgICAgICAgICAgIGJlemllclRvKHBvaW50cywgc2NhbGUsIHBlbiwgc2VnbWVudClcbiAgICAgICAgICAgIHNldChwZW4sIHNlZ21lbnRbNV0sIHNlZ21lbnRbNl0pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lsbGVnYWwgdHlwZSBpbiBTVkc6ICcrc2VnbWVudFswXSlcbiAgICAgICAgfVxuICAgIH0pXG4gICAgaWYgKHBvaW50cy5sZW5ndGg+MClcbiAgICAgICAgcGF0aHMucHVzaChwb2ludHMpXG4gICAgcmV0dXJuIHBhdGhzXG59IiwiXG5tb2R1bGUuZXhwb3J0cyA9IGFic29sdXRpemVcblxuLyoqXG4gKiByZWRlZmluZSBgcGF0aGAgd2l0aCBhYnNvbHV0ZSBjb29yZGluYXRlc1xuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHBhdGhcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5cbmZ1bmN0aW9uIGFic29sdXRpemUocGF0aCl7XG5cdHZhciBzdGFydFggPSAwXG5cdHZhciBzdGFydFkgPSAwXG5cdHZhciB4ID0gMFxuXHR2YXIgeSA9IDBcblxuXHRyZXR1cm4gcGF0aC5tYXAoZnVuY3Rpb24oc2VnKXtcblx0XHRzZWcgPSBzZWcuc2xpY2UoKVxuXHRcdHZhciB0eXBlID0gc2VnWzBdXG5cdFx0dmFyIGNvbW1hbmQgPSB0eXBlLnRvVXBwZXJDYXNlKClcblxuXHRcdC8vIGlzIHJlbGF0aXZlXG5cdFx0aWYgKHR5cGUgIT0gY29tbWFuZCkge1xuXHRcdFx0c2VnWzBdID0gY29tbWFuZFxuXHRcdFx0c3dpdGNoICh0eXBlKSB7XG5cdFx0XHRcdGNhc2UgJ2EnOlxuXHRcdFx0XHRcdHNlZ1s2XSArPSB4XG5cdFx0XHRcdFx0c2VnWzddICs9IHlcblx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHRjYXNlICd2Jzpcblx0XHRcdFx0XHRzZWdbMV0gKz0geVxuXHRcdFx0XHRcdGJyZWFrXG5cdFx0XHRcdGNhc2UgJ2gnOlxuXHRcdFx0XHRcdHNlZ1sxXSArPSB4XG5cdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRmb3IgKHZhciBpID0gMTsgaSA8IHNlZy5sZW5ndGg7KSB7XG5cdFx0XHRcdFx0XHRzZWdbaSsrXSArPSB4XG5cdFx0XHRcdFx0XHRzZWdbaSsrXSArPSB5XG5cdFx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIHVwZGF0ZSBjdXJzb3Igc3RhdGVcblx0XHRzd2l0Y2ggKGNvbW1hbmQpIHtcblx0XHRcdGNhc2UgJ1onOlxuXHRcdFx0XHR4ID0gc3RhcnRYXG5cdFx0XHRcdHkgPSBzdGFydFlcblx0XHRcdFx0YnJlYWtcblx0XHRcdGNhc2UgJ0gnOlxuXHRcdFx0XHR4ID0gc2VnWzFdXG5cdFx0XHRcdGJyZWFrXG5cdFx0XHRjYXNlICdWJzpcblx0XHRcdFx0eSA9IHNlZ1sxXVxuXHRcdFx0XHRicmVha1xuXHRcdFx0Y2FzZSAnTSc6XG5cdFx0XHRcdHggPSBzdGFydFggPSBzZWdbMV1cblx0XHRcdFx0eSA9IHN0YXJ0WSA9IHNlZ1syXVxuXHRcdFx0XHRicmVha1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0eCA9IHNlZ1tzZWcubGVuZ3RoIC0gMl1cblx0XHRcdFx0eSA9IHNlZ1tzZWcubGVuZ3RoIC0gMV1cblx0XHR9XG5cblx0XHRyZXR1cm4gc2VnXG5cdH0pXG59XG4iLCJmdW5jdGlvbiBjbG9uZShwb2ludCkgeyAvL1RPRE86IHVzZSBnbC12ZWMyIGZvciB0aGlzXG4gICAgcmV0dXJuIFtwb2ludFswXSwgcG9pbnRbMV1dXG59XG5cbmZ1bmN0aW9uIHZlYzIoeCwgeSkge1xuICAgIHJldHVybiBbeCwgeV1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjcmVhdGVCZXppZXJCdWlsZGVyKG9wdCkge1xuICAgIG9wdCA9IG9wdHx8e31cblxuICAgIHZhciBSRUNVUlNJT05fTElNSVQgPSB0eXBlb2Ygb3B0LnJlY3Vyc2lvbiA9PT0gJ251bWJlcicgPyBvcHQucmVjdXJzaW9uIDogOFxuICAgIHZhciBGTFRfRVBTSUxPTiA9IHR5cGVvZiBvcHQuZXBzaWxvbiA9PT0gJ251bWJlcicgPyBvcHQuZXBzaWxvbiA6IDEuMTkyMDkyOTBlLTdcbiAgICB2YXIgUEFUSF9ESVNUQU5DRV9FUFNJTE9OID0gdHlwZW9mIG9wdC5wYXRoRXBzaWxvbiA9PT0gJ251bWJlcicgPyBvcHQucGF0aEVwc2lsb24gOiAxLjBcblxuICAgIHZhciBjdXJ2ZV9hbmdsZV90b2xlcmFuY2VfZXBzaWxvbiA9IHR5cGVvZiBvcHQuYW5nbGVFcHNpbG9uID09PSAnbnVtYmVyJyA/IG9wdC5hbmdsZUVwc2lsb24gOiAwLjAxXG4gICAgdmFyIG1fYW5nbGVfdG9sZXJhbmNlID0gb3B0LmFuZ2xlVG9sZXJhbmNlIHx8IDBcbiAgICB2YXIgbV9jdXNwX2xpbWl0ID0gb3B0LmN1c3BMaW1pdCB8fCAwXG5cbiAgICByZXR1cm4gZnVuY3Rpb24gYmV6aWVyQ3VydmUoc3RhcnQsIGMxLCBjMiwgZW5kLCBzY2FsZSwgcG9pbnRzKSB7XG4gICAgICAgIGlmICghcG9pbnRzKVxuICAgICAgICAgICAgcG9pbnRzID0gW11cblxuICAgICAgICBzY2FsZSA9IHR5cGVvZiBzY2FsZSA9PT0gJ251bWJlcicgPyBzY2FsZSA6IDEuMFxuICAgICAgICB2YXIgZGlzdGFuY2VUb2xlcmFuY2UgPSBQQVRIX0RJU1RBTkNFX0VQU0lMT04gLyBzY2FsZVxuICAgICAgICBkaXN0YW5jZVRvbGVyYW5jZSAqPSBkaXN0YW5jZVRvbGVyYW5jZVxuICAgICAgICBiZWdpbihzdGFydCwgYzEsIGMyLCBlbmQsIHBvaW50cywgZGlzdGFuY2VUb2xlcmFuY2UpXG4gICAgICAgIHJldHVybiBwb2ludHNcbiAgICB9XG5cblxuICAgIC8vLy8vLyBCYXNlZCBvbjpcbiAgICAvLy8vLy8gaHR0cHM6Ly9naXRodWIuY29tL3BlbHNvbi9hbnRpZ3JhaW4vYmxvYi9tYXN0ZXIvYWdnLTIuNC9zcmMvYWdnX2N1cnZlcy5jcHBcblxuICAgIGZ1bmN0aW9uIGJlZ2luKHN0YXJ0LCBjMSwgYzIsIGVuZCwgcG9pbnRzLCBkaXN0YW5jZVRvbGVyYW5jZSkge1xuICAgICAgICBwb2ludHMucHVzaChjbG9uZShzdGFydCkpXG4gICAgICAgIHZhciB4MSA9IHN0YXJ0WzBdLFxuICAgICAgICAgICAgeTEgPSBzdGFydFsxXSxcbiAgICAgICAgICAgIHgyID0gYzFbMF0sXG4gICAgICAgICAgICB5MiA9IGMxWzFdLFxuICAgICAgICAgICAgeDMgPSBjMlswXSxcbiAgICAgICAgICAgIHkzID0gYzJbMV0sXG4gICAgICAgICAgICB4NCA9IGVuZFswXSxcbiAgICAgICAgICAgIHk0ID0gZW5kWzFdXG4gICAgICAgIHJlY3Vyc2l2ZSh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCB4NCwgeTQsIHBvaW50cywgZGlzdGFuY2VUb2xlcmFuY2UsIDApXG4gICAgICAgIHBvaW50cy5wdXNoKGNsb25lKGVuZCkpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVjdXJzaXZlKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIHg0LCB5NCwgcG9pbnRzLCBkaXN0YW5jZVRvbGVyYW5jZSwgbGV2ZWwpIHtcbiAgICAgICAgaWYobGV2ZWwgPiBSRUNVUlNJT05fTElNSVQpIFxuICAgICAgICAgICAgcmV0dXJuXG5cbiAgICAgICAgdmFyIHBpID0gTWF0aC5QSVxuXG4gICAgICAgIC8vIENhbGN1bGF0ZSBhbGwgdGhlIG1pZC1wb2ludHMgb2YgdGhlIGxpbmUgc2VnbWVudHNcbiAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIHZhciB4MTIgICA9ICh4MSArIHgyKSAvIDJcbiAgICAgICAgdmFyIHkxMiAgID0gKHkxICsgeTIpIC8gMlxuICAgICAgICB2YXIgeDIzICAgPSAoeDIgKyB4MykgLyAyXG4gICAgICAgIHZhciB5MjMgICA9ICh5MiArIHkzKSAvIDJcbiAgICAgICAgdmFyIHgzNCAgID0gKHgzICsgeDQpIC8gMlxuICAgICAgICB2YXIgeTM0ICAgPSAoeTMgKyB5NCkgLyAyXG4gICAgICAgIHZhciB4MTIzICA9ICh4MTIgKyB4MjMpIC8gMlxuICAgICAgICB2YXIgeTEyMyAgPSAoeTEyICsgeTIzKSAvIDJcbiAgICAgICAgdmFyIHgyMzQgID0gKHgyMyArIHgzNCkgLyAyXG4gICAgICAgIHZhciB5MjM0ICA9ICh5MjMgKyB5MzQpIC8gMlxuICAgICAgICB2YXIgeDEyMzQgPSAoeDEyMyArIHgyMzQpIC8gMlxuICAgICAgICB2YXIgeTEyMzQgPSAoeTEyMyArIHkyMzQpIC8gMlxuXG4gICAgICAgIGlmKGxldmVsID4gMCkgeyAvLyBFbmZvcmNlIHN1YmRpdmlzaW9uIGZpcnN0IHRpbWVcbiAgICAgICAgICAgIC8vIFRyeSB0byBhcHByb3hpbWF0ZSB0aGUgZnVsbCBjdWJpYyBjdXJ2ZSBieSBhIHNpbmdsZSBzdHJhaWdodCBsaW5lXG4gICAgICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgdmFyIGR4ID0geDQteDFcbiAgICAgICAgICAgIHZhciBkeSA9IHk0LXkxXG5cbiAgICAgICAgICAgIHZhciBkMiA9IE1hdGguYWJzKCh4MiAtIHg0KSAqIGR5IC0gKHkyIC0geTQpICogZHgpXG4gICAgICAgICAgICB2YXIgZDMgPSBNYXRoLmFicygoeDMgLSB4NCkgKiBkeSAtICh5MyAtIHk0KSAqIGR4KVxuXG4gICAgICAgICAgICB2YXIgZGExLCBkYTJcblxuICAgICAgICAgICAgaWYoZDIgPiBGTFRfRVBTSUxPTiAmJiBkMyA+IEZMVF9FUFNJTE9OKSB7XG4gICAgICAgICAgICAgICAgLy8gUmVndWxhciBjYXJlXG4gICAgICAgICAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgICAgIGlmKChkMiArIGQzKSooZDIgKyBkMykgPD0gZGlzdGFuY2VUb2xlcmFuY2UgKiAoZHgqZHggKyBkeSpkeSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIGN1cnZhdHVyZSBkb2Vzbid0IGV4Y2VlZCB0aGUgZGlzdGFuY2VUb2xlcmFuY2UgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgLy8gd2UgdGVuZCB0byBmaW5pc2ggc3ViZGl2aXNpb25zLlxuICAgICAgICAgICAgICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgICAgICAgICAgaWYobV9hbmdsZV90b2xlcmFuY2UgPCBjdXJ2ZV9hbmdsZV90b2xlcmFuY2VfZXBzaWxvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2godmVjMih4MTIzNCwgeTEyMzQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBBbmdsZSAmIEN1c3AgQ29uZGl0aW9uXG4gICAgICAgICAgICAgICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgICAgICAgICB2YXIgYTIzID0gTWF0aC5hdGFuMih5MyAtIHkyLCB4MyAtIHgyKVxuICAgICAgICAgICAgICAgICAgICBkYTEgPSBNYXRoLmFicyhhMjMgLSBNYXRoLmF0YW4yKHkyIC0geTEsIHgyIC0geDEpKVxuICAgICAgICAgICAgICAgICAgICBkYTIgPSBNYXRoLmFicyhNYXRoLmF0YW4yKHk0IC0geTMsIHg0IC0geDMpIC0gYTIzKVxuICAgICAgICAgICAgICAgICAgICBpZihkYTEgPj0gcGkpIGRhMSA9IDIqcGkgLSBkYTFcbiAgICAgICAgICAgICAgICAgICAgaWYoZGEyID49IHBpKSBkYTIgPSAyKnBpIC0gZGEyXG5cbiAgICAgICAgICAgICAgICAgICAgaWYoZGExICsgZGEyIDwgbV9hbmdsZV90b2xlcmFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpbmFsbHkgd2UgY2FuIHN0b3AgdGhlIHJlY3Vyc2lvblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaCh2ZWMyKHgxMjM0LCB5MTIzNCkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmKG1fY3VzcF9saW1pdCAhPT0gMC4wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihkYTEgPiBtX2N1c3BfbGltaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaCh2ZWMyKHgyLCB5MikpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGRhMiA+IG1fY3VzcF9saW1pdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKHZlYzIoeDMsIHkzKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmKGQyID4gRkxUX0VQU0lMT04pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcDEscDMscDQgYXJlIGNvbGxpbmVhciwgcDIgaXMgY29uc2lkZXJhYmxlXG4gICAgICAgICAgICAgICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgICAgICAgICBpZihkMiAqIGQyIDw9IGRpc3RhbmNlVG9sZXJhbmNlICogKGR4KmR4ICsgZHkqZHkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihtX2FuZ2xlX3RvbGVyYW5jZSA8IGN1cnZlX2FuZ2xlX3RvbGVyYW5jZV9lcHNpbG9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2godmVjMih4MTIzNCwgeTEyMzQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBbmdsZSBDb25kaXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgICAgICAgICAgICAgZGExID0gTWF0aC5hYnMoTWF0aC5hdGFuMih5MyAtIHkyLCB4MyAtIHgyKSAtIE1hdGguYXRhbjIoeTIgLSB5MSwgeDIgLSB4MSkpXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihkYTEgPj0gcGkpIGRhMSA9IDIqcGkgLSBkYTFcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoZGExIDwgbV9hbmdsZV90b2xlcmFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaCh2ZWMyKHgyLCB5MikpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2godmVjMih4MywgeTMpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihtX2N1c3BfbGltaXQgIT09IDAuMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGRhMSA+IG1fY3VzcF9saW1pdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaCh2ZWMyKHgyLCB5MikpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmKGQzID4gRkxUX0VQU0lMT04pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcDEscDIscDQgYXJlIGNvbGxpbmVhciwgcDMgaXMgY29uc2lkZXJhYmxlXG4gICAgICAgICAgICAgICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgICAgICAgICBpZihkMyAqIGQzIDw9IGRpc3RhbmNlVG9sZXJhbmNlICogKGR4KmR4ICsgZHkqZHkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihtX2FuZ2xlX3RvbGVyYW5jZSA8IGN1cnZlX2FuZ2xlX3RvbGVyYW5jZV9lcHNpbG9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2godmVjMih4MTIzNCwgeTEyMzQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBbmdsZSBDb25kaXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgICAgICAgICAgICAgZGExID0gTWF0aC5hYnMoTWF0aC5hdGFuMih5NCAtIHkzLCB4NCAtIHgzKSAtIE1hdGguYXRhbjIoeTMgLSB5MiwgeDMgLSB4MikpXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihkYTEgPj0gcGkpIGRhMSA9IDIqcGkgLSBkYTFcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoZGExIDwgbV9hbmdsZV90b2xlcmFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaCh2ZWMyKHgyLCB5MikpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2godmVjMih4MywgeTMpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihtX2N1c3BfbGltaXQgIT09IDAuMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGRhMSA+IG1fY3VzcF9saW1pdClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKHZlYzIoeDMsIHkzKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBDb2xsaW5lYXIgY2FzZVxuICAgICAgICAgICAgICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgICAgICAgICAgICAgIGR4ID0geDEyMzQgLSAoeDEgKyB4NCkgLyAyXG4gICAgICAgICAgICAgICAgICAgIGR5ID0geTEyMzQgLSAoeTEgKyB5NCkgLyAyXG4gICAgICAgICAgICAgICAgICAgIGlmKGR4KmR4ICsgZHkqZHkgPD0gZGlzdGFuY2VUb2xlcmFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKHZlYzIoeDEyMzQsIHkxMjM0KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ29udGludWUgc3ViZGl2aXNpb25cbiAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIHJlY3Vyc2l2ZSh4MSwgeTEsIHgxMiwgeTEyLCB4MTIzLCB5MTIzLCB4MTIzNCwgeTEyMzQsIHBvaW50cywgZGlzdGFuY2VUb2xlcmFuY2UsIGxldmVsICsgMSkgXG4gICAgICAgIHJlY3Vyc2l2ZSh4MTIzNCwgeTEyMzQsIHgyMzQsIHkyMzQsIHgzNCwgeTM0LCB4NCwgeTQsIHBvaW50cywgZGlzdGFuY2VUb2xlcmFuY2UsIGxldmVsICsgMSkgXG4gICAgfVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Z1bmN0aW9uJykoKSIsIlxudmFyIM+AID0gTWF0aC5QSVxudmFyIF8xMjAgPSByYWRpYW5zKDEyMClcblxubW9kdWxlLmV4cG9ydHMgPSBub3JtYWxpemVcblxuLyoqXG4gKiBkZXNjcmliZSBgcGF0aGAgaW4gdGVybXMgb2YgY3ViaWMgYsOpemllciBcbiAqIGN1cnZlcyBhbmQgbW92ZSBjb21tYW5kc1xuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHBhdGhcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZShwYXRoKXtcblx0Ly8gaW5pdCBzdGF0ZVxuXHR2YXIgcHJldlxuXHR2YXIgcmVzdWx0ID0gW11cblx0dmFyIGJlemllclggPSAwXG5cdHZhciBiZXppZXJZID0gMFxuXHR2YXIgc3RhcnRYID0gMFxuXHR2YXIgc3RhcnRZID0gMFxuXHR2YXIgcXVhZFggPSBudWxsXG5cdHZhciBxdWFkWSA9IG51bGxcblx0dmFyIHggPSAwXG5cdHZhciB5ID0gMFxuXG5cdGZvciAodmFyIGkgPSAwLCBsZW4gPSBwYXRoLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0dmFyIHNlZyA9IHBhdGhbaV1cblx0XHR2YXIgY29tbWFuZCA9IHNlZ1swXVxuXHRcdHN3aXRjaCAoY29tbWFuZCkge1xuXHRcdFx0Y2FzZSAnTSc6XG5cdFx0XHRcdHN0YXJ0WCA9IHNlZ1sxXVxuXHRcdFx0XHRzdGFydFkgPSBzZWdbMl1cblx0XHRcdFx0YnJlYWtcblx0XHRcdGNhc2UgJ0EnOlxuXHRcdFx0XHRzZWcgPSBhcmMoeCwgeSxzZWdbMV0sc2VnWzJdLHJhZGlhbnMoc2VnWzNdKSxzZWdbNF0sc2VnWzVdLHNlZ1s2XSxzZWdbN10pXG5cdFx0XHRcdC8vIHNwbGl0IG11bHRpIHBhcnRcblx0XHRcdFx0c2VnLnVuc2hpZnQoJ0MnKVxuXHRcdFx0XHRpZiAoc2VnLmxlbmd0aCA+IDcpIHtcblx0XHRcdFx0XHRyZXN1bHQucHVzaChzZWcuc3BsaWNlKDAsIDcpKVxuXHRcdFx0XHRcdHNlZy51bnNoaWZ0KCdDJylcblx0XHRcdFx0fVxuXHRcdFx0XHRicmVha1xuXHRcdFx0Y2FzZSAnUyc6XG5cdFx0XHRcdC8vIGRlZmF1bHQgY29udHJvbCBwb2ludFxuXHRcdFx0XHR2YXIgY3ggPSB4XG5cdFx0XHRcdHZhciBjeSA9IHlcblx0XHRcdFx0aWYgKHByZXYgPT0gJ0MnIHx8IHByZXYgPT0gJ1MnKSB7XG5cdFx0XHRcdFx0Y3ggKz0gY3ggLSBiZXppZXJYIC8vIHJlZmxlY3QgdGhlIHByZXZpb3VzIGNvbW1hbmQncyBjb250cm9sXG5cdFx0XHRcdFx0Y3kgKz0gY3kgLSBiZXppZXJZIC8vIHBvaW50IHJlbGF0aXZlIHRvIHRoZSBjdXJyZW50IHBvaW50XG5cdFx0XHRcdH1cblx0XHRcdFx0c2VnID0gWydDJywgY3gsIGN5LCBzZWdbMV0sIHNlZ1syXSwgc2VnWzNdLCBzZWdbNF1dXG5cdFx0XHRcdGJyZWFrXG5cdFx0XHRjYXNlICdUJzpcblx0XHRcdFx0aWYgKHByZXYgPT0gJ1EnIHx8IHByZXYgPT0gJ1QnKSB7XG5cdFx0XHRcdFx0cXVhZFggPSB4ICogMiAtIHF1YWRYIC8vIGFzIHdpdGggJ1MnIHJlZmxlY3QgcHJldmlvdXMgY29udHJvbCBwb2ludFxuXHRcdFx0XHRcdHF1YWRZID0geSAqIDIgLSBxdWFkWVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHF1YWRYID0geFxuXHRcdFx0XHRcdHF1YWRZID0geVxuXHRcdFx0XHR9XG5cdFx0XHRcdHNlZyA9IHF1YWRyYXRpYyh4LCB5LCBxdWFkWCwgcXVhZFksIHNlZ1sxXSwgc2VnWzJdKVxuXHRcdFx0XHRicmVha1xuXHRcdFx0Y2FzZSAnUSc6XG5cdFx0XHRcdHF1YWRYID0gc2VnWzFdXG5cdFx0XHRcdHF1YWRZID0gc2VnWzJdXG5cdFx0XHRcdHNlZyA9IHF1YWRyYXRpYyh4LCB5LCBzZWdbMV0sIHNlZ1syXSwgc2VnWzNdLCBzZWdbNF0pXG5cdFx0XHRcdGJyZWFrXG5cdFx0XHRjYXNlICdMJzpcblx0XHRcdFx0c2VnID0gbGluZSh4LCB5LCBzZWdbMV0sIHNlZ1syXSlcblx0XHRcdFx0YnJlYWtcblx0XHRcdGNhc2UgJ0gnOlxuXHRcdFx0XHRzZWcgPSBsaW5lKHgsIHksIHNlZ1sxXSwgeSlcblx0XHRcdFx0YnJlYWtcblx0XHRcdGNhc2UgJ1YnOlxuXHRcdFx0XHRzZWcgPSBsaW5lKHgsIHksIHgsIHNlZ1sxXSlcblx0XHRcdFx0YnJlYWtcblx0XHRcdGNhc2UgJ1onOlxuXHRcdFx0XHRzZWcgPSBsaW5lKHgsIHksIHN0YXJ0WCwgc3RhcnRZKVxuXHRcdFx0XHRicmVha1xuXHRcdH1cblxuXHRcdC8vIHVwZGF0ZSBzdGF0ZVxuXHRcdHByZXYgPSBjb21tYW5kXG5cdFx0eCA9IHNlZ1tzZWcubGVuZ3RoIC0gMl1cblx0XHR5ID0gc2VnW3NlZy5sZW5ndGggLSAxXVxuXHRcdGlmIChzZWcubGVuZ3RoID4gNCkge1xuXHRcdFx0YmV6aWVyWCA9IHNlZ1tzZWcubGVuZ3RoIC0gNF1cblx0XHRcdGJlemllclkgPSBzZWdbc2VnLmxlbmd0aCAtIDNdXG5cdFx0fSBlbHNlIHtcblx0XHRcdGJlemllclggPSB4XG5cdFx0XHRiZXppZXJZID0geVxuXHRcdH1cblx0XHRyZXN1bHQucHVzaChzZWcpXG5cdH1cblxuXHRyZXR1cm4gcmVzdWx0XG59XG5cbmZ1bmN0aW9uIGxpbmUoeDEsIHkxLCB4MiwgeTIpe1xuXHRyZXR1cm4gWydDJywgeDEsIHkxLCB4MiwgeTIsIHgyLCB5Ml1cbn1cblxuZnVuY3Rpb24gcXVhZHJhdGljKHgxLCB5MSwgY3gsIGN5LCB4MiwgeTIpe1xuXHRyZXR1cm4gW1xuXHRcdCdDJyxcblx0XHR4MS8zICsgKDIvMykgKiBjeCxcblx0XHR5MS8zICsgKDIvMykgKiBjeSxcblx0XHR4Mi8zICsgKDIvMykgKiBjeCxcblx0XHR5Mi8zICsgKDIvMykgKiBjeSxcblx0XHR4Mixcblx0XHR5MlxuXHRdXG59XG5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgcmlwcGVkIGZyb20gXG4vLyBnaXRodWIuY29tL0RtaXRyeUJhcmFub3Zza2l5L3JhcGhhZWwvYmxvYi80ZDk3ZDQvcmFwaGFlbC5qcyNMMjIxNi1MMjMwNCBcbi8vIHdoaWNoIHJlZmVyZW5jZXMgdzMub3JnL1RSL1NWRzExL2ltcGxub3RlLmh0bWwjQXJjSW1wbGVtZW50YXRpb25Ob3Rlc1xuLy8gVE9ETzogbWFrZSBpdCBodW1hbiByZWFkYWJsZVxuXG5mdW5jdGlvbiBhcmMoeDEsIHkxLCByeCwgcnksIGFuZ2xlLCBsYXJnZV9hcmNfZmxhZywgc3dlZXBfZmxhZywgeDIsIHkyLCByZWN1cnNpdmUpIHtcblx0aWYgKCFyZWN1cnNpdmUpIHtcblx0XHR2YXIgeHkgPSByb3RhdGUoeDEsIHkxLCAtYW5nbGUpXG5cdFx0eDEgPSB4eS54XG5cdFx0eTEgPSB4eS55XG5cdFx0eHkgPSByb3RhdGUoeDIsIHkyLCAtYW5nbGUpXG5cdFx0eDIgPSB4eS54XG5cdFx0eTIgPSB4eS55XG5cdFx0dmFyIHggPSAoeDEgLSB4MikgLyAyXG5cdFx0dmFyIHkgPSAoeTEgLSB5MikgLyAyXG5cdFx0dmFyIGggPSAoeCAqIHgpIC8gKHJ4ICogcngpICsgKHkgKiB5KSAvIChyeSAqIHJ5KVxuXHRcdGlmIChoID4gMSkge1xuXHRcdFx0aCA9IE1hdGguc3FydChoKVxuXHRcdFx0cnggPSBoICogcnhcblx0XHRcdHJ5ID0gaCAqIHJ5XG5cdFx0fVxuXHRcdHZhciByeDIgPSByeCAqIHJ4XG5cdFx0dmFyIHJ5MiA9IHJ5ICogcnlcblx0XHR2YXIgayA9IChsYXJnZV9hcmNfZmxhZyA9PSBzd2VlcF9mbGFnID8gLTEgOiAxKVxuXHRcdFx0KiBNYXRoLnNxcnQoTWF0aC5hYnMoKHJ4MiAqIHJ5MiAtIHJ4MiAqIHkgKiB5IC0gcnkyICogeCAqIHgpIC8gKHJ4MiAqIHkgKiB5ICsgcnkyICogeCAqIHgpKSlcblx0XHRpZiAoayA9PSBJbmZpbml0eSkgayA9IDEgLy8gbmV1dHJhbGl6ZVxuXHRcdHZhciBjeCA9IGsgKiByeCAqIHkgLyByeSArICh4MSArIHgyKSAvIDJcblx0XHR2YXIgY3kgPSBrICogLXJ5ICogeCAvIHJ4ICsgKHkxICsgeTIpIC8gMlxuXHRcdHZhciBmMSA9IE1hdGguYXNpbigoKHkxIC0gY3kpIC8gcnkpLnRvRml4ZWQoOSkpXG5cdFx0dmFyIGYyID0gTWF0aC5hc2luKCgoeTIgLSBjeSkgLyByeSkudG9GaXhlZCg5KSlcblxuXHRcdGYxID0geDEgPCBjeCA/IM+AIC0gZjEgOiBmMVxuXHRcdGYyID0geDIgPCBjeCA/IM+AIC0gZjIgOiBmMlxuXHRcdGlmIChmMSA8IDApIGYxID0gz4AgKiAyICsgZjFcblx0XHRpZiAoZjIgPCAwKSBmMiA9IM+AICogMiArIGYyXG5cdFx0aWYgKHN3ZWVwX2ZsYWcgJiYgZjEgPiBmMikgZjEgPSBmMSAtIM+AICogMlxuXHRcdGlmICghc3dlZXBfZmxhZyAmJiBmMiA+IGYxKSBmMiA9IGYyIC0gz4AgKiAyXG5cdH0gZWxzZSB7XG5cdFx0ZjEgPSByZWN1cnNpdmVbMF1cblx0XHRmMiA9IHJlY3Vyc2l2ZVsxXVxuXHRcdGN4ID0gcmVjdXJzaXZlWzJdXG5cdFx0Y3kgPSByZWN1cnNpdmVbM11cblx0fVxuXHQvLyBncmVhdGVyIHRoYW4gMTIwIGRlZ3JlZXMgcmVxdWlyZXMgbXVsdGlwbGUgc2VnbWVudHNcblx0aWYgKE1hdGguYWJzKGYyIC0gZjEpID4gXzEyMCkge1xuXHRcdHZhciBmMm9sZCA9IGYyXG5cdFx0dmFyIHgyb2xkID0geDJcblx0XHR2YXIgeTJvbGQgPSB5MlxuXHRcdGYyID0gZjEgKyBfMTIwICogKHN3ZWVwX2ZsYWcgJiYgZjIgPiBmMSA/IDEgOiAtMSlcblx0XHR4MiA9IGN4ICsgcnggKiBNYXRoLmNvcyhmMilcblx0XHR5MiA9IGN5ICsgcnkgKiBNYXRoLnNpbihmMilcblx0XHR2YXIgcmVzID0gYXJjKHgyLCB5MiwgcngsIHJ5LCBhbmdsZSwgMCwgc3dlZXBfZmxhZywgeDJvbGQsIHkyb2xkLCBbZjIsIGYyb2xkLCBjeCwgY3ldKVxuXHR9XG5cdHZhciB0ID0gTWF0aC50YW4oKGYyIC0gZjEpIC8gNClcblx0dmFyIGh4ID0gNCAvIDMgKiByeCAqIHRcblx0dmFyIGh5ID0gNCAvIDMgKiByeSAqIHRcblx0dmFyIGN1cnZlID0gW1xuXHRcdDIgKiB4MSAtICh4MSArIGh4ICogTWF0aC5zaW4oZjEpKSxcblx0XHQyICogeTEgLSAoeTEgLSBoeSAqIE1hdGguY29zKGYxKSksXG5cdFx0eDIgKyBoeCAqIE1hdGguc2luKGYyKSxcblx0XHR5MiAtIGh5ICogTWF0aC5jb3MoZjIpLFxuXHRcdHgyLFxuXHRcdHkyXG5cdF1cblx0aWYgKHJlY3Vyc2l2ZSkgcmV0dXJuIGN1cnZlXG5cdGlmIChyZXMpIGN1cnZlID0gY3VydmUuY29uY2F0KHJlcylcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBjdXJ2ZS5sZW5ndGg7KSB7XG5cdFx0dmFyIHJvdCA9IHJvdGF0ZShjdXJ2ZVtpXSwgY3VydmVbaSsxXSwgYW5nbGUpXG5cdFx0Y3VydmVbaSsrXSA9IHJvdC54XG5cdFx0Y3VydmVbaSsrXSA9IHJvdC55XG5cdH1cblx0cmV0dXJuIGN1cnZlXG59XG5cbmZ1bmN0aW9uIHJvdGF0ZSh4LCB5LCByYWQpe1xuXHRyZXR1cm4ge1xuXHRcdHg6IHggKiBNYXRoLmNvcyhyYWQpIC0geSAqIE1hdGguc2luKHJhZCksXG5cdFx0eTogeCAqIE1hdGguc2luKHJhZCkgKyB5ICogTWF0aC5jb3MocmFkKVxuXHR9XG59XG5cbmZ1bmN0aW9uIHJhZGlhbnMoZGVncmVzcyl7XG5cdHJldHVybiBkZWdyZXNzICogKM+AIC8gMTgwKVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB2ZWMyQ29weShvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSBhWzBdXG4gICAgb3V0WzFdID0gYVsxXVxuICAgIHJldHVybiBvdXRcbn0iLCIvKipcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihUSFJFRSkge1xuICB2YXIgQ29weVNoYWRlciA9IEVmZmVjdENvbXBvc2VyLkNvcHlTaGFkZXIgPSByZXF1aXJlKCd0aHJlZS1jb3B5c2hhZGVyJylcbiAgICAsIFJlbmRlclBhc3MgPSBFZmZlY3RDb21wb3Nlci5SZW5kZXJQYXNzID0gcmVxdWlyZSgnLi9saWIvcmVuZGVycGFzcycpKFRIUkVFKVxuICAgICwgU2hhZGVyUGFzcyA9IEVmZmVjdENvbXBvc2VyLlNoYWRlclBhc3MgPSByZXF1aXJlKCcuL2xpYi9zaGFkZXJwYXNzJykoVEhSRUUsIEVmZmVjdENvbXBvc2VyKVxuICAgICwgTWFza1Bhc3MgPSBFZmZlY3RDb21wb3Nlci5NYXNrUGFzcyA9IHJlcXVpcmUoJy4vbGliL21hc2twYXNzJykoVEhSRUUpXG4gICAgLCBDbGVhck1hc2tQYXNzID0gRWZmZWN0Q29tcG9zZXIuQ2xlYXJNYXNrUGFzcyA9IHJlcXVpcmUoJy4vbGliL2NsZWFybWFza3Bhc3MnKShUSFJFRSlcblxuICBmdW5jdGlvbiBFZmZlY3RDb21wb3NlciggcmVuZGVyZXIsIHJlbmRlclRhcmdldCApIHtcbiAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG5cbiAgICBpZiAoIHJlbmRlclRhcmdldCA9PT0gdW5kZWZpbmVkICkge1xuICAgICAgdmFyIHdpZHRoID0gd2luZG93LmlubmVyV2lkdGggfHwgMTtcbiAgICAgIHZhciBoZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQgfHwgMTtcbiAgICAgIHZhciBwYXJhbWV0ZXJzID0geyBtaW5GaWx0ZXI6IFRIUkVFLkxpbmVhckZpbHRlciwgbWFnRmlsdGVyOiBUSFJFRS5MaW5lYXJGaWx0ZXIsIGZvcm1hdDogVEhSRUUuUkdCRm9ybWF0LCBzdGVuY2lsQnVmZmVyOiBmYWxzZSB9O1xuXG4gICAgICByZW5kZXJUYXJnZXQgPSBuZXcgVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQoIHdpZHRoLCBoZWlnaHQsIHBhcmFtZXRlcnMgKTtcbiAgICB9XG5cbiAgICB0aGlzLnJlbmRlclRhcmdldDEgPSByZW5kZXJUYXJnZXQ7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXQyID0gcmVuZGVyVGFyZ2V0LmNsb25lKCk7XG5cbiAgICB0aGlzLndyaXRlQnVmZmVyID0gdGhpcy5yZW5kZXJUYXJnZXQxO1xuICAgIHRoaXMucmVhZEJ1ZmZlciA9IHRoaXMucmVuZGVyVGFyZ2V0MjtcblxuICAgIHRoaXMucGFzc2VzID0gW107XG5cbiAgICB0aGlzLmNvcHlQYXNzID0gbmV3IFNoYWRlclBhc3MoIENvcHlTaGFkZXIgKTtcbiAgfTtcblxuICBFZmZlY3RDb21wb3Nlci5wcm90b3R5cGUgPSB7XG4gICAgc3dhcEJ1ZmZlcnM6IGZ1bmN0aW9uKCkge1xuXG4gICAgICB2YXIgdG1wID0gdGhpcy5yZWFkQnVmZmVyO1xuICAgICAgdGhpcy5yZWFkQnVmZmVyID0gdGhpcy53cml0ZUJ1ZmZlcjtcbiAgICAgIHRoaXMud3JpdGVCdWZmZXIgPSB0bXA7XG5cbiAgICB9LFxuXG4gICAgYWRkUGFzczogZnVuY3Rpb24gKCBwYXNzICkge1xuXG4gICAgICB0aGlzLnBhc3Nlcy5wdXNoKCBwYXNzICk7XG5cbiAgICB9LFxuXG4gICAgaW5zZXJ0UGFzczogZnVuY3Rpb24gKCBwYXNzLCBpbmRleCApIHtcblxuICAgICAgdGhpcy5wYXNzZXMuc3BsaWNlKCBpbmRleCwgMCwgcGFzcyApO1xuXG4gICAgfSxcblxuICAgIHJlbmRlcjogZnVuY3Rpb24gKCBkZWx0YSApIHtcblxuICAgICAgdGhpcy53cml0ZUJ1ZmZlciA9IHRoaXMucmVuZGVyVGFyZ2V0MTtcbiAgICAgIHRoaXMucmVhZEJ1ZmZlciA9IHRoaXMucmVuZGVyVGFyZ2V0MjtcblxuICAgICAgdmFyIG1hc2tBY3RpdmUgPSBmYWxzZTtcblxuICAgICAgdmFyIHBhc3MsIGksIGlsID0gdGhpcy5wYXNzZXMubGVuZ3RoO1xuXG4gICAgICBmb3IgKCBpID0gMDsgaSA8IGlsOyBpICsrICkge1xuXG4gICAgICAgIHBhc3MgPSB0aGlzLnBhc3Nlc1sgaSBdO1xuXG4gICAgICAgIGlmICggIXBhc3MuZW5hYmxlZCApIGNvbnRpbnVlO1xuXG4gICAgICAgIHBhc3MucmVuZGVyKCB0aGlzLnJlbmRlcmVyLCB0aGlzLndyaXRlQnVmZmVyLCB0aGlzLnJlYWRCdWZmZXIsIGRlbHRhLCBtYXNrQWN0aXZlICk7XG5cbiAgICAgICAgaWYgKCBwYXNzLm5lZWRzU3dhcCApIHtcblxuICAgICAgICAgIGlmICggbWFza0FjdGl2ZSApIHtcblxuICAgICAgICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLnJlbmRlcmVyLmNvbnRleHQ7XG5cbiAgICAgICAgICAgIGNvbnRleHQuc3RlbmNpbEZ1bmMoIGNvbnRleHQuTk9URVFVQUwsIDEsIDB4ZmZmZmZmZmYgKTtcblxuICAgICAgICAgICAgdGhpcy5jb3B5UGFzcy5yZW5kZXIoIHRoaXMucmVuZGVyZXIsIHRoaXMud3JpdGVCdWZmZXIsIHRoaXMucmVhZEJ1ZmZlciwgZGVsdGEgKTtcblxuICAgICAgICAgICAgY29udGV4dC5zdGVuY2lsRnVuYyggY29udGV4dC5FUVVBTCwgMSwgMHhmZmZmZmZmZiApO1xuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5zd2FwQnVmZmVycygpO1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIHBhc3MgaW5zdGFuY2VvZiBNYXNrUGFzcyApIHtcblxuICAgICAgICAgIG1hc2tBY3RpdmUgPSB0cnVlO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoIHBhc3MgaW5zdGFuY2VvZiBDbGVhck1hc2tQYXNzICkge1xuXG4gICAgICAgICAgbWFza0FjdGl2ZSA9IGZhbHNlO1xuXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgfSxcblxuICAgIHJlc2V0OiBmdW5jdGlvbiAoIHJlbmRlclRhcmdldCApIHtcblxuICAgICAgaWYgKCByZW5kZXJUYXJnZXQgPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICByZW5kZXJUYXJnZXQgPSB0aGlzLnJlbmRlclRhcmdldDEuY2xvbmUoKTtcblxuICAgICAgICByZW5kZXJUYXJnZXQud2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICAgICAgcmVuZGVyVGFyZ2V0LmhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodDtcblxuICAgICAgfVxuXG4gICAgICB0aGlzLnJlbmRlclRhcmdldDEgPSByZW5kZXJUYXJnZXQ7XG4gICAgICB0aGlzLnJlbmRlclRhcmdldDIgPSByZW5kZXJUYXJnZXQuY2xvbmUoKTtcblxuICAgICAgdGhpcy53cml0ZUJ1ZmZlciA9IHRoaXMucmVuZGVyVGFyZ2V0MTtcbiAgICAgIHRoaXMucmVhZEJ1ZmZlciA9IHRoaXMucmVuZGVyVGFyZ2V0MjtcblxuICAgIH0sXG5cbiAgICBzZXRTaXplOiBmdW5jdGlvbiAoIHdpZHRoLCBoZWlnaHQgKSB7XG5cbiAgICAgIHZhciByZW5kZXJUYXJnZXQgPSB0aGlzLnJlbmRlclRhcmdldDEuY2xvbmUoKTtcblxuICAgICAgcmVuZGVyVGFyZ2V0LndpZHRoID0gd2lkdGg7XG4gICAgICByZW5kZXJUYXJnZXQuaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgICB0aGlzLnJlc2V0KCByZW5kZXJUYXJnZXQgKTtcblxuICAgIH1cblxuICB9O1xuXG4gIC8vIHNoYXJlZCBvcnRobyBjYW1lcmFcblxuICBFZmZlY3RDb21wb3Nlci5jYW1lcmEgPSBuZXcgVEhSRUUuT3J0aG9ncmFwaGljQ2FtZXJhKCAtMSwgMSwgMSwgLTEsIDAsIDEgKTtcblxuICBFZmZlY3RDb21wb3Nlci5xdWFkID0gbmV3IFRIUkVFLk1lc2goIG5ldyBUSFJFRS5QbGFuZUdlb21ldHJ5KCAyLCAyICksIG51bGwgKTtcblxuICBFZmZlY3RDb21wb3Nlci5zY2VuZSA9IG5ldyBUSFJFRS5TY2VuZSgpO1xuICBFZmZlY3RDb21wb3Nlci5zY2VuZS5hZGQoIEVmZmVjdENvbXBvc2VyLnF1YWQgKTtcblxuICByZXR1cm4gRWZmZWN0Q29tcG9zZXJcbn07IiwiLyoqXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oVEhSRUUpIHtcbiAgZnVuY3Rpb24gQ2xlYXJNYXNrUGFzcygpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQ2xlYXJNYXNrUGFzcykpIHJldHVybiBuZXcgQ2xlYXJNYXNrUGFzcyhzY2VuZSwgY2FtZXJhKTtcbiAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xuICB9O1xuXG4gIENsZWFyTWFza1Bhc3MucHJvdG90eXBlID0ge1xuICAgIHJlbmRlcjogZnVuY3Rpb24gKCByZW5kZXJlciwgd3JpdGVCdWZmZXIsIHJlYWRCdWZmZXIsIGRlbHRhICkge1xuICAgICAgdmFyIGNvbnRleHQgPSByZW5kZXJlci5jb250ZXh0O1xuICAgICAgY29udGV4dC5kaXNhYmxlKCBjb250ZXh0LlNURU5DSUxfVEVTVCApO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gQ2xlYXJNYXNrUGFzc1xufTsiLCIvKipcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihUSFJFRSkge1xuICBmdW5jdGlvbiBNYXNrUGFzcyggc2NlbmUsIGNhbWVyYSApIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgTWFza1Bhc3MpKSByZXR1cm4gbmV3IE1hc2tQYXNzKHNjZW5lLCBjYW1lcmEpO1xuXG4gICAgdGhpcy5zY2VuZSA9IHNjZW5lO1xuICAgIHRoaXMuY2FtZXJhID0gY2FtZXJhO1xuXG4gICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcbiAgICB0aGlzLmNsZWFyID0gdHJ1ZTtcbiAgICB0aGlzLm5lZWRzU3dhcCA9IGZhbHNlO1xuXG4gICAgdGhpcy5pbnZlcnNlID0gZmFsc2U7XG4gIH07XG5cbiAgTWFza1Bhc3MucHJvdG90eXBlID0ge1xuXG4gICAgcmVuZGVyOiBmdW5jdGlvbiAoIHJlbmRlcmVyLCB3cml0ZUJ1ZmZlciwgcmVhZEJ1ZmZlciwgZGVsdGEgKSB7XG5cbiAgICAgIHZhciBjb250ZXh0ID0gcmVuZGVyZXIuY29udGV4dDtcblxuICAgICAgLy8gZG9uJ3QgdXBkYXRlIGNvbG9yIG9yIGRlcHRoXG5cbiAgICAgIGNvbnRleHQuY29sb3JNYXNrKCBmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZSApO1xuICAgICAgY29udGV4dC5kZXB0aE1hc2soIGZhbHNlICk7XG5cbiAgICAgIC8vIHNldCB1cCBzdGVuY2lsXG5cbiAgICAgIHZhciB3cml0ZVZhbHVlLCBjbGVhclZhbHVlO1xuXG4gICAgICBpZiAoIHRoaXMuaW52ZXJzZSApIHtcblxuICAgICAgICB3cml0ZVZhbHVlID0gMDtcbiAgICAgICAgY2xlYXJWYWx1ZSA9IDE7XG5cbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgd3JpdGVWYWx1ZSA9IDE7XG4gICAgICAgIGNsZWFyVmFsdWUgPSAwO1xuXG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQuZW5hYmxlKCBjb250ZXh0LlNURU5DSUxfVEVTVCApO1xuICAgICAgY29udGV4dC5zdGVuY2lsT3AoIGNvbnRleHQuUkVQTEFDRSwgY29udGV4dC5SRVBMQUNFLCBjb250ZXh0LlJFUExBQ0UgKTtcbiAgICAgIGNvbnRleHQuc3RlbmNpbEZ1bmMoIGNvbnRleHQuQUxXQVlTLCB3cml0ZVZhbHVlLCAweGZmZmZmZmZmICk7XG4gICAgICBjb250ZXh0LmNsZWFyU3RlbmNpbCggY2xlYXJWYWx1ZSApO1xuXG4gICAgICAvLyBkcmF3IGludG8gdGhlIHN0ZW5jaWwgYnVmZmVyXG5cbiAgICAgIHJlbmRlcmVyLnJlbmRlciggdGhpcy5zY2VuZSwgdGhpcy5jYW1lcmEsIHJlYWRCdWZmZXIsIHRoaXMuY2xlYXIgKTtcbiAgICAgIHJlbmRlcmVyLnJlbmRlciggdGhpcy5zY2VuZSwgdGhpcy5jYW1lcmEsIHdyaXRlQnVmZmVyLCB0aGlzLmNsZWFyICk7XG5cbiAgICAgIC8vIHJlLWVuYWJsZSB1cGRhdGUgb2YgY29sb3IgYW5kIGRlcHRoXG5cbiAgICAgIGNvbnRleHQuY29sb3JNYXNrKCB0cnVlLCB0cnVlLCB0cnVlLCB0cnVlICk7XG4gICAgICBjb250ZXh0LmRlcHRoTWFzayggdHJ1ZSApO1xuXG4gICAgICAvLyBvbmx5IHJlbmRlciB3aGVyZSBzdGVuY2lsIGlzIHNldCB0byAxXG5cbiAgICAgIGNvbnRleHQuc3RlbmNpbEZ1bmMoIGNvbnRleHQuRVFVQUwsIDEsIDB4ZmZmZmZmZmYgKTsgIC8vIGRyYXcgaWYgPT0gMVxuICAgICAgY29udGV4dC5zdGVuY2lsT3AoIGNvbnRleHQuS0VFUCwgY29udGV4dC5LRUVQLCBjb250ZXh0LktFRVAgKTtcblxuICAgIH1cblxuICB9O1xuXG4gIHJldHVybiBNYXNrUGFzc1xufTtcbiIsIi8qKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFRIUkVFKSB7XG4gIGZ1bmN0aW9uIFJlbmRlclBhc3MoIHNjZW5lLCBjYW1lcmEsIG92ZXJyaWRlTWF0ZXJpYWwsIGNsZWFyQ29sb3IsIGNsZWFyQWxwaGEgKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlbmRlclBhc3MpKSByZXR1cm4gbmV3IFJlbmRlclBhc3Moc2NlbmUsIGNhbWVyYSwgb3ZlcnJpZGVNYXRlcmlhbCwgY2xlYXJDb2xvciwgY2xlYXJBbHBoYSk7XG5cbiAgICB0aGlzLnNjZW5lID0gc2NlbmU7XG4gICAgdGhpcy5jYW1lcmEgPSBjYW1lcmE7XG5cbiAgICB0aGlzLm92ZXJyaWRlTWF0ZXJpYWwgPSBvdmVycmlkZU1hdGVyaWFsO1xuXG4gICAgdGhpcy5jbGVhckNvbG9yID0gY2xlYXJDb2xvcjtcbiAgICB0aGlzLmNsZWFyQWxwaGEgPSAoIGNsZWFyQWxwaGEgIT09IHVuZGVmaW5lZCApID8gY2xlYXJBbHBoYSA6IDE7XG5cbiAgICB0aGlzLm9sZENsZWFyQ29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoKTtcbiAgICB0aGlzLm9sZENsZWFyQWxwaGEgPSAxO1xuXG4gICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcbiAgICB0aGlzLmNsZWFyID0gdHJ1ZTtcbiAgICB0aGlzLm5lZWRzU3dhcCA9IGZhbHNlO1xuXG4gIH07XG5cbiAgUmVuZGVyUGFzcy5wcm90b3R5cGUgPSB7XG5cbiAgICByZW5kZXI6IGZ1bmN0aW9uICggcmVuZGVyZXIsIHdyaXRlQnVmZmVyLCByZWFkQnVmZmVyLCBkZWx0YSApIHtcblxuICAgICAgdGhpcy5zY2VuZS5vdmVycmlkZU1hdGVyaWFsID0gdGhpcy5vdmVycmlkZU1hdGVyaWFsO1xuXG4gICAgICBpZiAoIHRoaXMuY2xlYXJDb2xvciApIHtcblxuICAgICAgICB0aGlzLm9sZENsZWFyQ29sb3IuY29weSggcmVuZGVyZXIuZ2V0Q2xlYXJDb2xvcigpICk7XG4gICAgICAgIHRoaXMub2xkQ2xlYXJBbHBoYSA9IHJlbmRlcmVyLmdldENsZWFyQWxwaGEoKTtcblxuICAgICAgICByZW5kZXJlci5zZXRDbGVhckNvbG9yKCB0aGlzLmNsZWFyQ29sb3IsIHRoaXMuY2xlYXJBbHBoYSApO1xuXG4gICAgICB9XG5cbiAgICAgIHJlbmRlcmVyLnJlbmRlciggdGhpcy5zY2VuZSwgdGhpcy5jYW1lcmEsIHJlYWRCdWZmZXIsIHRoaXMuY2xlYXIgKTtcblxuICAgICAgaWYgKCB0aGlzLmNsZWFyQ29sb3IgKSB7XG5cbiAgICAgICAgcmVuZGVyZXIuc2V0Q2xlYXJDb2xvciggdGhpcy5vbGRDbGVhckNvbG9yLCB0aGlzLm9sZENsZWFyQWxwaGEgKTtcblxuICAgICAgfVxuXG4gICAgICB0aGlzLnNjZW5lLm92ZXJyaWRlTWF0ZXJpYWwgPSBudWxsO1xuXG4gICAgfVxuXG4gIH07XG5cbiAgcmV0dXJuIFJlbmRlclBhc3M7XG5cbn07XG4iLCIvKipcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihUSFJFRSwgRWZmZWN0Q29tcG9zZXIpIHtcbiAgZnVuY3Rpb24gU2hhZGVyUGFzcyggc2hhZGVyLCB0ZXh0dXJlSUQgKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNoYWRlclBhc3MpKSByZXR1cm4gbmV3IFNoYWRlclBhc3Moc2hhZGVyLCB0ZXh0dXJlSUQpO1xuXG4gICAgdGhpcy50ZXh0dXJlSUQgPSAoIHRleHR1cmVJRCAhPT0gdW5kZWZpbmVkICkgPyB0ZXh0dXJlSUQgOiBcInREaWZmdXNlXCI7XG5cbiAgICB0aGlzLnVuaWZvcm1zID0gVEhSRUUuVW5pZm9ybXNVdGlscy5jbG9uZSggc2hhZGVyLnVuaWZvcm1zICk7XG5cbiAgICB0aGlzLm1hdGVyaWFsID0gbmV3IFRIUkVFLlNoYWRlck1hdGVyaWFsKCB7XG5cbiAgICAgIHVuaWZvcm1zOiB0aGlzLnVuaWZvcm1zLFxuICAgICAgdmVydGV4U2hhZGVyOiBzaGFkZXIudmVydGV4U2hhZGVyLFxuICAgICAgZnJhZ21lbnRTaGFkZXI6IHNoYWRlci5mcmFnbWVudFNoYWRlclxuXG4gICAgfSApO1xuXG4gICAgdGhpcy5yZW5kZXJUb1NjcmVlbiA9IGZhbHNlO1xuXG4gICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcbiAgICB0aGlzLm5lZWRzU3dhcCA9IHRydWU7XG4gICAgdGhpcy5jbGVhciA9IGZhbHNlO1xuXG4gIH07XG5cbiAgU2hhZGVyUGFzcy5wcm90b3R5cGUgPSB7XG5cbiAgICByZW5kZXI6IGZ1bmN0aW9uICggcmVuZGVyZXIsIHdyaXRlQnVmZmVyLCByZWFkQnVmZmVyLCBkZWx0YSApIHtcblxuICAgICAgaWYgKCB0aGlzLnVuaWZvcm1zWyB0aGlzLnRleHR1cmVJRCBdICkge1xuXG4gICAgICAgIHRoaXMudW5pZm9ybXNbIHRoaXMudGV4dHVyZUlEIF0udmFsdWUgPSByZWFkQnVmZmVyO1xuXG4gICAgICB9XG5cbiAgICAgIEVmZmVjdENvbXBvc2VyLnF1YWQubWF0ZXJpYWwgPSB0aGlzLm1hdGVyaWFsO1xuXG4gICAgICBpZiAoIHRoaXMucmVuZGVyVG9TY3JlZW4gKSB7XG5cbiAgICAgICAgcmVuZGVyZXIucmVuZGVyKCBFZmZlY3RDb21wb3Nlci5zY2VuZSwgRWZmZWN0Q29tcG9zZXIuY2FtZXJhICk7XG5cbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgcmVuZGVyZXIucmVuZGVyKCBFZmZlY3RDb21wb3Nlci5zY2VuZSwgRWZmZWN0Q29tcG9zZXIuY2FtZXJhLCB3cml0ZUJ1ZmZlciwgdGhpcy5jbGVhciApO1xuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgfTtcblxuICByZXR1cm4gU2hhZGVyUGFzcztcblxufTsiLCIvKipcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKlxuICogRnVsbC1zY3JlZW4gdGV4dHVyZWQgcXVhZCBzaGFkZXJcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgdW5pZm9ybXM6IHtcbiAgICBcInREaWZmdXNlXCI6IHsgdHlwZTogXCJ0XCIsIHZhbHVlOiBudWxsIH0sXG4gICAgXCJvcGFjaXR5XCI6ICB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMS4wIH1cbiAgfSxcbiAgdmVydGV4U2hhZGVyOiBbXG4gICAgXCJ2YXJ5aW5nIHZlYzIgdlV2O1wiLFxuXG4gICAgXCJ2b2lkIG1haW4oKSB7XCIsXG5cbiAgICAgIFwidlV2ID0gdXY7XCIsXG4gICAgICBcImdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG1vZGVsVmlld01hdHJpeCAqIHZlYzQoIHBvc2l0aW9uLCAxLjAgKTtcIixcblxuICAgIFwifVwiXG4gIF0uam9pbihcIlxcblwiKSxcbiAgZnJhZ21lbnRTaGFkZXI6IFtcbiAgICBcInVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcIixcblxuICAgIFwidW5pZm9ybSBzYW1wbGVyMkQgdERpZmZ1c2U7XCIsXG5cbiAgICBcInZhcnlpbmcgdmVjMiB2VXY7XCIsXG5cbiAgICBcInZvaWQgbWFpbigpIHtcIixcblxuICAgICAgXCJ2ZWM0IHRleGVsID0gdGV4dHVyZTJEKCB0RGlmZnVzZSwgdlV2ICk7XCIsXG4gICAgICBcImdsX0ZyYWdDb2xvciA9IG9wYWNpdHkgKiB0ZXhlbDtcIixcblxuICAgIFwifVwiXG4gIF0uam9pbihcIlxcblwiKVxufTtcbiIsInZhciBjcmVhdGVUeXBlcyA9IHJlcXVpcmUoJy4vdHlwZXMnKVxuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oVEhSRUUpIHtcblxuICAgIHZhciB0eXBlcyA9IGNyZWF0ZVR5cGVzKFRIUkVFKSBcblxuICAgIHJldHVybiBmdW5jdGlvbiBjcmVhdGUoZ2xTaGFkZXIsIG9wdHMpIHtcbiAgICAgICAgb3B0cyA9IG9wdHN8fHt9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBvcHRzLmNvbG9ycyA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICBvcHRzLmNvbG9ycyA9IFtvcHRzLmNvbG9yc11cbiAgICAgICAgXG4gICAgICAgIHZhciB0VW5pZm9ybXMgPSB0eXBlcyggZ2xTaGFkZXIudW5pZm9ybXMsIG9wdHMuY29sb3JzIClcbiAgICAgICAgdmFyIHRBdHRyaWJzID0gdHlwZXMoIGdsU2hhZGVyLmF0dHJpYnV0ZXMsIG9wdHMuY29sb3JzIClcbiAgICAgICAgICAgIFxuICAgICAgICAvL2NsZWFyIHRoZSBhdHRyaWJ1dGUgYXJyYXlzXG4gICAgICAgIGZvciAodmFyIGsgaW4gdEF0dHJpYnMpIHtcbiAgICAgICAgICAgIHRBdHRyaWJzW2tdLnZhbHVlID0gW11cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2ZXJ0ZXhTaGFkZXI6IGdsU2hhZGVyLnZlcnRleCxcbiAgICAgICAgICAgIGZyYWdtZW50U2hhZGVyOiBnbFNoYWRlci5mcmFnbWVudCxcbiAgICAgICAgICAgIHVuaWZvcm1zOiB0VW5pZm9ybXMsXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiB0QXR0cmlic1xuICAgICAgICB9XG4gICAgfVxufSIsInZhciB0eXBlTWFwID0ge1xuICAgICdpbnQnOiAnaScsXG4gICAgJ2Zsb2F0JzogJ2YnLFxuICAgICdpdmVjMic6ICdpMicsXG4gICAgJ2l2ZWMzJzogJ2kzJyxcbiAgICAnaXZlYzQnOiAnaTQnLFxuICAgICd2ZWMyJzogJ3YyJyxcbiAgICAndmVjMyc6ICd2MycsXG4gICAgJ3ZlYzQnOiAndjQnLFxuICAgICdtYXQ0JzogJ200JyxcbiAgICAnbWF0Myc6ICdtMycsXG4gICAgJ3NhbXBsZXIyRCc6ICd0JyxcbiAgICAnc2FtcGxlckN1YmUnOiAndCdcbn1cblxuZnVuY3Rpb24gY3JlYXRlKFRIUkVFKSB7XG4gICAgZnVuY3Rpb24gbmV3SW5zdGFuY2UodHlwZSwgaXNBcnJheSkge1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2Zsb2F0JzogXG4gICAgICAgICAgICBjYXNlICdpbnQnOlxuICAgICAgICAgICAgICAgIHJldHVybiAwXG4gICAgICAgICAgICBjYXNlICd2ZWMyJzpcbiAgICAgICAgICAgIGNhc2UgJ2l2ZWMyJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFRIUkVFLlZlY3RvcjIoKVxuICAgICAgICAgICAgY2FzZSAndmVjMyc6XG4gICAgICAgICAgICBjYXNlICdpdmVjMyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBUSFJFRS5WZWN0b3IzKClcbiAgICAgICAgICAgIGNhc2UgJ3ZlYzQnOlxuICAgICAgICAgICAgY2FzZSAnaXZlYzQnOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVEhSRUUuVmVjdG9yNCgpXG4gICAgICAgICAgICBjYXNlICdtYXQ0JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFRIUkVFLk1hdHJpeDQoKVxuICAgICAgICAgICAgY2FzZSAnbWF0Myc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBUSFJFRS5NYXRyaXgzKClcbiAgICAgICAgICAgIGNhc2UgJ3NhbXBsZXJDdWJlJzpcbiAgICAgICAgICAgIGNhc2UgJ3NhbXBsZXIyRCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBUSFJFRS5UZXh0dXJlKClcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVmYXVsdFZhbHVlKHR5cGUsIGlzQXJyYXksIGFycmF5TGVuKSB7XG4gICAgICAgIGlmIChpc0FycmF5KSB7XG4gICAgICAgICAgICAvL1RocmVlSlMgZmxhdHRlbnMgaXZlYzMgdHlwZVxuICAgICAgICAgICAgLy8od2UgZG9uJ3Qgc3VwcG9ydCAnZnYnIHR5cGUpXG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gJ2l2ZWMzJylcbiAgICAgICAgICAgICAgICBhcnJheUxlbiAqPSAzXG4gICAgICAgICAgICB2YXIgYXIgPSBuZXcgQXJyYXkoYXJyYXlMZW4pXG4gICAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8YXIubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgYXJbaV0gPSBuZXdJbnN0YW5jZSh0eXBlLCBpc0FycmF5KVxuICAgICAgICAgICAgcmV0dXJuIGFyXG4gICAgICAgIH0gIFxuICAgICAgICByZXR1cm4gbmV3SW5zdGFuY2UodHlwZSlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRUeXBlKHR5cGUsIGlzQXJyYXkpIHtcbiAgICAgICAgaWYgKCFpc0FycmF5KVxuICAgICAgICAgICAgcmV0dXJuIHR5cGVNYXBbdHlwZV1cblxuICAgICAgICBpZiAodHlwZSA9PT0gJ2ludCcpXG4gICAgICAgICAgICByZXR1cm4gJ2l2MSdcbiAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gJ2Zsb2F0JylcbiAgICAgICAgICAgIHJldHVybiAnZnYxJ1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gdHlwZU1hcFt0eXBlXSsndidcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gc2V0dXBVbmlmb3JtcyhnbFVuaWZvcm1zLCBjb2xvck5hbWVzKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShjb2xvck5hbWVzKSlcbiAgICAgICAgICAgIGNvbG9yTmFtZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpXG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9XG4gICAgICAgIHZhciBhcnJheXMgPSB7fVxuXG4gICAgICAgIC8vbWFwIHVuaWZvcm0gdHlwZXNcbiAgICAgICAgZ2xVbmlmb3Jtcy5mb3JFYWNoKGZ1bmN0aW9uKHVuaWZvcm0pIHtcbiAgICAgICAgICAgIHZhciBuYW1lID0gdW5pZm9ybS5uYW1lXG4gICAgICAgICAgICB2YXIgaXNBcnJheSA9IC8oLispXFxbWzAtOV0rXFxdLy5leGVjKG5hbWUpXG5cbiAgICAgICAgICAgIC8vc3BlY2lhbCBjYXNlOiBjb2xvcnMuLi5cbiAgICAgICAgICAgIGlmIChjb2xvck5hbWVzICYmIGNvbG9yTmFtZXMuaW5kZXhPZihuYW1lKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNBcnJheSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYXJyYXkgb2YgY29sb3IgdW5pZm9ybXMgbm90IHN1cHBvcnRlZFwiKVxuICAgICAgICAgICAgICAgIGlmICh1bmlmb3JtLnR5cGUgIT09ICd2ZWMzJylcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhyZWVKUyBleHBlY3RzIHZlYzMgZm9yIENvbG9yIHVuaWZvcm1zXCIpIFxuICAgICAgICAgICAgICAgIHJlc3VsdFtuYW1lXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2MnLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbmV3IFRIUkVFLkNvbG9yKClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpc0FycmF5KSB7XG4gICAgICAgICAgICAgICAgbmFtZSA9IGlzQXJyYXlbMV1cbiAgICAgICAgICAgICAgICBpZiAobmFtZSBpbiBhcnJheXMpIFxuICAgICAgICAgICAgICAgICAgICBhcnJheXNbbmFtZV0uY291bnQrKyBcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGFycmF5c1tuYW1lXSA9IHsgY291bnQ6IDEsIHR5cGU6IHVuaWZvcm0udHlwZSB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHRbbmFtZV0gPSB7IFxuICAgICAgICAgICAgICAgIHR5cGU6IGdldFR5cGUodW5pZm9ybS50eXBlLCBpc0FycmF5KSwgXG4gICAgICAgICAgICAgICAgdmFsdWU6IGlzQXJyYXkgPyBudWxsIDogZGVmYXVsdFZhbHVlKHVuaWZvcm0udHlwZSkgXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG5cbiAgICAgICAgLy9ub3cgY2xlYW4gdXAgYW55IGFycmF5IHZhbHVlc1xuICAgICAgICBmb3IgKHZhciBrIGluIHJlc3VsdCkge1xuICAgICAgICAgICAgdmFyIHUgPSByZXN1bHRba11cbiAgICAgICAgICAgIGlmIChrIGluIGFycmF5cykgeyAvL2lzIGFuIGFycmF5XG4gICAgICAgICAgICAgICAgdmFyIGEgPSBhcnJheXNba11cbiAgICAgICAgICAgICAgICB1LnZhbHVlID0gZGVmYXVsdFZhbHVlKGEudHlwZSwgdHJ1ZSwgYS5jb3VudClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZSIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvcmVuZGVyZXInKSIsInZhciBjcmVhdGVUZXh0ID0gcmVxdWlyZSgnZ2wtc3ByaXRlLXRleHQnKVxudmFyIG1hdDQgPSB7XG4gICAgY3JlYXRlOiByZXF1aXJlKCdnbC1tYXQ0L2NyZWF0ZScpLFxuICAgIHNjYWxlOiByZXF1aXJlKCdnbC1tYXQ0L3NjYWxlJyksXG4gICAgbXVsdGlwbHk6IHJlcXVpcmUoJ2dsLW1hdDQvbXVsdGlwbHknKVxufVxuXG52YXIgbW9kZWxUcmFuc2Zvcm0gPSBtYXQ0LmNyZWF0ZSgpXG52YXIgZmxpcCA9IG1hdDQuY3JlYXRlKClcbm1hdDQuc2NhbGUoZmxpcCwgZmxpcCwgWzEsIC0xLCAxXSlcblxudmFyIFdyYXBUZXh0dXJlID0gcmVxdWlyZSgnLi90ZXh0dXJlLXdyYXAnKVxudmFyIG51bWJlciA9IHJlcXVpcmUoJ2FzLW51bWJlcicpXG52YXIgeHRlbmQgPSByZXF1aXJlKCd4dGVuZCcpXG5cbnZhciBjcmVhdGVTaGFkZXIgPSByZXF1aXJlKCdnbC1zaGFkZXItY29yZScpXG5cblxuLy9uYXN0eSB0ZW1wIGhhY2sgdW50aWwgIzk3MSBpcyBmaXhlZFxudmFyIHZlcnRleCA9ICdhdHRyaWJ1dGUgdmVjNCBwb3NpdGlvbjtcXG5hdHRyaWJ1dGUgdmVjNCBjb2xvcjtcXG5hdHRyaWJ1dGUgdmVjMiB0ZXhjb29yZDA7XFxuXFxudW5pZm9ybSBtYXQ0IHByb2plY3Rpb247XFxudW5pZm9ybSBtYXQ0IHZpZXc7XFxudW5pZm9ybSBtYXQ0IG1vZGVsO1xcblxcbnZhcnlpbmcgdmVjNCB2X2NvbDtcXG52YXJ5aW5nIHZlYzIgdl90ZXgwO1xcblxcbnZvaWQgbWFpbigpIHtcXG4gZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uICogdmlldyAqIG1vZGVsICogcG9zaXRpb247XFxuIHZfY29sID0gY29sb3I7XFxuIHZfdGV4MCA9IHRleGNvb3JkMDtcXG4gZ2xfUG9pbnRTaXplID0gMS4wO1xcbn0nXG52YXIgZnJhZ21lbnQgPSAnI2lmZGVmIEdMX0VTXFxucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuI2VuZGlmXFxuXFxudmFyeWluZyB2ZWM0IHZfY29sO1xcbnZhcnlpbmcgdmVjMiB2X3RleDA7XFxudW5pZm9ybSBzYW1wbGVyMkQgdGV4dHVyZTA7XFxuXFxudW5pZm9ybSBmbG9hdCBzbW9vdGhpbmc7XFxuLy8gPSAxLjAvMzIuMDtcXG5cXG4vLyBkcm9wIHNoYWRvdyBjb21wdXRlZCBpbiBmcmFnbWVudCBzaGFkZXJcXG52b2lkIG1haW4oKSB7XFxuIHZlYzQgdGV4Q29sb3IgPSB0ZXh0dXJlMkQodGV4dHVyZTAsIHZfdGV4MCk7XFxuXFxuIGZsb2F0IGRzdCA9IHRleENvbG9yLmE7XFxuIGZsb2F0IGFscGhhID0gc21vb3Roc3RlcCgwLjUgLSBzbW9vdGhpbmcsIDAuNSArIHNtb290aGluZywgZHN0KTtcXG4gdmVjNCBiYXNlID0gdl9jb2wgKiB2ZWM0KGFscGhhKTtcXG5cXG4gZ2xfRnJhZ0NvbG9yID0gYmFzZTtcXG4gaWYgKGdsX0ZyYWdDb2xvci5hPDAuMSlcXG4gZGlzY2FyZDtcXG59J1xuXG52YXIgdW5pZm9ybXMgPSBbXG4gICAgICAgIHsgdHlwZTogJ2Zsb2F0JywgbmFtZTogJ3Ntb290aGluZycgfSxcbiAgICAgICAgeyB0eXBlOiAnc2FtcGxlcjJEJywgbmFtZTogJ3RleHR1cmUwJyB9LFxuICAgICAgICB7IHR5cGU6ICdtYXQ0JywgbmFtZTogJ3Byb2plY3Rpb24nIH0sXG4gICAgICAgIHsgdHlwZTogJ21hdDQnLCBuYW1lOiAndmlldycgfSxcbiAgICAgICAgeyB0eXBlOiAnbWF0NCcsIG5hbWU6ICdtb2RlbCcgfSAgICAgICAgXG4gICAgXSxcbiAgICBhdHRyaWJ1dGVzID0gW1xuICAgICAgICB7IHR5cGU6ICd2ZWM0JywgbmFtZTogJ3Bvc2l0aW9uJyB9LFxuICAgICAgICB7IHR5cGU6ICd2ZWM0JywgbmFtZTogJ2NvbG9yJyB9LFxuICAgICAgICB7IHR5cGU6ICd2ZWMyJywgbmFtZTogJ3RleGNvb3JkMCcgfVxuICAgIF1cblxuXG5cbmZ1bmN0aW9uIGNvcHlDb2xvcihvdXQsIGNvbG9yLCBvcGFjaXR5KSB7XG4gICAgb3V0WzBdID0gY29sb3IuclxuICAgIG91dFsxXSA9IGNvbG9yLmcgXG4gICAgb3V0WzJdID0gY29sb3IuYiBcbiAgICBvdXRbM10gPSBvcGFjaXR5XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oVEhSRUUpIHtcbiAgICB2YXIgc2hhcmVkU2hhZGVyXG5cbiAgICBmdW5jdGlvbiBUZXh0UmVuZGVyZXIocmVuZGVyZXIsIG9wdCkge1xuICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVGV4dFJlbmRlcmVyKSlcbiAgICAgICAgICAgIHJldHVybiBuZXcgVGV4dFJlbmRlcmVyKHJlbmRlcmVyLCBvcHQpXG4gICAgICAgIG9wdD1vcHR8fHt9XG5cbiAgICAgICAgdmFyIGdsID0gcmVuZGVyZXIuZ2V0Q29udGV4dCgpXG4gICAgICAgIHRoaXMuZ2wgPSBnbFxuICAgICAgICB0aGlzLmNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKClcbiAgICAgICAgaWYgKG9wdC5jb2xvciAhPT0gbnVsbCAmJiB0eXBlb2Ygb3B0LmNvbG9yICE9PSAndW5kZWZpbmVkJylcbiAgICAgICAgICAgIHRoaXMuY29sb3Iuc2V0KG9wdC5jb2xvcilcbiAgICAgICAgdGhpcy5vcGFjaXR5ID0gbnVtYmVyKG9wdC5vcGFjaXR5LCAxLjApXG5cbiAgICAgICAgLy9pZiBubyB0ZXh0dXJlcyBhcmUgZ2l2ZW4sIHByZXN1bWUgdGhleSBhcmUgYmFzZTY0IHBhY2tlZFxuICAgICAgICAvL2ludG8gdGhlIEZvbnQgb2JqZWN0IChsaWtlIHdpdGggYm1mb250LWxhdG8pXG4gICAgICAgIHZhciB0ZXh0T3B0cyA9IHh0ZW5kKG9wdClcbiAgICAgICAgaWYgKHRleHRPcHRzLnRleHR1cmVzKSB7XG4gICAgICAgICAgICB0ZXh0T3B0cy50ZXh0dXJlcyA9IHRleHRPcHRzLnRleHR1cmVzLm1hcChmdW5jdGlvbih0ZXgpIHtcbiAgICAgICAgICAgICAgICAvLyByZXR1cm4gcmVxdWlyZSgnZ2wtdGV4dHVyZTJkJykoZ2wsIHRleC5pbWFnZSlcbiAgICAgICAgICAgICAgICBpZiAodGV4IGluc3RhbmNlb2YgVEhSRUUuVGV4dHVyZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFdyYXBUZXh0dXJlKHJlbmRlcmVyLCB0ZXgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRleFxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gY3JlYXRlVGV4dChnbCwgdGV4dE9wdHMpXG4gICAgICAgIHRoaXMudHJhbnNmb3JtID0gbWF0NC5jcmVhdGUoKVxuXG4gICAgICAgIGlmICghc2hhcmVkU2hhZGVyICYmICFvcHQuc2hhZGVyKVxuICAgICAgICAgICAgc2hhcmVkU2hhZGVyID0gY3JlYXRlU2hhZGVyKGdsLCB2ZXJ0ZXgsIGZyYWdtZW50LCB1bmlmb3JtcywgYXR0cmlidXRlcylcbiAgICAgICAgdGhpcy5zaGFkZXIgPSBvcHQuc2hhZGVyIHx8IHNoYXJlZFNoYWRlclxuICAgICAgICB0aGlzLnNoYWRlci5iaW5kKClcblxuICAgICAgICB0aGlzLnBhZGRpbmcgPSBudW1iZXIob3B0LnBhZGRpbmcsIDApXG5cbiAgICAgICAgdmFyIHMgPSBudW1iZXIob3B0LnNtb290aGluZywgMS4wLzMyLjApXG4gICAgICAgIHRoaXMuc2hhZGVyLnVuaWZvcm1zLnNtb290aGluZyA9IHNcbiAgICAgICAgdGhpcy5zaGFkZXIudW5pZm9ybXMudGV4dHVyZTAgPSAwXG4gICAgfVxuXG4gICAgVGV4dFJlbmRlcmVyLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24oY2FtZXJhLCBvYmplY3QpIHtcbiAgICAgICAgdmFyIGdsID0gdGhpcy5nbFxuXG4gICAgICAgIGlmICghb2JqZWN0LnZpc2libGUpXG4gICAgICAgICAgICByZXR1cm5cblxuICAgICAgICBpZiAoIXRoaXMuZWxlbWVudC50ZXh0dXJlcyB8fCB0aGlzLmVsZW1lbnQudGV4dHVyZXMubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuXG5cbiAgICAgICAgZ2wuZW5hYmxlKGdsLkJMRU5EKVxuICAgICAgICAvLyBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIG51bGwpXG5cbiAgICAgICAgZ2wuZW5hYmxlKGdsLkRFUFRIX1RFU1QpXG4gICAgICAgIGdsLmRlcHRoRnVuYyhnbC5MRVFVQUwpXG5cbiAgICAgICAgLy8gZ2wuZnJvbnRGYWNlKCBnbC5DQ1cgKSAgICBcbiAgICAgICAgZ2wuZW5hYmxlKGdsLkNVTExfRkFDRSlcbiAgICAgICAgLy8gZ2wuY3VsbEZhY2UoIGdsLkZST05UIClcbiAgICAgICAgZ2wuY29sb3JNYXNrKHRydWUsIHRydWUsIHRydWUsIHRydWUpXG4gICAgICAgIGdsLmRpc2FibGUoZ2wuU1RFTkNJTF9URVNUKVxuICAgICAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwKVxuICAgICAgICBnbC5kZXB0aE1hc2sodHJ1ZSlcbiAgICAgICAgZ2wuYmxlbmRGdW5jKGdsLlNSQ19BTFBIQSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSlcblxuICAgICAgICB0aGlzLnNoYWRlci5iaW5kKClcbiAgICAgICAgdGhpcy5lbGVtZW50LnRleHR1cmVzWzBdLmJpbmQoMClcblxuICAgICAgICAvLyBnbC5jb2xvck1hc2sodHJ1ZSwgdHJ1ZSwgdHJ1ZSwgdHJ1ZSlcblxuICAgICAgICBnbC5jdWxsRmFjZShnbC5GUk9OVClcblxuICAgICAgICBtYXQ0Lm11bHRpcGx5KG1vZGVsVHJhbnNmb3JtLCBvYmplY3QubWF0cml4V29ybGQuZWxlbWVudHMsIHRoaXMudHJhbnNmb3JtKVxuICAgICAgICBtYXQ0Lm11bHRpcGx5KG1vZGVsVHJhbnNmb3JtLCBtb2RlbFRyYW5zZm9ybSwgZmxpcClcblxuICAgICAgICB0aGlzLnNoYWRlci5iaW5kKClcbiAgICAgICAgdGhpcy5zaGFkZXIudW5pZm9ybXMucHJvamVjdGlvbiA9IGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4LmVsZW1lbnRzXG4gICAgICAgIHRoaXMuc2hhZGVyLnVuaWZvcm1zLnZpZXcgPSBjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlLmVsZW1lbnRzXG4gICAgICAgIHRoaXMuc2hhZGVyLnVuaWZvcm1zLm1vZGVsID0gbW9kZWxUcmFuc2Zvcm1cbiAgICAgICAgICAgIFxuICAgICAgICBjb3B5Q29sb3IodGhpcy5lbGVtZW50LmJhdGNoLmNvbG9yLCB0aGlzLmNvbG9yLCB0aGlzLm9wYWNpdHkpXG4gICAgICAgIHRoaXMuZWxlbWVudC5kcmF3KHRoaXMuc2hhZGVyLCB0aGlzLnBhZGRpbmcsIHRoaXMucGFkZGluZylcblxuICAgICAgICBnbC5jdWxsRmFjZSggZ2wuQkFDSyApXG4gICAgfVxuXG5cbiAgICByZXR1cm4gVGV4dFJlbmRlcmVyXG59IiwiLy8gaW4gdGltZSB0aGlzIHdpbGwgYmUgcmVwbGFjZWQgd2l0aCBhIHNvbHV0aW9uXG4vLyB0aGF0IGJldHRlciBzdXBwb3J0ZWQgVGhyZWVKUyBUZXh0dXJlIG9iamVjdHNcblxuXG5mdW5jdGlvbiBUZXh0dXJlV3JhcChyZW5kZXJlciwgdGV4KSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFRleHR1cmVXcmFwKSlcbiAgICAgICAgcmV0dXJuIG5ldyBUZXh0dXJlV3JhcChyZW5kZXJlciwgdGV4KVxuICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlclxuICAgIHRoaXMudGV4dHVyZSA9IHRleFxuICAgIHRoaXMuX3NoYXBlID0gWzAsIDBdXG59XG5cblRleHR1cmVXcmFwLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24odW5pdCkge1xuICAgIHVwZGF0ZVNpemUodGhpcy5fc2hhcGUsIHRoaXMudGV4dHVyZSlcblxuXG4gICAgdmFyIGdsID0gdGhpcy5yZW5kZXJlci5nZXRDb250ZXh0KClcbiAgICB0aGlzLnJlbmRlcmVyLnNldFRleHR1cmUodGhpcy50ZXh0dXJlLCB1bml0fDApXG4gICAgXG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy50ZXh0dXJlLl9fd2ViZ2xUZXh0dXJlKVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVGV4dHVyZVdyYXAucHJvdG90eXBlLCBcInNoYXBlXCIsIHtcblxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHVwZGF0ZVNpemUodGhpcy5fc2hhcGUsIHRoaXMudGV4dHVyZSlcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NoYXBlXG4gICAgfVxufSlcblxuZnVuY3Rpb24gdXBkYXRlU2l6ZShzaGFwZSwgdGV4dHVyZSkge1xuICAgIHNoYXBlWzBdID0gKHRleHR1cmUuaW1hZ2UgJiYgdGV4dHVyZS5pbWFnZS53aWR0aCkgIHwwXG4gICAgc2hhcGVbMV0gPSAodGV4dHVyZS5pbWFnZSAmJiB0ZXh0dXJlLmltYWdlLmhlaWdodCkgfDBcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBUZXh0dXJlV3JhcCIsIm1vZHVsZS5leHBvcnRzPXJlcXVpcmUoXCIvcHJvamVjdHMvYmxhY2tpY2Uvbm9kZV9tb2R1bGVzL2FzLW51bWJlci9pbmRleC5qc1wiKSIsIm1vZHVsZS5leHBvcnRzID0gY3JlYXRlO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgaWRlbnRpdHkgbWF0NFxuICpcbiAqIEByZXR1cm5zIHttYXQ0fSBhIG5ldyA0eDQgbWF0cml4XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgICB2YXIgb3V0ID0gbmV3IEZsb2F0MzJBcnJheSgxNik7XG4gICAgb3V0WzBdID0gMTtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSAwO1xuICAgIG91dFs1XSA9IDE7XG4gICAgb3V0WzZdID0gMDtcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9IDA7XG4gICAgb3V0WzldID0gMDtcbiAgICBvdXRbMTBdID0gMTtcbiAgICBvdXRbMTFdID0gMDtcbiAgICBvdXRbMTJdID0gMDtcbiAgICBvdXRbMTNdID0gMDtcbiAgICBvdXRbMTRdID0gMDtcbiAgICBvdXRbMTVdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufTsiLCJtb2R1bGUuZXhwb3J0cz1yZXF1aXJlKFwiL3Byb2plY3RzL2JsYWNraWNlL25vZGVfbW9kdWxlcy9nbC1tYXQ0L211bHRpcGx5LmpzXCIpIiwibW9kdWxlLmV4cG9ydHM9cmVxdWlyZShcIi9wcm9qZWN0cy9ibGFja2ljZS9ub2RlX21vZHVsZXMvZ2wtbWF0NC9zY2FsZS5qc1wiKSIsIm1vZHVsZS5leHBvcnRzPXJlcXVpcmUoXCIvcHJvamVjdHMvYmxhY2tpY2Uvbm9kZV9tb2R1bGVzL2dsc2xpZnkvbm9kZV9tb2R1bGVzL2dsLXNoYWRlci1jb3JlL3NoYWRlci1jb3JlLmpzXCIpIiwidmFyIEJhc2UgPSByZXF1aXJlKCdmb250cGF0aC1zaW1wbGUtcmVuZGVyZXInKVxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIGJtZm9udDJmb250cGF0aCA9IHJlcXVpcmUoJ2ZvbnRwYXRoLWJtZm9udCcpXG52YXIgdGV4Y29vcmQgPSByZXF1aXJlKCd0ZXhjb29yZCcpXG52YXIgeHRlbmQgPSByZXF1aXJlKCd4dGVuZCcpXG52YXIgY3JlYXRlVGV4dHVyZSA9IHJlcXVpcmUoJ2dsLXRleHR1cmUyZCcpXG5cbnZhciBCYXRjaCA9IHJlcXVpcmUoJ2dsLXNwcml0ZS1iYXRjaCcpXG5cbnZhciB0bXBQb3MgPSBbMCwgMF0sXG4gICAgdG1wU2hhcGUgPSBbMCwgMF0sXG4gICAgdG1wMSA9IFswLCAwXSxcbiAgICB0bXAyID0gWzAsIDBdXG52YXIgREVGQVVMVF9URVhDT09SRCA9IFswLCAwLCAxLCAxXVxudmFyIG1heEluaXRpYWxDYXBhY2l0eSA9IDUwMFxuXG5mdW5jdGlvbiB0ZXhjb29yZEdseXBoKGdseXBoLCBhdGxhcywgb3V0KSB7XG4gICAgdG1wMVswXSA9IGdseXBoLnhcbiAgICB0bXAxWzFdID0gZ2x5cGgueVxuICAgIHRtcDJbMF0gPSBnbHlwaC53aWR0aFxuICAgIHRtcDJbMV0gPSBnbHlwaC5oZWlnaHRcbiAgICByZXR1cm4gdGV4Y29vcmQodG1wMSwgdG1wMiwgYXRsYXMsIG91dClcbn1cblxuZnVuY3Rpb24gVGV4dFJlbmRlcmVyKGdsLCBvcHQpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVGV4dFJlbmRlcmVyKSlcbiAgICAgICAgcmV0dXJuIG5ldyBUZXh0UmVuZGVyZXIoZ2wsIG9wdClcbiAgICBvcHQgPSBvcHR8fHt9XG5cbiAgICBpZiAoIW9wdC5mb250KSBcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtdXN0IHNwZWNpZnkgYm1mb250IGF0IGNyZWF0aW9uIHRpbWUnKVxuXG4gICAgLy9pZiB0aGUgZm9udCBoYXMgSW1hZ2UvbmRhcnJheSBhcnJheVxuICAgIGlmICghb3B0LnRleHR1cmVzICYmIEFycmF5LmlzQXJyYXkob3B0LmZvbnQuaW1hZ2VzKSkge1xuICAgICAgICBvcHQudGV4dHVyZXMgPSBvcHQuZm9udC5pbWFnZXMubWFwKGZ1bmN0aW9uKGltZykge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVRleHR1cmUoZ2wsIGltZylcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICBvcHQuZm9udCA9IGJtZm9udDJmb250cGF0aChvcHQuZm9udClcblxuICAgIEJhc2UuY2FsbCh0aGlzLCBvcHQpXG5cbiAgICB0aGlzLnRleHR1cmVzID0gb3B0LnRleHR1cmVzIHx8IFtdXG4gICAgdGhpcy5nbCA9IGdsXG4gICAgaWYgKCFnbClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibXVzdCBzcGVjaWZ5IGdsIGNvbnRleHRcIilcbiAgICBcbiAgICAvL2Fzc3VtZSB0ZXh0IHdpbGwgYmUgdXNlZCBkeW5hbWljYWxseSBcbiAgICBpZiAodHlwZW9mIG9wdC5keW5hbWljICE9PSAnYm9vbGVhbicpXG4gICAgICAgIG9wdC5keW5hbWljID0gdHJ1ZVxuXG4gICAgdmFyIGJhdGNoID0gb3B0LmJhdGNoXG4gICAgaWYgKCFiYXRjaClcbiAgICAgICAgdGhpcy5kZWZhdWx0QmF0Y2ggPSBCYXRjaChnbCwgb3B0KVxuICAgIHRoaXMuYmF0Y2ggPSBiYXRjaCB8fCB0aGlzLmRlZmF1bHRCYXRjaFxuXG4gICAgaWYgKHR5cGVvZiBvcHQud3JhcFdpZHRoICE9PSAnbnVtYmVyJylcbiAgICAgICAgdGhpcy5sYXlvdXQoKVxufVxuXG5pbmhlcml0cyhUZXh0UmVuZGVyZXIsIEJhc2UpXG5cblRleHRSZW5kZXJlci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uKHRleHR1cmVzKSB7XG4gICAgaWYgKHRoaXMuZGVmYXVsdEJhdGNoKVxuICAgICAgICB0aGlzLmRlZmF1bHRCYXRjaC5kaXNwb3NlKClcbiAgICBpZiAodGV4dHVyZXMpIHtcbiAgICAgICAgdGhpcy50ZXh0dXJlcy5mb3JFYWNoKGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdC5kaXNwb3NlID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgICAgIHQuZGlzcG9zZSgpXG4gICAgICAgIH0pXG4gICAgfVxuICAgIHJldHVybiB0aGlzXG59XG5cblRleHRSZW5kZXJlci5wcm90b3R5cGUudW5jYWNoZSA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2NhY2hlID0gZmFsc2VcbiAgICB0aGlzLmJhdGNoLmNsZWFyKClcbiAgICByZXR1cm4gdGhpc1xufVxuXG5UZXh0UmVuZGVyZXIucHJvdG90eXBlLmNhY2hlID0gZnVuY3Rpb24oeCwgeSwgc3RhcnQsIGVuZCkge1xuICAgIC8vIGlmICh0aGlzLnVuZGVybGluZSB8fCB0aGlzLmZvbnQucGFnZXMubGVuZ3RoID4gMSlcbiAgICAvLyAgICAgdGhyb3cgbmV3IEVycm9yKCdjdXJyZW50bHkgY2FjaGVkIHRleHQgZG9lcyBub3Qgc3VwcG9ydCB1bmRlcmxpbmVzIG9yIG11bHRpcGxlIHRleHR1cmUgcGFnZXMnKVxuICAgIFxuICAgIHRoaXMuX2NhY2hlID0gdHJ1ZVxuICAgIHRoaXMuYmF0Y2guZW5zdXJlQ2FwYWNpdHkodGhpcy50ZXh0Lmxlbmd0aClcbiAgICB0aGlzLmJhdGNoLmNsZWFyKClcbiAgICB0aGlzLl9idWlsZCh4LCB5LCBzdGFydCwgZW5kKVxuICAgIHJldHVybiB0aGlzXG59XG5cblRleHRSZW5kZXJlci5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uKHNoYWRlciwgeCwgeSwgc3RhcnQsIGVuZCkge1xuICAgIHZhciBiYXRjaCA9IHRoaXMuYmF0Y2hcbiAgICBiYXRjaC5iaW5kKHNoYWRlcilcblxuICAgIC8vaWYgd2UncmUgZHJhd2luZyBkeW5hbWljYWxseVxuICAgIGlmICghdGhpcy5fY2FjaGUpIHtcbiAgICAgICAgYmF0Y2guY2xlYXIoKVxuICAgICAgICB0aGlzLl9idWlsZCh4LCB5LCBzdGFydCwgZW5kKVxuICAgIH1cbiAgICBcbiAgICBiYXRjaC5kcmF3KClcbiAgICBiYXRjaC51bmJpbmQoKVxuICAgIHJldHVybiB0aGlzXG59XG5cblRleHRSZW5kZXJlci5wcm90b3R5cGUuX2J1aWxkID0gZnVuY3Rpb24oeCwgeSwgc3RhcnQsIGVuZCkge1xuICAgIHZhciByZXN1bHQgPSB0aGlzLnJlbmRlcih4LCB5LCBzdGFydCwgZW5kKVxuXG4gICAgdmFyIGJhdGNoID0gdGhpcy5iYXRjaFxuICAgIHZhciBpID0gMFxuICAgIFxuICAgIC8vdW5kZXJsaW5lcyBjdXJyZW50bHkgbm90IHN1cHBvcnRlZCB3aXRoIGNhY2hlKClcbiAgICBpZiAoIXRoaXMuX2NhY2hlKSB7XG4gICAgICAgIGJhdGNoLnRleGNvb3JkID0gREVGQVVMVF9URVhDT09SRFxuICAgICAgICBiYXRjaC50ZXh0dXJlID0gbnVsbFxuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCByZXN1bHQudW5kZXJsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHVuZGVybGluZSA9IHJlc3VsdC51bmRlcmxpbmVzW2ldXG4gICAgICAgICAgICBiYXRjaC5wb3NpdGlvbiA9IHVuZGVybGluZS5wb3NpdGlvblxuICAgICAgICAgICAgYmF0Y2guc2hhcGUgPSB1bmRlcmxpbmUuc2l6ZVxuICAgICAgICAgICAgYmF0Y2gucHVzaCgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvL25vdyBkcmF3IG91ciBnbHlwaHMgaW50byB0aGUgYmF0Y2guLi5cbiAgICBmb3IgKGkgPSAwOyBpIDwgcmVzdWx0LmdseXBocy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZyA9IHJlc3VsdC5nbHlwaHNbaV1cbiAgICAgICAgdGhpcy5fZHJhd0dseXBoKGJhdGNoLCBnKVxuICAgIH1cbn1cblxuVGV4dFJlbmRlcmVyLnByb3RvdHlwZS5fZHJhd0dseXBoID0gZnVuY3Rpb24oYmF0Y2gsIGRhdGEpIHtcbiAgICAvLy4uLiB3ZSBjb3VsZCBzb3J0IHRoZXNlIGJ5IHRleHR1cmUgcGFnZSB0byByZWR1Y2UgZHJhd3NcbiAgICB2YXIgZ2x5cGggPSBkYXRhLmdseXBoXG4gICAgdmFyIGltZyA9IHRoaXMudGV4dHVyZXNbZ2x5cGgucGFnZV1cbiAgICB0bXBQb3NbMF0gPSBkYXRhLnBvc2l0aW9uWzBdK2dseXBoLmhieFxuICAgIHRtcFBvc1sxXSA9IGRhdGEucG9zaXRpb25bMV0rZ2x5cGguaGJ5IC0gdGhpcy5mb250LmRlc2NlbmRlclxuICAgIHRtcFNoYXBlWzBdID0gZ2x5cGgud2lkdGggKiBkYXRhLnNjYWxlWzBdXG4gICAgdG1wU2hhcGVbMV0gPSBnbHlwaC5oZWlnaHQgKiBkYXRhLnNjYWxlWzFdXG4gICAgXG4gICAgYmF0Y2gudGV4dHVyZSA9IGltZ1xuICAgIHRleGNvb3JkR2x5cGgoZ2x5cGgsIGltZyAmJiBpbWcuc2hhcGUsIGJhdGNoLnRleGNvb3JkKVxuICAgIGJhdGNoLnBvc2l0aW9uID0gdG1wUG9zXG4gICAgYmF0Y2guc2hhcGUgPSB0bXBTaGFwZVxuICAgIGJhdGNoLnB1c2goKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFRleHRSZW5kZXJlciIsImZ1bmN0aW9uIGdseXBoKGRhdGEpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBwYWdlOiBkYXRhLnBhZ2UsXG4gICAgICAgIGhieDogZGF0YS54b2Zmc2V0LFxuICAgICAgICBoYnk6IGRhdGEueW9mZnNldCxcbiAgICAgICAgd2lkdGg6IGRhdGEud2lkdGgsXG4gICAgICAgIGhlaWdodDogZGF0YS5oZWlnaHQsXG4gICAgICAgIHhvZmY6IGRhdGEueGFkdmFuY2UsXG4gICAgICAgIHg6IGRhdGEueCxcbiAgICAgICAgeTogZGF0YS55XG4gICAgfVxufVxuXG5mdW5jdGlvbiBnbHlwaHMoY2hhcnMpIHtcbiAgICB2YXIgb3V0ID0ge31cbiAgICBjaGFycy5mb3JFYWNoKGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgb3V0W1N0cmluZy5mcm9tQ2hhckNvZGUoYy5pZCldID0gZ2x5cGgoYylcbiAgICB9KVxuICAgIHJldHVybiBvdXRcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihibWZvbnQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBwYWdlczogYm1mb250LnBhZ2VzLFxuICAgICAgICByZXNvbHV0aW9uOiA3MixcbiAgICAgICAgc2l6ZTogYm1mb250LmluZm8uc2l6ZSxcbiAgICAgICAgdW5pdHNfcGVyX0VNOiAxLFxuICAgICAgICBiaXRtYXA6IHRydWUsXG4gICAgICAgIGZhbWlseV9uYW1lOiBibWZvbnQuaW5mby5mYWNlLFxuICAgICAgICBoZWlnaHQ6IGJtZm9udC5jb21tb24ubGluZUhlaWdodCxcbiAgICAgICAgZGVzY2VuZGVyOiBibWZvbnQuY29tbW9uLmJhc2UsXG4gICAgICAgIGFzY2VuZGVyOiBibWZvbnQuY29tbW9uLmJhc2UsXG4gICAgICAgIGdseXBoczogZ2x5cGhzKGJtZm9udC5jaGFycyksXG4gICAgICAgIGtlcm5pbmc6IGJtZm9udC5rZXJuaW5ncy5tYXAoZnVuY3Rpb24oaykge1xuICAgICAgICAgICAgcmV0dXJuIFtTdHJpbmcuZnJvbUNoYXJDb2RlKGsuZmlyc3QpLFN0cmluZy5mcm9tQ2hhckNvZGUoay5zZWNvbmQpLGsuYW1vdW50XVxuICAgICAgICB9KVxuICAgIH1cbn0iLCJ2YXIgQmFzZSA9IHJlcXVpcmUoJ2ZvbnRwYXRoLXJlbmRlcmVyJylcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcblxuLy9UT0RPOiBFdmVudHVhbGx5IGxvdHMgb2YgdGhpcyBjb2RlIHdpbGwganVzdCByZXBsYWNlIGZvbnRwYXRoLXJlbmRlcmVyLi4uXG5cbmZ1bmN0aW9uIEZvbnRwYXRoUmVuZGVyZXIob3B0aW9ucykge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBGb250cGF0aFJlbmRlcmVyKSlcbiAgICAgICAgcmV0dXJuIG5ldyBGb250cGF0aFJlbmRlcmVyKG9wdGlvbnMpXG4gICAgQmFzZS5jYWxsKHRoaXMsIG9wdGlvbnMpXG5cbiAgICB0aGlzLmRhdGEgPSB7XG4gICAgICAgIGdseXBoczogW10sXG4gICAgICAgIHVuZGVybGluZXM6IFtdXG4gICAgfVxufVxuXG5pbmhlcml0cyhGb250cGF0aFJlbmRlcmVyLCBCYXNlKVxuXG5Gb250cGF0aFJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJHbHlwaCA9IGZ1bmN0aW9uKGksIGdseXBoLCBzY2FsZSwgeCwgeSkge1xuICAgIHRoaXMuZGF0YS5nbHlwaHMucHVzaChuZXcgR2x5cGgoaSwgZ2x5cGgsIFxuICAgICAgICAgICAgICAgIHRoaXMudGV4dC5jaGFyQ29kZUF0KGkpLCBcbiAgICAgICAgICAgICAgICBbIHNjYWxlLCB0aGlzLmZvbnQuYml0bWFwID8gc2NhbGUgOiAtc2NhbGUgXSxcbiAgICAgICAgICAgICAgICBbIHgsIHkgXSkpXG59XG5cbkZvbnRwYXRoUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlclVuZGVybGluZSA9IGZ1bmN0aW9uKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICB0aGlzLmRhdGEudW5kZXJsaW5lcy5wdXNoKG5ldyBVbmRlcmxpbmUoXG4gICAgICAgIFsgeCwgeSBdLFxuICAgICAgICBbIHdpZHRoLCBoZWlnaHQgXVxuICAgICkpXG59XG5cbkZvbnRwYXRoUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKHgsIHksIHN0YXJ0LCBlbmQpIHtcbiAgICAvL25ldyBkYXRhIGZvciByZXN1bHRcbiAgICB0aGlzLmRhdGEuZ2x5cGhzLmxlbmd0aCA9IDBcbiAgICB0aGlzLmRhdGEudW5kZXJsaW5lcy5sZW5ndGggPSAwXG4gICAgQmFzZS5wcm90b3R5cGUucmVuZGVyLmNhbGwodGhpcywgeCwgeSwgc3RhcnQsIGVuZClcbiAgICByZXR1cm4gdGhpcy5kYXRhXG59XG5cbmZ1bmN0aW9uIEdseXBoKGluZGV4LCBnbHlwaCwgY2hhckNvZGUsIHNjYWxlLCBwb3NpdGlvbikge1xuICAgIHRoaXMuZ2x5cGggPSBnbHlwaFxuICAgIHRoaXMuaW5kZXggPSBpbmRleFxuICAgIHRoaXMuY2hhckNvZGUgPSBjaGFyQ29kZVxuICAgIHRoaXMucG9zaXRpb24gPSBwb3NpdGlvblxuICAgIHRoaXMuc2NhbGUgPSBzY2FsZVxufVxuXG5mdW5jdGlvbiBVbmRlcmxpbmUocG9zaXRpb24sIHNpemUpIHtcbiAgICB0aGlzLnBvc2l0aW9uID0gcG9zaXRpb25cbiAgICB0aGlzLnNpemUgPSBzaXplXG59XG5cbm1vZHVsZS5leHBvcnRzID0gRm9udHBhdGhSZW5kZXJlciIsInZhciBHbHlwaEl0ZXJhdG9yID0gcmVxdWlyZSgnZm9udHBhdGgtZ2x5cGgtaXRlcmF0b3InKTtcbnZhciBXb3JkV3JhcCA9IHJlcXVpcmUoJ2ZvbnRwYXRoLXdvcmR3cmFwJyk7XG5cbnZhciB0bXBCb3VuZHMgPSB7IHg6IDAsIHk6IDAsIHdpZHRoOiAwLCBoZWlnaHQ6IDAsIGdseXBoczogMCB9O1xuXG5mdW5jdGlvbiBUZXh0UmVuZGVyZXIob3B0aW9ucykge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBUZXh0UmVuZGVyZXIpKVxuICAgICAgICByZXR1cm4gbmV3IFRleHRSZW5kZXJlcihvcHRpb25zKTtcbiAgICBvcHRpb25zID0gb3B0aW9uc3x8e31cblxuICAgIHRoaXMuaXRlcmF0b3IgPSBuZXcgR2x5cGhJdGVyYXRvcihvcHRpb25zLmZvbnQsIG9wdGlvbnMuZm9udFNpemUpO1xuICAgIHRoaXMud29yZHdyYXAgPSBuZXcgV29yZFdyYXAoKTtcblxuICAgIHRoaXMuYWxpZ24gPSAnbGVmdCc7XG4gICAgdGhpcy51bmRlcmxpbmUgPSBmYWxzZTtcblxuICAgIHRoaXMudW5kZXJsaW5lVGhpY2tuZXNzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMudW5kZXJsaW5lUG9zaXRpb24gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fdGV4dCA9IFwiXCI7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuYWxpZ24gPT09ICdzdHJpbmcnKVxuICAgICAgICB0aGlzLmFsaWduID0gb3B0aW9ucy5hbGlnbjtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMudW5kZXJsaW5lID09PSAnYm9vbGVhbicpXG4gICAgICAgIHRoaXMudW5kZXJsaW5lID0gb3B0aW9ucy51bmRlcmxpbmU7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnVuZGVybGluZVRoaWNrbmVzcyA9PT0gJ251bWJlcicpXG4gICAgICAgIHRoaXMudW5kZXJsaW5lVGhpY2tuZXNzID0gb3B0aW9ucy51bmRlcmxpbmVUaGlja25lc3M7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnVuZGVybGluZVBvc2l0aW9uID09PSAnbnVtYmVyJylcbiAgICAgICAgdGhpcy51bmRlcmxpbmVQb3NpdGlvbiA9IG9wdGlvbnMudW5kZXJsaW5lUG9zaXRpb247XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnRleHQgPT09ICdzdHJpbmcnKVxuICAgICAgICB0aGlzLnRleHQgPSBvcHRpb25zLnRleHQ7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmxpbmVIZWlnaHQgPT09ICdudW1iZXInKVxuICAgICAgICB0aGlzLmxpbmVIZWlnaHQgPSBvcHRpb25zLmxpbmVIZWlnaHQ7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmxldHRlclNwYWNpbmcgPT09ICdudW1iZXInKVxuICAgICAgICB0aGlzLmxldHRlclNwYWNpbmcgPSBvcHRpb25zLmxldHRlclNwYWNpbmc7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLndyYXBNb2RlID09PSAnc3RyaW5nJylcbiAgICAgICAgdGhpcy53b3Jkd3JhcC5tb2RlID0gb3B0aW9ucy53cmFwTW9kZTtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMud3JhcFdpZHRoID09PSAnbnVtYmVyJylcbiAgICAgICAgdGhpcy5sYXlvdXQob3B0aW9ucy53cmFwV2lkdGgpO1xufVxuXG4vL0ludGVybmFsbHkgd2Ugd2lsbCB1c2UgaW50ZWdlcnMgdG8gYXZvaWQgc3RyaW5nIGNvbXBhcmlzb24gZm9yIGVhY2ggZ2x5cGhcbnZhciBMRUZUX0FMSUdOID0gMCwgQ0VOVEVSX0FMSUdOID0gMSwgUklHSFRfQUxJR04gPSAyO1xudmFyIEFMSUdOX0FSUkFZID0gW1xuICAgICdsZWZ0JywgXG4gICAgJ2NlbnRlcicsIFxuICAgICdyaWdodCdcbl07XG4gICAgXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhUZXh0UmVuZGVyZXIucHJvdG90eXBlLCB7XG4gICAgLyoqXG4gICAgICogSWYgdGhlIG5ldyBmb250IGRpZmZlcnMgZnJvbSB0aGUgbGFzdCwgdGhlIHRleHQgbGF5b3V0IGlzIGNsZWFyZWRcbiAgICAgKiBhbmQgcGxhY2VkIG9udG8gYSBzaW5nbGUgbGluZS4gVXNlcnMgbXVzdCBtYW51YWxseSByZS1sYXlvdXQgdGhlIHRleHQgXG4gICAgICogZm9yIHdvcmQgd3JhcHBpbmcuXG4gICAgICovXG4gICAgXCJmb250XCI6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZXJhdG9yLmZvbnQ7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICB2YXIgb2xkRm9udCA9IHRoaXMuaXRlcmF0b3IuZm9udDtcbiAgICAgICAgICAgIHRoaXMuaXRlcmF0b3IuZm9udCA9IHZhbDtcbiAgICAgICAgICAgIGlmIChvbGRGb250ICE9PSB0aGlzLml0ZXJhdG9yLmZvbnQpXG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhckxheW91dCgpO1xuICAgICAgICB9LFxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJZiB0aGUgbmV3IGZvbnQgc2l6ZSBkaWZmZXJzIGZyb20gdGhlIGxhc3QsIHRoZSB0ZXh0IGxheW91dCBpcyBjbGVhcmVkXG4gICAgICogYW5kIHBsYWNlZCBvbnRvIGEgc2luZ2xlIGxpbmUuIFVzZXJzIG11c3QgbWFudWFsbHkgcmUtbGF5b3V0IHRoZSB0ZXh0IFxuICAgICAqIGZvciB3b3JkIHdyYXBwaW5nLlxuICAgICAqL1xuICAgIFwiZm9udFNpemVcIjoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXRlcmF0b3IuZm9udFNpemU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICB2YXIgb2xkU2l6ZSA9IHRoaXMuaXRlcmF0b3IuZm9udFNpemU7XG5cbiAgICAgICAgICAgIHRoaXMuaXRlcmF0b3IuZm9udFNpemUgPSB2YWw7XG5cbiAgICAgICAgICAgIGlmIChvbGRTaXplICE9PSB0aGlzLml0ZXJhdG9yLmZvbnRTaXplKVxuICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJMYXlvdXQoKTtcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIFwibGluZUhlaWdodFwiOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pdGVyYXRvci5saW5lSGVpZ2h0O1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICAgICAgdGhpcy5pdGVyYXRvci5saW5lSGVpZ2h0ID0gdmFsO1xuICAgICAgICB9LFxuICAgIH0sXG4gICAgXCJsZXR0ZXJTcGFjaW5nXCI6IHtcbiAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pdGVyYXRvci5sZXR0ZXJTcGFjaW5nO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICAgICAgdGhpcy5pdGVyYXRvci5sZXR0ZXJTcGFjaW5nID0gdmFsO1xuICAgICAgICB9LFxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJZiB0aGUgbmV3IHRleHQgaXMgZGlmZmVyZW50IGZyb20gdGhlIGxhc3QsIHRoZSBsYXlvdXQgKGkuZS4gd29yZC13cmFwcGluZylcbiAgICAgKiBpcyBjbGVhcmVkIGFuZCB0aGUgcmVzdWx0IGlzIGEgc2luZ2xlIGxpbmUgb2YgdGV4dCAoc2ltaWxhciB0byBIVE1MNSBjYW52YXMgdGV4dFxuICAgICAqIHJlbmRlcmluZykuXG4gICAgICogXG4gICAgICogVGhlIHRleHQgdGhlbiBuZWVkcyB0byBiZSByZS13b3Jkd3JhcHBlZCB3aXRoIGEgY2FsbCB0byBgbGF5b3V0KClgLlxuICAgICAqL1xuICAgIFwidGV4dFwiOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdGV4dDtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgICAgICAgIHRleHQgPSB0ZXh0fHxcIlwiO1xuXG4gICAgICAgICAgICB2YXIgb2xkID0gdGhpcy5fdGV4dDtcbiAgICAgICAgICAgIHRoaXMuX3RleHQgPSB0ZXh0O1xuICAgICAgICAgICAgdGhpcy53b3Jkd3JhcC50ZXh0ID0gdGhpcy50ZXh0O1xuXG4gICAgICAgICAgICBpZiAodGhpcy5fdGV4dCAhPT0gb2xkKSBcbiAgICAgICAgICAgICAgICB0aGlzLmNsZWFyTGF5b3V0KCk7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuLyoqXG4gKiBDbGVhcnMgdGhlIHRleHQgbGF5b3V0IGFuZCB3b3JkLXdyYXBwaW5nLCBwbGFjaW5nIGFsbCBvZiBpdCBvbiBhIHNpbmdsZSBsaW5lLlxuICovXG5UZXh0UmVuZGVyZXIucHJvdG90eXBlLmNsZWFyTGF5b3V0ID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy53b3Jkd3JhcC50ZXh0ID0gdGhpcy50ZXh0O1xuICAgIHRoaXMud29yZHdyYXAuZW1wdHkoKTtcblxuICAgIGlmICh0aGlzLml0ZXJhdG9yLmZvbnQpIC8vZm9udCBtaWdodCBub3QgaGF2ZSBiZWVuIHBhc3NlZCBhdCBjb25zdHJ1Y3RvclxuICAgICAgICB0aGlzLndvcmR3cmFwLmNsZWFyTGF5b3V0KHRoaXMuaXRlcmF0b3IpO1xufTtcblxuLyoqXG4gKiBDYWxscyB0aGUgd29yZCB3cmFwcGVyIHRvIGxheW91dCB0aGUgY3VycmVudCB0ZXh0IHN0cmluZyxcbiAqIGJhc2VkIG9uIHRoZSB3cmFwIHdpZHRoIGFuZCBhbnkgY3VycmVudCB3b3Jkd3JhcHBpbmcgb3B0aW9ucy5cbiAqXG4gKiBUaGlzIGlzIGNhbGxlZCB3aGVuIHRoZSB0ZXh0IGlzIGNoYW5nZWQuIFxuICogXG4gKiBAcmV0dXJuIHtbdHlwZV19IFtkZXNjcmlwdGlvbl1cbiAqL1xuVGV4dFJlbmRlcmVyLnByb3RvdHlwZS5sYXlvdXQgPSBmdW5jdGlvbih3cmFwV2lkdGgpIHtcbiAgICB0aGlzLndvcmR3cmFwLnRleHQgPSB0aGlzLnRleHQ7XG4gICAgdGhpcy53b3Jkd3JhcC5lbXB0eSgpO1xuICAgIHRoaXMud29yZHdyYXAubGF5b3V0KHRoaXMuaXRlcmF0b3IsIHdyYXBXaWR0aCk7XG59O1xuXG4vKipcbiAqIFwiUmVuZGVyc1wiIHRoaXMgZ2x5cGggYXQgdGhlIGdpdmVuIGxvY2F0aW9uLiBUaGlzIG1heSBpbnZvbHZlIGZpbGxpbmdcbiAqIGEgVkJPIHdpdGggdmVydGV4IGRhdGEsIG9yIGl0IG1heSBiZSBhIGRpcmVjdCBjYWxsIHRvIGRyYXcgYSBiaXRtYXAgZ2x5cGhcbiAqIG9yIHNoYXBlIG91dGxpbmUuXG4gKiBAcmV0dXJuIHtbdHlwZV19IFtkZXNjcmlwdGlvbl1cbiAqL1xuVGV4dFJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJHbHlwaCA9IGZ1bmN0aW9uKCkge1xuXG59O1xuXG5UZXh0UmVuZGVyZXIucHJvdG90eXBlLnJlbmRlclVuZGVybGluZSA9IGZ1bmN0aW9uKCkge1xuXG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGJvdW5kcyBvZiB0aGUgY3VycmVudCB0ZXh0IGxheW91dC4gXG4gKlxuICogVGhlIGhlaWdodCBkb2VzIG5vdCBleHRlbmQgcGFzdCB0aGUgYmFzZWxpbmUgb2YgdGhlXG4gKiBsYXN0IGxpbmU7IHVubGVzcyBgaW5jbHVkZVVuZGVybGluZWAgaXMgdHJ1ZSwgaW4gd2hpY2hcbiAqIGNhc2UgdGhlIHVuZGVybGluZSdzIHBvc2l0aW9uIGFuZCBoZWlnaHQgaXMgaW5jbHVkZWRcbiAqIGluIHRoZSBjYWxjdWxhdGlvbi4gXG4gKlxuICogVGhlIGJvdW5kaW5nIHkgcG9zaXRpb24gaXMgb2Zmc2V0IHNvIHRoYXQgdGhlIGJveCBoYXMgYW4gdXBwZXItbGVmdFxuICogb3JpZ2luLCBmb3IgcGFyaXR5IHdpdGggSFRNTDUgY2FudmFzIHJlbmRlcmluZy5cbiAqIFxuICogQHBhcmFtIHtCb29sZWFufSBpbmNsdWRlVW5kZXJsaW5lIHdoZXRoZXIgdG8gaW5jbHVkZSB0aGUgdW5kZXJsaW5lIGluIHRoZSBjYWxjdWxhdGlvbiwgZGVmYXVsdCBmYWxzZVxuICogQHBhcmFtIHtPYmplY3R9IG91dCBhbiBvcHRpb25hbCB7d2lkdGgsIGhlaWdodH0gb2JqZWN0IGZvciByZS11c2VcbiAqIEByZXR1cm4ge09iamVjdH0gYSBzaXplIHdpdGggeyB3aWR0aCwgaGVpZ2h0IH0gcHJvcGVydGllc1xuICovXG5UZXh0UmVuZGVyZXIucHJvdG90eXBlLmdldEJvdW5kcyA9IGZ1bmN0aW9uIChpbmNsdWRlVW5kZXJsaW5lLCBvdXQpIHtcbiAgICBpZiAoIW91dClcbiAgICAgICAgb3V0ID0geyB4OiAwLCB5OiAwLCB3aWR0aDogMCwgaGVpZ2h0OiAwIH07XG5cbiAgICB2YXIgd29yZHdyYXBwZXIgPSB0aGlzLndvcmR3cmFwO1xuICAgIHZhciBpdHIgPSB0aGlzLml0ZXJhdG9yO1xuXG4gICAgLy90aWdodGVuIHRoZSBib3VuZGluZyBib3ggYXJvdW5kIHRoZSBmaXJzdCBsaW5lLi5cbiAgICB2YXIgZmlyc3RMaW5lSGVpZ2h0ID0gMDtcbiAgICBpZiAod29yZHdyYXBwZXIubGluZXMubGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgZmlyc3RMaW5lID0gd29yZHdyYXBwZXIubGluZXNbMF07XG4gICAgICAgIGl0ci5nZXRCb3VuZHModGhpcy50ZXh0LCBmaXJzdExpbmUuc3RhcnQsIGZpcnN0TGluZS5lbmQsIHVuZGVmaW5lZCwgdG1wQm91bmRzKTtcbiAgICAgICAgZmlyc3RMaW5lSGVpZ2h0ID0gdG1wQm91bmRzLmhlaWdodDtcbiAgICB9XG5cbiAgICBvdXQud2lkdGggPSB3b3Jkd3JhcHBlci5nZXRNYXhMaW5lV2lkdGgoKTsgICBcbiAgICBvdXQuaGVpZ2h0ID0gTWF0aC5tYXgoMCwgd29yZHdyYXBwZXIubGluZXMubGVuZ3RoLTEpICogaXRyLmdldExpbmVHYXAoKSArIGZpcnN0TGluZUhlaWdodDtcblxuICAgIG91dC54ID0gMDtcbiAgICBvdXQueSA9IC1vdXQuaGVpZ2h0O1xuXG4gICAgaWYgKGluY2x1ZGVVbmRlcmxpbmUpIHtcbiAgICAgICAgdmFyIHVuZGVybGluZUhlaWdodCA9IHRoaXMuY29tcHV0ZVVuZGVybGluZUhlaWdodCgpO1xuICAgICAgICB2YXIgdW5kZXJsaW5lUG9zaXRpb24gPSB0aGlzLmNvbXB1dGVVbmRlcmxpbmVQb3NpdGlvbigpO1xuICAgICAgICB2YXIgdW5kZXJsaW5lT2ZmID0gdW5kZXJsaW5lUG9zaXRpb24rdW5kZXJsaW5lSGVpZ2h0LzI7XG4gICAgICAgIG91dC5oZWlnaHQgKz0gdW5kZXJsaW5lT2ZmO1xuICAgIH1cblxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBzY2FsZWQgdW5kZXJsaW5lIGhlaWdodCBhcyBwaXhlbHMsIGJhc2VkIG9uIFxuICogdGhlIGV4cGxpY2l0IGB1bmRlcmxpbmVIZWlnaHRgIChpbiBwaXhlbHMpLiBJZiBgdW5kZXJsaW5lSGVpZ2h0YCBpc1xuICogdW5kZWZpbmVkIG9yIG51bGwsIGl0IHdpbGwgdHJ5IHRvIHVzZSB0aGUgZm9udCdzIG5vbi16ZXJvIHVuZGVybGluZSBoZWlnaHQsIFxuICogb3RoZXJ3aXNlIGRlZmF1bHQgdG8gMS84IG9mIHRoZSBmb250J3MgRU0gc3F1YXJlLlxuICogXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IHRoZSBwaXhlbCBoZWlnaHQgb2YgdGhlIHVuZGVybGluZSBcbiAqL1xuVGV4dFJlbmRlcmVyLnByb3RvdHlwZS5jb21wdXRlVW5kZXJsaW5lSGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBmb250ID0gdGhpcy5mb250O1xuICAgIHZhciBzY2FsZSA9IHRoaXMuaXRlcmF0b3IuZm9udFNjYWxlO1xuICAgIGlmICh0aGlzLnVuZGVybGluZVRoaWNrbmVzcz09PTB8fHRoaXMudW5kZXJsaW5lVGhpY2tuZXNzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVuZGVybGluZVRoaWNrbmVzczsgXG4gICAgfSBlbHNlIGlmIChmb250LnVuZGVybGluZV90aGlja25lc3MpIHtcbiAgICAgICAgcmV0dXJuIGZvbnQudW5kZXJsaW5lX3RoaWNrbmVzcyAqIHNjYWxlOyBcbiAgICB9IGVsc2UgaWYgKGZvbnQuYml0bWFwKVxuICAgICAgICByZXR1cm4gZm9udC5zaXplLzg7XG4gICAgZWxzZVxuICAgICAgICByZXR1cm4gKGZvbnQudW5pdHNfcGVyX0VNLzgpKnNjYWxlO1xufTtcblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgc2NhbGVkIHVuZGVybGluZSBoZWlnaHQgYXMgcGl4ZWxzLCBiYXNlZCBvbiBcbiAqIHRoZSBleHBsaWNpdCBgdW5kZXJsaW5lUG9zaXRpb25gIChpbiBwaXhlbHMpLiBJZiBgdW5kZXJsaW5lUG9zaXRpb25gIGlzXG4gKiB1bmRlZmluZWQgb3IgbnVsbCwgaXQgd2lsbCB0cnkgdG8gdXNlIHRoZSBmb250J3Mgbm9uLXplcm8gdW5kZXJsaW5lIHBvc2l0aW9uLCBcbiAqIG90aGVyd2lzZSBkZWZhdWx0IHRvIDEvNCBvZiB0aGUgZm9udCdzIEVNIHNxdWFyZS5cbiAqXG4gKiBUaGlzIGlzIHRoZSBZIG9mZnNldCBmcm9tIHRoZSB0ZXh0IGJhc2VsaW5lIHRvIHRoZSBjZW50ZXIgb2YgdGhlIHVuZGVybGluZSBcbiAqIGJhciwgaW4gcGl4ZWxzLiBJdCBpcyBnZW5lcmFsbHkgYSBwb3NpdGl2ZSB2YWx1ZS5cbiAqIFxuICogQHJldHVybiB7TnVtYmVyfSB0aGUgcGl4ZWwgcG9zaXRpb24gb2YgdGhlIHVuZGVybGluZSBcbiAqL1xuVGV4dFJlbmRlcmVyLnByb3RvdHlwZS5jb21wdXRlVW5kZXJsaW5lUG9zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGZvbnQgPSB0aGlzLmZvbnQ7XG4gICAgdmFyIHNjYWxlID0gdGhpcy5pdGVyYXRvci5mb250U2NhbGU7XG4gICAgICAgIFxuICAgIGlmICh0aGlzLnVuZGVybGluZVBvc2l0aW9uPT09MHx8dGhpcy51bmRlcmxpbmVQb3NpdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy51bmRlcmxpbmVQb3NpdGlvbjsgXG4gICAgfSBlbHNlIGlmIChmb250LnVuZGVybGluZV9wb3NpdGlvbikge1xuICAgICAgICByZXR1cm4gLWZvbnQudW5kZXJsaW5lX3Bvc2l0aW9uICogc2NhbGU7IFxuICAgIH0gZWxzZSBpZiAoZm9udC5iaXRtYXApIHtcbiAgICAgICAgcmV0dXJuIGZvbnQuc2l6ZS80O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAoZm9udC51bml0c19wZXJfRU0vNCkqc2NhbGU7XG4gICAgfVxufTtcblxuLyoqXG4gKiBHZXRzIHRoZSBkZXNjZW50IG9mIHRoZSBjdXJyZW50IGZvbnQgKGFzc3VtZXMgaXRzIHNpemUgXG4gKiBpcyBhbHJlYWR5IHNldCkuIFRoaXMgaXMgYW4gYWJzb2x1dGUgKHBvc2l0aXZlKSB2YWx1ZS5cbiAqIFxuICogQHJldHVybiB7W3R5cGVdfSBbZGVzY3JpcHRpb25dXG4gKi9cblRleHRSZW5kZXJlci5wcm90b3R5cGUuZ2V0RGVzY2VuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBNYXRoLmFicyh0aGlzLml0ZXJhdG9yLmZvbnRTY2FsZSAqIHRoaXMuaXRlcmF0b3IuZm9udC5kZXNjZW5kZXIpO1xufTtcblxuLyoqXG4gKiBHZXRzIHRoZSBkZXNjZW50IG9mIHRoZSBjdXJyZW50IGZvbnQgKGFzc3VtZXMgaXRzIHNpemUgXG4gKiBpcyBhbHJlYWR5IHNldCkuIFRoaXMgaXMgYW4gYWJzb2x1dGUgKHBvc2l0aXZlKSB2YWx1ZS5cbiAqIFxuICogQHJldHVybiB7W3R5cGVdfSBbZGVzY3JpcHRpb25dXG4gKi9cblRleHRSZW5kZXJlci5wcm90b3R5cGUuZ2V0QXNjZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIE1hdGguYWJzKHRoaXMuaXRlcmF0b3IuZm9udFNjYWxlICogdGhpcy5pdGVyYXRvci5mb250LmFzY2VuZGVyKTtcbn07XG5cbi8vU2lnbmFscyBmb3Igc3ViY2xhc3NlcyB0byBvcHRpb25hbGx5IGltcGxtZWVudFxuLy9UaGlzIG1heSBiZSB1c2VmdWwgdG8gc3RvcC9zdGFydCBwYXRocyB3aXRoIGRpZmZlcmVudCBmaWxsc1xuVGV4dFJlbmRlcmVyLnByb3RvdHlwZS5vbkJlZ2luID0gZnVuY3Rpb24oKSB7IH1cblRleHRSZW5kZXJlci5wcm90b3R5cGUub25FbmQgPSBmdW5jdGlvbigpIHsgfVxuVGV4dFJlbmRlcmVyLnByb3RvdHlwZS5vbkJlZ2luTGluZSA9IGZ1bmN0aW9uKGxpbmVJbmRleCkgeyB9XG5UZXh0UmVuZGVyZXIucHJvdG90eXBlLm9uRW5kTGluZSA9IGZ1bmN0aW9uKGxpbmVJbmRleCkgeyB9XG5cbi8qKlxuICogUmVuZGVycyB0aGUgY3VycmVudCB0ZXh0IGxheW91dCwgd2hlcmUgbG93ZXItbGVmdCBpcyBcbiAqIHRoZSBvcmlnaW4uIE11bHRpcGxlIGxpbmVzIHdpbGwgYmUgcG9zaXRpb25lZCBhYm92ZSB0aGVcbiAqIG9yaWdpbi5cbiAqL1xuVGV4dFJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoeCwgeSwgc3RhcnQsIGVuZCkge1xuICAgIHggPSB4fHwwO1xuICAgIHkgPSB5fHwwO1xuXG4gICAgdmFyIHRleHQgPSB0aGlzLnRleHQ7XG4gICAgdmFyIHdvcmR3cmFwcGVyID0gdGhpcy53b3Jkd3JhcDtcblxuICAgIC8vaWYgd2UgaGF2ZSBub3RoaW5nIHRvIGRyYXdcbiAgICBpZiAoIXRleHQgfHwgd29yZHdyYXBwZXIubGluZXMubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm47XG5cbiAgICAvL2RlZmF1bHQgc3RhcnQvZW5kIHBhcmFtc1xuICAgIHN0YXJ0ID0gc3RhcnR8fDA7XG4gICAgZW5kID0gdHlwZW9mIGVuZCA9PT0gXCJudW1iZXJcIiA/IGVuZCA6IHRleHQubGVuZ3RoO1xuXG4gICAgdmFyIGl0ciA9IHRoaXMuaXRlcmF0b3I7XG4gICAgdmFyIHNjYWxlID0gaXRyLmZvbnRTY2FsZTtcbiAgICB2YXIgZm9udCA9IGl0ci5mb250O1xuICAgIHZhciB1bmRlcmxpbmUgPSB0aGlzLnVuZGVybGluZTtcblxuICAgIC8vdXNlZCBmb3IgYWxpZ25tZW50Li4uXG4gICAgdmFyIG1heExpbmVXaWR0aCA9IHdvcmR3cmFwcGVyLmdldE1heExpbmVXaWR0aCgpO1xuICAgIFxuICAgIHkgLT0gTWF0aC5tYXgoMCwgd29yZHdyYXBwZXIubGluZXMubGVuZ3RoLTEpICogaXRyLmdldExpbmVHYXAoKTtcblxuXG4gICAgLy91c2UgbnVtYmVycyB0byBhdm9pZCBzdHIgY29tcGFyZSBmb3IgZWFjaCBnbHlwaFxuICAgIHZhciBhbGlnblR5cGUgPSBBTElHTl9BUlJBWS5pbmRleE9mKHRoaXMuYWxpZ258fFwiXCIpO1xuICAgIGlmIChhbGlnblR5cGU9PT0tMSlcbiAgICAgICAgYWxpZ25UeXBlID0gTEVGVF9BTElHTjtcblxuICAgIHZhciB1bmRlcmxpbmVYID0gMDtcbiAgICB2YXIgdW5kZXJsaW5lU3RhcnRYID0gMDtcbiAgICB2YXIgdW5kZXJsaW5lWSA9IDA7XG4gICAgdmFyIHVuZGVybGluZVdpZHRoID0gMDtcblxuICAgIHZhciB1bmRlcmxpbmVTdGFydGVkID0gZmFsc2U7XG5cbiAgICAvL1RyeSB0byB1c2UgdXNlci1zcGVjaWZpZWQgdW5kZXJsaW5lIHNldHRpbmdzLCBvdGhlcndpc2UgdXNlIHRoZSBmb250IGlmIHBvc3NpYmxlLFxuICAgIC8vb3RoZXJ3aXNlIGp1c3QgdXNlIGEgcm91Z2ggZGVmYXVsdCBiYXNlZCBvbiBFTSBzcXVhcmUuICAgIFxuICAgIHZhciB1bmRlcmxpbmVQb3MgPSB0aGlzLmNvbXB1dGVVbmRlcmxpbmVQb3NpdGlvbigpO1xuICAgIHZhciB1bmRlcmxpbmVIZWlnaHQgPSB0aGlzLmNvbXB1dGVVbmRlcmxpbmVIZWlnaHQoKTtcblxuICAgIHRoaXMub25CZWdpbigpO1xuICAgIFxuICAgIC8vc2V0IHRoZSBvcmlnaW4gYW5kIHBlbiBwb3NpdGlvblxuICAgIGl0ci5iZWdpbih4LCB5KTtcbiAgICBmb3IgKHZhciBrPTA7IGs8d29yZHdyYXBwZXIubGluZXMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgdmFyIGxpbmUgPSB3b3Jkd3JhcHBlci5saW5lc1trXTtcbiAgICAgICAgdW5kZXJsaW5lU3RhcnRlZCA9IGZhbHNlO1xuXG4gICAgICAgIHZhciBsYXN0QWR2YW5jZSA9IDA7XG5cbiAgICAgICAgdmFyIGxpbmVYID0gaXRyLnBlbi54O1xuICAgICAgICB2YXIgbGluZVkgPSBpdHIucGVuLnk7XG5cbiAgICAgICAgdGhpcy5vbkJlZ2luTGluZShrKTtcblxuICAgICAgICAvL1RPRE86IHVzZSBtdWx0aXBsZSBOb2RlcyBpbnNpZGUgYSBzaW5nbGUgbGluZVxuICAgICAgICAvL2Egbm9kZSB3aWxsIGhhdmUgYXR0cmlidXRlcyBsaWtlIGZvbnQsIHNpemUsIGNvbG9yLCBcbiAgICAgICAgLy9sZXR0ZXItc3BhY2luZywgdW5kZXJsaW5lLCBldGMuXG4gICAgICAgIC8vVGhpcyB3aWxsIGFmZmVjdCB0aGUgbGluZSBoZWlnaHQsIGFzIGl0IHdpbGwgaGF2ZSB0byBiZSB0aGUgbWF4IG9mIGFsbCBub2Rlcy5cblxuICAgICAgICBmb3IgKHZhciBpPWxpbmUuc3RhcnQ7IGk8bGluZS5lbmQ7IGkrKykge1xuICAgICAgICAgICAgdmFyIGNociA9IHRleHQuY2hhckF0KGkpO1xuXG4gICAgICAgICAgICAvL1N0ZXAgdGhlIGl0ZXJhdG9yLCBtb3ZpbmcgZm9yd2FyZCBiYXNlZCBvbiBrZXJuaW5nIGZyb20gbGFzdCBjaGFyXG4gICAgICAgICAgICB2YXIgZ2x5cGggPSBpdHIuc3RlcCh0ZXh0LCBpKTtcblxuICAgICAgICAgICAgaWYgKCFnbHlwaClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAgICAgLy93aXRoaW4gZGVzaXJlZCByYW5nZVxuICAgICAgICAgICAgaWYgKGkgPj0gc3RhcnQgJiYgaSA8IGVuZCkge1xuICAgICAgICAgICAgICAgIHZhciB0eCA9IGl0ci5wZW4ueDtcbiAgICAgICAgICAgICAgICB2YXIgdHkgPSBpdHIucGVuLnk7XG5cbiAgICAgICAgICAgICAgICBpZiAoYWxpZ25UeXBlID09PSBDRU5URVJfQUxJR04pIHtcbiAgICAgICAgICAgICAgICAgICAgdHggKz0gKG1heExpbmVXaWR0aC1saW5lLndpZHRoKS8yO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYWxpZ25UeXBlID09PSBSSUdIVF9BTElHTikge1xuICAgICAgICAgICAgICAgICAgICB0eCArPSAobWF4TGluZVdpZHRoLWxpbmUud2lkdGgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghdW5kZXJsaW5lU3RhcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICB1bmRlcmxpbmVYID0gdHg7XG4gICAgICAgICAgICAgICAgICAgIHVuZGVybGluZVN0YXJ0WCA9IHR4O1xuICAgICAgICAgICAgICAgICAgICB1bmRlcmxpbmVZID0gdHkgKyB1bmRlcmxpbmVQb3M7XG4gICAgICAgICAgICAgICAgICAgIHVuZGVybGluZVdpZHRoID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdW5kZXJsaW5lU3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdW5kZXJsaW5lV2lkdGggPSB0eCAtIHVuZGVybGluZVN0YXJ0WDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlckdseXBoKGksIGdseXBoLCBzY2FsZSwgdHgsIHR5KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9BZHZhbmNlIHRoZSBpdGVyYXRvciB0byB0aGUgbmV4dCBnbHlwaCBpbiB0aGUgc3RyaW5nXG4gICAgICAgICAgICB2YXIgbmV3QWR2YW5jZSA9IGl0ci5hZHZhbmNlKGdseXBoKTtcblxuICAgICAgICAgICAgaWYgKGkgPj0gc3RhcnQgJiYgaSA8IGVuZClcbiAgICAgICAgICAgICAgICBsYXN0QWR2YW5jZSA9IG5ld0FkdmFuY2U7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm9uRW5kTGluZShrKTtcblxuICAgICAgICBpZiAodW5kZXJsaW5lKSB7XG4gICAgICAgICAgICB1bmRlcmxpbmVXaWR0aCArPSBsYXN0QWR2YW5jZTtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyVW5kZXJsaW5lKHVuZGVybGluZVgsIHVuZGVybGluZVktdW5kZXJsaW5lSGVpZ2h0LzIsIHVuZGVybGluZVdpZHRoLCB1bmRlcmxpbmVIZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvL1N0ZXBzIGRvd24gYSBsaW5lLi4uXG4gICAgICAgIGlmIChrIDwgd29yZHdyYXBwZXIubGluZXMubGVuZ3RoLTEpIHtcbiAgICAgICAgICAgIGl0ci5hZHZhbmNlTGluZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy9maW5pc2ggdGhlIGl0ZXJhdG9yLi4uXG4gICAgaXRyLmVuZCgpO1xuICAgIHRoaXMub25FbmQoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVGV4dFJlbmRlcmVyOyIsInZhciB1dGlsID0gcmVxdWlyZSgnZm9udHBhdGgtdXRpbCcpO1xuXG52YXIgREVGQVVMVF9UQUJfV0lEVEggPSA0O1xuXG5mdW5jdGlvbiBHbHlwaEl0ZXJhdG9yKGZvbnQsIGZvbnRTaXplKSB7XG4gICAgdGhpcy5fZm9udFNpemUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fZm9udFNjYWxlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2ZvbnQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5mb250U2NhbGUgPSAxLjA7XG4gICAgdGhpcy5rZXJuaW5nID0gdHJ1ZTtcbiAgICB0aGlzLmxldHRlclNwYWNpbmcgPSAwO1xuICAgIHRoaXMubGluZUhlaWdodCA9IHVuZGVmaW5lZDtcbiAgICBcbiAgICB0aGlzLmZvbnRTaXplID0gdHlwZW9mIGZvbnRTaXplID09PSAnbnVtYmVyJ1xuICAgICAgICAgICAgPyBmb250U2l6ZVxuICAgICAgICAgICAgOiAoZm9udCA/IGZvbnQuc2l6ZSA6IHVuZGVmaW5lZCk7XG4gICAgdGhpcy5mb250ID0gZm9udDtcblxuICAgIC8vTnVtYmVyIG9mIHNwYWNlcyBmb3IgYSB0YWIgY2hhcmFjdGVyXG4gICAgdGhpcy50YWJXaWR0aCA9IERFRkFVTFRfVEFCX1dJRFRIO1xuICAgIHRoaXMuX3RhYkdseXBoID0gbnVsbDtcblxuICAgIHRoaXMub3JpZ2luID0geyB4OiAwLCB5OiAwIH07XG4gICAgdGhpcy5wZW4gPSB7IHg6IDAsIHk6IDAgfTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEdseXBoSXRlcmF0b3IucHJvdG90eXBlLCBcImZvbnRcIiwge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9mb250O1xuICAgIH0sXG5cbiAgICBzZXQ6IGZ1bmN0aW9uKGZvbnQpIHtcbiAgICAgICAgdGhpcy5fZm9udCA9IGZvbnQ7XG5cbiAgICAgICAgLy9EZXRlcm1pbmUgdGhlIG5ldyBzY2FsaW5nIGZhY3Rvci4uLlxuICAgICAgICBpZiAoZm9udCkge1xuICAgICAgICAgICAgdGhpcy5mb250U2NhbGUgPSB1dGlsLmdldFB4U2NhbGUoZm9udCwgdGhpcy5mb250U2l6ZSk7XG5cbiAgICAgICAgICAgIC8vVXBkYXRlcyB0aGUgdGFiIGdseXBoXG4gICAgICAgICAgICB0aGlzLnRhYldpZHRoID0gdGhpcy5fdGFiV2lkdGg7XG4gICAgICAgIH1cbiAgICB9LFxufSk7XG5cbi8vVGhlcmUgbWlnaHQgYmUgYSBiZXR0ZXIgd2F5IG9mIGhhbmRsaW5nIHRhYiB3aWR0aCB1c2luZyBGcmVlVHlwZSA/IFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEdseXBoSXRlcmF0b3IucHJvdG90eXBlLCBcInRhYldpZHRoXCIsIHtcblxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90YWJXaWR0aDtcbiAgICB9LFxuXG4gICAgc2V0OiBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgdGhpcy5fdGFiV2lkdGggPSB2YWw9PT0wIHx8IHZhbCA/IHZhbCA6IERFRkFVTFRfVEFCX1dJRFRIO1xuICAgICAgICB0aGlzLl90YWJHbHlwaCA9IHt9O1xuXG4gICAgICAgIHZhciBzcGFjZUdseXBoID0gdGhpcy5mb250ID8gdGhpcy5mb250LmdseXBoc1tcIiBcIl0gOiBudWxsO1xuICAgICAgICBpZiAoc3BhY2VHbHlwaCkge1xuICAgICAgICAgICAgdGhpcy5fdGFiR2x5cGggPSB7fTtcbiAgICAgICAgICAgIGZvciAodmFyIGsgaW4gc3BhY2VHbHlwaCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3RhYkdseXBoW2tdID0gc3BhY2VHbHlwaFtrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl90YWJHbHlwaC54b2ZmKVxuICAgICAgICAgICAgICAgIHRoaXMuX3RhYkdseXBoLnhvZmYgKj0gdGhpcy5fdGFiV2lkdGg7XG4gICAgICAgIH1cbiAgICB9LFxufSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShHbHlwaEl0ZXJhdG9yLnByb3RvdHlwZSwgXCJmb250U2l6ZVwiLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLl9mb250U2l6ZSAhPT0gJ251bWJlcicpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mb250LmJpdG1hcCBcbiAgICAgICAgICAgICAgICA/IHRoaXMuZm9udC5zaXplIFxuICAgICAgICAgICAgICAgIDogdXRpbC5wb2ludFRvUGl4ZWwodGhpcy5mb250LnNpemUpXG4gICAgICAgIHJldHVybiB0aGlzLl9mb250U2l6ZTtcbiAgICB9LFxuXG4gICAgc2V0OiBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgdGhpcy5fZm9udFNpemUgPSB2YWw7XG5cbiAgICAgICAgLy9JZiB0aGUgZm9udCBpcyBhbHJlYWR5IHNldCwgZGV0ZXJtaW5lIHRoZSBuZXcgc2NhbGluZyBmYWN0b3JcbiAgICAgICAgaWYgKHRoaXMuX2ZvbnQpIHtcbiAgICAgICAgICAgIHRoaXMuZm9udFNjYWxlID0gdXRpbC5nZXRQeFNjYWxlKHRoaXMuX2ZvbnQsIHRoaXMuX2ZvbnRTaXplKTtcbiAgICAgICAgfVxuICAgIH0sXG59KTtcblxuR2x5cGhJdGVyYXRvci5wcm90b3R5cGUuZ2V0S2VybmluZyA9IGZ1bmN0aW9uKGxlZnQsIHJpZ2h0KSB7XG4gICAgdmFyIGZvbnQgPSB0aGlzLmZvbnQ7XG5cbiAgICBpZiAoIWZvbnQgfHwgIWZvbnQua2VybmluZylcbiAgICAgICAgcmV0dXJuIDA7XG5cbiAgICB2YXIgdGFibGUgPSB0aGlzLmtlcm5pbmdUYWJsZTtcblxuICAgIGZvciAodmFyIGk9MDsgaTxmb250Lmtlcm5pbmcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGsgPSBmb250Lmtlcm5pbmdbaV07XG4gICAgICAgIGlmIChrWzBdID09PSBsZWZ0ICYmIGtbMV0gPT09IHJpZ2h0KSBcbiAgICAgICAgICAgIHJldHVybiBrWzJdO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbn07XG5cbkdseXBoSXRlcmF0b3IucHJvdG90eXBlLmJlZ2luID0gZnVuY3Rpb24oeCwgeSkge1xuICAgIHRoaXMub3JpZ2luLnggPSB4fHwwO1xuICAgIHRoaXMub3JpZ2luLnkgPSB5fHwwO1xuXG4gICAgdGhpcy5wZW4ueCA9IHRoaXMub3JpZ2luLng7XG4gICAgdGhpcy5wZW4ueSA9IHRoaXMub3JpZ2luLnk7XG59O1xuXG5HbHlwaEl0ZXJhdG9yLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbigpIHtcbiAgICAvLy4uIG1haW5seSBmb3IgY29uc2lzdGVuY3kgd2l0aCBiZWdpbigpXG4gICAgLy9NaWdodCBiZSB1c2VmdWwgbGF0ZXIgb25cbn07XG5cbkdseXBoSXRlcmF0b3IucHJvdG90eXBlLmdldExpbmVHYXAgPSBmdW5jdGlvbigpIHtcbiAgICAvL0xpbmUgaGVpZ2h0IGhhbmRsaW5nIGlzIGEgbWVzcyBpbiBicm93c2Vycy5cbiAgICAvL01heWJlIHRoZSBiZXN0IHNvbHV0aW9uIGlzIHRvIGVuY291cmFnZSB1c2VycyB0byBcbiAgICAvL3NwZWNpZnkgcGl4ZWwgbGluZSBoZWlnaHRzIGlmIHRoZXkgd2FudCB0byBtYXRjaCBicm93c2VyIHN0YW5kYXJkcyxcbiAgICAvL290aGVyd2lzZSBpdCdzIHVucmVhc29uYWJsZSB0byBleHBlY3QgdGhlIGxpbmUgZ2FwcyB0byBsaW5lIHVwIGV4YWN0bHlcbiAgICAvL2Fjcm9zcyBhbGwgYnJvd3NlcnMuIEV4YW1wbGUgb2YgdGhlIGRpc2FzdGVyOlxuICAgIC8vaHR0cDovL2xpc3RzLnczLm9yZy9BcmNoaXZlcy9QdWJsaWMvd3d3LXN0eWxlLzIwMDhKYW4vMDQxMy5odG1sXG5cbiAgICAvL0ZvciByZWZlcmVuY2UsIHNvbWUgYmFzZWxpbmUtdG8tYmFzZWxpbmUgY2FsY3VsYXRpb25zOlxuICAgIC8vaHR0cDovL3d3dy5taWNyb3NvZnQuY29tL3R5cG9ncmFwaHkvb3RzcGVjL3JlY29tLmh0bVxuICAgIC8vZnJlZXR5cGUub3JnL2ZyZWV0eXBlMi9kb2NzL3JlZmVyZW5jZS9mdDItYmFzZV9pbnRlcmZhY2UuaHRtbFxuICAgIC8vaHR0cDovL3d3dy5mcmVldHlwZS5vcmcvZnJlZXR5cGUyL2RvY3MvZ2x5cGhzL2dseXBocy0zLmh0bWxcblxuICAgIC8vVW5mb3J0dW5hdGVseSBub25lIG9mIHRoZXNlIGFyZSBwcm9kdWNpbmcgbGluZS1oZWlnaHRzIHRoYXQgYXZvaWQgb3ZlcmxhcHBpbmdcbiAgICAvL29yIHJlc2VtYmxlIGJyb3dzZXIgcmVuZGVyaW5nIGluIGFueSB3YXkuIFxuXG4gICAgLy8gSWYgQ1NTIHVzZXMgMWVtIG9yIDEsIHRoZSBicm93c2VyIG9mZnNldHMgdGhlIGxpbmUgYnkgdGhlIFxuICAgIC8vIGZvbnQncyBwaXhlbCBzaXplLiBJZiBhbiBleGFjdCBwaXhlbCBsaW5lLWhlaWdodCBpcyBzcGVjaWZpZWQsXG4gICAgLy8gdGhlIGJyb3dzZXIgd2lsbCB1c2UgdGhhdCArIGEgY29tcHV0ZWQgXCJsaW5lZ2FwLlwiIFxuICAgIC8vIElmICdhdXRvJyBpcyBzcGVjaWZpZWQgZm9yIGxpbmUtaGVpZ2h0LCB0aGUgY2FsY3VsYXRpb25zIHNlZW1cbiAgICAvLyBtdWNoIG1vcmUgY29tcGxleCBhbmQgYnJvd3Nlci9wbGF0Zm9ybSBkZXBlbmRlbnQgKG5vdCBpbmNsdWRlZCBoZXJlKS5cbiAgICBcbiAgICB2YXIgZm9udCA9IHRoaXMuZm9udCxcbiAgICAgICAgc2NhbGUgPSB0aGlzLmZvbnRTY2FsZTtcbiAgICB2YXIgZ2FwID0gKGZvbnQuaGVpZ2h0IC0gZm9udC5hc2NlbmRlciArIE1hdGguYWJzKGZvbnQuZGVzY2VuZGVyKSkgKiBzY2FsZTsgICAgXG4gICAgdmFyIGxpbmVIZWlnaHQgPSB0aGlzLmxpbmVIZWlnaHQ7XG4gICAgXG4gICAgbGluZUhlaWdodCA9IChsaW5lSGVpZ2h0PT09MHx8bGluZUhlaWdodCkgXG4gICAgICAgICAgICA/IChsaW5lSGVpZ2h0ICsgZ2FwKVxuICAgICAgICAgICAgOiB0aGlzLmZvbnRTaXplO1xuICAgIHJldHVybiBsaW5lSGVpZ2h0O1xufTtcblxuR2x5cGhJdGVyYXRvci5wcm90b3R5cGUudHJhbnNsYXRlID0gZnVuY3Rpb24oeCwgeSkge1xuICAgIHRoaXMub3JpZ2luLnggKz0geHx8MDtcbiAgICB0aGlzLm9yaWdpbi55ICs9IHl8fDA7XG5cbiAgICB0aGlzLnBlbi54ICs9IHh8fDA7XG4gICAgdGhpcy5wZW4ueSArPSB5fHwwO1xufTtcblxuR2x5cGhJdGVyYXRvci5wcm90b3R5cGUuc3RlcCA9IGZ1bmN0aW9uKHRleHQsIGluZGV4KSB7XG4gICAgdmFyIHNjYWxlID0gdGhpcy5mb250U2NhbGUsXG4gICAgICAgIGZvbnQgPSB0aGlzLl9mb250O1xuXG4gICAgdmFyIGNociA9IHRleHQuY2hhckF0KGluZGV4KTsgXG5cbiAgICBpZiAoY2hyID09PSAnXFx0JyAmJiB0aGlzLl90YWJHbHlwaCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGFiR2x5cGg7XG4gICAgfVxuXG4gICAgLy9Ta2lwIG1pc3NpbmcgY2hhcmFjdGVycy4uLlxuICAgIGlmICghKGNociBpbiBmb250LmdseXBocykpXG4gICAgICAgIHJldHVybjtcbiAgICBcbiAgICB2YXIgZ2x5cGggPSBmb250LmdseXBoc1tjaHJdO1xuXG4gICAgLy9JZiB3ZSBoYXZlIGEgY2hhciB0byB0aGUgbGVmdCwgZGV0ZXJtaW5lIGl0cyBrZXJuaW5nXG4gICAgaWYgKGluZGV4ID4gMCAmJiB0aGlzLmtlcm5pbmcpIHtcbiAgICAgICAgdmFyIGtlcm4gPSB0aGlzLmdldEtlcm5pbmcodGV4dC5jaGFyQXQoaW5kZXgtMSksIGNocik7XG4gICAgICAgIHRoaXMucGVuLnggKz0gKGtlcm4qc2NhbGUpO1xuICAgIH1cblxuICAgIHJldHVybiBnbHlwaDtcbn07XG5cbkdseXBoSXRlcmF0b3IucHJvdG90eXBlLmFkdmFuY2VMaW5lID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5wZW4ueSArPSB0aGlzLmdldExpbmVHYXAoKTtcbiAgICB0aGlzLnBlbi54ID0gdGhpcy5vcmlnaW4ueDtcbn07XG5cbi8qKlxuICogQ2FsbGVkIGFmdGVyIHN0ZXAuIFxuICovXG5HbHlwaEl0ZXJhdG9yLnByb3RvdHlwZS5hZHZhbmNlID0gZnVuY3Rpb24oZ2x5cGgpIHtcbiAgICB2YXIgYWR2YW5jZSA9IChnbHlwaC54b2ZmICogdGhpcy5mb250U2NhbGUpO1xuICAgIC8vIEFkdmFuY2UgdG8gbmV4dCBwZW4gcG9zaXRpb25cbiAgICB0aGlzLnBlbi54ICs9IGFkdmFuY2UgKyB0aGlzLmxldHRlclNwYWNpbmc7XG4gICAgcmV0dXJuIGFkdmFuY2U7XG59O1xuXG4vKipcbiAqIFRoaXMgaXMgYSB1dGlsaXR5IGZ1bmN0aW9uIHRoYXQgcHJvdmlkZXMgdGhlIGJvdW5kcyBvZiB0aGUgZ2l2ZW5cbiAqIHRleHQgKGZyb20gc3RhcnQgYW5kIGVuZCBwb3NpdGlvbnMpIGFzIGlmIHRoZXkgd2VyZSBsYWlkIG91dCBob3Jpem9udGFsbHksXG4gKiBsZWZ0IHRvIHJpZ2h0LlxuICpcbiAqIEZvciBjb252ZW5pZW5jZSwgdGhpcyB3aWxsIG5vdCBhbHRlciB0aGUgY3VycmVudCBwZW4gYW5kIG9yaWdpbiBwb3NpdGlvbnMuXG4gKiBUaGlzIHdheSBpdCBjYW4gYmUgdXRpbGl6ZWQgaW5zaWRlIGEgZ2x5cGggaXRlcmF0aW9uIChpLmUuIGZvciByZW5kZXJpbmcpLlxuICpcbiAqIElmIGBhdmFpbGFibGVXaWR0aGAgaXMgc3BlY2lmaWVkLCB0aGlzIHdpbGwgYnJlYWsgYmVmb3JlIHJlYWNoaW5nIHRoZSBzcGVjaWZpZWRcbiAqIHBpeGVsIHdpZHRoLCB0byBlbnN1cmUgdGhhdCBhbGwgZ2x5cGhzIHdpbGwgZml0IGluc2lkZSB0aGUgYm91bmRzLiBcbiAqXG4gKiBUaGUgcmV0dXJuIG9iamVjdCBhbHNvIGluY2x1ZGVzIGEgYGdseXBoc2AgcHJvcGVydHksIHdoaWNoIGlzIHRoZSBudW1iZXIgb2YgZ2x5cGhzXG4gKiB0aGF0IGFyZSB2aXNpYmxlIHdpdGhpbiB0aGUgcmV0dXJuZWQgYm91bmRzLiBcbiAqXG4gKiBJZiBgb3V0YCBpcyBzcGVjaWZpZWQgKGFuIG9iamVjdCB3aXRoIHgsIHksIHdpZHRoLCBoZWlnaHQsIGFuZCBnbHlwaCBwcm9wZXJ0aWVzKSxcbiAqIGl0IHdpbGwgYmUgcmUtdXNlZC4gT3RoZXJ3aXNlIGEgbmV3IG9iamVjdCBpcyBjcmVhdGVkLlxuICogXG4gKiBAcGFyYW0ge1N0cmluZ30gdGV4dCB0aGUgdGV4dCB0byBjaGVja1xuICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0IHRoZSBzdGFydCBwb3NpdGlvbiwgZGVmYXVsdHMgdG8gMFxuICogQHBhcmFtIHtOdW1iZXJ9IGVuZCB0aGUgZW5kIHBvc2l0aW9uLCBleGNsdXNpdmUsIGRlZmF1bHRzIHRvIHRleHQgbGVuZ3RoXG4gKiBAcGFyYW0ge051bWJlcn0gYXZhaWxhYmxlV2lkdGggdGhlIHdpZHRoIGJlZm9yZSBzdG9wcGluZyB0aGUgYm91bmQgY2hlY2tcbiAqIEBwYXJhbSB7T2JqZWN0fSBvdXQgYW4gb2JqZWN0IHRvIHJlLXVzZSBmb3IgdGhlIHJldHVybiB2YWx1ZVxuICogQHJldHVybiB7T2JqZWN0fSB0aGUgYm91bmRzIGFuZCBnbHlwaCBjb3VudCB7eCx5LHdpZHRoLGhlaWdodCxnbHlwaHN9XG4gKi9cbkdseXBoSXRlcmF0b3IucHJvdG90eXBlLmdldEJvdW5kcyA9IGZ1bmN0aW9uKHRleHQsIHN0YXJ0LCBlbmQsIGF2YWlsYWJsZVdpZHRoLCBvdXQpIHtcbiAgICBpZiAoIW91dClcbiAgICAgICAgb3V0ID0geyB4OjAsIHk6MCwgd2lkdGg6IDAsIGhlaWdodDogMCwgZ2x5cGhzOiAwIH07XG5cbiAgICB2YXIgY2hlY2tXaWR0aCA9IGF2YWlsYWJsZVdpZHRoPT09MHx8YXZhaWxhYmxlV2lkdGg7XG5cbiAgICBzdGFydCA9IHN0YXJ0fHwwO1xuICAgIGVuZCA9IGVuZD09PTB8fGVuZCA/IGVuZCA6IHRleHQubGVuZ3RoO1xuXG4gICAgdmFyIG1heEhlaWdodCA9IDA7XG5cbiAgICBvdXQueCA9IDA7XG4gICAgb3V0LnkgPSAwO1xuICAgIG91dC5nbHlwaHMgPSAwO1xuXG4gICAgdmFyIG9sZFBlblggPSB0aGlzLnBlbi54LFxuICAgICAgICBvbGRQZW5ZID0gdGhpcy5wZW4ueSxcbiAgICAgICAgb2xkT3JpZ2luWCA9IHRoaXMub3JpZ2luLngsXG4gICAgICAgIG9sZE9yaWdpblkgPSB0aGlzLm9yaWdpbi55O1xuXG5cbiAgICB2YXIgZm9udCA9IHRoaXMuZm9udDtcbiAgICB0aGlzLmJlZ2luKCk7XG4gICAgZm9yICh2YXIgaT1zdGFydDsgaTxlbmQ7IGkrKykge1xuICAgICAgICB2YXIgY2hyID0gdGV4dC5jaGFyQXQoaSk7XG5cbiAgICAgICAgLy9zdGVwIHRoZSBpdGVyYXRvclxuICAgICAgICB2YXIgZ2x5cGggPSB0aGlzLnN0ZXAodGV4dCwgaSk7XG5cbiAgICAgICAgLy9pZiB0aGUgZ2x5cGggaXMgdmFsaWQsIHdlIGNhbiBhZHZhbmNlIHBhc3QgaXQgYW5kIGNhbGN1bGF0ZSBuZXcgaGVpZ2h0XG4gICAgICAgIGlmIChnbHlwaCkge1xuICAgICAgICAgICAgdmFyIGhlaWdodCA9IChnbHlwaC5oZWlnaHQpKnRoaXMuZm9udFNjYWxlO1xuXG4gICAgICAgICAgICBvdXQueSA9IE1hdGgubWF4KG91dC55LCB0aGlzLmZvbnRTY2FsZSooZ2x5cGguaGVpZ2h0LWdseXBoLmhieSkpO1xuXG4gICAgICAgICAgICBtYXhIZWlnaHQgPSBNYXRoLm1heChtYXhIZWlnaHQsIGhlaWdodCk7XG4gICAgICAgICAgICB2YXIgbGFzdEFkdmFuY2UgPSB0aGlzLmFkdmFuY2UoZ2x5cGgpO1xuXG4gICAgICAgICAgICAvL2lmIHdlJ3JlIHBhc3QgdGhlIGF2YWlsYWJsZSB3aWR0aFxuICAgICAgICAgICAgdmFyIG5ld1dpZHRoID0gdGhpcy5wZW4ueCAtIHRoaXMub3JpZ2luLng7XG4gICAgICAgICAgICBpZiAoY2hlY2tXaWR0aCAmJiAobmV3V2lkdGggLSBhdmFpbGFibGVXaWR0aCA+IDAuMDAxKSkge1xuICAgICAgICAgICAgICAgIHRoaXMucGVuLnggLT0gbGFzdEFkdmFuY2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG91dC5nbHlwaHMrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmVuZCgpO1xuXG4gICAgb3V0LndpZHRoID0gdGhpcy5wZW4ueCAtIHRoaXMub3JpZ2luLng7XG4gICAgb3V0LmhlaWdodCA9IG1heEhlaWdodDtcblxuICAgIHRoaXMucGVuLnggPSBvbGRQZW5YO1xuICAgIHRoaXMucGVuLnkgPSBvbGRQZW5ZO1xuICAgIHRoaXMub3JpZ2luLnggPSBvbGRPcmlnaW5YO1xuICAgIHRoaXMub3JpZ2luLnkgPSBvbGRPcmlnaW5ZO1xuXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gR2x5cGhJdGVyYXRvcjsiLCIvLyBtb2R1bGUuZXhwb3J0cy5wb2ludHNUb1BpeGVscyA9IGZ1bmN0aW9uKHBvaW50U2l6ZSwgcmVzb2x1dGlvbikge1xuLy8gXHRyZXNvbHV0aW9uID0gdHlwZW9mIHJlc29sdXRpb24gPT09IFwibnVtYmVyXCIgPyByZXNvbHV0aW9uIDogNzI7XG4vLyBcdHJldHVybiBwb2ludFNpemUgKiByZXNvbHV0aW9uIC8gNzI7XG4vLyB9O1xuXG4vLyBtb2R1bGUuZXhwb3J0cy5jb29yZFRvUGl4ZWwgPSBmdW5jdGlvbihjb29yZCwgcGl4ZWxTaXplLCBlbVNpemUpIHtcbi8vIFx0ZW1TaXplID0gdHlwZW9mIGVtU2l6ZSA9PT0gXCJudW1iZXJcIiA/IGVtU2l6ZSA6IDIwNDg7XG4vLyBcdHJldHVybiBjb29yZCAqIHBpeGVsU2l6ZSAvIGVtU2l6ZTtcbi8vIH07XG5cbi8qKlxuICogQ29udmVydHMgYSBwdCBzaXplIHRvIHB4IHNpemUsIG5hbWVseSB1c2VmdWwgZm9yIG1hdGNoaW5nXG4gKiBzaXplIHdpdGggQ1NTIHN0eWxlcy4gSWYgbm8gRFBJIGlzIHNwZWNpZmllZCwgOTYgaXMgYXNzdW1lZFxuICogKGFzIGl0IGxlYWRzIHRvIGNvcnJlY3QgcmVuZGVyaW5nIGluIGFsbCBicm93c2VycykuXG4gKiBcbiAqIEBwYXJhbSAge051bWJlcn0gZm9udFNpemUgdGhlIGRlc2lyZWQgZm9udCBzaXplIGluIHBvaW50c1xuICogQHBhcmFtICB7TnVtYmVyfSBkcGkgICAgICB0aGUgZXhwZWN0ZWQgRFBJLCBnZW5lcmFsbHkgOTYgZm9yIGJyb3dzZXJzXG4gKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgICAgIHRoZSByb3VuZGVkIHBpeGVsIGZvbnQgc2l6ZVxuICovXG5tb2R1bGUuZXhwb3J0cy5wb2ludFRvUGl4ZWwgPSBmdW5jdGlvbihmb250U2l6ZSwgZHBpKSB7XG4gICAgZHBpID0gZHBpfHxkcGk9PT0wID8gZHBpIDogOTY7XG4gICAgZm9udFNpemUgPSBmb250U2l6ZSAqIGRwaSAvIDcyO1xuICAgIHJldHVybiBNYXRoLnJvdW5kKGZvbnRTaXplKTtcbn07XG5cbi8qKlxuICogRm9yIHRoZSBnaXZlbiBmb250IGFuZCAocGl4ZWwpIGZvbnQgc2l6ZSwgdGhpcyBtZXRob2QgcmV0dXJucyB0aGVcbiAqIHNjYWxlIHRoYXQgd2lsbCBuZWVkIHRvIGJlIGFwcGxpZWQgdG8gRU0gdW5pdHMgKGkuZS4gZm9udCBwYXRocykgXG4gKiB0byBoYXZlIHRoZSBmb250IHJlbmRlciBhdCB0aGUgZXhwZWN0ZWQgc2l6ZSAoaS5lLiB0byBtYXRjaCB0aGUgYnJvd3NlcikuXG4gKlxuICogSWYgbm8gZm9udCBzaXplIGlzIHNwZWNpZmllZCwgd2Ugd2lsbCB1c2UgdGhlIGRlZmF1bHQgZm9udCBzaXplICh3aGljaCBpcyBpbiBwb2ludHMpXG4gKiBhbmQgY29udmVydCBpdCB0byBwaXhlbHMuIFxuICogXG4gKiBAcGFyYW0gIHtGb250fSBmb250ICAgICBhIGZvbnQgb2JqZWN0IGZyb20gdGhlIGZvbnRwYXRoIHRvb2xcbiAqIEBwYXJhbSAge051bWJlcn0gZm9udFNpemUgdGhlIGRlc2lyZWQgZm9udCBzaXplLCBkZWZhdWx0cyB0byB0aGUgZm9udCdzIGRlZmF1bHQgc2l6ZVxuICogQHJldHVybiB7TnVtYmVyfSByZXR1cm5zIHRoZSBzY2FsZSBmb3IgdGhpcyBmb250IHNpemUgICAgICAgICBcbiAqL1xubW9kdWxlLmV4cG9ydHMuZ2V0UHhTY2FsZSA9IGZ1bmN0aW9uKGZvbnQsIGZvbnRTaXplKSB7XG4gICAgaWYgKGZvbnQuYml0bWFwKVxuICAgICAgICByZXR1cm4gMS4wO1xuXG4gICAgLy9JZiBubyBmb250U2l6ZSBpcyBzcGVjaWZpZWQsIGl0IHdpbGwganVzdCBmYWxsIGJhY2sgdG8gdXNpbmcgdGhlIGZvbnQncyBvd24gc2l6ZSB3aXRoIDk2IERQSS5cbiAgICBmb250U2l6ZSA9IHR5cGVvZiBmb250U2l6ZSA9PT0gXCJudW1iZXJcIiA/IGZvbnRTaXplIDogdGhpcy5wb2ludFRvUGl4ZWwoZm9udC5zaXplKTtcblxuICAgIC8vVGFrZXMgaW4gYSBmb250IHNpemUgaW4gUElYRUxTIGFuZCBnaXZlcyB1cyB0aGUgZXhwZWN0ZWQgc2NhbGluZyBmYWN0b3JcbiAgICB2YXIgc3ogPSBmb250LnVuaXRzX3Blcl9FTS82NDtcbiAgICBzeiA9IChzei9mb250LnNpemUgKiBmb250U2l6ZSk7XG5cbiAgICByZXR1cm4gKChmb250LnJlc29sdXRpb24gKiAxLzcyICogc3opIC8gZm9udC51bml0c19wZXJfRU0pO1xufTtcblxuLyoqXG4gKiBGb3IgdGhlIGdpdmVuIGZvbnQgYW5kIChwb2ludCkgZm9udCBzaXplLCB0aGlzIG1ldGhvZCByZXR1cm5zIHRoZVxuICogc2NhbGUgdGhhdCB3aWxsIG5lZWQgdG8gYmUgYXBwbGllZCB0byBFTSB1bml0cyAoaS5lLiBmb250IHBhdGhzKSBcbiAqIHRvIGhhdmUgdGhlIGZvbnQgcmVuZGVyIGF0IHRoZSBleHBlY3RlZCBzaXplIChpLmUuIHRvIG1hdGNoIHRoZSBicm93c2VyKS5cbiAqIFxuICogSWYgbm8gZm9udCBzaXplIGlzIHNwZWNpZmllZCwgd2Ugd2lsbCB1c2UgdGhlIGRlZmF1bHQgZm9udCBzaXplLlxuICogXG4gKiBAcGFyYW0gIHtGb250fSBmb250ICAgICAgIGEgZm9udCBvYmplY3QgZnJvbSB0aGUgZm9udHBhdGggdG9vbFxuICogQHBhcmFtICB7TnVtYmVyfSBmb250U2l6ZSB0aGUgZGVzaXJlZCBmb250IHNpemUsIGRlZmF1bHRzIHRvIHRoZSBmb250J3MgZGVmYXVsdCBzaXplXG4gKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgICAgIHRoZSBzY2FsZSBmb3IgdGhpcyBmb250IHNpemVcbiAqL1xubW9kdWxlLmV4cG9ydHMuZ2V0UHRTY2FsZSA9IGZ1bmN0aW9uKGZvbnQsIGZvbnRTaXplKSB7XG4gICAgZm9udFNpemUgPSB0eXBlb2YgZm9udFNpemUgPT09IFwibnVtYmVyXCIgPyBmb250U2l6ZSA6IGZvbnQuc2l6ZTtcbiAgICBmb250U2l6ZSA9IHRoaXMucG9pbnRUb1BpeGVsKGZvbnRTaXplKTtcbiAgICByZXR1cm4gdGhpcy5nZXRQeFNjYWxlKGZvbnQsIGZvbnRTaXplKTtcbn07XG4iLCJ2YXIgdG1wQm91bmRzID0geyB4OiAwLCB5OiAwLCB3aWR0aDogMCwgaGVpZ2h0OiAwLCBnbHlwaHM6IDAgfTtcblxuZnVuY3Rpb24gaXNXaGl0ZXNwYWNlKGNocikge1xuXHRyZXR1cm4gY2hyPT09JyAnXG5cdFx0fHwgY2hyPT09J1xcbidcblx0XHR8fCBjaHI9PT0nXFxyJ1xuXHRcdHx8IGNocj09PSdcXHQnO1xufVxuXG5mdW5jdGlvbiBpZHhPZih0ZXh0LCBjaHIsIHN0YXJ0LCBlbmQpIHtcblx0dmFyIGlkeCA9IHRleHQuaW5kZXhPZihjaHIsIHN0YXJ0KTtcblx0aWYgKGlkeCA9PT0gLTEgfHwgaWR4ID4gZW5kKVxuXHRcdHJldHVybiBlbmQ7XG5cdHJldHVybiBpZHg7XG59XG5cbmZ1bmN0aW9uIFdvcmRXcmFwKHRleHQpIHtcblx0LyoqXG5cdCAqIFRoZSB0ZXh0IGJlaW5nIG9wZXJhdGVkIG9uLlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdGV4dFxuXHQgKi9cblx0dGhpcy50ZXh0ID0gdGV4dHx8XCJcIjtcblxuXHQvKipcblx0ICogQW4gYXJyYXkgb2YgbGluZXMgcmVwcmVzZW50aW5nIHRoZSBzdGF0ZSBvZiB0aGlzIHdvcmQgd3JhcHBlci5cblx0ICogQHBhcmFtIHtBcnJheX0gbGluZXNcblx0ICovXG5cdHRoaXMubGluZXMgPSBbXTtcblxuXHQvKiogXG5cdCAqIFRoZSBuZXdsaW5lIGNoYXJhY3RlciB0byBicmVhayBvbiwgZGVmYXVsdCAnXFxuJ1xuXHQgKiBAcGFyYW0ge1N0cmluZ30gbmV3bGluZVxuXHQgKi9cblx0dGhpcy5uZXdsaW5lID0gJ1xcbic7XG5cblx0LyoqXG5cdCAqIFdoZXRoZXIgdG8gY2xpcCBub24tYnJlYWtpbmcgdGV4dCAobm93cmFwIGFuZCBwcmUpXG5cdCAqIGlmIHRoZSB3cmFwV2lkdGggaXMgdG9vIHNtYWxsLiBcblx0ICogIFxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGNsaXBcblx0ICovXG5cdHRoaXMuY2xpcCA9IGZhbHNlO1xuXG5cdC8qKlxuXHQgKiBUaGUgbW9kZSBmb3Igd29yZHdyYXBwaW5nOiAncHJlJywgJ25vcm1hbCcsIG9yICdub3dyYXAnLlxuXHQgKlxuXHQgKiBZb3UgY2FuIGFsc28gdXNlIHRoZSBgUFJFYCwgYE5PUk1BTGAsIGFuZCBgTk9XUkFQYCBjb25zdGFudHNcblx0ICogaW4gYFdvcmRXcmFwLk1vZGVgLlxuXHQgKiBcblx0ICogQHBhcmFtIHtTdHJpbmd9IG1vZGVcblx0ICovXG5cdHRoaXMubW9kZSA9IFdvcmRXcmFwLk1vZGUuTk9STUFMO1xufVxuXG5Xb3JkV3JhcC5Nb2RlID0ge1xuXHRQUkU6ICdwcmUnLCAgICAgICAvL3doaXRlc3BhY2UgaXNuJ3QgY29sbGFwc2VkXG5cdE5PUk1BTDogJ25vcm1hbCcsIC8vd2hpdGVzcGFjZSBpcyBjb2xsYXBzZWRcblx0Tk9XUkFQOiAnbm93cmFwJyAgLy9vbmx5IGJyZWFrIG9uICdcXG4nXG59O1xuXG4vKipcbiAqIENsZWFycyBhbnkgbXVsdGktbGluZSBsYXlvdXQgYnkgcGxhY2luZyBhbGwgdGhlIHRleHQgaW4gYSBzaW5nbGUgTGluZSBvYmplY3QuXG4gKiBcbiAqIEBwYXJhbSB7R2x5cGhJdGVyYXRvcn0gaXRlcmF0b3IgdGhlIGl0ZXJhdG9yIHRvIHVzZSBcbiAqIEBtZXRob2QgIGNsZWFyTGF5b3V0XG4gKi9cbldvcmRXcmFwLnByb3RvdHlwZS5jbGVhckxheW91dCA9IGZ1bmN0aW9uKGl0ZXJhdG9yKSB7XG5cdHRoaXMubGluZXMubGVuZ3RoID0gMDtcblx0XG5cdGlmICh0aGlzLnRleHQubGVuZ3RoID4gMCkge1xuXHRcdGl0ZXJhdG9yLmdldEJvdW5kcyh0aGlzLnRleHQsIDAsIHRoaXMudGV4dC5sZW5ndGgsIHVuZGVmaW5lZCwgdG1wQm91bmRzKTtcblx0XHRcblx0XHR2YXIgbGluZSA9IG5ldyBXb3JkV3JhcC5MaW5lKDAsIHRoaXMudGV4dC5sZW5ndGgsIHRtcEJvdW5kcy53aWR0aCk7XG5cdFx0dGhpcy5saW5lcy5wdXNoKGxpbmUpO1xuXHR9XG59O1xuXG4vKipcbiAqIFJlc2V0cyB0aGUgd29yZCB3cmFwcGVyIGJ5IGVtcHR5aW5nIGFsbCBjdXJyZW50IGxpbmVzLlxuICogQG1ldGhvZCAgZW1wdHlcbiAqL1xuV29yZFdyYXAucHJvdG90eXBlLmVtcHR5ID0gZnVuY3Rpb24oKSB7XG5cdHRoaXMubGluZXMubGVuZ3RoID0gMDtcbn07XG5cbi8qKlxuICogV29yZC13cmFwcyB0aGUgZ2l2ZW4gdGV4dCBpbnRvIG11bHRpcGxlIGxpbmVzLlxuICogQHBhcmFtICB7W3R5cGVdfSBpdGVyYXRvciBbZGVzY3JpcHRpb25dXG4gKiBAcGFyYW0gIHtbdHlwZV19IHdpZHRoICAgIFtkZXNjcmlwdGlvbl1cbiAqIEBwYXJhbSAge1t0eXBlXX0gc3RhcnQgICAgW2Rlc2NyaXB0aW9uXVxuICogQHBhcmFtICB7W3R5cGVdfSBlbmQgICAgICBbZGVzY3JpcHRpb25dXG4gKiBAcmV0dXJuIHtbdHlwZV19ICAgICAgICAgIFtkZXNjcmlwdGlvbl1cbiAqL1xuV29yZFdyYXAucHJvdG90eXBlLmxheW91dCA9IGZ1bmN0aW9uKGl0ZXJhdG9yLCB3cmFwV2lkdGgsIHN0YXJ0LCBlbmQpIHtcblx0dmFyIHRleHQgPSB0aGlzLnRleHQ7XG5cblx0dmFyIGxpbmVzID0gdGhpcy5saW5lcztcblxuXHRzdGFydCA9IE1hdGgubWF4KDAsIHN0YXJ0fHwwKTtcblx0ZW5kID0gKGVuZD09PTB8fGVuZCkgPyBlbmQgOiB0ZXh0Lmxlbmd0aDtcblxuXHRpdGVyYXRvci5iZWdpbigpO1xuXG5cdC8vZGVmYXVsdCB3cmFwIHdpZHRoLi4uXG5cdHdyYXBXaWR0aCA9ICh3cmFwV2lkdGg9PT0wIHx8IHdyYXBXaWR0aCkgPyB3cmFwV2lkdGggOiBOdW1iZXIuTUFYX1ZBTFVFO1xuXG5cdC8vPHByZT4gbW9kZSBqdXN0IHVzZXMgYSBzaW1wbGUgYWxnb3JpdGhtLi4uXG5cdGlmICh0aGlzLm1vZGUgPT09IFdvcmRXcmFwLk1vZGUuUFJFKSB7XG5cdFx0dmFyIGxpbmVTdGFydCA9IHN0YXJ0O1xuXHRcdGZvciAodmFyIGk9c3RhcnQ7IGk8ZW5kOyBpKyspIHtcblx0XHRcdHZhciBjaHIgPSB0ZXh0LmNoYXJBdChpKTtcblxuXHRcdFx0Ly9JZiB3ZSd2ZSByZWFjaGVkIGEgbmV3bGluZSwgdGhlbiBzdGVwIGRvd24gYSBsaW5lXG5cdFx0XHQvL09yIGlmIHdlJ3ZlIHJlYWNoZWQgdGhlIEVPRlxuXHRcdFx0aWYgKCBjaHIgPT09IHRoaXMubmV3bGluZSB8fCBpPT09ZW5kLTEpIHtcblx0XHRcdFx0dmFyIGF2YWlsYWJsZVdpZHRoID0gdGhpcy5jbGlwID8gd3JhcFdpZHRoIDogdW5kZWZpbmVkO1xuXHRcdFx0XHRpdGVyYXRvci5nZXRCb3VuZHModGV4dCwgbGluZVN0YXJ0LCBpKzEsIGF2YWlsYWJsZVdpZHRoLCB0bXBCb3VuZHMpO1xuXHRcdFx0XHRsaW5lcy5wdXNoKCBuZXcgV29yZFdyYXAuTGluZShsaW5lU3RhcnQsIGxpbmVTdGFydCt0bXBCb3VuZHMuZ2x5cGhzLCB0bXBCb3VuZHMud2lkdGgpICk7XG5cdFx0XHRcdGxpbmVTdGFydCA9IGkrMTtcblx0XHRcdH1cblx0XHR9XG5cdH0gXG5cdC8vJ25vcm1hbCcgbW9kZSB1c2VzIExpYkdEWCdzIHdvcmQgd3JhcHBpbmcgYWxnb3JpdGhtOlxuXHQvL2h0dHBzOi8vZ2l0aHViLmNvbS9saWJnZHgvbGliZ2R4L2Jsb2IvbWFzdGVyL2dkeC9zcmMvY29tL2JhZGxvZ2ljL2dkeC9ncmFwaGljcy9nMmQvQml0bWFwRm9udENhY2hlLmphdmFcblx0ZWxzZSB7XG5cdFx0Ly9pZiAnbm93cmFwJyBpcyBzcGVjaWZpZWQsIHdlIG9ubHkgd3JhcCBvbiBuZXdsaW5lIGNoYXJzXG5cdFx0XG5cdFx0dmFyIHRlc3RXaWR0aCA9IHdyYXBXaWR0aDtcblx0XHRpZiAodGhpcy5tb2RlID09PSBXb3JkV3JhcC5Nb2RlLk5PV1JBUCkge1xuXHRcdFx0dGVzdFdpZHRoID0gTnVtYmVyLk1BWF9WQUxVRTtcblx0XHR9XG5cblx0XHR3aGlsZSAoc3RhcnQgPCBlbmQpIHtcblx0XHRcdC8vZ2V0IG5leHQgbmV3bGluZSBwb3NpdGlvblxuXHRcdFx0dmFyIG5ld0xpbmUgPSBpZHhPZih0ZXh0LCB0aGlzLm5ld2xpbmUsIHN0YXJ0LCBlbmQpO1xuXG5cdFx0XHQvL2VhdCB3aGl0ZXNwYWNlIGF0IHN0YXJ0IG9mIGxpbmVcblx0XHRcdHdoaWxlIChzdGFydCA8IG5ld0xpbmUpIHtcblx0XHRcdFx0aWYgKCFpc1doaXRlc3BhY2UoIHRleHQuY2hhckF0KHN0YXJ0KSApKVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRzdGFydCsrO1xuXHRcdFx0fVxuXG5cdFx0XHQvL2RldGVybWluZSB2aXNpYmxlICMgb2YgZ2x5cGhzIGZvciB0aGUgYXZhaWxhYmxlIHdpZHRoXG5cdFx0XHRpdGVyYXRvci5nZXRCb3VuZHModGV4dCwgc3RhcnQsIG5ld0xpbmUsIHRlc3RXaWR0aCwgdG1wQm91bmRzKVxuXG5cdFx0XHR2YXIgbGluZUVuZCA9IHN0YXJ0ICsgdG1wQm91bmRzLmdseXBocztcblx0XHRcdHZhciBuZXh0U3RhcnQgPSBsaW5lRW5kICsgdGhpcy5uZXdsaW5lLmxlbmd0aDtcblxuXHRcdFx0Ly9pZiB3ZSBoYWQgdG8gY3V0IHRoZSBsaW5lIGJlZm9yZSB0aGUgbmV4dCBuZXdsaW5lLi4uXG5cdFx0XHRpZiAobGluZUVuZCA8IG5ld0xpbmUpIHtcblx0XHRcdFx0Ly9maW5kIGNoYXIgdG8gYnJlYWsgb25cblx0XHRcdFx0d2hpbGUgKGxpbmVFbmQgPiBzdGFydCkge1xuXHRcdFx0XHRcdGlmIChpc1doaXRlc3BhY2UodGV4dC5jaGFyQXQobGluZUVuZCkpKVxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0bGluZUVuZC0tO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChsaW5lRW5kID09PSBzdGFydCkge1xuXHRcdFx0XHRcdGlmIChuZXh0U3RhcnQgPiBzdGFydCArIHRoaXMubmV3bGluZS5sZW5ndGgpIG5leHRTdGFydC0tO1xuXHRcdFx0XHRcdGxpbmVFbmQgPSBuZXh0U3RhcnQ7IC8vIElmIG5vIGNoYXJhY3RlcnMgdG8gYnJlYWssIHNob3cgYWxsLlxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdG5leHRTdGFydCA9IGxpbmVFbmQ7XG5cdFx0XHRcdFx0Ly9lYXQgd2hpdGVzcGFjZSBhdCBlbmQgb2YgbGluZVxuXHRcdFx0XHRcdHdoaWxlIChsaW5lRW5kID4gc3RhcnQpIHtcblx0XHRcdFx0XHRcdGlmICghaXNXaGl0ZXNwYWNlKHRleHQuY2hhckF0KGxpbmVFbmQgLSB0aGlzLm5ld2xpbmUubGVuZ3RoKSkpXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0bGluZUVuZC0tO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAobGluZUVuZCA+IHN0YXJ0KSB7XG5cdFx0XHRcdC8vdG8gY2xpcCwgdXNlIHRoZSBvcmlnaW5hbCB3cmFwIHdpZHRoICh1bmFsdGVyZWQgYnkgbW9kZSlcblx0XHRcdFx0dmFyIGF2YWlsYWJsZVdpZHRoID0gdGhpcy5jbGlwID8gd3JhcFdpZHRoIDogdW5kZWZpbmVkO1xuXHRcdFx0XHRpdGVyYXRvci5nZXRCb3VuZHModGV4dCwgc3RhcnQsIGxpbmVFbmQsIGF2YWlsYWJsZVdpZHRoLCB0bXBCb3VuZHMpO1xuXHRcdFx0XHR2YXIgbGluZVdpZHRoID0gdG1wQm91bmRzLndpZHRoO1xuXG5cdFx0XHRcdHZhciByTGluZUVuZCA9IHRoaXMuY2xpcCA/IHN0YXJ0K3RtcEJvdW5kcy5nbHlwaHMgOiBsaW5lRW5kO1xuXHRcdFx0XHRsaW5lcy5wdXNoKCBuZXcgV29yZFdyYXAuTGluZShzdGFydCwgckxpbmVFbmQsIGxpbmVXaWR0aCkgKTtcblx0XHRcdH1cblx0XHRcdHN0YXJ0ID0gbmV4dFN0YXJ0O1xuXG5cdFx0fVxuXHR9XG5cblx0aXRlcmF0b3IuZW5kKCk7XG59O1xuXG4vKipcbiAqIEEgY29udmVuaWVuY2UgbWV0aG9kIHRvIHJldHVybiB0aGUgbWF4aW11bSB3aWR0aCBvZiBhbGwgY3VycmVudCBsaW5lcy5cbiAqIFRoaXMgaXMgdXNlZnVsIGZvciBhbGlnbmluZyBibG9ja3Mgb2YgdGV4dC5cbiAqXG4gKiBAbWV0aG9kICBnZXRNYXhMaW5lV2lkdGhcbiAqIEByZXR1cm4ge051bWJlcn0gdGhlIG1heGltdW0gd2lkdGggb2YgYWxsIGxpbmVzXG4gKi9cbldvcmRXcmFwLnByb3RvdHlwZS5nZXRNYXhMaW5lV2lkdGggPSBmdW5jdGlvbigpIHtcblx0dmFyIG1heFdpZHRoID0gMDtcblx0Zm9yICh2YXIgaT0wOyBpPHRoaXMubGluZXMubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgbGluZSA9IHRoaXMubGluZXNbaV07XG5cdFx0bWF4V2lkdGggPSBNYXRoLm1heChsaW5lLndpZHRoLCBtYXhXaWR0aCk7XG5cdH1cblx0cmV0dXJuIG1heFdpZHRoO1xufTtcblxuLyoqXG4gKiBUaGUgTGluZSBvYmplY3QgaG9sZHMgdGhlIHN0YXJ0IGFuZCBlbmQgaW5kaWNlcyBpbnRvIHRoZSBzdHJpbmcsXG4gKiBhbmQgdGhlIHdpZHRoIGFzIGNvbXB1dGVkIGJ5IEdseXBoSXRlcmF0b3IuXG4gKiBcbiAqIEBjbGFzcyAgV29yZFdyYXAuTGluZVxuICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0IHRoZSBzdGFydCBpbmRleCwgaW5jbHVzaXZlXG4gKiBAcGFyYW0ge051bWJlcn0gZW5kICAgdGhlIGVuZCBpbmRleCwgZXhjbHVzaXZlXG4gKiBAcGFyYW0ge051bWJlcn0gd2lkdGggdGhlIGNvbXB1dGVkIHdpZHRoIG9mIHRoaXMgbGluZVxuICovXG5Xb3JkV3JhcC5MaW5lID0gZnVuY3Rpb24oc3RhcnQsIGVuZCwgd2lkdGgpIHtcblx0dGhpcy5zdGFydCA9IHN0YXJ0O1xuXHR0aGlzLmVuZCA9IGVuZDtcblx0dGhpcy53aWR0aCA9IHdpZHRoO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBXb3JkV3JhcDsiLCJ2YXIgY3JlYXRlVkFPID0gcmVxdWlyZSgnZ2wtYWxpYXNlZC12YW8nKSAvL1RPRE86IGltcHJvdmUgdGhpcyB3aXRoIGdsLXZhb1xudmFyIGNyZWF0ZUJ1ZmZlciA9IHJlcXVpcmUoJ2dsLWJ1ZmZlcicpXG5cbm1vZHVsZS5leHBvcnRzLmZsb2F0c1BlclZlcnRleCA9IDVcblxuZnVuY3Rpb24gY3JlYXRlSW5kaWNlcyhjYXBhY2l0eSkge1xuICAgIHZhciBudW1JbmRpY2VzID0gY2FwYWNpdHkgKiA2XG4gICAgdmFyIGluZGljZXMgPSBuZXcgVWludDE2QXJyYXkobnVtSW5kaWNlcylcblxuICAgIGZvciAodmFyIGkgPSAwLCBqID0gMDsgaSA8IG51bUluZGljZXM7IGkgKz0gNiwgaiArPSA0KSB7XG4gICAgICAgIGluZGljZXNbaSArIDBdID0gaiArIDBcbiAgICAgICAgaW5kaWNlc1tpICsgMV0gPSBqICsgMVxuICAgICAgICBpbmRpY2VzW2kgKyAyXSA9IGogKyAyXG4gICAgICAgIGluZGljZXNbaSArIDNdID0gaiArIDBcbiAgICAgICAgaW5kaWNlc1tpICsgNF0gPSBqICsgMlxuICAgICAgICBpbmRpY2VzW2kgKyA1XSA9IGogKyAzXG4gICAgfVxuICAgIHJldHVybiBpbmRpY2VzXG59XG5cbm1vZHVsZS5leHBvcnRzLm1peGlucyA9IHtcblxuICAgIGNyZWF0ZTogZnVuY3Rpb24gY3JlYXRlKG9wdCkge1xuICAgICAgICBvcHQgPSBvcHR8fHt9XG4gICAgICAgIHRoaXMuY2xlYXIoKVxuXG4gICAgICAgIC8vZGlzcG9zZSBiZWZvcmUgYnVpbGRpbmcuLi5cbiAgICAgICAgaWYgKHRoaXMudmFvKVxuICAgICAgICAgICAgdGhpcy5kaXNwb3NlKClcblxuICAgICAgICB2YXIgY2FwYWNpdHkgPSB0eXBlb2Ygb3B0LmNhcGFjaXR5ID09PSAnbnVtYmVyJyA/IG9wdC5jYXBhY2l0eSA6IDEwMFxuXG4gICAgICAgIC8vIDY1NTM1IGlzIG1heCBpbmRleCwgc28gNjU1MzUgLyA2ID0gMTA5MjIuXG4gICAgICAgIGlmIChjYXBhY2l0eSA+IDEwOTIyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgaGF2ZSBtb3JlIHRoYW4gMTA5MjIgcXVhZHMgcGVyIGJhdGNoOiBcIiArIGNhcGFjaXR5KVxuXG4gICAgICAgIHRoaXMuX2NhcGFjaXR5ID0gY2FwYWNpdHlcblxuICAgICAgICAvL3RoZSB0b3RhbCBudW1iZXIgb2YgZmxvYXRzIGluIG91ciBiYXRjaFxuICAgICAgICB2YXIgbnVtVmVydHMgPSBjYXBhY2l0eSAqIDQgKiBtb2R1bGUuZXhwb3J0cy5mbG9hdHNQZXJWZXJ0ZXhcblxuICAgICAgICB0aGlzLnZlcnRpY2VzID0gbmV3IEZsb2F0MzJBcnJheShudW1WZXJ0cylcbiAgICAgICAgdGhpcy5pbmRpY2VzID0gY3JlYXRlSW5kaWNlcyhjYXBhY2l0eSlcblxuICAgICAgICB2YXIgZ2wgPSB0aGlzLmdsXG4gICAgICAgIHZhciB1c2FnZSA9IG9wdC5keW5hbWljID8gZ2wuRFlOQU1JQ19EUkFXIDogZ2wuU1RBVElDX0RSQVdcbiAgICAgICAgdGhpcy52ZXJ0ZXhCdWZmZXIgPSBjcmVhdGVCdWZmZXIoZ2wsIHRoaXMudmVydGljZXMsIGdsLkFSUkFZX0JVRkZFUiwgdXNhZ2UpXG4gICAgICAgIHRoaXMuaW5kZXhCdWZmZXIgPSBjcmVhdGVCdWZmZXIoZ2wsIHRoaXMuaW5kaWNlcywgZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGdsLlNUQVRJQ19EUkFXKVxuXG4gICAgICAgIHZhciBzdHJpZGUgPSA1ICogNFxuICAgICAgICB0aGlzLnZhbyA9IGNyZWF0ZVZBTyhnbCwgW3sgLy9wb3NpdGlvbiBYWVxuICAgICAgICAgICAgbmFtZTogJ3Bvc2l0aW9uJyxcbiAgICAgICAgICAgIGJ1ZmZlcjogdGhpcy52ZXJ0ZXhCdWZmZXIsXG4gICAgICAgICAgICBzaXplOiAyLFxuICAgICAgICAgICAgc3RyaWRlOiBzdHJpZGVcbiAgICAgICAgfSwgeyAvL3RleGNvb3JkIFVWXG4gICAgICAgICAgICBuYW1lOiAndGV4Y29vcmQwJyxcbiAgICAgICAgICAgIGJ1ZmZlcjogdGhpcy52ZXJ0ZXhCdWZmZXIsXG4gICAgICAgICAgICBzaXplOiAyLFxuICAgICAgICAgICAgb2Zmc2V0OiAyICogNCxcbiAgICAgICAgICAgIHN0cmlkZTogc3RyaWRlXG4gICAgICAgIH0sIHsgLy9jb2xvciAocGFja2VkKSBDXG4gICAgICAgICAgICBuYW1lOiAnY29sb3InLFxuICAgICAgICAgICAgYnVmZmVyOiB0aGlzLnZlcnRleEJ1ZmZlcixcbiAgICAgICAgICAgIHNpemU6IDQsXG4gICAgICAgICAgICBzdHJpZGU6IHN0cmlkZSxcbiAgICAgICAgICAgIG9mZnNldDogNCAqIDQsXG4gICAgICAgICAgICB0eXBlOiBnbC5VTlNJR05FRF9CWVRFLFxuICAgICAgICAgICAgbm9ybWFsaXplZDogdHJ1ZVxuICAgICAgICB9XSwgdGhpcy5pbmRleEJ1ZmZlcilcbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICB9LFxuXG4gICAgZW5zdXJlQ2FwYWNpdHk6IGZ1bmN0aW9uKGNhcGFjaXR5KSB7XG4gICAgICAgIGlmICh0aGlzLmNhcGFjaXR5IDwgY2FwYWNpdHkpXG4gICAgICAgICAgICB0aGlzLmNyZWF0ZSh7IGNhcGFjaXR5OiBjYXBhY2l0eSB9KVxuICAgICAgICByZXR1cm4gdGhpc1xuICAgIH1cbn0iLCJ2YXIgY29sb3JUb0Zsb2F0ID0gcmVxdWlyZSgnLi9wYWNrLXJnYmEtZmxvYXQnKVxudmFyIG1peGVzID0gcmVxdWlyZSgnbWl4ZXMnKVxudmFyIHByZW11bHQgPSByZXF1aXJlKCdwcmVtdWx0aXBsaWVkLXJnYmEnKVxudmFyIFdoaXRlVGV4ID0gcmVxdWlyZSgnZ2wtd2hpdGUtdGV4dHVyZScpXG5cbnZhciB2ZXJ0TnVtRmxvYXRzID0gcmVxdWlyZSgnLi9jb21tb24nKS5mbG9hdHNQZXJWZXJ0ZXhcblxuLy9UZW1wb3JhcnkgYXJyYXlzIHRvIGF2b2lkIEdDIHRocmFzaGluZ1xudmFyIHBvc2l0aW9uID0gWzAsIDBdLFxuICAgIHNoYXBlID0gWzAsIDBdLFxuICAgIHRleGNvb3JkID0gWzAsIDAsIDAsIDBdLFxuICAgIGNvbG9yID0gWzAsIDAsIDAsIDBdXG5cbnZhciB0bXA0ID0gWzAsIDAsIDAsIDBdLFxuICAgIHJvdE9yaWdpbiA9IFswLCAwXSxcbiAgICB0bXAyID0gWzAsIDBdXG5cbmZ1bmN0aW9uIFNwcml0ZUJhdGNoKGdsLCBvcHQpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU3ByaXRlQmF0Y2gpKVxuICAgICAgICByZXR1cm4gbmV3IFNwcml0ZUJhdGNoKGdsLCBvcHQpXG4gICAgaWYgKCFnbClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibXVzdCBzcGVjaWZ5IGdsIGNvbnRleHRcIilcbiAgICB0aGlzLmdsID0gZ2xcbiAgICBvcHQgPSBvcHQgfHwge31cbiAgICBcbiAgICB0aGlzLl9ib3VuZCA9IGZhbHNlXG4gICAgdGhpcy5pZHggPSAwXG5cbiAgICAvL25vIHRyYW5zZm9ybSBtZWFucyBpZGVudGl0eVxuICAgIHRoaXMudHJhbnNmb3JtID0gbnVsbFxuXG4gICAgLy93aGl0ZSB0ZXh0dXJlIGlzIGFraW4gdG8gXCJubyB0ZXh0dXJlXCIgKHdpdGhvdXQgc3dpdGNoaW5nIHNoYWRlcnMpXG4gICAgdGhpcy5fZGVmYXVsdFRleHR1cmUgPSBvcHQuZGVmYXVsdFRleHR1cmUgfHwgV2hpdGVUZXgoZ2wpXG4gICAgdGhpcy5fb3duc0RlZmF1bHQgPSAhb3B0LmRlZmF1bHRUZXh0dXJlXG4gICAgdGhpcy5fbGFzdFRleHR1cmUgPSB0aGlzLl9kZWZhdWx0VGV4dHVyZVxuICAgIHRoaXMuX3RleHR1cmUgPSB0aGlzLl9kZWZhdWx0VGV4dHVyZVxuICAgIHRoaXMudGV4dHVyZSA9IG51bGxcblxuICAgIHRoaXMubW9kZSA9IHR5cGVvZiBvcHQubW9kZSA9PT0gJ251bWJlcicgPyBvcHQubW9kZSA6IGdsLlRSSUFOR0xFU1xuICAgIHRoaXMucHJlbXVsdGlwbGllZCA9IG9wdC5wcmVtdWx0aXBsaWVkIHx8IGZhbHNlXG5cbiAgICB0aGlzLl9kaXJ0eSA9IHRydWVcbiAgICB0aGlzLmNyZWF0ZShvcHQpXG5cbiAgICAvL3NldCBkZWZhdWx0IGF0dHJpYnV0ZXNcbiAgICB0aGlzLmRlZmF1bHRzKClcbn1cblxuLy9taXggaW4gY3JlYXRlKCkgYW5kIGVuc3VyZUNhcGFjaXR5KCkgZnVuY3Rpb25zXG5taXhlcyhTcHJpdGVCYXRjaCwgcmVxdWlyZSgnLi9jb21tb24nKS5taXhpbnMpXG5cbm1peGVzKFNwcml0ZUJhdGNoLCB7XG5cbiAgICBjYXBhY2l0eToge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NhcGFjaXR5XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgdGV4dHVyZToge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RleHR1cmVcbiAgICAgICAgfSxcblxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHRleCkge1xuICAgICAgICAgICAgdGhpcy5fdGV4dHVyZSA9IHRleCB8fCB0aGlzLl9kZWZhdWx0VGV4dHVyZVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIGRpc3Bvc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy52ZXJ0ZXhCdWZmZXIpXG4gICAgICAgICAgICB0aGlzLnZlcnRleEJ1ZmZlci5kaXNwb3NlKClcbiAgICAgICAgaWYgKHRoaXMuaW5kZXhCdWZmZXIpXG4gICAgICAgICAgICB0aGlzLmluZGV4QnVmZmVyLmRpc3Bvc2UoKVxuICAgICAgICBpZiAodGhpcy52YW8pXG4gICAgICAgICAgICB0aGlzLnZhby5kaXNwb3NlKClcbiAgICAgICAgaWYgKHRoaXMuX293bnNEZWZhdWx0KVxuICAgICAgICAgICAgdGhpcy5fZGVmYXVsdFRleHR1cmUuZGlzcG9zZSgpXG4gICAgfSxcblxuICAgIGNsZWFyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5pZHggPSAwXG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgfSxcblxuICAgIGJpbmQ6IGZ1bmN0aW9uKHNoYWRlcikge1xuICAgICAgICBzaGFkZXIuYmluZCgpXG4gICAgICAgIHRoaXMudmFvLmJpbmQoc2hhZGVyKVxuICAgICAgICB0aGlzLl9ib3VuZCA9IHRydWVcbiAgICB9LFxuXG4gICAgdW5iaW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy52YW8udW5iaW5kKClcbiAgICAgICAgdGhpcy5fYm91bmQgPSBmYWxzZVxuICAgIH0sXG5cbiAgICBkZWZhdWx0czogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMucG9zaXRpb24gPSBjb3B5Mihwb3NpdGlvbiwgMCwgMClcbiAgICAgICAgdGhpcy50ZXhjb29yZCA9IGNvcHk0KHRleGNvb3JkLCAwLCAwLCAxLCAxKVxuICAgICAgICB0aGlzLmNvbG9yID0gY29weTQoY29sb3IsIDEsIDEsIDEsIDEpXG4gICAgICAgIHRoaXMuc2hhcGUgPSBjb3B5MihzaGFwZSwgMCwgMClcbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICB9LFxuXG4gICAgcHVzaDogZnVuY3Rpb24oc3ByaXRlKSB7XG4gICAgICAgIC8vaWYgd2UgYXJlIGRlZmluaW5nIGF0dHJpYnV0ZXMgb24gdGhlIGZseVxuICAgICAgICBpZiAoc3ByaXRlKSB7XG4gICAgICAgICAgICB0aGlzLnRleHR1cmUgPSBzcHJpdGUudGV4dHVyZVxuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbiA9IHNwcml0ZS5wb3NpdGlvbiB8fCBjb3B5Mihwb3NpdGlvbiwgMCwgMClcbiAgICAgICAgICAgIHRoaXMudGV4Y29vcmQgPSBzcHJpdGUudGV4Y29vcmQgfHwgY29weTQodGV4Y29vcmQsIDAsIDAsIDEsIDEpXG4gICAgICAgICAgICB0aGlzLmNvbG9yID0gc3ByaXRlLmNvbG9yIHx8IGNvcHk0KGNvbG9yLCAxLCAxLCAxLCAxKVxuICAgICAgICAgICAgdGhpcy5zaGFwZSA9IHNwcml0ZS5zaGFwZSB8fCBjb3B5MihzaGFwZSwgMCwgMClcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnRleHR1cmUgIT09IHRoaXMuX2xhc3RUZXh0dXJlKSB7XG4gICAgICAgICAgICAvL25ldyB0ZXh0dXJlLCBmbHVzaCBwcmV2aW91cyBkYXRhXG4gICAgICAgICAgICBpZiAodGhpcy5fYm91bmQpXG4gICAgICAgICAgICAgICAgdGhpcy5mbHVzaCgpXG4gICAgICAgICAgICB0aGlzLl9sYXN0VGV4dHVyZSA9IHRoaXMudGV4dHVyZVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaWR4ID09PSB0aGlzLnZlcnRpY2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgLy9pZiB3ZSBBUkVOJ1QgYm91bmQsIHdlIG5lZWQgdG8gc3RvcCBwdXNoaW5nIHZlcnRleCBkYXRhIVxuICAgICAgICAgICAgaWYgKCF0aGlzLl9ib3VuZClcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1xuXG4gICAgICAgICAgICAvL2lmIHdlIEFSRSBib3VuZCwgd2UgY2FuIGZsdXNoIHRoZSBiYXRjaCBhbmQgY29udGludWUgZHJhd2luZ1xuICAgICAgICAgICAgdGhpcy5mbHVzaCgpXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9kaXJ0eSA9IHRydWVcblxuICAgICAgICAvL2dldCBSR0JBIGNvbXBvbmVudHMgYW5kIHBhY2sgaW50byBhIHNpbmdsZSBmbG9hdFxuICAgICAgICB2YXIgY29sb3JSR0JBID0gdGhpcy5wcmVtdWx0aXBsaWVkID8gcHJlbXVsdCh0aGlzLmNvbG9yLCB0bXA0KSA6IHRoaXMuY29sb3JcbiAgICAgICAgdmFyIGMgPSBjb2xvclRvRmxvYXQoY29sb3JSR0JBKVxuXG4gICAgICAgIHZhciB1MSA9IHRoaXMudGV4Y29vcmRbMF0sXG4gICAgICAgICAgICB2MSA9IHRoaXMudGV4Y29vcmRbMV0sXG4gICAgICAgICAgICB1MiA9IHRoaXMudGV4Y29vcmRbMl0sXG4gICAgICAgICAgICB2MiA9IHRoaXMudGV4Y29vcmRbM11cblxuICAgICAgICB2YXIgeCA9IHRoaXMucG9zaXRpb25bMF0sXG4gICAgICAgICAgICB5ID0gdGhpcy5wb3NpdGlvblsxXSxcbiAgICAgICAgICAgIHdpZHRoID0gdGhpcy5zaGFwZVswXSxcbiAgICAgICAgICAgIGhlaWdodCA9IHRoaXMuc2hhcGVbMV1cblxuICAgICAgICB0aGlzLl92ZXJ0KHgsIHksIHUxLCB2MSwgYylcbiAgICAgICAgdGhpcy5fdmVydCh4K3dpZHRoLCB5LCB1MiwgdjEsIGMpXG4gICAgICAgIHRoaXMuX3ZlcnQoeCt3aWR0aCwgeStoZWlnaHQsIHUyLCB2MiwgYylcbiAgICAgICAgdGhpcy5fdmVydCh4LCB5K2hlaWdodCwgdTEsIHYyLCBjKVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICB9LFxuXG4gICAgX3ZlcnQ6IGZ1bmN0aW9uKHgxLCB5MSwgdTEsIHYxLCBjKSB7XG4gICAgICAgIHZhciBpZHggPSB0aGlzLmlkeCxcbiAgICAgICAgICAgIHZlcnRzID0gdGhpcy52ZXJ0aWNlcyxcbiAgICAgICAgICAgIHRyYW5zZm9ybSA9IHRoaXMudHJhbnNmb3JtXG5cbiAgICAgICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgICAgICAgdmFyIHggPSB4MSwgeSA9IHkxXG4gICAgICAgICAgICB4MSA9IHRyYW5zZm9ybVswXSAqIHggKyB0cmFuc2Zvcm1bNF0gKiB5ICsgdHJhbnNmb3JtWzEyXVxuICAgICAgICAgICAgeTEgPSB0cmFuc2Zvcm1bMV0gKiB4ICsgdHJhbnNmb3JtWzVdICogeSArIHRyYW5zZm9ybVsxM11cbiAgICAgICAgfVxuXG4gICAgICAgIC8veHlcbiAgICAgICAgdmVydHNbaWR4KytdID0geDFcbiAgICAgICAgdmVydHNbaWR4KytdID0geTFcbiAgICAgICAgLy91dlxuICAgICAgICB2ZXJ0c1tpZHgrK10gPSB1MVxuICAgICAgICB2ZXJ0c1tpZHgrK10gPSB2MVxuICAgICAgICAvL2NvbG9yXG4gICAgICAgIHZlcnRzW2lkeCsrXSA9IGNcbiAgICAgICAgdGhpcy5pZHggPSBpZHhcbiAgICB9LFxuXG4gICAgZmx1c2g6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmRyYXcoKVxuICAgICAgICByZXR1cm4gdGhpcy5jbGVhcigpXG4gICAgfSxcblxuICAgIGRyYXc6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvL0lmIHdlJ3ZlIHJlYWNoZWQgYSBuZXcgdGV4dHVyZSBvciBjYXBhY2l0eVxuICAgICAgICAvL3doaWxlIG5vdCBib3VuZCwgdGhlbiB3ZSB3aWxsIGp1c3QgY2xlYXIgdGhlIGJhdGNoXG4gICAgICAgIC8vdG8gemVybyBhbmQgZHJhdyBub3RoaW5nXG4gICAgICAgIGlmICh0aGlzLmlkeCA9PT0gMCB8fCAhdGhpcy5fYm91bmQpXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xuXG4gICAgICAgIHZhciBnbCA9IHRoaXMuZ2xcbiAgICAgICAgXG4gICAgICAgIGlmICh0aGlzLl9kaXJ0eSkge1xuICAgICAgICAgICAgdmFyIHZpZXcgPSB0aGlzLnZlcnRpY2VzLnN1YmFycmF5KDAsIHRoaXMuaWR4KVxuICAgICAgICAgICAgdGhpcy52ZXJ0ZXhCdWZmZXIudXBkYXRlKHZpZXcsIDApXG4gICAgICAgICAgICB0aGlzLl9kaXJ0eSA9IGZhbHNlXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fbGFzdFRleHR1cmUpXG4gICAgICAgICAgICB0aGlzLl9sYXN0VGV4dHVyZS5iaW5kKClcbiAgICAgICAgdGhpcy5fbGFzdFRleHR1cmUgPSB0aGlzLnRleHR1cmVcblxuICAgICAgICB2YXIgc3ByaXRlcyA9ICh0aGlzLmlkeCAvICh2ZXJ0TnVtRmxvYXRzICogNCkpXG4gICAgICAgIGlmIChzcHJpdGVzID4gMClcbiAgICAgICAgICAgIHRoaXMudmFvLmRyYXcodGhpcy5tb2RlLCBzcHJpdGVzICogNiwgMClcbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICB9LFxufSlcblxubW9kdWxlLmV4cG9ydHMgPSBTcHJpdGVCYXRjaFxuXG4vL1RPRE86IHdpbGwgdXNlIG1vZHVsYXIgZ2wtbWF0cml4IGZvciB0aGVzZS4uLlxuZnVuY3Rpb24gY29weTIob3V0LCB4LCB5KSB7XG4gICAgb3V0WzBdID0geFxuICAgIG91dFsxXSA9IHlcbiAgICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIGNvcHk0KG91dCwgeCwgeSwgeiwgdykge1xuICAgIG91dFswXSA9IHhcbiAgICBvdXRbMV0gPSB5XG4gICAgb3V0WzJdID0gelxuICAgIG91dFszXSA9IHdcbiAgICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIGNvcHlWZWMyKG91dCwgdmVjKSB7XG4gICAgcmV0dXJuIGNvcHkyKG91dCwgdmVjWzBdLCB2ZWNbMV0pXG59XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybU1hdDQob3V0LCBhLCBtKSB7XG4gICAgdmFyIHggPSBhWzBdLCBcbiAgICAgICAgeSA9IGFbMV1cbiAgICBvdXRbMF0gPSBtWzBdICogeCArIG1bNF0gKiB5ICsgbVsxMl1cbiAgICBvdXRbMV0gPSBtWzFdICogeCArIG1bNV0gKiB5ICsgbVsxM11cbiAgICByZXR1cm4gb3V0XG59IiwidmFyIGNyZWF0ZVZBT0VtdWxhdGVkID0gcmVxdWlyZShcIi4vbGliL3Zhby1lbXVsYXRlZC5qc1wiKVxuXG5mdW5jdGlvbiBjcmVhdGVWQU8oZ2wsIGF0dHJpYnV0ZXMsIGVsZW1lbnRzLCBlbGVtZW50c1R5cGUpIHtcbiAgdmFyIHZhbyA9IGNyZWF0ZVZBT0VtdWxhdGVkKGdsKVxuICB2YW8udXBkYXRlKGF0dHJpYnV0ZXMsIGVsZW1lbnRzLCBlbGVtZW50c1R5cGUpXG4gIHJldHVybiB2YW9cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVWQU8iLCJmdW5jdGlvbiBnZXRBdHRyaWJ1dGVMb2NhdGlvbihuYW1lLCBzaGFkZXIpIHtcbiAgICBpZiAoIW5hbWUpXG4gICAgICAgIHJldHVybiBudWxsXG4gICAgdmFyIGF0dHIgPSBzaGFkZXIuYXR0cmlidXRlc1xuICAgIGlmIChhdHRyW25hbWVdKSBcbiAgICAgICAgcmV0dXJuIGF0dHJbbmFtZV0ubG9jYXRpb25cbiAgICByZXR1cm4gbnVsbFxufVxuXG52YXIgbmF0dHJpYnMgPSBudWxsXG52YXIgYm91bmQgPSBudWxsXG5cbmZ1bmN0aW9uIGRvQmluZChnbCwgZWxlbWVudHMsIGF0dHJpYnV0ZXMsIHNoYWRlcikge1xuICAgIGlmIChlbGVtZW50cykge1xuICAgICAgICBlbGVtZW50cy5iaW5kKClcbiAgICB9IGVsc2Uge1xuICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBudWxsKVxuICAgIH1cbiAgICBpZiAobmF0dHJpYnMgPT09IG51bGwpIHtcbiAgICAgIG5hdHRyaWJzID0gZ2wuZ2V0UGFyYW1ldGVyKGdsLk1BWF9WRVJURVhfQVRUUklCUykgfCAwXG4gICAgICBib3VuZCA9IG5ldyBBcnJheShuYXR0cmlicylcbiAgICB9XG5cbiAgICBpZiAoYXR0cmlidXRlcykge1xuICAgICAgICBpZiAoYXR0cmlidXRlcy5sZW5ndGggPiBuYXR0cmlicykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZ2wtdmFvOiBUb28gbWFueSB2ZXJ0ZXggYXR0cmlidXRlc1wiKVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxhc3RCb3VuZCA9IG51bGxcblxuICAgICAgICBmb3IgKGk9MDsgaTxuYXR0cmliczsgaSsrKVxuICAgICAgICAgIGJvdW5kW2ldID0gZmFsc2VcblxuICAgICAgICAvL25vdyBiaW5kIGFsaWFzZWQgYXR0cmlidXRlc1xuICAgICAgICBmb3IgKGk9MDsgaTxhdHRyaWJ1dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYXR0cmliID0gYXR0cmlidXRlc1tpXVxuICAgICAgICAgICAgdmFyIGxvYyA9IGdldEF0dHJpYnV0ZUxvY2F0aW9uKGF0dHJpYi5uYW1lLCBzaGFkZXIpXG4gICAgICAgICAgICBpZiAobG9jID09PSBudWxsKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgICAgIGJvdW5kW2xvY10gPSB0cnVlXG5cbiAgICAgICAgICAgIGlmKGF0dHJpYi5idWZmZXIpIHtcbiAgICAgICAgICAgICAgdmFyIGJ1ZmZlciA9IGF0dHJpYi5idWZmZXJcbiAgICAgICAgICAgICAgdmFyIHNpemUgPSBhdHRyaWIuc2l6ZSB8fCA0XG4gICAgICAgICAgICAgIHZhciB0eXBlID0gYXR0cmliLnR5cGUgfHwgZ2wuRkxPQVRcbiAgICAgICAgICAgICAgdmFyIG5vcm1hbGl6ZWQgPSAhIWF0dHJpYi5ub3JtYWxpemVkXG4gICAgICAgICAgICAgIHZhciBzdHJpZGUgPSBhdHRyaWIuc3RyaWRlIHx8IDBcbiAgICAgICAgICAgICAgdmFyIG9mZnNldCA9IGF0dHJpYi5vZmZzZXQgfHwgMFxuICAgICAgICAgICAgICBpZiAobGFzdEJvdW5kICE9PSBidWZmZXIpIHtcbiAgICAgICAgICAgICAgICBidWZmZXIuYmluZCgpXG4gICAgICAgICAgICAgICAgbGFzdEJvdW5kID0gYnVmZmVyXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkobG9jKVxuICAgICAgICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGxvYywgc2l6ZSwgdHlwZSwgbm9ybWFsaXplZCwgc3RyaWRlLCBvZmZzZXQpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZih0eXBlb2YgYXR0cmliID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgZ2wudmVydGV4QXR0cmliMWYobG9jLCBhdHRyaWIpXG4gICAgICAgICAgICAgIH0gZWxzZSBpZihhdHRyaWIubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgZ2wudmVydGV4QXR0cmliMWYobG9jLCBhdHRyaWJbMF0pXG4gICAgICAgICAgICAgIH0gZWxzZSBpZihhdHRyaWIubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgICAgZ2wudmVydGV4QXR0cmliMmYobG9jLCBhdHRyaWJbMF0sIGF0dHJpYlsxXSlcbiAgICAgICAgICAgICAgfSBlbHNlIGlmKGF0dHJpYi5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgICAgICAgICBnbC52ZXJ0ZXhBdHRyaWIzZihsb2MsIGF0dHJpYlswXSwgYXR0cmliWzFdLCBhdHRyaWJbMl0pXG4gICAgICAgICAgICAgIH0gZWxzZSBpZihhdHRyaWIubGVuZ3RoID09PSA0KSB7XG4gICAgICAgICAgICAgICAgZ2wudmVydGV4QXR0cmliNGYobG9jLCBhdHRyaWJbMF0sIGF0dHJpYlsxXSwgYXR0cmliWzJdLCBhdHRyaWJbM10pXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZ2wtdmFvOiBJbnZhbGlkIHZlcnRleCBhdHRyaWJ1dGVcIilcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBnbC5kaXNhYmxlVmVydGV4QXR0cmliQXJyYXkobG9jKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGZvciAoaT0wOyBpPG5hdHRyaWJzOyBpKyspIHtcbiAgICAgICAgICBpZiAoIWJvdW5kW2ldKVxuICAgICAgICAgICAgZ2wuZGlzYWJsZVZlcnRleEF0dHJpYkFycmF5KGkpXG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIG51bGwpXG4gICAgICBmb3IodmFyIGk9MDsgaTxuYXR0cmliczsgKytpKSB7XG4gICAgICAgIGdsLmRpc2FibGVWZXJ0ZXhBdHRyaWJBcnJheShpKVxuICAgICAgfVxuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBkb0JpbmQiLCJ2YXIgYmluZEF0dHJpYnMgPSByZXF1aXJlKFwiLi9kby1iaW5kLmpzXCIpXG5cbmZ1bmN0aW9uIFZBT0VtdWxhdGVkKGdsKSB7XG4gIHRoaXMuZ2wgPSBnbFxuICB0aGlzLl9lbGVtZW50cyA9IG51bGxcbiAgdGhpcy5fYXR0cmlidXRlcyA9IG51bGxcbiAgdGhpcy5fZWxlbWVudHNUeXBlID0gZ2wuVU5TSUdORURfU0hPUlRcbn1cblxuVkFPRW11bGF0ZWQucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbihzaGFkZXIpIHtcbiAgaWYgKCFzaGFkZXIpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdtdXN0IGFzc29jaWF0ZSBzaGFkZXIgd2l0aCB2ZXJ0ZXggYXJyYXknKVxuICBiaW5kQXR0cmlicyh0aGlzLmdsLCB0aGlzLl9lbGVtZW50cywgdGhpcy5fYXR0cmlidXRlcywgc2hhZGVyKVxufVxuXG5WQU9FbXVsYXRlZC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oYXR0cmlidXRlcywgZWxlbWVudHMsIGVsZW1lbnRzVHlwZSkge1xuICB0aGlzLl9lbGVtZW50cyA9IGVsZW1lbnRzXG4gIHRoaXMuX2F0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzXG4gIHRoaXMuX2VsZW1lbnRzVHlwZSA9IGVsZW1lbnRzVHlwZSB8fCB0aGlzLmdsLlVOU0lHTkVEX1NIT1JUXG59XG5cblZBT0VtdWxhdGVkLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24oKSB7IH1cblZBT0VtdWxhdGVkLnByb3RvdHlwZS51bmJpbmQgPSBmdW5jdGlvbigpIHtcbiAgYmluZEF0dHJpYnModGhpcy5nbClcbn1cblxuVkFPRW11bGF0ZWQucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbihtb2RlLCBjb3VudCwgb2Zmc2V0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8fCAwXG4gIHZhciBnbCA9IHRoaXMuZ2xcbiAgaWYodGhpcy5fZWxlbWVudHMpIHtcbiAgICBnbC5kcmF3RWxlbWVudHMobW9kZSwgY291bnQsIHRoaXMuX2VsZW1lbnRzVHlwZSwgb2Zmc2V0KVxuICB9IGVsc2Uge1xuICAgIGdsLmRyYXdBcnJheXMobW9kZSwgb2Zmc2V0LCBjb3VudClcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVWQU9FbXVsYXRlZChnbCkge1xuICByZXR1cm4gbmV3IFZBT0VtdWxhdGVkKGdsKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZVZBT0VtdWxhdGVkIiwiXCJ1c2Ugc3RyaWN0XCJcblxudmFyIHBvb2wgPSByZXF1aXJlKFwidHlwZWRhcnJheS1wb29sXCIpXG52YXIgb3BzID0gcmVxdWlyZShcIm5kYXJyYXktb3BzXCIpXG52YXIgbmRhcnJheSA9IHJlcXVpcmUoXCJuZGFycmF5XCIpXG52YXIgd2ViZ2xldyA9IHJlcXVpcmUoXCJ3ZWJnbGV3XCIpXG5cbnZhciBTVVBQT1JURURfVFlQRVMgPSBbXG4gIFwidWludDhcIixcbiAgXCJ1aW50OF9jbGFtcGVkXCIsXG4gIFwidWludDE2XCIsXG4gIFwidWludDMyXCIsXG4gIFwiaW50OFwiLFxuICBcImludDE2XCIsXG4gIFwiaW50MzJcIixcbiAgXCJmbG9hdDMyXCIgXVxuXG5mdW5jdGlvbiBHTEJ1ZmZlcihnbCwgdHlwZSwgaGFuZGxlLCBsZW5ndGgsIHVzYWdlKSB7XG4gIHRoaXMuZ2wgPSBnbFxuICB0aGlzLnR5cGUgPSB0eXBlXG4gIHRoaXMuaGFuZGxlID0gaGFuZGxlXG4gIHRoaXMubGVuZ3RoID0gbGVuZ3RoXG4gIHRoaXMudXNhZ2UgPSB1c2FnZVxufVxuXG52YXIgcHJvdG8gPSBHTEJ1ZmZlci5wcm90b3R5cGVcblxucHJvdG8uYmluZCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmdsLmJpbmRCdWZmZXIodGhpcy50eXBlLCB0aGlzLmhhbmRsZSlcbn1cblxucHJvdG8udW5iaW5kID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZ2wuYmluZEJ1ZmZlcih0aGlzLnR5cGUsIG51bGwpXG59XG5cbnByb3RvLmRpc3Bvc2UgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5nbC5kZWxldGVCdWZmZXIodGhpcy5oYW5kbGUpXG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVR5cGVBcnJheShnbCwgdHlwZSwgbGVuLCB1c2FnZSwgZGF0YSwgb2Zmc2V0KSB7XG4gIHZhciBkYXRhTGVuID0gZGF0YS5sZW5ndGggKiBkYXRhLkJZVEVTX1BFUl9FTEVNRU5UIFxuICBpZihvZmZzZXQgPCAwKSB7XG4gICAgZ2wuYnVmZmVyRGF0YSh0eXBlLCBkYXRhLCB1c2FnZSlcbiAgICByZXR1cm4gZGF0YUxlblxuICB9XG4gIGlmKGRhdGFMZW4gKyBvZmZzZXQgPiBsZW4pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJnbC1idWZmZXI6IElmIHJlc2l6aW5nIGJ1ZmZlciwgbXVzdCBub3Qgc3BlY2lmeSBvZmZzZXRcIilcbiAgfVxuICBnbC5idWZmZXJTdWJEYXRhKHR5cGUsIG9mZnNldCwgZGF0YSlcbiAgcmV0dXJuIGxlblxufVxuXG5mdW5jdGlvbiBtYWtlU2NyYXRjaFR5cGVBcnJheShhcnJheSwgZHR5cGUpIHtcbiAgdmFyIHJlcyA9IHBvb2wubWFsbG9jKGFycmF5Lmxlbmd0aCwgZHR5cGUpXG4gIHZhciBuID0gYXJyYXkubGVuZ3RoXG4gIGZvcih2YXIgaT0wOyBpPG47ICsraSkge1xuICAgIHJlc1tpXSA9IGFycmF5W2ldXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBpc1BhY2tlZChzaGFwZSwgc3RyaWRlKSB7XG4gIHZhciBuID0gMVxuICBmb3IodmFyIGk9c3RyaWRlLmxlbmd0aC0xOyBpPj0wOyAtLWkpIHtcbiAgICBpZihzdHJpZGVbaV0gIT09IG4pIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICBuICo9IHNoYXBlW2ldXG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxucHJvdG8udXBkYXRlID0gZnVuY3Rpb24oYXJyYXksIG9mZnNldCkge1xuICBpZih0eXBlb2Ygb2Zmc2V0ICE9PSBcIm51bWJlclwiKSB7XG4gICAgb2Zmc2V0ID0gLTFcbiAgfVxuICB0aGlzLmJpbmQoKVxuICBpZih0eXBlb2YgYXJyYXkgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIGFycmF5LnNoYXBlICE9PSBcInVuZGVmaW5lZFwiKSB7IC8vbmRhcnJheVxuICAgIHZhciBkdHlwZSA9IGFycmF5LmR0eXBlXG4gICAgaWYoU1VQUE9SVEVEX1RZUEVTLmluZGV4T2YoZHR5cGUpIDwgMCkge1xuICAgICAgZHR5cGUgPSBcImZsb2F0MzJcIlxuICAgIH1cbiAgICBpZih0aGlzLnR5cGUgPT09IHRoaXMuZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIpIHtcbiAgICAgIHZhciB3Z2wgPSB3ZWJnbGV3KHRoaXMuZ2wpXG4gICAgICB2YXIgZXh0ID0gd2dsLk9FU19lbGVtZW50X2luZGV4X3VpbnRcbiAgICAgIGlmKGV4dCAmJiBkdHlwZSAhPT0gXCJ1aW50MTZcIikge1xuICAgICAgICBkdHlwZSA9IFwidWludDMyXCJcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGR0eXBlID0gXCJ1aW50MTZcIlxuICAgICAgfVxuICAgIH1cbiAgICBpZihkdHlwZSA9PT0gYXJyYXkuZHR5cGUgJiYgaXNQYWNrZWQoYXJyYXkuc2hhcGUsIGFycmF5LnN0cmlkZSkpIHtcbiAgICAgIGlmKGFycmF5Lm9mZnNldCA9PT0gMCAmJiBhcnJheS5kYXRhLmxlbmd0aCA9PT0gYXJyYXkuc2hhcGVbMF0pIHtcbiAgICAgICAgdGhpcy5sZW5ndGggPSB1cGRhdGVUeXBlQXJyYXkodGhpcy5nbCwgdGhpcy50eXBlLCB0aGlzLmxlbmd0aCwgdGhpcy51c2FnZSwgYXJyYXkuZGF0YSwgb2Zmc2V0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5sZW5ndGggPSB1cGRhdGVUeXBlQXJyYXkodGhpcy5nbCwgdGhpcy50eXBlLCB0aGlzLmxlbmd0aCwgdGhpcy51c2FnZSwgYXJyYXkuZGF0YS5zdWJhcnJheShhcnJheS5vZmZzZXQsIGFycmF5LnNoYXBlWzBdKSwgb2Zmc2V0KVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgdG1wID0gcG9vbC5tYWxsb2MoYXJyYXkuc2l6ZSwgZHR5cGUpXG4gICAgICB2YXIgbmR0ID0gbmRhcnJheSh0bXAsIGFycmF5LnNoYXBlKVxuICAgICAgb3BzLmFzc2lnbihuZHQsIGFycmF5KVxuICAgICAgaWYob2Zmc2V0IDwgMCkge1xuICAgICAgICB0aGlzLmxlbmd0aCA9IHVwZGF0ZVR5cGVBcnJheSh0aGlzLmdsLCB0aGlzLnR5cGUsIHRoaXMubGVuZ3RoLCB0aGlzLnVzYWdlLCB0bXAsIG9mZnNldCkgIFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5sZW5ndGggPSB1cGRhdGVUeXBlQXJyYXkodGhpcy5nbCwgdGhpcy50eXBlLCB0aGlzLmxlbmd0aCwgdGhpcy51c2FnZSwgdG1wLnN1YmFycmF5KDAsIGFycmF5LnNpemUpLCBvZmZzZXQpICBcbiAgICAgIH1cbiAgICAgIHBvb2wuZnJlZSh0bXApXG4gICAgfVxuICB9IGVsc2UgaWYoQXJyYXkuaXNBcnJheShhcnJheSkpIHsgLy9WYW5pbGxhIGFycmF5XG4gICAgdmFyIHRcbiAgICBpZih0aGlzLnR5cGUgPT09IHRoaXMuZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIpIHtcbiAgICAgIHQgPSBtYWtlU2NyYXRjaFR5cGVBcnJheShhcnJheSwgXCJ1aW50MTZcIilcbiAgICB9IGVsc2Uge1xuICAgICAgdCA9IG1ha2VTY3JhdGNoVHlwZUFycmF5KGFycmF5LCBcImZsb2F0MzJcIilcbiAgICB9XG4gICAgaWYob2Zmc2V0IDwgMCkge1xuICAgICAgdGhpcy5sZW5ndGggPSB1cGRhdGVUeXBlQXJyYXkodGhpcy5nbCwgdGhpcy50eXBlLCB0aGlzLmxlbmd0aCwgdGhpcy51c2FnZSwgdCwgb2Zmc2V0KVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmxlbmd0aCA9IHVwZGF0ZVR5cGVBcnJheSh0aGlzLmdsLCB0aGlzLnR5cGUsIHRoaXMubGVuZ3RoLCB0aGlzLnVzYWdlLCB0LnN1YmFycmF5KDAsIGFycmF5Lmxlbmd0aCksIG9mZnNldClcbiAgICB9XG4gICAgcG9vbC5mcmVlKHQpXG4gIH0gZWxzZSBpZih0eXBlb2YgYXJyYXkgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIGFycmF5Lmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyAvL1R5cGVkIGFycmF5XG4gICAgdGhpcy5sZW5ndGggPSB1cGRhdGVUeXBlQXJyYXkodGhpcy5nbCwgdGhpcy50eXBlLCB0aGlzLmxlbmd0aCwgdGhpcy51c2FnZSwgYXJyYXksIG9mZnNldClcbiAgfSBlbHNlIGlmKHR5cGVvZiBhcnJheSA9PT0gXCJudW1iZXJcIiB8fCBhcnJheSA9PT0gdW5kZWZpbmVkKSB7IC8vTnVtYmVyL2RlZmF1bHRcbiAgICBpZihvZmZzZXQgPj0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZ2wtYnVmZmVyOiBDYW5ub3Qgc3BlY2lmeSBvZmZzZXQgd2hlbiByZXNpemluZyBidWZmZXJcIilcbiAgICB9XG4gICAgYXJyYXkgPSBhcnJheSB8IDBcbiAgICBpZihhcnJheSA8PSAwKSB7XG4gICAgICBhcnJheSA9IDFcbiAgICB9XG4gICAgdGhpcy5nbC5idWZmZXJEYXRhKHRoaXMudHlwZSwgYXJyYXl8MCwgdGhpcy51c2FnZSlcbiAgICB0aGlzLmxlbmd0aCA9IGFycmF5XG4gIH0gZWxzZSB7IC8vRXJyb3IsIGNhc2Ugc2hvdWxkIG5vdCBoYXBwZW5cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJnbC1idWZmZXI6IEludmFsaWQgZGF0YSB0eXBlXCIpXG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlQnVmZmVyKGdsLCBkYXRhLCB0eXBlLCB1c2FnZSkge1xuICB3ZWJnbGV3KGdsKVxuICB0eXBlID0gdHlwZSB8fCBnbC5BUlJBWV9CVUZGRVJcbiAgdXNhZ2UgPSB1c2FnZSB8fCBnbC5EWU5BTUlDX0RSQVdcbiAgaWYodHlwZSAhPT0gZ2wuQVJSQVlfQlVGRkVSICYmIHR5cGUgIT09IGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZ2wtYnVmZmVyOiBJbnZhbGlkIHR5cGUgZm9yIHdlYmdsIGJ1ZmZlciwgbXVzdCBiZSBlaXRoZXIgZ2wuQVJSQVlfQlVGRkVSIG9yIGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSXCIpXG4gIH1cbiAgaWYodXNhZ2UgIT09IGdsLkRZTkFNSUNfRFJBVyAmJiB1c2FnZSAhPT0gZ2wuU1RBVElDX0RSQVcgJiYgdXNhZ2UgIT09IGdsLlNUUkVBTV9EUkFXKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZ2wtYnVmZmVyOiBJbnZhbGlkIHVzYWdlIGZvciBidWZmZXIsIG11c3QgYmUgZWl0aGVyIGdsLkRZTkFNSUNfRFJBVywgZ2wuU1RBVElDX0RSQVcgb3IgZ2wuU1RSRUFNX0RSQVdcIilcbiAgfVxuICB2YXIgaGFuZGxlID0gZ2wuY3JlYXRlQnVmZmVyKClcbiAgdmFyIHJlc3VsdCA9IG5ldyBHTEJ1ZmZlcihnbCwgdHlwZSwgaGFuZGxlLCAwLCB1c2FnZSlcbiAgcmVzdWx0LnVwZGF0ZShkYXRhKVxuICByZXR1cm4gcmVzdWx0XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlQnVmZmVyIiwibW9kdWxlLmV4cG9ydHM9cmVxdWlyZShcIi9wcm9qZWN0cy9ibGFja2ljZS9ub2RlX21vZHVsZXMvZ2wtdGV4dHVyZTJkL25vZGVfbW9kdWxlcy9uZGFycmF5LW9wcy9uZGFycmF5LW9wcy5qc1wiKSIsIihmdW5jdGlvbiAoQnVmZmVyKXtcbnZhciBpb3RhID0gcmVxdWlyZShcImlvdGEtYXJyYXlcIilcblxudmFyIGhhc1R5cGVkQXJyYXlzICA9ICgodHlwZW9mIEZsb2F0NjRBcnJheSkgIT09IFwidW5kZWZpbmVkXCIpXG52YXIgaGFzQnVmZmVyICAgICAgID0gKCh0eXBlb2YgQnVmZmVyKSAhPT0gXCJ1bmRlZmluZWRcIilcblxuZnVuY3Rpb24gY29tcGFyZTFzdChhLCBiKSB7XG4gIHJldHVybiBhWzBdIC0gYlswXVxufVxuXG5mdW5jdGlvbiBvcmRlcigpIHtcbiAgdmFyIHN0cmlkZSA9IHRoaXMuc3RyaWRlXG4gIHZhciB0ZXJtcyA9IG5ldyBBcnJheShzdHJpZGUubGVuZ3RoKVxuICB2YXIgaVxuICBmb3IoaT0wOyBpPHRlcm1zLmxlbmd0aDsgKytpKSB7XG4gICAgdGVybXNbaV0gPSBbTWF0aC5hYnMoc3RyaWRlW2ldKSwgaV1cbiAgfVxuICB0ZXJtcy5zb3J0KGNvbXBhcmUxc3QpXG4gIHZhciByZXN1bHQgPSBuZXcgQXJyYXkodGVybXMubGVuZ3RoKVxuICBmb3IoaT0wOyBpPHJlc3VsdC5sZW5ndGg7ICsraSkge1xuICAgIHJlc3VsdFtpXSA9IHRlcm1zW2ldWzFdXG4gIH1cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5mdW5jdGlvbiBjb21waWxlQ29uc3RydWN0b3IoZHR5cGUsIGRpbWVuc2lvbikge1xuICB2YXIgY2xhc3NOYW1lID0gW1wiVmlld1wiLCBkaW1lbnNpb24sIFwiZFwiLCBkdHlwZV0uam9pbihcIlwiKVxuICBpZihkaW1lbnNpb24gPCAwKSB7XG4gICAgY2xhc3NOYW1lID0gXCJWaWV3X05pbFwiICsgZHR5cGVcbiAgfVxuICB2YXIgdXNlR2V0dGVycyA9IChkdHlwZSA9PT0gXCJnZW5lcmljXCIpXG4gIFxuICBpZihkaW1lbnNpb24gPT09IC0xKSB7XG4gICAgLy9TcGVjaWFsIGNhc2UgZm9yIHRyaXZpYWwgYXJyYXlzXG4gICAgdmFyIGNvZGUgPSBcbiAgICAgIFwiZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiKGEpe3RoaXMuZGF0YT1hO307XFxcbnZhciBwcm90bz1cIitjbGFzc05hbWUrXCIucHJvdG90eXBlO1xcXG5wcm90by5kdHlwZT0nXCIrZHR5cGUrXCInO1xcXG5wcm90by5pbmRleD1mdW5jdGlvbigpe3JldHVybiAtMX07XFxcbnByb3RvLnNpemU9MDtcXFxucHJvdG8uZGltZW5zaW9uPS0xO1xcXG5wcm90by5zaGFwZT1wcm90by5zdHJpZGU9cHJvdG8ub3JkZXI9W107XFxcbnByb3RvLmxvPXByb3RvLmhpPXByb3RvLnRyYW5zcG9zZT1wcm90by5zdGVwPVxcXG5mdW5jdGlvbigpe3JldHVybiBuZXcgXCIrY2xhc3NOYW1lK1wiKHRoaXMuZGF0YSk7fTtcXFxucHJvdG8uZ2V0PXByb3RvLnNldD1mdW5jdGlvbigpe307XFxcbnByb3RvLnBpY2s9ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbH07XFxcbnJldHVybiBmdW5jdGlvbiBjb25zdHJ1Y3RfXCIrY2xhc3NOYW1lK1wiKGEpe3JldHVybiBuZXcgXCIrY2xhc3NOYW1lK1wiKGEpO31cIlxuICAgIHZhciBwcm9jZWR1cmUgPSBuZXcgRnVuY3Rpb24oY29kZSlcbiAgICByZXR1cm4gcHJvY2VkdXJlKClcbiAgfSBlbHNlIGlmKGRpbWVuc2lvbiA9PT0gMCkge1xuICAgIC8vU3BlY2lhbCBjYXNlIGZvciAwZCBhcnJheXNcbiAgICB2YXIgY29kZSA9XG4gICAgICBcImZ1bmN0aW9uIFwiK2NsYXNzTmFtZStcIihhLGQpIHtcXFxudGhpcy5kYXRhID0gYTtcXFxudGhpcy5vZmZzZXQgPSBkXFxcbn07XFxcbnZhciBwcm90bz1cIitjbGFzc05hbWUrXCIucHJvdG90eXBlO1xcXG5wcm90by5kdHlwZT0nXCIrZHR5cGUrXCInO1xcXG5wcm90by5pbmRleD1mdW5jdGlvbigpe3JldHVybiB0aGlzLm9mZnNldH07XFxcbnByb3RvLmRpbWVuc2lvbj0wO1xcXG5wcm90by5zaXplPTE7XFxcbnByb3RvLnNoYXBlPVxcXG5wcm90by5zdHJpZGU9XFxcbnByb3RvLm9yZGVyPVtdO1xcXG5wcm90by5sbz1cXFxucHJvdG8uaGk9XFxcbnByb3RvLnRyYW5zcG9zZT1cXFxucHJvdG8uc3RlcD1mdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfY29weSgpIHtcXFxucmV0dXJuIG5ldyBcIitjbGFzc05hbWUrXCIodGhpcy5kYXRhLHRoaXMub2Zmc2V0KVxcXG59O1xcXG5wcm90by5waWNrPWZ1bmN0aW9uIFwiK2NsYXNzTmFtZStcIl9waWNrKCl7XFxcbnJldHVybiBUcml2aWFsQXJyYXkodGhpcy5kYXRhKTtcXFxufTtcXFxucHJvdG8udmFsdWVPZj1wcm90by5nZXQ9ZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiX2dldCgpe1xcXG5yZXR1cm4gXCIrKHVzZUdldHRlcnMgPyBcInRoaXMuZGF0YS5nZXQodGhpcy5vZmZzZXQpXCIgOiBcInRoaXMuZGF0YVt0aGlzLm9mZnNldF1cIikrXG5cIn07XFxcbnByb3RvLnNldD1mdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfc2V0KHYpe1xcXG5yZXR1cm4gXCIrKHVzZUdldHRlcnMgPyBcInRoaXMuZGF0YS5zZXQodGhpcy5vZmZzZXQsdilcIiA6IFwidGhpcy5kYXRhW3RoaXMub2Zmc2V0XT12XCIpK1wiXFxcbn07XFxcbnJldHVybiBmdW5jdGlvbiBjb25zdHJ1Y3RfXCIrY2xhc3NOYW1lK1wiKGEsYixjLGQpe3JldHVybiBuZXcgXCIrY2xhc3NOYW1lK1wiKGEsZCl9XCJcbiAgICB2YXIgcHJvY2VkdXJlID0gbmV3IEZ1bmN0aW9uKFwiVHJpdmlhbEFycmF5XCIsIGNvZGUpXG4gICAgcmV0dXJuIHByb2NlZHVyZShDQUNIRURfQ09OU1RSVUNUT1JTW2R0eXBlXVswXSlcbiAgfVxuXG4gIHZhciBjb2RlID0gW1wiJ3VzZSBzdHJpY3QnXCJdXG4gICAgXG4gIC8vQ3JlYXRlIGNvbnN0cnVjdG9yIGZvciB2aWV3XG4gIHZhciBpbmRpY2VzID0gaW90YShkaW1lbnNpb24pXG4gIHZhciBhcmdzID0gaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkgeyByZXR1cm4gXCJpXCIraSB9KVxuICB2YXIgaW5kZXhfc3RyID0gXCJ0aGlzLm9mZnNldCtcIiArIGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgcmV0dXJuIFwidGhpcy5zdHJpZGVbXCIgKyBpICsgXCJdKmlcIiArIGlcbiAgICAgIH0pLmpvaW4oXCIrXCIpXG4gIHZhciBzaGFwZUFyZyA9IGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBcImJcIitpXG4gICAgfSkuam9pbihcIixcIilcbiAgdmFyIHN0cmlkZUFyZyA9IGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBcImNcIitpXG4gICAgfSkuam9pbihcIixcIilcbiAgY29kZS5wdXNoKFxuICAgIFwiZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiKGEsXCIgKyBzaGFwZUFyZyArIFwiLFwiICsgc3RyaWRlQXJnICsgXCIsZCl7dGhpcy5kYXRhPWFcIixcbiAgICAgIFwidGhpcy5zaGFwZT1bXCIgKyBzaGFwZUFyZyArIFwiXVwiLFxuICAgICAgXCJ0aGlzLnN0cmlkZT1bXCIgKyBzdHJpZGVBcmcgKyBcIl1cIixcbiAgICAgIFwidGhpcy5vZmZzZXQ9ZHwwfVwiLFxuICAgIFwidmFyIHByb3RvPVwiK2NsYXNzTmFtZStcIi5wcm90b3R5cGVcIixcbiAgICBcInByb3RvLmR0eXBlPSdcIitkdHlwZStcIidcIixcbiAgICBcInByb3RvLmRpbWVuc2lvbj1cIitkaW1lbnNpb24pXG4gIFxuICAvL3ZpZXcuc2l6ZTpcbiAgY29kZS5wdXNoKFwiT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvLCdzaXplJyx7Z2V0OmZ1bmN0aW9uIFwiK2NsYXNzTmFtZStcIl9zaXplKCl7XFxcbnJldHVybiBcIitpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7IHJldHVybiBcInRoaXMuc2hhcGVbXCIraStcIl1cIiB9KS5qb2luKFwiKlwiKSxcblwifX0pXCIpXG5cbiAgLy92aWV3Lm9yZGVyOlxuICBpZihkaW1lbnNpb24gPT09IDEpIHtcbiAgICBjb2RlLnB1c2goXCJwcm90by5vcmRlcj1bMF1cIilcbiAgfSBlbHNlIHtcbiAgICBjb2RlLnB1c2goXCJPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG8sJ29yZGVyJyx7Z2V0OlwiKVxuICAgIGlmKGRpbWVuc2lvbiA8IDQpIHtcbiAgICAgIGNvZGUucHVzaChcImZ1bmN0aW9uIFwiK2NsYXNzTmFtZStcIl9vcmRlcigpe1wiKVxuICAgICAgaWYoZGltZW5zaW9uID09PSAyKSB7XG4gICAgICAgIGNvZGUucHVzaChcInJldHVybiAoTWF0aC5hYnModGhpcy5zdHJpZGVbMF0pPk1hdGguYWJzKHRoaXMuc3RyaWRlWzFdKSk/WzEsMF06WzAsMV19fSlcIilcbiAgICAgIH0gZWxzZSBpZihkaW1lbnNpb24gPT09IDMpIHtcbiAgICAgICAgY29kZS5wdXNoKFxuXCJ2YXIgczA9TWF0aC5hYnModGhpcy5zdHJpZGVbMF0pLHMxPU1hdGguYWJzKHRoaXMuc3RyaWRlWzFdKSxzMj1NYXRoLmFicyh0aGlzLnN0cmlkZVsyXSk7XFxcbmlmKHMwPnMxKXtcXFxuaWYoczE+czIpe1xcXG5yZXR1cm4gWzIsMSwwXTtcXFxufWVsc2UgaWYoczA+czIpe1xcXG5yZXR1cm4gWzEsMiwwXTtcXFxufWVsc2V7XFxcbnJldHVybiBbMSwwLDJdO1xcXG59XFxcbn1lbHNlIGlmKHMwPnMyKXtcXFxucmV0dXJuIFsyLDAsMV07XFxcbn1lbHNlIGlmKHMyPnMxKXtcXFxucmV0dXJuIFswLDEsMl07XFxcbn1lbHNle1xcXG5yZXR1cm4gWzAsMiwxXTtcXFxufX19KVwiKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb2RlLnB1c2goXCJPUkRFUn0pXCIpXG4gICAgfVxuICB9XG4gIFxuICAvL3ZpZXcuc2V0KGkwLCAuLi4sIHYpOlxuICBjb2RlLnB1c2goXG5cInByb3RvLnNldD1mdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfc2V0KFwiK2FyZ3Muam9pbihcIixcIikrXCIsdil7XCIpXG4gIGlmKHVzZUdldHRlcnMpIHtcbiAgICBjb2RlLnB1c2goXCJyZXR1cm4gdGhpcy5kYXRhLnNldChcIitpbmRleF9zdHIrXCIsdil9XCIpXG4gIH0gZWxzZSB7XG4gICAgY29kZS5wdXNoKFwicmV0dXJuIHRoaXMuZGF0YVtcIitpbmRleF9zdHIrXCJdPXZ9XCIpXG4gIH1cbiAgXG4gIC8vdmlldy5nZXQoaTAsIC4uLik6XG4gIGNvZGUucHVzaChcInByb3RvLmdldD1mdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfZ2V0KFwiK2FyZ3Muam9pbihcIixcIikrXCIpe1wiKVxuICBpZih1c2VHZXR0ZXJzKSB7XG4gICAgY29kZS5wdXNoKFwicmV0dXJuIHRoaXMuZGF0YS5nZXQoXCIraW5kZXhfc3RyK1wiKX1cIilcbiAgfSBlbHNlIHtcbiAgICBjb2RlLnB1c2goXCJyZXR1cm4gdGhpcy5kYXRhW1wiK2luZGV4X3N0citcIl19XCIpXG4gIH1cbiAgXG4gIC8vdmlldy5pbmRleDpcbiAgY29kZS5wdXNoKFxuICAgIFwicHJvdG8uaW5kZXg9ZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiX2luZGV4KFwiLCBhcmdzLmpvaW4oKSwgXCIpe3JldHVybiBcIitpbmRleF9zdHIrXCJ9XCIpXG5cbiAgLy92aWV3LmhpKCk6XG4gIGNvZGUucHVzaChcInByb3RvLmhpPWZ1bmN0aW9uIFwiK2NsYXNzTmFtZStcIl9oaShcIithcmdzLmpvaW4oXCIsXCIpK1wiKXtyZXR1cm4gbmV3IFwiK2NsYXNzTmFtZStcIih0aGlzLmRhdGEsXCIrXG4gICAgaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIFtcIih0eXBlb2YgaVwiLGksXCIhPT0nbnVtYmVyJ3x8aVwiLGksXCI8MCk/dGhpcy5zaGFwZVtcIiwgaSwgXCJdOmlcIiwgaSxcInwwXCJdLmpvaW4oXCJcIilcbiAgICB9KS5qb2luKFwiLFwiKStcIixcIitcbiAgICBpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gXCJ0aGlzLnN0cmlkZVtcIitpICsgXCJdXCJcbiAgICB9KS5qb2luKFwiLFwiKStcIix0aGlzLm9mZnNldCl9XCIpXG4gIFxuICAvL3ZpZXcubG8oKTpcbiAgdmFyIGFfdmFycyA9IGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHsgcmV0dXJuIFwiYVwiK2krXCI9dGhpcy5zaGFwZVtcIitpK1wiXVwiIH0pXG4gIHZhciBjX3ZhcnMgPSBpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7IHJldHVybiBcImNcIitpK1wiPXRoaXMuc3RyaWRlW1wiK2krXCJdXCIgfSlcbiAgY29kZS5wdXNoKFwicHJvdG8ubG89ZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiX2xvKFwiK2FyZ3Muam9pbihcIixcIikrXCIpe3ZhciBiPXRoaXMub2Zmc2V0LGQ9MCxcIithX3ZhcnMuam9pbihcIixcIikrXCIsXCIrY192YXJzLmpvaW4oXCIsXCIpKVxuICBmb3IodmFyIGk9MDsgaTxkaW1lbnNpb247ICsraSkge1xuICAgIGNvZGUucHVzaChcblwiaWYodHlwZW9mIGlcIitpK1wiPT09J251bWJlcicmJmlcIitpK1wiPj0wKXtcXFxuZD1pXCIraStcInwwO1xcXG5iKz1jXCIraStcIipkO1xcXG5hXCIraStcIi09ZH1cIilcbiAgfVxuICBjb2RlLnB1c2goXCJyZXR1cm4gbmV3IFwiK2NsYXNzTmFtZStcIih0aGlzLmRhdGEsXCIrXG4gICAgaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIFwiYVwiK2lcbiAgICB9KS5qb2luKFwiLFwiKStcIixcIitcbiAgICBpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gXCJjXCIraVxuICAgIH0pLmpvaW4oXCIsXCIpK1wiLGIpfVwiKVxuICBcbiAgLy92aWV3LnN0ZXAoKTpcbiAgY29kZS5wdXNoKFwicHJvdG8uc3RlcD1mdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfc3RlcChcIithcmdzLmpvaW4oXCIsXCIpK1wiKXt2YXIgXCIrXG4gICAgaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIFwiYVwiK2krXCI9dGhpcy5zaGFwZVtcIitpK1wiXVwiXG4gICAgfSkuam9pbihcIixcIikrXCIsXCIrXG4gICAgaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIFwiYlwiK2krXCI9dGhpcy5zdHJpZGVbXCIraStcIl1cIlxuICAgIH0pLmpvaW4oXCIsXCIpK1wiLGM9dGhpcy5vZmZzZXQsZD0wLGNlaWw9TWF0aC5jZWlsXCIpXG4gIGZvcih2YXIgaT0wOyBpPGRpbWVuc2lvbjsgKytpKSB7XG4gICAgY29kZS5wdXNoKFxuXCJpZih0eXBlb2YgaVwiK2krXCI9PT0nbnVtYmVyJyl7XFxcbmQ9aVwiK2krXCJ8MDtcXFxuaWYoZDwwKXtcXFxuYys9YlwiK2krXCIqKGFcIitpK1wiLTEpO1xcXG5hXCIraStcIj1jZWlsKC1hXCIraStcIi9kKVxcXG59ZWxzZXtcXFxuYVwiK2krXCI9Y2VpbChhXCIraStcIi9kKVxcXG59XFxcbmJcIitpK1wiKj1kXFxcbn1cIilcbiAgfVxuICBjb2RlLnB1c2goXCJyZXR1cm4gbmV3IFwiK2NsYXNzTmFtZStcIih0aGlzLmRhdGEsXCIrXG4gICAgaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIFwiYVwiICsgaVxuICAgIH0pLmpvaW4oXCIsXCIpK1wiLFwiK1xuICAgIGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBcImJcIiArIGlcbiAgICB9KS5qb2luKFwiLFwiKStcIixjKX1cIilcbiAgXG4gIC8vdmlldy50cmFuc3Bvc2UoKTpcbiAgdmFyIHRTaGFwZSA9IG5ldyBBcnJheShkaW1lbnNpb24pXG4gIHZhciB0U3RyaWRlID0gbmV3IEFycmF5KGRpbWVuc2lvbilcbiAgZm9yKHZhciBpPTA7IGk8ZGltZW5zaW9uOyArK2kpIHtcbiAgICB0U2hhcGVbaV0gPSBcImFbaVwiK2krXCJdXCJcbiAgICB0U3RyaWRlW2ldID0gXCJiW2lcIitpK1wiXVwiXG4gIH1cbiAgY29kZS5wdXNoKFwicHJvdG8udHJhbnNwb3NlPWZ1bmN0aW9uIFwiK2NsYXNzTmFtZStcIl90cmFuc3Bvc2UoXCIrYXJncytcIil7XCIrXG4gICAgYXJncy5tYXAoZnVuY3Rpb24obixpZHgpIHsgcmV0dXJuIG4gKyBcIj0oXCIgKyBuICsgXCI9PT11bmRlZmluZWQ/XCIgKyBpZHggKyBcIjpcIiArIG4gKyBcInwwKVwifSkuam9pbihcIjtcIiksXG4gICAgXCJ2YXIgYT10aGlzLnNoYXBlLGI9dGhpcy5zdHJpZGU7cmV0dXJuIG5ldyBcIitjbGFzc05hbWUrXCIodGhpcy5kYXRhLFwiK3RTaGFwZS5qb2luKFwiLFwiKStcIixcIit0U3RyaWRlLmpvaW4oXCIsXCIpK1wiLHRoaXMub2Zmc2V0KX1cIilcbiAgXG4gIC8vdmlldy5waWNrKCk6XG4gIGNvZGUucHVzaChcInByb3RvLnBpY2s9ZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiX3BpY2soXCIrYXJncytcIil7dmFyIGE9W10sYj1bXSxjPXRoaXMub2Zmc2V0XCIpXG4gIGZvcih2YXIgaT0wOyBpPGRpbWVuc2lvbjsgKytpKSB7XG4gICAgY29kZS5wdXNoKFwiaWYodHlwZW9mIGlcIitpK1wiPT09J251bWJlcicmJmlcIitpK1wiPj0wKXtjPShjK3RoaXMuc3RyaWRlW1wiK2krXCJdKmlcIitpK1wiKXwwfWVsc2V7YS5wdXNoKHRoaXMuc2hhcGVbXCIraStcIl0pO2IucHVzaCh0aGlzLnN0cmlkZVtcIitpK1wiXSl9XCIpXG4gIH1cbiAgY29kZS5wdXNoKFwidmFyIGN0b3I9Q1RPUl9MSVNUW2EubGVuZ3RoKzFdO3JldHVybiBjdG9yKHRoaXMuZGF0YSxhLGIsYyl9XCIpXG4gICAgXG4gIC8vQWRkIHJldHVybiBzdGF0ZW1lbnRcbiAgY29kZS5wdXNoKFwicmV0dXJuIGZ1bmN0aW9uIGNvbnN0cnVjdF9cIitjbGFzc05hbWUrXCIoZGF0YSxzaGFwZSxzdHJpZGUsb2Zmc2V0KXtyZXR1cm4gbmV3IFwiK2NsYXNzTmFtZStcIihkYXRhLFwiK1xuICAgIGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBcInNoYXBlW1wiK2krXCJdXCJcbiAgICB9KS5qb2luKFwiLFwiKStcIixcIitcbiAgICBpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gXCJzdHJpZGVbXCIraStcIl1cIlxuICAgIH0pLmpvaW4oXCIsXCIpK1wiLG9mZnNldCl9XCIpXG5cbiAgLy9Db21waWxlIHByb2NlZHVyZVxuICB2YXIgcHJvY2VkdXJlID0gbmV3IEZ1bmN0aW9uKFwiQ1RPUl9MSVNUXCIsIFwiT1JERVJcIiwgY29kZS5qb2luKFwiXFxuXCIpKVxuICByZXR1cm4gcHJvY2VkdXJlKENBQ0hFRF9DT05TVFJVQ1RPUlNbZHR5cGVdLCBvcmRlcilcbn1cblxuZnVuY3Rpb24gYXJyYXlEVHlwZShkYXRhKSB7XG4gIGlmKGhhc0J1ZmZlcikge1xuICAgIGlmKEJ1ZmZlci5pc0J1ZmZlcihkYXRhKSkge1xuICAgICAgcmV0dXJuIFwiYnVmZmVyXCJcbiAgICB9XG4gIH1cbiAgaWYoaGFzVHlwZWRBcnJheXMpIHtcbiAgICBzd2l0Y2goT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGRhdGEpKSB7XG4gICAgICBjYXNlIFwiW29iamVjdCBGbG9hdDY0QXJyYXldXCI6XG4gICAgICAgIHJldHVybiBcImZsb2F0NjRcIlxuICAgICAgY2FzZSBcIltvYmplY3QgRmxvYXQzMkFycmF5XVwiOlxuICAgICAgICByZXR1cm4gXCJmbG9hdDMyXCJcbiAgICAgIGNhc2UgXCJbb2JqZWN0IEludDhBcnJheV1cIjpcbiAgICAgICAgcmV0dXJuIFwiaW50OFwiXG4gICAgICBjYXNlIFwiW29iamVjdCBJbnQxNkFycmF5XVwiOlxuICAgICAgICByZXR1cm4gXCJpbnQxNlwiXG4gICAgICBjYXNlIFwiW29iamVjdCBJbnQzMkFycmF5XVwiOlxuICAgICAgICByZXR1cm4gXCJpbnQzMlwiXG4gICAgICBjYXNlIFwiW29iamVjdCBVaW50OEFycmF5XVwiOlxuICAgICAgICByZXR1cm4gXCJ1aW50OFwiXG4gICAgICBjYXNlIFwiW29iamVjdCBVaW50MTZBcnJheV1cIjpcbiAgICAgICAgcmV0dXJuIFwidWludDE2XCJcbiAgICAgIGNhc2UgXCJbb2JqZWN0IFVpbnQzMkFycmF5XVwiOlxuICAgICAgICByZXR1cm4gXCJ1aW50MzJcIlxuICAgICAgY2FzZSBcIltvYmplY3QgVWludDhDbGFtcGVkQXJyYXldXCI6XG4gICAgICAgIHJldHVybiBcInVpbnQ4X2NsYW1wZWRcIlxuICAgIH1cbiAgfVxuICBpZihBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgcmV0dXJuIFwiYXJyYXlcIlxuICB9XG4gIHJldHVybiBcImdlbmVyaWNcIlxufVxuXG52YXIgQ0FDSEVEX0NPTlNUUlVDVE9SUyA9IHtcbiAgXCJmbG9hdDMyXCI6W10sXG4gIFwiZmxvYXQ2NFwiOltdLFxuICBcImludDhcIjpbXSxcbiAgXCJpbnQxNlwiOltdLFxuICBcImludDMyXCI6W10sXG4gIFwidWludDhcIjpbXSxcbiAgXCJ1aW50MTZcIjpbXSxcbiAgXCJ1aW50MzJcIjpbXSxcbiAgXCJhcnJheVwiOltdLFxuICBcInVpbnQ4X2NsYW1wZWRcIjpbXSxcbiAgXCJidWZmZXJcIjpbXSxcbiAgXCJnZW5lcmljXCI6W11cbn1cblxuOyhmdW5jdGlvbigpIHtcbiAgZm9yKHZhciBpZCBpbiBDQUNIRURfQ09OU1RSVUNUT1JTKSB7XG4gICAgQ0FDSEVEX0NPTlNUUlVDVE9SU1tpZF0ucHVzaChjb21waWxlQ29uc3RydWN0b3IoaWQsIC0xKSlcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIHdyYXBwZWROREFycmF5Q3RvcihkYXRhLCBzaGFwZSwgc3RyaWRlLCBvZmZzZXQpIHtcbiAgaWYoZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIGN0b3IgPSBDQUNIRURfQ09OU1RSVUNUT1JTLmFycmF5WzBdXG4gICAgcmV0dXJuIGN0b3IoW10pXG4gIH0gZWxzZSBpZih0eXBlb2YgZGF0YSA9PT0gXCJudW1iZXJcIikge1xuICAgIGRhdGEgPSBbZGF0YV1cbiAgfVxuICBpZihzaGFwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc2hhcGUgPSBbIGRhdGEubGVuZ3RoIF1cbiAgfVxuICB2YXIgZCA9IHNoYXBlLmxlbmd0aFxuICBpZihzdHJpZGUgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0cmlkZSA9IG5ldyBBcnJheShkKVxuICAgIGZvcih2YXIgaT1kLTEsIHN6PTE7IGk+PTA7IC0taSkge1xuICAgICAgc3RyaWRlW2ldID0gc3pcbiAgICAgIHN6ICo9IHNoYXBlW2ldXG4gICAgfVxuICB9XG4gIGlmKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgb2Zmc2V0ID0gMFxuICAgIGZvcih2YXIgaT0wOyBpPGQ7ICsraSkge1xuICAgICAgaWYoc3RyaWRlW2ldIDwgMCkge1xuICAgICAgICBvZmZzZXQgLT0gKHNoYXBlW2ldLTEpKnN0cmlkZVtpXVxuICAgICAgfVxuICAgIH1cbiAgfVxuICB2YXIgZHR5cGUgPSBhcnJheURUeXBlKGRhdGEpXG4gIHZhciBjdG9yX2xpc3QgPSBDQUNIRURfQ09OU1RSVUNUT1JTW2R0eXBlXVxuICB3aGlsZShjdG9yX2xpc3QubGVuZ3RoIDw9IGQrMSkge1xuICAgIGN0b3JfbGlzdC5wdXNoKGNvbXBpbGVDb25zdHJ1Y3RvcihkdHlwZSwgY3Rvcl9saXN0Lmxlbmd0aC0xKSlcbiAgfVxuICB2YXIgY3RvciA9IGN0b3JfbGlzdFtkKzFdXG4gIHJldHVybiBjdG9yKGRhdGEsIHNoYXBlLCBzdHJpZGUsIG9mZnNldClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB3cmFwcGVkTkRBcnJheUN0b3Jcbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcikiLCJtb2R1bGUuZXhwb3J0cz1yZXF1aXJlKFwiL3Byb2plY3RzL2JsYWNraWNlL25vZGVfbW9kdWxlcy9nbC10ZXh0dXJlMmQvbm9kZV9tb2R1bGVzL25kYXJyYXkvbm9kZV9tb2R1bGVzL2lvdGEtYXJyYXkvaW90YS5qc1wiKSIsIm1vZHVsZS5leHBvcnRzPXJlcXVpcmUoXCIvcHJvamVjdHMvYmxhY2tpY2Uvbm9kZV9tb2R1bGVzL2dsLXRleHR1cmUyZC9ub2RlX21vZHVsZXMvdHlwZWRhcnJheS1wb29sL3Bvb2wuanNcIikiLCIvLyBDb3B5cmlnaHQgKEMpIDIwMTEgR29vZ2xlIEluYy5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IEluc3RhbGwgYSBsZWFreSBXZWFrTWFwIGVtdWxhdGlvbiBvbiBwbGF0Zm9ybXMgdGhhdFxuICogZG9uJ3QgcHJvdmlkZSBhIGJ1aWx0LWluIG9uZS5cbiAqXG4gKiA8cD5Bc3N1bWVzIHRoYXQgYW4gRVM1IHBsYXRmb3JtIHdoZXJlLCBpZiB7QGNvZGUgV2Vha01hcH0gaXNcbiAqIGFscmVhZHkgcHJlc2VudCwgdGhlbiBpdCBjb25mb3JtcyB0byB0aGUgYW50aWNpcGF0ZWQgRVM2XG4gKiBzcGVjaWZpY2F0aW9uLiBUbyBydW4gdGhpcyBmaWxlIG9uIGFuIEVTNSBvciBhbG1vc3QgRVM1XG4gKiBpbXBsZW1lbnRhdGlvbiB3aGVyZSB0aGUge0Bjb2RlIFdlYWtNYXB9IHNwZWNpZmljYXRpb24gZG9lcyBub3RcbiAqIHF1aXRlIGNvbmZvcm0sIHJ1biA8Y29kZT5yZXBhaXJFUzUuanM8L2NvZGU+IGZpcnN0LlxuICpcbiAqIDxwPkV2ZW4gdGhvdWdoIFdlYWtNYXBNb2R1bGUgaXMgbm90IGdsb2JhbCwgdGhlIGxpbnRlciB0aGlua3MgaXRcbiAqIGlzLCB3aGljaCBpcyB3aHkgaXQgaXMgaW4gdGhlIG92ZXJyaWRlcyBsaXN0IGJlbG93LlxuICpcbiAqIDxwPk5PVEU6IEJlZm9yZSB1c2luZyB0aGlzIFdlYWtNYXAgZW11bGF0aW9uIGluIGEgbm9uLVNFU1xuICogZW52aXJvbm1lbnQsIHNlZSB0aGUgbm90ZSBiZWxvdyBhYm91dCBoaWRkZW5SZWNvcmQuXG4gKlxuICogQGF1dGhvciBNYXJrIFMuIE1pbGxlclxuICogQHJlcXVpcmVzIGNyeXB0bywgQXJyYXlCdWZmZXIsIFVpbnQ4QXJyYXksIG5hdmlnYXRvciwgY29uc29sZVxuICogQG92ZXJyaWRlcyBXZWFrTWFwLCBzZXMsIFByb3h5XG4gKiBAb3ZlcnJpZGVzIFdlYWtNYXBNb2R1bGVcbiAqL1xuXG4vKipcbiAqIFRoaXMge0Bjb2RlIFdlYWtNYXB9IGVtdWxhdGlvbiBpcyBvYnNlcnZhYmx5IGVxdWl2YWxlbnQgdG8gdGhlXG4gKiBFUy1IYXJtb255IFdlYWtNYXAsIGJ1dCB3aXRoIGxlYWtpZXIgZ2FyYmFnZSBjb2xsZWN0aW9uIHByb3BlcnRpZXMuXG4gKlxuICogPHA+QXMgd2l0aCB0cnVlIFdlYWtNYXBzLCBpbiB0aGlzIGVtdWxhdGlvbiwgYSBrZXkgZG9lcyBub3RcbiAqIHJldGFpbiBtYXBzIGluZGV4ZWQgYnkgdGhhdCBrZXkgYW5kIChjcnVjaWFsbHkpIGEgbWFwIGRvZXMgbm90XG4gKiByZXRhaW4gdGhlIGtleXMgaXQgaW5kZXhlcy4gQSBtYXAgYnkgaXRzZWxmIGFsc28gZG9lcyBub3QgcmV0YWluXG4gKiB0aGUgdmFsdWVzIGFzc29jaWF0ZWQgd2l0aCB0aGF0IG1hcC5cbiAqXG4gKiA8cD5Ib3dldmVyLCB0aGUgdmFsdWVzIGFzc29jaWF0ZWQgd2l0aCBhIGtleSBpbiBzb21lIG1hcCBhcmVcbiAqIHJldGFpbmVkIHNvIGxvbmcgYXMgdGhhdCBrZXkgaXMgcmV0YWluZWQgYW5kIHRob3NlIGFzc29jaWF0aW9ucyBhcmVcbiAqIG5vdCBvdmVycmlkZGVuLiBGb3IgZXhhbXBsZSwgd2hlbiB1c2VkIHRvIHN1cHBvcnQgbWVtYnJhbmVzLCBhbGxcbiAqIHZhbHVlcyBleHBvcnRlZCBmcm9tIGEgZ2l2ZW4gbWVtYnJhbmUgd2lsbCBsaXZlIGZvciB0aGUgbGlmZXRpbWVcbiAqIHRoZXkgd291bGQgaGF2ZSBoYWQgaW4gdGhlIGFic2VuY2Ugb2YgYW4gaW50ZXJwb3NlZCBtZW1icmFuZS4gRXZlblxuICogd2hlbiB0aGUgbWVtYnJhbmUgaXMgcmV2b2tlZCwgYWxsIG9iamVjdHMgdGhhdCB3b3VsZCBoYXZlIGJlZW5cbiAqIHJlYWNoYWJsZSBpbiB0aGUgYWJzZW5jZSBvZiByZXZvY2F0aW9uIHdpbGwgc3RpbGwgYmUgcmVhY2hhYmxlLCBhc1xuICogZmFyIGFzIHRoZSBHQyBjYW4gdGVsbCwgZXZlbiB0aG91Z2ggdGhleSB3aWxsIG5vIGxvbmdlciBiZSByZWxldmFudFxuICogdG8gb25nb2luZyBjb21wdXRhdGlvbi5cbiAqXG4gKiA8cD5UaGUgQVBJIGltcGxlbWVudGVkIGhlcmUgaXMgYXBwcm94aW1hdGVseSB0aGUgQVBJIGFzIGltcGxlbWVudGVkXG4gKiBpbiBGRjYuMGExIGFuZCBhZ3JlZWQgdG8gYnkgTWFya00sIEFuZHJlYXMgR2FsLCBhbmQgRGF2ZSBIZXJtYW4sXG4gKiByYXRoZXIgdGhhbiB0aGUgb2ZmaWFsbHkgYXBwcm92ZWQgcHJvcG9zYWwgcGFnZS4gVE9ETyhlcmlnaHRzKTpcbiAqIHVwZ3JhZGUgdGhlIGVjbWFzY3JpcHQgV2Vha01hcCBwcm9wb3NhbCBwYWdlIHRvIGV4cGxhaW4gdGhpcyBBUElcbiAqIGNoYW5nZSBhbmQgcHJlc2VudCB0byBFY21hU2NyaXB0IGNvbW1pdHRlZSBmb3IgdGhlaXIgYXBwcm92YWwuXG4gKlxuICogPHA+VGhlIGZpcnN0IGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgZW11bGF0aW9uIGhlcmUgYW5kIHRoYXQgaW5cbiAqIEZGNi4wYTEgaXMgdGhlIHByZXNlbmNlIG9mIG5vbiBlbnVtZXJhYmxlIHtAY29kZSBnZXRfX18sIGhhc19fXyxcbiAqIHNldF9fXywgYW5kIGRlbGV0ZV9fX30gbWV0aG9kcyBvbiBXZWFrTWFwIGluc3RhbmNlcyB0byByZXByZXNlbnRcbiAqIHdoYXQgd291bGQgYmUgdGhlIGhpZGRlbiBpbnRlcm5hbCBwcm9wZXJ0aWVzIG9mIGEgcHJpbWl0aXZlXG4gKiBpbXBsZW1lbnRhdGlvbi4gV2hlcmVhcyB0aGUgRkY2LjBhMSBXZWFrTWFwLnByb3RvdHlwZSBtZXRob2RzXG4gKiByZXF1aXJlIHRoZWlyIHtAY29kZSB0aGlzfSB0byBiZSBhIGdlbnVpbmUgV2Vha01hcCBpbnN0YW5jZSAoaS5lLixcbiAqIGFuIG9iamVjdCBvZiB7QGNvZGUgW1tDbGFzc11dfSBcIldlYWtNYXB9KSwgc2luY2UgdGhlcmUgaXMgbm90aGluZ1xuICogdW5mb3JnZWFibGUgYWJvdXQgdGhlIHBzZXVkby1pbnRlcm5hbCBtZXRob2QgbmFtZXMgdXNlZCBoZXJlLFxuICogbm90aGluZyBwcmV2ZW50cyB0aGVzZSBlbXVsYXRlZCBwcm90b3R5cGUgbWV0aG9kcyBmcm9tIGJlaW5nXG4gKiBhcHBsaWVkIHRvIG5vbi1XZWFrTWFwcyB3aXRoIHBzZXVkby1pbnRlcm5hbCBtZXRob2RzIG9mIHRoZSBzYW1lXG4gKiBuYW1lcy5cbiAqXG4gKiA8cD5Bbm90aGVyIGRpZmZlcmVuY2UgaXMgdGhhdCBvdXIgZW11bGF0ZWQge0Bjb2RlXG4gKiBXZWFrTWFwLnByb3RvdHlwZX0gaXMgbm90IGl0c2VsZiBhIFdlYWtNYXAuIEEgcHJvYmxlbSB3aXRoIHRoZVxuICogY3VycmVudCBGRjYuMGExIEFQSSBpcyB0aGF0IFdlYWtNYXAucHJvdG90eXBlIGlzIGl0c2VsZiBhIFdlYWtNYXBcbiAqIHByb3ZpZGluZyBhbWJpZW50IG11dGFiaWxpdHkgYW5kIGFuIGFtYmllbnQgY29tbXVuaWNhdGlvbnNcbiAqIGNoYW5uZWwuIFRodXMsIGlmIGEgV2Vha01hcCBpcyBhbHJlYWR5IHByZXNlbnQgYW5kIGhhcyB0aGlzXG4gKiBwcm9ibGVtLCByZXBhaXJFUzUuanMgd3JhcHMgaXQgaW4gYSBzYWZlIHdyYXBwcGVyIGluIG9yZGVyIHRvXG4gKiBwcmV2ZW50IGFjY2VzcyB0byB0aGlzIGNoYW5uZWwuIChTZWVcbiAqIFBBVENIX01VVEFCTEVfRlJPWkVOX1dFQUtNQVBfUFJPVE8gaW4gcmVwYWlyRVM1LmpzKS5cbiAqL1xuXG4vKipcbiAqIElmIHRoaXMgaXMgYSBmdWxsIDxhIGhyZWY9XG4gKiBcImh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9lcy1sYWIvd2lraS9TZWN1cmVhYmxlRVM1XCJcbiAqID5zZWN1cmVhYmxlIEVTNTwvYT4gcGxhdGZvcm0gYW5kIHRoZSBFUy1IYXJtb255IHtAY29kZSBXZWFrTWFwfSBpc1xuICogYWJzZW50LCBpbnN0YWxsIGFuIGFwcHJveGltYXRlIGVtdWxhdGlvbi5cbiAqXG4gKiA8cD5JZiBXZWFrTWFwIGlzIHByZXNlbnQgYnV0IGNhbm5vdCBzdG9yZSBzb21lIG9iamVjdHMsIHVzZSBvdXIgYXBwcm94aW1hdGVcbiAqIGVtdWxhdGlvbiBhcyBhIHdyYXBwZXIuXG4gKlxuICogPHA+SWYgdGhpcyBpcyBhbG1vc3QgYSBzZWN1cmVhYmxlIEVTNSBwbGF0Zm9ybSwgdGhlbiBXZWFrTWFwLmpzXG4gKiBzaG91bGQgYmUgcnVuIGFmdGVyIHJlcGFpckVTNS5qcy5cbiAqXG4gKiA8cD5TZWUge0Bjb2RlIFdlYWtNYXB9IGZvciBkb2N1bWVudGF0aW9uIG9mIHRoZSBnYXJiYWdlIGNvbGxlY3Rpb25cbiAqIHByb3BlcnRpZXMgb2YgdGhpcyBXZWFrTWFwIGVtdWxhdGlvbi5cbiAqL1xuKGZ1bmN0aW9uIFdlYWtNYXBNb2R1bGUoKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIGlmICh0eXBlb2Ygc2VzICE9PSAndW5kZWZpbmVkJyAmJiBzZXMub2sgJiYgIXNlcy5vaygpKSB7XG4gICAgLy8gYWxyZWFkeSB0b28gYnJva2VuLCBzbyBnaXZlIHVwXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLyoqXG4gICAqIEluIHNvbWUgY2FzZXMgKGN1cnJlbnQgRmlyZWZveCksIHdlIG11c3QgbWFrZSBhIGNob2ljZSBiZXR3ZWVlbiBhXG4gICAqIFdlYWtNYXAgd2hpY2ggaXMgY2FwYWJsZSBvZiB1c2luZyBhbGwgdmFyaWV0aWVzIG9mIGhvc3Qgb2JqZWN0cyBhc1xuICAgKiBrZXlzIGFuZCBvbmUgd2hpY2ggaXMgY2FwYWJsZSBvZiBzYWZlbHkgdXNpbmcgcHJveGllcyBhcyBrZXlzLiBTZWVcbiAgICogY29tbWVudHMgYmVsb3cgYWJvdXQgSG9zdFdlYWtNYXAgYW5kIERvdWJsZVdlYWtNYXAgZm9yIGRldGFpbHMuXG4gICAqXG4gICAqIFRoaXMgZnVuY3Rpb24gKHdoaWNoIGlzIGEgZ2xvYmFsLCBub3QgZXhwb3NlZCB0byBndWVzdHMpIG1hcmtzIGFcbiAgICogV2Vha01hcCBhcyBwZXJtaXR0ZWQgdG8gZG8gd2hhdCBpcyBuZWNlc3NhcnkgdG8gaW5kZXggYWxsIGhvc3RcbiAgICogb2JqZWN0cywgYXQgdGhlIGNvc3Qgb2YgbWFraW5nIGl0IHVuc2FmZSBmb3IgcHJveGllcy5cbiAgICpcbiAgICogRG8gbm90IGFwcGx5IHRoaXMgZnVuY3Rpb24gdG8gYW55dGhpbmcgd2hpY2ggaXMgbm90IGEgZ2VudWluZVxuICAgKiBmcmVzaCBXZWFrTWFwLlxuICAgKi9cbiAgZnVuY3Rpb24gd2Vha01hcFBlcm1pdEhvc3RPYmplY3RzKG1hcCkge1xuICAgIC8vIGlkZW50aXR5IG9mIGZ1bmN0aW9uIHVzZWQgYXMgYSBzZWNyZXQgLS0gZ29vZCBlbm91Z2ggYW5kIGNoZWFwXG4gICAgaWYgKG1hcC5wZXJtaXRIb3N0T2JqZWN0c19fXykge1xuICAgICAgbWFwLnBlcm1pdEhvc3RPYmplY3RzX19fKHdlYWtNYXBQZXJtaXRIb3N0T2JqZWN0cyk7XG4gICAgfVxuICB9XG4gIGlmICh0eXBlb2Ygc2VzICE9PSAndW5kZWZpbmVkJykge1xuICAgIHNlcy53ZWFrTWFwUGVybWl0SG9zdE9iamVjdHMgPSB3ZWFrTWFwUGVybWl0SG9zdE9iamVjdHM7XG4gIH1cblxuICAvLyBJRSAxMSBoYXMgbm8gUHJveHkgYnV0IGhhcyBhIGJyb2tlbiBXZWFrTWFwIHN1Y2ggdGhhdCB3ZSBuZWVkIHRvIHBhdGNoXG4gIC8vIGl0IHVzaW5nIERvdWJsZVdlYWtNYXA7IHRoaXMgZmxhZyB0ZWxscyBEb3VibGVXZWFrTWFwIHNvLlxuICB2YXIgZG91YmxlV2Vha01hcENoZWNrU2lsZW50RmFpbHVyZSA9IGZhbHNlO1xuXG4gIC8vIENoZWNrIGlmIHRoZXJlIGlzIGFscmVhZHkgYSBnb29kLWVub3VnaCBXZWFrTWFwIGltcGxlbWVudGF0aW9uLCBhbmQgaWYgc29cbiAgLy8gZXhpdCB3aXRob3V0IHJlcGxhY2luZyBpdC5cbiAgaWYgKHR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIEhvc3RXZWFrTWFwID0gV2Vha01hcDtcbiAgICAvLyBUaGVyZSBpcyBhIFdlYWtNYXAgLS0gaXMgaXQgZ29vZCBlbm91Z2g/XG4gICAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIC9GaXJlZm94Ly50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpKSB7XG4gICAgICAvLyBXZSdyZSBub3cgKmFzc3VtaW5nIG5vdCosIGJlY2F1c2UgYXMgb2YgdGhpcyB3cml0aW5nICgyMDEzLTA1LTA2KVxuICAgICAgLy8gRmlyZWZveCdzIFdlYWtNYXBzIGhhdmUgYSBtaXNjZWxsYW55IG9mIG9iamVjdHMgdGhleSB3b24ndCBhY2NlcHQsIGFuZFxuICAgICAgLy8gd2UgZG9uJ3Qgd2FudCB0byBtYWtlIGFuIGV4aGF1c3RpdmUgbGlzdCwgYW5kIHRlc3RpbmcgZm9yIGp1c3Qgb25lXG4gICAgICAvLyB3aWxsIGJlIGEgcHJvYmxlbSBpZiB0aGF0IG9uZSBpcyBmaXhlZCBhbG9uZSAoYXMgdGhleSBkaWQgZm9yIEV2ZW50KS5cblxuICAgICAgLy8gSWYgdGhlcmUgaXMgYSBwbGF0Zm9ybSB0aGF0IHdlICpjYW4qIHJlbGlhYmx5IHRlc3Qgb24sIGhlcmUncyBob3cgdG9cbiAgICAgIC8vIGRvIGl0OlxuICAgICAgLy8gIHZhciBwcm9ibGVtYXRpYyA9IC4uLiA7XG4gICAgICAvLyAgdmFyIHRlc3RIb3N0TWFwID0gbmV3IEhvc3RXZWFrTWFwKCk7XG4gICAgICAvLyAgdHJ5IHtcbiAgICAgIC8vICAgIHRlc3RIb3N0TWFwLnNldChwcm9ibGVtYXRpYywgMSk7ICAvLyBGaXJlZm94IDIwIHdpbGwgdGhyb3cgaGVyZVxuICAgICAgLy8gICAgaWYgKHRlc3RIb3N0TWFwLmdldChwcm9ibGVtYXRpYykgPT09IDEpIHtcbiAgICAgIC8vICAgICAgcmV0dXJuO1xuICAgICAgLy8gICAgfVxuICAgICAgLy8gIH0gY2F0Y2ggKGUpIHt9XG5cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSUUgMTEgYnVnOiBXZWFrTWFwcyBzaWxlbnRseSBmYWlsIHRvIHN0b3JlIGZyb3plbiBvYmplY3RzLlxuICAgICAgdmFyIHRlc3RNYXAgPSBuZXcgSG9zdFdlYWtNYXAoKTtcbiAgICAgIHZhciB0ZXN0T2JqZWN0ID0gT2JqZWN0LmZyZWV6ZSh7fSk7XG4gICAgICB0ZXN0TWFwLnNldCh0ZXN0T2JqZWN0LCAxKTtcbiAgICAgIGlmICh0ZXN0TWFwLmdldCh0ZXN0T2JqZWN0KSAhPT0gMSkge1xuICAgICAgICBkb3VibGVXZWFrTWFwQ2hlY2tTaWxlbnRGYWlsdXJlID0gdHJ1ZTtcbiAgICAgICAgLy8gRmFsbCB0aHJvdWdoIHRvIGluc3RhbGxpbmcgb3VyIFdlYWtNYXAuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IFdlYWtNYXA7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgaG9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbiAgdmFyIGdvcG4gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbiAgdmFyIGRlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG4gIHZhciBpc0V4dGVuc2libGUgPSBPYmplY3QuaXNFeHRlbnNpYmxlO1xuXG4gIC8qKlxuICAgKiBTZWN1cml0eSBkZXBlbmRzIG9uIEhJRERFTl9OQU1FIGJlaW5nIGJvdGggPGk+dW5ndWVzc2FibGU8L2k+IGFuZFxuICAgKiA8aT51bmRpc2NvdmVyYWJsZTwvaT4gYnkgdW50cnVzdGVkIGNvZGUuXG4gICAqXG4gICAqIDxwPkdpdmVuIHRoZSBrbm93biB3ZWFrbmVzc2VzIG9mIE1hdGgucmFuZG9tKCkgb24gZXhpc3RpbmdcbiAgICogYnJvd3NlcnMsIGl0IGRvZXMgbm90IGdlbmVyYXRlIHVuZ3Vlc3NhYmlsaXR5IHdlIGNhbiBiZSBjb25maWRlbnRcbiAgICogb2YuXG4gICAqXG4gICAqIDxwPkl0IGlzIHRoZSBtb25rZXkgcGF0Y2hpbmcgbG9naWMgaW4gdGhpcyBmaWxlIHRoYXQgaXMgaW50ZW5kZWRcbiAgICogdG8gZW5zdXJlIHVuZGlzY292ZXJhYmlsaXR5LiBUaGUgYmFzaWMgaWRlYSBpcyB0aGF0IHRoZXJlIGFyZVxuICAgKiB0aHJlZSBmdW5kYW1lbnRhbCBtZWFucyBvZiBkaXNjb3ZlcmluZyBwcm9wZXJ0aWVzIG9mIGFuIG9iamVjdDpcbiAgICogVGhlIGZvci9pbiBsb29wLCBPYmplY3Qua2V5cygpLCBhbmQgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoKSxcbiAgICogYXMgd2VsbCBhcyBzb21lIHByb3Bvc2VkIEVTNiBleHRlbnNpb25zIHRoYXQgYXBwZWFyIG9uIG91clxuICAgKiB3aGl0ZWxpc3QuIFRoZSBmaXJzdCB0d28gb25seSBkaXNjb3ZlciBlbnVtZXJhYmxlIHByb3BlcnRpZXMsIGFuZFxuICAgKiB3ZSBvbmx5IHVzZSBISURERU5fTkFNRSB0byBuYW1lIGEgbm9uLWVudW1lcmFibGUgcHJvcGVydHksIHNvIHRoZVxuICAgKiBvbmx5IHJlbWFpbmluZyB0aHJlYXQgc2hvdWxkIGJlIGdldE93blByb3BlcnR5TmFtZXMgYW5kIHNvbWVcbiAgICogcHJvcG9zZWQgRVM2IGV4dGVuc2lvbnMgdGhhdCBhcHBlYXIgb24gb3VyIHdoaXRlbGlzdC4gV2UgbW9ua2V5XG4gICAqIHBhdGNoIHRoZW0gdG8gcmVtb3ZlIEhJRERFTl9OQU1FIGZyb20gdGhlIGxpc3Qgb2YgcHJvcGVydGllcyB0aGV5XG4gICAqIHJldHVybnMuXG4gICAqXG4gICAqIDxwPlRPRE8oZXJpZ2h0cyk6IE9uIGEgcGxhdGZvcm0gd2l0aCBidWlsdC1pbiBQcm94aWVzLCBwcm94aWVzXG4gICAqIGNvdWxkIGJlIHVzZWQgdG8gdHJhcCBhbmQgdGhlcmVieSBkaXNjb3ZlciB0aGUgSElEREVOX05BTUUsIHNvIHdlXG4gICAqIG5lZWQgdG8gbW9ua2V5IHBhdGNoIFByb3h5LmNyZWF0ZSwgUHJveHkuY3JlYXRlRnVuY3Rpb24sIGV0YywgaW5cbiAgICogb3JkZXIgdG8gd3JhcCB0aGUgcHJvdmlkZWQgaGFuZGxlciB3aXRoIHRoZSByZWFsIGhhbmRsZXIgd2hpY2hcbiAgICogZmlsdGVycyBvdXQgYWxsIHRyYXBzIHVzaW5nIEhJRERFTl9OQU1FLlxuICAgKlxuICAgKiA8cD5UT0RPKGVyaWdodHMpOiBSZXZpc2l0IE1pa2UgU3RheSdzIHN1Z2dlc3Rpb24gdGhhdCB3ZSB1c2UgYW5cbiAgICogZW5jYXBzdWxhdGVkIGZ1bmN0aW9uIGF0IGEgbm90LW5lY2Vzc2FyaWx5LXNlY3JldCBuYW1lLCB3aGljaFxuICAgKiB1c2VzIHRoZSBTdGllZ2xlciBzaGFyZWQtc3RhdGUgcmlnaHRzIGFtcGxpZmljYXRpb24gcGF0dGVybiB0b1xuICAgKiByZXZlYWwgdGhlIGFzc29jaWF0ZWQgdmFsdWUgb25seSB0byB0aGUgV2Vha01hcCBpbiB3aGljaCB0aGlzIGtleVxuICAgKiBpcyBhc3NvY2lhdGVkIHdpdGggdGhhdCB2YWx1ZS4gU2luY2Ugb25seSB0aGUga2V5IHJldGFpbnMgdGhlXG4gICAqIGZ1bmN0aW9uLCB0aGUgZnVuY3Rpb24gY2FuIGFsc28gcmVtZW1iZXIgdGhlIGtleSB3aXRob3V0IGNhdXNpbmdcbiAgICogbGVha2FnZSBvZiB0aGUga2V5LCBzbyB0aGlzIGRvZXNuJ3QgdmlvbGF0ZSBvdXIgZ2VuZXJhbCBnY1xuICAgKiBnb2Fscy4gSW4gYWRkaXRpb24sIGJlY2F1c2UgdGhlIG5hbWUgbmVlZCBub3QgYmUgYSBndWFyZGVkXG4gICAqIHNlY3JldCwgd2UgY291bGQgZWZmaWNpZW50bHkgaGFuZGxlIGNyb3NzLWZyYW1lIGZyb3plbiBrZXlzLlxuICAgKi9cbiAgdmFyIEhJRERFTl9OQU1FX1BSRUZJWCA9ICd3ZWFrbWFwOic7XG4gIHZhciBISURERU5fTkFNRSA9IEhJRERFTl9OQU1FX1BSRUZJWCArICdpZGVudDonICsgTWF0aC5yYW5kb20oKSArICdfX18nO1xuXG4gIGlmICh0eXBlb2YgY3J5cHRvICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgdHlwZW9mIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgIHR5cGVvZiBBcnJheUJ1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgdHlwZW9mIFVpbnQ4QXJyYXkgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgYWIgPSBuZXcgQXJyYXlCdWZmZXIoMjUpO1xuICAgIHZhciB1OHMgPSBuZXcgVWludDhBcnJheShhYik7XG4gICAgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyh1OHMpO1xuICAgIEhJRERFTl9OQU1FID0gSElEREVOX05BTUVfUFJFRklYICsgJ3JhbmQ6JyArXG4gICAgICBBcnJheS5wcm90b3R5cGUubWFwLmNhbGwodThzLCBmdW5jdGlvbih1OCkge1xuICAgICAgICByZXR1cm4gKHU4ICUgMzYpLnRvU3RyaW5nKDM2KTtcbiAgICAgIH0pLmpvaW4oJycpICsgJ19fXyc7XG4gIH1cblxuICBmdW5jdGlvbiBpc05vdEhpZGRlbk5hbWUobmFtZSkge1xuICAgIHJldHVybiAhKFxuICAgICAgICBuYW1lLnN1YnN0cigwLCBISURERU5fTkFNRV9QUkVGSVgubGVuZ3RoKSA9PSBISURERU5fTkFNRV9QUkVGSVggJiZcbiAgICAgICAgbmFtZS5zdWJzdHIobmFtZS5sZW5ndGggLSAzKSA9PT0gJ19fXycpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1vbmtleSBwYXRjaCBnZXRPd25Qcm9wZXJ0eU5hbWVzIHRvIGF2b2lkIHJldmVhbGluZyB0aGVcbiAgICogSElEREVOX05BTUUuXG4gICAqXG4gICAqIDxwPlRoZSBFUzUuMSBzcGVjIHJlcXVpcmVzIGVhY2ggbmFtZSB0byBhcHBlYXIgb25seSBvbmNlLCBidXQgYXNcbiAgICogb2YgdGhpcyB3cml0aW5nLCB0aGlzIHJlcXVpcmVtZW50IGlzIGNvbnRyb3ZlcnNpYWwgZm9yIEVTNiwgc28gd2VcbiAgICogbWFkZSB0aGlzIGNvZGUgcm9idXN0IGFnYWluc3QgdGhpcyBjYXNlLiBJZiB0aGUgcmVzdWx0aW5nIGV4dHJhXG4gICAqIHNlYXJjaCB0dXJucyBvdXQgdG8gYmUgZXhwZW5zaXZlLCB3ZSBjYW4gcHJvYmFibHkgcmVsYXggdGhpcyBvbmNlXG4gICAqIEVTNiBpcyBhZGVxdWF0ZWx5IHN1cHBvcnRlZCBvbiBhbGwgbWFqb3IgYnJvd3NlcnMsIGlmZiBubyBicm93c2VyXG4gICAqIHZlcnNpb25zIHdlIHN1cHBvcnQgYXQgdGhhdCB0aW1lIGhhdmUgcmVsYXhlZCB0aGlzIGNvbnN0cmFpbnRcbiAgICogd2l0aG91dCBwcm92aWRpbmcgYnVpbHQtaW4gRVM2IFdlYWtNYXBzLlxuICAgKi9cbiAgZGVmUHJvcChPYmplY3QsICdnZXRPd25Qcm9wZXJ0eU5hbWVzJywge1xuICAgIHZhbHVlOiBmdW5jdGlvbiBmYWtlR2V0T3duUHJvcGVydHlOYW1lcyhvYmopIHtcbiAgICAgIHJldHVybiBnb3BuKG9iaikuZmlsdGVyKGlzTm90SGlkZGVuTmFtZSk7XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogZ2V0UHJvcGVydHlOYW1lcyBpcyBub3QgaW4gRVM1IGJ1dCBpdCBpcyBwcm9wb3NlZCBmb3IgRVM2IGFuZFxuICAgKiBkb2VzIGFwcGVhciBpbiBvdXIgd2hpdGVsaXN0LCBzbyB3ZSBuZWVkIHRvIGNsZWFuIGl0IHRvby5cbiAgICovXG4gIGlmICgnZ2V0UHJvcGVydHlOYW1lcycgaW4gT2JqZWN0KSB7XG4gICAgdmFyIG9yaWdpbmFsR2V0UHJvcGVydHlOYW1lcyA9IE9iamVjdC5nZXRQcm9wZXJ0eU5hbWVzO1xuICAgIGRlZlByb3AoT2JqZWN0LCAnZ2V0UHJvcGVydHlOYW1lcycsIHtcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBmYWtlR2V0UHJvcGVydHlOYW1lcyhvYmopIHtcbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsR2V0UHJvcGVydHlOYW1lcyhvYmopLmZpbHRlcihpc05vdEhpZGRlbk5hbWUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIDxwPlRvIHRyZWF0IG9iamVjdHMgYXMgaWRlbnRpdHkta2V5cyB3aXRoIHJlYXNvbmFibGUgZWZmaWNpZW5jeVxuICAgKiBvbiBFUzUgYnkgaXRzZWxmIChpLmUuLCB3aXRob3V0IGFueSBvYmplY3Qta2V5ZWQgY29sbGVjdGlvbnMpLCB3ZVxuICAgKiBuZWVkIHRvIGFkZCBhIGhpZGRlbiBwcm9wZXJ0eSB0byBzdWNoIGtleSBvYmplY3RzIHdoZW4gd2VcbiAgICogY2FuLiBUaGlzIHJhaXNlcyBzZXZlcmFsIGlzc3VlczpcbiAgICogPHVsPlxuICAgKiA8bGk+QXJyYW5naW5nIHRvIGFkZCB0aGlzIHByb3BlcnR5IHRvIG9iamVjdHMgYmVmb3JlIHdlIGxvc2UgdGhlXG4gICAqICAgICBjaGFuY2UsIGFuZFxuICAgKiA8bGk+SGlkaW5nIHRoZSBleGlzdGVuY2Ugb2YgdGhpcyBuZXcgcHJvcGVydHkgZnJvbSBtb3N0XG4gICAqICAgICBKYXZhU2NyaXB0IGNvZGUuXG4gICAqIDxsaT5QcmV2ZW50aW5nIDxpPmNlcnRpZmljYXRpb24gdGhlZnQ8L2k+LCB3aGVyZSBvbmUgb2JqZWN0IGlzXG4gICAqICAgICBjcmVhdGVkIGZhbHNlbHkgY2xhaW1pbmcgdG8gYmUgdGhlIGtleSBvZiBhbiBhc3NvY2lhdGlvblxuICAgKiAgICAgYWN0dWFsbHkga2V5ZWQgYnkgYW5vdGhlciBvYmplY3QuXG4gICAqIDxsaT5QcmV2ZW50aW5nIDxpPnZhbHVlIHRoZWZ0PC9pPiwgd2hlcmUgdW50cnVzdGVkIGNvZGUgd2l0aFxuICAgKiAgICAgYWNjZXNzIHRvIGEga2V5IG9iamVjdCBidXQgbm90IGEgd2VhayBtYXAgbmV2ZXJ0aGVsZXNzXG4gICAqICAgICBvYnRhaW5zIGFjY2VzcyB0byB0aGUgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIHRoYXQga2V5IGluIHRoYXRcbiAgICogICAgIHdlYWsgbWFwLlxuICAgKiA8L3VsPlxuICAgKiBXZSBkbyBzbyBieVxuICAgKiA8dWw+XG4gICAqIDxsaT5NYWtpbmcgdGhlIG5hbWUgb2YgdGhlIGhpZGRlbiBwcm9wZXJ0eSB1bmd1ZXNzYWJsZSwgc28gXCJbXVwiXG4gICAqICAgICBpbmRleGluZywgd2hpY2ggd2UgY2Fubm90IGludGVyY2VwdCwgY2Fubm90IGJlIHVzZWQgdG8gYWNjZXNzXG4gICAqICAgICBhIHByb3BlcnR5IHdpdGhvdXQga25vd2luZyB0aGUgbmFtZS5cbiAgICogPGxpPk1ha2luZyB0aGUgaGlkZGVuIHByb3BlcnR5IG5vbi1lbnVtZXJhYmxlLCBzbyB3ZSBuZWVkIG5vdFxuICAgKiAgICAgd29ycnkgYWJvdXQgZm9yLWluIGxvb3BzIG9yIHtAY29kZSBPYmplY3Qua2V5c30sXG4gICAqIDxsaT5tb25rZXkgcGF0Y2hpbmcgdGhvc2UgcmVmbGVjdGl2ZSBtZXRob2RzIHRoYXQgd291bGRcbiAgICogICAgIHByZXZlbnQgZXh0ZW5zaW9ucywgdG8gYWRkIHRoaXMgaGlkZGVuIHByb3BlcnR5IGZpcnN0LFxuICAgKiA8bGk+bW9ua2V5IHBhdGNoaW5nIHRob3NlIG1ldGhvZHMgdGhhdCB3b3VsZCByZXZlYWwgdGhpc1xuICAgKiAgICAgaGlkZGVuIHByb3BlcnR5LlxuICAgKiA8L3VsPlxuICAgKiBVbmZvcnR1bmF0ZWx5LCBiZWNhdXNlIG9mIHNhbWUtb3JpZ2luIGlmcmFtZXMsIHdlIGNhbm5vdCByZWxpYWJseVxuICAgKiBhZGQgdGhpcyBoaWRkZW4gcHJvcGVydHkgYmVmb3JlIGFuIG9iamVjdCBiZWNvbWVzXG4gICAqIG5vbi1leHRlbnNpYmxlLiBJbnN0ZWFkLCBpZiB3ZSBlbmNvdW50ZXIgYSBub24tZXh0ZW5zaWJsZSBvYmplY3RcbiAgICogd2l0aG91dCBhIGhpZGRlbiByZWNvcmQgdGhhdCB3ZSBjYW4gZGV0ZWN0ICh3aGV0aGVyIG9yIG5vdCBpdCBoYXNcbiAgICogYSBoaWRkZW4gcmVjb3JkIHN0b3JlZCB1bmRlciBhIG5hbWUgc2VjcmV0IHRvIHVzKSwgdGhlbiB3ZSBqdXN0XG4gICAqIHVzZSB0aGUga2V5IG9iamVjdCBpdHNlbGYgdG8gcmVwcmVzZW50IGl0cyBpZGVudGl0eSBpbiBhIGJydXRlXG4gICAqIGZvcmNlIGxlYWt5IG1hcCBzdG9yZWQgaW4gdGhlIHdlYWsgbWFwLCBsb3NpbmcgYWxsIHRoZSBhZHZhbnRhZ2VzXG4gICAqIG9mIHdlYWtuZXNzIGZvciB0aGVzZS5cbiAgICovXG4gIGZ1bmN0aW9uIGdldEhpZGRlblJlY29yZChrZXkpIHtcbiAgICBpZiAoa2V5ICE9PSBPYmplY3Qoa2V5KSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTm90IGFuIG9iamVjdDogJyArIGtleSk7XG4gICAgfVxuICAgIHZhciBoaWRkZW5SZWNvcmQgPSBrZXlbSElEREVOX05BTUVdO1xuICAgIGlmIChoaWRkZW5SZWNvcmQgJiYgaGlkZGVuUmVjb3JkLmtleSA9PT0ga2V5KSB7IHJldHVybiBoaWRkZW5SZWNvcmQ7IH1cbiAgICBpZiAoIWlzRXh0ZW5zaWJsZShrZXkpKSB7XG4gICAgICAvLyBXZWFrIG1hcCBtdXN0IGJydXRlIGZvcmNlLCBhcyBleHBsYWluZWQgaW4gZG9jLWNvbW1lbnQgYWJvdmUuXG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cblxuICAgIC8vIFRoZSBoaWRkZW5SZWNvcmQgYW5kIHRoZSBrZXkgcG9pbnQgZGlyZWN0bHkgYXQgZWFjaCBvdGhlciwgdmlhXG4gICAgLy8gdGhlIFwia2V5XCIgYW5kIEhJRERFTl9OQU1FIHByb3BlcnRpZXMgcmVzcGVjdGl2ZWx5LiBUaGUga2V5XG4gICAgLy8gZmllbGQgaXMgZm9yIHF1aWNrbHkgdmVyaWZ5aW5nIHRoYXQgdGhpcyBoaWRkZW4gcmVjb3JkIGlzIGFuXG4gICAgLy8gb3duIHByb3BlcnR5LCBub3QgYSBoaWRkZW4gcmVjb3JkIGZyb20gdXAgdGhlIHByb3RvdHlwZSBjaGFpbi5cbiAgICAvL1xuICAgIC8vIE5PVEU6IEJlY2F1c2UgdGhpcyBXZWFrTWFwIGVtdWxhdGlvbiBpcyBtZWFudCBvbmx5IGZvciBzeXN0ZW1zIGxpa2VcbiAgICAvLyBTRVMgd2hlcmUgT2JqZWN0LnByb3RvdHlwZSBpcyBmcm96ZW4gd2l0aG91dCBhbnkgbnVtZXJpY1xuICAgIC8vIHByb3BlcnRpZXMsIGl0IGlzIG9rIHRvIHVzZSBhbiBvYmplY3QgbGl0ZXJhbCBmb3IgdGhlIGhpZGRlblJlY29yZC5cbiAgICAvLyBUaGlzIGhhcyB0d28gYWR2YW50YWdlczpcbiAgICAvLyAqIEl0IGlzIG11Y2ggZmFzdGVyIGluIGEgcGVyZm9ybWFuY2UgY3JpdGljYWwgcGxhY2VcbiAgICAvLyAqIEl0IGF2b2lkcyByZWx5aW5nIG9uIE9iamVjdC5jcmVhdGUobnVsbCksIHdoaWNoIGhhZCBiZWVuXG4gICAgLy8gICBwcm9ibGVtYXRpYyBvbiBDaHJvbWUgMjguMC4xNDgwLjAuIFNlZVxuICAgIC8vICAgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9nb29nbGUtY2FqYS9pc3N1ZXMvZGV0YWlsP2lkPTE2ODdcbiAgICBoaWRkZW5SZWNvcmQgPSB7IGtleToga2V5IH07XG5cbiAgICAvLyBXaGVuIHVzaW5nIHRoaXMgV2Vha01hcCBlbXVsYXRpb24gb24gcGxhdGZvcm1zIHdoZXJlXG4gICAgLy8gT2JqZWN0LnByb3RvdHlwZSBtaWdodCBub3QgYmUgZnJvemVuIGFuZCBPYmplY3QuY3JlYXRlKG51bGwpIGlzXG4gICAgLy8gcmVsaWFibGUsIHVzZSB0aGUgZm9sbG93aW5nIHR3byBjb21tZW50ZWQgb3V0IGxpbmVzIGluc3RlYWQuXG4gICAgLy8gaGlkZGVuUmVjb3JkID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAvLyBoaWRkZW5SZWNvcmQua2V5ID0ga2V5O1xuXG4gICAgLy8gUGxlYXNlIGNvbnRhY3QgdXMgaWYgeW91IG5lZWQgdGhpcyB0byB3b3JrIG9uIHBsYXRmb3JtcyB3aGVyZVxuICAgIC8vIE9iamVjdC5wcm90b3R5cGUgbWlnaHQgbm90IGJlIGZyb3plbiBhbmRcbiAgICAvLyBPYmplY3QuY3JlYXRlKG51bGwpIG1pZ2h0IG5vdCBiZSByZWxpYWJsZS5cblxuICAgIHRyeSB7XG4gICAgICBkZWZQcm9wKGtleSwgSElEREVOX05BTUUsIHtcbiAgICAgICAgdmFsdWU6IGhpZGRlblJlY29yZCxcbiAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gaGlkZGVuUmVjb3JkO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyBVbmRlciBzb21lIGNpcmN1bXN0YW5jZXMsIGlzRXh0ZW5zaWJsZSBzZWVtcyB0byBtaXNyZXBvcnQgd2hldGhlclxuICAgICAgLy8gdGhlIEhJRERFTl9OQU1FIGNhbiBiZSBkZWZpbmVkLlxuICAgICAgLy8gVGhlIGNpcmN1bXN0YW5jZXMgaGF2ZSBub3QgYmVlbiBpc29sYXRlZCwgYnV0IGF0IGxlYXN0IGFmZmVjdFxuICAgICAgLy8gTm9kZS5qcyB2MC4xMC4yNiBvbiBUcmF2aXNDSSAvIExpbnV4LCBidXQgbm90IHRoZSBzYW1lIHZlcnNpb24gb2ZcbiAgICAgIC8vIE5vZGUuanMgb24gT1MgWC5cbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE1vbmtleSBwYXRjaCBvcGVyYXRpb25zIHRoYXQgd291bGQgbWFrZSB0aGVpciBhcmd1bWVudFxuICAgKiBub24tZXh0ZW5zaWJsZS5cbiAgICpcbiAgICogPHA+VGhlIG1vbmtleSBwYXRjaGVkIHZlcnNpb25zIHRocm93IGEgVHlwZUVycm9yIGlmIHRoZWlyXG4gICAqIGFyZ3VtZW50IGlzIG5vdCBhbiBvYmplY3QsIHNvIGl0IHNob3VsZCBvbmx5IGJlIGRvbmUgdG8gZnVuY3Rpb25zXG4gICAqIHRoYXQgc2hvdWxkIHRocm93IGEgVHlwZUVycm9yIGFueXdheSBpZiB0aGVpciBhcmd1bWVudCBpcyBub3QgYW5cbiAgICogb2JqZWN0LlxuICAgKi9cbiAgKGZ1bmN0aW9uKCl7XG4gICAgdmFyIG9sZEZyZWV6ZSA9IE9iamVjdC5mcmVlemU7XG4gICAgZGVmUHJvcChPYmplY3QsICdmcmVlemUnLCB7XG4gICAgICB2YWx1ZTogZnVuY3Rpb24gaWRlbnRpZnlpbmdGcmVlemUob2JqKSB7XG4gICAgICAgIGdldEhpZGRlblJlY29yZChvYmopO1xuICAgICAgICByZXR1cm4gb2xkRnJlZXplKG9iaik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdmFyIG9sZFNlYWwgPSBPYmplY3Quc2VhbDtcbiAgICBkZWZQcm9wKE9iamVjdCwgJ3NlYWwnLCB7XG4gICAgICB2YWx1ZTogZnVuY3Rpb24gaWRlbnRpZnlpbmdTZWFsKG9iaikge1xuICAgICAgICBnZXRIaWRkZW5SZWNvcmQob2JqKTtcbiAgICAgICAgcmV0dXJuIG9sZFNlYWwob2JqKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB2YXIgb2xkUHJldmVudEV4dGVuc2lvbnMgPSBPYmplY3QucHJldmVudEV4dGVuc2lvbnM7XG4gICAgZGVmUHJvcChPYmplY3QsICdwcmV2ZW50RXh0ZW5zaW9ucycsIHtcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBpZGVudGlmeWluZ1ByZXZlbnRFeHRlbnNpb25zKG9iaikge1xuICAgICAgICBnZXRIaWRkZW5SZWNvcmQob2JqKTtcbiAgICAgICAgcmV0dXJuIG9sZFByZXZlbnRFeHRlbnNpb25zKG9iaik7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pKCk7XG5cbiAgZnVuY3Rpb24gY29uc3RGdW5jKGZ1bmMpIHtcbiAgICBmdW5jLnByb3RvdHlwZSA9IG51bGw7XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoZnVuYyk7XG4gIH1cblxuICB2YXIgY2FsbGVkQXNGdW5jdGlvbldhcm5pbmdEb25lID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGNhbGxlZEFzRnVuY3Rpb25XYXJuaW5nKCkge1xuICAgIC8vIEZ1dHVyZSBFUzYgV2Vha01hcCBpcyBjdXJyZW50bHkgKDIwMTMtMDktMTApIGV4cGVjdGVkIHRvIHJlamVjdCBXZWFrTWFwKClcbiAgICAvLyBidXQgd2UgdXNlZCB0byBwZXJtaXQgaXQgYW5kIGRvIGl0IG91cnNlbHZlcywgc28gd2FybiBvbmx5LlxuICAgIGlmICghY2FsbGVkQXNGdW5jdGlvbldhcm5pbmdEb25lICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY2FsbGVkQXNGdW5jdGlvbldhcm5pbmdEb25lID0gdHJ1ZTtcbiAgICAgIGNvbnNvbGUud2FybignV2Vha01hcCBzaG91bGQgYmUgaW52b2tlZCBhcyBuZXcgV2Vha01hcCgpLCBub3QgJyArXG4gICAgICAgICAgJ1dlYWtNYXAoKS4gVGhpcyB3aWxsIGJlIGFuIGVycm9yIGluIHRoZSBmdXR1cmUuJyk7XG4gICAgfVxuICB9XG5cbiAgdmFyIG5leHRJZCA9IDA7XG5cbiAgdmFyIE91cldlYWtNYXAgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgT3VyV2Vha01hcCkpIHsgIC8vIGFwcHJveGltYXRlIHRlc3QgZm9yIG5ldyAuLi4oKVxuICAgICAgY2FsbGVkQXNGdW5jdGlvbldhcm5pbmcoKTtcbiAgICB9XG5cbiAgICAvLyBXZSBhcmUgY3VycmVudGx5ICgxMi8yNS8yMDEyKSBuZXZlciBlbmNvdW50ZXJpbmcgYW55IHByZW1hdHVyZWx5XG4gICAgLy8gbm9uLWV4dGVuc2libGUga2V5cy5cbiAgICB2YXIga2V5cyA9IFtdOyAvLyBicnV0ZSBmb3JjZSBmb3IgcHJlbWF0dXJlbHkgbm9uLWV4dGVuc2libGUga2V5cy5cbiAgICB2YXIgdmFsdWVzID0gW107IC8vIGJydXRlIGZvcmNlIGZvciBjb3JyZXNwb25kaW5nIHZhbHVlcy5cbiAgICB2YXIgaWQgPSBuZXh0SWQrKztcblxuICAgIGZ1bmN0aW9uIGdldF9fXyhrZXksIG9wdF9kZWZhdWx0KSB7XG4gICAgICB2YXIgaW5kZXg7XG4gICAgICB2YXIgaGlkZGVuUmVjb3JkID0gZ2V0SGlkZGVuUmVjb3JkKGtleSk7XG4gICAgICBpZiAoaGlkZGVuUmVjb3JkKSB7XG4gICAgICAgIHJldHVybiBpZCBpbiBoaWRkZW5SZWNvcmQgPyBoaWRkZW5SZWNvcmRbaWRdIDogb3B0X2RlZmF1bHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbmRleCA9IGtleXMuaW5kZXhPZihrZXkpO1xuICAgICAgICByZXR1cm4gaW5kZXggPj0gMCA/IHZhbHVlc1tpbmRleF0gOiBvcHRfZGVmYXVsdDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYXNfX18oa2V5KSB7XG4gICAgICB2YXIgaGlkZGVuUmVjb3JkID0gZ2V0SGlkZGVuUmVjb3JkKGtleSk7XG4gICAgICBpZiAoaGlkZGVuUmVjb3JkKSB7XG4gICAgICAgIHJldHVybiBpZCBpbiBoaWRkZW5SZWNvcmQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ga2V5cy5pbmRleE9mKGtleSkgPj0gMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRfX18oa2V5LCB2YWx1ZSkge1xuICAgICAgdmFyIGluZGV4O1xuICAgICAgdmFyIGhpZGRlblJlY29yZCA9IGdldEhpZGRlblJlY29yZChrZXkpO1xuICAgICAgaWYgKGhpZGRlblJlY29yZCkge1xuICAgICAgICBoaWRkZW5SZWNvcmRbaWRdID0gdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbmRleCA9IGtleXMuaW5kZXhPZihrZXkpO1xuICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgIHZhbHVlc1tpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBTaW5jZSBzb21lIGJyb3dzZXJzIHByZWVtcHRpdmVseSB0ZXJtaW5hdGUgc2xvdyB0dXJucyBidXRcbiAgICAgICAgICAvLyB0aGVuIGNvbnRpbnVlIGNvbXB1dGluZyB3aXRoIHByZXN1bWFibHkgY29ycnVwdGVkIGhlYXBcbiAgICAgICAgICAvLyBzdGF0ZSwgd2UgaGVyZSBkZWZlbnNpdmVseSBnZXQga2V5cy5sZW5ndGggZmlyc3QgYW5kIHRoZW5cbiAgICAgICAgICAvLyB1c2UgaXQgdG8gdXBkYXRlIGJvdGggdGhlIHZhbHVlcyBhbmQga2V5cyBhcnJheXMsIGtlZXBpbmdcbiAgICAgICAgICAvLyB0aGVtIGluIHN5bmMuXG4gICAgICAgICAgaW5kZXggPSBrZXlzLmxlbmd0aDtcbiAgICAgICAgICB2YWx1ZXNbaW5kZXhdID0gdmFsdWU7XG4gICAgICAgICAgLy8gSWYgd2UgY3Jhc2ggaGVyZSwgdmFsdWVzIHdpbGwgYmUgb25lIGxvbmdlciB0aGFuIGtleXMuXG4gICAgICAgICAga2V5c1tpbmRleF0gPSBrZXk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlbGV0ZV9fXyhrZXkpIHtcbiAgICAgIHZhciBoaWRkZW5SZWNvcmQgPSBnZXRIaWRkZW5SZWNvcmQoa2V5KTtcbiAgICAgIHZhciBpbmRleCwgbGFzdEluZGV4O1xuICAgICAgaWYgKGhpZGRlblJlY29yZCkge1xuICAgICAgICByZXR1cm4gaWQgaW4gaGlkZGVuUmVjb3JkICYmIGRlbGV0ZSBoaWRkZW5SZWNvcmRbaWRdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5kZXggPSBrZXlzLmluZGV4T2Yoa2V5KTtcbiAgICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTaW5jZSBzb21lIGJyb3dzZXJzIHByZWVtcHRpdmVseSB0ZXJtaW5hdGUgc2xvdyB0dXJucyBidXRcbiAgICAgICAgLy8gdGhlbiBjb250aW51ZSBjb21wdXRpbmcgd2l0aCBwb3RlbnRpYWxseSBjb3JydXB0ZWQgaGVhcFxuICAgICAgICAvLyBzdGF0ZSwgd2UgaGVyZSBkZWZlbnNpdmVseSBnZXQga2V5cy5sZW5ndGggZmlyc3QgYW5kIHRoZW4gdXNlXG4gICAgICAgIC8vIGl0IHRvIHVwZGF0ZSBib3RoIHRoZSBrZXlzIGFuZCB0aGUgdmFsdWVzIGFycmF5LCBrZWVwaW5nXG4gICAgICAgIC8vIHRoZW0gaW4gc3luYy4gV2UgdXBkYXRlIHRoZSB0d28gd2l0aCBhbiBvcmRlciBvZiBhc3NpZ25tZW50cyxcbiAgICAgICAgLy8gc3VjaCB0aGF0IGFueSBwcmVmaXggb2YgdGhlc2UgYXNzaWdubWVudHMgd2lsbCBwcmVzZXJ2ZSB0aGVcbiAgICAgICAgLy8ga2V5L3ZhbHVlIGNvcnJlc3BvbmRlbmNlLCBlaXRoZXIgYmVmb3JlIG9yIGFmdGVyIHRoZSBkZWxldGUuXG4gICAgICAgIC8vIE5vdGUgdGhhdCB0aGlzIG5lZWRzIHRvIHdvcmsgY29ycmVjdGx5IHdoZW4gaW5kZXggPT09IGxhc3RJbmRleC5cbiAgICAgICAgbGFzdEluZGV4ID0ga2V5cy5sZW5ndGggLSAxO1xuICAgICAgICBrZXlzW2luZGV4XSA9IHZvaWQgMDtcbiAgICAgICAgLy8gSWYgd2UgY3Jhc2ggaGVyZSwgdGhlcmUncyBhIHZvaWQgMCBpbiB0aGUga2V5cyBhcnJheSwgYnV0XG4gICAgICAgIC8vIG5vIG9wZXJhdGlvbiB3aWxsIGNhdXNlIGEgXCJrZXlzLmluZGV4T2Yodm9pZCAwKVwiLCBzaW5jZVxuICAgICAgICAvLyBnZXRIaWRkZW5SZWNvcmQodm9pZCAwKSB3aWxsIGFsd2F5cyB0aHJvdyBhbiBlcnJvciBmaXJzdC5cbiAgICAgICAgdmFsdWVzW2luZGV4XSA9IHZhbHVlc1tsYXN0SW5kZXhdO1xuICAgICAgICAvLyBJZiB3ZSBjcmFzaCBoZXJlLCB2YWx1ZXNbaW5kZXhdIGNhbm5vdCBiZSBmb3VuZCBoZXJlLFxuICAgICAgICAvLyBiZWNhdXNlIGtleXNbaW5kZXhdIGlzIHZvaWQgMC5cbiAgICAgICAga2V5c1tpbmRleF0gPSBrZXlzW2xhc3RJbmRleF07XG4gICAgICAgIC8vIElmIGluZGV4ID09PSBsYXN0SW5kZXggYW5kIHdlIGNyYXNoIGhlcmUsIHRoZW4ga2V5c1tpbmRleF1cbiAgICAgICAgLy8gaXMgc3RpbGwgdm9pZCAwLCBzaW5jZSB0aGUgYWxpYXNpbmcga2lsbGVkIHRoZSBwcmV2aW91cyBrZXkuXG4gICAgICAgIGtleXMubGVuZ3RoID0gbGFzdEluZGV4O1xuICAgICAgICAvLyBJZiB3ZSBjcmFzaCBoZXJlLCBrZXlzIHdpbGwgYmUgb25lIHNob3J0ZXIgdGhhbiB2YWx1ZXMuXG4gICAgICAgIHZhbHVlcy5sZW5ndGggPSBsYXN0SW5kZXg7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBPYmplY3QuY3JlYXRlKE91cldlYWtNYXAucHJvdG90eXBlLCB7XG4gICAgICBnZXRfX186ICAgIHsgdmFsdWU6IGNvbnN0RnVuYyhnZXRfX18pIH0sXG4gICAgICBoYXNfX186ICAgIHsgdmFsdWU6IGNvbnN0RnVuYyhoYXNfX18pIH0sXG4gICAgICBzZXRfX186ICAgIHsgdmFsdWU6IGNvbnN0RnVuYyhzZXRfX18pIH0sXG4gICAgICBkZWxldGVfX186IHsgdmFsdWU6IGNvbnN0RnVuYyhkZWxldGVfX18pIH1cbiAgICB9KTtcbiAgfTtcblxuICBPdXJXZWFrTWFwLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoT2JqZWN0LnByb3RvdHlwZSwge1xuICAgIGdldDoge1xuICAgICAgLyoqXG4gICAgICAgKiBSZXR1cm4gdGhlIHZhbHVlIG1vc3QgcmVjZW50bHkgYXNzb2NpYXRlZCB3aXRoIGtleSwgb3JcbiAgICAgICAqIG9wdF9kZWZhdWx0IGlmIG5vbmUuXG4gICAgICAgKi9cbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXQoa2V5LCBvcHRfZGVmYXVsdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRfX18oa2V5LCBvcHRfZGVmYXVsdCk7XG4gICAgICB9LFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9LFxuXG4gICAgaGFzOiB7XG4gICAgICAvKipcbiAgICAgICAqIElzIHRoZXJlIGEgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIGtleSBpbiB0aGlzIFdlYWtNYXA/XG4gICAgICAgKi9cbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBoYXMoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhc19fXyhrZXkpO1xuICAgICAgfSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSxcblxuICAgIHNldDoge1xuICAgICAgLyoqXG4gICAgICAgKiBBc3NvY2lhdGUgdmFsdWUgd2l0aCBrZXkgaW4gdGhpcyBXZWFrTWFwLCBvdmVyd3JpdGluZyBhbnlcbiAgICAgICAqIHByZXZpb3VzIGFzc29jaWF0aW9uIGlmIHByZXNlbnQuXG4gICAgICAgKi9cbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRfX18oa2V5LCB2YWx1ZSk7XG4gICAgICB9LFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9LFxuXG4gICAgJ2RlbGV0ZSc6IHtcbiAgICAgIC8qKlxuICAgICAgICogUmVtb3ZlIGFueSBhc3NvY2lhdGlvbiBmb3Iga2V5IGluIHRoaXMgV2Vha01hcCwgcmV0dXJuaW5nXG4gICAgICAgKiB3aGV0aGVyIHRoZXJlIHdhcyBvbmUuXG4gICAgICAgKlxuICAgICAgICogPHA+Tm90ZSB0aGF0IHRoZSBib29sZWFuIHJldHVybiBoZXJlIGRvZXMgbm90IHdvcmsgbGlrZSB0aGVcbiAgICAgICAqIHtAY29kZSBkZWxldGV9IG9wZXJhdG9yLiBUaGUge0Bjb2RlIGRlbGV0ZX0gb3BlcmF0b3IgcmV0dXJuc1xuICAgICAgICogd2hldGhlciB0aGUgZGVsZXRpb24gc3VjY2VlZHMgYXQgYnJpbmdpbmcgYWJvdXQgYSBzdGF0ZSBpblxuICAgICAgICogd2hpY2ggdGhlIGRlbGV0ZWQgcHJvcGVydHkgaXMgYWJzZW50LiBUaGUge0Bjb2RlIGRlbGV0ZX1cbiAgICAgICAqIG9wZXJhdG9yIHRoZXJlZm9yZSByZXR1cm5zIHRydWUgaWYgdGhlIHByb3BlcnR5IHdhcyBhbHJlYWR5XG4gICAgICAgKiBhYnNlbnQsIHdoZXJlYXMgdGhpcyB7QGNvZGUgZGVsZXRlfSBtZXRob2QgcmV0dXJucyBmYWxzZSBpZlxuICAgICAgICogdGhlIGFzc29jaWF0aW9uIHdhcyBhbHJlYWR5IGFic2VudC5cbiAgICAgICAqL1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZShrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVsZXRlX19fKGtleSk7XG4gICAgICB9LFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xuXG4gIGlmICh0eXBlb2YgSG9zdFdlYWtNYXAgPT09ICdmdW5jdGlvbicpIHtcbiAgICAoZnVuY3Rpb24oKSB7XG4gICAgICAvLyBJZiB3ZSBnb3QgaGVyZSwgdGhlbiB0aGUgcGxhdGZvcm0gaGFzIGEgV2Vha01hcCBidXQgd2UgYXJlIGNvbmNlcm5lZFxuICAgICAgLy8gdGhhdCBpdCBtYXkgcmVmdXNlIHRvIHN0b3JlIHNvbWUga2V5IHR5cGVzLiBUaGVyZWZvcmUsIG1ha2UgYSBtYXBcbiAgICAgIC8vIGltcGxlbWVudGF0aW9uIHdoaWNoIG1ha2VzIHVzZSBvZiBib3RoIGFzIHBvc3NpYmxlLlxuXG4gICAgICAvLyBJbiB0aGlzIG1vZGUgd2UgYXJlIGFsd2F5cyB1c2luZyBkb3VibGUgbWFwcywgc28gd2UgYXJlIG5vdCBwcm94eS1zYWZlLlxuICAgICAgLy8gVGhpcyBjb21iaW5hdGlvbiBkb2VzIG5vdCBvY2N1ciBpbiBhbnkga25vd24gYnJvd3NlciwgYnV0IHdlIGhhZCBiZXN0XG4gICAgICAvLyBiZSBzYWZlLlxuICAgICAgaWYgKGRvdWJsZVdlYWtNYXBDaGVja1NpbGVudEZhaWx1cmUgJiYgdHlwZW9mIFByb3h5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBQcm94eSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gRG91YmxlV2Vha01hcCgpIHtcbiAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE91cldlYWtNYXApKSB7ICAvLyBhcHByb3hpbWF0ZSB0ZXN0IGZvciBuZXcgLi4uKClcbiAgICAgICAgICBjYWxsZWRBc0Z1bmN0aW9uV2FybmluZygpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUHJlZmVyYWJsZSwgdHJ1bHkgd2VhayBtYXAuXG4gICAgICAgIHZhciBobWFwID0gbmV3IEhvc3RXZWFrTWFwKCk7XG5cbiAgICAgICAgLy8gT3VyIGhpZGRlbi1wcm9wZXJ0eS1iYXNlZCBwc2V1ZG8td2Vhay1tYXAuIExhemlseSBpbml0aWFsaXplZCBpbiB0aGVcbiAgICAgICAgLy8gJ3NldCcgaW1wbGVtZW50YXRpb247IHRodXMgd2UgY2FuIGF2b2lkIHBlcmZvcm1pbmcgZXh0cmEgbG9va3VwcyBpZlxuICAgICAgICAvLyB3ZSBrbm93IGFsbCBlbnRyaWVzIGFjdHVhbGx5IHN0b3JlZCBhcmUgZW50ZXJlZCBpbiAnaG1hcCcuXG4gICAgICAgIHZhciBvbWFwID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIC8vIEhpZGRlbi1wcm9wZXJ0eSBtYXBzIGFyZSBub3QgY29tcGF0aWJsZSB3aXRoIHByb3hpZXMgYmVjYXVzZSBwcm94aWVzXG4gICAgICAgIC8vIGNhbiBvYnNlcnZlIHRoZSBoaWRkZW4gbmFtZSBhbmQgZWl0aGVyIGFjY2lkZW50YWxseSBleHBvc2UgaXQgb3IgZmFpbFxuICAgICAgICAvLyB0byBhbGxvdyB0aGUgaGlkZGVuIHByb3BlcnR5IHRvIGJlIHNldC4gVGhlcmVmb3JlLCB3ZSBkbyBub3QgYWxsb3dcbiAgICAgICAgLy8gYXJiaXRyYXJ5IFdlYWtNYXBzIHRvIHN3aXRjaCB0byB1c2luZyBoaWRkZW4gcHJvcGVydGllcywgYnV0IG9ubHlcbiAgICAgICAgLy8gdGhvc2Ugd2hpY2ggbmVlZCB0aGUgYWJpbGl0eSwgYW5kIHVucHJpdmlsZWdlZCBjb2RlIGlzIG5vdCBhbGxvd2VkXG4gICAgICAgIC8vIHRvIHNldCB0aGUgZmxhZy5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gKEV4Y2VwdCBpbiBkb3VibGVXZWFrTWFwQ2hlY2tTaWxlbnRGYWlsdXJlIG1vZGUgaW4gd2hpY2ggY2FzZSB3ZVxuICAgICAgICAvLyBkaXNhYmxlIHByb3hpZXMuKVxuICAgICAgICB2YXIgZW5hYmxlU3dpdGNoaW5nID0gZmFsc2U7XG5cbiAgICAgICAgZnVuY3Rpb24gZGdldChrZXksIG9wdF9kZWZhdWx0KSB7XG4gICAgICAgICAgaWYgKG9tYXApIHtcbiAgICAgICAgICAgIHJldHVybiBobWFwLmhhcyhrZXkpID8gaG1hcC5nZXQoa2V5KVxuICAgICAgICAgICAgICAgIDogb21hcC5nZXRfX18oa2V5LCBvcHRfZGVmYXVsdCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBobWFwLmdldChrZXksIG9wdF9kZWZhdWx0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBkaGFzKGtleSkge1xuICAgICAgICAgIHJldHVybiBobWFwLmhhcyhrZXkpIHx8IChvbWFwID8gb21hcC5oYXNfX18oa2V5KSA6IGZhbHNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkc2V0O1xuICAgICAgICBpZiAoZG91YmxlV2Vha01hcENoZWNrU2lsZW50RmFpbHVyZSkge1xuICAgICAgICAgIGRzZXQgPSBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICBobWFwLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIGlmICghaG1hcC5oYXMoa2V5KSkge1xuICAgICAgICAgICAgICBpZiAoIW9tYXApIHsgb21hcCA9IG5ldyBPdXJXZWFrTWFwKCk7IH1cbiAgICAgICAgICAgICAgb21hcC5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRzZXQgPSBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoZW5hYmxlU3dpdGNoaW5nKSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaG1hcC5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIW9tYXApIHsgb21hcCA9IG5ldyBPdXJXZWFrTWFwKCk7IH1cbiAgICAgICAgICAgICAgICBvbWFwLnNldF9fXyhrZXksIHZhbHVlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaG1hcC5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZGRlbGV0ZShrZXkpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gISFobWFwWydkZWxldGUnXShrZXkpO1xuICAgICAgICAgIGlmIChvbWFwKSB7IHJldHVybiBvbWFwLmRlbGV0ZV9fXyhrZXkpIHx8IHJlc3VsdDsgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gT2JqZWN0LmNyZWF0ZShPdXJXZWFrTWFwLnByb3RvdHlwZSwge1xuICAgICAgICAgIGdldF9fXzogICAgeyB2YWx1ZTogY29uc3RGdW5jKGRnZXQpIH0sXG4gICAgICAgICAgaGFzX19fOiAgICB7IHZhbHVlOiBjb25zdEZ1bmMoZGhhcykgfSxcbiAgICAgICAgICBzZXRfX186ICAgIHsgdmFsdWU6IGNvbnN0RnVuYyhkc2V0KSB9LFxuICAgICAgICAgIGRlbGV0ZV9fXzogeyB2YWx1ZTogY29uc3RGdW5jKGRkZWxldGUpIH0sXG4gICAgICAgICAgcGVybWl0SG9zdE9iamVjdHNfX186IHsgdmFsdWU6IGNvbnN0RnVuYyhmdW5jdGlvbih0b2tlbikge1xuICAgICAgICAgICAgaWYgKHRva2VuID09PSB3ZWFrTWFwUGVybWl0SG9zdE9iamVjdHMpIHtcbiAgICAgICAgICAgICAgZW5hYmxlU3dpdGNoaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYm9ndXMgY2FsbCB0byBwZXJtaXRIb3N0T2JqZWN0c19fXycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIERvdWJsZVdlYWtNYXAucHJvdG90eXBlID0gT3VyV2Vha01hcC5wcm90b3R5cGU7XG4gICAgICBtb2R1bGUuZXhwb3J0cyA9IERvdWJsZVdlYWtNYXA7XG5cbiAgICAgIC8vIGRlZmluZSAuY29uc3RydWN0b3IgdG8gaGlkZSBPdXJXZWFrTWFwIGN0b3JcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWFrTWFwLnByb3RvdHlwZSwgJ2NvbnN0cnVjdG9yJywge1xuICAgICAgICB2YWx1ZTogV2Vha01hcCxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsICAvLyBhcyBkZWZhdWx0IC5jb25zdHJ1Y3RvciBpc1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9KSgpO1xuICB9IGVsc2Uge1xuICAgIC8vIFRoZXJlIGlzIG5vIGhvc3QgV2Vha01hcCwgc28gd2UgbXVzdCB1c2UgdGhlIGVtdWxhdGlvbi5cblxuICAgIC8vIEVtdWxhdGVkIFdlYWtNYXBzIGFyZSBpbmNvbXBhdGlibGUgd2l0aCBuYXRpdmUgcHJveGllcyAoYmVjYXVzZSBwcm94aWVzXG4gICAgLy8gY2FuIG9ic2VydmUgdGhlIGhpZGRlbiBuYW1lKSwgc28gd2UgbXVzdCBkaXNhYmxlIFByb3h5IHVzYWdlIChpblxuICAgIC8vIEFycmF5TGlrZSBhbmQgRG9tYWRvLCBjdXJyZW50bHkpLlxuICAgIGlmICh0eXBlb2YgUHJveHkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBQcm94eSA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IE91cldlYWtNYXA7XG4gIH1cbn0pKCk7XG4iLCIndXNlIHN0cmljdCdcblxudmFyIHdlYWtNYXAgPSB0eXBlb2YgV2Vha01hcCA9PT0gJ3VuZGVmaW5lZCcgPyByZXF1aXJlKCd3ZWFrLW1hcCcpIDogV2Vha01hcFxuXG52YXIgV2ViR0xFV1N0cnVjdCA9IG5ldyB3ZWFrTWFwKClcblxuZnVuY3Rpb24gYmFzZU5hbWUoZXh0X25hbWUpIHtcbiAgcmV0dXJuIGV4dF9uYW1lLnJlcGxhY2UoL15bQS1aXStfLywgJycpXG59XG5cbmZ1bmN0aW9uIGluaXRXZWJHTEVXKGdsKSB7XG4gIHZhciBzdHJ1Y3QgPSBXZWJHTEVXU3RydWN0LmdldChnbClcbiAgaWYoc3RydWN0KSB7XG4gICAgcmV0dXJuIHN0cnVjdFxuICB9XG4gIHZhciBleHRlbnNpb25zID0ge31cbiAgdmFyIHN1cHBvcnRlZCA9IGdsLmdldFN1cHBvcnRlZEV4dGVuc2lvbnMoKVxuICBmb3IodmFyIGk9MDsgaTxzdXBwb3J0ZWQubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgZXh0TmFtZSA9IHN1cHBvcnRlZFtpXVxuXG4gICAgLy9Ta2lwIE1PWl8gZXh0ZW5zaW9uc1xuICAgIGlmKGV4dE5hbWUuaW5kZXhPZignTU9aXycpID09PSAwKSB7XG4gICAgICBjb250aW51ZVxuICAgIH1cbiAgICB2YXIgZXh0ID0gZ2wuZ2V0RXh0ZW5zaW9uKHN1cHBvcnRlZFtpXSlcbiAgICBpZighZXh0KSB7XG4gICAgICBjb250aW51ZVxuICAgIH1cbiAgICB3aGlsZSh0cnVlKSB7XG4gICAgICBleHRlbnNpb25zW2V4dE5hbWVdID0gZXh0XG4gICAgICB2YXIgYmFzZSA9IGJhc2VOYW1lKGV4dE5hbWUpXG4gICAgICBpZihiYXNlID09PSBleHROYW1lKSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBleHROYW1lID0gYmFzZVxuICAgIH1cbiAgfVxuICBXZWJHTEVXU3RydWN0LnNldChnbCwgZXh0ZW5zaW9ucylcbiAgcmV0dXJuIGV4dGVuc2lvbnNcbn1cbm1vZHVsZS5leHBvcnRzID0gaW5pdFdlYkdMRVciLCJ2YXIgY3JlYXRlID0gcmVxdWlyZSgnZ2wtdGV4dHVyZTJkJylcbnZhciBuZGFycmF5ID0gcmVxdWlyZSgnbmRhcnJheScpXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZ2wpIHtcbiAgICAvL2ZpbGwgYW4gYXJyYXkgd2l0aCAweGZmXG4gICAgdmFyIGRhdGEgPSBBcnJheS5hcHBseShudWxsLCBuZXcgQXJyYXkoMTYpKVxuICAgICAgICAgICAgLm1hcChOdW1iZXIucHJvdG90eXBlLnZhbHVlT2YsIDB4RkYpO1xuICAgIC8vY3JlYXRlIGEgMkQgbmRhcnJheVxuICAgIHZhciBhcnJheSA9IG5kYXJyYXkobmV3IFVpbnQ4QXJyYXkoZGF0YSksIFsyLCAyLCA0XSlcbiAgICByZXR1cm4gY3JlYXRlKGdsLCBhcnJheSlcbn0iLCJtb2R1bGUuZXhwb3J0cz1yZXF1aXJlKFwiL3Byb2plY3RzL2JsYWNraWNlL25vZGVfbW9kdWxlcy90aHJlZS1zZGYtdGV4dC9ub2RlX21vZHVsZXMvZ2wtc3ByaXRlLXRleHQvbm9kZV9tb2R1bGVzL2dsLXNwcml0ZS1iYXRjaC9ub2RlX21vZHVsZXMvZ2wtYnVmZmVyL25vZGVfbW9kdWxlcy9uZGFycmF5L25kYXJyYXkuanNcIikiLCJtb2R1bGUuZXhwb3J0cz1yZXF1aXJlKFwiL3Byb2plY3RzL2JsYWNraWNlL25vZGVfbW9kdWxlcy9taXhlcy9pbmRleC5qc1wiKSIsInZhciBpbnQ4ID0gbmV3IEludDhBcnJheSg0KTtcbnZhciBpbnQzMiA9IG5ldyBJbnQzMkFycmF5KGludDguYnVmZmVyLCAwLCAxKTtcbnZhciBmbG9hdDMyID0gbmV3IEZsb2F0MzJBcnJheShpbnQ4LmJ1ZmZlciwgMCwgMSk7XG5cbi8qKlxuICogQSBzaW5nbGV0b24gZm9yIG51bWJlciB1dGlsaXRpZXMuIFxuICogQGNsYXNzIE51bWJlclV0aWxcbiAqL1xudmFyIE51bWJlclV0aWwgPSBmdW5jdGlvbigpIHtcblxufTtcblxuXG4vKipcbiAqIFJldHVybnMgYSBmbG9hdCByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gaW50IGJpdHMuIEFycmF5QnVmZmVyXG4gKiBpcyB1c2VkIGZvciB0aGUgY29udmVyc2lvbi5cbiAqXG4gKiBAbWV0aG9kICBpbnRCaXRzVG9GbG9hdFxuICogQHN0YXRpY1xuICogQHBhcmFtICB7TnVtYmVyfSBpIHRoZSBpbnQgdG8gY2FzdFxuICogQHJldHVybiB7TnVtYmVyfSAgIHRoZSBmbG9hdFxuICovXG5OdW1iZXJVdGlsLmludEJpdHNUb0Zsb2F0ID0gZnVuY3Rpb24oaSkge1xuXHRpbnQzMlswXSA9IGk7XG5cdHJldHVybiBmbG9hdDMyWzBdO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBpbnQgYml0cyBmcm9tIHRoZSBnaXZlbiBmbG9hdC4gQXJyYXlCdWZmZXIgaXMgdXNlZFxuICogZm9yIHRoZSBjb252ZXJzaW9uLlxuICpcbiAqIEBtZXRob2QgIGZsb2F0VG9JbnRCaXRzXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGYgdGhlIGZsb2F0IHRvIGNhc3RcbiAqIEByZXR1cm4ge051bWJlcn0gICB0aGUgaW50IGJpdHNcbiAqL1xuTnVtYmVyVXRpbC5mbG9hdFRvSW50Qml0cyA9IGZ1bmN0aW9uKGYpIHtcblx0ZmxvYXQzMlswXSA9IGY7XG5cdHJldHVybiBpbnQzMlswXTtcbn07XG5cbi8qKlxuICogRW5jb2RlcyBBQkdSIGludCBhcyBhIGZsb2F0LCB3aXRoIHNsaWdodCBwcmVjaXNpb24gbG9zcy5cbiAqXG4gKiBAbWV0aG9kICBpbnRUb0Zsb2F0Q29sb3JcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSBhbiBBQkdSIHBhY2tlZCBpbnRlZ2VyXG4gKi9cbk51bWJlclV0aWwuaW50VG9GbG9hdENvbG9yID0gZnVuY3Rpb24odmFsdWUpIHtcblx0cmV0dXJuIE51bWJlclV0aWwuaW50Qml0c1RvRmxvYXQoIHZhbHVlICYgMHhmZWZmZmZmZiApO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgZmxvYXQgZW5jb2RlZCBBQkdSIHZhbHVlIGZyb20gdGhlIGdpdmVuIFJHQkFcbiAqIGJ5dGVzICgwIC0gMjU1KS4gVXNlZnVsIGZvciBzYXZpbmcgYmFuZHdpZHRoIGluIHZlcnRleCBkYXRhLlxuICpcbiAqIEBtZXRob2QgIGNvbG9yVG9GbG9hdFxuICogQHN0YXRpY1xuICogQHBhcmFtIHtOdW1iZXJ9IHIgdGhlIFJlZCBieXRlICgwIC0gMjU1KVxuICogQHBhcmFtIHtOdW1iZXJ9IGcgdGhlIEdyZWVuIGJ5dGUgKDAgLSAyNTUpXG4gKiBAcGFyYW0ge051bWJlcn0gYiB0aGUgQmx1ZSBieXRlICgwIC0gMjU1KVxuICogQHBhcmFtIHtOdW1iZXJ9IGEgdGhlIEFscGhhIGJ5dGUgKDAgLSAyNTUpXG4gKiBAcmV0dXJuIHtGbG9hdDMyfSAgYSBGbG9hdDMyIG9mIHRoZSBSR0JBIGNvbG9yXG4gKi9cbk51bWJlclV0aWwuY29sb3JUb0Zsb2F0ID0gZnVuY3Rpb24ociwgZywgYiwgYSkge1xuXHR2YXIgYml0cyA9IChhIDw8IDI0IHwgYiA8PCAxNiB8IGcgPDwgOCB8IHIpO1xuXHRyZXR1cm4gTnVtYmVyVXRpbC5pbnRUb0Zsb2F0Q29sb3IoYml0cyk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgbnVtYmVyIGlzIGEgcG93ZXItb2YtdHdvLlxuICpcbiAqIEBtZXRob2QgIGlzUG93ZXJPZlR3b1xuICogQHBhcmFtICB7TnVtYmVyfSAgbiB0aGUgbnVtYmVyIHRvIHRlc3RcbiAqIEByZXR1cm4ge0Jvb2xlYW59ICAgdHJ1ZSBpZiBwb3dlci1vZi10d29cbiAqL1xuTnVtYmVyVXRpbC5pc1Bvd2VyT2ZUd28gPSBmdW5jdGlvbihuKSB7XG5cdHJldHVybiAobiAmIChuIC0gMSkpID09PSAwO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBuZXh0IGhpZ2hlc3QgcG93ZXItb2YtdHdvIGZyb20gdGhlIHNwZWNpZmllZCBudW1iZXIuIFxuICogXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IG4gdGhlIG51bWJlciB0byB0ZXN0XG4gKiBAcmV0dXJuIHtOdW1iZXJ9ICAgdGhlIG5leHQgaGlnaGVzdCBwb3dlciBvZiB0d29cbiAqL1xuTnVtYmVyVXRpbC5uZXh0UG93ZXJPZlR3byA9IGZ1bmN0aW9uKG4pIHtcblx0bi0tO1xuXHRuIHw9IG4gPj4gMTtcblx0biB8PSBuID4+IDI7XG5cdG4gfD0gbiA+PiA0O1xuXHRuIHw9IG4gPj4gODtcblx0biB8PSBuID4+IDE2O1xuXHRyZXR1cm4gbisxO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBOdW1iZXJVdGlsOyIsImZ1bmN0aW9uIHByZW11bHRpcGx5KHJnYmEsIG91dCkge1xuXHRpZiAoIW91dCB8fCB0eXBlb2Ygb3V0ID09PSAnbnVtYmVyJylcblx0XHRvdXQgPSBbMCwwLDAsMF1cblx0b3V0WzBdID0gcmdiYVswXSAqIHJnYmFbM11cblx0b3V0WzFdID0gcmdiYVsxXSAqIHJnYmFbM11cblx0b3V0WzJdID0gcmdiYVsyXSAqIHJnYmFbM11cblx0b3V0WzNdID0gcmdiYVszXVxuXHRyZXR1cm4gb3V0XG59XG5tb2R1bGUuZXhwb3J0cyA9IHByZW11bHRpcGx5IiwidmFyIHBhY2tDb2xvciA9IHJlcXVpcmUoJ251bWJlci11dGlsJykuY29sb3JUb0Zsb2F0XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY29sb3JUb0Zsb2F0KHJnYmEpIHtcbiAgICByZXR1cm4gcGFja0NvbG9yKFxuICAgICAgICB+fihyZ2JhWzBdICogMjU1KSxcbiAgICAgICAgfn4ocmdiYVsxXSAqIDI1NSksXG4gICAgICAgIH5+KHJnYmFbMl0gKiAyNTUpLFxuICAgICAgICB+fihyZ2JhWzNdICogMjU1KVxuICAgIClcbn0iLCJtb2R1bGUuZXhwb3J0cz1yZXF1aXJlKFwiL3Byb2plY3RzL2JsYWNraWNlL25vZGVfbW9kdWxlcy9pbmhlcml0cy9pbmhlcml0c19icm93c2VyLmpzXCIpIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB0ZXhjb29yZChwb3NpdGlvbiwgc2hhcGUsIHRleFNoYXBlLCBvdXQpIHtcbiAgICBpZiAoIW91dClcbiAgICAgICAgb3V0ID0gWzAsIDAsIDEsIDFdXG5cbiAgICBwb3NpdGlvbiA9IHBvc2l0aW9uIHx8IFswLCAwXVxuICAgIHNoYXBlID0gc2hhcGUgfHwgWzEsIDFdXG5cbiAgICB0ZXhTaGFwZSA9IHRleFNoYXBlIHx8IHNoYXBlXG5cbiAgICB2YXIgaW52V2lkdGggPSAxIC8gdGV4U2hhcGVbMF1cbiAgICB2YXIgaW52SGVpZ2h0ID0gMSAvIHRleFNoYXBlWzFdXG4gICAgdmFyIHggPSBwb3NpdGlvblswXSxcbiAgICAgICAgeSA9IHBvc2l0aW9uWzFdLFxuICAgICAgICB3ID0gc2hhcGVbMF0sXG4gICAgICAgIGggPSBzaGFwZVsxXVxuXG4gICAgb3V0WzBdID0geCAqIGludldpZHRoXG4gICAgb3V0WzFdID0geSAqIGludkhlaWdodFxuICAgIG91dFsyXSA9ICh4ICsgdykgKiBpbnZXaWR0aFxuICAgIG91dFszXSA9ICh5ICsgaCkgKiBpbnZIZWlnaHRcbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHM9cmVxdWlyZShcIi9wcm9qZWN0cy9ibGFja2ljZS9ub2RlX21vZHVsZXMvZ2wtdGV4dHVyZTJkL3RleHR1cmUuanNcIikiLCJtb2R1bGUuZXhwb3J0cyA9IGV4dGVuZFxuXG5mdW5jdGlvbiBleHRlbmQoKSB7XG4gICAgdmFyIHRhcmdldCA9IHt9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldXG5cbiAgICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICAgICAgaWYgKHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldFxufVxuIiwidmFyIGdsc2xpZnkgPSByZXF1aXJlKFwiZ2xzbGlmeVwiKTtcbnZhciB0aHJlZWlmeSA9IHJlcXVpcmUoXCJ0aHJlZS1nbHNsaWZ5XCIpO1xudmFyIHNvdXJjZSA9IHJlcXVpcmUoXCJnbHNsaWZ5L3NpbXBsZS1hZGFwdGVyLmpzXCIpKFwiXFxuI2RlZmluZSBHTFNMSUZZIDFcXG5cXG52YXJ5aW5nIHZlYzIgdlV2O1xcbnZhcnlpbmcgdmVjMiB2X3JnYk5XO1xcbnZhcnlpbmcgdmVjMiB2X3JnYk5FO1xcbnZhcnlpbmcgdmVjMiB2X3JnYlNXO1xcbnZhcnlpbmcgdmVjMiB2X3JnYlNFO1xcbnZhcnlpbmcgdmVjMiB2X3JnYk07XFxudW5pZm9ybSB2ZWMyIHJlc29sdXRpb247XFxudm9pZCBhX3hfdGV4Y29vcmRzKHZlYzIgZnJhZ0Nvb3JkLCB2ZWMyIHJlc29sdXRpb24sIG91dCB2ZWMyIHZfcmdiTlcsIG91dCB2ZWMyIHZfcmdiTkUsIG91dCB2ZWMyIHZfcmdiU1csIG91dCB2ZWMyIHZfcmdiU0UsIG91dCB2ZWMyIHZfcmdiTSkge1xcbiAgdmVjMiBpbnZlcnNlVlAgPSAxLjAgLyByZXNvbHV0aW9uLnh5O1xcbiAgdl9yZ2JOVyA9IChmcmFnQ29vcmQgKyB2ZWMyKC0xLjAsIC0xLjApKSAqIGludmVyc2VWUDtcXG4gIHZfcmdiTkUgPSAoZnJhZ0Nvb3JkICsgdmVjMigxLjAsIC0xLjApKSAqIGludmVyc2VWUDtcXG4gIHZfcmdiU1cgPSAoZnJhZ0Nvb3JkICsgdmVjMigtMS4wLCAxLjApKSAqIGludmVyc2VWUDtcXG4gIHZfcmdiU0UgPSAoZnJhZ0Nvb3JkICsgdmVjMigxLjAsIDEuMCkpICogaW52ZXJzZVZQO1xcbiAgdl9yZ2JNID0gdmVjMihmcmFnQ29vcmQgKiBpbnZlcnNlVlApO1xcbn1cXG52b2lkIG1haW4oKSB7XFxuICB2VXYgPSB1djtcXG4gIHZlYzIgZnJhZ0Nvb3JkID0gdXYgKiByZXNvbHV0aW9uO1xcbiAgYV94X3RleGNvb3JkcyhmcmFnQ29vcmQsIHJlc29sdXRpb24sIHZfcmdiTlcsIHZfcmdiTkUsIHZfcmdiU1csIHZfcmdiU0UsIHZfcmdiTSk7XFxuICBnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KHBvc2l0aW9uLCAxLjApO1xcbn1cIiwgXCJcXG4jZGVmaW5lIEdMU0xJRlkgMVxcblxcbnZhcnlpbmcgdmVjMiB2VXY7XFxudmFyeWluZyB2ZWMyIHZfcmdiTlc7XFxudmFyeWluZyB2ZWMyIHZfcmdiTkU7XFxudmFyeWluZyB2ZWMyIHZfcmdiU1c7XFxudmFyeWluZyB2ZWMyIHZfcmdiU0U7XFxudmFyeWluZyB2ZWMyIHZfcmdiTTtcXG51bmlmb3JtIHZlYzIgcmVzb2x1dGlvbjtcXG51bmlmb3JtIHNhbXBsZXIyRCB0RGlmZnVzZTtcXG4jaWZuZGVmIEZYQUFfUkVEVUNFX01JTlxcblxcbiNkZWZpbmUgRlhBQV9SRURVQ0VfTUlOICAgKDEuMC8gMTI4LjApXFxuXFxuI2VuZGlmXFxuXFxuI2lmbmRlZiBGWEFBX1JFRFVDRV9NVUxcXG5cXG4jZGVmaW5lIEZYQUFfUkVEVUNFX01VTCAgICgxLjAgLyA4LjApXFxuXFxuI2VuZGlmXFxuXFxuI2lmbmRlZiBGWEFBX1NQQU5fTUFYXFxuXFxuI2RlZmluZSBGWEFBX1NQQU5fTUFYICAgICA4LjBcXG5cXG4jZW5kaWZcXG5cXG52ZWM0IGFfeF9meGFhKHNhbXBsZXIyRCB0ZXgsIHZlYzIgZnJhZ0Nvb3JkLCB2ZWMyIHJlc29sdXRpb24sIHZlYzIgdl9yZ2JOVywgdmVjMiB2X3JnYk5FLCB2ZWMyIHZfcmdiU1csIHZlYzIgdl9yZ2JTRSwgdmVjMiB2X3JnYk0pIHtcXG4gIHZlYzQgY29sb3I7XFxuICBtZWRpdW1wIHZlYzIgaW52ZXJzZVZQID0gdmVjMigxLjAgLyByZXNvbHV0aW9uLngsIDEuMCAvIHJlc29sdXRpb24ueSk7XFxuICB2ZWMzIHJnYk5XID0gdGV4dHVyZTJEKHRleCwgdl9yZ2JOVykueHl6O1xcbiAgdmVjMyByZ2JORSA9IHRleHR1cmUyRCh0ZXgsIHZfcmdiTkUpLnh5ejtcXG4gIHZlYzMgcmdiU1cgPSB0ZXh0dXJlMkQodGV4LCB2X3JnYlNXKS54eXo7XFxuICB2ZWMzIHJnYlNFID0gdGV4dHVyZTJEKHRleCwgdl9yZ2JTRSkueHl6O1xcbiAgdmVjNCB0ZXhDb2xvciA9IHRleHR1cmUyRCh0ZXgsIHZfcmdiTSk7XFxuICB2ZWMzIHJnYk0gPSB0ZXhDb2xvci54eXo7XFxuICB2ZWMzIGx1bWEgPSB2ZWMzKDAuMjk5LCAwLjU4NywgMC4xMTQpO1xcbiAgZmxvYXQgbHVtYU5XID0gZG90KHJnYk5XLCBsdW1hKTtcXG4gIGZsb2F0IGx1bWFORSA9IGRvdChyZ2JORSwgbHVtYSk7XFxuICBmbG9hdCBsdW1hU1cgPSBkb3QocmdiU1csIGx1bWEpO1xcbiAgZmxvYXQgbHVtYVNFID0gZG90KHJnYlNFLCBsdW1hKTtcXG4gIGZsb2F0IGx1bWFNID0gZG90KHJnYk0sIGx1bWEpO1xcbiAgZmxvYXQgbHVtYU1pbiA9IG1pbihsdW1hTSwgbWluKG1pbihsdW1hTlcsIGx1bWFORSksIG1pbihsdW1hU1csIGx1bWFTRSkpKTtcXG4gIGZsb2F0IGx1bWFNYXggPSBtYXgobHVtYU0sIG1heChtYXgobHVtYU5XLCBsdW1hTkUpLCBtYXgobHVtYVNXLCBsdW1hU0UpKSk7XFxuICBtZWRpdW1wIHZlYzIgZGlyO1xcbiAgZGlyLnggPSAtKChsdW1hTlcgKyBsdW1hTkUpIC0gKGx1bWFTVyArIGx1bWFTRSkpO1xcbiAgZGlyLnkgPSAoKGx1bWFOVyArIGx1bWFTVykgLSAobHVtYU5FICsgbHVtYVNFKSk7XFxuICBmbG9hdCBkaXJSZWR1Y2UgPSBtYXgoKGx1bWFOVyArIGx1bWFORSArIGx1bWFTVyArIGx1bWFTRSkgKiAoMC4yNSAqIEZYQUFfUkVEVUNFX01VTCksIEZYQUFfUkVEVUNFX01JTik7XFxuICBmbG9hdCByY3BEaXJNaW4gPSAxLjAgLyAobWluKGFicyhkaXIueCksIGFicyhkaXIueSkpICsgZGlyUmVkdWNlKTtcXG4gIGRpciA9IG1pbih2ZWMyKEZYQUFfU1BBTl9NQVgsIEZYQUFfU1BBTl9NQVgpLCBtYXgodmVjMigtRlhBQV9TUEFOX01BWCwgLUZYQUFfU1BBTl9NQVgpLCBkaXIgKiByY3BEaXJNaW4pKSAqIGludmVyc2VWUDtcXG4gIHZlYzMgcmdiQSA9IDAuNSAqICh0ZXh0dXJlMkQodGV4LCBmcmFnQ29vcmQgKiBpbnZlcnNlVlAgKyBkaXIgKiAoMS4wIC8gMy4wIC0gMC41KSkueHl6ICsgdGV4dHVyZTJEKHRleCwgZnJhZ0Nvb3JkICogaW52ZXJzZVZQICsgZGlyICogKDIuMCAvIDMuMCAtIDAuNSkpLnh5eik7XFxuICB2ZWMzIHJnYkIgPSByZ2JBICogMC41ICsgMC4yNSAqICh0ZXh0dXJlMkQodGV4LCBmcmFnQ29vcmQgKiBpbnZlcnNlVlAgKyBkaXIgKiAtMC41KS54eXogKyB0ZXh0dXJlMkQodGV4LCBmcmFnQ29vcmQgKiBpbnZlcnNlVlAgKyBkaXIgKiAwLjUpLnh5eik7XFxuICBmbG9hdCBsdW1hQiA9IGRvdChyZ2JCLCBsdW1hKTtcXG4gIGlmKChsdW1hQiA8IGx1bWFNaW4pIHx8IChsdW1hQiA+IGx1bWFNYXgpKVxcbiAgICBjb2xvciA9IHZlYzQocmdiQSwgdGV4Q29sb3IuYSk7XFxuICBlbHNlXFxuICAgIGNvbG9yID0gdmVjNChyZ2JCLCB0ZXhDb2xvci5hKTtcXG4gIHJldHVybiBjb2xvcjtcXG59XFxudm9pZCBtYWluKCkge1xcbiAgdmVjMiBmcmFnQ29vcmQgPSB2VXYgKiByZXNvbHV0aW9uO1xcbiAgZ2xfRnJhZ0NvbG9yID0gYV94X2Z4YWEodERpZmZ1c2UsIGZyYWdDb29yZCwgcmVzb2x1dGlvbiwgdl9yZ2JOVywgdl9yZ2JORSwgdl9yZ2JTVywgdl9yZ2JTRSwgdl9yZ2JNKTtcXG59XCIsIFt7XCJuYW1lXCI6XCJyZXNvbHV0aW9uXCIsXCJ0eXBlXCI6XCJ2ZWMyXCJ9LHtcIm5hbWVcIjpcInJlc29sdXRpb25cIixcInR5cGVcIjpcInZlYzJcIn0se1wibmFtZVwiOlwidERpZmZ1c2VcIixcInR5cGVcIjpcInNhbXBsZXIyRFwifV0sIFtdKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihUSFJFRSkge1xuICAgIHZhciBjcmVhdGVTaGFkZXIgPSB0aHJlZWlmeShUSFJFRSk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVTaGFkZXIoc291cmNlKTtcbiAgICB9O1xufTsiLCJ2YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oVEhSRUUpIHtcblxuICAgIGZ1bmN0aW9uIENvbXBsZXgobWVzaCkge1xuICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQ29tcGxleCkpXG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbXBsZXgobWVzaClcbiAgICAgICAgVEhSRUUuR2VvbWV0cnkuY2FsbCh0aGlzKVxuICAgICAgICB0aGlzLmR5bmFtaWMgPSB0cnVlXG5cbiAgICAgICAgaWYgKG1lc2gpXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZShtZXNoKVxuICAgIH1cblxuICAgIGluaGVyaXRzKENvbXBsZXgsIFRIUkVFLkdlb21ldHJ5KVxuXG4gICAgLy9tYXkgZXhwb3NlIHRoZXNlIGluIG5leHQgdmVyc2lvblxuICAgIENvbXBsZXgucHJvdG90eXBlLl91cGRhdGVQb3NpdGlvbnMgPSBmdW5jdGlvbihwb3NpdGlvbnMpIHtcbiAgICAgICAgZm9yICh2YXIgaT0wOyBpPHBvc2l0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHBvcyA9IHBvc2l0aW9uc1tpXVxuICAgICAgICAgICAgaWYgKGkgPiB0aGlzLnZlcnRpY2VzLmxlbmd0aC0xKVxuICAgICAgICAgICAgICAgIHRoaXMudmVydGljZXMucHVzaChuZXcgVEhSRUUuVmVjdG9yMygpLmZyb21BcnJheShwb3MpKVxuICAgICAgICAgICAgZWxzZSBcbiAgICAgICAgICAgICAgICB0aGlzLnZlcnRpY2VzW2ldLmZyb21BcnJheShwb3MpXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52ZXJ0aWNlcy5sZW5ndGggPSBwb3NpdGlvbnMubGVuZ3RoXG4gICAgICAgIHRoaXMudmVydGljZXNOZWVkVXBkYXRlID0gdHJ1ZVxuICAgIH1cblxuICAgIENvbXBsZXgucHJvdG90eXBlLl91cGRhdGVDZWxscyA9IGZ1bmN0aW9uKGNlbGxzKSB7XG4gICAgICAgIGZvciAodmFyIGk9MDsgaTxjZWxscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGZhY2UgPSBjZWxsc1tpXVxuICAgICAgICAgICAgaWYgKGkgPiB0aGlzLmZhY2VzLmxlbmd0aC0xKVxuICAgICAgICAgICAgICAgIHRoaXMuZmFjZXMucHVzaChuZXcgVEhSRUUuRmFjZTMoZmFjZVswXSwgZmFjZVsxXSwgZmFjZVsyXSkpXG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgdGYgPSB0aGlzLmZhY2VzW2ldXG4gICAgICAgICAgICAgICAgdGYuYSA9IGZhY2VbMF1cbiAgICAgICAgICAgICAgICB0Zi5iID0gZmFjZVsxXVxuICAgICAgICAgICAgICAgIHRmLmMgPSBmYWNlWzJdXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmZhY2VzLmxlbmd0aCA9IGNlbGxzLmxlbmd0aFxuICAgICAgICB0aGlzLmVsZW1lbnRzTmVlZFVwZGF0ZSA9IHRydWVcbiAgICB9XG5cbiAgICBDb21wbGV4LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbihtZXNoKSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVBvc2l0aW9ucyhtZXNoLnBvc2l0aW9ucylcbiAgICAgICAgdGhpcy5fdXBkYXRlQ2VsbHMobWVzaC5jZWxscylcbiAgICB9XG5cbiAgICByZXR1cm4gQ29tcGxleFxufSIsInZhciBUZXNzMiA9IHJlcXVpcmUoJ3Rlc3MyJylcbnZhciB4dGVuZCA9IHJlcXVpcmUoJ3h0ZW5kJylcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihjb250b3Vycywgb3B0KSB7XG4gICAgb3B0ID0gb3B0fHx7fVxuICAgIGNvbnRvdXJzID0gY29udG91cnMuZmlsdGVyKGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgcmV0dXJuIGMubGVuZ3RoPjBcbiAgICB9KVxuICAgIFxuICAgIGlmIChjb250b3Vycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHsgXG4gICAgICAgICAgICBwb3NpdGlvbnM6IFtdLFxuICAgICAgICAgICAgY2VsbHM6IFtdXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG9wdC52ZXJ0ZXhTaXplICE9PSAnbnVtYmVyJylcbiAgICAgICAgb3B0LnZlcnRleFNpemUgPSBjb250b3Vyc1swXVswXS5sZW5ndGhcblxuICAgIC8vZmxhdHRlbiBmb3IgdGVzczIuanNcbiAgICBjb250b3VycyA9IGNvbnRvdXJzLm1hcChmdW5jdGlvbihjKSB7XG4gICAgICAgIHJldHVybiBjLnJlZHVjZShmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYS5jb25jYXQoYilcbiAgICAgICAgfSlcbiAgICB9KVxuXG4gICAgLy8gVGVzc2VsYXRlXG4gICAgdmFyIHJlcyA9IFRlc3MyLnRlc3NlbGF0ZSh4dGVuZCh7XG4gICAgICAgIGNvbnRvdXJzOiBjb250b3VycyxcbiAgICAgICAgd2luZGluZ1J1bGU6IFRlc3MyLldJTkRJTkdfT0RELFxuICAgICAgICBlbGVtZW50VHlwZTogVGVzczIuUE9MWUdPTlMsXG4gICAgICAgIHBvbHlTaXplOiAzLFxuICAgICAgICB2ZXJ0ZXhTaXplOiAyXG4gICAgfSwgb3B0KSlcblxuICAgIHZhciBwb3NpdGlvbnMgPSBbXVxuICAgIGZvciAodmFyIGk9MDsgaTxyZXMudmVydGljZXMubGVuZ3RoOyBpKz1vcHQudmVydGV4U2l6ZSkge1xuICAgICAgICB2YXIgcG9zID0gcmVzLnZlcnRpY2VzLnNsaWNlKGksIGkrb3B0LnZlcnRleFNpemUpXG4gICAgICAgIHBvc2l0aW9ucy5wdXNoKHBvcylcbiAgICB9XG4gICAgXG4gICAgdmFyIGNlbGxzID0gW11cbiAgICBmb3IgKGk9MDsgaTxyZXMuZWxlbWVudHMubGVuZ3RoOyBpKz0zKSB7XG4gICAgICAgIHZhciBhID0gcmVzLmVsZW1lbnRzW2ldLFxuICAgICAgICAgICAgYiA9IHJlcy5lbGVtZW50c1tpKzFdLFxuICAgICAgICAgICAgYyA9IHJlcy5lbGVtZW50c1tpKzJdXG4gICAgICAgIGNlbGxzLnB1c2goW2EsIGIsIGNdKVxuICAgIH1cblxuICAgIC8vcmV0dXJuIGEgc2ltcGxpY2lhbCBjb21wbGV4XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcG9zaXRpb25zOiBwb3NpdGlvbnMsXG4gICAgICAgIGNlbGxzOiBjZWxsc1xuICAgIH1cbn0iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vc3JjL3Rlc3MyJyk7IiwiLypcbioqIFNHSSBGUkVFIFNPRlRXQVJFIExJQ0VOU0UgQiAoVmVyc2lvbiAyLjAsIFNlcHQuIDE4LCAyMDA4KSBcbioqIENvcHlyaWdodCAoQykgW2RhdGVzIG9mIGZpcnN0IHB1YmxpY2F0aW9uXSBTaWxpY29uIEdyYXBoaWNzLCBJbmMuXG4qKiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuKipcbioqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbioqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbioqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbioqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzXG4qKiBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4qKiBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbioqIFxuKiogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgaW5jbHVkaW5nIHRoZSBkYXRlcyBvZiBmaXJzdCBwdWJsaWNhdGlvbiBhbmQgZWl0aGVyIHRoaXNcbioqIHBlcm1pc3Npb24gbm90aWNlIG9yIGEgcmVmZXJlbmNlIHRvIGh0dHA6Ly9vc3Muc2dpLmNvbS9wcm9qZWN0cy9GcmVlQi8gc2hhbGwgYmVcbioqIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLiBcbioqXG4qKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SIElNUExJRUQsXG4qKiBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQVxuKiogUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFNJTElDT04gR1JBUEhJQ1MsIElOQy5cbioqIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsXG4qKiBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFXG4qKiBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4qKiBcbioqIEV4Y2VwdCBhcyBjb250YWluZWQgaW4gdGhpcyBub3RpY2UsIHRoZSBuYW1lIG9mIFNpbGljb24gR3JhcGhpY3MsIEluYy4gc2hhbGwgbm90XG4qKiBiZSB1c2VkIGluIGFkdmVydGlzaW5nIG9yIG90aGVyd2lzZSB0byBwcm9tb3RlIHRoZSBzYWxlLCB1c2Ugb3Igb3RoZXIgZGVhbGluZ3MgaW5cbioqIHRoaXMgU29mdHdhcmUgd2l0aG91dCBwcmlvciB3cml0dGVuIGF1dGhvcml6YXRpb24gZnJvbSBTaWxpY29uIEdyYXBoaWNzLCBJbmMuXG4qL1xuLypcbioqIEF1dGhvcjogTWlra28gTW9ub25lbiwgQXVnIDIwMTMuXG4qKiBUaGUgY29kZSBpcyBiYXNlZCBvbiBHTFUgbGlidGVzcyBieSBFcmljIFZlYWNoLCBKdWx5IDE5OTRcbiovXG5cblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0LyogUHVibGljIEFQSSAqL1xuXG5cdHZhciBUZXNzMiA9IHt9O1xuXG5cdG1vZHVsZS5leHBvcnRzID0gVGVzczI7XG5cdFxuXHRUZXNzMi5XSU5ESU5HX09ERCA9IDA7XG5cdFRlc3MyLldJTkRJTkdfTk9OWkVSTyA9IDE7XG5cdFRlc3MyLldJTkRJTkdfUE9TSVRJVkUgPSAyO1xuXHRUZXNzMi5XSU5ESU5HX05FR0FUSVZFID0gMztcblx0VGVzczIuV0lORElOR19BQlNfR0VRX1RXTyA9IDQ7XG5cblx0VGVzczIuUE9MWUdPTlMgPSAwO1xuXHRUZXNzMi5DT05ORUNURURfUE9MWUdPTlMgPSAxO1xuXHRUZXNzMi5CT1VOREFSWV9DT05UT1VSUyA9IDI7XG5cblx0VGVzczIudGVzc2VsYXRlID0gZnVuY3Rpb24ob3B0cykge1xuXHRcdHZhciBkZWJ1ZyA9ICBvcHRzLmRlYnVnIHx8IGZhbHNlO1xuXHRcdHZhciB0ZXNzID0gbmV3IFRlc3NlbGF0b3IoKTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG9wdHMuY29udG91cnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHRlc3MuYWRkQ29udG91cihvcHRzLnZlcnRleFNpemUgfHwgMiwgb3B0cy5jb250b3Vyc1tpXSk7XG5cdFx0fVxuXHRcdHRlc3MudGVzc2VsYXRlKG9wdHMud2luZGluZ1J1bGUgfHwgVGVzczIuV0lORElOR19PREQsXG5cdFx0XHRcdFx0ICAgb3B0cy5lbGVtZW50VHlwZSB8fCBUZXNzMi5QT0xZR09OUyxcblx0XHRcdFx0XHQgICBvcHRzLnBvbHlTaXplIHx8IDMsXG5cdFx0XHRcdFx0ICAgb3B0cy52ZXJ0ZXhTaXplIHx8IDIsXG5cdFx0XHRcdFx0ICAgb3B0cy5ub3JtYWwgfHwgWzAsMCwxXSk7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHZlcnRpY2VzOiB0ZXNzLnZlcnRpY2VzLFxuXHRcdFx0dmVydGV4SW5kaWNlczogdGVzcy52ZXJ0ZXhJbmRpY2VzLFxuXHRcdFx0dmVydGV4Q291bnQ6IHRlc3MudmVydGV4Q291bnQsXG5cdFx0XHRlbGVtZW50czogdGVzcy5lbGVtZW50cyxcblx0XHRcdGVsZW1lbnRDb3VudDogdGVzcy5lbGVtZW50Q291bnQsXG5cdFx0XHRtZXNoOiBkZWJ1ZyA/IHRlc3MubWVzaCA6IHVuZGVmaW5lZFxuXHRcdH07XG5cdH07XG5cblx0LyogSW50ZXJuYWwgKi9cblxuXHR2YXIgYXNzZXJ0ID0gZnVuY3Rpb24oY29uZCkge1xuXHRcdGlmICghY29uZCkge1xuXHRcdFx0dGhyb3cgXCJBc3NlcnRpb24gRmFpbGVkIVwiO1xuXHRcdH1cblx0fVxuXG5cdC8qIFRoZSBtZXNoIHN0cnVjdHVyZSBpcyBzaW1pbGFyIGluIHNwaXJpdCwgbm90YXRpb24sIGFuZCBvcGVyYXRpb25zXG5cdCogdG8gdGhlIFwicXVhZC1lZGdlXCIgc3RydWN0dXJlIChzZWUgTC4gR3VpYmFzIGFuZCBKLiBTdG9sZmksIFByaW1pdGl2ZXNcblx0KiBmb3IgdGhlIG1hbmlwdWxhdGlvbiBvZiBnZW5lcmFsIHN1YmRpdmlzaW9ucyBhbmQgdGhlIGNvbXB1dGF0aW9uIG9mXG5cdCogVm9yb25vaSBkaWFncmFtcywgQUNNIFRyYW5zYWN0aW9ucyBvbiBHcmFwaGljcywgNCgyKTo3NC0xMjMsIEFwcmlsIDE5ODUpLlxuXHQqIEZvciBhIHNpbXBsaWZpZWQgZGVzY3JpcHRpb24sIHNlZSB0aGUgY291cnNlIG5vdGVzIGZvciBDUzM0OGEsXG5cdCogXCJNYXRoZW1hdGljYWwgRm91bmRhdGlvbnMgb2YgQ29tcHV0ZXIgR3JhcGhpY3NcIiwgYXZhaWxhYmxlIGF0IHRoZVxuXHQqIFN0YW5mb3JkIGJvb2tzdG9yZSAoYW5kIHRhdWdodCBkdXJpbmcgdGhlIGZhbGwgcXVhcnRlcikuXG5cdCogVGhlIGltcGxlbWVudGF0aW9uIGFsc28gYm9ycm93cyBhIHRpbnkgc3Vic2V0IG9mIHRoZSBncmFwaC1iYXNlZCBhcHByb2FjaFxuXHQqIHVzZSBpbiBNYW50eWxhJ3MgR2VvbWV0cmljIFdvcmsgQmVuY2ggKHNlZSBNLiBNYW50eWxhLCBBbiBJbnRyb2R1Y3Rpb25cblx0KiB0byBTb2xkIE1vZGVsaW5nLCBDb21wdXRlciBTY2llbmNlIFByZXNzLCBSb2NrdmlsbGUsIE1hcnlsYW5kLCAxOTg4KS5cblx0KlxuXHQqIFRoZSBmdW5kYW1lbnRhbCBkYXRhIHN0cnVjdHVyZSBpcyB0aGUgXCJoYWxmLWVkZ2VcIi4gIFR3byBoYWxmLWVkZ2VzXG5cdCogZ28gdG9nZXRoZXIgdG8gbWFrZSBhbiBlZGdlLCBidXQgdGhleSBwb2ludCBpbiBvcHBvc2l0ZSBkaXJlY3Rpb25zLlxuXHQqIEVhY2ggaGFsZi1lZGdlIGhhcyBhIHBvaW50ZXIgdG8gaXRzIG1hdGUgKHRoZSBcInN5bW1ldHJpY1wiIGhhbGYtZWRnZSBTeW0pLFxuXHQqIGl0cyBvcmlnaW4gdmVydGV4IChPcmcpLCB0aGUgZmFjZSBvbiBpdHMgbGVmdCBzaWRlIChMZmFjZSksIGFuZCB0aGVcblx0KiBhZGphY2VudCBoYWxmLWVkZ2VzIGluIHRoZSBDQ1cgZGlyZWN0aW9uIGFyb3VuZCB0aGUgb3JpZ2luIHZlcnRleFxuXHQqIChPbmV4dCkgYW5kIGFyb3VuZCB0aGUgbGVmdCBmYWNlIChMbmV4dCkuICBUaGVyZSBpcyBhbHNvIGEgXCJuZXh0XCJcblx0KiBwb2ludGVyIGZvciB0aGUgZ2xvYmFsIGVkZ2UgbGlzdCAoc2VlIGJlbG93KS5cblx0KlxuXHQqIFRoZSBub3RhdGlvbiB1c2VkIGZvciBtZXNoIG5hdmlnYXRpb246XG5cdCogIFN5bSAgID0gdGhlIG1hdGUgb2YgYSBoYWxmLWVkZ2UgKHNhbWUgZWRnZSwgYnV0IG9wcG9zaXRlIGRpcmVjdGlvbilcblx0KiAgT25leHQgPSBlZGdlIENDVyBhcm91bmQgb3JpZ2luIHZlcnRleCAoa2VlcCBzYW1lIG9yaWdpbilcblx0KiAgRG5leHQgPSBlZGdlIENDVyBhcm91bmQgZGVzdGluYXRpb24gdmVydGV4IChrZWVwIHNhbWUgZGVzdClcblx0KiAgTG5leHQgPSBlZGdlIENDVyBhcm91bmQgbGVmdCBmYWNlIChkZXN0IGJlY29tZXMgbmV3IG9yaWdpbilcblx0KiAgUm5leHQgPSBlZGdlIENDVyBhcm91bmQgcmlnaHQgZmFjZSAob3JpZ2luIGJlY29tZXMgbmV3IGRlc3QpXG5cdCpcblx0KiBcInByZXZcIiBtZWFucyB0byBzdWJzdGl0dXRlIENXIGZvciBDQ1cgaW4gdGhlIGRlZmluaXRpb25zIGFib3ZlLlxuXHQqXG5cdCogVGhlIG1lc2gga2VlcHMgZ2xvYmFsIGxpc3RzIG9mIGFsbCB2ZXJ0aWNlcywgZmFjZXMsIGFuZCBlZGdlcyxcblx0KiBzdG9yZWQgYXMgZG91Ymx5LWxpbmtlZCBjaXJjdWxhciBsaXN0cyB3aXRoIGEgZHVtbXkgaGVhZGVyIG5vZGUuXG5cdCogVGhlIG1lc2ggc3RvcmVzIHBvaW50ZXJzIHRvIHRoZXNlIGR1bW15IGhlYWRlcnMgKHZIZWFkLCBmSGVhZCwgZUhlYWQpLlxuXHQqXG5cdCogVGhlIGNpcmN1bGFyIGVkZ2UgbGlzdCBpcyBzcGVjaWFsOyBzaW5jZSBoYWxmLWVkZ2VzIGFsd2F5cyBvY2N1clxuXHQqIGluIHBhaXJzIChlIGFuZCBlLT5TeW0pLCBlYWNoIGhhbGYtZWRnZSBzdG9yZXMgYSBwb2ludGVyIGluIG9ubHlcblx0KiBvbmUgZGlyZWN0aW9uLiAgU3RhcnRpbmcgYXQgZUhlYWQgYW5kIGZvbGxvd2luZyB0aGUgZS0+bmV4dCBwb2ludGVyc1xuXHQqIHdpbGwgdmlzaXQgZWFjaCAqZWRnZSogb25jZSAoaWUuIGUgb3IgZS0+U3ltLCBidXQgbm90IGJvdGgpLlxuXHQqIGUtPlN5bSBzdG9yZXMgYSBwb2ludGVyIGluIHRoZSBvcHBvc2l0ZSBkaXJlY3Rpb24sIHRodXMgaXQgaXNcblx0KiBhbHdheXMgdHJ1ZSB0aGF0IGUtPlN5bS0+bmV4dC0+U3ltLT5uZXh0ID09IGUuXG5cdCpcblx0KiBFYWNoIHZlcnRleCBoYXMgYSBwb2ludGVyIHRvIG5leHQgYW5kIHByZXZpb3VzIHZlcnRpY2VzIGluIHRoZVxuXHQqIGNpcmN1bGFyIGxpc3QsIGFuZCBhIHBvaW50ZXIgdG8gYSBoYWxmLWVkZ2Ugd2l0aCB0aGlzIHZlcnRleCBhc1xuXHQqIHRoZSBvcmlnaW4gKE5VTEwgaWYgdGhpcyBpcyB0aGUgZHVtbXkgaGVhZGVyKS4gIFRoZXJlIGlzIGFsc28gYVxuXHQqIGZpZWxkIFwiZGF0YVwiIGZvciBjbGllbnQgZGF0YS5cblx0KlxuXHQqIEVhY2ggZmFjZSBoYXMgYSBwb2ludGVyIHRvIHRoZSBuZXh0IGFuZCBwcmV2aW91cyBmYWNlcyBpbiB0aGVcblx0KiBjaXJjdWxhciBsaXN0LCBhbmQgYSBwb2ludGVyIHRvIGEgaGFsZi1lZGdlIHdpdGggdGhpcyBmYWNlIGFzXG5cdCogdGhlIGxlZnQgZmFjZSAoTlVMTCBpZiB0aGlzIGlzIHRoZSBkdW1teSBoZWFkZXIpLiAgVGhlcmUgaXMgYWxzb1xuXHQqIGEgZmllbGQgXCJkYXRhXCIgZm9yIGNsaWVudCBkYXRhLlxuXHQqXG5cdCogTm90ZSB0aGF0IHdoYXQgd2UgY2FsbCBhIFwiZmFjZVwiIGlzIHJlYWxseSBhIGxvb3A7IGZhY2VzIG1heSBjb25zaXN0XG5cdCogb2YgbW9yZSB0aGFuIG9uZSBsb29wIChpZS4gbm90IHNpbXBseSBjb25uZWN0ZWQpLCBidXQgdGhlcmUgaXMgbm9cblx0KiByZWNvcmQgb2YgdGhpcyBpbiB0aGUgZGF0YSBzdHJ1Y3R1cmUuICBUaGUgbWVzaCBtYXkgY29uc2lzdCBvZlxuXHQqIHNldmVyYWwgZGlzY29ubmVjdGVkIHJlZ2lvbnMsIHNvIGl0IG1heSBub3QgYmUgcG9zc2libGUgdG8gdmlzaXRcblx0KiB0aGUgZW50aXJlIG1lc2ggYnkgc3RhcnRpbmcgYXQgYSBoYWxmLWVkZ2UgYW5kIHRyYXZlcnNpbmcgdGhlIGVkZ2Vcblx0KiBzdHJ1Y3R1cmUuXG5cdCpcblx0KiBUaGUgbWVzaCBkb2VzIE5PVCBzdXBwb3J0IGlzb2xhdGVkIHZlcnRpY2VzOyBhIHZlcnRleCBpcyBkZWxldGVkIGFsb25nXG5cdCogd2l0aCBpdHMgbGFzdCBlZGdlLiAgU2ltaWxhcmx5IHdoZW4gdHdvIGZhY2VzIGFyZSBtZXJnZWQsIG9uZSBvZiB0aGVcblx0KiBmYWNlcyBpcyBkZWxldGVkIChzZWUgdGVzc01lc2hEZWxldGUgYmVsb3cpLiAgRm9yIG1lc2ggb3BlcmF0aW9ucyxcblx0KiBhbGwgZmFjZSAobG9vcCkgYW5kIHZlcnRleCBwb2ludGVycyBtdXN0IG5vdCBiZSBOVUxMLiAgSG93ZXZlciwgb25jZVxuXHQqIG1lc2ggbWFuaXB1bGF0aW9uIGlzIGZpbmlzaGVkLCBURVNTbWVzaFphcEZhY2UgY2FuIGJlIHVzZWQgdG8gZGVsZXRlXG5cdCogZmFjZXMgb2YgdGhlIG1lc2gsIG9uZSBhdCBhIHRpbWUuICBBbGwgZXh0ZXJuYWwgZmFjZXMgY2FuIGJlIFwiemFwcGVkXCJcblx0KiBiZWZvcmUgdGhlIG1lc2ggaXMgcmV0dXJuZWQgdG8gdGhlIGNsaWVudDsgdGhlbiBhIE5VTEwgZmFjZSBpbmRpY2F0ZXNcblx0KiBhIHJlZ2lvbiB3aGljaCBpcyBub3QgcGFydCBvZiB0aGUgb3V0cHV0IHBvbHlnb24uXG5cdCovXG5cblx0ZnVuY3Rpb24gVEVTU3ZlcnRleCgpIHtcblx0XHR0aGlzLm5leHQgPSBudWxsO1x0LyogbmV4dCB2ZXJ0ZXggKG5ldmVyIE5VTEwpICovXG5cdFx0dGhpcy5wcmV2ID0gbnVsbDtcdC8qIHByZXZpb3VzIHZlcnRleCAobmV2ZXIgTlVMTCkgKi9cblx0XHR0aGlzLmFuRWRnZSA9IG51bGw7XHQvKiBhIGhhbGYtZWRnZSB3aXRoIHRoaXMgb3JpZ2luICovXG5cblx0XHQvKiBJbnRlcm5hbCBkYXRhIChrZWVwIGhpZGRlbikgKi9cblx0XHR0aGlzLmNvb3JkcyA9IFswLDAsMF07XHQvKiB2ZXJ0ZXggbG9jYXRpb24gaW4gM0QgKi9cblx0XHR0aGlzLnMgPSAwLjA7XG5cdFx0dGhpcy50ID0gMC4wO1x0XHRcdC8qIHByb2plY3Rpb24gb250byB0aGUgc3dlZXAgcGxhbmUgKi9cblx0XHR0aGlzLnBxSGFuZGxlID0gMDtcdFx0LyogdG8gYWxsb3cgZGVsZXRpb24gZnJvbSBwcmlvcml0eSBxdWV1ZSAqL1xuXHRcdHRoaXMubiA9IDA7XHRcdFx0XHQvKiB0byBhbGxvdyBpZGVudGlmeSB1bmlxdWUgdmVydGljZXMgKi9cblx0XHR0aGlzLmlkeCA9IDA7XHRcdFx0LyogdG8gYWxsb3cgbWFwIHJlc3VsdCB0byBvcmlnaW5hbCB2ZXJ0cyAqL1xuXHR9IFxuXG5cdGZ1bmN0aW9uIFRFU1NmYWNlKCkge1xuXHRcdHRoaXMubmV4dCA9IG51bGw7XHRcdC8qIG5leHQgZmFjZSAobmV2ZXIgTlVMTCkgKi9cblx0XHR0aGlzLnByZXYgPSBudWxsO1x0XHQvKiBwcmV2aW91cyBmYWNlIChuZXZlciBOVUxMKSAqL1xuXHRcdHRoaXMuYW5FZGdlID0gbnVsbDtcdFx0LyogYSBoYWxmIGVkZ2Ugd2l0aCB0aGlzIGxlZnQgZmFjZSAqL1xuXG5cdFx0LyogSW50ZXJuYWwgZGF0YSAoa2VlcCBoaWRkZW4pICovXG5cdFx0dGhpcy50cmFpbCA9IG51bGw7XHRcdC8qIFwic3RhY2tcIiBmb3IgY29udmVyc2lvbiB0byBzdHJpcHMgKi9cblx0XHR0aGlzLm4gPSAwO1x0XHRcdFx0LyogdG8gYWxsb3cgaWRlbnRpeSB1bmlxdWUgZmFjZXMgKi9cblx0XHR0aGlzLm1hcmtlZCA9IGZhbHNlO1x0LyogZmxhZyBmb3IgY29udmVyc2lvbiB0byBzdHJpcHMgKi9cblx0XHR0aGlzLmluc2lkZSA9IGZhbHNlO1x0LyogdGhpcyBmYWNlIGlzIGluIHRoZSBwb2x5Z29uIGludGVyaW9yICovXG5cdH07XG5cblx0ZnVuY3Rpb24gVEVTU2hhbGZFZGdlKHNpZGUpIHtcblx0XHR0aGlzLm5leHQgPSBudWxsO1x0XHQvKiBkb3VibHktbGlua2VkIGxpc3QgKHByZXY9PVN5bS0+bmV4dCkgKi9cblx0XHR0aGlzLlN5bSA9IG51bGw7XHRcdC8qIHNhbWUgZWRnZSwgb3Bwb3NpdGUgZGlyZWN0aW9uICovXG5cdFx0dGhpcy5PbmV4dCA9IG51bGw7XHRcdC8qIG5leHQgZWRnZSBDQ1cgYXJvdW5kIG9yaWdpbiAqL1xuXHRcdHRoaXMuTG5leHQgPSBudWxsO1x0XHQvKiBuZXh0IGVkZ2UgQ0NXIGFyb3VuZCBsZWZ0IGZhY2UgKi9cblx0XHR0aGlzLk9yZyA9IG51bGw7XHRcdC8qIG9yaWdpbiB2ZXJ0ZXggKE92ZXJ0ZXggdG9vIGxvbmcpICovXG5cdFx0dGhpcy5MZmFjZSA9IG51bGw7XHRcdC8qIGxlZnQgZmFjZSAqL1xuXG5cdFx0LyogSW50ZXJuYWwgZGF0YSAoa2VlcCBoaWRkZW4pICovXG5cdFx0dGhpcy5hY3RpdmVSZWdpb24gPSBudWxsO1x0LyogYSByZWdpb24gd2l0aCB0aGlzIHVwcGVyIGVkZ2UgKHN3ZWVwLmMpICovXG5cdFx0dGhpcy53aW5kaW5nID0gMDtcdFx0XHQvKiBjaGFuZ2UgaW4gd2luZGluZyBudW1iZXIgd2hlbiBjcm9zc2luZ1xuXHRcdFx0XHRcdFx0XHRcdFx0ICAgZnJvbSB0aGUgcmlnaHQgZmFjZSB0byB0aGUgbGVmdCBmYWNlICovXG5cdFx0dGhpcy5zaWRlID0gc2lkZTtcblx0fTtcblxuXHRURVNTaGFsZkVkZ2UucHJvdG90eXBlID0ge1xuXHRcdGdldCBSZmFjZSgpIHsgcmV0dXJuIHRoaXMuU3ltLkxmYWNlOyB9LFxuXHRcdHNldCBSZmFjZSh2KSB7IHRoaXMuU3ltLkxmYWNlID0gdjsgfSxcblx0XHRnZXQgRHN0KCkgeyByZXR1cm4gdGhpcy5TeW0uT3JnOyB9LFxuXHRcdHNldCBEc3QodikgeyB0aGlzLlN5bS5PcmcgPSB2OyB9LFxuXHRcdGdldCBPcHJldigpIHsgcmV0dXJuIHRoaXMuU3ltLkxuZXh0OyB9LFxuXHRcdHNldCBPcHJldih2KSB7IHRoaXMuU3ltLkxuZXh0ID0gdjsgfSxcblx0XHRnZXQgTHByZXYoKSB7IHJldHVybiB0aGlzLk9uZXh0LlN5bTsgfSxcblx0XHRzZXQgTHByZXYodikgeyB0aGlzLk9uZXh0LlN5bSA9IHY7IH0sXG5cdFx0Z2V0IERwcmV2KCkgeyByZXR1cm4gdGhpcy5MbmV4dC5TeW07IH0sXG5cdFx0c2V0IERwcmV2KHYpIHsgdGhpcy5MbmV4dC5TeW0gPSB2OyB9LFxuXHRcdGdldCBScHJldigpIHsgcmV0dXJuIHRoaXMuU3ltLk9uZXh0OyB9LFxuXHRcdHNldCBScHJldih2KSB7IHRoaXMuU3ltLk9uZXh0ID0gdjsgfSxcblx0XHRnZXQgRG5leHQoKSB7IHJldHVybiAvKnRoaXMuUnByZXYqL3RoaXMuU3ltLk9uZXh0LlN5bTsgfSwgIC8qIDMgcG9pbnRlcnMgKi9cblx0XHRzZXQgRG5leHQodikgeyAvKnRoaXMuUnByZXYqL3RoaXMuU3ltLk9uZXh0LlN5bSA9IHY7IH0sICAvKiAzIHBvaW50ZXJzICovXG5cdFx0Z2V0IFJuZXh0KCkgeyByZXR1cm4gLyp0aGlzLk9wcmV2Ki90aGlzLlN5bS5MbmV4dC5TeW07IH0sICAvKiAzIHBvaW50ZXJzICovXG5cdFx0c2V0IFJuZXh0KHYpIHsgLyp0aGlzLk9wcmV2Ki90aGlzLlN5bS5MbmV4dC5TeW0gPSB2OyB9LCAgLyogMyBwb2ludGVycyAqL1xuXHR9O1xuXG5cblxuXHRmdW5jdGlvbiBURVNTbWVzaCgpIHtcblx0XHR2YXIgdiA9IG5ldyBURVNTdmVydGV4KCk7XG5cdFx0dmFyIGYgPSBuZXcgVEVTU2ZhY2UoKTtcblx0XHR2YXIgZSA9IG5ldyBURVNTaGFsZkVkZ2UoMCk7XG5cdFx0dmFyIGVTeW0gPSBuZXcgVEVTU2hhbGZFZGdlKDEpO1xuXG5cdFx0di5uZXh0ID0gdi5wcmV2ID0gdjtcblx0XHR2LmFuRWRnZSA9IG51bGw7XG5cblx0XHRmLm5leHQgPSBmLnByZXYgPSBmO1xuXHRcdGYuYW5FZGdlID0gbnVsbDtcblx0XHRmLnRyYWlsID0gbnVsbDtcblx0XHRmLm1hcmtlZCA9IGZhbHNlO1xuXHRcdGYuaW5zaWRlID0gZmFsc2U7XG5cblx0XHRlLm5leHQgPSBlO1xuXHRcdGUuU3ltID0gZVN5bTtcblx0XHRlLk9uZXh0ID0gbnVsbDtcblx0XHRlLkxuZXh0ID0gbnVsbDtcblx0XHRlLk9yZyA9IG51bGw7XG5cdFx0ZS5MZmFjZSA9IG51bGw7XG5cdFx0ZS53aW5kaW5nID0gMDtcblx0XHRlLmFjdGl2ZVJlZ2lvbiA9IG51bGw7XG5cblx0XHRlU3ltLm5leHQgPSBlU3ltO1xuXHRcdGVTeW0uU3ltID0gZTtcblx0XHRlU3ltLk9uZXh0ID0gbnVsbDtcblx0XHRlU3ltLkxuZXh0ID0gbnVsbDtcblx0XHRlU3ltLk9yZyA9IG51bGw7XG5cdFx0ZVN5bS5MZmFjZSA9IG51bGw7XG5cdFx0ZVN5bS53aW5kaW5nID0gMDtcblx0XHRlU3ltLmFjdGl2ZVJlZ2lvbiA9IG51bGw7XG5cblx0XHR0aGlzLnZIZWFkID0gdjtcdFx0LyogZHVtbXkgaGVhZGVyIGZvciB2ZXJ0ZXggbGlzdCAqL1xuXHRcdHRoaXMuZkhlYWQgPSBmO1x0XHQvKiBkdW1teSBoZWFkZXIgZm9yIGZhY2UgbGlzdCAqL1xuXHRcdHRoaXMuZUhlYWQgPSBlO1x0XHQvKiBkdW1teSBoZWFkZXIgZm9yIGVkZ2UgbGlzdCAqL1xuXHRcdHRoaXMuZUhlYWRTeW0gPSBlU3ltO1x0LyogYW5kIGl0cyBzeW1tZXRyaWMgY291bnRlcnBhcnQgKi9cblx0fTtcblxuXHQvKiBUaGUgbWVzaCBvcGVyYXRpb25zIGJlbG93IGhhdmUgdGhyZWUgbW90aXZhdGlvbnM6IGNvbXBsZXRlbmVzcyxcblx0KiBjb252ZW5pZW5jZSwgYW5kIGVmZmljaWVuY3kuICBUaGUgYmFzaWMgbWVzaCBvcGVyYXRpb25zIGFyZSBNYWtlRWRnZSxcblx0KiBTcGxpY2UsIGFuZCBEZWxldGUuICBBbGwgdGhlIG90aGVyIGVkZ2Ugb3BlcmF0aW9ucyBjYW4gYmUgaW1wbGVtZW50ZWRcblx0KiBpbiB0ZXJtcyBvZiB0aGVzZS4gIFRoZSBvdGhlciBvcGVyYXRpb25zIGFyZSBwcm92aWRlZCBmb3IgY29udmVuaWVuY2Vcblx0KiBhbmQvb3IgZWZmaWNpZW5jeS5cblx0KlxuXHQqIFdoZW4gYSBmYWNlIGlzIHNwbGl0IG9yIGEgdmVydGV4IGlzIGFkZGVkLCB0aGV5IGFyZSBpbnNlcnRlZCBpbnRvIHRoZVxuXHQqIGdsb2JhbCBsaXN0ICpiZWZvcmUqIHRoZSBleGlzdGluZyB2ZXJ0ZXggb3IgZmFjZSAoaWUuIGUtPk9yZyBvciBlLT5MZmFjZSkuXG5cdCogVGhpcyBtYWtlcyBpdCBlYXNpZXIgdG8gcHJvY2VzcyBhbGwgdmVydGljZXMgb3IgZmFjZXMgaW4gdGhlIGdsb2JhbCBsaXN0c1xuXHQqIHdpdGhvdXQgd29ycnlpbmcgYWJvdXQgcHJvY2Vzc2luZyB0aGUgc2FtZSBkYXRhIHR3aWNlLiAgQXMgYSBjb252ZW5pZW5jZSxcblx0KiB3aGVuIGEgZmFjZSBpcyBzcGxpdCwgdGhlIFwiaW5zaWRlXCIgZmxhZyBpcyBjb3BpZWQgZnJvbSB0aGUgb2xkIGZhY2UuXG5cdCogT3RoZXIgaW50ZXJuYWwgZGF0YSAodi0+ZGF0YSwgdi0+YWN0aXZlUmVnaW9uLCBmLT5kYXRhLCBmLT5tYXJrZWQsXG5cdCogZi0+dHJhaWwsIGUtPndpbmRpbmcpIGlzIHNldCB0byB6ZXJvLlxuXHQqXG5cdCogKioqKioqKioqKioqKioqKioqKioqKiBCYXNpYyBFZGdlIE9wZXJhdGlvbnMgKioqKioqKioqKioqKioqKioqKioqKioqKipcblx0KlxuXHQqIHRlc3NNZXNoTWFrZUVkZ2UoIG1lc2ggKSBjcmVhdGVzIG9uZSBlZGdlLCB0d28gdmVydGljZXMsIGFuZCBhIGxvb3AuXG5cdCogVGhlIGxvb3AgKGZhY2UpIGNvbnNpc3RzIG9mIHRoZSB0d28gbmV3IGhhbGYtZWRnZXMuXG5cdCpcblx0KiB0ZXNzTWVzaFNwbGljZSggZU9yZywgZURzdCApIGlzIHRoZSBiYXNpYyBvcGVyYXRpb24gZm9yIGNoYW5naW5nIHRoZVxuXHQqIG1lc2ggY29ubmVjdGl2aXR5IGFuZCB0b3BvbG9neS4gIEl0IGNoYW5nZXMgdGhlIG1lc2ggc28gdGhhdFxuXHQqICBlT3JnLT5PbmV4dCA8LSBPTEQoIGVEc3QtPk9uZXh0IClcblx0KiAgZURzdC0+T25leHQgPC0gT0xEKCBlT3JnLT5PbmV4dCApXG5cdCogd2hlcmUgT0xEKC4uLikgbWVhbnMgdGhlIHZhbHVlIGJlZm9yZSB0aGUgbWVzaFNwbGljZSBvcGVyYXRpb24uXG5cdCpcblx0KiBUaGlzIGNhbiBoYXZlIHR3byBlZmZlY3RzIG9uIHRoZSB2ZXJ0ZXggc3RydWN0dXJlOlxuXHQqICAtIGlmIGVPcmctPk9yZyAhPSBlRHN0LT5PcmcsIHRoZSB0d28gdmVydGljZXMgYXJlIG1lcmdlZCB0b2dldGhlclxuXHQqICAtIGlmIGVPcmctPk9yZyA9PSBlRHN0LT5PcmcsIHRoZSBvcmlnaW4gaXMgc3BsaXQgaW50byB0d28gdmVydGljZXNcblx0KiBJbiBib3RoIGNhc2VzLCBlRHN0LT5PcmcgaXMgY2hhbmdlZCBhbmQgZU9yZy0+T3JnIGlzIHVudG91Y2hlZC5cblx0KlxuXHQqIFNpbWlsYXJseSAoYW5kIGluZGVwZW5kZW50bHkpIGZvciB0aGUgZmFjZSBzdHJ1Y3R1cmUsXG5cdCogIC0gaWYgZU9yZy0+TGZhY2UgPT0gZURzdC0+TGZhY2UsIG9uZSBsb29wIGlzIHNwbGl0IGludG8gdHdvXG5cdCogIC0gaWYgZU9yZy0+TGZhY2UgIT0gZURzdC0+TGZhY2UsIHR3byBkaXN0aW5jdCBsb29wcyBhcmUgam9pbmVkIGludG8gb25lXG5cdCogSW4gYm90aCBjYXNlcywgZURzdC0+TGZhY2UgaXMgY2hhbmdlZCBhbmQgZU9yZy0+TGZhY2UgaXMgdW5hZmZlY3RlZC5cblx0KlxuXHQqIHRlc3NNZXNoRGVsZXRlKCBlRGVsICkgcmVtb3ZlcyB0aGUgZWRnZSBlRGVsLiAgVGhlcmUgYXJlIHNldmVyYWwgY2FzZXM6XG5cdCogaWYgKGVEZWwtPkxmYWNlICE9IGVEZWwtPlJmYWNlKSwgd2Ugam9pbiB0d28gbG9vcHMgaW50byBvbmU7IHRoZSBsb29wXG5cdCogZURlbC0+TGZhY2UgaXMgZGVsZXRlZC4gIE90aGVyd2lzZSwgd2UgYXJlIHNwbGl0dGluZyBvbmUgbG9vcCBpbnRvIHR3bztcblx0KiB0aGUgbmV3bHkgY3JlYXRlZCBsb29wIHdpbGwgY29udGFpbiBlRGVsLT5Ec3QuICBJZiB0aGUgZGVsZXRpb24gb2YgZURlbFxuXHQqIHdvdWxkIGNyZWF0ZSBpc29sYXRlZCB2ZXJ0aWNlcywgdGhvc2UgYXJlIGRlbGV0ZWQgYXMgd2VsbC5cblx0KlxuXHQqICoqKioqKioqKioqKioqKioqKioqKiogT3RoZXIgRWRnZSBPcGVyYXRpb25zICoqKioqKioqKioqKioqKioqKioqKioqKioqXG5cdCpcblx0KiB0ZXNzTWVzaEFkZEVkZ2VWZXJ0ZXgoIGVPcmcgKSBjcmVhdGVzIGEgbmV3IGVkZ2UgZU5ldyBzdWNoIHRoYXRcblx0KiBlTmV3ID09IGVPcmctPkxuZXh0LCBhbmQgZU5ldy0+RHN0IGlzIGEgbmV3bHkgY3JlYXRlZCB2ZXJ0ZXguXG5cdCogZU9yZyBhbmQgZU5ldyB3aWxsIGhhdmUgdGhlIHNhbWUgbGVmdCBmYWNlLlxuXHQqXG5cdCogdGVzc01lc2hTcGxpdEVkZ2UoIGVPcmcgKSBzcGxpdHMgZU9yZyBpbnRvIHR3byBlZGdlcyBlT3JnIGFuZCBlTmV3LFxuXHQqIHN1Y2ggdGhhdCBlTmV3ID09IGVPcmctPkxuZXh0LiAgVGhlIG5ldyB2ZXJ0ZXggaXMgZU9yZy0+RHN0ID09IGVOZXctPk9yZy5cblx0KiBlT3JnIGFuZCBlTmV3IHdpbGwgaGF2ZSB0aGUgc2FtZSBsZWZ0IGZhY2UuXG5cdCpcblx0KiB0ZXNzTWVzaENvbm5lY3QoIGVPcmcsIGVEc3QgKSBjcmVhdGVzIGEgbmV3IGVkZ2UgZnJvbSBlT3JnLT5Ec3Rcblx0KiB0byBlRHN0LT5PcmcsIGFuZCByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIGhhbGYtZWRnZSBlTmV3LlxuXHQqIElmIGVPcmctPkxmYWNlID09IGVEc3QtPkxmYWNlLCB0aGlzIHNwbGl0cyBvbmUgbG9vcCBpbnRvIHR3byxcblx0KiBhbmQgdGhlIG5ld2x5IGNyZWF0ZWQgbG9vcCBpcyBlTmV3LT5MZmFjZS4gIE90aGVyd2lzZSwgdHdvIGRpc2pvaW50XG5cdCogbG9vcHMgYXJlIG1lcmdlZCBpbnRvIG9uZSwgYW5kIHRoZSBsb29wIGVEc3QtPkxmYWNlIGlzIGRlc3Ryb3llZC5cblx0KlxuXHQqICoqKioqKioqKioqKioqKioqKioqKioqKiBPdGhlciBPcGVyYXRpb25zICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cdCpcblx0KiB0ZXNzTWVzaE5ld01lc2goKSBjcmVhdGVzIGEgbmV3IG1lc2ggd2l0aCBubyBlZGdlcywgbm8gdmVydGljZXMsXG5cdCogYW5kIG5vIGxvb3BzICh3aGF0IHdlIHVzdWFsbHkgY2FsbCBhIFwiZmFjZVwiKS5cblx0KlxuXHQqIHRlc3NNZXNoVW5pb24oIG1lc2gxLCBtZXNoMiApIGZvcm1zIHRoZSB1bmlvbiBvZiBhbGwgc3RydWN0dXJlcyBpblxuXHQqIGJvdGggbWVzaGVzLCBhbmQgcmV0dXJucyB0aGUgbmV3IG1lc2ggKHRoZSBvbGQgbWVzaGVzIGFyZSBkZXN0cm95ZWQpLlxuXHQqXG5cdCogdGVzc01lc2hEZWxldGVNZXNoKCBtZXNoICkgd2lsbCBmcmVlIGFsbCBzdG9yYWdlIGZvciBhbnkgdmFsaWQgbWVzaC5cblx0KlxuXHQqIHRlc3NNZXNoWmFwRmFjZSggZlphcCApIGRlc3Ryb3lzIGEgZmFjZSBhbmQgcmVtb3ZlcyBpdCBmcm9tIHRoZVxuXHQqIGdsb2JhbCBmYWNlIGxpc3QuICBBbGwgZWRnZXMgb2YgZlphcCB3aWxsIGhhdmUgYSBOVUxMIHBvaW50ZXIgYXMgdGhlaXJcblx0KiBsZWZ0IGZhY2UuICBBbnkgZWRnZXMgd2hpY2ggYWxzbyBoYXZlIGEgTlVMTCBwb2ludGVyIGFzIHRoZWlyIHJpZ2h0IGZhY2Vcblx0KiBhcmUgZGVsZXRlZCBlbnRpcmVseSAoYWxvbmcgd2l0aCBhbnkgaXNvbGF0ZWQgdmVydGljZXMgdGhpcyBwcm9kdWNlcykuXG5cdCogQW4gZW50aXJlIG1lc2ggY2FuIGJlIGRlbGV0ZWQgYnkgemFwcGluZyBpdHMgZmFjZXMsIG9uZSBhdCBhIHRpbWUsXG5cdCogaW4gYW55IG9yZGVyLiAgWmFwcGVkIGZhY2VzIGNhbm5vdCBiZSB1c2VkIGluIGZ1cnRoZXIgbWVzaCBvcGVyYXRpb25zIVxuXHQqXG5cdCogdGVzc01lc2hDaGVja01lc2goIG1lc2ggKSBjaGVja3MgYSBtZXNoIGZvciBzZWxmLWNvbnNpc3RlbmN5LlxuXHQqL1xuXG5cdFRFU1NtZXNoLnByb3RvdHlwZSA9IHtcblxuXHRcdC8qIE1ha2VFZGdlIGNyZWF0ZXMgYSBuZXcgcGFpciBvZiBoYWxmLWVkZ2VzIHdoaWNoIGZvcm0gdGhlaXIgb3duIGxvb3AuXG5cdFx0KiBObyB2ZXJ0ZXggb3IgZmFjZSBzdHJ1Y3R1cmVzIGFyZSBhbGxvY2F0ZWQsIGJ1dCB0aGVzZSBtdXN0IGJlIGFzc2lnbmVkXG5cdFx0KiBiZWZvcmUgdGhlIGN1cnJlbnQgZWRnZSBvcGVyYXRpb24gaXMgY29tcGxldGVkLlxuXHRcdCovXG5cdFx0Ly9zdGF0aWMgVEVTU2hhbGZFZGdlICpNYWtlRWRnZSggVEVTU21lc2gqIG1lc2gsIFRFU1NoYWxmRWRnZSAqZU5leHQgKVxuXHRcdG1ha2VFZGdlXzogZnVuY3Rpb24oZU5leHQpIHtcblx0XHRcdHZhciBlID0gbmV3IFRFU1NoYWxmRWRnZSgwKTtcblx0XHRcdHZhciBlU3ltID0gbmV3IFRFU1NoYWxmRWRnZSgxKTtcblxuXHRcdFx0LyogTWFrZSBzdXJlIGVOZXh0IHBvaW50cyB0byB0aGUgZmlyc3QgZWRnZSBvZiB0aGUgZWRnZSBwYWlyICovXG5cdFx0XHRpZiggZU5leHQuU3ltLnNpZGUgPCBlTmV4dC5zaWRlICkgeyBlTmV4dCA9IGVOZXh0LlN5bTsgfVxuXG5cdFx0XHQvKiBJbnNlcnQgaW4gY2lyY3VsYXIgZG91Ymx5LWxpbmtlZCBsaXN0IGJlZm9yZSBlTmV4dC5cblx0XHRcdCogTm90ZSB0aGF0IHRoZSBwcmV2IHBvaW50ZXIgaXMgc3RvcmVkIGluIFN5bS0+bmV4dC5cblx0XHRcdCovXG5cdFx0XHR2YXIgZVByZXYgPSBlTmV4dC5TeW0ubmV4dDtcblx0XHRcdGVTeW0ubmV4dCA9IGVQcmV2O1xuXHRcdFx0ZVByZXYuU3ltLm5leHQgPSBlO1xuXHRcdFx0ZS5uZXh0ID0gZU5leHQ7XG5cdFx0XHRlTmV4dC5TeW0ubmV4dCA9IGVTeW07XG5cblx0XHRcdGUuU3ltID0gZVN5bTtcblx0XHRcdGUuT25leHQgPSBlO1xuXHRcdFx0ZS5MbmV4dCA9IGVTeW07XG5cdFx0XHRlLk9yZyA9IG51bGw7XG5cdFx0XHRlLkxmYWNlID0gbnVsbDtcblx0XHRcdGUud2luZGluZyA9IDA7XG5cdFx0XHRlLmFjdGl2ZVJlZ2lvbiA9IG51bGw7XG5cblx0XHRcdGVTeW0uU3ltID0gZTtcblx0XHRcdGVTeW0uT25leHQgPSBlU3ltO1xuXHRcdFx0ZVN5bS5MbmV4dCA9IGU7XG5cdFx0XHRlU3ltLk9yZyA9IG51bGw7XG5cdFx0XHRlU3ltLkxmYWNlID0gbnVsbDtcblx0XHRcdGVTeW0ud2luZGluZyA9IDA7XG5cdFx0XHRlU3ltLmFjdGl2ZVJlZ2lvbiA9IG51bGw7XG5cblx0XHRcdHJldHVybiBlO1xuXHRcdH0sXG5cblx0XHQvKiBTcGxpY2UoIGEsIGIgKSBpcyBiZXN0IGRlc2NyaWJlZCBieSB0aGUgR3VpYmFzL1N0b2xmaSBwYXBlciBvciB0aGVcblx0XHQqIENTMzQ4YSBub3RlcyAoc2VlIG1lc2guaCkuICBCYXNpY2FsbHkgaXQgbW9kaWZpZXMgdGhlIG1lc2ggc28gdGhhdFxuXHRcdCogYS0+T25leHQgYW5kIGItPk9uZXh0IGFyZSBleGNoYW5nZWQuICBUaGlzIGNhbiBoYXZlIHZhcmlvdXMgZWZmZWN0c1xuXHRcdCogZGVwZW5kaW5nIG9uIHdoZXRoZXIgYSBhbmQgYiBiZWxvbmcgdG8gZGlmZmVyZW50IGZhY2Ugb3IgdmVydGV4IHJpbmdzLlxuXHRcdCogRm9yIG1vcmUgZXhwbGFuYXRpb24gc2VlIHRlc3NNZXNoU3BsaWNlKCkgYmVsb3cuXG5cdFx0Ki9cblx0XHQvLyBzdGF0aWMgdm9pZCBTcGxpY2UoIFRFU1NoYWxmRWRnZSAqYSwgVEVTU2hhbGZFZGdlICpiIClcblx0XHRzcGxpY2VfOiBmdW5jdGlvbihhLCBiKSB7XG5cdFx0XHR2YXIgYU9uZXh0ID0gYS5PbmV4dDtcblx0XHRcdHZhciBiT25leHQgPSBiLk9uZXh0O1xuXHRcdFx0YU9uZXh0LlN5bS5MbmV4dCA9IGI7XG5cdFx0XHRiT25leHQuU3ltLkxuZXh0ID0gYTtcblx0XHRcdGEuT25leHQgPSBiT25leHQ7XG5cdFx0XHRiLk9uZXh0ID0gYU9uZXh0O1xuXHRcdH0sXG5cblx0XHQvKiBNYWtlVmVydGV4KCBuZXdWZXJ0ZXgsIGVPcmlnLCB2TmV4dCApIGF0dGFjaGVzIGEgbmV3IHZlcnRleCBhbmQgbWFrZXMgaXQgdGhlXG5cdFx0KiBvcmlnaW4gb2YgYWxsIGVkZ2VzIGluIHRoZSB2ZXJ0ZXggbG9vcCB0byB3aGljaCBlT3JpZyBiZWxvbmdzLiBcInZOZXh0XCIgZ2l2ZXNcblx0XHQqIGEgcGxhY2UgdG8gaW5zZXJ0IHRoZSBuZXcgdmVydGV4IGluIHRoZSBnbG9iYWwgdmVydGV4IGxpc3QuICBXZSBpbnNlcnRcblx0XHQqIHRoZSBuZXcgdmVydGV4ICpiZWZvcmUqIHZOZXh0IHNvIHRoYXQgYWxnb3JpdGhtcyB3aGljaCB3YWxrIHRoZSB2ZXJ0ZXhcblx0XHQqIGxpc3Qgd2lsbCBub3Qgc2VlIHRoZSBuZXdseSBjcmVhdGVkIHZlcnRpY2VzLlxuXHRcdCovXG5cdFx0Ly9zdGF0aWMgdm9pZCBNYWtlVmVydGV4KCBURVNTdmVydGV4ICpuZXdWZXJ0ZXgsIFRFU1NoYWxmRWRnZSAqZU9yaWcsIFRFU1N2ZXJ0ZXggKnZOZXh0IClcblx0XHRtYWtlVmVydGV4XzogZnVuY3Rpb24obmV3VmVydGV4LCBlT3JpZywgdk5leHQpIHtcblx0XHRcdHZhciB2TmV3ID0gbmV3VmVydGV4O1xuXHRcdFx0YXNzZXJ0KHZOZXcgIT09IG51bGwpO1xuXG5cdFx0XHQvKiBpbnNlcnQgaW4gY2lyY3VsYXIgZG91Ymx5LWxpbmtlZCBsaXN0IGJlZm9yZSB2TmV4dCAqL1xuXHRcdFx0dmFyIHZQcmV2ID0gdk5leHQucHJldjtcblx0XHRcdHZOZXcucHJldiA9IHZQcmV2O1xuXHRcdFx0dlByZXYubmV4dCA9IHZOZXc7XG5cdFx0XHR2TmV3Lm5leHQgPSB2TmV4dDtcblx0XHRcdHZOZXh0LnByZXYgPSB2TmV3O1xuXG5cdFx0XHR2TmV3LmFuRWRnZSA9IGVPcmlnO1xuXHRcdFx0LyogbGVhdmUgY29vcmRzLCBzLCB0IHVuZGVmaW5lZCAqL1xuXG5cdFx0XHQvKiBmaXggb3RoZXIgZWRnZXMgb24gdGhpcyB2ZXJ0ZXggbG9vcCAqL1xuXHRcdFx0dmFyIGUgPSBlT3JpZztcblx0XHRcdGRvIHtcblx0XHRcdFx0ZS5PcmcgPSB2TmV3O1xuXHRcdFx0XHRlID0gZS5PbmV4dDtcblx0XHRcdH0gd2hpbGUoZSAhPT0gZU9yaWcpO1xuXHRcdH0sXG5cblx0XHQvKiBNYWtlRmFjZSggbmV3RmFjZSwgZU9yaWcsIGZOZXh0ICkgYXR0YWNoZXMgYSBuZXcgZmFjZSBhbmQgbWFrZXMgaXQgdGhlIGxlZnRcblx0XHQqIGZhY2Ugb2YgYWxsIGVkZ2VzIGluIHRoZSBmYWNlIGxvb3AgdG8gd2hpY2ggZU9yaWcgYmVsb25ncy4gIFwiZk5leHRcIiBnaXZlc1xuXHRcdCogYSBwbGFjZSB0byBpbnNlcnQgdGhlIG5ldyBmYWNlIGluIHRoZSBnbG9iYWwgZmFjZSBsaXN0LiAgV2UgaW5zZXJ0XG5cdFx0KiB0aGUgbmV3IGZhY2UgKmJlZm9yZSogZk5leHQgc28gdGhhdCBhbGdvcml0aG1zIHdoaWNoIHdhbGsgdGhlIGZhY2Vcblx0XHQqIGxpc3Qgd2lsbCBub3Qgc2VlIHRoZSBuZXdseSBjcmVhdGVkIGZhY2VzLlxuXHRcdCovXG5cdFx0Ly8gc3RhdGljIHZvaWQgTWFrZUZhY2UoIFRFU1NmYWNlICpuZXdGYWNlLCBURVNTaGFsZkVkZ2UgKmVPcmlnLCBURVNTZmFjZSAqZk5leHQgKVxuXHRcdG1ha2VGYWNlXzogZnVuY3Rpb24obmV3RmFjZSwgZU9yaWcsIGZOZXh0KSB7XG5cdFx0XHR2YXIgZk5ldyA9IG5ld0ZhY2U7XG5cdFx0XHRhc3NlcnQoZk5ldyAhPT0gbnVsbCk7IFxuXG5cdFx0XHQvKiBpbnNlcnQgaW4gY2lyY3VsYXIgZG91Ymx5LWxpbmtlZCBsaXN0IGJlZm9yZSBmTmV4dCAqL1xuXHRcdFx0dmFyIGZQcmV2ID0gZk5leHQucHJldjtcblx0XHRcdGZOZXcucHJldiA9IGZQcmV2O1xuXHRcdFx0ZlByZXYubmV4dCA9IGZOZXc7XG5cdFx0XHRmTmV3Lm5leHQgPSBmTmV4dDtcblx0XHRcdGZOZXh0LnByZXYgPSBmTmV3O1xuXG5cdFx0XHRmTmV3LmFuRWRnZSA9IGVPcmlnO1xuXHRcdFx0Zk5ldy50cmFpbCA9IG51bGw7XG5cdFx0XHRmTmV3Lm1hcmtlZCA9IGZhbHNlO1xuXG5cdFx0XHQvKiBUaGUgbmV3IGZhY2UgaXMgbWFya2VkIFwiaW5zaWRlXCIgaWYgdGhlIG9sZCBvbmUgd2FzLiAgVGhpcyBpcyBhXG5cdFx0XHQqIGNvbnZlbmllbmNlIGZvciB0aGUgY29tbW9uIGNhc2Ugd2hlcmUgYSBmYWNlIGhhcyBiZWVuIHNwbGl0IGluIHR3by5cblx0XHRcdCovXG5cdFx0XHRmTmV3Lmluc2lkZSA9IGZOZXh0Lmluc2lkZTtcblxuXHRcdFx0LyogZml4IG90aGVyIGVkZ2VzIG9uIHRoaXMgZmFjZSBsb29wICovXG5cdFx0XHR2YXIgZSA9IGVPcmlnO1xuXHRcdFx0ZG8ge1xuXHRcdFx0XHRlLkxmYWNlID0gZk5ldztcblx0XHRcdFx0ZSA9IGUuTG5leHQ7XG5cdFx0XHR9IHdoaWxlKGUgIT09IGVPcmlnKTtcblx0XHR9LFxuXG5cdFx0LyogS2lsbEVkZ2UoIGVEZWwgKSBkZXN0cm95cyBhbiBlZGdlICh0aGUgaGFsZi1lZGdlcyBlRGVsIGFuZCBlRGVsLT5TeW0pLFxuXHRcdCogYW5kIHJlbW92ZXMgZnJvbSB0aGUgZ2xvYmFsIGVkZ2UgbGlzdC5cblx0XHQqL1xuXHRcdC8vc3RhdGljIHZvaWQgS2lsbEVkZ2UoIFRFU1NtZXNoICptZXNoLCBURVNTaGFsZkVkZ2UgKmVEZWwgKVxuXHRcdGtpbGxFZGdlXzogZnVuY3Rpb24oZURlbCkge1xuXHRcdFx0LyogSGFsZi1lZGdlcyBhcmUgYWxsb2NhdGVkIGluIHBhaXJzLCBzZWUgRWRnZVBhaXIgYWJvdmUgKi9cblx0XHRcdGlmKCBlRGVsLlN5bS5zaWRlIDwgZURlbC5zaWRlICkgeyBlRGVsID0gZURlbC5TeW07IH1cblxuXHRcdFx0LyogZGVsZXRlIGZyb20gY2lyY3VsYXIgZG91Ymx5LWxpbmtlZCBsaXN0ICovXG5cdFx0XHR2YXIgZU5leHQgPSBlRGVsLm5leHQ7XG5cdFx0XHR2YXIgZVByZXYgPSBlRGVsLlN5bS5uZXh0O1xuXHRcdFx0ZU5leHQuU3ltLm5leHQgPSBlUHJldjtcblx0XHRcdGVQcmV2LlN5bS5uZXh0ID0gZU5leHQ7XG5cdFx0fSxcblxuXG5cdFx0LyogS2lsbFZlcnRleCggdkRlbCApIGRlc3Ryb3lzIGEgdmVydGV4IGFuZCByZW1vdmVzIGl0IGZyb20gdGhlIGdsb2JhbFxuXHRcdCogdmVydGV4IGxpc3QuICBJdCB1cGRhdGVzIHRoZSB2ZXJ0ZXggbG9vcCB0byBwb2ludCB0byBhIGdpdmVuIG5ldyB2ZXJ0ZXguXG5cdFx0Ki9cblx0XHQvL3N0YXRpYyB2b2lkIEtpbGxWZXJ0ZXgoIFRFU1NtZXNoICptZXNoLCBURVNTdmVydGV4ICp2RGVsLCBURVNTdmVydGV4ICpuZXdPcmcgKVxuXHRcdGtpbGxWZXJ0ZXhfOiBmdW5jdGlvbih2RGVsLCBuZXdPcmcpIHtcblx0XHRcdHZhciBlU3RhcnQgPSB2RGVsLmFuRWRnZTtcblx0XHRcdC8qIGNoYW5nZSB0aGUgb3JpZ2luIG9mIGFsbCBhZmZlY3RlZCBlZGdlcyAqL1xuXHRcdFx0dmFyIGUgPSBlU3RhcnQ7XG5cdFx0XHRkbyB7XG5cdFx0XHRcdGUuT3JnID0gbmV3T3JnO1xuXHRcdFx0XHRlID0gZS5PbmV4dDtcblx0XHRcdH0gd2hpbGUoZSAhPT0gZVN0YXJ0KTtcblxuXHRcdFx0LyogZGVsZXRlIGZyb20gY2lyY3VsYXIgZG91Ymx5LWxpbmtlZCBsaXN0ICovXG5cdFx0XHR2YXIgdlByZXYgPSB2RGVsLnByZXY7XG5cdFx0XHR2YXIgdk5leHQgPSB2RGVsLm5leHQ7XG5cdFx0XHR2TmV4dC5wcmV2ID0gdlByZXY7XG5cdFx0XHR2UHJldi5uZXh0ID0gdk5leHQ7XG5cdFx0fSxcblxuXHRcdC8qIEtpbGxGYWNlKCBmRGVsICkgZGVzdHJveXMgYSBmYWNlIGFuZCByZW1vdmVzIGl0IGZyb20gdGhlIGdsb2JhbCBmYWNlXG5cdFx0KiBsaXN0LiAgSXQgdXBkYXRlcyB0aGUgZmFjZSBsb29wIHRvIHBvaW50IHRvIGEgZ2l2ZW4gbmV3IGZhY2UuXG5cdFx0Ki9cblx0XHQvL3N0YXRpYyB2b2lkIEtpbGxGYWNlKCBURVNTbWVzaCAqbWVzaCwgVEVTU2ZhY2UgKmZEZWwsIFRFU1NmYWNlICpuZXdMZmFjZSApXG5cdFx0a2lsbEZhY2VfOiBmdW5jdGlvbihmRGVsLCBuZXdMZmFjZSkge1xuXHRcdFx0dmFyIGVTdGFydCA9IGZEZWwuYW5FZGdlO1xuXG5cdFx0XHQvKiBjaGFuZ2UgdGhlIGxlZnQgZmFjZSBvZiBhbGwgYWZmZWN0ZWQgZWRnZXMgKi9cblx0XHRcdHZhciBlID0gZVN0YXJ0O1xuXHRcdFx0ZG8ge1xuXHRcdFx0XHRlLkxmYWNlID0gbmV3TGZhY2U7XG5cdFx0XHRcdGUgPSBlLkxuZXh0O1xuXHRcdFx0fSB3aGlsZShlICE9PSBlU3RhcnQpO1xuXG5cdFx0XHQvKiBkZWxldGUgZnJvbSBjaXJjdWxhciBkb3VibHktbGlua2VkIGxpc3QgKi9cblx0XHRcdHZhciBmUHJldiA9IGZEZWwucHJldjtcblx0XHRcdHZhciBmTmV4dCA9IGZEZWwubmV4dDtcblx0XHRcdGZOZXh0LnByZXYgPSBmUHJldjtcblx0XHRcdGZQcmV2Lm5leHQgPSBmTmV4dDtcblx0XHR9LFxuXG5cdFx0LyoqKioqKioqKioqKioqKioqKiBCYXNpYyBFZGdlIE9wZXJhdGlvbnMgKioqKioqKioqKioqKioqKioqKioqKi9cblxuXHRcdC8qIHRlc3NNZXNoTWFrZUVkZ2UgY3JlYXRlcyBvbmUgZWRnZSwgdHdvIHZlcnRpY2VzLCBhbmQgYSBsb29wIChmYWNlKS5cblx0XHQqIFRoZSBsb29wIGNvbnNpc3RzIG9mIHRoZSB0d28gbmV3IGhhbGYtZWRnZXMuXG5cdFx0Ki9cblx0XHQvL1RFU1NoYWxmRWRnZSAqdGVzc01lc2hNYWtlRWRnZSggVEVTU21lc2ggKm1lc2ggKVxuXHRcdG1ha2VFZGdlOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXdWZXJ0ZXgxID0gbmV3IFRFU1N2ZXJ0ZXgoKTtcblx0XHRcdHZhciBuZXdWZXJ0ZXgyID0gbmV3IFRFU1N2ZXJ0ZXgoKTtcblx0XHRcdHZhciBuZXdGYWNlID0gbmV3IFRFU1NmYWNlKCk7XG5cdFx0XHR2YXIgZSA9IHRoaXMubWFrZUVkZ2VfKCB0aGlzLmVIZWFkKTtcblx0XHRcdHRoaXMubWFrZVZlcnRleF8oIG5ld1ZlcnRleDEsIGUsIHRoaXMudkhlYWQgKTtcblx0XHRcdHRoaXMubWFrZVZlcnRleF8oIG5ld1ZlcnRleDIsIGUuU3ltLCB0aGlzLnZIZWFkICk7XG5cdFx0XHR0aGlzLm1ha2VGYWNlXyggbmV3RmFjZSwgZSwgdGhpcy5mSGVhZCApO1xuXHRcdFx0cmV0dXJuIGU7XG5cdFx0fSxcblxuXHRcdC8qIHRlc3NNZXNoU3BsaWNlKCBlT3JnLCBlRHN0ICkgaXMgdGhlIGJhc2ljIG9wZXJhdGlvbiBmb3IgY2hhbmdpbmcgdGhlXG5cdFx0KiBtZXNoIGNvbm5lY3Rpdml0eSBhbmQgdG9wb2xvZ3kuICBJdCBjaGFuZ2VzIHRoZSBtZXNoIHNvIHRoYXRcblx0XHQqXHRlT3JnLT5PbmV4dCA8LSBPTEQoIGVEc3QtPk9uZXh0IClcblx0XHQqXHRlRHN0LT5PbmV4dCA8LSBPTEQoIGVPcmctPk9uZXh0IClcblx0XHQqIHdoZXJlIE9MRCguLi4pIG1lYW5zIHRoZSB2YWx1ZSBiZWZvcmUgdGhlIG1lc2hTcGxpY2Ugb3BlcmF0aW9uLlxuXHRcdCpcblx0XHQqIFRoaXMgY2FuIGhhdmUgdHdvIGVmZmVjdHMgb24gdGhlIHZlcnRleCBzdHJ1Y3R1cmU6XG5cdFx0KiAgLSBpZiBlT3JnLT5PcmcgIT0gZURzdC0+T3JnLCB0aGUgdHdvIHZlcnRpY2VzIGFyZSBtZXJnZWQgdG9nZXRoZXJcblx0XHQqICAtIGlmIGVPcmctPk9yZyA9PSBlRHN0LT5PcmcsIHRoZSBvcmlnaW4gaXMgc3BsaXQgaW50byB0d28gdmVydGljZXNcblx0XHQqIEluIGJvdGggY2FzZXMsIGVEc3QtPk9yZyBpcyBjaGFuZ2VkIGFuZCBlT3JnLT5PcmcgaXMgdW50b3VjaGVkLlxuXHRcdCpcblx0XHQqIFNpbWlsYXJseSAoYW5kIGluZGVwZW5kZW50bHkpIGZvciB0aGUgZmFjZSBzdHJ1Y3R1cmUsXG5cdFx0KiAgLSBpZiBlT3JnLT5MZmFjZSA9PSBlRHN0LT5MZmFjZSwgb25lIGxvb3AgaXMgc3BsaXQgaW50byB0d29cblx0XHQqICAtIGlmIGVPcmctPkxmYWNlICE9IGVEc3QtPkxmYWNlLCB0d28gZGlzdGluY3QgbG9vcHMgYXJlIGpvaW5lZCBpbnRvIG9uZVxuXHRcdCogSW4gYm90aCBjYXNlcywgZURzdC0+TGZhY2UgaXMgY2hhbmdlZCBhbmQgZU9yZy0+TGZhY2UgaXMgdW5hZmZlY3RlZC5cblx0XHQqXG5cdFx0KiBTb21lIHNwZWNpYWwgY2FzZXM6XG5cdFx0KiBJZiBlRHN0ID09IGVPcmcsIHRoZSBvcGVyYXRpb24gaGFzIG5vIGVmZmVjdC5cblx0XHQqIElmIGVEc3QgPT0gZU9yZy0+TG5leHQsIHRoZSBuZXcgZmFjZSB3aWxsIGhhdmUgYSBzaW5nbGUgZWRnZS5cblx0XHQqIElmIGVEc3QgPT0gZU9yZy0+THByZXYsIHRoZSBvbGQgZmFjZSB3aWxsIGhhdmUgYSBzaW5nbGUgZWRnZS5cblx0XHQqIElmIGVEc3QgPT0gZU9yZy0+T25leHQsIHRoZSBuZXcgdmVydGV4IHdpbGwgaGF2ZSBhIHNpbmdsZSBlZGdlLlxuXHRcdCogSWYgZURzdCA9PSBlT3JnLT5PcHJldiwgdGhlIG9sZCB2ZXJ0ZXggd2lsbCBoYXZlIGEgc2luZ2xlIGVkZ2UuXG5cdFx0Ki9cblx0XHQvL2ludCB0ZXNzTWVzaFNwbGljZSggVEVTU21lc2gqIG1lc2gsIFRFU1NoYWxmRWRnZSAqZU9yZywgVEVTU2hhbGZFZGdlICplRHN0IClcblx0XHRzcGxpY2U6IGZ1bmN0aW9uKGVPcmcsIGVEc3QpIHtcblx0XHRcdHZhciBqb2luaW5nTG9vcHMgPSBmYWxzZTtcblx0XHRcdHZhciBqb2luaW5nVmVydGljZXMgPSBmYWxzZTtcblxuXHRcdFx0aWYoIGVPcmcgPT09IGVEc3QgKSByZXR1cm47XG5cblx0XHRcdGlmKCBlRHN0Lk9yZyAhPT0gZU9yZy5PcmcgKSB7XG5cdFx0XHRcdC8qIFdlIGFyZSBtZXJnaW5nIHR3byBkaXNqb2ludCB2ZXJ0aWNlcyAtLSBkZXN0cm95IGVEc3QtPk9yZyAqL1xuXHRcdFx0XHRqb2luaW5nVmVydGljZXMgPSB0cnVlO1xuXHRcdFx0XHR0aGlzLmtpbGxWZXJ0ZXhfKCBlRHN0Lk9yZywgZU9yZy5PcmcgKTtcblx0XHRcdH1cblx0XHRcdGlmKCBlRHN0LkxmYWNlICE9PSBlT3JnLkxmYWNlICkge1xuXHRcdFx0XHQvKiBXZSBhcmUgY29ubmVjdGluZyB0d28gZGlzam9pbnQgbG9vcHMgLS0gZGVzdHJveSBlRHN0LT5MZmFjZSAqL1xuXHRcdFx0XHRqb2luaW5nTG9vcHMgPSB0cnVlO1xuXHRcdFx0XHR0aGlzLmtpbGxGYWNlXyggZURzdC5MZmFjZSwgZU9yZy5MZmFjZSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvKiBDaGFuZ2UgdGhlIGVkZ2Ugc3RydWN0dXJlICovXG5cdFx0XHR0aGlzLnNwbGljZV8oIGVEc3QsIGVPcmcgKTtcblxuXHRcdFx0aWYoICEgam9pbmluZ1ZlcnRpY2VzICkge1xuXHRcdFx0XHR2YXIgbmV3VmVydGV4ID0gbmV3IFRFU1N2ZXJ0ZXgoKTtcblxuXHRcdFx0XHQvKiBXZSBzcGxpdCBvbmUgdmVydGV4IGludG8gdHdvIC0tIHRoZSBuZXcgdmVydGV4IGlzIGVEc3QtPk9yZy5cblx0XHRcdFx0KiBNYWtlIHN1cmUgdGhlIG9sZCB2ZXJ0ZXggcG9pbnRzIHRvIGEgdmFsaWQgaGFsZi1lZGdlLlxuXHRcdFx0XHQqL1xuXHRcdFx0XHR0aGlzLm1ha2VWZXJ0ZXhfKCBuZXdWZXJ0ZXgsIGVEc3QsIGVPcmcuT3JnICk7XG5cdFx0XHRcdGVPcmcuT3JnLmFuRWRnZSA9IGVPcmc7XG5cdFx0XHR9XG5cdFx0XHRpZiggISBqb2luaW5nTG9vcHMgKSB7XG5cdFx0XHRcdHZhciBuZXdGYWNlID0gbmV3IFRFU1NmYWNlKCk7ICBcblxuXHRcdFx0XHQvKiBXZSBzcGxpdCBvbmUgbG9vcCBpbnRvIHR3byAtLSB0aGUgbmV3IGxvb3AgaXMgZURzdC0+TGZhY2UuXG5cdFx0XHRcdCogTWFrZSBzdXJlIHRoZSBvbGQgZmFjZSBwb2ludHMgdG8gYSB2YWxpZCBoYWxmLWVkZ2UuXG5cdFx0XHRcdCovXG5cdFx0XHRcdHRoaXMubWFrZUZhY2VfKCBuZXdGYWNlLCBlRHN0LCBlT3JnLkxmYWNlICk7XG5cdFx0XHRcdGVPcmcuTGZhY2UuYW5FZGdlID0gZU9yZztcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyogdGVzc01lc2hEZWxldGUoIGVEZWwgKSByZW1vdmVzIHRoZSBlZGdlIGVEZWwuICBUaGVyZSBhcmUgc2V2ZXJhbCBjYXNlczpcblx0XHQqIGlmIChlRGVsLT5MZmFjZSAhPSBlRGVsLT5SZmFjZSksIHdlIGpvaW4gdHdvIGxvb3BzIGludG8gb25lOyB0aGUgbG9vcFxuXHRcdCogZURlbC0+TGZhY2UgaXMgZGVsZXRlZC4gIE90aGVyd2lzZSwgd2UgYXJlIHNwbGl0dGluZyBvbmUgbG9vcCBpbnRvIHR3bztcblx0XHQqIHRoZSBuZXdseSBjcmVhdGVkIGxvb3Agd2lsbCBjb250YWluIGVEZWwtPkRzdC4gIElmIHRoZSBkZWxldGlvbiBvZiBlRGVsXG5cdFx0KiB3b3VsZCBjcmVhdGUgaXNvbGF0ZWQgdmVydGljZXMsIHRob3NlIGFyZSBkZWxldGVkIGFzIHdlbGwuXG5cdFx0KlxuXHRcdCogVGhpcyBmdW5jdGlvbiBjb3VsZCBiZSBpbXBsZW1lbnRlZCBhcyB0d28gY2FsbHMgdG8gdGVzc01lc2hTcGxpY2Vcblx0XHQqIHBsdXMgYSBmZXcgY2FsbHMgdG8gbWVtRnJlZSwgYnV0IHRoaXMgd291bGQgYWxsb2NhdGUgYW5kIGRlbGV0ZVxuXHRcdCogdW5uZWNlc3NhcnkgdmVydGljZXMgYW5kIGZhY2VzLlxuXHRcdCovXG5cdFx0Ly9pbnQgdGVzc01lc2hEZWxldGUoIFRFU1NtZXNoICptZXNoLCBURVNTaGFsZkVkZ2UgKmVEZWwgKVxuXHRcdGRlbGV0ZTogZnVuY3Rpb24oZURlbCkge1xuXHRcdFx0dmFyIGVEZWxTeW0gPSBlRGVsLlN5bTtcblx0XHRcdHZhciBqb2luaW5nTG9vcHMgPSBmYWxzZTtcblxuXHRcdFx0LyogRmlyc3Qgc3RlcDogZGlzY29ubmVjdCB0aGUgb3JpZ2luIHZlcnRleCBlRGVsLT5PcmcuICBXZSBtYWtlIGFsbFxuXHRcdFx0KiBjaGFuZ2VzIHRvIGdldCBhIGNvbnNpc3RlbnQgbWVzaCBpbiB0aGlzIFwiaW50ZXJtZWRpYXRlXCIgc3RhdGUuXG5cdFx0XHQqL1xuXHRcdFx0aWYoIGVEZWwuTGZhY2UgIT09IGVEZWwuUmZhY2UgKSB7XG5cdFx0XHRcdC8qIFdlIGFyZSBqb2luaW5nIHR3byBsb29wcyBpbnRvIG9uZSAtLSByZW1vdmUgdGhlIGxlZnQgZmFjZSAqL1xuXHRcdFx0XHRqb2luaW5nTG9vcHMgPSB0cnVlO1xuXHRcdFx0XHR0aGlzLmtpbGxGYWNlXyggZURlbC5MZmFjZSwgZURlbC5SZmFjZSApO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiggZURlbC5PbmV4dCA9PT0gZURlbCApIHtcblx0XHRcdFx0dGhpcy5raWxsVmVydGV4XyggZURlbC5PcmcsIG51bGwgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8qIE1ha2Ugc3VyZSB0aGF0IGVEZWwtPk9yZyBhbmQgZURlbC0+UmZhY2UgcG9pbnQgdG8gdmFsaWQgaGFsZi1lZGdlcyAqL1xuXHRcdFx0XHRlRGVsLlJmYWNlLmFuRWRnZSA9IGVEZWwuT3ByZXY7XG5cdFx0XHRcdGVEZWwuT3JnLmFuRWRnZSA9IGVEZWwuT25leHQ7XG5cblx0XHRcdFx0dGhpcy5zcGxpY2VfKCBlRGVsLCBlRGVsLk9wcmV2ICk7XG5cdFx0XHRcdGlmKCAhIGpvaW5pbmdMb29wcyApIHtcblx0XHRcdFx0XHR2YXIgbmV3RmFjZSA9IG5ldyBURVNTZmFjZSgpO1xuXG5cdFx0XHRcdFx0LyogV2UgYXJlIHNwbGl0dGluZyBvbmUgbG9vcCBpbnRvIHR3byAtLSBjcmVhdGUgYSBuZXcgbG9vcCBmb3IgZURlbC4gKi9cblx0XHRcdFx0XHR0aGlzLm1ha2VGYWNlXyggbmV3RmFjZSwgZURlbCwgZURlbC5MZmFjZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8qIENsYWltOiB0aGUgbWVzaCBpcyBub3cgaW4gYSBjb25zaXN0ZW50IHN0YXRlLCBleGNlcHQgdGhhdCBlRGVsLT5Pcmdcblx0XHRcdCogbWF5IGhhdmUgYmVlbiBkZWxldGVkLiAgTm93IHdlIGRpc2Nvbm5lY3QgZURlbC0+RHN0LlxuXHRcdFx0Ki9cblx0XHRcdGlmKCBlRGVsU3ltLk9uZXh0ID09PSBlRGVsU3ltICkge1xuXHRcdFx0XHR0aGlzLmtpbGxWZXJ0ZXhfKCBlRGVsU3ltLk9yZywgbnVsbCApO1xuXHRcdFx0XHR0aGlzLmtpbGxGYWNlXyggZURlbFN5bS5MZmFjZSwgbnVsbCApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0LyogTWFrZSBzdXJlIHRoYXQgZURlbC0+RHN0IGFuZCBlRGVsLT5MZmFjZSBwb2ludCB0byB2YWxpZCBoYWxmLWVkZ2VzICovXG5cdFx0XHRcdGVEZWwuTGZhY2UuYW5FZGdlID0gZURlbFN5bS5PcHJldjtcblx0XHRcdFx0ZURlbFN5bS5PcmcuYW5FZGdlID0gZURlbFN5bS5PbmV4dDtcblx0XHRcdFx0dGhpcy5zcGxpY2VfKCBlRGVsU3ltLCBlRGVsU3ltLk9wcmV2ICk7XG5cdFx0XHR9XG5cblx0XHRcdC8qIEFueSBpc29sYXRlZCB2ZXJ0aWNlcyBvciBmYWNlcyBoYXZlIGFscmVhZHkgYmVlbiBmcmVlZC4gKi9cblx0XHRcdHRoaXMua2lsbEVkZ2VfKCBlRGVsICk7XG5cdFx0fSxcblxuXHRcdC8qKioqKioqKioqKioqKioqKioqKiBPdGhlciBFZGdlIE9wZXJhdGlvbnMgKioqKioqKioqKioqKioqKioqKioqKi9cblxuXHRcdC8qIEFsbCB0aGVzZSByb3V0aW5lcyBjYW4gYmUgaW1wbGVtZW50ZWQgd2l0aCB0aGUgYmFzaWMgZWRnZVxuXHRcdCogb3BlcmF0aW9ucyBhYm92ZS4gIFRoZXkgYXJlIHByb3ZpZGVkIGZvciBjb252ZW5pZW5jZSBhbmQgZWZmaWNpZW5jeS5cblx0XHQqL1xuXG5cblx0XHQvKiB0ZXNzTWVzaEFkZEVkZ2VWZXJ0ZXgoIGVPcmcgKSBjcmVhdGVzIGEgbmV3IGVkZ2UgZU5ldyBzdWNoIHRoYXRcblx0XHQqIGVOZXcgPT0gZU9yZy0+TG5leHQsIGFuZCBlTmV3LT5Ec3QgaXMgYSBuZXdseSBjcmVhdGVkIHZlcnRleC5cblx0XHQqIGVPcmcgYW5kIGVOZXcgd2lsbCBoYXZlIHRoZSBzYW1lIGxlZnQgZmFjZS5cblx0XHQqL1xuXHRcdC8vIFRFU1NoYWxmRWRnZSAqdGVzc01lc2hBZGRFZGdlVmVydGV4KCBURVNTbWVzaCAqbWVzaCwgVEVTU2hhbGZFZGdlICplT3JnICk7XG5cdFx0YWRkRWRnZVZlcnRleDogZnVuY3Rpb24oZU9yZykge1xuXHRcdFx0dmFyIGVOZXcgPSB0aGlzLm1ha2VFZGdlXyggZU9yZyApO1xuXHRcdFx0dmFyIGVOZXdTeW0gPSBlTmV3LlN5bTtcblxuXHRcdFx0LyogQ29ubmVjdCB0aGUgbmV3IGVkZ2UgYXBwcm9wcmlhdGVseSAqL1xuXHRcdFx0dGhpcy5zcGxpY2VfKCBlTmV3LCBlT3JnLkxuZXh0ICk7XG5cblx0XHRcdC8qIFNldCB0aGUgdmVydGV4IGFuZCBmYWNlIGluZm9ybWF0aW9uICovXG5cdFx0XHRlTmV3Lk9yZyA9IGVPcmcuRHN0O1xuXG5cdFx0XHR2YXIgbmV3VmVydGV4ID0gbmV3IFRFU1N2ZXJ0ZXgoKTtcblx0XHRcdHRoaXMubWFrZVZlcnRleF8oIG5ld1ZlcnRleCwgZU5ld1N5bSwgZU5ldy5PcmcgKTtcblxuXHRcdFx0ZU5ldy5MZmFjZSA9IGVOZXdTeW0uTGZhY2UgPSBlT3JnLkxmYWNlO1xuXG5cdFx0XHRyZXR1cm4gZU5ldztcblx0XHR9LFxuXG5cblx0XHQvKiB0ZXNzTWVzaFNwbGl0RWRnZSggZU9yZyApIHNwbGl0cyBlT3JnIGludG8gdHdvIGVkZ2VzIGVPcmcgYW5kIGVOZXcsXG5cdFx0KiBzdWNoIHRoYXQgZU5ldyA9PSBlT3JnLT5MbmV4dC4gIFRoZSBuZXcgdmVydGV4IGlzIGVPcmctPkRzdCA9PSBlTmV3LT5PcmcuXG5cdFx0KiBlT3JnIGFuZCBlTmV3IHdpbGwgaGF2ZSB0aGUgc2FtZSBsZWZ0IGZhY2UuXG5cdFx0Ki9cblx0XHQvLyBURVNTaGFsZkVkZ2UgKnRlc3NNZXNoU3BsaXRFZGdlKCBURVNTbWVzaCAqbWVzaCwgVEVTU2hhbGZFZGdlICplT3JnICk7XG5cdFx0c3BsaXRFZGdlOiBmdW5jdGlvbihlT3JnLCBlRHN0KSB7XG5cdFx0XHR2YXIgdGVtcEhhbGZFZGdlID0gdGhpcy5hZGRFZGdlVmVydGV4KCBlT3JnICk7XG5cdFx0XHR2YXIgZU5ldyA9IHRlbXBIYWxmRWRnZS5TeW07XG5cblx0XHRcdC8qIERpc2Nvbm5lY3QgZU9yZyBmcm9tIGVPcmctPkRzdCBhbmQgY29ubmVjdCBpdCB0byBlTmV3LT5PcmcgKi9cblx0XHRcdHRoaXMuc3BsaWNlXyggZU9yZy5TeW0sIGVPcmcuU3ltLk9wcmV2ICk7XG5cdFx0XHR0aGlzLnNwbGljZV8oIGVPcmcuU3ltLCBlTmV3ICk7XG5cblx0XHRcdC8qIFNldCB0aGUgdmVydGV4IGFuZCBmYWNlIGluZm9ybWF0aW9uICovXG5cdFx0XHRlT3JnLkRzdCA9IGVOZXcuT3JnO1xuXHRcdFx0ZU5ldy5Ec3QuYW5FZGdlID0gZU5ldy5TeW07XHQvKiBtYXkgaGF2ZSBwb2ludGVkIHRvIGVPcmctPlN5bSAqL1xuXHRcdFx0ZU5ldy5SZmFjZSA9IGVPcmcuUmZhY2U7XG5cdFx0XHRlTmV3LndpbmRpbmcgPSBlT3JnLndpbmRpbmc7XHQvKiBjb3B5IG9sZCB3aW5kaW5nIGluZm9ybWF0aW9uICovXG5cdFx0XHRlTmV3LlN5bS53aW5kaW5nID0gZU9yZy5TeW0ud2luZGluZztcblxuXHRcdFx0cmV0dXJuIGVOZXc7XG5cdFx0fSxcblxuXG5cdFx0LyogdGVzc01lc2hDb25uZWN0KCBlT3JnLCBlRHN0ICkgY3JlYXRlcyBhIG5ldyBlZGdlIGZyb20gZU9yZy0+RHN0XG5cdFx0KiB0byBlRHN0LT5PcmcsIGFuZCByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIGhhbGYtZWRnZSBlTmV3LlxuXHRcdCogSWYgZU9yZy0+TGZhY2UgPT0gZURzdC0+TGZhY2UsIHRoaXMgc3BsaXRzIG9uZSBsb29wIGludG8gdHdvLFxuXHRcdCogYW5kIHRoZSBuZXdseSBjcmVhdGVkIGxvb3AgaXMgZU5ldy0+TGZhY2UuICBPdGhlcndpc2UsIHR3byBkaXNqb2ludFxuXHRcdCogbG9vcHMgYXJlIG1lcmdlZCBpbnRvIG9uZSwgYW5kIHRoZSBsb29wIGVEc3QtPkxmYWNlIGlzIGRlc3Ryb3llZC5cblx0XHQqXG5cdFx0KiBJZiAoZU9yZyA9PSBlRHN0KSwgdGhlIG5ldyBmYWNlIHdpbGwgaGF2ZSBvbmx5IHR3byBlZGdlcy5cblx0XHQqIElmIChlT3JnLT5MbmV4dCA9PSBlRHN0KSwgdGhlIG9sZCBmYWNlIGlzIHJlZHVjZWQgdG8gYSBzaW5nbGUgZWRnZS5cblx0XHQqIElmIChlT3JnLT5MbmV4dC0+TG5leHQgPT0gZURzdCksIHRoZSBvbGQgZmFjZSBpcyByZWR1Y2VkIHRvIHR3byBlZGdlcy5cblx0XHQqL1xuXG5cdFx0Ly8gVEVTU2hhbGZFZGdlICp0ZXNzTWVzaENvbm5lY3QoIFRFU1NtZXNoICptZXNoLCBURVNTaGFsZkVkZ2UgKmVPcmcsIFRFU1NoYWxmRWRnZSAqZURzdCApO1xuXHRcdGNvbm5lY3Q6IGZ1bmN0aW9uKGVPcmcsIGVEc3QpIHtcblx0XHRcdHZhciBqb2luaW5nTG9vcHMgPSBmYWxzZTsgIFxuXHRcdFx0dmFyIGVOZXcgPSB0aGlzLm1ha2VFZGdlXyggZU9yZyApO1xuXHRcdFx0dmFyIGVOZXdTeW0gPSBlTmV3LlN5bTtcblxuXHRcdFx0aWYoIGVEc3QuTGZhY2UgIT09IGVPcmcuTGZhY2UgKSB7XG5cdFx0XHRcdC8qIFdlIGFyZSBjb25uZWN0aW5nIHR3byBkaXNqb2ludCBsb29wcyAtLSBkZXN0cm95IGVEc3QtPkxmYWNlICovXG5cdFx0XHRcdGpvaW5pbmdMb29wcyA9IHRydWU7XG5cdFx0XHRcdHRoaXMua2lsbEZhY2VfKCBlRHN0LkxmYWNlLCBlT3JnLkxmYWNlICk7XG5cdFx0XHR9XG5cblx0XHRcdC8qIENvbm5lY3QgdGhlIG5ldyBlZGdlIGFwcHJvcHJpYXRlbHkgKi9cblx0XHRcdHRoaXMuc3BsaWNlXyggZU5ldywgZU9yZy5MbmV4dCApO1xuXHRcdFx0dGhpcy5zcGxpY2VfKCBlTmV3U3ltLCBlRHN0ICk7XG5cblx0XHRcdC8qIFNldCB0aGUgdmVydGV4IGFuZCBmYWNlIGluZm9ybWF0aW9uICovXG5cdFx0XHRlTmV3Lk9yZyA9IGVPcmcuRHN0O1xuXHRcdFx0ZU5ld1N5bS5PcmcgPSBlRHN0Lk9yZztcblx0XHRcdGVOZXcuTGZhY2UgPSBlTmV3U3ltLkxmYWNlID0gZU9yZy5MZmFjZTtcblxuXHRcdFx0LyogTWFrZSBzdXJlIHRoZSBvbGQgZmFjZSBwb2ludHMgdG8gYSB2YWxpZCBoYWxmLWVkZ2UgKi9cblx0XHRcdGVPcmcuTGZhY2UuYW5FZGdlID0gZU5ld1N5bTtcblxuXHRcdFx0aWYoICEgam9pbmluZ0xvb3BzICkge1xuXHRcdFx0XHR2YXIgbmV3RmFjZSA9IG5ldyBURVNTZmFjZSgpO1xuXHRcdFx0XHQvKiBXZSBzcGxpdCBvbmUgbG9vcCBpbnRvIHR3byAtLSB0aGUgbmV3IGxvb3AgaXMgZU5ldy0+TGZhY2UgKi9cblx0XHRcdFx0dGhpcy5tYWtlRmFjZV8oIG5ld0ZhY2UsIGVOZXcsIGVPcmcuTGZhY2UgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBlTmV3O1xuXHRcdH0sXG5cblx0XHQvKiB0ZXNzTWVzaFphcEZhY2UoIGZaYXAgKSBkZXN0cm95cyBhIGZhY2UgYW5kIHJlbW92ZXMgaXQgZnJvbSB0aGVcblx0XHQqIGdsb2JhbCBmYWNlIGxpc3QuICBBbGwgZWRnZXMgb2YgZlphcCB3aWxsIGhhdmUgYSBOVUxMIHBvaW50ZXIgYXMgdGhlaXJcblx0XHQqIGxlZnQgZmFjZS4gIEFueSBlZGdlcyB3aGljaCBhbHNvIGhhdmUgYSBOVUxMIHBvaW50ZXIgYXMgdGhlaXIgcmlnaHQgZmFjZVxuXHRcdCogYXJlIGRlbGV0ZWQgZW50aXJlbHkgKGFsb25nIHdpdGggYW55IGlzb2xhdGVkIHZlcnRpY2VzIHRoaXMgcHJvZHVjZXMpLlxuXHRcdCogQW4gZW50aXJlIG1lc2ggY2FuIGJlIGRlbGV0ZWQgYnkgemFwcGluZyBpdHMgZmFjZXMsIG9uZSBhdCBhIHRpbWUsXG5cdFx0KiBpbiBhbnkgb3JkZXIuICBaYXBwZWQgZmFjZXMgY2Fubm90IGJlIHVzZWQgaW4gZnVydGhlciBtZXNoIG9wZXJhdGlvbnMhXG5cdFx0Ki9cblx0XHR6YXBGYWNlOiBmdW5jdGlvbiggZlphcCApXG5cdFx0e1xuXHRcdFx0dmFyIGVTdGFydCA9IGZaYXAuYW5FZGdlO1xuXHRcdFx0dmFyIGUsIGVOZXh0LCBlU3ltO1xuXHRcdFx0dmFyIGZQcmV2LCBmTmV4dDtcblxuXHRcdFx0Lyogd2FsayBhcm91bmQgZmFjZSwgZGVsZXRpbmcgZWRnZXMgd2hvc2UgcmlnaHQgZmFjZSBpcyBhbHNvIE5VTEwgKi9cblx0XHRcdGVOZXh0ID0gZVN0YXJ0LkxuZXh0O1xuXHRcdFx0ZG8ge1xuXHRcdFx0XHRlID0gZU5leHQ7XG5cdFx0XHRcdGVOZXh0ID0gZS5MbmV4dDtcblxuXHRcdFx0XHRlLkxmYWNlID0gbnVsbDtcblx0XHRcdFx0aWYoIGUuUmZhY2UgPT09IG51bGwgKSB7XG5cdFx0XHRcdFx0LyogZGVsZXRlIHRoZSBlZGdlIC0tIHNlZSBURVNTbWVzaERlbGV0ZSBhYm92ZSAqL1xuXG5cdFx0XHRcdFx0aWYoIGUuT25leHQgPT09IGUgKSB7XG5cdFx0XHRcdFx0XHR0aGlzLmtpbGxWZXJ0ZXhfKCBlLk9yZywgbnVsbCApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHQvKiBNYWtlIHN1cmUgdGhhdCBlLT5PcmcgcG9pbnRzIHRvIGEgdmFsaWQgaGFsZi1lZGdlICovXG5cdFx0XHRcdFx0XHRlLk9yZy5hbkVkZ2UgPSBlLk9uZXh0O1xuXHRcdFx0XHRcdFx0dGhpcy5zcGxpY2VfKCBlLCBlLk9wcmV2ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVTeW0gPSBlLlN5bTtcblx0XHRcdFx0XHRpZiggZVN5bS5PbmV4dCA9PT0gZVN5bSApIHtcblx0XHRcdFx0XHRcdHRoaXMua2lsbFZlcnRleF8oIGVTeW0uT3JnLCBudWxsICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdC8qIE1ha2Ugc3VyZSB0aGF0IGVTeW0tPk9yZyBwb2ludHMgdG8gYSB2YWxpZCBoYWxmLWVkZ2UgKi9cblx0XHRcdFx0XHRcdGVTeW0uT3JnLmFuRWRnZSA9IGVTeW0uT25leHQ7XG5cdFx0XHRcdFx0XHR0aGlzLnNwbGljZV8oIGVTeW0sIGVTeW0uT3ByZXYgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhpcy5raWxsRWRnZV8oIGUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSB3aGlsZSggZSAhPSBlU3RhcnQgKTtcblxuXHRcdFx0LyogZGVsZXRlIGZyb20gY2lyY3VsYXIgZG91Ymx5LWxpbmtlZCBsaXN0ICovXG5cdFx0XHRmUHJldiA9IGZaYXAucHJldjtcblx0XHRcdGZOZXh0ID0gZlphcC5uZXh0O1xuXHRcdFx0Zk5leHQucHJldiA9IGZQcmV2O1xuXHRcdFx0ZlByZXYubmV4dCA9IGZOZXh0O1xuXHRcdH0sXG5cblx0XHRjb3VudEZhY2VWZXJ0c186IGZ1bmN0aW9uKGYpIHtcblx0XHRcdHZhciBlQ3VyID0gZi5hbkVkZ2U7XG5cdFx0XHR2YXIgbiA9IDA7XG5cdFx0XHRkb1xuXHRcdFx0e1xuXHRcdFx0XHRuKys7XG5cdFx0XHRcdGVDdXIgPSBlQ3VyLkxuZXh0O1xuXHRcdFx0fVxuXHRcdFx0d2hpbGUgKGVDdXIgIT09IGYuYW5FZGdlKTtcblx0XHRcdHJldHVybiBuO1xuXHRcdH0sXG5cblx0XHQvL2ludCB0ZXNzTWVzaE1lcmdlQ29udmV4RmFjZXMoIFRFU1NtZXNoICptZXNoLCBpbnQgbWF4VmVydHNQZXJGYWNlIClcblx0XHRtZXJnZUNvbnZleEZhY2VzOiBmdW5jdGlvbihtYXhWZXJ0c1BlckZhY2UpIHtcblx0XHRcdHZhciBmO1xuXHRcdFx0dmFyIGVDdXIsIGVOZXh0LCBlU3ltO1xuXHRcdFx0dmFyIHZTdGFydDtcblx0XHRcdHZhciBjdXJOdiwgc3ltTnY7XG5cblx0XHRcdGZvciggZiA9IHRoaXMuZkhlYWQubmV4dDsgZiAhPT0gdGhpcy5mSGVhZDsgZiA9IGYubmV4dCApXG5cdFx0XHR7XG5cdFx0XHRcdC8vIFNraXAgZmFjZXMgd2hpY2ggYXJlIG91dHNpZGUgdGhlIHJlc3VsdC5cblx0XHRcdFx0aWYoICFmLmluc2lkZSApXG5cdFx0XHRcdFx0Y29udGludWU7XG5cblx0XHRcdFx0ZUN1ciA9IGYuYW5FZGdlO1xuXHRcdFx0XHR2U3RhcnQgPSBlQ3VyLk9yZztcblx0XHRcdFx0XHRcblx0XHRcdFx0d2hpbGUgKHRydWUpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRlTmV4dCA9IGVDdXIuTG5leHQ7XG5cdFx0XHRcdFx0ZVN5bSA9IGVDdXIuU3ltO1xuXG5cdFx0XHRcdFx0Ly8gVHJ5IHRvIG1lcmdlIGlmIHRoZSBuZWlnaGJvdXIgZmFjZSBpcyB2YWxpZC5cblx0XHRcdFx0XHRpZiggZVN5bSAmJiBlU3ltLkxmYWNlICYmIGVTeW0uTGZhY2UuaW5zaWRlIClcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHQvLyBUcnkgdG8gbWVyZ2UgdGhlIG5laWdoYm91ciBmYWNlcyBpZiB0aGUgcmVzdWx0aW5nIHBvbHlnb25zXG5cdFx0XHRcdFx0XHQvLyBkb2VzIG5vdCBleGNlZWQgbWF4aW11bSBudW1iZXIgb2YgdmVydGljZXMuXG5cdFx0XHRcdFx0XHRjdXJOdiA9IHRoaXMuY291bnRGYWNlVmVydHNfKCBmICk7XG5cdFx0XHRcdFx0XHRzeW1OdiA9IHRoaXMuY291bnRGYWNlVmVydHNfKCBlU3ltLkxmYWNlICk7XG5cdFx0XHRcdFx0XHRpZiggKGN1ck52K3N5bU52LTIpIDw9IG1heFZlcnRzUGVyRmFjZSApXG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdC8vIE1lcmdlIGlmIHRoZSByZXN1bHRpbmcgcG9seSBpcyBjb252ZXguXG5cdFx0XHRcdFx0XHRcdGlmKCBHZW9tLnZlcnRDQ1coIGVDdXIuTHByZXYuT3JnLCBlQ3VyLk9yZywgZVN5bS5MbmV4dC5MbmV4dC5PcmcgKSAmJlxuXHRcdFx0XHRcdFx0XHRcdEdlb20udmVydENDVyggZVN5bS5McHJldi5PcmcsIGVTeW0uT3JnLCBlQ3VyLkxuZXh0LkxuZXh0Lk9yZyApIClcblx0XHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRcdGVOZXh0ID0gZVN5bS5MbmV4dDtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLmRlbGV0ZSggZVN5bSApO1xuXHRcdFx0XHRcdFx0XHRcdGVDdXIgPSBudWxsO1xuXHRcdFx0XHRcdFx0XHRcdGVTeW0gPSBudWxsO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGlmKCBlQ3VyICYmIGVDdXIuTG5leHQuT3JnID09PSB2U3RhcnQgKVxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHQvLyBDb250aW51ZSB0byBuZXh0IGVkZ2UuXG5cdFx0XHRcdFx0ZUN1ciA9IGVOZXh0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0sXG5cblx0XHQvKiB0ZXNzTWVzaENoZWNrTWVzaCggbWVzaCApIGNoZWNrcyBhIG1lc2ggZm9yIHNlbGYtY29uc2lzdGVuY3kuXG5cdFx0Ki9cblx0XHRjaGVjazogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgZkhlYWQgPSB0aGlzLmZIZWFkO1xuXHRcdFx0dmFyIHZIZWFkID0gdGhpcy52SGVhZDtcblx0XHRcdHZhciBlSGVhZCA9IHRoaXMuZUhlYWQ7XG5cdFx0XHR2YXIgZiwgZlByZXYsIHYsIHZQcmV2LCBlLCBlUHJldjtcblxuXHRcdFx0ZlByZXYgPSBmSGVhZDtcblx0XHRcdGZvciggZlByZXYgPSBmSGVhZCA7IChmID0gZlByZXYubmV4dCkgIT09IGZIZWFkOyBmUHJldiA9IGYpIHtcblx0XHRcdFx0YXNzZXJ0KCBmLnByZXYgPT09IGZQcmV2ICk7XG5cdFx0XHRcdGUgPSBmLmFuRWRnZTtcblx0XHRcdFx0ZG8ge1xuXHRcdFx0XHRcdGFzc2VydCggZS5TeW0gIT09IGUgKTtcblx0XHRcdFx0XHRhc3NlcnQoIGUuU3ltLlN5bSA9PT0gZSApO1xuXHRcdFx0XHRcdGFzc2VydCggZS5MbmV4dC5PbmV4dC5TeW0gPT09IGUgKTtcblx0XHRcdFx0XHRhc3NlcnQoIGUuT25leHQuU3ltLkxuZXh0ID09PSBlICk7XG5cdFx0XHRcdFx0YXNzZXJ0KCBlLkxmYWNlID09PSBmICk7XG5cdFx0XHRcdFx0ZSA9IGUuTG5leHQ7XG5cdFx0XHRcdH0gd2hpbGUoIGUgIT09IGYuYW5FZGdlICk7XG5cdFx0XHR9XG5cdFx0XHRhc3NlcnQoIGYucHJldiA9PT0gZlByZXYgJiYgZi5hbkVkZ2UgPT09IG51bGwgKTtcblxuXHRcdFx0dlByZXYgPSB2SGVhZDtcblx0XHRcdGZvciggdlByZXYgPSB2SGVhZCA7ICh2ID0gdlByZXYubmV4dCkgIT09IHZIZWFkOyB2UHJldiA9IHYpIHtcblx0XHRcdFx0YXNzZXJ0KCB2LnByZXYgPT09IHZQcmV2ICk7XG5cdFx0XHRcdGUgPSB2LmFuRWRnZTtcblx0XHRcdFx0ZG8ge1xuXHRcdFx0XHRcdGFzc2VydCggZS5TeW0gIT09IGUgKTtcblx0XHRcdFx0XHRhc3NlcnQoIGUuU3ltLlN5bSA9PT0gZSApO1xuXHRcdFx0XHRcdGFzc2VydCggZS5MbmV4dC5PbmV4dC5TeW0gPT09IGUgKTtcblx0XHRcdFx0XHRhc3NlcnQoIGUuT25leHQuU3ltLkxuZXh0ID09PSBlICk7XG5cdFx0XHRcdFx0YXNzZXJ0KCBlLk9yZyA9PT0gdiApO1xuXHRcdFx0XHRcdGUgPSBlLk9uZXh0O1xuXHRcdFx0XHR9IHdoaWxlKCBlICE9PSB2LmFuRWRnZSApO1xuXHRcdFx0fVxuXHRcdFx0YXNzZXJ0KCB2LnByZXYgPT09IHZQcmV2ICYmIHYuYW5FZGdlID09PSBudWxsICk7XG5cblx0XHRcdGVQcmV2ID0gZUhlYWQ7XG5cdFx0XHRmb3IoIGVQcmV2ID0gZUhlYWQgOyAoZSA9IGVQcmV2Lm5leHQpICE9PSBlSGVhZDsgZVByZXYgPSBlKSB7XG5cdFx0XHRcdGFzc2VydCggZS5TeW0ubmV4dCA9PT0gZVByZXYuU3ltICk7XG5cdFx0XHRcdGFzc2VydCggZS5TeW0gIT09IGUgKTtcblx0XHRcdFx0YXNzZXJ0KCBlLlN5bS5TeW0gPT09IGUgKTtcblx0XHRcdFx0YXNzZXJ0KCBlLk9yZyAhPT0gbnVsbCApO1xuXHRcdFx0XHRhc3NlcnQoIGUuRHN0ICE9PSBudWxsICk7XG5cdFx0XHRcdGFzc2VydCggZS5MbmV4dC5PbmV4dC5TeW0gPT09IGUgKTtcblx0XHRcdFx0YXNzZXJ0KCBlLk9uZXh0LlN5bS5MbmV4dCA9PT0gZSApO1xuXHRcdFx0fVxuXHRcdFx0YXNzZXJ0KCBlLlN5bS5uZXh0ID09PSBlUHJldi5TeW1cblx0XHRcdFx0JiYgZS5TeW0gPT09IHRoaXMuZUhlYWRTeW1cblx0XHRcdFx0JiYgZS5TeW0uU3ltID09PSBlXG5cdFx0XHRcdCYmIGUuT3JnID09PSBudWxsICYmIGUuRHN0ID09PSBudWxsXG5cdFx0XHRcdCYmIGUuTGZhY2UgPT09IG51bGwgJiYgZS5SZmFjZSA9PT0gbnVsbCApO1xuXHRcdH1cblxuXHR9O1xuXG5cdHZhciBHZW9tID0ge307XG5cblx0R2VvbS52ZXJ0RXEgPSBmdW5jdGlvbih1LHYpIHtcblx0XHRyZXR1cm4gKHUucyA9PT0gdi5zICYmIHUudCA9PT0gdi50KTtcblx0fTtcblxuXHQvKiBSZXR1cm5zIFRSVUUgaWYgdSBpcyBsZXhpY29ncmFwaGljYWxseSA8PSB2LiAqL1xuXHRHZW9tLnZlcnRMZXEgPSBmdW5jdGlvbih1LHYpIHtcblx0XHRyZXR1cm4gKCh1LnMgPCB2LnMpIHx8ICh1LnMgPT09IHYucyAmJiB1LnQgPD0gdi50KSk7XG5cdH07XG5cblx0LyogVmVyc2lvbnMgb2YgVmVydExlcSwgRWRnZVNpZ24sIEVkZ2VFdmFsIHdpdGggcyBhbmQgdCB0cmFuc3Bvc2VkLiAqL1xuXHRHZW9tLnRyYW5zTGVxID0gZnVuY3Rpb24odSx2KSB7XG5cdFx0cmV0dXJuICgodS50IDwgdi50KSB8fCAodS50ID09PSB2LnQgJiYgdS5zIDw9IHYucykpO1xuXHR9O1xuXG5cdEdlb20uZWRnZUdvZXNMZWZ0ID0gZnVuY3Rpb24oZSkge1xuXHRcdHJldHVybiBHZW9tLnZlcnRMZXEoIGUuRHN0LCBlLk9yZyApO1xuXHR9O1xuXG5cdEdlb20uZWRnZUdvZXNSaWdodCA9IGZ1bmN0aW9uKGUpIHtcblx0XHRyZXR1cm4gR2VvbS52ZXJ0TGVxKCBlLk9yZywgZS5Ec3QgKTtcblx0fTtcblxuXHRHZW9tLnZlcnRMMWRpc3QgPSBmdW5jdGlvbih1LHYpIHtcblx0XHRyZXR1cm4gKE1hdGguYWJzKHUucyAtIHYucykgKyBNYXRoLmFicyh1LnQgLSB2LnQpKTtcblx0fTtcblxuXHQvL1RFU1NyZWFsIHRlc2VkZ2VFdmFsKCBURVNTdmVydGV4ICp1LCBURVNTdmVydGV4ICp2LCBURVNTdmVydGV4ICp3IClcblx0R2VvbS5lZGdlRXZhbCA9IGZ1bmN0aW9uKCB1LCB2LCB3ICkge1xuXHRcdC8qIEdpdmVuIHRocmVlIHZlcnRpY2VzIHUsdix3IHN1Y2ggdGhhdCBWZXJ0TGVxKHUsdikgJiYgVmVydExlcSh2LHcpLFxuXHRcdCogZXZhbHVhdGVzIHRoZSB0LWNvb3JkIG9mIHRoZSBlZGdlIHV3IGF0IHRoZSBzLWNvb3JkIG9mIHRoZSB2ZXJ0ZXggdi5cblx0XHQqIFJldHVybnMgdi0+dCAtICh1dykodi0+cyksIGllLiB0aGUgc2lnbmVkIGRpc3RhbmNlIGZyb20gdXcgdG8gdi5cblx0XHQqIElmIHV3IGlzIHZlcnRpY2FsIChhbmQgdGh1cyBwYXNzZXMgdGhydSB2KSwgdGhlIHJlc3VsdCBpcyB6ZXJvLlxuXHRcdCpcblx0XHQqIFRoZSBjYWxjdWxhdGlvbiBpcyBleHRyZW1lbHkgYWNjdXJhdGUgYW5kIHN0YWJsZSwgZXZlbiB3aGVuIHZcblx0XHQqIGlzIHZlcnkgY2xvc2UgdG8gdSBvciB3LiAgSW4gcGFydGljdWxhciBpZiB3ZSBzZXQgdi0+dCA9IDAgYW5kXG5cdFx0KiBsZXQgciBiZSB0aGUgbmVnYXRlZCByZXN1bHQgKHRoaXMgZXZhbHVhdGVzICh1dykodi0+cykpLCB0aGVuXG5cdFx0KiByIGlzIGd1YXJhbnRlZWQgdG8gc2F0aXNmeSBNSU4odS0+dCx3LT50KSA8PSByIDw9IE1BWCh1LT50LHctPnQpLlxuXHRcdCovXG5cdFx0YXNzZXJ0KCBHZW9tLnZlcnRMZXEoIHUsIHYgKSAmJiBHZW9tLnZlcnRMZXEoIHYsIHcgKSk7XG5cblx0XHR2YXIgZ2FwTCA9IHYucyAtIHUucztcblx0XHR2YXIgZ2FwUiA9IHcucyAtIHYucztcblxuXHRcdGlmKCBnYXBMICsgZ2FwUiA+IDAuMCApIHtcblx0XHRcdGlmKCBnYXBMIDwgZ2FwUiApIHtcblx0XHRcdFx0cmV0dXJuICh2LnQgLSB1LnQpICsgKHUudCAtIHcudCkgKiAoZ2FwTCAvIChnYXBMICsgZ2FwUikpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuICh2LnQgLSB3LnQpICsgKHcudCAtIHUudCkgKiAoZ2FwUiAvIChnYXBMICsgZ2FwUikpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHQvKiB2ZXJ0aWNhbCBsaW5lICovXG5cdFx0cmV0dXJuIDAuMDtcblx0fTtcblxuXHQvL1RFU1NyZWFsIHRlc2VkZ2VTaWduKCBURVNTdmVydGV4ICp1LCBURVNTdmVydGV4ICp2LCBURVNTdmVydGV4ICp3IClcblx0R2VvbS5lZGdlU2lnbiA9IGZ1bmN0aW9uKCB1LCB2LCB3ICkge1xuXHRcdC8qIFJldHVybnMgYSBudW1iZXIgd2hvc2Ugc2lnbiBtYXRjaGVzIEVkZ2VFdmFsKHUsdix3KSBidXQgd2hpY2hcblx0XHQqIGlzIGNoZWFwZXIgdG8gZXZhbHVhdGUuICBSZXR1cm5zID4gMCwgPT0gMCAsIG9yIDwgMFxuXHRcdCogYXMgdiBpcyBhYm92ZSwgb24sIG9yIGJlbG93IHRoZSBlZGdlIHV3LlxuXHRcdCovXG5cdFx0YXNzZXJ0KCBHZW9tLnZlcnRMZXEoIHUsIHYgKSAmJiBHZW9tLnZlcnRMZXEoIHYsIHcgKSk7XG5cblx0XHR2YXIgZ2FwTCA9IHYucyAtIHUucztcblx0XHR2YXIgZ2FwUiA9IHcucyAtIHYucztcblxuXHRcdGlmKCBnYXBMICsgZ2FwUiA+IDAuMCApIHtcblx0XHRcdHJldHVybiAodi50IC0gdy50KSAqIGdhcEwgKyAodi50IC0gdS50KSAqIGdhcFI7XG5cdFx0fVxuXHRcdC8qIHZlcnRpY2FsIGxpbmUgKi9cblx0XHRyZXR1cm4gMC4wO1xuXHR9O1xuXG5cblx0LyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cdCogRGVmaW5lIHZlcnNpb25zIG9mIEVkZ2VTaWduLCBFZGdlRXZhbCB3aXRoIHMgYW5kIHQgdHJhbnNwb3NlZC5cblx0Ki9cblxuXHQvL1RFU1NyZWFsIHRlc3RyYW5zRXZhbCggVEVTU3ZlcnRleCAqdSwgVEVTU3ZlcnRleCAqdiwgVEVTU3ZlcnRleCAqdyApXG5cdEdlb20udHJhbnNFdmFsID0gZnVuY3Rpb24oIHUsIHYsIHcgKSB7XG5cdFx0LyogR2l2ZW4gdGhyZWUgdmVydGljZXMgdSx2LHcgc3VjaCB0aGF0IFRyYW5zTGVxKHUsdikgJiYgVHJhbnNMZXEodix3KSxcblx0XHQqIGV2YWx1YXRlcyB0aGUgdC1jb29yZCBvZiB0aGUgZWRnZSB1dyBhdCB0aGUgcy1jb29yZCBvZiB0aGUgdmVydGV4IHYuXG5cdFx0KiBSZXR1cm5zIHYtPnMgLSAodXcpKHYtPnQpLCBpZS4gdGhlIHNpZ25lZCBkaXN0YW5jZSBmcm9tIHV3IHRvIHYuXG5cdFx0KiBJZiB1dyBpcyB2ZXJ0aWNhbCAoYW5kIHRodXMgcGFzc2VzIHRocnUgdiksIHRoZSByZXN1bHQgaXMgemVyby5cblx0XHQqXG5cdFx0KiBUaGUgY2FsY3VsYXRpb24gaXMgZXh0cmVtZWx5IGFjY3VyYXRlIGFuZCBzdGFibGUsIGV2ZW4gd2hlbiB2XG5cdFx0KiBpcyB2ZXJ5IGNsb3NlIHRvIHUgb3Igdy4gIEluIHBhcnRpY3VsYXIgaWYgd2Ugc2V0IHYtPnMgPSAwIGFuZFxuXHRcdCogbGV0IHIgYmUgdGhlIG5lZ2F0ZWQgcmVzdWx0ICh0aGlzIGV2YWx1YXRlcyAodXcpKHYtPnQpKSwgdGhlblxuXHRcdCogciBpcyBndWFyYW50ZWVkIHRvIHNhdGlzZnkgTUlOKHUtPnMsdy0+cykgPD0gciA8PSBNQVgodS0+cyx3LT5zKS5cblx0XHQqL1xuXHRcdGFzc2VydCggR2VvbS50cmFuc0xlcSggdSwgdiApICYmIEdlb20udHJhbnNMZXEoIHYsIHcgKSk7XG5cblx0XHR2YXIgZ2FwTCA9IHYudCAtIHUudDtcblx0XHR2YXIgZ2FwUiA9IHcudCAtIHYudDtcblxuXHRcdGlmKCBnYXBMICsgZ2FwUiA+IDAuMCApIHtcblx0XHRcdGlmKCBnYXBMIDwgZ2FwUiApIHtcblx0XHRcdFx0cmV0dXJuICh2LnMgLSB1LnMpICsgKHUucyAtIHcucykgKiAoZ2FwTCAvIChnYXBMICsgZ2FwUikpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuICh2LnMgLSB3LnMpICsgKHcucyAtIHUucykgKiAoZ2FwUiAvIChnYXBMICsgZ2FwUikpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHQvKiB2ZXJ0aWNhbCBsaW5lICovXG5cdFx0cmV0dXJuIDAuMDtcblx0fTtcblxuXHQvL1RFU1NyZWFsIHRlc3RyYW5zU2lnbiggVEVTU3ZlcnRleCAqdSwgVEVTU3ZlcnRleCAqdiwgVEVTU3ZlcnRleCAqdyApXG5cdEdlb20udHJhbnNTaWduID0gZnVuY3Rpb24oIHUsIHYsIHcgKSB7XG5cdFx0LyogUmV0dXJucyBhIG51bWJlciB3aG9zZSBzaWduIG1hdGNoZXMgVHJhbnNFdmFsKHUsdix3KSBidXQgd2hpY2hcblx0XHQqIGlzIGNoZWFwZXIgdG8gZXZhbHVhdGUuICBSZXR1cm5zID4gMCwgPT0gMCAsIG9yIDwgMFxuXHRcdCogYXMgdiBpcyBhYm92ZSwgb24sIG9yIGJlbG93IHRoZSBlZGdlIHV3LlxuXHRcdCovXG5cdFx0YXNzZXJ0KCBHZW9tLnRyYW5zTGVxKCB1LCB2ICkgJiYgR2VvbS50cmFuc0xlcSggdiwgdyApKTtcblxuXHRcdHZhciBnYXBMID0gdi50IC0gdS50O1xuXHRcdHZhciBnYXBSID0gdy50IC0gdi50O1xuXG5cdFx0aWYoIGdhcEwgKyBnYXBSID4gMC4wICkge1xuXHRcdFx0cmV0dXJuICh2LnMgLSB3LnMpICogZ2FwTCArICh2LnMgLSB1LnMpICogZ2FwUjtcblx0XHR9XG5cdFx0LyogdmVydGljYWwgbGluZSAqL1xuXHRcdHJldHVybiAwLjA7XG5cdH07XG5cblxuXHQvL2ludCB0ZXN2ZXJ0Q0NXKCBURVNTdmVydGV4ICp1LCBURVNTdmVydGV4ICp2LCBURVNTdmVydGV4ICp3IClcblx0R2VvbS52ZXJ0Q0NXID0gZnVuY3Rpb24oIHUsIHYsIHcgKSB7XG5cdFx0LyogRm9yIGFsbW9zdC1kZWdlbmVyYXRlIHNpdHVhdGlvbnMsIHRoZSByZXN1bHRzIGFyZSBub3QgcmVsaWFibGUuXG5cdFx0KiBVbmxlc3MgdGhlIGZsb2F0aW5nLXBvaW50IGFyaXRobWV0aWMgY2FuIGJlIHBlcmZvcm1lZCB3aXRob3V0XG5cdFx0KiByb3VuZGluZyBlcnJvcnMsICphbnkqIGltcGxlbWVudGF0aW9uIHdpbGwgZ2l2ZSBpbmNvcnJlY3QgcmVzdWx0c1xuXHRcdCogb24gc29tZSBkZWdlbmVyYXRlIGlucHV0cywgc28gdGhlIGNsaWVudCBtdXN0IGhhdmUgc29tZSB3YXkgdG9cblx0XHQqIGhhbmRsZSB0aGlzIHNpdHVhdGlvbi5cblx0XHQqL1xuXHRcdHJldHVybiAodS5zKih2LnQgLSB3LnQpICsgdi5zKih3LnQgLSB1LnQpICsgdy5zKih1LnQgLSB2LnQpKSA+PSAwLjA7XG5cdH07XG5cblx0LyogR2l2ZW4gcGFyYW1ldGVycyBhLHgsYix5IHJldHVybnMgdGhlIHZhbHVlIChiKngrYSp5KS8oYStiKSxcblx0KiBvciAoeCt5KS8yIGlmIGE9PWI9PTAuICBJdCByZXF1aXJlcyB0aGF0IGEsYiA+PSAwLCBhbmQgZW5mb3JjZXNcblx0KiB0aGlzIGluIHRoZSByYXJlIGNhc2UgdGhhdCBvbmUgYXJndW1lbnQgaXMgc2xpZ2h0bHkgbmVnYXRpdmUuXG5cdCogVGhlIGltcGxlbWVudGF0aW9uIGlzIGV4dHJlbWVseSBzdGFibGUgbnVtZXJpY2FsbHkuXG5cdCogSW4gcGFydGljdWxhciBpdCBndWFyYW50ZWVzIHRoYXQgdGhlIHJlc3VsdCByIHNhdGlzZmllc1xuXHQqIE1JTih4LHkpIDw9IHIgPD0gTUFYKHgseSksIGFuZCB0aGUgcmVzdWx0cyBhcmUgdmVyeSBhY2N1cmF0ZVxuXHQqIGV2ZW4gd2hlbiBhIGFuZCBiIGRpZmZlciBncmVhdGx5IGluIG1hZ25pdHVkZS5cblx0Ki9cblx0R2VvbS5pbnRlcnBvbGF0ZSA9IGZ1bmN0aW9uKGEseCxiLHkpIHtcblx0XHRyZXR1cm4gKGEgPSAoYSA8IDApID8gMCA6IGEsIGIgPSAoYiA8IDApID8gMCA6IGIsICgoYSA8PSBiKSA/ICgoYiA9PSAwKSA/ICgoeCt5KSAvIDIpIDogKHggKyAoeS14KSAqIChhLyhhK2IpKSkpIDogKHkgKyAoeC15KSAqIChiLyhhK2IpKSkpKTtcblx0fTtcblxuXHQvKlxuXHQjaWZuZGVmIEZPUl9UUklURV9URVNUX1BST0dSQU1cblx0I2RlZmluZSBJbnRlcnBvbGF0ZShhLHgsYix5KVx0UmVhbEludGVycG9sYXRlKGEseCxiLHkpXG5cdCNlbHNlXG5cblx0Ly8gQ2xhaW06IHRoZSBPTkxZIHByb3BlcnR5IHRoZSBzd2VlcCBhbGdvcml0aG0gcmVsaWVzIG9uIGlzIHRoYXRcblx0Ly8gTUlOKHgseSkgPD0gciA8PSBNQVgoeCx5KS4gIFRoaXMgaXMgYSBuYXN0eSB3YXkgdG8gdGVzdCB0aGF0LlxuXHQjaW5jbHVkZSA8c3RkbGliLmg+XG5cdGV4dGVybiBpbnQgUmFuZG9tSW50ZXJwb2xhdGU7XG5cblx0ZG91YmxlIEludGVycG9sYXRlKCBkb3VibGUgYSwgZG91YmxlIHgsIGRvdWJsZSBiLCBkb3VibGUgeSlcblx0e1xuXHRcdHByaW50ZihcIioqKioqKioqKioqKioqKioqKioqKiVkXFxuXCIsUmFuZG9tSW50ZXJwb2xhdGUpO1xuXHRcdGlmKCBSYW5kb21JbnRlcnBvbGF0ZSApIHtcblx0XHRcdGEgPSAxLjIgKiBkcmFuZDQ4KCkgLSAwLjE7XG5cdFx0XHRhID0gKGEgPCAwKSA/IDAgOiAoKGEgPiAxKSA/IDEgOiBhKTtcblx0XHRcdGIgPSAxLjAgLSBhO1xuXHRcdH1cblx0XHRyZXR1cm4gUmVhbEludGVycG9sYXRlKGEseCxiLHkpO1xuXHR9XG5cdCNlbmRpZiovXG5cblx0R2VvbS5pbnRlcnNlY3QgPSBmdW5jdGlvbiggbzEsIGQxLCBvMiwgZDIsIHYgKSB7XG5cdFx0LyogR2l2ZW4gZWRnZXMgKG8xLGQxKSBhbmQgKG8yLGQyKSwgY29tcHV0ZSB0aGVpciBwb2ludCBvZiBpbnRlcnNlY3Rpb24uXG5cdFx0KiBUaGUgY29tcHV0ZWQgcG9pbnQgaXMgZ3VhcmFudGVlZCB0byBsaWUgaW4gdGhlIGludGVyc2VjdGlvbiBvZiB0aGVcblx0XHQqIGJvdW5kaW5nIHJlY3RhbmdsZXMgZGVmaW5lZCBieSBlYWNoIGVkZ2UuXG5cdFx0Ki9cblx0XHR2YXIgejEsIHoyO1xuXHRcdHZhciB0O1xuXG5cdFx0LyogVGhpcyBpcyBjZXJ0YWlubHkgbm90IHRoZSBtb3N0IGVmZmljaWVudCB3YXkgdG8gZmluZCB0aGUgaW50ZXJzZWN0aW9uXG5cdFx0KiBvZiB0d28gbGluZSBzZWdtZW50cywgYnV0IGl0IGlzIHZlcnkgbnVtZXJpY2FsbHkgc3RhYmxlLlxuXHRcdCpcblx0XHQqIFN0cmF0ZWd5OiBmaW5kIHRoZSB0d28gbWlkZGxlIHZlcnRpY2VzIGluIHRoZSBWZXJ0TGVxIG9yZGVyaW5nLFxuXHRcdCogYW5kIGludGVycG9sYXRlIHRoZSBpbnRlcnNlY3Rpb24gcy12YWx1ZSBmcm9tIHRoZXNlLiAgVGhlbiByZXBlYXRcblx0XHQqIHVzaW5nIHRoZSBUcmFuc0xlcSBvcmRlcmluZyB0byBmaW5kIHRoZSBpbnRlcnNlY3Rpb24gdC12YWx1ZS5cblx0XHQqL1xuXG5cdFx0aWYoICEgR2VvbS52ZXJ0TGVxKCBvMSwgZDEgKSkgeyB0ID0gbzE7IG8xID0gZDE7IGQxID0gdDsgfSAvL3N3YXAoIG8xLCBkMSApOyB9XG5cdFx0aWYoICEgR2VvbS52ZXJ0TGVxKCBvMiwgZDIgKSkgeyB0ID0gbzI7IG8yID0gZDI7IGQyID0gdDsgfSAvL3N3YXAoIG8yLCBkMiApOyB9XG5cdFx0aWYoICEgR2VvbS52ZXJ0TGVxKCBvMSwgbzIgKSkgeyB0ID0gbzE7IG8xID0gbzI7IG8yID0gdDsgdCA9IGQxOyBkMSA9IGQyOyBkMiA9IHQ7IH0vL3N3YXAoIG8xLCBvMiApOyBzd2FwKCBkMSwgZDIgKTsgfVxuXG5cdFx0aWYoICEgR2VvbS52ZXJ0TGVxKCBvMiwgZDEgKSkge1xuXHRcdFx0LyogVGVjaG5pY2FsbHksIG5vIGludGVyc2VjdGlvbiAtLSBkbyBvdXIgYmVzdCAqL1xuXHRcdFx0di5zID0gKG8yLnMgKyBkMS5zKSAvIDI7XG5cdFx0fSBlbHNlIGlmKCBHZW9tLnZlcnRMZXEoIGQxLCBkMiApKSB7XG5cdFx0XHQvKiBJbnRlcnBvbGF0ZSBiZXR3ZWVuIG8yIGFuZCBkMSAqL1xuXHRcdFx0ejEgPSBHZW9tLmVkZ2VFdmFsKCBvMSwgbzIsIGQxICk7XG5cdFx0XHR6MiA9IEdlb20uZWRnZUV2YWwoIG8yLCBkMSwgZDIgKTtcblx0XHRcdGlmKCB6MSt6MiA8IDAgKSB7IHoxID0gLXoxOyB6MiA9IC16MjsgfVxuXHRcdFx0di5zID0gR2VvbS5pbnRlcnBvbGF0ZSggejEsIG8yLnMsIHoyLCBkMS5zICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8qIEludGVycG9sYXRlIGJldHdlZW4gbzIgYW5kIGQyICovXG5cdFx0XHR6MSA9IEdlb20uZWRnZVNpZ24oIG8xLCBvMiwgZDEgKTtcblx0XHRcdHoyID0gLUdlb20uZWRnZVNpZ24oIG8xLCBkMiwgZDEgKTtcblx0XHRcdGlmKCB6MSt6MiA8IDAgKSB7IHoxID0gLXoxOyB6MiA9IC16MjsgfVxuXHRcdFx0di5zID0gR2VvbS5pbnRlcnBvbGF0ZSggejEsIG8yLnMsIHoyLCBkMi5zICk7XG5cdFx0fVxuXG5cdFx0LyogTm93IHJlcGVhdCB0aGUgcHJvY2VzcyBmb3IgdCAqL1xuXG5cdFx0aWYoICEgR2VvbS50cmFuc0xlcSggbzEsIGQxICkpIHsgdCA9IG8xOyBvMSA9IGQxOyBkMSA9IHQ7IH0gLy9zd2FwKCBvMSwgZDEgKTsgfVxuXHRcdGlmKCAhIEdlb20udHJhbnNMZXEoIG8yLCBkMiApKSB7IHQgPSBvMjsgbzIgPSBkMjsgZDIgPSB0OyB9IC8vc3dhcCggbzIsIGQyICk7IH1cblx0XHRpZiggISBHZW9tLnRyYW5zTGVxKCBvMSwgbzIgKSkgeyB0ID0gbzE7IG8xID0gbzI7IG8yID0gdDsgdCA9IGQxOyBkMSA9IGQyOyBkMiA9IHQ7IH0gLy9zd2FwKCBvMSwgbzIgKTsgc3dhcCggZDEsIGQyICk7IH1cblxuXHRcdGlmKCAhIEdlb20udHJhbnNMZXEoIG8yLCBkMSApKSB7XG5cdFx0XHQvKiBUZWNobmljYWxseSwgbm8gaW50ZXJzZWN0aW9uIC0tIGRvIG91ciBiZXN0ICovXG5cdFx0XHR2LnQgPSAobzIudCArIGQxLnQpIC8gMjtcblx0XHR9IGVsc2UgaWYoIEdlb20udHJhbnNMZXEoIGQxLCBkMiApKSB7XG5cdFx0XHQvKiBJbnRlcnBvbGF0ZSBiZXR3ZWVuIG8yIGFuZCBkMSAqL1xuXHRcdFx0ejEgPSBHZW9tLnRyYW5zRXZhbCggbzEsIG8yLCBkMSApO1xuXHRcdFx0ejIgPSBHZW9tLnRyYW5zRXZhbCggbzIsIGQxLCBkMiApO1xuXHRcdFx0aWYoIHoxK3oyIDwgMCApIHsgejEgPSAtejE7IHoyID0gLXoyOyB9XG5cdFx0XHR2LnQgPSBHZW9tLmludGVycG9sYXRlKCB6MSwgbzIudCwgejIsIGQxLnQgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0LyogSW50ZXJwb2xhdGUgYmV0d2VlbiBvMiBhbmQgZDIgKi9cblx0XHRcdHoxID0gR2VvbS50cmFuc1NpZ24oIG8xLCBvMiwgZDEgKTtcblx0XHRcdHoyID0gLUdlb20udHJhbnNTaWduKCBvMSwgZDIsIGQxICk7XG5cdFx0XHRpZiggejErejIgPCAwICkgeyB6MSA9IC16MTsgejIgPSAtejI7IH1cblx0XHRcdHYudCA9IEdlb20uaW50ZXJwb2xhdGUoIHoxLCBvMi50LCB6MiwgZDIudCApO1xuXHRcdH1cblx0fTtcblxuXG5cblx0ZnVuY3Rpb24gRGljdE5vZGUoKSB7XG5cdFx0dGhpcy5rZXkgPSBudWxsO1xuXHRcdHRoaXMubmV4dCA9IG51bGw7XG5cdFx0dGhpcy5wcmV2ID0gbnVsbDtcblx0fTtcblxuXHRmdW5jdGlvbiBEaWN0KGZyYW1lLCBsZXEpIHtcblx0XHR0aGlzLmhlYWQgPSBuZXcgRGljdE5vZGUoKTtcblx0XHR0aGlzLmhlYWQubmV4dCA9IHRoaXMuaGVhZDtcblx0XHR0aGlzLmhlYWQucHJldiA9IHRoaXMuaGVhZDtcblx0XHR0aGlzLmZyYW1lID0gZnJhbWU7XG5cdFx0dGhpcy5sZXEgPSBsZXE7XG5cdH07XG5cblx0RGljdC5wcm90b3R5cGUgPSB7XG5cdFx0bWluOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLmhlYWQubmV4dDtcblx0XHR9LFxuXG5cdFx0bWF4OiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLmhlYWQucHJldjtcblx0XHR9LFxuXG5cdFx0aW5zZXJ0OiBmdW5jdGlvbihrKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5pbnNlcnRCZWZvcmUodGhpcy5oZWFkLCBrKTtcblx0XHR9LFxuXG5cdFx0c2VhcmNoOiBmdW5jdGlvbihrZXkpIHtcblx0XHRcdC8qIFNlYXJjaCByZXR1cm5zIHRoZSBub2RlIHdpdGggdGhlIHNtYWxsZXN0IGtleSBncmVhdGVyIHRoYW4gb3IgZXF1YWxcblx0XHRcdCogdG8gdGhlIGdpdmVuIGtleS4gIElmIHRoZXJlIGlzIG5vIHN1Y2gga2V5LCByZXR1cm5zIGEgbm9kZSB3aG9zZVxuXHRcdFx0KiBrZXkgaXMgTlVMTC4gIFNpbWlsYXJseSwgU3VjYyhNYXgoZCkpIGhhcyBhIE5VTEwga2V5LCBldGMuXG5cdFx0XHQqL1xuXHRcdFx0dmFyIG5vZGUgPSB0aGlzLmhlYWQ7XG5cdFx0XHRkbyB7XG5cdFx0XHRcdG5vZGUgPSBub2RlLm5leHQ7XG5cdFx0XHR9IHdoaWxlKCBub2RlLmtleSAhPT0gbnVsbCAmJiAhIHRoaXMubGVxKHRoaXMuZnJhbWUsIGtleSwgbm9kZS5rZXkpKTtcblxuXHRcdFx0cmV0dXJuIG5vZGU7XG5cdFx0fSxcblxuXHRcdGluc2VydEJlZm9yZTogZnVuY3Rpb24obm9kZSwga2V5KSB7XG5cdFx0XHRkbyB7XG5cdFx0XHRcdG5vZGUgPSBub2RlLnByZXY7XG5cdFx0XHR9IHdoaWxlKCBub2RlLmtleSAhPT0gbnVsbCAmJiAhIHRoaXMubGVxKHRoaXMuZnJhbWUsIG5vZGUua2V5LCBrZXkpKTtcblxuXHRcdFx0dmFyIG5ld05vZGUgPSBuZXcgRGljdE5vZGUoKTtcblx0XHRcdG5ld05vZGUua2V5ID0ga2V5O1xuXHRcdFx0bmV3Tm9kZS5uZXh0ID0gbm9kZS5uZXh0O1xuXHRcdFx0bm9kZS5uZXh0LnByZXYgPSBuZXdOb2RlO1xuXHRcdFx0bmV3Tm9kZS5wcmV2ID0gbm9kZTtcblx0XHRcdG5vZGUubmV4dCA9IG5ld05vZGU7XG5cblx0XHRcdHJldHVybiBuZXdOb2RlO1xuXHRcdH0sXG5cblx0XHRkZWxldGU6IGZ1bmN0aW9uKG5vZGUpIHtcblx0XHRcdG5vZGUubmV4dC5wcmV2ID0gbm9kZS5wcmV2O1xuXHRcdFx0bm9kZS5wcmV2Lm5leHQgPSBub2RlLm5leHQ7XG5cdFx0fVxuXHR9O1xuXG5cblx0ZnVuY3Rpb24gUFFub2RlKCkge1xuXHRcdHRoaXMuaGFuZGxlID0gbnVsbDtcblx0fVxuXG5cdGZ1bmN0aW9uIFBRaGFuZGxlRWxlbSgpIHtcblx0XHR0aGlzLmtleSA9IG51bGw7XG5cdFx0dGhpcy5ub2RlID0gbnVsbDtcblx0fVxuXG5cdGZ1bmN0aW9uIFByaW9yaXR5UShzaXplLCBsZXEpIHtcblx0XHR0aGlzLnNpemUgPSAwO1xuXHRcdHRoaXMubWF4ID0gc2l6ZTtcblxuXHRcdHRoaXMubm9kZXMgPSBbXTtcblx0XHR0aGlzLm5vZGVzLmxlbmd0aCA9IHNpemUrMTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubm9kZXMubGVuZ3RoOyBpKyspXG5cdFx0XHR0aGlzLm5vZGVzW2ldID0gbmV3IFBRbm9kZSgpO1xuXG5cdFx0dGhpcy5oYW5kbGVzID0gW107XG5cdFx0dGhpcy5oYW5kbGVzLmxlbmd0aCA9IHNpemUrMTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaGFuZGxlcy5sZW5ndGg7IGkrKylcblx0XHRcdHRoaXMuaGFuZGxlc1tpXSA9IG5ldyBQUWhhbmRsZUVsZW0oKTtcblxuXHRcdHRoaXMuaW5pdGlhbGl6ZWQgPSBmYWxzZTtcblx0XHR0aGlzLmZyZWVMaXN0ID0gMDtcblx0XHR0aGlzLmxlcSA9IGxlcTtcblxuXHRcdHRoaXMubm9kZXNbMV0uaGFuZGxlID0gMTtcdC8qIHNvIHRoYXQgTWluaW11bSgpIHJldHVybnMgTlVMTCAqL1xuXHRcdHRoaXMuaGFuZGxlc1sxXS5rZXkgPSBudWxsO1xuXHR9O1xuXG5cdFByaW9yaXR5US5wcm90b3R5cGUgPSB7XG5cblx0XHRmbG9hdERvd25fOiBmdW5jdGlvbiggY3VyciApXG5cdFx0e1xuXHRcdFx0dmFyIG4gPSB0aGlzLm5vZGVzO1xuXHRcdFx0dmFyIGggPSB0aGlzLmhhbmRsZXM7XG5cdFx0XHR2YXIgaEN1cnIsIGhDaGlsZDtcblx0XHRcdHZhciBjaGlsZDtcblxuXHRcdFx0aEN1cnIgPSBuW2N1cnJdLmhhbmRsZTtcblx0XHRcdGZvciggOzsgKSB7XG5cdFx0XHRcdGNoaWxkID0gY3VyciA8PCAxO1xuXHRcdFx0XHRpZiggY2hpbGQgPCB0aGlzLnNpemUgJiYgdGhpcy5sZXEoIGhbbltjaGlsZCsxXS5oYW5kbGVdLmtleSwgaFtuW2NoaWxkXS5oYW5kbGVdLmtleSApKSB7XG5cdFx0XHRcdFx0KytjaGlsZDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGFzc2VydChjaGlsZCA8PSB0aGlzLm1heCk7XG5cblx0XHRcdFx0aENoaWxkID0gbltjaGlsZF0uaGFuZGxlO1xuXHRcdFx0XHRpZiggY2hpbGQgPiB0aGlzLnNpemUgfHwgdGhpcy5sZXEoIGhbaEN1cnJdLmtleSwgaFtoQ2hpbGRdLmtleSApKSB7XG5cdFx0XHRcdFx0bltjdXJyXS5oYW5kbGUgPSBoQ3Vycjtcblx0XHRcdFx0XHRoW2hDdXJyXS5ub2RlID0gY3Vycjtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0XHRuW2N1cnJdLmhhbmRsZSA9IGhDaGlsZDtcblx0XHRcdFx0aFtoQ2hpbGRdLm5vZGUgPSBjdXJyO1xuXHRcdFx0XHRjdXJyID0gY2hpbGQ7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGZsb2F0VXBfOiBmdW5jdGlvbiggY3VyciApXG5cdFx0e1xuXHRcdFx0dmFyIG4gPSB0aGlzLm5vZGVzO1xuXHRcdFx0dmFyIGggPSB0aGlzLmhhbmRsZXM7XG5cdFx0XHR2YXIgaEN1cnIsIGhQYXJlbnQ7XG5cdFx0XHR2YXIgcGFyZW50O1xuXG5cdFx0XHRoQ3VyciA9IG5bY3Vycl0uaGFuZGxlO1xuXHRcdFx0Zm9yKCA7OyApIHtcblx0XHRcdFx0cGFyZW50ID0gY3VyciA+PiAxO1xuXHRcdFx0XHRoUGFyZW50ID0gbltwYXJlbnRdLmhhbmRsZTtcblx0XHRcdFx0aWYoIHBhcmVudCA9PSAwIHx8IHRoaXMubGVxKCBoW2hQYXJlbnRdLmtleSwgaFtoQ3Vycl0ua2V5ICkpIHtcblx0XHRcdFx0XHRuW2N1cnJdLmhhbmRsZSA9IGhDdXJyO1xuXHRcdFx0XHRcdGhbaEN1cnJdLm5vZGUgPSBjdXJyO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG5bY3Vycl0uaGFuZGxlID0gaFBhcmVudDtcblx0XHRcdFx0aFtoUGFyZW50XS5ub2RlID0gY3Vycjtcblx0XHRcdFx0Y3VyciA9IHBhcmVudDtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0aW5pdDogZnVuY3Rpb24oKSB7XG5cdFx0XHQvKiBUaGlzIG1ldGhvZCBvZiBidWlsZGluZyBhIGhlYXAgaXMgTyhuKSwgcmF0aGVyIHRoYW4gTyhuIGxnIG4pLiAqL1xuXHRcdFx0Zm9yKCB2YXIgaSA9IHRoaXMuc2l6ZTsgaSA+PSAxOyAtLWkgKSB7XG5cdFx0XHRcdHRoaXMuZmxvYXREb3duXyggaSApO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5pbml0aWFsaXplZCA9IHRydWU7XG5cdFx0fSxcblxuXHRcdG1pbjogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5oYW5kbGVzW3RoaXMubm9kZXNbMV0uaGFuZGxlXS5rZXk7XG5cdFx0fSxcblxuXHRcdGlzRW1wdHk6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5zaXplID09PSAwO1xuXHRcdH0sXG5cblx0XHQvKiByZWFsbHkgcHFIZWFwSW5zZXJ0ICovXG5cdFx0LyogcmV0dXJucyBJTlZfSEFORExFIGlmZiBvdXQgb2YgbWVtb3J5ICovXG5cdFx0Ly9QUWhhbmRsZSBwcUhlYXBJbnNlcnQoIFRFU1NhbGxvYyogYWxsb2MsIFByaW9yaXR5UUhlYXAgKnBxLCBQUWtleSBrZXlOZXcgKVxuXHRcdGluc2VydDogZnVuY3Rpb24oa2V5TmV3KVxuXHRcdHtcblx0XHRcdHZhciBjdXJyO1xuXHRcdFx0dmFyIGZyZWU7XG5cblx0XHRcdGN1cnIgPSArK3RoaXMuc2l6ZTtcblx0XHRcdGlmKCAoY3VycioyKSA+IHRoaXMubWF4ICkge1xuXHRcdFx0XHR0aGlzLm1heCAqPSAyO1xuXHRcdFx0XHR2YXIgcztcblx0XHRcdFx0cyA9IHRoaXMubm9kZXMubGVuZ3RoO1xuXHRcdFx0XHR0aGlzLm5vZGVzLmxlbmd0aCA9IHRoaXMubWF4KzE7XG5cdFx0XHRcdGZvciAodmFyIGkgPSBzOyBpIDwgdGhpcy5ub2Rlcy5sZW5ndGg7IGkrKylcblx0XHRcdFx0XHR0aGlzLm5vZGVzW2ldID0gbmV3IFBRbm9kZSgpO1xuXG5cdFx0XHRcdHMgPSB0aGlzLmhhbmRsZXMubGVuZ3RoO1xuXHRcdFx0XHR0aGlzLmhhbmRsZXMubGVuZ3RoID0gdGhpcy5tYXgrMTtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IHM7IGkgPCB0aGlzLmhhbmRsZXMubGVuZ3RoOyBpKyspXG5cdFx0XHRcdFx0dGhpcy5oYW5kbGVzW2ldID0gbmV3IFBRaGFuZGxlRWxlbSgpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiggdGhpcy5mcmVlTGlzdCA9PT0gMCApIHtcblx0XHRcdFx0ZnJlZSA9IGN1cnI7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRmcmVlID0gdGhpcy5mcmVlTGlzdDtcblx0XHRcdFx0dGhpcy5mcmVlTGlzdCA9IHRoaXMuaGFuZGxlc1tmcmVlXS5ub2RlO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLm5vZGVzW2N1cnJdLmhhbmRsZSA9IGZyZWU7XG5cdFx0XHR0aGlzLmhhbmRsZXNbZnJlZV0ubm9kZSA9IGN1cnI7XG5cdFx0XHR0aGlzLmhhbmRsZXNbZnJlZV0ua2V5ID0ga2V5TmV3O1xuXG5cdFx0XHRpZiggdGhpcy5pbml0aWFsaXplZCApIHtcblx0XHRcdFx0dGhpcy5mbG9hdFVwXyggY3VyciApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZyZWU7XG5cdFx0fSxcblxuXHRcdC8vUFFrZXkgcHFIZWFwRXh0cmFjdE1pbiggUHJpb3JpdHlRSGVhcCAqcHEgKVxuXHRcdGV4dHJhY3RNaW46IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG4gPSB0aGlzLm5vZGVzO1xuXHRcdFx0dmFyIGggPSB0aGlzLmhhbmRsZXM7XG5cdFx0XHR2YXIgaE1pbiA9IG5bMV0uaGFuZGxlO1xuXHRcdFx0dmFyIG1pbiA9IGhbaE1pbl0ua2V5O1xuXG5cdFx0XHRpZiggdGhpcy5zaXplID4gMCApIHtcblx0XHRcdFx0blsxXS5oYW5kbGUgPSBuW3RoaXMuc2l6ZV0uaGFuZGxlO1xuXHRcdFx0XHRoW25bMV0uaGFuZGxlXS5ub2RlID0gMTtcblxuXHRcdFx0XHRoW2hNaW5dLmtleSA9IG51bGw7XG5cdFx0XHRcdGhbaE1pbl0ubm9kZSA9IHRoaXMuZnJlZUxpc3Q7XG5cdFx0XHRcdHRoaXMuZnJlZUxpc3QgPSBoTWluO1xuXG5cdFx0XHRcdC0tdGhpcy5zaXplO1xuXHRcdFx0XHRpZiggdGhpcy5zaXplID4gMCApIHtcblx0XHRcdFx0XHR0aGlzLmZsb2F0RG93bl8oIDEgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1pbjtcblx0XHR9LFxuXG5cdFx0ZGVsZXRlOiBmdW5jdGlvbiggaEN1cnIgKSB7XG5cdFx0XHR2YXIgbiA9IHRoaXMubm9kZXM7XG5cdFx0XHR2YXIgaCA9IHRoaXMuaGFuZGxlcztcblx0XHRcdHZhciBjdXJyO1xuXG5cdFx0XHRhc3NlcnQoIGhDdXJyID49IDEgJiYgaEN1cnIgPD0gdGhpcy5tYXggJiYgaFtoQ3Vycl0ua2V5ICE9PSBudWxsICk7XG5cblx0XHRcdGN1cnIgPSBoW2hDdXJyXS5ub2RlO1xuXHRcdFx0bltjdXJyXS5oYW5kbGUgPSBuW3RoaXMuc2l6ZV0uaGFuZGxlO1xuXHRcdFx0aFtuW2N1cnJdLmhhbmRsZV0ubm9kZSA9IGN1cnI7XG5cblx0XHRcdC0tdGhpcy5zaXplO1xuXHRcdFx0aWYoIGN1cnIgPD0gdGhpcy5zaXplICkge1xuXHRcdFx0XHRpZiggY3VyciA8PSAxIHx8IHRoaXMubGVxKCBoW25bY3Vycj4+MV0uaGFuZGxlXS5rZXksIGhbbltjdXJyXS5oYW5kbGVdLmtleSApKSB7XG5cdFx0XHRcdFx0dGhpcy5mbG9hdERvd25fKCBjdXJyICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5mbG9hdFVwXyggY3VyciApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRoW2hDdXJyXS5rZXkgPSBudWxsO1xuXHRcdFx0aFtoQ3Vycl0ubm9kZSA9IHRoaXMuZnJlZUxpc3Q7XG5cdFx0XHR0aGlzLmZyZWVMaXN0ID0gaEN1cnI7XG5cdFx0fVxuXHR9O1xuXG5cblx0LyogRm9yIGVhY2ggcGFpciBvZiBhZGphY2VudCBlZGdlcyBjcm9zc2luZyB0aGUgc3dlZXAgbGluZSwgdGhlcmUgaXNcblx0KiBhbiBBY3RpdmVSZWdpb24gdG8gcmVwcmVzZW50IHRoZSByZWdpb24gYmV0d2VlbiB0aGVtLiAgVGhlIGFjdGl2ZVxuXHQqIHJlZ2lvbnMgYXJlIGtlcHQgaW4gc29ydGVkIG9yZGVyIGluIGEgZHluYW1pYyBkaWN0aW9uYXJ5LiAgQXMgdGhlXG5cdCogc3dlZXAgbGluZSBjcm9zc2VzIGVhY2ggdmVydGV4LCB3ZSB1cGRhdGUgdGhlIGFmZmVjdGVkIHJlZ2lvbnMuXG5cdCovXG5cblx0ZnVuY3Rpb24gQWN0aXZlUmVnaW9uKCkge1xuXHRcdHRoaXMuZVVwID0gbnVsbDtcdFx0LyogdXBwZXIgZWRnZSwgZGlyZWN0ZWQgcmlnaHQgdG8gbGVmdCAqL1xuXHRcdHRoaXMubm9kZVVwID0gbnVsbDtcdC8qIGRpY3Rpb25hcnkgbm9kZSBjb3JyZXNwb25kaW5nIHRvIGVVcCAqL1xuXHRcdHRoaXMud2luZGluZ051bWJlciA9IDA7XHQvKiB1c2VkIHRvIGRldGVybWluZSB3aGljaCByZWdpb25zIGFyZVxuXHRcdFx0XHRcdFx0XHRcdCogaW5zaWRlIHRoZSBwb2x5Z29uICovXG5cdFx0dGhpcy5pbnNpZGUgPSBmYWxzZTtcdFx0LyogaXMgdGhpcyByZWdpb24gaW5zaWRlIHRoZSBwb2x5Z29uPyAqL1xuXHRcdHRoaXMuc2VudGluZWwgPSBmYWxzZTtcdC8qIG1hcmtzIGZha2UgZWRnZXMgYXQgdCA9ICsvLWluZmluaXR5ICovXG5cdFx0dGhpcy5kaXJ0eSA9IGZhbHNlO1x0XHQvKiBtYXJrcyByZWdpb25zIHdoZXJlIHRoZSB1cHBlciBvciBsb3dlclxuXHRcdFx0XHRcdFx0KiBlZGdlIGhhcyBjaGFuZ2VkLCBidXQgd2UgaGF2ZW4ndCBjaGVja2VkXG5cdFx0XHRcdFx0XHQqIHdoZXRoZXIgdGhleSBpbnRlcnNlY3QgeWV0ICovXG5cdFx0dGhpcy5maXhVcHBlckVkZ2UgPSBmYWxzZTtcdC8qIG1hcmtzIHRlbXBvcmFyeSBlZGdlcyBpbnRyb2R1Y2VkIHdoZW5cblx0XHRcdFx0XHRcdFx0KiB3ZSBwcm9jZXNzIGEgXCJyaWdodCB2ZXJ0ZXhcIiAob25lIHdpdGhvdXRcblx0XHRcdFx0XHRcdFx0KiBhbnkgZWRnZXMgbGVhdmluZyB0byB0aGUgcmlnaHQpICovXG5cdH07XG5cblx0dmFyIFN3ZWVwID0ge307XG5cblx0U3dlZXAucmVnaW9uQmVsb3cgPSBmdW5jdGlvbihyKSB7XG5cdFx0cmV0dXJuIHIubm9kZVVwLnByZXYua2V5O1xuXHR9XG5cblx0U3dlZXAucmVnaW9uQWJvdmUgPSBmdW5jdGlvbihyKSB7XG5cdFx0cmV0dXJuIHIubm9kZVVwLm5leHQua2V5O1xuXHR9XG5cblx0U3dlZXAuZGVidWdFdmVudCA9IGZ1bmN0aW9uKCB0ZXNzICkge1xuXHRcdC8vIGVtcHR5XG5cdH1cblxuXG5cdC8qXG5cdCogSW52YXJpYW50cyBmb3IgdGhlIEVkZ2UgRGljdGlvbmFyeS5cblx0KiAtIGVhY2ggcGFpciBvZiBhZGphY2VudCBlZGdlcyBlMj1TdWNjKGUxKSBzYXRpc2ZpZXMgRWRnZUxlcShlMSxlMilcblx0KiAgIGF0IGFueSB2YWxpZCBsb2NhdGlvbiBvZiB0aGUgc3dlZXAgZXZlbnRcblx0KiAtIGlmIEVkZ2VMZXEoZTIsZTEpIGFzIHdlbGwgKGF0IGFueSB2YWxpZCBzd2VlcCBldmVudCksIHRoZW4gZTEgYW5kIGUyXG5cdCogICBzaGFyZSBhIGNvbW1vbiBlbmRwb2ludFxuXHQqIC0gZm9yIGVhY2ggZSwgZS0+RHN0IGhhcyBiZWVuIHByb2Nlc3NlZCwgYnV0IG5vdCBlLT5Pcmdcblx0KiAtIGVhY2ggZWRnZSBlIHNhdGlzZmllcyBWZXJ0TGVxKGUtPkRzdCxldmVudCkgJiYgVmVydExlcShldmVudCxlLT5PcmcpXG5cdCogICB3aGVyZSBcImV2ZW50XCIgaXMgdGhlIGN1cnJlbnQgc3dlZXAgbGluZSBldmVudC5cblx0KiAtIG5vIGVkZ2UgZSBoYXMgemVybyBsZW5ndGhcblx0KlxuXHQqIEludmFyaWFudHMgZm9yIHRoZSBNZXNoICh0aGUgcHJvY2Vzc2VkIHBvcnRpb24pLlxuXHQqIC0gdGhlIHBvcnRpb24gb2YgdGhlIG1lc2ggbGVmdCBvZiB0aGUgc3dlZXAgbGluZSBpcyBhIHBsYW5hciBncmFwaCxcblx0KiAgIGllLiB0aGVyZSBpcyAqc29tZSogd2F5IHRvIGVtYmVkIGl0IGluIHRoZSBwbGFuZVxuXHQqIC0gbm8gcHJvY2Vzc2VkIGVkZ2UgaGFzIHplcm8gbGVuZ3RoXG5cdCogLSBubyB0d28gcHJvY2Vzc2VkIHZlcnRpY2VzIGhhdmUgaWRlbnRpY2FsIGNvb3JkaW5hdGVzXG5cdCogLSBlYWNoIFwiaW5zaWRlXCIgcmVnaW9uIGlzIG1vbm90b25lLCBpZS4gY2FuIGJlIGJyb2tlbiBpbnRvIHR3byBjaGFpbnNcblx0KiAgIG9mIG1vbm90b25pY2FsbHkgaW5jcmVhc2luZyB2ZXJ0aWNlcyBhY2NvcmRpbmcgdG8gVmVydExlcSh2MSx2Milcblx0KiAgIC0gYSBub24taW52YXJpYW50OiB0aGVzZSBjaGFpbnMgbWF5IGludGVyc2VjdCAodmVyeSBzbGlnaHRseSlcblx0KlxuXHQqIEludmFyaWFudHMgZm9yIHRoZSBTd2VlcC5cblx0KiAtIGlmIG5vbmUgb2YgdGhlIGVkZ2VzIGluY2lkZW50IHRvIHRoZSBldmVudCB2ZXJ0ZXggaGF2ZSBhbiBhY3RpdmVSZWdpb25cblx0KiAgIChpZS4gbm9uZSBvZiB0aGVzZSBlZGdlcyBhcmUgaW4gdGhlIGVkZ2UgZGljdGlvbmFyeSksIHRoZW4gdGhlIHZlcnRleFxuXHQqICAgaGFzIG9ubHkgcmlnaHQtZ29pbmcgZWRnZXMuXG5cdCogLSBpZiBhbiBlZGdlIGlzIG1hcmtlZCBcImZpeFVwcGVyRWRnZVwiIChpdCBpcyBhIHRlbXBvcmFyeSBlZGdlIGludHJvZHVjZWRcblx0KiAgIGJ5IENvbm5lY3RSaWdodFZlcnRleCksIHRoZW4gaXQgaXMgdGhlIG9ubHkgcmlnaHQtZ29pbmcgZWRnZSBmcm9tXG5cdCogICBpdHMgYXNzb2NpYXRlZCB2ZXJ0ZXguICAoVGhpcyBzYXlzIHRoYXQgdGhlc2UgZWRnZXMgZXhpc3Qgb25seVxuXHQqICAgd2hlbiBpdCBpcyBuZWNlc3NhcnkuKVxuXHQqL1xuXG5cdC8qIFdoZW4gd2UgbWVyZ2UgdHdvIGVkZ2VzIGludG8gb25lLCB3ZSBuZWVkIHRvIGNvbXB1dGUgdGhlIGNvbWJpbmVkXG5cdCogd2luZGluZyBvZiB0aGUgbmV3IGVkZ2UuXG5cdCovXG5cdFN3ZWVwLmFkZFdpbmRpbmcgPSBmdW5jdGlvbihlRHN0LGVTcmMpIHtcblx0XHRlRHN0LndpbmRpbmcgKz0gZVNyYy53aW5kaW5nO1xuXHRcdGVEc3QuU3ltLndpbmRpbmcgKz0gZVNyYy5TeW0ud2luZGluZztcblx0fVxuXG5cblx0Ly9zdGF0aWMgaW50IEVkZ2VMZXEoIFRFU1N0ZXNzZWxhdG9yICp0ZXNzLCBBY3RpdmVSZWdpb24gKnJlZzEsIEFjdGl2ZVJlZ2lvbiAqcmVnMiApXG5cdFN3ZWVwLmVkZ2VMZXEgPSBmdW5jdGlvbiggdGVzcywgcmVnMSwgcmVnMiApIHtcblx0XHQvKlxuXHRcdCogQm90aCBlZGdlcyBtdXN0IGJlIGRpcmVjdGVkIGZyb20gcmlnaHQgdG8gbGVmdCAodGhpcyBpcyB0aGUgY2Fub25pY2FsXG5cdFx0KiBkaXJlY3Rpb24gZm9yIHRoZSB1cHBlciBlZGdlIG9mIGVhY2ggcmVnaW9uKS5cblx0XHQqXG5cdFx0KiBUaGUgc3RyYXRlZ3kgaXMgdG8gZXZhbHVhdGUgYSBcInRcIiB2YWx1ZSBmb3IgZWFjaCBlZGdlIGF0IHRoZVxuXHRcdCogY3VycmVudCBzd2VlcCBsaW5lIHBvc2l0aW9uLCBnaXZlbiBieSB0ZXNzLT5ldmVudC4gIFRoZSBjYWxjdWxhdGlvbnNcblx0XHQqIGFyZSBkZXNpZ25lZCB0byBiZSB2ZXJ5IHN0YWJsZSwgYnV0IG9mIGNvdXJzZSB0aGV5IGFyZSBub3QgcGVyZmVjdC5cblx0XHQqXG5cdFx0KiBTcGVjaWFsIGNhc2U6IGlmIGJvdGggZWRnZSBkZXN0aW5hdGlvbnMgYXJlIGF0IHRoZSBzd2VlcCBldmVudCxcblx0XHQqIHdlIHNvcnQgdGhlIGVkZ2VzIGJ5IHNsb3BlICh0aGV5IHdvdWxkIG90aGVyd2lzZSBjb21wYXJlIGVxdWFsbHkpLlxuXHRcdCovXG5cdFx0dmFyIGV2ID0gdGVzcy5ldmVudDtcblx0XHR2YXIgdDEsIHQyO1xuXG5cdFx0dmFyIGUxID0gcmVnMS5lVXA7XG5cdFx0dmFyIGUyID0gcmVnMi5lVXA7XG5cblx0XHRpZiggZTEuRHN0ID09PSBldiApIHtcblx0XHRcdGlmKCBlMi5Ec3QgPT09IGV2ICkge1xuXHRcdFx0XHQvKiBUd28gZWRnZXMgcmlnaHQgb2YgdGhlIHN3ZWVwIGxpbmUgd2hpY2ggbWVldCBhdCB0aGUgc3dlZXAgZXZlbnQuXG5cdFx0XHRcdCogU29ydCB0aGVtIGJ5IHNsb3BlLlxuXHRcdFx0XHQqL1xuXHRcdFx0XHRpZiggR2VvbS52ZXJ0TGVxKCBlMS5PcmcsIGUyLk9yZyApKSB7XG5cdFx0XHRcdFx0cmV0dXJuIEdlb20uZWRnZVNpZ24oIGUyLkRzdCwgZTEuT3JnLCBlMi5PcmcgKSA8PSAwO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBHZW9tLmVkZ2VTaWduKCBlMS5Ec3QsIGUyLk9yZywgZTEuT3JnICkgPj0gMDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBHZW9tLmVkZ2VTaWduKCBlMi5Ec3QsIGV2LCBlMi5PcmcgKSA8PSAwO1xuXHRcdH1cblx0XHRpZiggZTIuRHN0ID09PSBldiApIHtcblx0XHRcdHJldHVybiBHZW9tLmVkZ2VTaWduKCBlMS5Ec3QsIGV2LCBlMS5PcmcgKSA+PSAwO1xuXHRcdH1cblxuXHRcdC8qIEdlbmVyYWwgY2FzZSAtIGNvbXB1dGUgc2lnbmVkIGRpc3RhbmNlICpmcm9tKiBlMSwgZTIgdG8gZXZlbnQgKi9cblx0XHR2YXIgdDEgPSBHZW9tLmVkZ2VFdmFsKCBlMS5Ec3QsIGV2LCBlMS5PcmcgKTtcblx0XHR2YXIgdDIgPSBHZW9tLmVkZ2VFdmFsKCBlMi5Ec3QsIGV2LCBlMi5PcmcgKTtcblx0XHRyZXR1cm4gKHQxID49IHQyKTtcblx0fVxuXG5cblx0Ly9zdGF0aWMgdm9pZCBEZWxldGVSZWdpb24oIFRFU1N0ZXNzZWxhdG9yICp0ZXNzLCBBY3RpdmVSZWdpb24gKnJlZyApXG5cdFN3ZWVwLmRlbGV0ZVJlZ2lvbiA9IGZ1bmN0aW9uKCB0ZXNzLCByZWcgKSB7XG5cdFx0aWYoIHJlZy5maXhVcHBlckVkZ2UgKSB7XG5cdFx0XHQvKiBJdCB3YXMgY3JlYXRlZCB3aXRoIHplcm8gd2luZGluZyBudW1iZXIsIHNvIGl0IGJldHRlciBiZVxuXHRcdFx0KiBkZWxldGVkIHdpdGggemVybyB3aW5kaW5nIG51bWJlciAoaWUuIGl0IGJldHRlciBub3QgZ2V0IG1lcmdlZFxuXHRcdFx0KiB3aXRoIGEgcmVhbCBlZGdlKS5cblx0XHRcdCovXG5cdFx0XHRhc3NlcnQoIHJlZy5lVXAud2luZGluZyA9PT0gMCApO1xuXHRcdH1cblx0XHRyZWcuZVVwLmFjdGl2ZVJlZ2lvbiA9IG51bGw7XG5cdFx0dGVzcy5kaWN0LmRlbGV0ZSggcmVnLm5vZGVVcCApO1xuXHR9XG5cblx0Ly9zdGF0aWMgaW50IEZpeFVwcGVyRWRnZSggVEVTU3Rlc3NlbGF0b3IgKnRlc3MsIEFjdGl2ZVJlZ2lvbiAqcmVnLCBURVNTaGFsZkVkZ2UgKm5ld0VkZ2UgKVxuXHRTd2VlcC5maXhVcHBlckVkZ2UgPSBmdW5jdGlvbiggdGVzcywgcmVnLCBuZXdFZGdlICkge1xuXHRcdC8qXG5cdFx0KiBSZXBsYWNlIGFuIHVwcGVyIGVkZ2Ugd2hpY2ggbmVlZHMgZml4aW5nIChzZWUgQ29ubmVjdFJpZ2h0VmVydGV4KS5cblx0XHQqL1xuXHRcdGFzc2VydCggcmVnLmZpeFVwcGVyRWRnZSApO1xuXHRcdHRlc3MubWVzaC5kZWxldGUoIHJlZy5lVXAgKTtcblx0XHRyZWcuZml4VXBwZXJFZGdlID0gZmFsc2U7XG5cdFx0cmVnLmVVcCA9IG5ld0VkZ2U7XG5cdFx0bmV3RWRnZS5hY3RpdmVSZWdpb24gPSByZWc7XG5cdH1cblxuXHQvL3N0YXRpYyBBY3RpdmVSZWdpb24gKlRvcExlZnRSZWdpb24oIFRFU1N0ZXNzZWxhdG9yICp0ZXNzLCBBY3RpdmVSZWdpb24gKnJlZyApXG5cdFN3ZWVwLnRvcExlZnRSZWdpb24gPSBmdW5jdGlvbiggdGVzcywgcmVnICkge1xuXHRcdHZhciBvcmcgPSByZWcuZVVwLk9yZztcblx0XHR2YXIgZTtcblxuXHRcdC8qIEZpbmQgdGhlIHJlZ2lvbiBhYm92ZSB0aGUgdXBwZXJtb3N0IGVkZ2Ugd2l0aCB0aGUgc2FtZSBvcmlnaW4gKi9cblx0XHRkbyB7XG5cdFx0XHRyZWcgPSBTd2VlcC5yZWdpb25BYm92ZSggcmVnICk7XG5cdFx0fSB3aGlsZSggcmVnLmVVcC5PcmcgPT09IG9yZyApO1xuXG5cdFx0LyogSWYgdGhlIGVkZ2UgYWJvdmUgd2FzIGEgdGVtcG9yYXJ5IGVkZ2UgaW50cm9kdWNlZCBieSBDb25uZWN0UmlnaHRWZXJ0ZXgsXG5cdFx0KiBub3cgaXMgdGhlIHRpbWUgdG8gZml4IGl0LlxuXHRcdCovXG5cdFx0aWYoIHJlZy5maXhVcHBlckVkZ2UgKSB7XG5cdFx0XHRlID0gdGVzcy5tZXNoLmNvbm5lY3QoIFN3ZWVwLnJlZ2lvbkJlbG93KHJlZykuZVVwLlN5bSwgcmVnLmVVcC5MbmV4dCApO1xuXHRcdFx0aWYgKGUgPT09IG51bGwpIHJldHVybiBudWxsO1xuXHRcdFx0U3dlZXAuZml4VXBwZXJFZGdlKCB0ZXNzLCByZWcsIGUgKTtcblx0XHRcdHJlZyA9IFN3ZWVwLnJlZ2lvbkFib3ZlKCByZWcgKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlZztcblx0fVxuXG5cdC8vc3RhdGljIEFjdGl2ZVJlZ2lvbiAqVG9wUmlnaHRSZWdpb24oIEFjdGl2ZVJlZ2lvbiAqcmVnIClcblx0U3dlZXAudG9wUmlnaHRSZWdpb24gPSBmdW5jdGlvbiggcmVnIClcblx0e1xuXHRcdHZhciBkc3QgPSByZWcuZVVwLkRzdDtcblx0XHR2YXIgcmVnID0gbnVsbDtcblx0XHQvKiBGaW5kIHRoZSByZWdpb24gYWJvdmUgdGhlIHVwcGVybW9zdCBlZGdlIHdpdGggdGhlIHNhbWUgZGVzdGluYXRpb24gKi9cblx0XHRkbyB7XG5cdFx0XHRyZWcgPSBTd2VlcC5yZWdpb25BYm92ZSggcmVnICk7XG5cdFx0fSB3aGlsZSggcmVnLmVVcC5Ec3QgPT09IGRzdCApO1xuXHRcdHJldHVybiByZWc7XG5cdH1cblxuXHQvL3N0YXRpYyBBY3RpdmVSZWdpb24gKkFkZFJlZ2lvbkJlbG93KCBURVNTdGVzc2VsYXRvciAqdGVzcywgQWN0aXZlUmVnaW9uICpyZWdBYm92ZSwgVEVTU2hhbGZFZGdlICplTmV3VXAgKVxuXHRTd2VlcC5hZGRSZWdpb25CZWxvdyA9IGZ1bmN0aW9uKCB0ZXNzLCByZWdBYm92ZSwgZU5ld1VwICkge1xuXHRcdC8qXG5cdFx0KiBBZGQgYSBuZXcgYWN0aXZlIHJlZ2lvbiB0byB0aGUgc3dlZXAgbGluZSwgKnNvbWV3aGVyZSogYmVsb3cgXCJyZWdBYm92ZVwiXG5cdFx0KiAoYWNjb3JkaW5nIHRvIHdoZXJlIHRoZSBuZXcgZWRnZSBiZWxvbmdzIGluIHRoZSBzd2VlcC1saW5lIGRpY3Rpb25hcnkpLlxuXHRcdCogVGhlIHVwcGVyIGVkZ2Ugb2YgdGhlIG5ldyByZWdpb24gd2lsbCBiZSBcImVOZXdVcFwiLlxuXHRcdCogV2luZGluZyBudW1iZXIgYW5kIFwiaW5zaWRlXCIgZmxhZyBhcmUgbm90IHVwZGF0ZWQuXG5cdFx0Ki9cblx0XHR2YXIgcmVnTmV3ID0gbmV3IEFjdGl2ZVJlZ2lvbigpO1xuXHRcdHJlZ05ldy5lVXAgPSBlTmV3VXA7XG5cdFx0cmVnTmV3Lm5vZGVVcCA9IHRlc3MuZGljdC5pbnNlcnRCZWZvcmUoIHJlZ0Fib3ZlLm5vZGVVcCwgcmVnTmV3ICk7XG5cdC8vXHRpZiAocmVnTmV3LT5ub2RlVXAgPT0gTlVMTCkgbG9uZ2ptcCh0ZXNzLT5lbnYsMSk7XG5cdFx0cmVnTmV3LmZpeFVwcGVyRWRnZSA9IGZhbHNlO1xuXHRcdHJlZ05ldy5zZW50aW5lbCA9IGZhbHNlO1xuXHRcdHJlZ05ldy5kaXJ0eSA9IGZhbHNlO1xuXG5cdFx0ZU5ld1VwLmFjdGl2ZVJlZ2lvbiA9IHJlZ05ldztcblx0XHRyZXR1cm4gcmVnTmV3O1xuXHR9XG5cblx0Ly9zdGF0aWMgaW50IElzV2luZGluZ0luc2lkZSggVEVTU3Rlc3NlbGF0b3IgKnRlc3MsIGludCBuIClcblx0U3dlZXAuaXNXaW5kaW5nSW5zaWRlID0gZnVuY3Rpb24oIHRlc3MsIG4gKSB7XG5cdFx0c3dpdGNoKCB0ZXNzLndpbmRpbmdSdWxlICkge1xuXHRcdFx0Y2FzZSBUZXNzMi5XSU5ESU5HX09ERDpcblx0XHRcdFx0cmV0dXJuIChuICYgMSkgIT0gMDtcblx0XHRcdGNhc2UgVGVzczIuV0lORElOR19OT05aRVJPOlxuXHRcdFx0XHRyZXR1cm4gKG4gIT0gMCk7XG5cdFx0XHRjYXNlIFRlc3MyLldJTkRJTkdfUE9TSVRJVkU6XG5cdFx0XHRcdHJldHVybiAobiA+IDApO1xuXHRcdFx0Y2FzZSBUZXNzMi5XSU5ESU5HX05FR0FUSVZFOlxuXHRcdFx0XHRyZXR1cm4gKG4gPCAwKTtcblx0XHRcdGNhc2UgVGVzczIuV0lORElOR19BQlNfR0VRX1RXTzpcblx0XHRcdFx0cmV0dXJuIChuID49IDIpIHx8IChuIDw9IC0yKTtcblx0XHR9XG5cdFx0YXNzZXJ0KCBmYWxzZSApO1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdC8vc3RhdGljIHZvaWQgQ29tcHV0ZVdpbmRpbmcoIFRFU1N0ZXNzZWxhdG9yICp0ZXNzLCBBY3RpdmVSZWdpb24gKnJlZyApXG5cdFN3ZWVwLmNvbXB1dGVXaW5kaW5nID0gZnVuY3Rpb24oIHRlc3MsIHJlZyApIHtcblx0XHRyZWcud2luZGluZ051bWJlciA9IFN3ZWVwLnJlZ2lvbkFib3ZlKHJlZykud2luZGluZ051bWJlciArIHJlZy5lVXAud2luZGluZztcblx0XHRyZWcuaW5zaWRlID0gU3dlZXAuaXNXaW5kaW5nSW5zaWRlKCB0ZXNzLCByZWcud2luZGluZ051bWJlciApO1xuXHR9XG5cblxuXHQvL3N0YXRpYyB2b2lkIEZpbmlzaFJlZ2lvbiggVEVTU3Rlc3NlbGF0b3IgKnRlc3MsIEFjdGl2ZVJlZ2lvbiAqcmVnIClcblx0U3dlZXAuZmluaXNoUmVnaW9uID0gZnVuY3Rpb24oIHRlc3MsIHJlZyApIHtcblx0XHQvKlxuXHRcdCogRGVsZXRlIGEgcmVnaW9uIGZyb20gdGhlIHN3ZWVwIGxpbmUuICBUaGlzIGhhcHBlbnMgd2hlbiB0aGUgdXBwZXJcblx0XHQqIGFuZCBsb3dlciBjaGFpbnMgb2YgYSByZWdpb24gbWVldCAoYXQgYSB2ZXJ0ZXggb24gdGhlIHN3ZWVwIGxpbmUpLlxuXHRcdCogVGhlIFwiaW5zaWRlXCIgZmxhZyBpcyBjb3BpZWQgdG8gdGhlIGFwcHJvcHJpYXRlIG1lc2ggZmFjZSAod2UgY291bGRcblx0XHQqIG5vdCBkbyB0aGlzIGJlZm9yZSAtLSBzaW5jZSB0aGUgc3RydWN0dXJlIG9mIHRoZSBtZXNoIGlzIGFsd2F5c1xuXHRcdCogY2hhbmdpbmcsIHRoaXMgZmFjZSBtYXkgbm90IGhhdmUgZXZlbiBleGlzdGVkIHVudGlsIG5vdykuXG5cdFx0Ki9cblx0XHR2YXIgZSA9IHJlZy5lVXA7XG5cdFx0dmFyIGYgPSBlLkxmYWNlO1xuXG5cdFx0Zi5pbnNpZGUgPSByZWcuaW5zaWRlO1xuXHRcdGYuYW5FZGdlID0gZTsgICAvKiBvcHRpbWl6YXRpb24gZm9yIHRlc3NNZXNoVGVzc2VsbGF0ZU1vbm9SZWdpb24oKSAqL1xuXHRcdFN3ZWVwLmRlbGV0ZVJlZ2lvbiggdGVzcywgcmVnICk7XG5cdH1cblxuXG5cdC8vc3RhdGljIFRFU1NoYWxmRWRnZSAqRmluaXNoTGVmdFJlZ2lvbnMoIFRFU1N0ZXNzZWxhdG9yICp0ZXNzLCBBY3RpdmVSZWdpb24gKnJlZ0ZpcnN0LCBBY3RpdmVSZWdpb24gKnJlZ0xhc3QgKVxuXHRTd2VlcC5maW5pc2hMZWZ0UmVnaW9ucyA9IGZ1bmN0aW9uKCB0ZXNzLCByZWdGaXJzdCwgcmVnTGFzdCApIHtcblx0XHQvKlxuXHRcdCogV2UgYXJlIGdpdmVuIGEgdmVydGV4IHdpdGggb25lIG9yIG1vcmUgbGVmdC1nb2luZyBlZGdlcy4gIEFsbCBhZmZlY3RlZFxuXHRcdCogZWRnZXMgc2hvdWxkIGJlIGluIHRoZSBlZGdlIGRpY3Rpb25hcnkuICBTdGFydGluZyBhdCByZWdGaXJzdC0+ZVVwLFxuXHRcdCogd2Ugd2FsayBkb3duIGRlbGV0aW5nIGFsbCByZWdpb25zIHdoZXJlIGJvdGggZWRnZXMgaGF2ZSB0aGUgc2FtZVxuXHRcdCogb3JpZ2luIHZPcmcuICBBdCB0aGUgc2FtZSB0aW1lIHdlIGNvcHkgdGhlIFwiaW5zaWRlXCIgZmxhZyBmcm9tIHRoZVxuXHRcdCogYWN0aXZlIHJlZ2lvbiB0byB0aGUgZmFjZSwgc2luY2UgYXQgdGhpcyBwb2ludCBlYWNoIGZhY2Ugd2lsbCBiZWxvbmdcblx0XHQqIHRvIGF0IG1vc3Qgb25lIHJlZ2lvbiAodGhpcyB3YXMgbm90IG5lY2Vzc2FyaWx5IHRydWUgdW50aWwgdGhpcyBwb2ludFxuXHRcdCogaW4gdGhlIHN3ZWVwKS4gIFRoZSB3YWxrIHN0b3BzIGF0IHRoZSByZWdpb24gYWJvdmUgcmVnTGFzdDsgaWYgcmVnTGFzdFxuXHRcdCogaXMgTlVMTCB3ZSB3YWxrIGFzIGZhciBhcyBwb3NzaWJsZS4gIEF0IHRoZSBzYW1lIHRpbWUgd2UgcmVsaW5rIHRoZVxuXHRcdCogbWVzaCBpZiBuZWNlc3NhcnksIHNvIHRoYXQgdGhlIG9yZGVyaW5nIG9mIGVkZ2VzIGFyb3VuZCB2T3JnIGlzIHRoZVxuXHRcdCogc2FtZSBhcyBpbiB0aGUgZGljdGlvbmFyeS5cblx0XHQqL1xuXHRcdHZhciBlLCBlUHJldjtcblx0XHR2YXIgcmVnID0gbnVsbDtcblx0XHR2YXIgcmVnUHJldiA9IHJlZ0ZpcnN0O1xuXHRcdHZhciBlUHJldiA9IHJlZ0ZpcnN0LmVVcDtcblx0XHR3aGlsZSggcmVnUHJldiAhPT0gcmVnTGFzdCApIHtcblx0XHRcdHJlZ1ByZXYuZml4VXBwZXJFZGdlID0gZmFsc2U7XHQvKiBwbGFjZW1lbnQgd2FzIE9LICovXG5cdFx0XHRyZWcgPSBTd2VlcC5yZWdpb25CZWxvdyggcmVnUHJldiApO1xuXHRcdFx0ZSA9IHJlZy5lVXA7XG5cdFx0XHRpZiggZS5PcmcgIT0gZVByZXYuT3JnICkge1xuXHRcdFx0XHRpZiggISByZWcuZml4VXBwZXJFZGdlICkge1xuXHRcdFx0XHRcdC8qIFJlbW92ZSB0aGUgbGFzdCBsZWZ0LWdvaW5nIGVkZ2UuICBFdmVuIHRob3VnaCB0aGVyZSBhcmUgbm8gZnVydGhlclxuXHRcdFx0XHRcdCogZWRnZXMgaW4gdGhlIGRpY3Rpb25hcnkgd2l0aCB0aGlzIG9yaWdpbiwgdGhlcmUgbWF5IGJlIGZ1cnRoZXJcblx0XHRcdFx0XHQqIHN1Y2ggZWRnZXMgaW4gdGhlIG1lc2ggKGlmIHdlIGFyZSBhZGRpbmcgbGVmdCBlZGdlcyB0byBhIHZlcnRleFxuXHRcdFx0XHRcdCogdGhhdCBoYXMgYWxyZWFkeSBiZWVuIHByb2Nlc3NlZCkuICBUaHVzIGl0IGlzIGltcG9ydGFudCB0byBjYWxsXG5cdFx0XHRcdFx0KiBGaW5pc2hSZWdpb24gcmF0aGVyIHRoYW4ganVzdCBEZWxldGVSZWdpb24uXG5cdFx0XHRcdFx0Ki9cblx0XHRcdFx0XHRTd2VlcC5maW5pc2hSZWdpb24oIHRlc3MsIHJlZ1ByZXYgKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0XHQvKiBJZiB0aGUgZWRnZSBiZWxvdyB3YXMgYSB0ZW1wb3JhcnkgZWRnZSBpbnRyb2R1Y2VkIGJ5XG5cdFx0XHRcdCogQ29ubmVjdFJpZ2h0VmVydGV4LCBub3cgaXMgdGhlIHRpbWUgdG8gZml4IGl0LlxuXHRcdFx0XHQqL1xuXHRcdFx0XHRlID0gdGVzcy5tZXNoLmNvbm5lY3QoIGVQcmV2LkxwcmV2LCBlLlN5bSApO1xuXHQvL1x0XHRcdGlmIChlID09IE5VTEwpIGxvbmdqbXAodGVzcy0+ZW52LDEpO1xuXHRcdFx0XHRTd2VlcC5maXhVcHBlckVkZ2UoIHRlc3MsIHJlZywgZSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvKiBSZWxpbmsgZWRnZXMgc28gdGhhdCBlUHJldi0+T25leHQgPT0gZSAqL1xuXHRcdFx0aWYoIGVQcmV2Lk9uZXh0ICE9PSBlICkge1xuXHRcdFx0XHR0ZXNzLm1lc2guc3BsaWNlKCBlLk9wcmV2LCBlICk7XG5cdFx0XHRcdHRlc3MubWVzaC5zcGxpY2UoIGVQcmV2LCBlICk7XG5cdFx0XHR9XG5cdFx0XHRTd2VlcC5maW5pc2hSZWdpb24oIHRlc3MsIHJlZ1ByZXYgKTtcdC8qIG1heSBjaGFuZ2UgcmVnLT5lVXAgKi9cblx0XHRcdGVQcmV2ID0gcmVnLmVVcDtcblx0XHRcdHJlZ1ByZXYgPSByZWc7XG5cdFx0fVxuXHRcdHJldHVybiBlUHJldjtcblx0fVxuXG5cblx0Ly9zdGF0aWMgdm9pZCBBZGRSaWdodEVkZ2VzKCBURVNTdGVzc2VsYXRvciAqdGVzcywgQWN0aXZlUmVnaW9uICpyZWdVcCwgVEVTU2hhbGZFZGdlICplRmlyc3QsIFRFU1NoYWxmRWRnZSAqZUxhc3QsIFRFU1NoYWxmRWRnZSAqZVRvcExlZnQsIGludCBjbGVhblVwIClcblx0U3dlZXAuYWRkUmlnaHRFZGdlcyA9IGZ1bmN0aW9uKCB0ZXNzLCByZWdVcCwgZUZpcnN0LCBlTGFzdCwgZVRvcExlZnQsIGNsZWFuVXAgKSB7XG5cdFx0Lypcblx0XHQqIFB1cnBvc2U6IGluc2VydCByaWdodC1nb2luZyBlZGdlcyBpbnRvIHRoZSBlZGdlIGRpY3Rpb25hcnksIGFuZCB1cGRhdGVcblx0XHQqIHdpbmRpbmcgbnVtYmVycyBhbmQgbWVzaCBjb25uZWN0aXZpdHkgYXBwcm9wcmlhdGVseS4gIEFsbCByaWdodC1nb2luZ1xuXHRcdCogZWRnZXMgc2hhcmUgYSBjb21tb24gb3JpZ2luIHZPcmcuICBFZGdlcyBhcmUgaW5zZXJ0ZWQgQ0NXIHN0YXJ0aW5nIGF0XG5cdFx0KiBlRmlyc3Q7IHRoZSBsYXN0IGVkZ2UgaW5zZXJ0ZWQgaXMgZUxhc3QtPk9wcmV2LiAgSWYgdk9yZyBoYXMgYW55XG5cdFx0KiBsZWZ0LWdvaW5nIGVkZ2VzIGFscmVhZHkgcHJvY2Vzc2VkLCB0aGVuIGVUb3BMZWZ0IG11c3QgYmUgdGhlIGVkZ2Vcblx0XHQqIHN1Y2ggdGhhdCBhbiBpbWFnaW5hcnkgdXB3YXJkIHZlcnRpY2FsIHNlZ21lbnQgZnJvbSB2T3JnIHdvdWxkIGJlXG5cdFx0KiBjb250YWluZWQgYmV0d2VlbiBlVG9wTGVmdC0+T3ByZXYgYW5kIGVUb3BMZWZ0OyBvdGhlcndpc2UgZVRvcExlZnRcblx0XHQqIHNob3VsZCBiZSBOVUxMLlxuXHRcdCovXG5cdFx0dmFyIHJlZywgcmVnUHJldjtcblx0XHR2YXIgZSwgZVByZXY7XG5cdFx0dmFyIGZpcnN0VGltZSA9IHRydWU7XG5cblx0XHQvKiBJbnNlcnQgdGhlIG5ldyByaWdodC1nb2luZyBlZGdlcyBpbiB0aGUgZGljdGlvbmFyeSAqL1xuXHRcdGUgPSBlRmlyc3Q7XG5cdFx0ZG8ge1xuXHRcdFx0YXNzZXJ0KCBHZW9tLnZlcnRMZXEoIGUuT3JnLCBlLkRzdCApKTtcblx0XHRcdFN3ZWVwLmFkZFJlZ2lvbkJlbG93KCB0ZXNzLCByZWdVcCwgZS5TeW0gKTtcblx0XHRcdGUgPSBlLk9uZXh0O1xuXHRcdH0gd2hpbGUgKCBlICE9PSBlTGFzdCApO1xuXG5cdFx0LyogV2FsayAqYWxsKiByaWdodC1nb2luZyBlZGdlcyBmcm9tIGUtPk9yZywgaW4gdGhlIGRpY3Rpb25hcnkgb3JkZXIsXG5cdFx0KiB1cGRhdGluZyB0aGUgd2luZGluZyBudW1iZXJzIG9mIGVhY2ggcmVnaW9uLCBhbmQgcmUtbGlua2luZyB0aGUgbWVzaFxuXHRcdCogZWRnZXMgdG8gbWF0Y2ggdGhlIGRpY3Rpb25hcnkgb3JkZXJpbmcgKGlmIG5lY2Vzc2FyeSkuXG5cdFx0Ki9cblx0XHRpZiggZVRvcExlZnQgPT09IG51bGwgKSB7XG5cdFx0XHRlVG9wTGVmdCA9IFN3ZWVwLnJlZ2lvbkJlbG93KCByZWdVcCApLmVVcC5ScHJldjtcblx0XHR9XG5cdFx0cmVnUHJldiA9IHJlZ1VwO1xuXHRcdGVQcmV2ID0gZVRvcExlZnQ7XG5cdFx0Zm9yKCA7OyApIHtcblx0XHRcdHJlZyA9IFN3ZWVwLnJlZ2lvbkJlbG93KCByZWdQcmV2ICk7XG5cdFx0XHRlID0gcmVnLmVVcC5TeW07XG5cdFx0XHRpZiggZS5PcmcgIT09IGVQcmV2Lk9yZyApIGJyZWFrO1xuXG5cdFx0XHRpZiggZS5PbmV4dCAhPT0gZVByZXYgKSB7XG5cdFx0XHRcdC8qIFVubGluayBlIGZyb20gaXRzIGN1cnJlbnQgcG9zaXRpb24sIGFuZCByZWxpbmsgYmVsb3cgZVByZXYgKi9cblx0XHRcdFx0dGVzcy5tZXNoLnNwbGljZSggZS5PcHJldiwgZSApO1xuXHRcdFx0XHR0ZXNzLm1lc2guc3BsaWNlKCBlUHJldi5PcHJldiwgZSApO1xuXHRcdFx0fVxuXHRcdFx0LyogQ29tcHV0ZSB0aGUgd2luZGluZyBudW1iZXIgYW5kIFwiaW5zaWRlXCIgZmxhZyBmb3IgdGhlIG5ldyByZWdpb25zICovXG5cdFx0XHRyZWcud2luZGluZ051bWJlciA9IHJlZ1ByZXYud2luZGluZ051bWJlciAtIGUud2luZGluZztcblx0XHRcdHJlZy5pbnNpZGUgPSBTd2VlcC5pc1dpbmRpbmdJbnNpZGUoIHRlc3MsIHJlZy53aW5kaW5nTnVtYmVyICk7XG5cblx0XHRcdC8qIENoZWNrIGZvciB0d28gb3V0Z29pbmcgZWRnZXMgd2l0aCBzYW1lIHNsb3BlIC0tIHByb2Nlc3MgdGhlc2Vcblx0XHRcdCogYmVmb3JlIGFueSBpbnRlcnNlY3Rpb24gdGVzdHMgKHNlZSBleGFtcGxlIGluIHRlc3NDb21wdXRlSW50ZXJpb3IpLlxuXHRcdFx0Ki9cblx0XHRcdHJlZ1ByZXYuZGlydHkgPSB0cnVlO1xuXHRcdFx0aWYoICEgZmlyc3RUaW1lICYmIFN3ZWVwLmNoZWNrRm9yUmlnaHRTcGxpY2UoIHRlc3MsIHJlZ1ByZXYgKSkge1xuXHRcdFx0XHRTd2VlcC5hZGRXaW5kaW5nKCBlLCBlUHJldiApO1xuXHRcdFx0XHRTd2VlcC5kZWxldGVSZWdpb24oIHRlc3MsIHJlZ1ByZXYgKTtcblx0XHRcdFx0dGVzcy5tZXNoLmRlbGV0ZSggZVByZXYgKTtcblx0XHRcdH1cblx0XHRcdGZpcnN0VGltZSA9IGZhbHNlO1xuXHRcdFx0cmVnUHJldiA9IHJlZztcblx0XHRcdGVQcmV2ID0gZTtcblx0XHR9XG5cdFx0cmVnUHJldi5kaXJ0eSA9IHRydWU7XG5cdFx0YXNzZXJ0KCByZWdQcmV2LndpbmRpbmdOdW1iZXIgLSBlLndpbmRpbmcgPT09IHJlZy53aW5kaW5nTnVtYmVyICk7XG5cblx0XHRpZiggY2xlYW5VcCApIHtcblx0XHRcdC8qIENoZWNrIGZvciBpbnRlcnNlY3Rpb25zIGJldHdlZW4gbmV3bHkgYWRqYWNlbnQgZWRnZXMuICovXG5cdFx0XHRTd2VlcC53YWxrRGlydHlSZWdpb25zKCB0ZXNzLCByZWdQcmV2ICk7XG5cdFx0fVxuXHR9XG5cblxuXHQvL3N0YXRpYyB2b2lkIFNwbGljZU1lcmdlVmVydGljZXMoIFRFU1N0ZXNzZWxhdG9yICp0ZXNzLCBURVNTaGFsZkVkZ2UgKmUxLCBURVNTaGFsZkVkZ2UgKmUyIClcblx0U3dlZXAuc3BsaWNlTWVyZ2VWZXJ0aWNlcyA9IGZ1bmN0aW9uKCB0ZXNzLCBlMSwgZTIgKSB7XG5cdFx0Lypcblx0XHQqIFR3byB2ZXJ0aWNlcyB3aXRoIGlkZW50aWFsIGNvb3JkaW5hdGVzIGFyZSBjb21iaW5lZCBpbnRvIG9uZS5cblx0XHQqIGUxLT5PcmcgaXMga2VwdCwgd2hpbGUgZTItPk9yZyBpcyBkaXNjYXJkZWQuXG5cdFx0Ki9cblx0XHR0ZXNzLm1lc2guc3BsaWNlKCBlMSwgZTIgKTsgXG5cdH1cblxuXHQvL3N0YXRpYyB2b2lkIFZlcnRleFdlaWdodHMoIFRFU1N2ZXJ0ZXggKmlzZWN0LCBURVNTdmVydGV4ICpvcmcsIFRFU1N2ZXJ0ZXggKmRzdCwgVEVTU3JlYWwgKndlaWdodHMgKVxuXHRTd2VlcC52ZXJ0ZXhXZWlnaHRzID0gZnVuY3Rpb24oIGlzZWN0LCBvcmcsIGRzdCApIHtcblx0XHQvKlxuXHRcdCogRmluZCBzb21lIHdlaWdodHMgd2hpY2ggZGVzY3JpYmUgaG93IHRoZSBpbnRlcnNlY3Rpb24gdmVydGV4IGlzXG5cdFx0KiBhIGxpbmVhciBjb21iaW5hdGlvbiBvZiBcIm9yZ1wiIGFuZCBcImRlc3RcIi4gIEVhY2ggb2YgdGhlIHR3byBlZGdlc1xuXHRcdCogd2hpY2ggZ2VuZXJhdGVkIFwiaXNlY3RcIiBpcyBhbGxvY2F0ZWQgNTAlIG9mIHRoZSB3ZWlnaHQ7IGVhY2ggZWRnZVxuXHRcdCogc3BsaXRzIHRoZSB3ZWlnaHQgYmV0d2VlbiBpdHMgb3JnIGFuZCBkc3QgYWNjb3JkaW5nIHRvIHRoZVxuXHRcdCogcmVsYXRpdmUgZGlzdGFuY2UgdG8gXCJpc2VjdFwiLlxuXHRcdCovXG5cdFx0dmFyIHQxID0gR2VvbS52ZXJ0TDFkaXN0KCBvcmcsIGlzZWN0ICk7XG5cdFx0dmFyIHQyID0gR2VvbS52ZXJ0TDFkaXN0KCBkc3QsIGlzZWN0ICk7XG5cdFx0dmFyIHcwID0gMC41ICogdDIgLyAodDEgKyB0Mik7XG5cdFx0dmFyIHcxID0gMC41ICogdDEgLyAodDEgKyB0Mik7XG5cdFx0aXNlY3QuY29vcmRzWzBdICs9IHcwKm9yZy5jb29yZHNbMF0gKyB3MSpkc3QuY29vcmRzWzBdO1xuXHRcdGlzZWN0LmNvb3Jkc1sxXSArPSB3MCpvcmcuY29vcmRzWzFdICsgdzEqZHN0LmNvb3Jkc1sxXTtcblx0XHRpc2VjdC5jb29yZHNbMl0gKz0gdzAqb3JnLmNvb3Jkc1syXSArIHcxKmRzdC5jb29yZHNbMl07XG5cdH1cblxuXG5cdC8vc3RhdGljIHZvaWQgR2V0SW50ZXJzZWN0RGF0YSggVEVTU3Rlc3NlbGF0b3IgKnRlc3MsIFRFU1N2ZXJ0ZXggKmlzZWN0LCBURVNTdmVydGV4ICpvcmdVcCwgVEVTU3ZlcnRleCAqZHN0VXAsIFRFU1N2ZXJ0ZXggKm9yZ0xvLCBURVNTdmVydGV4ICpkc3RMbyApXG5cdFN3ZWVwLmdldEludGVyc2VjdERhdGEgPSBmdW5jdGlvbiggdGVzcywgaXNlY3QsIG9yZ1VwLCBkc3RVcCwgb3JnTG8sIGRzdExvICkge1xuXHRcdCAvKlxuXHRcdCAqIFdlJ3ZlIGNvbXB1dGVkIGEgbmV3IGludGVyc2VjdGlvbiBwb2ludCwgbm93IHdlIG5lZWQgYSBcImRhdGFcIiBwb2ludGVyXG5cdFx0ICogZnJvbSB0aGUgdXNlciBzbyB0aGF0IHdlIGNhbiByZWZlciB0byB0aGlzIG5ldyB2ZXJ0ZXggaW4gdGhlXG5cdFx0ICogcmVuZGVyaW5nIGNhbGxiYWNrcy5cblx0XHQgKi9cblx0XHRpc2VjdC5jb29yZHNbMF0gPSBpc2VjdC5jb29yZHNbMV0gPSBpc2VjdC5jb29yZHNbMl0gPSAwO1xuXHRcdGlzZWN0LmlkeCA9IC0xO1xuXHRcdFN3ZWVwLnZlcnRleFdlaWdodHMoIGlzZWN0LCBvcmdVcCwgZHN0VXAgKTtcblx0XHRTd2VlcC52ZXJ0ZXhXZWlnaHRzKCBpc2VjdCwgb3JnTG8sIGRzdExvICk7XG5cdH1cblxuXHQvL3N0YXRpYyBpbnQgQ2hlY2tGb3JSaWdodFNwbGljZSggVEVTU3Rlc3NlbGF0b3IgKnRlc3MsIEFjdGl2ZVJlZ2lvbiAqcmVnVXAgKVxuXHRTd2VlcC5jaGVja0ZvclJpZ2h0U3BsaWNlID0gZnVuY3Rpb24oIHRlc3MsIHJlZ1VwICkge1xuXHRcdC8qXG5cdFx0KiBDaGVjayB0aGUgdXBwZXIgYW5kIGxvd2VyIGVkZ2Ugb2YgXCJyZWdVcFwiLCB0byBtYWtlIHN1cmUgdGhhdCB0aGVcblx0XHQqIGVVcC0+T3JnIGlzIGFib3ZlIGVMbywgb3IgZUxvLT5PcmcgaXMgYmVsb3cgZVVwIChkZXBlbmRpbmcgb24gd2hpY2hcblx0XHQqIG9yaWdpbiBpcyBsZWZ0bW9zdCkuXG5cdFx0KlxuXHRcdCogVGhlIG1haW4gcHVycG9zZSBpcyB0byBzcGxpY2UgcmlnaHQtZ29pbmcgZWRnZXMgd2l0aCB0aGUgc2FtZVxuXHRcdCogZGVzdCB2ZXJ0ZXggYW5kIG5lYXJseSBpZGVudGljYWwgc2xvcGVzIChpZS4gd2UgY2FuJ3QgZGlzdGluZ3Vpc2hcblx0XHQqIHRoZSBzbG9wZXMgbnVtZXJpY2FsbHkpLiAgSG93ZXZlciB0aGUgc3BsaWNpbmcgY2FuIGFsc28gaGVscCB1c1xuXHRcdCogdG8gcmVjb3ZlciBmcm9tIG51bWVyaWNhbCBlcnJvcnMuICBGb3IgZXhhbXBsZSwgc3VwcG9zZSBhdCBvbmVcblx0XHQqIHBvaW50IHdlIGNoZWNrZWQgZVVwIGFuZCBlTG8sIGFuZCBkZWNpZGVkIHRoYXQgZVVwLT5PcmcgaXMgYmFyZWx5XG5cdFx0KiBhYm92ZSBlTG8uICBUaGVuIGxhdGVyLCB3ZSBzcGxpdCBlTG8gaW50byB0d28gZWRnZXMgKGVnLiBmcm9tXG5cdFx0KiBhIHNwbGljZSBvcGVyYXRpb24gbGlrZSB0aGlzIG9uZSkuICBUaGlzIGNhbiBjaGFuZ2UgdGhlIHJlc3VsdCBvZlxuXHRcdCogb3VyIHRlc3Qgc28gdGhhdCBub3cgZVVwLT5PcmcgaXMgaW5jaWRlbnQgdG8gZUxvLCBvciBiYXJlbHkgYmVsb3cgaXQuXG5cdFx0KiBXZSBtdXN0IGNvcnJlY3QgdGhpcyBjb25kaXRpb24gdG8gbWFpbnRhaW4gdGhlIGRpY3Rpb25hcnkgaW52YXJpYW50cy5cblx0XHQqXG5cdFx0KiBPbmUgcG9zc2liaWxpdHkgaXMgdG8gY2hlY2sgdGhlc2UgZWRnZXMgZm9yIGludGVyc2VjdGlvbiBhZ2FpblxuXHRcdCogKGllLiBDaGVja0ZvckludGVyc2VjdCkuICBUaGlzIGlzIHdoYXQgd2UgZG8gaWYgcG9zc2libGUuICBIb3dldmVyXG5cdFx0KiBDaGVja0ZvckludGVyc2VjdCByZXF1aXJlcyB0aGF0IHRlc3MtPmV2ZW50IGxpZXMgYmV0d2VlbiBlVXAgYW5kIGVMbyxcblx0XHQqIHNvIHRoYXQgaXQgaGFzIHNvbWV0aGluZyB0byBmYWxsIGJhY2sgb24gd2hlbiB0aGUgaW50ZXJzZWN0aW9uXG5cdFx0KiBjYWxjdWxhdGlvbiBnaXZlcyB1cyBhbiB1bnVzYWJsZSBhbnN3ZXIuICBTbywgZm9yIHRob3NlIGNhc2VzIHdoZXJlXG5cdFx0KiB3ZSBjYW4ndCBjaGVjayBmb3IgaW50ZXJzZWN0aW9uLCB0aGlzIHJvdXRpbmUgZml4ZXMgdGhlIHByb2JsZW1cblx0XHQqIGJ5IGp1c3Qgc3BsaWNpbmcgdGhlIG9mZmVuZGluZyB2ZXJ0ZXggaW50byB0aGUgb3RoZXIgZWRnZS5cblx0XHQqIFRoaXMgaXMgYSBndWFyYW50ZWVkIHNvbHV0aW9uLCBubyBtYXR0ZXIgaG93IGRlZ2VuZXJhdGUgdGhpbmdzIGdldC5cblx0XHQqIEJhc2ljYWxseSB0aGlzIGlzIGEgY29tYmluYXRvcmlhbCBzb2x1dGlvbiB0byBhIG51bWVyaWNhbCBwcm9ibGVtLlxuXHRcdCovXG5cdFx0dmFyIHJlZ0xvID0gU3dlZXAucmVnaW9uQmVsb3cocmVnVXApO1xuXHRcdHZhciBlVXAgPSByZWdVcC5lVXA7XG5cdFx0dmFyIGVMbyA9IHJlZ0xvLmVVcDtcblxuXHRcdGlmKCBHZW9tLnZlcnRMZXEoIGVVcC5PcmcsIGVMby5PcmcgKSkge1xuXHRcdFx0aWYoIEdlb20uZWRnZVNpZ24oIGVMby5Ec3QsIGVVcC5PcmcsIGVMby5PcmcgKSA+IDAgKSByZXR1cm4gZmFsc2U7XG5cblx0XHRcdC8qIGVVcC0+T3JnIGFwcGVhcnMgdG8gYmUgYmVsb3cgZUxvICovXG5cdFx0XHRpZiggISBHZW9tLnZlcnRFcSggZVVwLk9yZywgZUxvLk9yZyApKSB7XG5cdFx0XHRcdC8qIFNwbGljZSBlVXAtPk9yZyBpbnRvIGVMbyAqL1xuXHRcdFx0XHR0ZXNzLm1lc2guc3BsaXRFZGdlKCBlTG8uU3ltICk7XG5cdFx0XHRcdHRlc3MubWVzaC5zcGxpY2UoIGVVcCwgZUxvLk9wcmV2ICk7XG5cdFx0XHRcdHJlZ1VwLmRpcnR5ID0gcmVnTG8uZGlydHkgPSB0cnVlO1xuXG5cdFx0XHR9IGVsc2UgaWYoIGVVcC5PcmcgIT09IGVMby5PcmcgKSB7XG5cdFx0XHRcdC8qIG1lcmdlIHRoZSB0d28gdmVydGljZXMsIGRpc2NhcmRpbmcgZVVwLT5PcmcgKi9cblx0XHRcdFx0dGVzcy5wcS5kZWxldGUoIGVVcC5PcmcucHFIYW5kbGUgKTtcblx0XHRcdFx0U3dlZXAuc3BsaWNlTWVyZ2VWZXJ0aWNlcyggdGVzcywgZUxvLk9wcmV2LCBlVXAgKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYoIEdlb20uZWRnZVNpZ24oIGVVcC5Ec3QsIGVMby5PcmcsIGVVcC5PcmcgKSA8IDAgKSByZXR1cm4gZmFsc2U7XG5cblx0XHRcdC8qIGVMby0+T3JnIGFwcGVhcnMgdG8gYmUgYWJvdmUgZVVwLCBzbyBzcGxpY2UgZUxvLT5PcmcgaW50byBlVXAgKi9cblx0XHRcdFN3ZWVwLnJlZ2lvbkFib3ZlKHJlZ1VwKS5kaXJ0eSA9IHJlZ1VwLmRpcnR5ID0gdHJ1ZTtcblx0XHRcdHRlc3MubWVzaC5zcGxpdEVkZ2UoIGVVcC5TeW0gKTtcblx0XHRcdHRlc3MubWVzaC5zcGxpY2UoIGVMby5PcHJldiwgZVVwICk7XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0Ly9zdGF0aWMgaW50IENoZWNrRm9yTGVmdFNwbGljZSggVEVTU3Rlc3NlbGF0b3IgKnRlc3MsIEFjdGl2ZVJlZ2lvbiAqcmVnVXAgKVxuXHRTd2VlcC5jaGVja0ZvckxlZnRTcGxpY2UgPSBmdW5jdGlvbiggdGVzcywgcmVnVXAgKSB7XG5cdFx0Lypcblx0XHQqIENoZWNrIHRoZSB1cHBlciBhbmQgbG93ZXIgZWRnZSBvZiBcInJlZ1VwXCIsIHRvIG1ha2Ugc3VyZSB0aGF0IHRoZVxuXHRcdCogZVVwLT5Ec3QgaXMgYWJvdmUgZUxvLCBvciBlTG8tPkRzdCBpcyBiZWxvdyBlVXAgKGRlcGVuZGluZyBvbiB3aGljaFxuXHRcdCogZGVzdGluYXRpb24gaXMgcmlnaHRtb3N0KS5cblx0XHQqXG5cdFx0KiBUaGVvcmV0aWNhbGx5LCB0aGlzIHNob3VsZCBhbHdheXMgYmUgdHJ1ZS4gIEhvd2V2ZXIsIHNwbGl0dGluZyBhbiBlZGdlXG5cdFx0KiBpbnRvIHR3byBwaWVjZXMgY2FuIGNoYW5nZSB0aGUgcmVzdWx0cyBvZiBwcmV2aW91cyB0ZXN0cy4gIEZvciBleGFtcGxlLFxuXHRcdCogc3VwcG9zZSBhdCBvbmUgcG9pbnQgd2UgY2hlY2tlZCBlVXAgYW5kIGVMbywgYW5kIGRlY2lkZWQgdGhhdCBlVXAtPkRzdFxuXHRcdCogaXMgYmFyZWx5IGFib3ZlIGVMby4gIFRoZW4gbGF0ZXIsIHdlIHNwbGl0IGVMbyBpbnRvIHR3byBlZGdlcyAoZWcuIGZyb21cblx0XHQqIGEgc3BsaWNlIG9wZXJhdGlvbiBsaWtlIHRoaXMgb25lKS4gIFRoaXMgY2FuIGNoYW5nZSB0aGUgcmVzdWx0IG9mXG5cdFx0KiB0aGUgdGVzdCBzbyB0aGF0IG5vdyBlVXAtPkRzdCBpcyBpbmNpZGVudCB0byBlTG8sIG9yIGJhcmVseSBiZWxvdyBpdC5cblx0XHQqIFdlIG11c3QgY29ycmVjdCB0aGlzIGNvbmRpdGlvbiB0byBtYWludGFpbiB0aGUgZGljdGlvbmFyeSBpbnZhcmlhbnRzXG5cdFx0KiAob3RoZXJ3aXNlIG5ldyBlZGdlcyBtaWdodCBnZXQgaW5zZXJ0ZWQgaW4gdGhlIHdyb25nIHBsYWNlIGluIHRoZVxuXHRcdCogZGljdGlvbmFyeSwgYW5kIGJhZCBzdHVmZiB3aWxsIGhhcHBlbikuXG5cdFx0KlxuXHRcdCogV2UgZml4IHRoZSBwcm9ibGVtIGJ5IGp1c3Qgc3BsaWNpbmcgdGhlIG9mZmVuZGluZyB2ZXJ0ZXggaW50byB0aGVcblx0XHQqIG90aGVyIGVkZ2UuXG5cdFx0Ki9cblx0XHR2YXIgcmVnTG8gPSBTd2VlcC5yZWdpb25CZWxvdyhyZWdVcCk7XG5cdFx0dmFyIGVVcCA9IHJlZ1VwLmVVcDtcblx0XHR2YXIgZUxvID0gcmVnTG8uZVVwO1xuXHRcdHZhciBlO1xuXG5cdFx0YXNzZXJ0KCAhIEdlb20udmVydEVxKCBlVXAuRHN0LCBlTG8uRHN0ICkpO1xuXG5cdFx0aWYoIEdlb20udmVydExlcSggZVVwLkRzdCwgZUxvLkRzdCApKSB7XG5cdFx0XHRpZiggR2VvbS5lZGdlU2lnbiggZVVwLkRzdCwgZUxvLkRzdCwgZVVwLk9yZyApIDwgMCApIHJldHVybiBmYWxzZTtcblxuXHRcdFx0LyogZUxvLT5Ec3QgaXMgYWJvdmUgZVVwLCBzbyBzcGxpY2UgZUxvLT5Ec3QgaW50byBlVXAgKi9cblx0XHRcdFN3ZWVwLnJlZ2lvbkFib3ZlKHJlZ1VwKS5kaXJ0eSA9IHJlZ1VwLmRpcnR5ID0gdHJ1ZTtcblx0XHRcdGUgPSB0ZXNzLm1lc2guc3BsaXRFZGdlKCBlVXAgKTtcblx0XHRcdHRlc3MubWVzaC5zcGxpY2UoIGVMby5TeW0sIGUgKTtcblx0XHRcdGUuTGZhY2UuaW5zaWRlID0gcmVnVXAuaW5zaWRlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiggR2VvbS5lZGdlU2lnbiggZUxvLkRzdCwgZVVwLkRzdCwgZUxvLk9yZyApID4gMCApIHJldHVybiBmYWxzZTtcblxuXHRcdFx0LyogZVVwLT5Ec3QgaXMgYmVsb3cgZUxvLCBzbyBzcGxpY2UgZVVwLT5Ec3QgaW50byBlTG8gKi9cblx0XHRcdHJlZ1VwLmRpcnR5ID0gcmVnTG8uZGlydHkgPSB0cnVlO1xuXHRcdFx0ZSA9IHRlc3MubWVzaC5zcGxpdEVkZ2UoIGVMbyApO1xuXHRcdFx0dGVzcy5tZXNoLnNwbGljZSggZVVwLkxuZXh0LCBlTG8uU3ltICk7XG5cdFx0XHRlLlJmYWNlLmluc2lkZSA9IHJlZ1VwLmluc2lkZTtcblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXG5cdC8vc3RhdGljIGludCBDaGVja0ZvckludGVyc2VjdCggVEVTU3Rlc3NlbGF0b3IgKnRlc3MsIEFjdGl2ZVJlZ2lvbiAqcmVnVXAgKVxuXHRTd2VlcC5jaGVja0ZvckludGVyc2VjdCA9IGZ1bmN0aW9uKCB0ZXNzLCByZWdVcCApIHtcblx0XHQvKlxuXHRcdCogQ2hlY2sgdGhlIHVwcGVyIGFuZCBsb3dlciBlZGdlcyBvZiB0aGUgZ2l2ZW4gcmVnaW9uIHRvIHNlZSBpZlxuXHRcdCogdGhleSBpbnRlcnNlY3QuICBJZiBzbywgY3JlYXRlIHRoZSBpbnRlcnNlY3Rpb24gYW5kIGFkZCBpdFxuXHRcdCogdG8gdGhlIGRhdGEgc3RydWN0dXJlcy5cblx0XHQqXG5cdFx0KiBSZXR1cm5zIFRSVUUgaWYgYWRkaW5nIHRoZSBuZXcgaW50ZXJzZWN0aW9uIHJlc3VsdGVkIGluIGEgcmVjdXJzaXZlXG5cdFx0KiBjYWxsIHRvIEFkZFJpZ2h0RWRnZXMoKTsgaW4gdGhpcyBjYXNlIGFsbCBcImRpcnR5XCIgcmVnaW9ucyBoYXZlIGJlZW5cblx0XHQqIGNoZWNrZWQgZm9yIGludGVyc2VjdGlvbnMsIGFuZCBwb3NzaWJseSByZWdVcCBoYXMgYmVlbiBkZWxldGVkLlxuXHRcdCovXG5cdFx0dmFyIHJlZ0xvID0gU3dlZXAucmVnaW9uQmVsb3cocmVnVXApO1xuXHRcdHZhciBlVXAgPSByZWdVcC5lVXA7XG5cdFx0dmFyIGVMbyA9IHJlZ0xvLmVVcDtcblx0XHR2YXIgb3JnVXAgPSBlVXAuT3JnO1xuXHRcdHZhciBvcmdMbyA9IGVMby5Pcmc7XG5cdFx0dmFyIGRzdFVwID0gZVVwLkRzdDtcblx0XHR2YXIgZHN0TG8gPSBlTG8uRHN0O1xuXHRcdHZhciB0TWluVXAsIHRNYXhMbztcblx0XHR2YXIgaXNlY3QgPSBuZXcgVEVTU3ZlcnRleCwgb3JnTWluO1xuXHRcdHZhciBlO1xuXG5cdFx0YXNzZXJ0KCAhIEdlb20udmVydEVxKCBkc3RMbywgZHN0VXAgKSk7XG5cdFx0YXNzZXJ0KCBHZW9tLmVkZ2VTaWduKCBkc3RVcCwgdGVzcy5ldmVudCwgb3JnVXAgKSA8PSAwICk7XG5cdFx0YXNzZXJ0KCBHZW9tLmVkZ2VTaWduKCBkc3RMbywgdGVzcy5ldmVudCwgb3JnTG8gKSA+PSAwICk7XG5cdFx0YXNzZXJ0KCBvcmdVcCAhPT0gdGVzcy5ldmVudCAmJiBvcmdMbyAhPT0gdGVzcy5ldmVudCApO1xuXHRcdGFzc2VydCggISByZWdVcC5maXhVcHBlckVkZ2UgJiYgISByZWdMby5maXhVcHBlckVkZ2UgKTtcblxuXHRcdGlmKCBvcmdVcCA9PT0gb3JnTG8gKSByZXR1cm4gZmFsc2U7XHQvKiByaWdodCBlbmRwb2ludHMgYXJlIHRoZSBzYW1lICovXG5cblx0XHR0TWluVXAgPSBNYXRoLm1pbiggb3JnVXAudCwgZHN0VXAudCApO1xuXHRcdHRNYXhMbyA9IE1hdGgubWF4KCBvcmdMby50LCBkc3RMby50ICk7XG5cdFx0aWYoIHRNaW5VcCA+IHRNYXhMbyApIHJldHVybiBmYWxzZTtcdC8qIHQgcmFuZ2VzIGRvIG5vdCBvdmVybGFwICovXG5cblx0XHRpZiggR2VvbS52ZXJ0TGVxKCBvcmdVcCwgb3JnTG8gKSkge1xuXHRcdFx0aWYoIEdlb20uZWRnZVNpZ24oIGRzdExvLCBvcmdVcCwgb3JnTG8gKSA+IDAgKSByZXR1cm4gZmFsc2U7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmKCBHZW9tLmVkZ2VTaWduKCBkc3RVcCwgb3JnTG8sIG9yZ1VwICkgPCAwICkgcmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8qIEF0IHRoaXMgcG9pbnQgdGhlIGVkZ2VzIGludGVyc2VjdCwgYXQgbGVhc3QgbWFyZ2luYWxseSAqL1xuXHRcdFN3ZWVwLmRlYnVnRXZlbnQoIHRlc3MgKTtcblxuXHRcdEdlb20uaW50ZXJzZWN0KCBkc3RVcCwgb3JnVXAsIGRzdExvLCBvcmdMbywgaXNlY3QgKTtcblx0XHQvKiBUaGUgZm9sbG93aW5nIHByb3BlcnRpZXMgYXJlIGd1YXJhbnRlZWQ6ICovXG5cdFx0YXNzZXJ0KCBNYXRoLm1pbiggb3JnVXAudCwgZHN0VXAudCApIDw9IGlzZWN0LnQgKTtcblx0XHRhc3NlcnQoIGlzZWN0LnQgPD0gTWF0aC5tYXgoIG9yZ0xvLnQsIGRzdExvLnQgKSk7XG5cdFx0YXNzZXJ0KCBNYXRoLm1pbiggZHN0TG8ucywgZHN0VXAucyApIDw9IGlzZWN0LnMgKTtcblx0XHRhc3NlcnQoIGlzZWN0LnMgPD0gTWF0aC5tYXgoIG9yZ0xvLnMsIG9yZ1VwLnMgKSk7XG5cblx0XHRpZiggR2VvbS52ZXJ0TGVxKCBpc2VjdCwgdGVzcy5ldmVudCApKSB7XG5cdFx0XHQvKiBUaGUgaW50ZXJzZWN0aW9uIHBvaW50IGxpZXMgc2xpZ2h0bHkgdG8gdGhlIGxlZnQgb2YgdGhlIHN3ZWVwIGxpbmUsXG5cdFx0XHQqIHNvIG1vdmUgaXQgdW50aWwgaXQnJ3Mgc2xpZ2h0bHkgdG8gdGhlIHJpZ2h0IG9mIHRoZSBzd2VlcCBsaW5lLlxuXHRcdFx0KiAoSWYgd2UgaGFkIHBlcmZlY3QgbnVtZXJpY2FsIHByZWNpc2lvbiwgdGhpcyB3b3VsZCBuZXZlciBoYXBwZW5cblx0XHRcdCogaW4gdGhlIGZpcnN0IHBsYWNlKS4gIFRoZSBlYXNpZXN0IGFuZCBzYWZlc3QgdGhpbmcgdG8gZG8gaXNcblx0XHRcdCogcmVwbGFjZSB0aGUgaW50ZXJzZWN0aW9uIGJ5IHRlc3MtPmV2ZW50LlxuXHRcdFx0Ki9cblx0XHRcdGlzZWN0LnMgPSB0ZXNzLmV2ZW50LnM7XG5cdFx0XHRpc2VjdC50ID0gdGVzcy5ldmVudC50O1xuXHRcdH1cblx0XHQvKiBTaW1pbGFybHksIGlmIHRoZSBjb21wdXRlZCBpbnRlcnNlY3Rpb24gbGllcyB0byB0aGUgcmlnaHQgb2YgdGhlXG5cdFx0KiByaWdodG1vc3Qgb3JpZ2luICh3aGljaCBzaG91bGQgcmFyZWx5IGhhcHBlbiksIGl0IGNhbiBjYXVzZVxuXHRcdCogdW5iZWxpZXZhYmxlIGluZWZmaWNpZW5jeSBvbiBzdWZmaWNpZW50bHkgZGVnZW5lcmF0ZSBpbnB1dHMuXG5cdFx0KiAoSWYgeW91IGhhdmUgdGhlIHRlc3QgcHJvZ3JhbSwgdHJ5IHJ1bm5pbmcgdGVzdDU0LmQgd2l0aCB0aGVcblx0XHQqIFwiWCB6b29tXCIgb3B0aW9uIHR1cm5lZCBvbikuXG5cdFx0Ki9cblx0XHRvcmdNaW4gPSBHZW9tLnZlcnRMZXEoIG9yZ1VwLCBvcmdMbyApID8gb3JnVXAgOiBvcmdMbztcblx0XHRpZiggR2VvbS52ZXJ0TGVxKCBvcmdNaW4sIGlzZWN0ICkpIHtcblx0XHRcdGlzZWN0LnMgPSBvcmdNaW4ucztcblx0XHRcdGlzZWN0LnQgPSBvcmdNaW4udDtcblx0XHR9XG5cblx0XHRpZiggR2VvbS52ZXJ0RXEoIGlzZWN0LCBvcmdVcCApIHx8IEdlb20udmVydEVxKCBpc2VjdCwgb3JnTG8gKSkge1xuXHRcdFx0LyogRWFzeSBjYXNlIC0tIGludGVyc2VjdGlvbiBhdCBvbmUgb2YgdGhlIHJpZ2h0IGVuZHBvaW50cyAqL1xuXHRcdFx0U3dlZXAuY2hlY2tGb3JSaWdodFNwbGljZSggdGVzcywgcmVnVXAgKTtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRpZiggICAgKCEgR2VvbS52ZXJ0RXEoIGRzdFVwLCB0ZXNzLmV2ZW50IClcblx0XHRcdCYmIEdlb20uZWRnZVNpZ24oIGRzdFVwLCB0ZXNzLmV2ZW50LCBpc2VjdCApID49IDApXG5cdFx0XHR8fCAoISBHZW9tLnZlcnRFcSggZHN0TG8sIHRlc3MuZXZlbnQgKVxuXHRcdFx0JiYgR2VvbS5lZGdlU2lnbiggZHN0TG8sIHRlc3MuZXZlbnQsIGlzZWN0ICkgPD0gMCApKVxuXHRcdHtcblx0XHRcdC8qIFZlcnkgdW51c3VhbCAtLSB0aGUgbmV3IHVwcGVyIG9yIGxvd2VyIGVkZ2Ugd291bGQgcGFzcyBvbiB0aGVcblx0XHRcdCogd3Jvbmcgc2lkZSBvZiB0aGUgc3dlZXAgZXZlbnQsIG9yIHRocm91Z2ggaXQuICBUaGlzIGNhbiBoYXBwZW5cblx0XHRcdCogZHVlIHRvIHZlcnkgc21hbGwgbnVtZXJpY2FsIGVycm9ycyBpbiB0aGUgaW50ZXJzZWN0aW9uIGNhbGN1bGF0aW9uLlxuXHRcdFx0Ki9cblx0XHRcdGlmKCBkc3RMbyA9PT0gdGVzcy5ldmVudCApIHtcblx0XHRcdFx0LyogU3BsaWNlIGRzdExvIGludG8gZVVwLCBhbmQgcHJvY2VzcyB0aGUgbmV3IHJlZ2lvbihzKSAqL1xuXHRcdFx0XHR0ZXNzLm1lc2guc3BsaXRFZGdlKCBlVXAuU3ltICk7XG5cdFx0XHRcdHRlc3MubWVzaC5zcGxpY2UoIGVMby5TeW0sIGVVcCApO1xuXHRcdFx0XHRyZWdVcCA9IFN3ZWVwLnRvcExlZnRSZWdpb24oIHRlc3MsIHJlZ1VwICk7XG5cdC8vXHRcdFx0aWYgKHJlZ1VwID09IE5VTEwpIGxvbmdqbXAodGVzcy0+ZW52LDEpO1xuXHRcdFx0XHRlVXAgPSBTd2VlcC5yZWdpb25CZWxvdyhyZWdVcCkuZVVwO1xuXHRcdFx0XHRTd2VlcC5maW5pc2hMZWZ0UmVnaW9ucyggdGVzcywgU3dlZXAucmVnaW9uQmVsb3cocmVnVXApLCByZWdMbyApO1xuXHRcdFx0XHRTd2VlcC5hZGRSaWdodEVkZ2VzKCB0ZXNzLCByZWdVcCwgZVVwLk9wcmV2LCBlVXAsIGVVcCwgdHJ1ZSApO1xuXHRcdFx0XHRyZXR1cm4gVFJVRTtcblx0XHRcdH1cblx0XHRcdGlmKCBkc3RVcCA9PT0gdGVzcy5ldmVudCApIHtcblx0XHRcdFx0LyogU3BsaWNlIGRzdFVwIGludG8gZUxvLCBhbmQgcHJvY2VzcyB0aGUgbmV3IHJlZ2lvbihzKSAqL1xuXHRcdFx0XHR0ZXNzLm1lc2guc3BsaXRFZGdlKCBlTG8uU3ltICk7XG5cdFx0XHRcdHRlc3MubWVzaC5zcGxpY2UoIGVVcC5MbmV4dCwgZUxvLk9wcmV2ICk7IFxuXHRcdFx0XHRyZWdMbyA9IHJlZ1VwO1xuXHRcdFx0XHRyZWdVcCA9IFN3ZWVwLnRvcFJpZ2h0UmVnaW9uKCByZWdVcCApO1xuXHRcdFx0XHRlID0gU3dlZXAucmVnaW9uQmVsb3cocmVnVXApLmVVcC5ScHJldjtcblx0XHRcdFx0cmVnTG8uZVVwID0gZUxvLk9wcmV2O1xuXHRcdFx0XHRlTG8gPSBTd2VlcC5maW5pc2hMZWZ0UmVnaW9ucyggdGVzcywgcmVnTG8sIG51bGwgKTtcblx0XHRcdFx0U3dlZXAuYWRkUmlnaHRFZGdlcyggdGVzcywgcmVnVXAsIGVMby5PbmV4dCwgZVVwLlJwcmV2LCBlLCB0cnVlICk7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0LyogU3BlY2lhbCBjYXNlOiBjYWxsZWQgZnJvbSBDb25uZWN0UmlnaHRWZXJ0ZXguICBJZiBlaXRoZXJcblx0XHRcdCogZWRnZSBwYXNzZXMgb24gdGhlIHdyb25nIHNpZGUgb2YgdGVzcy0+ZXZlbnQsIHNwbGl0IGl0XG5cdFx0XHQqIChhbmQgd2FpdCBmb3IgQ29ubmVjdFJpZ2h0VmVydGV4IHRvIHNwbGljZSBpdCBhcHByb3ByaWF0ZWx5KS5cblx0XHRcdCovXG5cdFx0XHRpZiggR2VvbS5lZGdlU2lnbiggZHN0VXAsIHRlc3MuZXZlbnQsIGlzZWN0ICkgPj0gMCApIHtcblx0XHRcdFx0U3dlZXAucmVnaW9uQWJvdmUocmVnVXApLmRpcnR5ID0gcmVnVXAuZGlydHkgPSB0cnVlO1xuXHRcdFx0XHR0ZXNzLm1lc2guc3BsaXRFZGdlKCBlVXAuU3ltICk7XG5cdFx0XHRcdGVVcC5PcmcucyA9IHRlc3MuZXZlbnQucztcblx0XHRcdFx0ZVVwLk9yZy50ID0gdGVzcy5ldmVudC50O1xuXHRcdFx0fVxuXHRcdFx0aWYoIEdlb20uZWRnZVNpZ24oIGRzdExvLCB0ZXNzLmV2ZW50LCBpc2VjdCApIDw9IDAgKSB7XG5cdFx0XHRcdHJlZ1VwLmRpcnR5ID0gcmVnTG8uZGlydHkgPSB0cnVlO1xuXHRcdFx0XHR0ZXNzLm1lc2guc3BsaXRFZGdlKCBlTG8uU3ltICk7XG5cdFx0XHRcdGVMby5PcmcucyA9IHRlc3MuZXZlbnQucztcblx0XHRcdFx0ZUxvLk9yZy50ID0gdGVzcy5ldmVudC50O1xuXHRcdFx0fVxuXHRcdFx0LyogbGVhdmUgdGhlIHJlc3QgZm9yIENvbm5lY3RSaWdodFZlcnRleCAqL1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8qIEdlbmVyYWwgY2FzZSAtLSBzcGxpdCBib3RoIGVkZ2VzLCBzcGxpY2UgaW50byBuZXcgdmVydGV4LlxuXHRcdCogV2hlbiB3ZSBkbyB0aGUgc3BsaWNlIG9wZXJhdGlvbiwgdGhlIG9yZGVyIG9mIHRoZSBhcmd1bWVudHMgaXNcblx0XHQqIGFyYml0cmFyeSBhcyBmYXIgYXMgY29ycmVjdG5lc3MgZ29lcy4gIEhvd2V2ZXIsIHdoZW4gdGhlIG9wZXJhdGlvblxuXHRcdCogY3JlYXRlcyBhIG5ldyBmYWNlLCB0aGUgd29yayBkb25lIGlzIHByb3BvcnRpb25hbCB0byB0aGUgc2l6ZSBvZlxuXHRcdCogdGhlIG5ldyBmYWNlLiAgV2UgZXhwZWN0IHRoZSBmYWNlcyBpbiB0aGUgcHJvY2Vzc2VkIHBhcnQgb2Zcblx0XHQqIHRoZSBtZXNoIChpZS4gZVVwLT5MZmFjZSkgdG8gYmUgc21hbGxlciB0aGFuIHRoZSBmYWNlcyBpbiB0aGVcblx0XHQqIHVucHJvY2Vzc2VkIG9yaWdpbmFsIGNvbnRvdXJzICh3aGljaCB3aWxsIGJlIGVMby0+T3ByZXYtPkxmYWNlKS5cblx0XHQqL1xuXHRcdHRlc3MubWVzaC5zcGxpdEVkZ2UoIGVVcC5TeW0gKTtcblx0XHR0ZXNzLm1lc2guc3BsaXRFZGdlKCBlTG8uU3ltICk7XG5cdFx0dGVzcy5tZXNoLnNwbGljZSggZUxvLk9wcmV2LCBlVXAgKTtcblx0XHRlVXAuT3JnLnMgPSBpc2VjdC5zO1xuXHRcdGVVcC5PcmcudCA9IGlzZWN0LnQ7XG5cdFx0ZVVwLk9yZy5wcUhhbmRsZSA9IHRlc3MucHEuaW5zZXJ0KCBlVXAuT3JnICk7XG5cdFx0U3dlZXAuZ2V0SW50ZXJzZWN0RGF0YSggdGVzcywgZVVwLk9yZywgb3JnVXAsIGRzdFVwLCBvcmdMbywgZHN0TG8gKTtcblx0XHRTd2VlcC5yZWdpb25BYm92ZShyZWdVcCkuZGlydHkgPSByZWdVcC5kaXJ0eSA9IHJlZ0xvLmRpcnR5ID0gdHJ1ZTtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHQvL3N0YXRpYyB2b2lkIFdhbGtEaXJ0eVJlZ2lvbnMoIFRFU1N0ZXNzZWxhdG9yICp0ZXNzLCBBY3RpdmVSZWdpb24gKnJlZ1VwIClcblx0U3dlZXAud2Fsa0RpcnR5UmVnaW9ucyA9IGZ1bmN0aW9uKCB0ZXNzLCByZWdVcCApIHtcblx0XHQvKlxuXHRcdCogV2hlbiB0aGUgdXBwZXIgb3IgbG93ZXIgZWRnZSBvZiBhbnkgcmVnaW9uIGNoYW5nZXMsIHRoZSByZWdpb24gaXNcblx0XHQqIG1hcmtlZCBcImRpcnR5XCIuICBUaGlzIHJvdXRpbmUgd2Fsa3MgdGhyb3VnaCBhbGwgdGhlIGRpcnR5IHJlZ2lvbnNcblx0XHQqIGFuZCBtYWtlcyBzdXJlIHRoYXQgdGhlIGRpY3Rpb25hcnkgaW52YXJpYW50cyBhcmUgc2F0aXNmaWVkXG5cdFx0KiAoc2VlIHRoZSBjb21tZW50cyBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoaXMgZmlsZSkuICBPZiBjb3Vyc2Vcblx0XHQqIG5ldyBkaXJ0eSByZWdpb25zIGNhbiBiZSBjcmVhdGVkIGFzIHdlIG1ha2UgY2hhbmdlcyB0byByZXN0b3JlXG5cdFx0KiB0aGUgaW52YXJpYW50cy5cblx0XHQqL1xuXHRcdHZhciByZWdMbyA9IFN3ZWVwLnJlZ2lvbkJlbG93KHJlZ1VwKTtcblx0XHR2YXIgZVVwLCBlTG87XG5cblx0XHRmb3IoIDs7ICkge1xuXHRcdFx0LyogRmluZCB0aGUgbG93ZXN0IGRpcnR5IHJlZ2lvbiAod2Ugd2FsayBmcm9tIHRoZSBib3R0b20gdXApLiAqL1xuXHRcdFx0d2hpbGUoIHJlZ0xvLmRpcnR5ICkge1xuXHRcdFx0XHRyZWdVcCA9IHJlZ0xvO1xuXHRcdFx0XHRyZWdMbyA9IFN3ZWVwLnJlZ2lvbkJlbG93KHJlZ0xvKTtcblx0XHRcdH1cblx0XHRcdGlmKCAhIHJlZ1VwLmRpcnR5ICkge1xuXHRcdFx0XHRyZWdMbyA9IHJlZ1VwO1xuXHRcdFx0XHRyZWdVcCA9IFN3ZWVwLnJlZ2lvbkFib3ZlKCByZWdVcCApO1xuXHRcdFx0XHRpZiggcmVnVXAgPT0gbnVsbCB8fCAhIHJlZ1VwLmRpcnR5ICkge1xuXHRcdFx0XHRcdC8qIFdlJ3ZlIHdhbGtlZCBhbGwgdGhlIGRpcnR5IHJlZ2lvbnMgKi9cblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJlZ1VwLmRpcnR5ID0gZmFsc2U7XG5cdFx0XHRlVXAgPSByZWdVcC5lVXA7XG5cdFx0XHRlTG8gPSByZWdMby5lVXA7XG5cblx0XHRcdGlmKCBlVXAuRHN0ICE9PSBlTG8uRHN0ICkge1xuXHRcdFx0XHQvKiBDaGVjayB0aGF0IHRoZSBlZGdlIG9yZGVyaW5nIGlzIG9iZXllZCBhdCB0aGUgRHN0IHZlcnRpY2VzLiAqL1xuXHRcdFx0XHRpZiggU3dlZXAuY2hlY2tGb3JMZWZ0U3BsaWNlKCB0ZXNzLCByZWdVcCApKSB7XG5cblx0XHRcdFx0XHQvKiBJZiB0aGUgdXBwZXIgb3IgbG93ZXIgZWRnZSB3YXMgbWFya2VkIGZpeFVwcGVyRWRnZSwgdGhlblxuXHRcdFx0XHRcdCogd2Ugbm8gbG9uZ2VyIG5lZWQgaXQgKHNpbmNlIHRoZXNlIGVkZ2VzIGFyZSBuZWVkZWQgb25seSBmb3Jcblx0XHRcdFx0XHQqIHZlcnRpY2VzIHdoaWNoIG90aGVyd2lzZSBoYXZlIG5vIHJpZ2h0LWdvaW5nIGVkZ2VzKS5cblx0XHRcdFx0XHQqL1xuXHRcdFx0XHRcdGlmKCByZWdMby5maXhVcHBlckVkZ2UgKSB7XG5cdFx0XHRcdFx0XHRTd2VlcC5kZWxldGVSZWdpb24oIHRlc3MsIHJlZ0xvICk7XG5cdFx0XHRcdFx0XHR0ZXNzLm1lc2guZGVsZXRlKCBlTG8gKTtcblx0XHRcdFx0XHRcdHJlZ0xvID0gU3dlZXAucmVnaW9uQmVsb3coIHJlZ1VwICk7XG5cdFx0XHRcdFx0XHRlTG8gPSByZWdMby5lVXA7XG5cdFx0XHRcdFx0fSBlbHNlIGlmKCByZWdVcC5maXhVcHBlckVkZ2UgKSB7XG5cdFx0XHRcdFx0XHRTd2VlcC5kZWxldGVSZWdpb24oIHRlc3MsIHJlZ1VwICk7XG5cdFx0XHRcdFx0XHR0ZXNzLm1lc2guZGVsZXRlKCBlVXAgKTtcblx0XHRcdFx0XHRcdHJlZ1VwID0gU3dlZXAucmVnaW9uQWJvdmUoIHJlZ0xvICk7XG5cdFx0XHRcdFx0XHRlVXAgPSByZWdVcC5lVXA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiggZVVwLk9yZyAhPT0gZUxvLk9yZyApIHtcblx0XHRcdFx0aWYoICAgIGVVcC5Ec3QgIT09IGVMby5Ec3Rcblx0XHRcdFx0XHQmJiAhIHJlZ1VwLmZpeFVwcGVyRWRnZSAmJiAhIHJlZ0xvLmZpeFVwcGVyRWRnZVxuXHRcdFx0XHRcdCYmIChlVXAuRHN0ID09PSB0ZXNzLmV2ZW50IHx8IGVMby5Ec3QgPT09IHRlc3MuZXZlbnQpIClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdC8qIFdoZW4gYWxsIGVsc2UgZmFpbHMgaW4gQ2hlY2tGb3JJbnRlcnNlY3QoKSwgaXQgdXNlcyB0ZXNzLT5ldmVudFxuXHRcdFx0XHRcdCogYXMgdGhlIGludGVyc2VjdGlvbiBsb2NhdGlvbi4gIFRvIG1ha2UgdGhpcyBwb3NzaWJsZSwgaXQgcmVxdWlyZXNcblx0XHRcdFx0XHQqIHRoYXQgdGVzcy0+ZXZlbnQgbGllIGJldHdlZW4gdGhlIHVwcGVyIGFuZCBsb3dlciBlZGdlcywgYW5kIGFsc29cblx0XHRcdFx0XHQqIHRoYXQgbmVpdGhlciBvZiB0aGVzZSBpcyBtYXJrZWQgZml4VXBwZXJFZGdlIChzaW5jZSBpbiB0aGUgd29yc3Rcblx0XHRcdFx0XHQqIGNhc2UgaXQgbWlnaHQgc3BsaWNlIG9uZSBvZiB0aGVzZSBlZGdlcyBpbnRvIHRlc3MtPmV2ZW50LCBhbmRcblx0XHRcdFx0XHQqIHZpb2xhdGUgdGhlIGludmFyaWFudCB0aGF0IGZpeGFibGUgZWRnZXMgYXJlIHRoZSBvbmx5IHJpZ2h0LWdvaW5nXG5cdFx0XHRcdFx0KiBlZGdlIGZyb20gdGhlaXIgYXNzb2NpYXRlZCB2ZXJ0ZXgpLlxuXHRcdFx0XHRcdCovXG5cdFx0XHRcdFx0aWYoIFN3ZWVwLmNoZWNrRm9ySW50ZXJzZWN0KCB0ZXNzLCByZWdVcCApKSB7XG5cdFx0XHRcdFx0XHQvKiBXYWxrRGlydHlSZWdpb25zKCkgd2FzIGNhbGxlZCByZWN1cnNpdmVseTsgd2UncmUgZG9uZSAqL1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvKiBFdmVuIHRob3VnaCB3ZSBjYW4ndCB1c2UgQ2hlY2tGb3JJbnRlcnNlY3QoKSwgdGhlIE9yZyB2ZXJ0aWNlc1xuXHRcdFx0XHRcdCogbWF5IHZpb2xhdGUgdGhlIGRpY3Rpb25hcnkgZWRnZSBvcmRlcmluZy4gIENoZWNrIGFuZCBjb3JyZWN0IHRoaXMuXG5cdFx0XHRcdFx0Ki9cblx0XHRcdFx0XHRTd2VlcC5jaGVja0ZvclJpZ2h0U3BsaWNlKCB0ZXNzLCByZWdVcCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiggZVVwLk9yZyA9PT0gZUxvLk9yZyAmJiBlVXAuRHN0ID09PSBlTG8uRHN0ICkge1xuXHRcdFx0XHQvKiBBIGRlZ2VuZXJhdGUgbG9vcCBjb25zaXN0aW5nIG9mIG9ubHkgdHdvIGVkZ2VzIC0tIGRlbGV0ZSBpdC4gKi9cblx0XHRcdFx0U3dlZXAuYWRkV2luZGluZyggZUxvLCBlVXAgKTtcblx0XHRcdFx0U3dlZXAuZGVsZXRlUmVnaW9uKCB0ZXNzLCByZWdVcCApO1xuXHRcdFx0XHR0ZXNzLm1lc2guZGVsZXRlKCBlVXAgKTtcblx0XHRcdFx0cmVnVXAgPSBTd2VlcC5yZWdpb25BYm92ZSggcmVnTG8gKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXG5cdC8vc3RhdGljIHZvaWQgQ29ubmVjdFJpZ2h0VmVydGV4KCBURVNTdGVzc2VsYXRvciAqdGVzcywgQWN0aXZlUmVnaW9uICpyZWdVcCwgVEVTU2hhbGZFZGdlICplQm90dG9tTGVmdCApXG5cdFN3ZWVwLmNvbm5lY3RSaWdodFZlcnRleCA9IGZ1bmN0aW9uKCB0ZXNzLCByZWdVcCwgZUJvdHRvbUxlZnQgKSB7XG5cdFx0Lypcblx0XHQqIFB1cnBvc2U6IGNvbm5lY3QgYSBcInJpZ2h0XCIgdmVydGV4IHZFdmVudCAob25lIHdoZXJlIGFsbCBlZGdlcyBnbyBsZWZ0KVxuXHRcdCogdG8gdGhlIHVucHJvY2Vzc2VkIHBvcnRpb24gb2YgdGhlIG1lc2guICBTaW5jZSB0aGVyZSBhcmUgbm8gcmlnaHQtZ29pbmdcblx0XHQqIGVkZ2VzLCB0d28gcmVnaW9ucyAob25lIGFib3ZlIHZFdmVudCBhbmQgb25lIGJlbG93KSBhcmUgYmVpbmcgbWVyZ2VkXG5cdFx0KiBpbnRvIG9uZS4gIFwicmVnVXBcIiBpcyB0aGUgdXBwZXIgb2YgdGhlc2UgdHdvIHJlZ2lvbnMuXG5cdFx0KlxuXHRcdCogVGhlcmUgYXJlIHR3byByZWFzb25zIGZvciBkb2luZyB0aGlzIChhZGRpbmcgYSByaWdodC1nb2luZyBlZGdlKTpcblx0XHQqICAtIGlmIHRoZSB0d28gcmVnaW9ucyBiZWluZyBtZXJnZWQgYXJlIFwiaW5zaWRlXCIsIHdlIG11c3QgYWRkIGFuIGVkZ2Vcblx0XHQqICAgIHRvIGtlZXAgdGhlbSBzZXBhcmF0ZWQgKHRoZSBjb21iaW5lZCByZWdpb24gd291bGQgbm90IGJlIG1vbm90b25lKS5cblx0XHQqICAtIGluIGFueSBjYXNlLCB3ZSBtdXN0IGxlYXZlIHNvbWUgcmVjb3JkIG9mIHZFdmVudCBpbiB0aGUgZGljdGlvbmFyeSxcblx0XHQqICAgIHNvIHRoYXQgd2UgY2FuIG1lcmdlIHZFdmVudCB3aXRoIGZlYXR1cmVzIHRoYXQgd2UgaGF2ZSBub3Qgc2VlbiB5ZXQuXG5cdFx0KiAgICBGb3IgZXhhbXBsZSwgbWF5YmUgdGhlcmUgaXMgYSB2ZXJ0aWNhbCBlZGdlIHdoaWNoIHBhc3NlcyBqdXN0IHRvXG5cdFx0KiAgICB0aGUgcmlnaHQgb2YgdkV2ZW50OyB3ZSB3b3VsZCBsaWtlIHRvIHNwbGljZSB2RXZlbnQgaW50byB0aGlzIGVkZ2UuXG5cdFx0KlxuXHRcdCogSG93ZXZlciwgd2UgZG9uJ3Qgd2FudCB0byBjb25uZWN0IHZFdmVudCB0byBqdXN0IGFueSB2ZXJ0ZXguICBXZSBkb24nJ3Rcblx0XHQqIHdhbnQgdGhlIG5ldyBlZGdlIHRvIGNyb3NzIGFueSBvdGhlciBlZGdlczsgb3RoZXJ3aXNlIHdlIHdpbGwgY3JlYXRlXG5cdFx0KiBpbnRlcnNlY3Rpb24gdmVydGljZXMgZXZlbiB3aGVuIHRoZSBpbnB1dCBkYXRhIGhhZCBubyBzZWxmLWludGVyc2VjdGlvbnMuXG5cdFx0KiAoVGhpcyBpcyBhIGJhZCB0aGluZzsgaWYgdGhlIHVzZXIncyBpbnB1dCBkYXRhIGhhcyBubyBpbnRlcnNlY3Rpb25zLFxuXHRcdCogd2UgZG9uJ3Qgd2FudCB0byBnZW5lcmF0ZSBhbnkgZmFsc2UgaW50ZXJzZWN0aW9ucyBvdXJzZWx2ZXMuKVxuXHRcdCpcblx0XHQqIE91ciBldmVudHVhbCBnb2FsIGlzIHRvIGNvbm5lY3QgdkV2ZW50IHRvIHRoZSBsZWZ0bW9zdCB1bnByb2Nlc3NlZFxuXHRcdCogdmVydGV4IG9mIHRoZSBjb21iaW5lZCByZWdpb24gKHRoZSB1bmlvbiBvZiByZWdVcCBhbmQgcmVnTG8pLlxuXHRcdCogQnV0IGJlY2F1c2Ugb2YgdW5zZWVuIHZlcnRpY2VzIHdpdGggYWxsIHJpZ2h0LWdvaW5nIGVkZ2VzLCBhbmQgYWxzb1xuXHRcdCogbmV3IHZlcnRpY2VzIHdoaWNoIG1heSBiZSBjcmVhdGVkIGJ5IGVkZ2UgaW50ZXJzZWN0aW9ucywgd2UgZG9uJyd0XG5cdFx0KiBrbm93IHdoZXJlIHRoYXQgbGVmdG1vc3QgdW5wcm9jZXNzZWQgdmVydGV4IGlzLiAgSW4gdGhlIG1lYW50aW1lLCB3ZVxuXHRcdCogY29ubmVjdCB2RXZlbnQgdG8gdGhlIGNsb3Nlc3QgdmVydGV4IG9mIGVpdGhlciBjaGFpbiwgYW5kIG1hcmsgdGhlIHJlZ2lvblxuXHRcdCogYXMgXCJmaXhVcHBlckVkZ2VcIi4gIFRoaXMgZmxhZyBzYXlzIHRvIGRlbGV0ZSBhbmQgcmVjb25uZWN0IHRoaXMgZWRnZVxuXHRcdCogdG8gdGhlIG5leHQgcHJvY2Vzc2VkIHZlcnRleCBvbiB0aGUgYm91bmRhcnkgb2YgdGhlIGNvbWJpbmVkIHJlZ2lvbi5cblx0XHQqIFF1aXRlIHBvc3NpYmx5IHRoZSB2ZXJ0ZXggd2UgY29ubmVjdGVkIHRvIHdpbGwgdHVybiBvdXQgdG8gYmUgdGhlXG5cdFx0KiBjbG9zZXN0IG9uZSwgaW4gd2hpY2ggY2FzZSB3ZSB3b24nJ3QgbmVlZCB0byBtYWtlIGFueSBjaGFuZ2VzLlxuXHRcdCovXG5cdFx0dmFyIGVOZXc7XG5cdFx0dmFyIGVUb3BMZWZ0ID0gZUJvdHRvbUxlZnQuT25leHQ7XG5cdFx0dmFyIHJlZ0xvID0gU3dlZXAucmVnaW9uQmVsb3cocmVnVXApO1xuXHRcdHZhciBlVXAgPSByZWdVcC5lVXA7XG5cdFx0dmFyIGVMbyA9IHJlZ0xvLmVVcDtcblx0XHR2YXIgZGVnZW5lcmF0ZSA9IGZhbHNlO1xuXG5cdFx0aWYoIGVVcC5Ec3QgIT09IGVMby5Ec3QgKSB7XG5cdFx0XHRTd2VlcC5jaGVja0ZvckludGVyc2VjdCggdGVzcywgcmVnVXAgKTtcblx0XHR9XG5cblx0XHQvKiBQb3NzaWJsZSBuZXcgZGVnZW5lcmFjaWVzOiB1cHBlciBvciBsb3dlciBlZGdlIG9mIHJlZ1VwIG1heSBwYXNzXG5cdFx0KiB0aHJvdWdoIHZFdmVudCwgb3IgbWF5IGNvaW5jaWRlIHdpdGggbmV3IGludGVyc2VjdGlvbiB2ZXJ0ZXhcblx0XHQqL1xuXHRcdGlmKCBHZW9tLnZlcnRFcSggZVVwLk9yZywgdGVzcy5ldmVudCApKSB7XG5cdFx0XHR0ZXNzLm1lc2guc3BsaWNlKCBlVG9wTGVmdC5PcHJldiwgZVVwICk7XG5cdFx0XHRyZWdVcCA9IFN3ZWVwLnRvcExlZnRSZWdpb24oIHRlc3MsIHJlZ1VwICk7XG5cdFx0XHRlVG9wTGVmdCA9IFN3ZWVwLnJlZ2lvbkJlbG93KCByZWdVcCApLmVVcDtcblx0XHRcdFN3ZWVwLmZpbmlzaExlZnRSZWdpb25zKCB0ZXNzLCBTd2VlcC5yZWdpb25CZWxvdyhyZWdVcCksIHJlZ0xvICk7XG5cdFx0XHRkZWdlbmVyYXRlID0gdHJ1ZTtcblx0XHR9XG5cdFx0aWYoIEdlb20udmVydEVxKCBlTG8uT3JnLCB0ZXNzLmV2ZW50ICkpIHtcblx0XHRcdHRlc3MubWVzaC5zcGxpY2UoIGVCb3R0b21MZWZ0LCBlTG8uT3ByZXYgKTtcblx0XHRcdGVCb3R0b21MZWZ0ID0gU3dlZXAuZmluaXNoTGVmdFJlZ2lvbnMoIHRlc3MsIHJlZ0xvLCBudWxsICk7XG5cdFx0XHRkZWdlbmVyYXRlID0gdHJ1ZTtcblx0XHR9XG5cdFx0aWYoIGRlZ2VuZXJhdGUgKSB7XG5cdFx0XHRTd2VlcC5hZGRSaWdodEVkZ2VzKCB0ZXNzLCByZWdVcCwgZUJvdHRvbUxlZnQuT25leHQsIGVUb3BMZWZ0LCBlVG9wTGVmdCwgdHJ1ZSApO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8qIE5vbi1kZWdlbmVyYXRlIHNpdHVhdGlvbiAtLSBuZWVkIHRvIGFkZCBhIHRlbXBvcmFyeSwgZml4YWJsZSBlZGdlLlxuXHRcdCogQ29ubmVjdCB0byB0aGUgY2xvc2VyIG9mIGVMby0+T3JnLCBlVXAtPk9yZy5cblx0XHQqL1xuXHRcdGlmKCBHZW9tLnZlcnRMZXEoIGVMby5PcmcsIGVVcC5PcmcgKSkge1xuXHRcdFx0ZU5ldyA9IGVMby5PcHJldjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZU5ldyA9IGVVcDtcblx0XHR9XG5cdFx0ZU5ldyA9IHRlc3MubWVzaC5jb25uZWN0KCBlQm90dG9tTGVmdC5McHJldiwgZU5ldyApO1xuXG5cdFx0LyogUHJldmVudCBjbGVhbnVwLCBvdGhlcndpc2UgZU5ldyBtaWdodCBkaXNhcHBlYXIgYmVmb3JlIHdlJ3ZlIGV2ZW5cblx0XHQqIGhhZCBhIGNoYW5jZSB0byBtYXJrIGl0IGFzIGEgdGVtcG9yYXJ5IGVkZ2UuXG5cdFx0Ki9cblx0XHRTd2VlcC5hZGRSaWdodEVkZ2VzKCB0ZXNzLCByZWdVcCwgZU5ldywgZU5ldy5PbmV4dCwgZU5ldy5PbmV4dCwgZmFsc2UgKTtcblx0XHRlTmV3LlN5bS5hY3RpdmVSZWdpb24uZml4VXBwZXJFZGdlID0gdHJ1ZTtcblx0XHRTd2VlcC53YWxrRGlydHlSZWdpb25zKCB0ZXNzLCByZWdVcCApO1xuXHR9XG5cblx0LyogQmVjYXVzZSB2ZXJ0aWNlcyBhdCBleGFjdGx5IHRoZSBzYW1lIGxvY2F0aW9uIGFyZSBtZXJnZWQgdG9nZXRoZXJcblx0KiBiZWZvcmUgd2UgcHJvY2VzcyB0aGUgc3dlZXAgZXZlbnQsIHNvbWUgZGVnZW5lcmF0ZSBjYXNlcyBjYW4ndCBvY2N1ci5cblx0KiBIb3dldmVyIGlmIHNvbWVvbmUgZXZlbnR1YWxseSBtYWtlcyB0aGUgbW9kaWZpY2F0aW9ucyByZXF1aXJlZCB0b1xuXHQqIG1lcmdlIGZlYXR1cmVzIHdoaWNoIGFyZSBjbG9zZSB0b2dldGhlciwgdGhlIGNhc2VzIGJlbG93IG1hcmtlZFxuXHQqIFRPTEVSQU5DRV9OT05aRVJPIHdpbGwgYmUgdXNlZnVsLiAgVGhleSB3ZXJlIGRlYnVnZ2VkIGJlZm9yZSB0aGVcblx0KiBjb2RlIHRvIG1lcmdlIGlkZW50aWNhbCB2ZXJ0aWNlcyBpbiB0aGUgbWFpbiBsb29wIHdhcyBhZGRlZC5cblx0Ki9cblx0Ly8jZGVmaW5lIFRPTEVSQU5DRV9OT05aRVJPXHRGQUxTRVxuXG5cdC8vc3RhdGljIHZvaWQgQ29ubmVjdExlZnREZWdlbmVyYXRlKCBURVNTdGVzc2VsYXRvciAqdGVzcywgQWN0aXZlUmVnaW9uICpyZWdVcCwgVEVTU3ZlcnRleCAqdkV2ZW50IClcblx0U3dlZXAuY29ubmVjdExlZnREZWdlbmVyYXRlID0gZnVuY3Rpb24oIHRlc3MsIHJlZ1VwLCB2RXZlbnQgKSB7XG5cdFx0Lypcblx0XHQqIFRoZSBldmVudCB2ZXJ0ZXggbGllcyBleGFjdHkgb24gYW4gYWxyZWFkeS1wcm9jZXNzZWQgZWRnZSBvciB2ZXJ0ZXguXG5cdFx0KiBBZGRpbmcgdGhlIG5ldyB2ZXJ0ZXggaW52b2x2ZXMgc3BsaWNpbmcgaXQgaW50byB0aGUgYWxyZWFkeS1wcm9jZXNzZWRcblx0XHQqIHBhcnQgb2YgdGhlIG1lc2guXG5cdFx0Ki9cblx0XHR2YXIgZSwgZVRvcExlZnQsIGVUb3BSaWdodCwgZUxhc3Q7XG5cdFx0dmFyIHJlZztcblxuXHRcdGUgPSByZWdVcC5lVXA7XG5cdFx0aWYoIEdlb20udmVydEVxKCBlLk9yZywgdkV2ZW50ICkpIHtcblx0XHRcdC8qIGUtPk9yZyBpcyBhbiB1bnByb2Nlc3NlZCB2ZXJ0ZXggLSBqdXN0IGNvbWJpbmUgdGhlbSwgYW5kIHdhaXRcblx0XHRcdCogZm9yIGUtPk9yZyB0byBiZSBwdWxsZWQgZnJvbSB0aGUgcXVldWVcblx0XHRcdCovXG5cdFx0XHRhc3NlcnQoIGZhbHNlIC8qVE9MRVJBTkNFX05PTlpFUk8qLyApO1xuXHRcdFx0U3dlZXAuc3BsaWNlTWVyZ2VWZXJ0aWNlcyggdGVzcywgZSwgdkV2ZW50LmFuRWRnZSApO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmKCAhIEdlb20udmVydEVxKCBlLkRzdCwgdkV2ZW50ICkpIHtcblx0XHRcdC8qIEdlbmVyYWwgY2FzZSAtLSBzcGxpY2UgdkV2ZW50IGludG8gZWRnZSBlIHdoaWNoIHBhc3NlcyB0aHJvdWdoIGl0ICovXG5cdFx0XHR0ZXNzLm1lc2guc3BsaXRFZGdlKCBlLlN5bSApO1xuXHRcdFx0aWYoIHJlZ1VwLmZpeFVwcGVyRWRnZSApIHtcblx0XHRcdFx0LyogVGhpcyBlZGdlIHdhcyBmaXhhYmxlIC0tIGRlbGV0ZSB1bnVzZWQgcG9ydGlvbiBvZiBvcmlnaW5hbCBlZGdlICovXG5cdFx0XHRcdHRlc3MubWVzaC5kZWxldGUoIGUuT25leHQgKTtcblx0XHRcdFx0cmVnVXAuZml4VXBwZXJFZGdlID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHR0ZXNzLm1lc2guc3BsaWNlKCB2RXZlbnQuYW5FZGdlLCBlICk7XG5cdFx0XHRTd2VlcC5zd2VlcEV2ZW50KCB0ZXNzLCB2RXZlbnQgKTtcdC8qIHJlY3Vyc2UgKi9cblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvKiB2RXZlbnQgY29pbmNpZGVzIHdpdGggZS0+RHN0LCB3aGljaCBoYXMgYWxyZWFkeSBiZWVuIHByb2Nlc3NlZC5cblx0XHQqIFNwbGljZSBpbiB0aGUgYWRkaXRpb25hbCByaWdodC1nb2luZyBlZGdlcy5cblx0XHQqL1xuXHRcdGFzc2VydCggZmFsc2UgLypUT0xFUkFOQ0VfTk9OWkVSTyovICk7XG5cdFx0cmVnVXAgPSBTd2VlcC50b3BSaWdodFJlZ2lvbiggcmVnVXAgKTtcblx0XHRyZWcgPSBTd2VlcC5yZWdpb25CZWxvdyggcmVnVXAgKTtcblx0XHRlVG9wUmlnaHQgPSByZWcuZVVwLlN5bTtcblx0XHRlVG9wTGVmdCA9IGVMYXN0ID0gZVRvcFJpZ2h0Lk9uZXh0O1xuXHRcdGlmKCByZWcuZml4VXBwZXJFZGdlICkge1xuXHRcdFx0LyogSGVyZSBlLT5Ec3QgaGFzIG9ubHkgYSBzaW5nbGUgZml4YWJsZSBlZGdlIGdvaW5nIHJpZ2h0LlxuXHRcdFx0KiBXZSBjYW4gZGVsZXRlIGl0IHNpbmNlIG5vdyB3ZSBoYXZlIHNvbWUgcmVhbCByaWdodC1nb2luZyBlZGdlcy5cblx0XHRcdCovXG5cdFx0XHRhc3NlcnQoIGVUb3BMZWZ0ICE9PSBlVG9wUmlnaHQgKTsgICAvKiB0aGVyZSBhcmUgc29tZSBsZWZ0IGVkZ2VzIHRvbyAqL1xuXHRcdFx0U3dlZXAuZGVsZXRlUmVnaW9uKCB0ZXNzLCByZWcgKTtcblx0XHRcdHRlc3MubWVzaC5kZWxldGUoIGVUb3BSaWdodCApO1xuXHRcdFx0ZVRvcFJpZ2h0ID0gZVRvcExlZnQuT3ByZXY7XG5cdFx0fVxuXHRcdHRlc3MubWVzaC5zcGxpY2UoIHZFdmVudC5hbkVkZ2UsIGVUb3BSaWdodCApO1xuXHRcdGlmKCAhIEdlb20uZWRnZUdvZXNMZWZ0KCBlVG9wTGVmdCApKSB7XG5cdFx0XHQvKiBlLT5Ec3QgaGFkIG5vIGxlZnQtZ29pbmcgZWRnZXMgLS0gaW5kaWNhdGUgdGhpcyB0byBBZGRSaWdodEVkZ2VzKCkgKi9cblx0XHRcdGVUb3BMZWZ0ID0gbnVsbDtcblx0XHR9XG5cdFx0U3dlZXAuYWRkUmlnaHRFZGdlcyggdGVzcywgcmVnVXAsIGVUb3BSaWdodC5PbmV4dCwgZUxhc3QsIGVUb3BMZWZ0LCB0cnVlICk7XG5cdH1cblxuXG5cdC8vc3RhdGljIHZvaWQgQ29ubmVjdExlZnRWZXJ0ZXgoIFRFU1N0ZXNzZWxhdG9yICp0ZXNzLCBURVNTdmVydGV4ICp2RXZlbnQgKVxuXHRTd2VlcC5jb25uZWN0TGVmdFZlcnRleCA9IGZ1bmN0aW9uKCB0ZXNzLCB2RXZlbnQgKSB7XG5cdFx0Lypcblx0XHQqIFB1cnBvc2U6IGNvbm5lY3QgYSBcImxlZnRcIiB2ZXJ0ZXggKG9uZSB3aGVyZSBib3RoIGVkZ2VzIGdvIHJpZ2h0KVxuXHRcdCogdG8gdGhlIHByb2Nlc3NlZCBwb3J0aW9uIG9mIHRoZSBtZXNoLiAgTGV0IFIgYmUgdGhlIGFjdGl2ZSByZWdpb25cblx0XHQqIGNvbnRhaW5pbmcgdkV2ZW50LCBhbmQgbGV0IFUgYW5kIEwgYmUgdGhlIHVwcGVyIGFuZCBsb3dlciBlZGdlXG5cdFx0KiBjaGFpbnMgb2YgUi4gIFRoZXJlIGFyZSB0d28gcG9zc2liaWxpdGllczpcblx0XHQqXG5cdFx0KiAtIHRoZSBub3JtYWwgY2FzZTogc3BsaXQgUiBpbnRvIHR3byByZWdpb25zLCBieSBjb25uZWN0aW5nIHZFdmVudCB0b1xuXHRcdCogICB0aGUgcmlnaHRtb3N0IHZlcnRleCBvZiBVIG9yIEwgbHlpbmcgdG8gdGhlIGxlZnQgb2YgdGhlIHN3ZWVwIGxpbmVcblx0XHQqXG5cdFx0KiAtIHRoZSBkZWdlbmVyYXRlIGNhc2U6IGlmIHZFdmVudCBpcyBjbG9zZSBlbm91Z2ggdG8gVSBvciBMLCB3ZVxuXHRcdCogICBtZXJnZSB2RXZlbnQgaW50byB0aGF0IGVkZ2UgY2hhaW4uICBUaGUgc3ViY2FzZXMgYXJlOlxuXHRcdCpcdC0gbWVyZ2luZyB3aXRoIHRoZSByaWdodG1vc3QgdmVydGV4IG9mIFUgb3IgTFxuXHRcdCpcdC0gbWVyZ2luZyB3aXRoIHRoZSBhY3RpdmUgZWRnZSBvZiBVIG9yIExcblx0XHQqXHQtIG1lcmdpbmcgd2l0aCBhbiBhbHJlYWR5LXByb2Nlc3NlZCBwb3J0aW9uIG9mIFUgb3IgTFxuXHRcdCovXG5cdFx0dmFyIHJlZ1VwLCByZWdMbywgcmVnO1xuXHRcdHZhciBlVXAsIGVMbywgZU5ldztcblx0XHR2YXIgdG1wID0gbmV3IEFjdGl2ZVJlZ2lvbigpO1xuXG5cdFx0LyogYXNzZXJ0KCB2RXZlbnQtPmFuRWRnZS0+T25leHQtPk9uZXh0ID09IHZFdmVudC0+YW5FZGdlICk7ICovXG5cblx0XHQvKiBHZXQgYSBwb2ludGVyIHRvIHRoZSBhY3RpdmUgcmVnaW9uIGNvbnRhaW5pbmcgdkV2ZW50ICovXG5cdFx0dG1wLmVVcCA9IHZFdmVudC5hbkVkZ2UuU3ltO1xuXHRcdC8qIF9fR0xfRElDVExJU1RLRVkgKi8gLyogdGVzc0RpY3RMaXN0U2VhcmNoICovXG5cdFx0cmVnVXAgPSB0ZXNzLmRpY3Quc2VhcmNoKCB0bXAgKS5rZXk7XG5cdFx0cmVnTG8gPSBTd2VlcC5yZWdpb25CZWxvdyggcmVnVXAgKTtcblx0XHRpZiggIXJlZ0xvICkge1xuXHRcdFx0Ly8gVGhpcyBtYXkgaGFwcGVuIGlmIHRoZSBpbnB1dCBwb2x5Z29uIGlzIGNvcGxhbmFyLlxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRlVXAgPSByZWdVcC5lVXA7XG5cdFx0ZUxvID0gcmVnTG8uZVVwO1xuXG5cdFx0LyogVHJ5IG1lcmdpbmcgd2l0aCBVIG9yIEwgZmlyc3QgKi9cblx0XHRpZiggR2VvbS5lZGdlU2lnbiggZVVwLkRzdCwgdkV2ZW50LCBlVXAuT3JnICkgPT09IDAuMCApIHtcblx0XHRcdFN3ZWVwLmNvbm5lY3RMZWZ0RGVnZW5lcmF0ZSggdGVzcywgcmVnVXAsIHZFdmVudCApO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8qIENvbm5lY3QgdkV2ZW50IHRvIHJpZ2h0bW9zdCBwcm9jZXNzZWQgdmVydGV4IG9mIGVpdGhlciBjaGFpbi5cblx0XHQqIGUtPkRzdCBpcyB0aGUgdmVydGV4IHRoYXQgd2Ugd2lsbCBjb25uZWN0IHRvIHZFdmVudC5cblx0XHQqL1xuXHRcdHJlZyA9IEdlb20udmVydExlcSggZUxvLkRzdCwgZVVwLkRzdCApID8gcmVnVXAgOiByZWdMbztcblxuXHRcdGlmKCByZWdVcC5pbnNpZGUgfHwgcmVnLmZpeFVwcGVyRWRnZSkge1xuXHRcdFx0aWYoIHJlZyA9PT0gcmVnVXAgKSB7XG5cdFx0XHRcdGVOZXcgPSB0ZXNzLm1lc2guY29ubmVjdCggdkV2ZW50LmFuRWRnZS5TeW0sIGVVcC5MbmV4dCApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIHRlbXBIYWxmRWRnZSA9IHRlc3MubWVzaC5jb25uZWN0KCBlTG8uRG5leHQsIHZFdmVudC5hbkVkZ2UpO1xuXHRcdFx0XHRlTmV3ID0gdGVtcEhhbGZFZGdlLlN5bTtcblx0XHRcdH1cblx0XHRcdGlmKCByZWcuZml4VXBwZXJFZGdlICkge1xuXHRcdFx0XHRTd2VlcC5maXhVcHBlckVkZ2UoIHRlc3MsIHJlZywgZU5ldyApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0U3dlZXAuY29tcHV0ZVdpbmRpbmcoIHRlc3MsIFN3ZWVwLmFkZFJlZ2lvbkJlbG93KCB0ZXNzLCByZWdVcCwgZU5ldyApKTtcblx0XHRcdH1cblx0XHRcdFN3ZWVwLnN3ZWVwRXZlbnQoIHRlc3MsIHZFdmVudCApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvKiBUaGUgbmV3IHZlcnRleCBpcyBpbiBhIHJlZ2lvbiB3aGljaCBkb2VzIG5vdCBiZWxvbmcgdG8gdGhlIHBvbHlnb24uXG5cdFx0XHQqIFdlIGRvbicndCBuZWVkIHRvIGNvbm5lY3QgdGhpcyB2ZXJ0ZXggdG8gdGhlIHJlc3Qgb2YgdGhlIG1lc2guXG5cdFx0XHQqL1xuXHRcdFx0U3dlZXAuYWRkUmlnaHRFZGdlcyggdGVzcywgcmVnVXAsIHZFdmVudC5hbkVkZ2UsIHZFdmVudC5hbkVkZ2UsIG51bGwsIHRydWUgKTtcblx0XHR9XG5cdH07XG5cblxuXHQvL3N0YXRpYyB2b2lkIFN3ZWVwRXZlbnQoIFRFU1N0ZXNzZWxhdG9yICp0ZXNzLCBURVNTdmVydGV4ICp2RXZlbnQgKVxuXHRTd2VlcC5zd2VlcEV2ZW50ID0gZnVuY3Rpb24oIHRlc3MsIHZFdmVudCApIHtcblx0XHQvKlxuXHRcdCogRG9lcyBldmVyeXRoaW5nIG5lY2Vzc2FyeSB3aGVuIHRoZSBzd2VlcCBsaW5lIGNyb3NzZXMgYSB2ZXJ0ZXguXG5cdFx0KiBVcGRhdGVzIHRoZSBtZXNoIGFuZCB0aGUgZWRnZSBkaWN0aW9uYXJ5LlxuXHRcdCovXG5cblx0XHR0ZXNzLmV2ZW50ID0gdkV2ZW50O1x0XHQvKiBmb3IgYWNjZXNzIGluIEVkZ2VMZXEoKSAqL1xuXHRcdFN3ZWVwLmRlYnVnRXZlbnQoIHRlc3MgKTtcblxuXHRcdC8qIENoZWNrIGlmIHRoaXMgdmVydGV4IGlzIHRoZSByaWdodCBlbmRwb2ludCBvZiBhbiBlZGdlIHRoYXQgaXNcblx0XHQqIGFscmVhZHkgaW4gdGhlIGRpY3Rpb25hcnkuICBJbiB0aGlzIGNhc2Ugd2UgZG9uJ3QgbmVlZCB0byB3YXN0ZVxuXHRcdCogdGltZSBzZWFyY2hpbmcgZm9yIHRoZSBsb2NhdGlvbiB0byBpbnNlcnQgbmV3IGVkZ2VzLlxuXHRcdCovXG5cdFx0dmFyIGUgPSB2RXZlbnQuYW5FZGdlO1xuXHRcdHdoaWxlKCBlLmFjdGl2ZVJlZ2lvbiA9PT0gbnVsbCApIHtcblx0XHRcdGUgPSBlLk9uZXh0O1xuXHRcdFx0aWYoIGUgPT0gdkV2ZW50LmFuRWRnZSApIHtcblx0XHRcdFx0LyogQWxsIGVkZ2VzIGdvIHJpZ2h0IC0tIG5vdCBpbmNpZGVudCB0byBhbnkgcHJvY2Vzc2VkIGVkZ2VzICovXG5cdFx0XHRcdFN3ZWVwLmNvbm5lY3RMZWZ0VmVydGV4KCB0ZXNzLCB2RXZlbnQgKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8qIFByb2Nlc3NpbmcgY29uc2lzdHMgb2YgdHdvIHBoYXNlczogZmlyc3Qgd2UgXCJmaW5pc2hcIiBhbGwgdGhlXG5cdFx0KiBhY3RpdmUgcmVnaW9ucyB3aGVyZSBib3RoIHRoZSB1cHBlciBhbmQgbG93ZXIgZWRnZXMgdGVybWluYXRlXG5cdFx0KiBhdCB2RXZlbnQgKGllLiB2RXZlbnQgaXMgY2xvc2luZyBvZmYgdGhlc2UgcmVnaW9ucykuXG5cdFx0KiBXZSBtYXJrIHRoZXNlIGZhY2VzIFwiaW5zaWRlXCIgb3IgXCJvdXRzaWRlXCIgdGhlIHBvbHlnb24gYWNjb3JkaW5nXG5cdFx0KiB0byB0aGVpciB3aW5kaW5nIG51bWJlciwgYW5kIGRlbGV0ZSB0aGUgZWRnZXMgZnJvbSB0aGUgZGljdGlvbmFyeS5cblx0XHQqIFRoaXMgdGFrZXMgY2FyZSBvZiBhbGwgdGhlIGxlZnQtZ29pbmcgZWRnZXMgZnJvbSB2RXZlbnQuXG5cdFx0Ki9cblx0XHR2YXIgcmVnVXAgPSBTd2VlcC50b3BMZWZ0UmVnaW9uKCB0ZXNzLCBlLmFjdGl2ZVJlZ2lvbiApO1xuXHRcdGFzc2VydCggcmVnVXAgIT09IG51bGwgKTtcblx0Ly9cdGlmIChyZWdVcCA9PSBOVUxMKSBsb25nam1wKHRlc3MtPmVudiwxKTtcblx0XHR2YXIgcmVnID0gU3dlZXAucmVnaW9uQmVsb3coIHJlZ1VwICk7XG5cdFx0dmFyIGVUb3BMZWZ0ID0gcmVnLmVVcDtcblx0XHR2YXIgZUJvdHRvbUxlZnQgPSBTd2VlcC5maW5pc2hMZWZ0UmVnaW9ucyggdGVzcywgcmVnLCBudWxsICk7XG5cblx0XHQvKiBOZXh0IHdlIHByb2Nlc3MgYWxsIHRoZSByaWdodC1nb2luZyBlZGdlcyBmcm9tIHZFdmVudC4gIFRoaXNcblx0XHQqIGludm9sdmVzIGFkZGluZyB0aGUgZWRnZXMgdG8gdGhlIGRpY3Rpb25hcnksIGFuZCBjcmVhdGluZyB0aGVcblx0XHQqIGFzc29jaWF0ZWQgXCJhY3RpdmUgcmVnaW9uc1wiIHdoaWNoIHJlY29yZCBpbmZvcm1hdGlvbiBhYm91dCB0aGVcblx0XHQqIHJlZ2lvbnMgYmV0d2VlbiBhZGphY2VudCBkaWN0aW9uYXJ5IGVkZ2VzLlxuXHRcdCovXG5cdFx0aWYoIGVCb3R0b21MZWZ0Lk9uZXh0ID09PSBlVG9wTGVmdCApIHtcblx0XHRcdC8qIE5vIHJpZ2h0LWdvaW5nIGVkZ2VzIC0tIGFkZCBhIHRlbXBvcmFyeSBcImZpeGFibGVcIiBlZGdlICovXG5cdFx0XHRTd2VlcC5jb25uZWN0UmlnaHRWZXJ0ZXgoIHRlc3MsIHJlZ1VwLCBlQm90dG9tTGVmdCApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRTd2VlcC5hZGRSaWdodEVkZ2VzKCB0ZXNzLCByZWdVcCwgZUJvdHRvbUxlZnQuT25leHQsIGVUb3BMZWZ0LCBlVG9wTGVmdCwgdHJ1ZSApO1xuXHRcdH1cblx0fTtcblxuXG5cdC8qIE1ha2UgdGhlIHNlbnRpbmVsIGNvb3JkaW5hdGVzIGJpZyBlbm91Z2ggdGhhdCB0aGV5IHdpbGwgbmV2ZXIgYmVcblx0KiBtZXJnZWQgd2l0aCByZWFsIGlucHV0IGZlYXR1cmVzLlxuXHQqL1xuXG5cdC8vc3RhdGljIHZvaWQgQWRkU2VudGluZWwoIFRFU1N0ZXNzZWxhdG9yICp0ZXNzLCBURVNTcmVhbCBzbWluLCBURVNTcmVhbCBzbWF4LCBURVNTcmVhbCB0IClcblx0U3dlZXAuYWRkU2VudGluZWwgPSBmdW5jdGlvbiggdGVzcywgc21pbiwgc21heCwgdCApIHtcblx0XHQvKlxuXHRcdCogV2UgYWRkIHR3byBzZW50aW5lbCBlZGdlcyBhYm92ZSBhbmQgYmVsb3cgYWxsIG90aGVyIGVkZ2VzLFxuXHRcdCogdG8gYXZvaWQgc3BlY2lhbCBjYXNlcyBhdCB0aGUgdG9wIGFuZCBib3R0b20uXG5cdFx0Ki9cblx0XHR2YXIgcmVnID0gbmV3IEFjdGl2ZVJlZ2lvbigpO1xuXHRcdHZhciBlID0gdGVzcy5tZXNoLm1ha2VFZGdlKCk7XG5cdC8vXHRpZiAoZSA9PSBOVUxMKSBsb25nam1wKHRlc3MtPmVudiwxKTtcblxuXHRcdGUuT3JnLnMgPSBzbWF4O1xuXHRcdGUuT3JnLnQgPSB0O1xuXHRcdGUuRHN0LnMgPSBzbWluO1xuXHRcdGUuRHN0LnQgPSB0O1xuXHRcdHRlc3MuZXZlbnQgPSBlLkRzdDtcdFx0LyogaW5pdGlhbGl6ZSBpdCAqL1xuXG5cdFx0cmVnLmVVcCA9IGU7XG5cdFx0cmVnLndpbmRpbmdOdW1iZXIgPSAwO1xuXHRcdHJlZy5pbnNpZGUgPSBmYWxzZTtcblx0XHRyZWcuZml4VXBwZXJFZGdlID0gZmFsc2U7XG5cdFx0cmVnLnNlbnRpbmVsID0gdHJ1ZTtcblx0XHRyZWcuZGlydHkgPSBmYWxzZTtcblx0XHRyZWcubm9kZVVwID0gdGVzcy5kaWN0Lmluc2VydCggcmVnICk7XG5cdC8vXHRpZiAocmVnLT5ub2RlVXAgPT0gTlVMTCkgbG9uZ2ptcCh0ZXNzLT5lbnYsMSk7XG5cdH1cblxuXG5cdC8vc3RhdGljIHZvaWQgSW5pdEVkZ2VEaWN0KCBURVNTdGVzc2VsYXRvciAqdGVzcyApXG5cdFN3ZWVwLmluaXRFZGdlRGljdCA9IGZ1bmN0aW9uKCB0ZXNzICkge1xuXHRcdC8qXG5cdFx0KiBXZSBtYWludGFpbiBhbiBvcmRlcmluZyBvZiBlZGdlIGludGVyc2VjdGlvbnMgd2l0aCB0aGUgc3dlZXAgbGluZS5cblx0XHQqIFRoaXMgb3JkZXIgaXMgbWFpbnRhaW5lZCBpbiBhIGR5bmFtaWMgZGljdGlvbmFyeS5cblx0XHQqL1xuXHRcdHRlc3MuZGljdCA9IG5ldyBEaWN0KCB0ZXNzLCBTd2VlcC5lZGdlTGVxICk7XG5cdC8vXHRpZiAodGVzcy0+ZGljdCA9PSBOVUxMKSBsb25nam1wKHRlc3MtPmVudiwxKTtcblxuXHRcdHZhciB3ID0gKHRlc3MuYm1heFswXSAtIHRlc3MuYm1pblswXSk7XG5cdFx0dmFyIGggPSAodGVzcy5ibWF4WzFdIC0gdGVzcy5ibWluWzFdKTtcblxuXHRcdHZhciBzbWluID0gdGVzcy5ibWluWzBdIC0gdztcblx0XHR2YXIgc21heCA9IHRlc3MuYm1heFswXSArIHc7XG5cdFx0dmFyIHRtaW4gPSB0ZXNzLmJtaW5bMV0gLSBoO1xuXHRcdHZhciB0bWF4ID0gdGVzcy5ibWF4WzFdICsgaDtcblxuXHRcdFN3ZWVwLmFkZFNlbnRpbmVsKCB0ZXNzLCBzbWluLCBzbWF4LCB0bWluICk7XG5cdFx0U3dlZXAuYWRkU2VudGluZWwoIHRlc3MsIHNtaW4sIHNtYXgsIHRtYXggKTtcblx0fVxuXG5cblx0U3dlZXAuZG9uZUVkZ2VEaWN0ID0gZnVuY3Rpb24oIHRlc3MgKVxuXHR7XG5cdFx0dmFyIHJlZztcblx0XHR2YXIgZml4ZWRFZGdlcyA9IDA7XG5cblx0XHR3aGlsZSggKHJlZyA9IHRlc3MuZGljdC5taW4oKS5rZXkpICE9PSBudWxsICkge1xuXHRcdFx0Lypcblx0XHRcdCogQXQgdGhlIGVuZCBvZiBhbGwgcHJvY2Vzc2luZywgdGhlIGRpY3Rpb25hcnkgc2hvdWxkIGNvbnRhaW5cblx0XHRcdCogb25seSB0aGUgdHdvIHNlbnRpbmVsIGVkZ2VzLCBwbHVzIGF0IG1vc3Qgb25lIFwiZml4YWJsZVwiIGVkZ2Vcblx0XHRcdCogY3JlYXRlZCBieSBDb25uZWN0UmlnaHRWZXJ0ZXgoKS5cblx0XHRcdCovXG5cdFx0XHRpZiggISByZWcuc2VudGluZWwgKSB7XG5cdFx0XHRcdGFzc2VydCggcmVnLmZpeFVwcGVyRWRnZSApO1xuXHRcdFx0XHRhc3NlcnQoICsrZml4ZWRFZGdlcyA9PSAxICk7XG5cdFx0XHR9XG5cdFx0XHRhc3NlcnQoIHJlZy53aW5kaW5nTnVtYmVyID09IDAgKTtcblx0XHRcdFN3ZWVwLmRlbGV0ZVJlZ2lvbiggdGVzcywgcmVnICk7XG5cdFx0XHQvKiAgICB0ZXNzTWVzaERlbGV0ZSggcmVnLT5lVXAgKTsqL1xuXHRcdH1cblx0Ly9cdGRpY3REZWxldGVEaWN0KCAmdGVzcy0+YWxsb2MsIHRlc3MtPmRpY3QgKTtcblx0fVxuXG5cblx0U3dlZXAucmVtb3ZlRGVnZW5lcmF0ZUVkZ2VzID0gZnVuY3Rpb24oIHRlc3MgKSB7XG5cdFx0Lypcblx0XHQqIFJlbW92ZSB6ZXJvLWxlbmd0aCBlZGdlcywgYW5kIGNvbnRvdXJzIHdpdGggZmV3ZXIgdGhhbiAzIHZlcnRpY2VzLlxuXHRcdCovXG5cdFx0dmFyIGUsIGVOZXh0LCBlTG5leHQ7XG5cdFx0dmFyIGVIZWFkID0gdGVzcy5tZXNoLmVIZWFkO1xuXG5cdFx0LypMSU5URUQqL1xuXHRcdGZvciggZSA9IGVIZWFkLm5leHQ7IGUgIT09IGVIZWFkOyBlID0gZU5leHQgKSB7XG5cdFx0XHRlTmV4dCA9IGUubmV4dDtcblx0XHRcdGVMbmV4dCA9IGUuTG5leHQ7XG5cblx0XHRcdGlmKCBHZW9tLnZlcnRFcSggZS5PcmcsIGUuRHN0ICkgJiYgZS5MbmV4dC5MbmV4dCAhPT0gZSApIHtcblx0XHRcdFx0LyogWmVyby1sZW5ndGggZWRnZSwgY29udG91ciBoYXMgYXQgbGVhc3QgMyBlZGdlcyAqL1xuXHRcdFx0XHRTd2VlcC5zcGxpY2VNZXJnZVZlcnRpY2VzKCB0ZXNzLCBlTG5leHQsIGUgKTtcdC8qIGRlbGV0ZXMgZS0+T3JnICovXG5cdFx0XHRcdHRlc3MubWVzaC5kZWxldGUoIGUgKTsgLyogZSBpcyBhIHNlbGYtbG9vcCAqL1xuXHRcdFx0XHRlID0gZUxuZXh0O1xuXHRcdFx0XHRlTG5leHQgPSBlLkxuZXh0O1xuXHRcdFx0fVxuXHRcdFx0aWYoIGVMbmV4dC5MbmV4dCA9PT0gZSApIHtcblx0XHRcdFx0LyogRGVnZW5lcmF0ZSBjb250b3VyIChvbmUgb3IgdHdvIGVkZ2VzKSAqL1xuXHRcdFx0XHRpZiggZUxuZXh0ICE9PSBlICkge1xuXHRcdFx0XHRcdGlmKCBlTG5leHQgPT09IGVOZXh0IHx8IGVMbmV4dCA9PT0gZU5leHQuU3ltICkgeyBlTmV4dCA9IGVOZXh0Lm5leHQ7IH1cblx0XHRcdFx0XHR0ZXNzLm1lc2guZGVsZXRlKCBlTG5leHQgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiggZSA9PT0gZU5leHQgfHwgZSA9PT0gZU5leHQuU3ltICkgeyBlTmV4dCA9IGVOZXh0Lm5leHQ7IH1cblx0XHRcdFx0dGVzcy5tZXNoLmRlbGV0ZSggZSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdFN3ZWVwLmluaXRQcmlvcml0eVEgPSBmdW5jdGlvbiggdGVzcyApIHtcblx0XHQvKlxuXHRcdCogSW5zZXJ0IGFsbCB2ZXJ0aWNlcyBpbnRvIHRoZSBwcmlvcml0eSBxdWV1ZSB3aGljaCBkZXRlcm1pbmVzIHRoZVxuXHRcdCogb3JkZXIgaW4gd2hpY2ggdmVydGljZXMgY3Jvc3MgdGhlIHN3ZWVwIGxpbmUuXG5cdFx0Ki9cblx0XHR2YXIgcHE7XG5cdFx0dmFyIHYsIHZIZWFkO1xuXHRcdHZhciB2ZXJ0ZXhDb3VudCA9IDA7XG5cdFx0XG5cdFx0dkhlYWQgPSB0ZXNzLm1lc2gudkhlYWQ7XG5cdFx0Zm9yKCB2ID0gdkhlYWQubmV4dDsgdiAhPT0gdkhlYWQ7IHYgPSB2Lm5leHQgKSB7XG5cdFx0XHR2ZXJ0ZXhDb3VudCsrO1xuXHRcdH1cblx0XHQvKiBNYWtlIHN1cmUgdGhlcmUgaXMgZW5vdWdoIHNwYWNlIGZvciBzZW50aW5lbHMuICovXG5cdFx0dmVydGV4Q291bnQgKz0gODsgLy9NQVgoIDgsIHRlc3MtPmFsbG9jLmV4dHJhVmVydGljZXMgKTtcblx0XHRcblx0XHRwcSA9IHRlc3MucHEgPSBuZXcgUHJpb3JpdHlRKCB2ZXJ0ZXhDb3VudCwgR2VvbS52ZXJ0TGVxICk7XG5cdC8vXHRpZiAocHEgPT0gTlVMTCkgcmV0dXJuIDA7XG5cblx0XHR2SGVhZCA9IHRlc3MubWVzaC52SGVhZDtcblx0XHRmb3IoIHYgPSB2SGVhZC5uZXh0OyB2ICE9PSB2SGVhZDsgdiA9IHYubmV4dCApIHtcblx0XHRcdHYucHFIYW5kbGUgPSBwcS5pbnNlcnQoIHYgKTtcblx0Ly9cdFx0aWYgKHYucHFIYW5kbGUgPT0gSU5WX0hBTkRMRSlcblx0Ly9cdFx0XHRicmVhaztcblx0XHR9XG5cblx0XHRpZiAodiAhPT0gdkhlYWQpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRwcS5pbml0KCk7XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cblx0U3dlZXAuZG9uZVByaW9yaXR5USA9IGZ1bmN0aW9uKCB0ZXNzICkge1xuXHRcdHRlc3MucHEgPSBudWxsO1xuXHR9XG5cblxuXHRTd2VlcC5yZW1vdmVEZWdlbmVyYXRlRmFjZXMgPSBmdW5jdGlvbiggdGVzcywgbWVzaCApIHtcblx0XHQvKlxuXHRcdCogRGVsZXRlIGFueSBkZWdlbmVyYXRlIGZhY2VzIHdpdGggb25seSB0d28gZWRnZXMuICBXYWxrRGlydHlSZWdpb25zKClcblx0XHQqIHdpbGwgY2F0Y2ggYWxtb3N0IGFsbCBvZiB0aGVzZSwgYnV0IGl0IHdvbid0IGNhdGNoIGRlZ2VuZXJhdGUgZmFjZXNcblx0XHQqIHByb2R1Y2VkIGJ5IHNwbGljZSBvcGVyYXRpb25zIG9uIGFscmVhZHktcHJvY2Vzc2VkIGVkZ2VzLlxuXHRcdCogVGhlIHR3byBwbGFjZXMgdGhpcyBjYW4gaGFwcGVuIGFyZSBpbiBGaW5pc2hMZWZ0UmVnaW9ucygpLCB3aGVuXG5cdFx0KiB3ZSBzcGxpY2UgaW4gYSBcInRlbXBvcmFyeVwiIGVkZ2UgcHJvZHVjZWQgYnkgQ29ubmVjdFJpZ2h0VmVydGV4KCksXG5cdFx0KiBhbmQgaW4gQ2hlY2tGb3JMZWZ0U3BsaWNlKCksIHdoZXJlIHdlIHNwbGljZSBhbHJlYWR5LXByb2Nlc3NlZFxuXHRcdCogZWRnZXMgdG8gZW5zdXJlIHRoYXQgb3VyIGRpY3Rpb25hcnkgaW52YXJpYW50cyBhcmUgbm90IHZpb2xhdGVkXG5cdFx0KiBieSBudW1lcmljYWwgZXJyb3JzLlxuXHRcdCpcblx0XHQqIEluIGJvdGggdGhlc2UgY2FzZXMgaXQgaXMgKnZlcnkqIGRhbmdlcm91cyB0byBkZWxldGUgdGhlIG9mZmVuZGluZ1xuXHRcdCogZWRnZSBhdCB0aGUgdGltZSwgc2luY2Ugb25lIG9mIHRoZSByb3V0aW5lcyBmdXJ0aGVyIHVwIHRoZSBzdGFja1xuXHRcdCogd2lsbCBzb21ldGltZXMgYmUga2VlcGluZyBhIHBvaW50ZXIgdG8gdGhhdCBlZGdlLlxuXHRcdCovXG5cdFx0dmFyIGYsIGZOZXh0O1xuXHRcdHZhciBlO1xuXG5cdFx0LypMSU5URUQqL1xuXHRcdGZvciggZiA9IG1lc2guZkhlYWQubmV4dDsgZiAhPT0gbWVzaC5mSGVhZDsgZiA9IGZOZXh0ICkge1xuXHRcdFx0Zk5leHQgPSBmLm5leHQ7XG5cdFx0XHRlID0gZi5hbkVkZ2U7XG5cdFx0XHRhc3NlcnQoIGUuTG5leHQgIT09IGUgKTtcblxuXHRcdFx0aWYoIGUuTG5leHQuTG5leHQgPT09IGUgKSB7XG5cdFx0XHRcdC8qIEEgZmFjZSB3aXRoIG9ubHkgdHdvIGVkZ2VzICovXG5cdFx0XHRcdFN3ZWVwLmFkZFdpbmRpbmcoIGUuT25leHQsIGUgKTtcblx0XHRcdFx0dGVzcy5tZXNoLmRlbGV0ZSggZSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdFN3ZWVwLmNvbXB1dGVJbnRlcmlvciA9IGZ1bmN0aW9uKCB0ZXNzICkge1xuXHRcdC8qXG5cdFx0KiB0ZXNzQ29tcHV0ZUludGVyaW9yKCB0ZXNzICkgY29tcHV0ZXMgdGhlIHBsYW5hciBhcnJhbmdlbWVudCBzcGVjaWZpZWRcblx0XHQqIGJ5IHRoZSBnaXZlbiBjb250b3VycywgYW5kIGZ1cnRoZXIgc3ViZGl2aWRlcyB0aGlzIGFycmFuZ2VtZW50XG5cdFx0KiBpbnRvIHJlZ2lvbnMuICBFYWNoIHJlZ2lvbiBpcyBtYXJrZWQgXCJpbnNpZGVcIiBpZiBpdCBiZWxvbmdzXG5cdFx0KiB0byB0aGUgcG9seWdvbiwgYWNjb3JkaW5nIHRvIHRoZSBydWxlIGdpdmVuIGJ5IHRlc3MtPndpbmRpbmdSdWxlLlxuXHRcdCogRWFjaCBpbnRlcmlvciByZWdpb24gaXMgZ3VhcmFudGVlZCBiZSBtb25vdG9uZS5cblx0XHQqL1xuXHRcdHZhciB2LCB2TmV4dDtcblxuXHRcdC8qIEVhY2ggdmVydGV4IGRlZmluZXMgYW4gZXZlbnQgZm9yIG91ciBzd2VlcCBsaW5lLiAgU3RhcnQgYnkgaW5zZXJ0aW5nXG5cdFx0KiBhbGwgdGhlIHZlcnRpY2VzIGluIGEgcHJpb3JpdHkgcXVldWUuICBFdmVudHMgYXJlIHByb2Nlc3NlZCBpblxuXHRcdCogbGV4aWNvZ3JhcGhpYyBvcmRlciwgaWUuXG5cdFx0KlxuXHRcdCpcdGUxIDwgZTIgIGlmZiAgZTEueCA8IGUyLnggfHwgKGUxLnggPT0gZTIueCAmJiBlMS55IDwgZTIueSlcblx0XHQqL1xuXHRcdFN3ZWVwLnJlbW92ZURlZ2VuZXJhdGVFZGdlcyggdGVzcyApO1xuXHRcdGlmICggIVN3ZWVwLmluaXRQcmlvcml0eVEoIHRlc3MgKSApIHJldHVybiBmYWxzZTsgLyogaWYgZXJyb3IgKi9cblx0XHRTd2VlcC5pbml0RWRnZURpY3QoIHRlc3MgKTtcblxuXHRcdHdoaWxlKCAodiA9IHRlc3MucHEuZXh0cmFjdE1pbigpKSAhPT0gbnVsbCApIHtcblx0XHRcdGZvciggOzsgKSB7XG5cdFx0XHRcdHZOZXh0ID0gdGVzcy5wcS5taW4oKTtcblx0XHRcdFx0aWYoIHZOZXh0ID09PSBudWxsIHx8ICEgR2VvbS52ZXJ0RXEoIHZOZXh0LCB2ICkpIGJyZWFrO1xuXG5cdFx0XHRcdC8qIE1lcmdlIHRvZ2V0aGVyIGFsbCB2ZXJ0aWNlcyBhdCBleGFjdGx5IHRoZSBzYW1lIGxvY2F0aW9uLlxuXHRcdFx0XHQqIFRoaXMgaXMgbW9yZSBlZmZpY2llbnQgdGhhbiBwcm9jZXNzaW5nIHRoZW0gb25lIGF0IGEgdGltZSxcblx0XHRcdFx0KiBzaW1wbGlmaWVzIHRoZSBjb2RlIChzZWUgQ29ubmVjdExlZnREZWdlbmVyYXRlKSwgYW5kIGlzIGFsc29cblx0XHRcdFx0KiBpbXBvcnRhbnQgZm9yIGNvcnJlY3QgaGFuZGxpbmcgb2YgY2VydGFpbiBkZWdlbmVyYXRlIGNhc2VzLlxuXHRcdFx0XHQqIEZvciBleGFtcGxlLCBzdXBwb3NlIHRoZXJlIGFyZSB0d28gaWRlbnRpY2FsIGVkZ2VzIEEgYW5kIEJcblx0XHRcdFx0KiB0aGF0IGJlbG9uZyB0byBkaWZmZXJlbnQgY29udG91cnMgKHNvIHdpdGhvdXQgdGhpcyBjb2RlIHRoZXkgd291bGRcblx0XHRcdFx0KiBiZSBwcm9jZXNzZWQgYnkgc2VwYXJhdGUgc3dlZXAgZXZlbnRzKS4gIFN1cHBvc2UgYW5vdGhlciBlZGdlIENcblx0XHRcdFx0KiBjcm9zc2VzIEEgYW5kIEIgZnJvbSBhYm92ZS4gIFdoZW4gQSBpcyBwcm9jZXNzZWQsIHdlIHNwbGl0IGl0XG5cdFx0XHRcdCogYXQgaXRzIGludGVyc2VjdGlvbiBwb2ludCB3aXRoIEMuICBIb3dldmVyIHRoaXMgYWxzbyBzcGxpdHMgQyxcblx0XHRcdFx0KiBzbyB3aGVuIHdlIGluc2VydCBCIHdlIG1heSBjb21wdXRlIGEgc2xpZ2h0bHkgZGlmZmVyZW50XG5cdFx0XHRcdCogaW50ZXJzZWN0aW9uIHBvaW50LiAgVGhpcyBtaWdodCBsZWF2ZSB0d28gZWRnZXMgd2l0aCBhIHNtYWxsXG5cdFx0XHRcdCogZ2FwIGJldHdlZW4gdGhlbS4gIFRoaXMga2luZCBvZiBlcnJvciBpcyBlc3BlY2lhbGx5IG9idmlvdXNcblx0XHRcdFx0KiB3aGVuIHVzaW5nIGJvdW5kYXJ5IGV4dHJhY3Rpb24gKFRFU1NfQk9VTkRBUllfT05MWSkuXG5cdFx0XHRcdCovXG5cdFx0XHRcdHZOZXh0ID0gdGVzcy5wcS5leHRyYWN0TWluKCk7XG5cdFx0XHRcdFN3ZWVwLnNwbGljZU1lcmdlVmVydGljZXMoIHRlc3MsIHYuYW5FZGdlLCB2TmV4dC5hbkVkZ2UgKTtcblx0XHRcdH1cblx0XHRcdFN3ZWVwLnN3ZWVwRXZlbnQoIHRlc3MsIHYgKTtcblx0XHR9XG5cblx0XHQvKiBTZXQgdGVzcy0+ZXZlbnQgZm9yIGRlYnVnZ2luZyBwdXJwb3NlcyAqL1xuXHRcdHRlc3MuZXZlbnQgPSB0ZXNzLmRpY3QubWluKCkua2V5LmVVcC5Pcmc7XG5cdFx0U3dlZXAuZGVidWdFdmVudCggdGVzcyApO1xuXHRcdFN3ZWVwLmRvbmVFZGdlRGljdCggdGVzcyApO1xuXHRcdFN3ZWVwLmRvbmVQcmlvcml0eVEoIHRlc3MgKTtcblxuXHRcdGlmICggIVN3ZWVwLnJlbW92ZURlZ2VuZXJhdGVGYWNlcyggdGVzcywgdGVzcy5tZXNoICkgKSByZXR1cm4gZmFsc2U7XG5cdFx0dGVzcy5tZXNoLmNoZWNrKCk7XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cblx0ZnVuY3Rpb24gVGVzc2VsYXRvcigpIHtcblxuXHRcdC8qKiogc3RhdGUgbmVlZGVkIGZvciBjb2xsZWN0aW5nIHRoZSBpbnB1dCBkYXRhICoqKi9cblx0XHR0aGlzLm1lc2ggPSBudWxsO1x0XHQvKiBzdG9yZXMgdGhlIGlucHV0IGNvbnRvdXJzLCBhbmQgZXZlbnR1YWxseVxuXHRcdFx0XHRcdFx0XHR0aGUgdGVzc2VsbGF0aW9uIGl0c2VsZiAqL1xuXG5cdFx0LyoqKiBzdGF0ZSBuZWVkZWQgZm9yIHByb2plY3Rpbmcgb250byB0aGUgc3dlZXAgcGxhbmUgKioqL1xuXG5cdFx0dGhpcy5ub3JtYWwgPSBbMC4wLCAwLjAsIDAuMF07XHQvKiB1c2VyLXNwZWNpZmllZCBub3JtYWwgKGlmIHByb3ZpZGVkKSAqL1xuXHRcdHRoaXMuc1VuaXQgPSBbMC4wLCAwLjAsIDAuMF07XHQvKiB1bml0IHZlY3RvciBpbiBzLWRpcmVjdGlvbiAoZGVidWdnaW5nKSAqL1xuXHRcdHRoaXMudFVuaXQgPSBbMC4wLCAwLjAsIDAuMF07XHQvKiB1bml0IHZlY3RvciBpbiB0LWRpcmVjdGlvbiAoZGVidWdnaW5nKSAqL1xuXG5cdFx0dGhpcy5ibWluID0gWzAuMCwgMC4wXTtcblx0XHR0aGlzLmJtYXggPSBbMC4wLCAwLjBdO1xuXG5cdFx0LyoqKiBzdGF0ZSBuZWVkZWQgZm9yIHRoZSBsaW5lIHN3ZWVwICoqKi9cblx0XHR0aGlzLndpbmRpbmdSdWxlID0gVGVzczIuV0lORElOR19PREQ7XHQvKiBydWxlIGZvciBkZXRlcm1pbmluZyBwb2x5Z29uIGludGVyaW9yICovXG5cblx0XHR0aGlzLmRpY3QgPSBudWxsO1x0XHQvKiBlZGdlIGRpY3Rpb25hcnkgZm9yIHN3ZWVwIGxpbmUgKi9cblx0XHR0aGlzLnBxID0gbnVsbDtcdFx0LyogcHJpb3JpdHkgcXVldWUgb2YgdmVydGV4IGV2ZW50cyAqL1xuXHRcdHRoaXMuZXZlbnQgPSBudWxsO1x0XHQvKiBjdXJyZW50IHN3ZWVwIGV2ZW50IGJlaW5nIHByb2Nlc3NlZCAqL1xuXG5cdFx0dGhpcy52ZXJ0ZXhJbmRleENvdW50ZXIgPSAwO1xuXHRcdFxuXHRcdHRoaXMudmVydGljZXMgPSBbXTtcblx0XHR0aGlzLnZlcnRleEluZGljZXMgPSBbXTtcblx0XHR0aGlzLnZlcnRleENvdW50ID0gMDtcblx0XHR0aGlzLmVsZW1lbnRzID0gW107XG5cdFx0dGhpcy5lbGVtZW50Q291bnQgPSAwO1xuXHR9O1xuXG5cdFRlc3NlbGF0b3IucHJvdG90eXBlID0ge1xuXG5cdFx0ZG90XzogZnVuY3Rpb24odSwgdikge1xuXHRcdFx0cmV0dXJuICh1WzBdKnZbMF0gKyB1WzFdKnZbMV0gKyB1WzJdKnZbMl0pO1xuXHRcdH0sXG5cblx0XHRub3JtYWxpemVfOiBmdW5jdGlvbiggdiApIHtcblx0XHRcdHZhciBsZW4gPSB2WzBdKnZbMF0gKyB2WzFdKnZbMV0gKyB2WzJdKnZbMl07XG5cdFx0XHRhc3NlcnQoIGxlbiA+IDAuMCApO1xuXHRcdFx0bGVuID0gTWF0aC5zcXJ0KCBsZW4gKTtcblx0XHRcdHZbMF0gLz0gbGVuO1xuXHRcdFx0dlsxXSAvPSBsZW47XG5cdFx0XHR2WzJdIC89IGxlbjtcblx0XHR9LFxuXG5cdFx0bG9uZ0F4aXNfOiBmdW5jdGlvbiggdiApIHtcblx0XHRcdHZhciBpID0gMDtcblx0XHRcdGlmKCBNYXRoLmFicyh2WzFdKSA+IE1hdGguYWJzKHZbMF0pICkgeyBpID0gMTsgfVxuXHRcdFx0aWYoIE1hdGguYWJzKHZbMl0pID4gTWF0aC5hYnModltpXSkgKSB7IGkgPSAyOyB9XG5cdFx0XHRyZXR1cm4gaTtcblx0XHR9LFxuXG5cdFx0Y29tcHV0ZU5vcm1hbF86IGZ1bmN0aW9uKCBub3JtIClcblx0XHR7XG5cdFx0XHR2YXIgdiwgdjEsIHYyO1xuXHRcdFx0dmFyIGMsIHRMZW4yLCBtYXhMZW4yO1xuXHRcdFx0dmFyIG1heFZhbCA9IFswLDAsMF0sIG1pblZhbCA9IFswLDAsMF0sIGQxID0gWzAsMCwwXSwgZDIgPSBbMCwwLDBdLCB0Tm9ybSA9IFswLDAsMF07XG5cdFx0XHR2YXIgbWF4VmVydCA9IFtudWxsLG51bGwsbnVsbF0sIG1pblZlcnQgPSBbbnVsbCxudWxsLG51bGxdO1xuXHRcdFx0dmFyIHZIZWFkID0gdGhpcy5tZXNoLnZIZWFkO1xuXHRcdFx0dmFyIGk7XG5cblx0XHRcdHYgPSB2SGVhZC5uZXh0O1xuXHRcdFx0Zm9yKCBpID0gMDsgaSA8IDM7ICsraSApIHtcblx0XHRcdFx0YyA9IHYuY29vcmRzW2ldO1xuXHRcdFx0XHRtaW5WYWxbaV0gPSBjO1xuXHRcdFx0XHRtaW5WZXJ0W2ldID0gdjtcblx0XHRcdFx0bWF4VmFsW2ldID0gYztcblx0XHRcdFx0bWF4VmVydFtpXSA9IHY7XG5cdFx0XHR9XG5cblx0XHRcdGZvciggdiA9IHZIZWFkLm5leHQ7IHYgIT09IHZIZWFkOyB2ID0gdi5uZXh0ICkge1xuXHRcdFx0XHRmb3IoIGkgPSAwOyBpIDwgMzsgKytpICkge1xuXHRcdFx0XHRcdGMgPSB2LmNvb3Jkc1tpXTtcblx0XHRcdFx0XHRpZiggYyA8IG1pblZhbFtpXSApIHsgbWluVmFsW2ldID0gYzsgbWluVmVydFtpXSA9IHY7IH1cblx0XHRcdFx0XHRpZiggYyA+IG1heFZhbFtpXSApIHsgbWF4VmFsW2ldID0gYzsgbWF4VmVydFtpXSA9IHY7IH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvKiBGaW5kIHR3byB2ZXJ0aWNlcyBzZXBhcmF0ZWQgYnkgYXQgbGVhc3QgMS9zcXJ0KDMpIG9mIHRoZSBtYXhpbXVtXG5cdFx0XHQqIGRpc3RhbmNlIGJldHdlZW4gYW55IHR3byB2ZXJ0aWNlc1xuXHRcdFx0Ki9cblx0XHRcdGkgPSAwO1xuXHRcdFx0aWYoIG1heFZhbFsxXSAtIG1pblZhbFsxXSA+IG1heFZhbFswXSAtIG1pblZhbFswXSApIHsgaSA9IDE7IH1cblx0XHRcdGlmKCBtYXhWYWxbMl0gLSBtaW5WYWxbMl0gPiBtYXhWYWxbaV0gLSBtaW5WYWxbaV0gKSB7IGkgPSAyOyB9XG5cdFx0XHRpZiggbWluVmFsW2ldID49IG1heFZhbFtpXSApIHtcblx0XHRcdFx0LyogQWxsIHZlcnRpY2VzIGFyZSB0aGUgc2FtZSAtLSBub3JtYWwgZG9lc24ndCBtYXR0ZXIgKi9cblx0XHRcdFx0bm9ybVswXSA9IDA7IG5vcm1bMV0gPSAwOyBub3JtWzJdID0gMTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvKiBMb29rIGZvciBhIHRoaXJkIHZlcnRleCB3aGljaCBmb3JtcyB0aGUgdHJpYW5nbGUgd2l0aCBtYXhpbXVtIGFyZWFcblx0XHRcdCogKExlbmd0aCBvZiBub3JtYWwgPT0gdHdpY2UgdGhlIHRyaWFuZ2xlIGFyZWEpXG5cdFx0XHQqL1xuXHRcdFx0bWF4TGVuMiA9IDA7XG5cdFx0XHR2MSA9IG1pblZlcnRbaV07XG5cdFx0XHR2MiA9IG1heFZlcnRbaV07XG5cdFx0XHRkMVswXSA9IHYxLmNvb3Jkc1swXSAtIHYyLmNvb3Jkc1swXTtcblx0XHRcdGQxWzFdID0gdjEuY29vcmRzWzFdIC0gdjIuY29vcmRzWzFdO1xuXHRcdFx0ZDFbMl0gPSB2MS5jb29yZHNbMl0gLSB2Mi5jb29yZHNbMl07XG5cdFx0XHRmb3IoIHYgPSB2SGVhZC5uZXh0OyB2ICE9PSB2SGVhZDsgdiA9IHYubmV4dCApIHtcblx0XHRcdFx0ZDJbMF0gPSB2LmNvb3Jkc1swXSAtIHYyLmNvb3Jkc1swXTtcblx0XHRcdFx0ZDJbMV0gPSB2LmNvb3Jkc1sxXSAtIHYyLmNvb3Jkc1sxXTtcblx0XHRcdFx0ZDJbMl0gPSB2LmNvb3Jkc1syXSAtIHYyLmNvb3Jkc1syXTtcblx0XHRcdFx0dE5vcm1bMF0gPSBkMVsxXSpkMlsyXSAtIGQxWzJdKmQyWzFdO1xuXHRcdFx0XHR0Tm9ybVsxXSA9IGQxWzJdKmQyWzBdIC0gZDFbMF0qZDJbMl07XG5cdFx0XHRcdHROb3JtWzJdID0gZDFbMF0qZDJbMV0gLSBkMVsxXSpkMlswXTtcblx0XHRcdFx0dExlbjIgPSB0Tm9ybVswXSp0Tm9ybVswXSArIHROb3JtWzFdKnROb3JtWzFdICsgdE5vcm1bMl0qdE5vcm1bMl07XG5cdFx0XHRcdGlmKCB0TGVuMiA+IG1heExlbjIgKSB7XG5cdFx0XHRcdFx0bWF4TGVuMiA9IHRMZW4yO1xuXHRcdFx0XHRcdG5vcm1bMF0gPSB0Tm9ybVswXTtcblx0XHRcdFx0XHRub3JtWzFdID0gdE5vcm1bMV07XG5cdFx0XHRcdFx0bm9ybVsyXSA9IHROb3JtWzJdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmKCBtYXhMZW4yIDw9IDAgKSB7XG5cdFx0XHRcdC8qIEFsbCBwb2ludHMgbGllIG9uIGEgc2luZ2xlIGxpbmUgLS0gYW55IGRlY2VudCBub3JtYWwgd2lsbCBkbyAqL1xuXHRcdFx0XHRub3JtWzBdID0gbm9ybVsxXSA9IG5vcm1bMl0gPSAwO1xuXHRcdFx0XHRub3JtW3RoaXMubG9uZ0F4aXNfKGQxKV0gPSAxO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRjaGVja09yaWVudGF0aW9uXzogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgYXJlYTtcblx0XHRcdHZhciBmLCBmSGVhZCA9IHRoaXMubWVzaC5mSGVhZDtcblx0XHRcdHZhciB2LCB2SGVhZCA9IHRoaXMubWVzaC52SGVhZDtcblx0XHRcdHZhciBlO1xuXG5cdFx0XHQvKiBXaGVuIHdlIGNvbXB1dGUgdGhlIG5vcm1hbCBhdXRvbWF0aWNhbGx5LCB3ZSBjaG9vc2UgdGhlIG9yaWVudGF0aW9uXG5cdFx0XHQqIHNvIHRoYXQgdGhlIHRoZSBzdW0gb2YgdGhlIHNpZ25lZCBhcmVhcyBvZiBhbGwgY29udG91cnMgaXMgbm9uLW5lZ2F0aXZlLlxuXHRcdFx0Ki9cblx0XHRcdGFyZWEgPSAwO1xuXHRcdFx0Zm9yKCBmID0gZkhlYWQubmV4dDsgZiAhPT0gZkhlYWQ7IGYgPSBmLm5leHQgKSB7XG5cdFx0XHRcdGUgPSBmLmFuRWRnZTtcblx0XHRcdFx0aWYoIGUud2luZGluZyA8PSAwICkgY29udGludWU7XG5cdFx0XHRcdGRvIHtcblx0XHRcdFx0XHRhcmVhICs9IChlLk9yZy5zIC0gZS5Ec3QucykgKiAoZS5PcmcudCArIGUuRHN0LnQpO1xuXHRcdFx0XHRcdGUgPSBlLkxuZXh0O1xuXHRcdFx0XHR9IHdoaWxlKCBlICE9PSBmLmFuRWRnZSApO1xuXHRcdFx0fVxuXHRcdFx0aWYoIGFyZWEgPCAwICkge1xuXHRcdFx0XHQvKiBSZXZlcnNlIHRoZSBvcmllbnRhdGlvbiBieSBmbGlwcGluZyBhbGwgdGhlIHQtY29vcmRpbmF0ZXMgKi9cblx0XHRcdFx0Zm9yKCB2ID0gdkhlYWQubmV4dDsgdiAhPT0gdkhlYWQ7IHYgPSB2Lm5leHQgKSB7XG5cdFx0XHRcdFx0di50ID0gLSB2LnQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy50VW5pdFswXSA9IC0gdGhpcy50VW5pdFswXTtcblx0XHRcdFx0dGhpcy50VW5pdFsxXSA9IC0gdGhpcy50VW5pdFsxXTtcblx0XHRcdFx0dGhpcy50VW5pdFsyXSA9IC0gdGhpcy50VW5pdFsyXTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdC8qXHQjaWZkZWYgRk9SX1RSSVRFX1RFU1RfUFJPR1JBTVxuXHRcdCNpbmNsdWRlIDxzdGRsaWIuaD5cblx0XHRleHRlcm4gaW50IFJhbmRvbVN3ZWVwO1xuXHRcdCNkZWZpbmUgU19VTklUX1hcdChSYW5kb21Td2VlcCA/ICgyKmRyYW5kNDgoKS0xKSA6IDEuMClcblx0XHQjZGVmaW5lIFNfVU5JVF9ZXHQoUmFuZG9tU3dlZXAgPyAoMipkcmFuZDQ4KCktMSkgOiAwLjApXG5cdFx0I2Vsc2Vcblx0XHQjaWYgZGVmaW5lZChTTEFOVEVEX1NXRUVQKSAqL1xuXHRcdC8qIFRoZSBcImZlYXR1cmUgbWVyZ2luZ1wiIGlzIG5vdCBpbnRlbmRlZCB0byBiZSBjb21wbGV0ZS4gIFRoZXJlIGFyZVxuXHRcdCogc3BlY2lhbCBjYXNlcyB3aGVyZSBlZGdlcyBhcmUgbmVhcmx5IHBhcmFsbGVsIHRvIHRoZSBzd2VlcCBsaW5lXG5cdFx0KiB3aGljaCBhcmUgbm90IGltcGxlbWVudGVkLiAgVGhlIGFsZ29yaXRobSBzaG91bGQgc3RpbGwgYmVoYXZlXG5cdFx0KiByb2J1c3RseSAoaWUuIHByb2R1Y2UgYSByZWFzb25hYmxlIHRlc3NlbGF0aW9uKSBpbiB0aGUgcHJlc2VuY2Vcblx0XHQqIG9mIHN1Y2ggZWRnZXMsIGhvd2V2ZXIgaXQgbWF5IG1pc3MgZmVhdHVyZXMgd2hpY2ggY291bGQgaGF2ZSBiZWVuXG5cdFx0KiBtZXJnZWQuICBXZSBjb3VsZCBtaW5pbWl6ZSB0aGlzIGVmZmVjdCBieSBjaG9vc2luZyB0aGUgc3dlZXAgbGluZVxuXHRcdCogZGlyZWN0aW9uIHRvIGJlIHNvbWV0aGluZyB1bnVzdWFsIChpZS4gbm90IHBhcmFsbGVsIHRvIG9uZSBvZiB0aGVcblx0XHQqIGNvb3JkaW5hdGUgYXhlcykuXG5cdFx0Ki9cblx0LypcdCNkZWZpbmUgU19VTklUX1hcdChURVNTcmVhbCkwLjUwOTQxNTM5NTY0OTU1Mzg1XHQvLyBQcmUtbm9ybWFsaXplZFxuXHRcdCNkZWZpbmUgU19VTklUX1lcdChURVNTcmVhbCkwLjg2MDUyMDc0NjIyMDEwNjMzXG5cdFx0I2Vsc2Vcblx0XHQjZGVmaW5lIFNfVU5JVF9YXHQoVEVTU3JlYWwpMS4wXG5cdFx0I2RlZmluZSBTX1VOSVRfWVx0KFRFU1NyZWFsKTAuMFxuXHRcdCNlbmRpZlxuXHRcdCNlbmRpZiovXG5cblx0XHQvKiBEZXRlcm1pbmUgdGhlIHBvbHlnb24gbm9ybWFsIGFuZCBwcm9qZWN0IHZlcnRpY2VzIG9udG8gdGhlIHBsYW5lXG5cdFx0KiBvZiB0aGUgcG9seWdvbi5cblx0XHQqL1xuXHRcdHByb2plY3RQb2x5Z29uXzogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgdiwgdkhlYWQgPSB0aGlzLm1lc2gudkhlYWQ7XG5cdFx0XHR2YXIgbm9ybSA9IFswLDAsMF07XG5cdFx0XHR2YXIgc1VuaXQsIHRVbml0O1xuXHRcdFx0dmFyIGksIGZpcnN0LCBjb21wdXRlZE5vcm1hbCA9IGZhbHNlO1xuXG5cdFx0XHRub3JtWzBdID0gdGhpcy5ub3JtYWxbMF07XG5cdFx0XHRub3JtWzFdID0gdGhpcy5ub3JtYWxbMV07XG5cdFx0XHRub3JtWzJdID0gdGhpcy5ub3JtYWxbMl07XG5cdFx0XHRpZiggbm9ybVswXSA9PT0gMC4wICYmIG5vcm1bMV0gPT09IDAuMCAmJiBub3JtWzJdID09PSAwLjAgKSB7XG5cdFx0XHRcdHRoaXMuY29tcHV0ZU5vcm1hbF8oIG5vcm0gKTtcblx0XHRcdFx0Y29tcHV0ZWROb3JtYWwgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0c1VuaXQgPSB0aGlzLnNVbml0O1xuXHRcdFx0dFVuaXQgPSB0aGlzLnRVbml0O1xuXHRcdFx0aSA9IHRoaXMubG9uZ0F4aXNfKCBub3JtICk7XG5cblx0LypcdCNpZiBkZWZpbmVkKEZPUl9UUklURV9URVNUX1BST0dSQU0pIHx8IGRlZmluZWQoVFJVRV9QUk9KRUNUKVxuXHRcdFx0Ly8gQ2hvb3NlIHRoZSBpbml0aWFsIHNVbml0IHZlY3RvciB0byBiZSBhcHByb3hpbWF0ZWx5IHBlcnBlbmRpY3VsYXJcblx0XHRcdC8vIHRvIHRoZSBub3JtYWwuXG5cdFx0XHRcblx0XHRcdE5vcm1hbGl6ZSggbm9ybSApO1xuXG5cdFx0XHRzVW5pdFtpXSA9IDA7XG5cdFx0XHRzVW5pdFsoaSsxKSUzXSA9IFNfVU5JVF9YO1xuXHRcdFx0c1VuaXRbKGkrMiklM10gPSBTX1VOSVRfWTtcblxuXHRcdFx0Ly8gTm93IG1ha2UgaXQgZXhhY3RseSBwZXJwZW5kaWN1bGFyIFxuXHRcdFx0dyA9IERvdCggc1VuaXQsIG5vcm0gKTtcblx0XHRcdHNVbml0WzBdIC09IHcgKiBub3JtWzBdO1xuXHRcdFx0c1VuaXRbMV0gLT0gdyAqIG5vcm1bMV07XG5cdFx0XHRzVW5pdFsyXSAtPSB3ICogbm9ybVsyXTtcblx0XHRcdE5vcm1hbGl6ZSggc1VuaXQgKTtcblxuXHRcdFx0Ly8gQ2hvb3NlIHRVbml0IHNvIHRoYXQgKHNVbml0LHRVbml0LG5vcm0pIGZvcm0gYSByaWdodC1oYW5kZWQgZnJhbWUgXG5cdFx0XHR0VW5pdFswXSA9IG5vcm1bMV0qc1VuaXRbMl0gLSBub3JtWzJdKnNVbml0WzFdO1xuXHRcdFx0dFVuaXRbMV0gPSBub3JtWzJdKnNVbml0WzBdIC0gbm9ybVswXSpzVW5pdFsyXTtcblx0XHRcdHRVbml0WzJdID0gbm9ybVswXSpzVW5pdFsxXSAtIG5vcm1bMV0qc1VuaXRbMF07XG5cdFx0XHROb3JtYWxpemUoIHRVbml0ICk7XG5cdFx0I2Vsc2UqL1xuXHRcdFx0LyogUHJvamVjdCBwZXJwZW5kaWN1bGFyIHRvIGEgY29vcmRpbmF0ZSBheGlzIC0tIGJldHRlciBudW1lcmljYWxseSAqL1xuXHRcdFx0c1VuaXRbaV0gPSAwO1xuXHRcdFx0c1VuaXRbKGkrMSklM10gPSAxLjA7XG5cdFx0XHRzVW5pdFsoaSsyKSUzXSA9IDAuMDtcblxuXHRcdFx0dFVuaXRbaV0gPSAwO1xuXHRcdFx0dFVuaXRbKGkrMSklM10gPSAwLjA7XG5cdFx0XHR0VW5pdFsoaSsyKSUzXSA9IChub3JtW2ldID4gMCkgPyAxLjAgOiAtMS4wO1xuXHQvL1x0I2VuZGlmXG5cblx0XHRcdC8qIFByb2plY3QgdGhlIHZlcnRpY2VzIG9udG8gdGhlIHN3ZWVwIHBsYW5lICovXG5cdFx0XHRmb3IoIHYgPSB2SGVhZC5uZXh0OyB2ICE9PSB2SGVhZDsgdiA9IHYubmV4dCApIHtcblx0XHRcdFx0di5zID0gdGhpcy5kb3RfKCB2LmNvb3Jkcywgc1VuaXQgKTtcblx0XHRcdFx0di50ID0gdGhpcy5kb3RfKCB2LmNvb3JkcywgdFVuaXQgKTtcblx0XHRcdH1cblx0XHRcdGlmKCBjb21wdXRlZE5vcm1hbCApIHtcblx0XHRcdFx0dGhpcy5jaGVja09yaWVudGF0aW9uXygpO1xuXHRcdFx0fVxuXG5cdFx0XHQvKiBDb21wdXRlIFNUIGJvdW5kcy4gKi9cblx0XHRcdGZpcnN0ID0gdHJ1ZTtcblx0XHRcdGZvciggdiA9IHZIZWFkLm5leHQ7IHYgIT09IHZIZWFkOyB2ID0gdi5uZXh0ICkge1xuXHRcdFx0XHRpZiAoZmlyc3QpIHtcblx0XHRcdFx0XHR0aGlzLmJtaW5bMF0gPSB0aGlzLmJtYXhbMF0gPSB2LnM7XG5cdFx0XHRcdFx0dGhpcy5ibWluWzFdID0gdGhpcy5ibWF4WzFdID0gdi50O1xuXHRcdFx0XHRcdGZpcnN0ID0gZmFsc2U7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aWYgKHYucyA8IHRoaXMuYm1pblswXSkgdGhpcy5ibWluWzBdID0gdi5zO1xuXHRcdFx0XHRcdGlmICh2LnMgPiB0aGlzLmJtYXhbMF0pIHRoaXMuYm1heFswXSA9IHYucztcblx0XHRcdFx0XHRpZiAodi50IDwgdGhpcy5ibWluWzFdKSB0aGlzLmJtaW5bMV0gPSB2LnQ7XG5cdFx0XHRcdFx0aWYgKHYudCA+IHRoaXMuYm1heFsxXSkgdGhpcy5ibWF4WzFdID0gdi50O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGFkZFdpbmRpbmdfOiBmdW5jdGlvbihlRHN0LGVTcmMpIHtcblx0XHRcdGVEc3Qud2luZGluZyArPSBlU3JjLndpbmRpbmc7XG5cdFx0XHRlRHN0LlN5bS53aW5kaW5nICs9IGVTcmMuU3ltLndpbmRpbmc7XG5cdFx0fSxcblx0XHRcblx0XHQvKiB0ZXNzTWVzaFRlc3NlbGxhdGVNb25vUmVnaW9uKCBmYWNlICkgdGVzc2VsbGF0ZXMgYSBtb25vdG9uZSByZWdpb25cblx0XHQqICh3aGF0IGVsc2Ugd291bGQgaXQgZG8/PykgIFRoZSByZWdpb24gbXVzdCBjb25zaXN0IG9mIGEgc2luZ2xlXG5cdFx0KiBsb29wIG9mIGhhbGYtZWRnZXMgKHNlZSBtZXNoLmgpIG9yaWVudGVkIENDVy4gIFwiTW9ub3RvbmVcIiBpbiB0aGlzXG5cdFx0KiBjYXNlIG1lYW5zIHRoYXQgYW55IHZlcnRpY2FsIGxpbmUgaW50ZXJzZWN0cyB0aGUgaW50ZXJpb3Igb2YgdGhlXG5cdFx0KiByZWdpb24gaW4gYSBzaW5nbGUgaW50ZXJ2YWwuICBcblx0XHQqXG5cdFx0KiBUZXNzZWxsYXRpb24gY29uc2lzdHMgb2YgYWRkaW5nIGludGVyaW9yIGVkZ2VzIChhY3R1YWxseSBwYWlycyBvZlxuXHRcdCogaGFsZi1lZGdlcyksIHRvIHNwbGl0IHRoZSByZWdpb24gaW50byBub24tb3ZlcmxhcHBpbmcgdHJpYW5nbGVzLlxuXHRcdCpcblx0XHQqIFRoZSBiYXNpYyBpZGVhIGlzIGV4cGxhaW5lZCBpbiBQcmVwYXJhdGEgYW5kIFNoYW1vcyAod2hpY2ggSSBkb24nJ3Rcblx0XHQqIGhhdmUgaGFuZHkgcmlnaHQgbm93KSwgYWx0aG91Z2ggdGhlaXIgaW1wbGVtZW50YXRpb24gaXMgbW9yZVxuXHRcdCogY29tcGxpY2F0ZWQgdGhhbiB0aGlzIG9uZS4gIFRoZSBhcmUgdHdvIGVkZ2UgY2hhaW5zLCBhbiB1cHBlciBjaGFpblxuXHRcdCogYW5kIGEgbG93ZXIgY2hhaW4uICBXZSBwcm9jZXNzIGFsbCB2ZXJ0aWNlcyBmcm9tIGJvdGggY2hhaW5zIGluIG9yZGVyLFxuXHRcdCogZnJvbSByaWdodCB0byBsZWZ0LlxuXHRcdCpcblx0XHQqIFRoZSBhbGdvcml0aG0gZW5zdXJlcyB0aGF0IHRoZSBmb2xsb3dpbmcgaW52YXJpYW50IGhvbGRzIGFmdGVyIGVhY2hcblx0XHQqIHZlcnRleCBpcyBwcm9jZXNzZWQ6IHRoZSB1bnRlc3NlbGxhdGVkIHJlZ2lvbiBjb25zaXN0cyBvZiB0d29cblx0XHQqIGNoYWlucywgd2hlcmUgb25lIGNoYWluIChzYXkgdGhlIHVwcGVyKSBpcyBhIHNpbmdsZSBlZGdlLCBhbmRcblx0XHQqIHRoZSBvdGhlciBjaGFpbiBpcyBjb25jYXZlLiAgVGhlIGxlZnQgdmVydGV4IG9mIHRoZSBzaW5nbGUgZWRnZVxuXHRcdCogaXMgYWx3YXlzIHRvIHRoZSBsZWZ0IG9mIGFsbCB2ZXJ0aWNlcyBpbiB0aGUgY29uY2F2ZSBjaGFpbi5cblx0XHQqXG5cdFx0KiBFYWNoIHN0ZXAgY29uc2lzdHMgb2YgYWRkaW5nIHRoZSByaWdodG1vc3QgdW5wcm9jZXNzZWQgdmVydGV4IHRvIG9uZVxuXHRcdCogb2YgdGhlIHR3byBjaGFpbnMsIGFuZCBmb3JtaW5nIGEgZmFuIG9mIHRyaWFuZ2xlcyBmcm9tIHRoZSByaWdodG1vc3Rcblx0XHQqIG9mIHR3byBjaGFpbiBlbmRwb2ludHMuICBEZXRlcm1pbmluZyB3aGV0aGVyIHdlIGNhbiBhZGQgZWFjaCB0cmlhbmdsZVxuXHRcdCogdG8gdGhlIGZhbiBpcyBhIHNpbXBsZSBvcmllbnRhdGlvbiB0ZXN0LiAgQnkgbWFraW5nIHRoZSBmYW4gYXMgbGFyZ2Vcblx0XHQqIGFzIHBvc3NpYmxlLCB3ZSByZXN0b3JlIHRoZSBpbnZhcmlhbnQgKGNoZWNrIGl0IHlvdXJzZWxmKS5cblx0XHQqL1xuXHQvL1x0aW50IHRlc3NNZXNoVGVzc2VsbGF0ZU1vbm9SZWdpb24oIFRFU1NtZXNoICptZXNoLCBURVNTZmFjZSAqZmFjZSApXG5cdFx0dGVzc2VsbGF0ZU1vbm9SZWdpb25fOiBmdW5jdGlvbiggbWVzaCwgZmFjZSApIHtcblx0XHRcdHZhciB1cCwgbG87XG5cblx0XHRcdC8qIEFsbCBlZGdlcyBhcmUgb3JpZW50ZWQgQ0NXIGFyb3VuZCB0aGUgYm91bmRhcnkgb2YgdGhlIHJlZ2lvbi5cblx0XHRcdCogRmlyc3QsIGZpbmQgdGhlIGhhbGYtZWRnZSB3aG9zZSBvcmlnaW4gdmVydGV4IGlzIHJpZ2h0bW9zdC5cblx0XHRcdCogU2luY2UgdGhlIHN3ZWVwIGdvZXMgZnJvbSBsZWZ0IHRvIHJpZ2h0LCBmYWNlLT5hbkVkZ2Ugc2hvdWxkXG5cdFx0XHQqIGJlIGNsb3NlIHRvIHRoZSBlZGdlIHdlIHdhbnQuXG5cdFx0XHQqL1xuXHRcdFx0dXAgPSBmYWNlLmFuRWRnZTtcblx0XHRcdGFzc2VydCggdXAuTG5leHQgIT09IHVwICYmIHVwLkxuZXh0LkxuZXh0ICE9PSB1cCApO1xuXG5cdFx0XHRmb3IoIDsgR2VvbS52ZXJ0TGVxKCB1cC5Ec3QsIHVwLk9yZyApOyB1cCA9IHVwLkxwcmV2IClcblx0XHRcdFx0O1xuXHRcdFx0Zm9yKCA7IEdlb20udmVydExlcSggdXAuT3JnLCB1cC5Ec3QgKTsgdXAgPSB1cC5MbmV4dCApXG5cdFx0XHRcdDtcblx0XHRcdGxvID0gdXAuTHByZXY7XG5cblx0XHRcdHdoaWxlKCB1cC5MbmV4dCAhPT0gbG8gKSB7XG5cdFx0XHRcdGlmKCBHZW9tLnZlcnRMZXEoIHVwLkRzdCwgbG8uT3JnICkpIHtcblx0XHRcdFx0XHQvKiB1cC0+RHN0IGlzIG9uIHRoZSBsZWZ0LiAgSXQgaXMgc2FmZSB0byBmb3JtIHRyaWFuZ2xlcyBmcm9tIGxvLT5PcmcuXG5cdFx0XHRcdFx0KiBUaGUgRWRnZUdvZXNMZWZ0IHRlc3QgZ3VhcmFudGVlcyBwcm9ncmVzcyBldmVuIHdoZW4gc29tZSB0cmlhbmdsZXNcblx0XHRcdFx0XHQqIGFyZSBDVywgZ2l2ZW4gdGhhdCB0aGUgdXBwZXIgYW5kIGxvd2VyIGNoYWlucyBhcmUgdHJ1bHkgbW9ub3RvbmUuXG5cdFx0XHRcdFx0Ki9cblx0XHRcdFx0XHR3aGlsZSggbG8uTG5leHQgIT09IHVwICYmIChHZW9tLmVkZ2VHb2VzTGVmdCggbG8uTG5leHQgKVxuXHRcdFx0XHRcdFx0fHwgR2VvbS5lZGdlU2lnbiggbG8uT3JnLCBsby5Ec3QsIGxvLkxuZXh0LkRzdCApIDw9IDAuMCApKSB7XG5cdFx0XHRcdFx0XHRcdHZhciB0ZW1wSGFsZkVkZ2UgPSBtZXNoLmNvbm5lY3QoIGxvLkxuZXh0LCBsbyApO1xuXHRcdFx0XHRcdFx0XHQvL2lmICh0ZW1wSGFsZkVkZ2UgPT0gTlVMTCkgcmV0dXJuIDA7XG5cdFx0XHRcdFx0XHRcdGxvID0gdGVtcEhhbGZFZGdlLlN5bTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bG8gPSBsby5McHJldjtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvKiBsby0+T3JnIGlzIG9uIHRoZSBsZWZ0LiAgV2UgY2FuIG1ha2UgQ0NXIHRyaWFuZ2xlcyBmcm9tIHVwLT5Ec3QuICovXG5cdFx0XHRcdFx0d2hpbGUoIGxvLkxuZXh0ICE9IHVwICYmIChHZW9tLmVkZ2VHb2VzUmlnaHQoIHVwLkxwcmV2IClcblx0XHRcdFx0XHRcdHx8IEdlb20uZWRnZVNpZ24oIHVwLkRzdCwgdXAuT3JnLCB1cC5McHJldi5PcmcgKSA+PSAwLjAgKSkge1xuXHRcdFx0XHRcdFx0XHR2YXIgdGVtcEhhbGZFZGdlID0gbWVzaC5jb25uZWN0KCB1cCwgdXAuTHByZXYgKTtcblx0XHRcdFx0XHRcdFx0Ly9pZiAodGVtcEhhbGZFZGdlID09IE5VTEwpIHJldHVybiAwO1xuXHRcdFx0XHRcdFx0XHR1cCA9IHRlbXBIYWxmRWRnZS5TeW07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHVwID0gdXAuTG5leHQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0LyogTm93IGxvLT5PcmcgPT0gdXAtPkRzdCA9PSB0aGUgbGVmdG1vc3QgdmVydGV4LiAgVGhlIHJlbWFpbmluZyByZWdpb25cblx0XHRcdCogY2FuIGJlIHRlc3NlbGxhdGVkIGluIGEgZmFuIGZyb20gdGhpcyBsZWZ0bW9zdCB2ZXJ0ZXguXG5cdFx0XHQqL1xuXHRcdFx0YXNzZXJ0KCBsby5MbmV4dCAhPT0gdXAgKTtcblx0XHRcdHdoaWxlKCBsby5MbmV4dC5MbmV4dCAhPT0gdXAgKSB7XG5cdFx0XHRcdHZhciB0ZW1wSGFsZkVkZ2UgPSBtZXNoLmNvbm5lY3QoIGxvLkxuZXh0LCBsbyApO1xuXHRcdFx0XHQvL2lmICh0ZW1wSGFsZkVkZ2UgPT0gTlVMTCkgcmV0dXJuIDA7XG5cdFx0XHRcdGxvID0gdGVtcEhhbGZFZGdlLlN5bTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSxcblxuXG5cdFx0LyogdGVzc01lc2hUZXNzZWxsYXRlSW50ZXJpb3IoIG1lc2ggKSB0ZXNzZWxsYXRlcyBlYWNoIHJlZ2lvbiBvZlxuXHRcdCogdGhlIG1lc2ggd2hpY2ggaXMgbWFya2VkIFwiaW5zaWRlXCIgdGhlIHBvbHlnb24uICBFYWNoIHN1Y2ggcmVnaW9uXG5cdFx0KiBtdXN0IGJlIG1vbm90b25lLlxuXHRcdCovXG5cdFx0Ly9pbnQgdGVzc01lc2hUZXNzZWxsYXRlSW50ZXJpb3IoIFRFU1NtZXNoICptZXNoIClcblx0XHR0ZXNzZWxsYXRlSW50ZXJpb3JfOiBmdW5jdGlvbiggbWVzaCApIHtcblx0XHRcdHZhciBmLCBuZXh0O1xuXG5cdFx0XHQvKkxJTlRFRCovXG5cdFx0XHRmb3IoIGYgPSBtZXNoLmZIZWFkLm5leHQ7IGYgIT09IG1lc2guZkhlYWQ7IGYgPSBuZXh0ICkge1xuXHRcdFx0XHQvKiBNYWtlIHN1cmUgd2UgZG9uJyd0IHRyeSB0byB0ZXNzZWxsYXRlIHRoZSBuZXcgdHJpYW5nbGVzLiAqL1xuXHRcdFx0XHRuZXh0ID0gZi5uZXh0O1xuXHRcdFx0XHRpZiggZi5pbnNpZGUgKSB7XG5cdFx0XHRcdFx0aWYgKCAhdGhpcy50ZXNzZWxsYXRlTW9ub1JlZ2lvbl8oIG1lc2gsIGYgKSApIHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9LFxuXG5cblx0XHQvKiB0ZXNzTWVzaERpc2NhcmRFeHRlcmlvciggbWVzaCApIHphcHMgKGllLiBzZXRzIHRvIE5VTEwpIGFsbCBmYWNlc1xuXHRcdCogd2hpY2ggYXJlIG5vdCBtYXJrZWQgXCJpbnNpZGVcIiB0aGUgcG9seWdvbi4gIFNpbmNlIGZ1cnRoZXIgbWVzaCBvcGVyYXRpb25zXG5cdFx0KiBvbiBOVUxMIGZhY2VzIGFyZSBub3QgYWxsb3dlZCwgdGhlIG1haW4gcHVycG9zZSBpcyB0byBjbGVhbiB1cCB0aGVcblx0XHQqIG1lc2ggc28gdGhhdCBleHRlcmlvciBsb29wcyBhcmUgbm90IHJlcHJlc2VudGVkIGluIHRoZSBkYXRhIHN0cnVjdHVyZS5cblx0XHQqL1xuXHRcdC8vdm9pZCB0ZXNzTWVzaERpc2NhcmRFeHRlcmlvciggVEVTU21lc2ggKm1lc2ggKVxuXHRcdGRpc2NhcmRFeHRlcmlvcl86IGZ1bmN0aW9uKCBtZXNoICkge1xuXHRcdFx0dmFyIGYsIG5leHQ7XG5cblx0XHRcdC8qTElOVEVEKi9cblx0XHRcdGZvciggZiA9IG1lc2guZkhlYWQubmV4dDsgZiAhPT0gbWVzaC5mSGVhZDsgZiA9IG5leHQgKSB7XG5cdFx0XHRcdC8qIFNpbmNlIGYgd2lsbCBiZSBkZXN0cm95ZWQsIHNhdmUgaXRzIG5leHQgcG9pbnRlci4gKi9cblx0XHRcdFx0bmV4dCA9IGYubmV4dDtcblx0XHRcdFx0aWYoICEgZi5pbnNpZGUgKSB7XG5cdFx0XHRcdFx0bWVzaC56YXBGYWNlKCBmICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyogdGVzc01lc2hTZXRXaW5kaW5nTnVtYmVyKCBtZXNoLCB2YWx1ZSwga2VlcE9ubHlCb3VuZGFyeSApIHJlc2V0cyB0aGVcblx0XHQqIHdpbmRpbmcgbnVtYmVycyBvbiBhbGwgZWRnZXMgc28gdGhhdCByZWdpb25zIG1hcmtlZCBcImluc2lkZVwiIHRoZVxuXHRcdCogcG9seWdvbiBoYXZlIGEgd2luZGluZyBudW1iZXIgb2YgXCJ2YWx1ZVwiLCBhbmQgcmVnaW9ucyBvdXRzaWRlXG5cdFx0KiBoYXZlIGEgd2luZGluZyBudW1iZXIgb2YgMC5cblx0XHQqXG5cdFx0KiBJZiBrZWVwT25seUJvdW5kYXJ5IGlzIFRSVUUsIGl0IGFsc28gZGVsZXRlcyBhbGwgZWRnZXMgd2hpY2ggZG8gbm90XG5cdFx0KiBzZXBhcmF0ZSBhbiBpbnRlcmlvciByZWdpb24gZnJvbSBhbiBleHRlcmlvciBvbmUuXG5cdFx0Ki9cblx0Ly9cdGludCB0ZXNzTWVzaFNldFdpbmRpbmdOdW1iZXIoIFRFU1NtZXNoICptZXNoLCBpbnQgdmFsdWUsIGludCBrZWVwT25seUJvdW5kYXJ5IClcblx0XHRzZXRXaW5kaW5nTnVtYmVyXzogZnVuY3Rpb24oIG1lc2gsIHZhbHVlLCBrZWVwT25seUJvdW5kYXJ5ICkge1xuXHRcdFx0dmFyIGUsIGVOZXh0O1xuXG5cdFx0XHRmb3IoIGUgPSBtZXNoLmVIZWFkLm5leHQ7IGUgIT09IG1lc2guZUhlYWQ7IGUgPSBlTmV4dCApIHtcblx0XHRcdFx0ZU5leHQgPSBlLm5leHQ7XG5cdFx0XHRcdGlmKCBlLlJmYWNlLmluc2lkZSAhPT0gZS5MZmFjZS5pbnNpZGUgKSB7XG5cblx0XHRcdFx0XHQvKiBUaGlzIGlzIGEgYm91bmRhcnkgZWRnZSAob25lIHNpZGUgaXMgaW50ZXJpb3IsIG9uZSBpcyBleHRlcmlvcikuICovXG5cdFx0XHRcdFx0ZS53aW5kaW5nID0gKGUuTGZhY2UuaW5zaWRlKSA/IHZhbHVlIDogLXZhbHVlO1xuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0LyogQm90aCByZWdpb25zIGFyZSBpbnRlcmlvciwgb3IgYm90aCBhcmUgZXh0ZXJpb3IuICovXG5cdFx0XHRcdFx0aWYoICEga2VlcE9ubHlCb3VuZGFyeSApIHtcblx0XHRcdFx0XHRcdGUud2luZGluZyA9IDA7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdG1lc2guZGVsZXRlKCBlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGdldE5laWdoYm91ckZhY2VfOiBmdW5jdGlvbihlZGdlKVxuXHRcdHtcblx0XHRcdGlmICghZWRnZS5SZmFjZSlcblx0XHRcdFx0cmV0dXJuIC0xO1xuXHRcdFx0aWYgKCFlZGdlLlJmYWNlLmluc2lkZSlcblx0XHRcdFx0cmV0dXJuIC0xO1xuXHRcdFx0cmV0dXJuIGVkZ2UuUmZhY2Uubjtcblx0XHR9LFxuXG5cdFx0b3V0cHV0UG9seW1lc2hfOiBmdW5jdGlvbiggbWVzaCwgZWxlbWVudFR5cGUsIHBvbHlTaXplLCB2ZXJ0ZXhTaXplICkge1xuXHRcdFx0dmFyIHY7XG5cdFx0XHR2YXIgZjtcblx0XHRcdHZhciBlZGdlO1xuXHRcdFx0dmFyIG1heEZhY2VDb3VudCA9IDA7XG5cdFx0XHR2YXIgbWF4VmVydGV4Q291bnQgPSAwO1xuXHRcdFx0dmFyIGZhY2VWZXJ0cywgaTtcblx0XHRcdHZhciBlbGVtZW50cyA9IDA7XG5cdFx0XHR2YXIgdmVydDtcblxuXHRcdFx0Ly8gQXNzdW1lIHRoYXQgdGhlIGlucHV0IGRhdGEgaXMgdHJpYW5nbGVzIG5vdy5cblx0XHRcdC8vIFRyeSB0byBtZXJnZSBhcyBtYW55IHBvbHlnb25zIGFzIHBvc3NpYmxlXG5cdFx0XHRpZiAocG9seVNpemUgPiAzKVxuXHRcdFx0e1xuXHRcdFx0XHRtZXNoLm1lcmdlQ29udmV4RmFjZXMoIHBvbHlTaXplICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE1hcmsgdW51c2VkXG5cdFx0XHRmb3IgKCB2ID0gbWVzaC52SGVhZC5uZXh0OyB2ICE9PSBtZXNoLnZIZWFkOyB2ID0gdi5uZXh0IClcblx0XHRcdFx0di5uID0gLTE7XG5cblx0XHRcdC8vIENyZWF0ZSB1bmlxdWUgSURzIGZvciBhbGwgdmVydGljZXMgYW5kIGZhY2VzLlxuXHRcdFx0Zm9yICggZiA9IG1lc2guZkhlYWQubmV4dDsgZiAhPSBtZXNoLmZIZWFkOyBmID0gZi5uZXh0IClcblx0XHRcdHtcblx0XHRcdFx0Zi5uID0gLTE7XG5cdFx0XHRcdGlmKCAhZi5pbnNpZGUgKSBjb250aW51ZTtcblxuXHRcdFx0XHRlZGdlID0gZi5hbkVkZ2U7XG5cdFx0XHRcdGZhY2VWZXJ0cyA9IDA7XG5cdFx0XHRcdGRvXG5cdFx0XHRcdHtcblx0XHRcdFx0XHR2ID0gZWRnZS5Pcmc7XG5cdFx0XHRcdFx0aWYgKCB2Lm4gPT09IC0xIClcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHR2Lm4gPSBtYXhWZXJ0ZXhDb3VudDtcblx0XHRcdFx0XHRcdG1heFZlcnRleENvdW50Kys7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGZhY2VWZXJ0cysrO1xuXHRcdFx0XHRcdGVkZ2UgPSBlZGdlLkxuZXh0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHdoaWxlIChlZGdlICE9PSBmLmFuRWRnZSk7XG5cdFx0XHRcdFxuXHRcdFx0XHRhc3NlcnQoIGZhY2VWZXJ0cyA8PSBwb2x5U2l6ZSApO1xuXG5cdFx0XHRcdGYubiA9IG1heEZhY2VDb3VudDtcblx0XHRcdFx0KyttYXhGYWNlQ291bnQ7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuZWxlbWVudENvdW50ID0gbWF4RmFjZUNvdW50O1xuXHRcdFx0aWYgKGVsZW1lbnRUeXBlID09IFRlc3MyLkNPTk5FQ1RFRF9QT0xZR09OUylcblx0XHRcdFx0bWF4RmFjZUNvdW50ICo9IDI7XG5cdC8qXHRcdHRlc3MuZWxlbWVudHMgPSAoVEVTU2luZGV4Kil0ZXNzLT5hbGxvYy5tZW1hbGxvYyggdGVzcy0+YWxsb2MudXNlckRhdGEsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQgIHNpemVvZihURVNTaW5kZXgpICogbWF4RmFjZUNvdW50ICogcG9seVNpemUgKTtcblx0XHRcdGlmICghdGVzcy0+ZWxlbWVudHMpXG5cdFx0XHR7XG5cdFx0XHRcdHRlc3MtPm91dE9mTWVtb3J5ID0gMTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fSovXG5cdFx0XHR0aGlzLmVsZW1lbnRzID0gW107XG5cdFx0XHR0aGlzLmVsZW1lbnRzLmxlbmd0aCA9IG1heEZhY2VDb3VudCAqIHBvbHlTaXplO1xuXHRcdFx0XG5cdFx0XHR0aGlzLnZlcnRleENvdW50ID0gbWF4VmVydGV4Q291bnQ7XG5cdC8qXHRcdHRlc3MtPnZlcnRpY2VzID0gKFRFU1NyZWFsKil0ZXNzLT5hbGxvYy5tZW1hbGxvYyggdGVzcy0+YWxsb2MudXNlckRhdGEsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQgc2l6ZW9mKFRFU1NyZWFsKSAqIHRlc3MtPnZlcnRleENvdW50ICogdmVydGV4U2l6ZSApO1xuXHRcdFx0aWYgKCF0ZXNzLT52ZXJ0aWNlcylcblx0XHRcdHtcblx0XHRcdFx0dGVzcy0+b3V0T2ZNZW1vcnkgPSAxO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9Ki9cblx0XHRcdHRoaXMudmVydGljZXMgPSBbXTtcblx0XHRcdHRoaXMudmVydGljZXMubGVuZ3RoID0gbWF4VmVydGV4Q291bnQgKiB2ZXJ0ZXhTaXplO1xuXG5cdC8qXHRcdHRlc3MtPnZlcnRleEluZGljZXMgPSAoVEVTU2luZGV4Kil0ZXNzLT5hbGxvYy5tZW1hbGxvYyggdGVzcy0+YWxsb2MudXNlckRhdGEsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdCAgICBzaXplb2YoVEVTU2luZGV4KSAqIHRlc3MtPnZlcnRleENvdW50ICk7XG5cdFx0XHRpZiAoIXRlc3MtPnZlcnRleEluZGljZXMpXG5cdFx0XHR7XG5cdFx0XHRcdHRlc3MtPm91dE9mTWVtb3J5ID0gMTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fSovXG5cdFx0XHR0aGlzLnZlcnRleEluZGljZXMgPSBbXTtcblx0XHRcdHRoaXMudmVydGV4SW5kaWNlcy5sZW5ndGggPSBtYXhWZXJ0ZXhDb3VudDtcblxuXHRcdFx0XG5cdFx0XHQvLyBPdXRwdXQgdmVydGljZXMuXG5cdFx0XHRmb3IgKCB2ID0gbWVzaC52SGVhZC5uZXh0OyB2ICE9PSBtZXNoLnZIZWFkOyB2ID0gdi5uZXh0IClcblx0XHRcdHtcblx0XHRcdFx0aWYgKCB2Lm4gIT0gLTEgKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Ly8gU3RvcmUgY29vcmRpbmF0ZVxuXHRcdFx0XHRcdHZhciBpZHggPSB2Lm4gKiB2ZXJ0ZXhTaXplO1xuXHRcdFx0XHRcdHRoaXMudmVydGljZXNbaWR4KzBdID0gdi5jb29yZHNbMF07XG5cdFx0XHRcdFx0dGhpcy52ZXJ0aWNlc1tpZHgrMV0gPSB2LmNvb3Jkc1sxXTtcblx0XHRcdFx0XHRpZiAoIHZlcnRleFNpemUgPiAyIClcblx0XHRcdFx0XHRcdHRoaXMudmVydGljZXNbaWR4KzJdID0gdi5jb29yZHNbMl07XG5cdFx0XHRcdFx0Ly8gU3RvcmUgdmVydGV4IGluZGV4LlxuXHRcdFx0XHRcdHRoaXMudmVydGV4SW5kaWNlc1t2Lm5dID0gdi5pZHg7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gT3V0cHV0IGluZGljZXMuXG5cdFx0XHR2YXIgbmVsID0gMDtcblx0XHRcdGZvciAoIGYgPSBtZXNoLmZIZWFkLm5leHQ7IGYgIT09IG1lc2guZkhlYWQ7IGYgPSBmLm5leHQgKVxuXHRcdFx0e1xuXHRcdFx0XHRpZiAoICFmLmluc2lkZSApIGNvbnRpbnVlO1xuXHRcdFx0XHRcblx0XHRcdFx0Ly8gU3RvcmUgcG9seWdvblxuXHRcdFx0XHRlZGdlID0gZi5hbkVkZ2U7XG5cdFx0XHRcdGZhY2VWZXJ0cyA9IDA7XG5cdFx0XHRcdGRvXG5cdFx0XHRcdHtcblx0XHRcdFx0XHR2ID0gZWRnZS5Pcmc7XG5cdFx0XHRcdFx0dGhpcy5lbGVtZW50c1tuZWwrK10gPSB2Lm47XG5cdFx0XHRcdFx0ZmFjZVZlcnRzKys7XG5cdFx0XHRcdFx0ZWRnZSA9IGVkZ2UuTG5leHQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0d2hpbGUgKGVkZ2UgIT09IGYuYW5FZGdlKTtcblx0XHRcdFx0Ly8gRmlsbCB1bnVzZWQuXG5cdFx0XHRcdGZvciAoaSA9IGZhY2VWZXJ0czsgaSA8IHBvbHlTaXplOyArK2kpXG5cdFx0XHRcdFx0dGhpcy5lbGVtZW50c1tuZWwrK10gPSAtMTtcblxuXHRcdFx0XHQvLyBTdG9yZSBwb2x5Z29uIGNvbm5lY3Rpdml0eVxuXHRcdFx0XHRpZiAoIGVsZW1lbnRUeXBlID09IFRlc3MyLkNPTk5FQ1RFRF9QT0xZR09OUyApXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRlZGdlID0gZi5hbkVkZ2U7XG5cdFx0XHRcdFx0ZG9cblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHR0aGlzLmVsZW1lbnRzW25lbCsrXSA9IHRoaXMuZ2V0TmVpZ2hib3VyRmFjZV8oIGVkZ2UgKTtcblx0XHRcdFx0XHRcdGVkZ2UgPSBlZGdlLkxuZXh0O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR3aGlsZSAoZWRnZSAhPT0gZi5hbkVkZ2UpO1xuXHRcdFx0XHRcdC8vIEZpbGwgdW51c2VkLlxuXHRcdFx0XHRcdGZvciAoaSA9IGZhY2VWZXJ0czsgaSA8IHBvbHlTaXplOyArK2kpXG5cdFx0XHRcdFx0XHR0aGlzLmVsZW1lbnRzW25lbCsrXSA9IC0xO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHQvL1x0dm9pZCBPdXRwdXRDb250b3VycyggVEVTU3Rlc3NlbGF0b3IgKnRlc3MsIFRFU1NtZXNoICptZXNoLCBpbnQgdmVydGV4U2l6ZSApXG5cdFx0b3V0cHV0Q29udG91cnNfOiBmdW5jdGlvbiggbWVzaCwgdmVydGV4U2l6ZSApIHtcblx0XHRcdHZhciBmO1xuXHRcdFx0dmFyIGVkZ2U7XG5cdFx0XHR2YXIgc3RhcnQ7XG5cdFx0XHR2YXIgdmVydHM7XG5cdFx0XHR2YXIgZWxlbWVudHM7XG5cdFx0XHR2YXIgdmVydEluZHM7XG5cdFx0XHR2YXIgc3RhcnRWZXJ0ID0gMDtcblx0XHRcdHZhciB2ZXJ0Q291bnQgPSAwO1xuXG5cdFx0XHR0aGlzLnZlcnRleENvdW50ID0gMDtcblx0XHRcdHRoaXMuZWxlbWVudENvdW50ID0gMDtcblxuXHRcdFx0Zm9yICggZiA9IG1lc2guZkhlYWQubmV4dDsgZiAhPT0gbWVzaC5mSGVhZDsgZiA9IGYubmV4dCApXG5cdFx0XHR7XG5cdFx0XHRcdGlmICggIWYuaW5zaWRlICkgY29udGludWU7XG5cblx0XHRcdFx0c3RhcnQgPSBlZGdlID0gZi5hbkVkZ2U7XG5cdFx0XHRcdGRvXG5cdFx0XHRcdHtcblx0XHRcdFx0XHR0aGlzLnZlcnRleENvdW50Kys7XG5cdFx0XHRcdFx0ZWRnZSA9IGVkZ2UuTG5leHQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0d2hpbGUgKCBlZGdlICE9PSBzdGFydCApO1xuXG5cdFx0XHRcdHRoaXMuZWxlbWVudENvdW50Kys7XG5cdFx0XHR9XG5cblx0LypcdFx0dGVzcy0+ZWxlbWVudHMgPSAoVEVTU2luZGV4Kil0ZXNzLT5hbGxvYy5tZW1hbGxvYyggdGVzcy0+YWxsb2MudXNlckRhdGEsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQgIHNpemVvZihURVNTaW5kZXgpICogdGVzcy0+ZWxlbWVudENvdW50ICogMiApO1xuXHRcdFx0aWYgKCF0ZXNzLT5lbGVtZW50cylcblx0XHRcdHtcblx0XHRcdFx0dGVzcy0+b3V0T2ZNZW1vcnkgPSAxO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9Ki9cblx0XHRcdHRoaXMuZWxlbWVudHMgPSBbXTtcblx0XHRcdHRoaXMuZWxlbWVudHMubGVuZ3RoID0gdGhpcy5lbGVtZW50Q291bnQgKiAyO1xuXHRcdFx0XG5cdC8qXHRcdHRlc3MtPnZlcnRpY2VzID0gKFRFU1NyZWFsKil0ZXNzLT5hbGxvYy5tZW1hbGxvYyggdGVzcy0+YWxsb2MudXNlckRhdGEsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQgIHNpemVvZihURVNTcmVhbCkgKiB0ZXNzLT52ZXJ0ZXhDb3VudCAqIHZlcnRleFNpemUgKTtcblx0XHRcdGlmICghdGVzcy0+dmVydGljZXMpXG5cdFx0XHR7XG5cdFx0XHRcdHRlc3MtPm91dE9mTWVtb3J5ID0gMTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fSovXG5cdFx0XHR0aGlzLnZlcnRpY2VzID0gW107XG5cdFx0XHR0aGlzLnZlcnRpY2VzLmxlbmd0aCA9IHRoaXMudmVydGV4Q291bnQgKiB2ZXJ0ZXhTaXplO1xuXG5cdC8qXHRcdHRlc3MtPnZlcnRleEluZGljZXMgPSAoVEVTU2luZGV4Kil0ZXNzLT5hbGxvYy5tZW1hbGxvYyggdGVzcy0+YWxsb2MudXNlckRhdGEsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdCAgICBzaXplb2YoVEVTU2luZGV4KSAqIHRlc3MtPnZlcnRleENvdW50ICk7XG5cdFx0XHRpZiAoIXRlc3MtPnZlcnRleEluZGljZXMpXG5cdFx0XHR7XG5cdFx0XHRcdHRlc3MtPm91dE9mTWVtb3J5ID0gMTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fSovXG5cdFx0XHR0aGlzLnZlcnRleEluZGljZXMgPSBbXTtcblx0XHRcdHRoaXMudmVydGV4SW5kaWNlcy5sZW5ndGggPSB0aGlzLnZlcnRleENvdW50O1xuXG5cdFx0XHR2YXIgbnYgPSAwO1xuXHRcdFx0dmFyIG52aSA9IDA7XG5cdFx0XHR2YXIgbmVsID0gMDtcblx0XHRcdHN0YXJ0VmVydCA9IDA7XG5cblx0XHRcdGZvciAoIGYgPSBtZXNoLmZIZWFkLm5leHQ7IGYgIT09IG1lc2guZkhlYWQ7IGYgPSBmLm5leHQgKVxuXHRcdFx0e1xuXHRcdFx0XHRpZiAoICFmLmluc2lkZSApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdHZlcnRDb3VudCA9IDA7XG5cdFx0XHRcdHN0YXJ0ID0gZWRnZSA9IGYuYW5FZGdlO1xuXHRcdFx0XHRkb1xuXHRcdFx0XHR7XG5cdFx0XHRcdFx0dGhpcy52ZXJ0aWNlc1tudisrXSA9IGVkZ2UuT3JnLmNvb3Jkc1swXTtcblx0XHRcdFx0XHR0aGlzLnZlcnRpY2VzW252KytdID0gZWRnZS5PcmcuY29vcmRzWzFdO1xuXHRcdFx0XHRcdGlmICggdmVydGV4U2l6ZSA+IDIgKVxuXHRcdFx0XHRcdFx0dGhpcy52ZXJ0aWNlc1tudisrXSA9IGVkZ2UuT3JnLmNvb3Jkc1syXTtcblx0XHRcdFx0XHR0aGlzLnZlcnRleEluZGljZXNbbnZpKytdID0gZWRnZS5PcmcuaWR4O1xuXHRcdFx0XHRcdHZlcnRDb3VudCsrO1xuXHRcdFx0XHRcdGVkZ2UgPSBlZGdlLkxuZXh0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHdoaWxlICggZWRnZSAhPT0gc3RhcnQgKTtcblxuXHRcdFx0XHR0aGlzLmVsZW1lbnRzW25lbCsrXSA9IHN0YXJ0VmVydDtcblx0XHRcdFx0dGhpcy5lbGVtZW50c1tuZWwrK10gPSB2ZXJ0Q291bnQ7XG5cblx0XHRcdFx0c3RhcnRWZXJ0ICs9IHZlcnRDb3VudDtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0YWRkQ29udG91cjogZnVuY3Rpb24oIHNpemUsIHZlcnRpY2VzIClcblx0XHR7XG5cdFx0XHR2YXIgZTtcblx0XHRcdHZhciBpO1xuXG5cdFx0XHRpZiAoIHRoaXMubWVzaCA9PT0gbnVsbCApXG5cdFx0XHQgIFx0dGhpcy5tZXNoID0gbmV3IFRFU1NtZXNoKCk7XG5cdC8qXHQgXHRpZiAoIHRlc3MtPm1lc2ggPT0gTlVMTCApIHtcblx0XHRcdFx0dGVzcy0+b3V0T2ZNZW1vcnkgPSAxO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9Ki9cblxuXHRcdFx0aWYgKCBzaXplIDwgMiApXG5cdFx0XHRcdHNpemUgPSAyO1xuXHRcdFx0aWYgKCBzaXplID4gMyApXG5cdFx0XHRcdHNpemUgPSAzO1xuXG5cdFx0XHRlID0gbnVsbDtcblxuXHRcdFx0Zm9yKCBpID0gMDsgaSA8IHZlcnRpY2VzLmxlbmd0aDsgaSArPSBzaXplIClcblx0XHRcdHtcblx0XHRcdFx0aWYoIGUgPT0gbnVsbCApIHtcblx0XHRcdFx0XHQvKiBNYWtlIGEgc2VsZi1sb29wIChvbmUgdmVydGV4LCBvbmUgZWRnZSkuICovXG5cdFx0XHRcdFx0ZSA9IHRoaXMubWVzaC5tYWtlRWRnZSgpO1xuXHQvKlx0XHRcdFx0aWYgKCBlID09IE5VTEwgKSB7XG5cdFx0XHRcdFx0XHR0ZXNzLT5vdXRPZk1lbW9yeSA9IDE7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fSovXG5cdFx0XHRcdFx0dGhpcy5tZXNoLnNwbGljZSggZSwgZS5TeW0gKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvKiBDcmVhdGUgYSBuZXcgdmVydGV4IGFuZCBlZGdlIHdoaWNoIGltbWVkaWF0ZWx5IGZvbGxvdyBlXG5cdFx0XHRcdFx0KiBpbiB0aGUgb3JkZXJpbmcgYXJvdW5kIHRoZSBsZWZ0IGZhY2UuXG5cdFx0XHRcdFx0Ki9cblx0XHRcdFx0XHR0aGlzLm1lc2guc3BsaXRFZGdlKCBlICk7XG5cdFx0XHRcdFx0ZSA9IGUuTG5leHQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvKiBUaGUgbmV3IHZlcnRleCBpcyBub3cgZS0+T3JnLiAqL1xuXHRcdFx0XHRlLk9yZy5jb29yZHNbMF0gPSB2ZXJ0aWNlc1tpKzBdO1xuXHRcdFx0XHRlLk9yZy5jb29yZHNbMV0gPSB2ZXJ0aWNlc1tpKzFdO1xuXHRcdFx0XHRpZiAoIHNpemUgPiAyIClcblx0XHRcdFx0XHRlLk9yZy5jb29yZHNbMl0gPSB2ZXJ0aWNlc1tpKzJdO1xuXHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0ZS5PcmcuY29vcmRzWzJdID0gMC4wO1xuXHRcdFx0XHQvKiBTdG9yZSB0aGUgaW5zZXJ0aW9uIG51bWJlciBzbyB0aGF0IHRoZSB2ZXJ0ZXggY2FuIGJlIGxhdGVyIHJlY29nbml6ZWQuICovXG5cdFx0XHRcdGUuT3JnLmlkeCA9IHRoaXMudmVydGV4SW5kZXhDb3VudGVyKys7XG5cblx0XHRcdFx0LyogVGhlIHdpbmRpbmcgb2YgYW4gZWRnZSBzYXlzIGhvdyB0aGUgd2luZGluZyBudW1iZXIgY2hhbmdlcyBhcyB3ZVxuXHRcdFx0XHQqIGNyb3NzIGZyb20gdGhlIGVkZ2UnJ3MgcmlnaHQgZmFjZSB0byBpdHMgbGVmdCBmYWNlLiAgV2UgYWRkIHRoZVxuXHRcdFx0XHQqIHZlcnRpY2VzIGluIHN1Y2ggYW4gb3JkZXIgdGhhdCBhIENDVyBjb250b3VyIHdpbGwgYWRkICsxIHRvXG5cdFx0XHRcdCogdGhlIHdpbmRpbmcgbnVtYmVyIG9mIHRoZSByZWdpb24gaW5zaWRlIHRoZSBjb250b3VyLlxuXHRcdFx0XHQqL1xuXHRcdFx0XHRlLndpbmRpbmcgPSAxO1xuXHRcdFx0XHRlLlN5bS53aW5kaW5nID0gLTE7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHQvL1x0aW50IHRlc3NUZXNzZWxhdGUoIFRFU1N0ZXNzZWxhdG9yICp0ZXNzLCBpbnQgd2luZGluZ1J1bGUsIGludCBlbGVtZW50VHlwZSwgaW50IHBvbHlTaXplLCBpbnQgdmVydGV4U2l6ZSwgY29uc3QgVEVTU3JlYWwqIG5vcm1hbCApXG5cdFx0dGVzc2VsYXRlOiBmdW5jdGlvbiggd2luZGluZ1J1bGUsIGVsZW1lbnRUeXBlLCBwb2x5U2l6ZSwgdmVydGV4U2l6ZSwgbm9ybWFsICkge1xuXHRcdFx0dGhpcy52ZXJ0aWNlcyA9IFtdO1xuXHRcdFx0dGhpcy5lbGVtZW50cyA9IFtdO1xuXHRcdFx0dGhpcy52ZXJ0ZXhJbmRpY2VzID0gW107XG5cblx0XHRcdHRoaXMudmVydGV4SW5kZXhDb3VudGVyID0gMDtcblx0XHRcdFxuXHRcdFx0aWYgKG5vcm1hbClcblx0XHRcdHtcblx0XHRcdFx0dGhpcy5ub3JtYWxbMF0gPSBub3JtYWxbMF07XG5cdFx0XHRcdHRoaXMubm9ybWFsWzFdID0gbm9ybWFsWzFdO1xuXHRcdFx0XHR0aGlzLm5vcm1hbFsyXSA9IG5vcm1hbFsyXTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy53aW5kaW5nUnVsZSA9IHdpbmRpbmdSdWxlO1xuXG5cdFx0XHRpZiAodmVydGV4U2l6ZSA8IDIpXG5cdFx0XHRcdHZlcnRleFNpemUgPSAyO1xuXHRcdFx0aWYgKHZlcnRleFNpemUgPiAzKVxuXHRcdFx0XHR2ZXJ0ZXhTaXplID0gMztcblxuXHQvKlx0XHRpZiAoc2V0am1wKHRlc3MtPmVudikgIT0gMCkgeyBcblx0XHRcdFx0Ly8gY29tZSBiYWNrIGhlcmUgaWYgb3V0IG9mIG1lbW9yeVxuXHRcdFx0XHRyZXR1cm4gMDtcblx0XHRcdH0qL1xuXG5cdFx0XHRpZiAoIXRoaXMubWVzaClcblx0XHRcdHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHQvKiBEZXRlcm1pbmUgdGhlIHBvbHlnb24gbm9ybWFsIGFuZCBwcm9qZWN0IHZlcnRpY2VzIG9udG8gdGhlIHBsYW5lXG5cdFx0XHQqIG9mIHRoZSBwb2x5Z29uLlxuXHRcdFx0Ki9cblx0XHRcdHRoaXMucHJvamVjdFBvbHlnb25fKCk7XG5cblx0XHRcdC8qIHRlc3NDb21wdXRlSW50ZXJpb3IoIHRlc3MgKSBjb21wdXRlcyB0aGUgcGxhbmFyIGFycmFuZ2VtZW50IHNwZWNpZmllZFxuXHRcdFx0KiBieSB0aGUgZ2l2ZW4gY29udG91cnMsIGFuZCBmdXJ0aGVyIHN1YmRpdmlkZXMgdGhpcyBhcnJhbmdlbWVudFxuXHRcdFx0KiBpbnRvIHJlZ2lvbnMuICBFYWNoIHJlZ2lvbiBpcyBtYXJrZWQgXCJpbnNpZGVcIiBpZiBpdCBiZWxvbmdzXG5cdFx0XHQqIHRvIHRoZSBwb2x5Z29uLCBhY2NvcmRpbmcgdG8gdGhlIHJ1bGUgZ2l2ZW4gYnkgdGVzcy0+d2luZGluZ1J1bGUuXG5cdFx0XHQqIEVhY2ggaW50ZXJpb3IgcmVnaW9uIGlzIGd1YXJhbnRlZWQgYmUgbW9ub3RvbmUuXG5cdFx0XHQqL1xuXHRcdFx0U3dlZXAuY29tcHV0ZUludGVyaW9yKCB0aGlzICk7XG5cblx0XHRcdHZhciBtZXNoID0gdGhpcy5tZXNoO1xuXG5cdFx0XHQvKiBJZiB0aGUgdXNlciB3YW50cyBvbmx5IHRoZSBib3VuZGFyeSBjb250b3Vycywgd2UgdGhyb3cgYXdheSBhbGwgZWRnZXNcblx0XHRcdCogZXhjZXB0IHRob3NlIHdoaWNoIHNlcGFyYXRlIHRoZSBpbnRlcmlvciBmcm9tIHRoZSBleHRlcmlvci5cblx0XHRcdCogT3RoZXJ3aXNlIHdlIHRlc3NlbGxhdGUgYWxsIHRoZSByZWdpb25zIG1hcmtlZCBcImluc2lkZVwiLlxuXHRcdFx0Ki9cblx0XHRcdGlmIChlbGVtZW50VHlwZSA9PSBUZXNzMi5CT1VOREFSWV9DT05UT1VSUykge1xuXHRcdFx0XHR0aGlzLnNldFdpbmRpbmdOdW1iZXJfKCBtZXNoLCAxLCB0cnVlICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLnRlc3NlbGxhdGVJbnRlcmlvcl8oIG1lc2ggKTsgXG5cdFx0XHR9XG5cdC8vXHRcdGlmIChyYyA9PSAwKSBsb25nam1wKHRlc3MtPmVudiwxKTsgIC8qIGNvdWxkJ3ZlIHVzZWQgYSBsYWJlbCAqL1xuXG5cdFx0XHRtZXNoLmNoZWNrKCk7XG5cblx0XHRcdGlmIChlbGVtZW50VHlwZSA9PSBUZXNzMi5CT1VOREFSWV9DT05UT1VSUykge1xuXHRcdFx0XHR0aGlzLm91dHB1dENvbnRvdXJzXyggbWVzaCwgdmVydGV4U2l6ZSApOyAgICAgLyogb3V0cHV0IGNvbnRvdXJzICovXG5cdFx0XHR9XG5cdFx0XHRlbHNlXG5cdFx0XHR7XG5cdFx0XHRcdHRoaXMub3V0cHV0UG9seW1lc2hfKCBtZXNoLCBlbGVtZW50VHlwZSwgcG9seVNpemUsIHZlcnRleFNpemUgKTsgICAgIC8qIG91dHB1dCBwb2x5Z29ucyAqL1xuXHRcdFx0fVxuXG4vL1x0XHRcdHRlc3MubWVzaCA9IG51bGw7XG5cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0fTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHJhbmdlKG1pbiwgbWF4LCB2YWx1ZSkge1xuICByZXR1cm4gKHZhbHVlIC0gbWluKSAvIChtYXggLSBtaW4pXG59IiwibW9kdWxlLmV4cG9ydHM9cmVxdWlyZShcIi9wcm9qZWN0cy9ibGFja2ljZS9ub2RlX21vZHVsZXMvdGhyZWUtc2RmLXRleHQvbm9kZV9tb2R1bGVzL3h0ZW5kL2ltbXV0YWJsZS5qc1wiKSJdfQ==
