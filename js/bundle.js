(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({"./test.js":[function(require,module,exports){
var scene3d = require('./')

require('domready')(function() {
    document.body.style.margin = '0'
    document.body.style.overflow = 'hidden'

    //your canvas...
    var canvas = document.createElement('canvas')
    canvas.style.display = 'block'
    document.body.appendChild(canvas)

    var app = scene3d({ 
        canvas: canvas
    })

    app.load(function(err) {
        if (err)
            console.error(err)
        app.start()
    })
})
},{"./":"/projects/blackice/index.js","domready":"/projects/blackice/node_modules/domready/ready.js"}],"/projects/blackice/fonts/Exo2SemiBold.json":[function(require,module,exports){
module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports={"pages":["Exo2SemiBold.png"],"chars":[{"id":32,"x":0,"y":0,"width":0,"height":0,"xoffset":0,"yoffset":33,"xadvance":7,"page":0,"chnl":0},{"id":41,"x":0,"y":0,"width":20,"height":41,"xoffset":-4,"yoffset":3,"xadvance":12,"page":0,"chnl":0},{"id":40,"x":20,"y":0,"width":19,"height":41,"xoffset":-3,"yoffset":3,"xadvance":12,"page":0,"chnl":0},{"id":124,"x":39,"y":0,"width":13,"height":40,"xoffset":-2,"yoffset":3,"xadvance":8,"page":0,"chnl":0},{"id":125,"x":52,"y":0,"width":18,"height":40,"xoffset":-3,"yoffset":4,"xadvance":11,"page":0,"chnl":0},{"id":123,"x":70,"y":0,"width":18,"height":40,"xoffset":-3,"yoffset":4,"xadvance":11,"page":0,"chnl":0},{"id":36,"x":88,"y":0,"width":25,"height":39,"xoffset":-3,"yoffset":3,"xadvance":18,"page":0,"chnl":0},{"id":93,"x":113,"y":0,"width":17,"height":39,"xoffset":-3,"yoffset":4,"xadvance":11,"page":0,"chnl":0},{"id":91,"x":130,"y":0,"width":17,"height":39,"xoffset":-2,"yoffset":4,"xadvance":11,"page":0,"chnl":0},{"id":81,"x":147,"y":0,"width":28,"height":39,"xoffset":-3,"yoffset":6,"xadvance":22,"page":0,"chnl":0},{"id":106,"x":175,"y":0,"width":16,"height":38,"xoffset":-4,"yoffset":6,"xadvance":9,"page":0,"chnl":0},{"id":92,"x":191,"y":0,"width":26,"height":34,"xoffset":-4,"yoffset":6,"xadvance":17,"page":0,"chnl":0},{"id":47,"x":217,"y":0,"width":26,"height":34,"xoffset":-4,"yoffset":6,"xadvance":17,"page":0,"chnl":0},{"id":102,"x":243,"y":0,"width":23,"height":33,"xoffset":-4,"yoffset":5,"xadvance":13,"page":0,"chnl":0},{"id":38,"x":266,"y":0,"width":32,"height":32,"xoffset":-3,"yoffset":6,"xadvance":25,"page":0,"chnl":0},{"id":35,"x":298,"y":0,"width":30,"height":32,"xoffset":-3,"yoffset":6,"xadvance":22,"page":0,"chnl":0},{"id":37,"x":328,"y":0,"width":36,"height":32,"xoffset":-3,"yoffset":6,"xadvance":29,"page":0,"chnl":0},{"id":63,"x":364,"y":0,"width":24,"height":32,"xoffset":-3,"yoffset":6,"xadvance":16,"page":0,"chnl":0},{"id":33,"x":388,"y":0,"width":14,"height":32,"xoffset":-2,"yoffset":6,"xadvance":9,"page":0,"chnl":0},{"id":48,"x":402,"y":0,"width":26,"height":32,"xoffset":-3,"yoffset":6,"xadvance":20,"page":0,"chnl":0},{"id":57,"x":428,"y":0,"width":25,"height":32,"xoffset":-3,"yoffset":6,"xadvance":19,"page":0,"chnl":0},{"id":56,"x":453,"y":0,"width":26,"height":32,"xoffset":-3,"yoffset":6,"xadvance":20,"page":0,"chnl":0},{"id":55,"x":479,"y":0,"width":24,"height":32,"xoffset":-3,"yoffset":6,"xadvance":17,"page":0,"chnl":0},{"id":54,"x":0,"y":41,"width":26,"height":32,"xoffset":-3,"yoffset":6,"xadvance":19,"page":0,"chnl":0},{"id":53,"x":26,"y":41,"width":24,"height":32,"xoffset":-3,"yoffset":6,"xadvance":17,"page":0,"chnl":0},{"id":52,"x":50,"y":41,"width":27,"height":32,"xoffset":-3,"yoffset":6,"xadvance":20,"page":0,"chnl":0},{"id":51,"x":77,"y":41,"width":25,"height":32,"xoffset":-3,"yoffset":6,"xadvance":18,"page":0,"chnl":0},{"id":50,"x":102,"y":41,"width":25,"height":32,"xoffset":-3,"yoffset":6,"xadvance":18,"page":0,"chnl":0},{"id":49,"x":127,"y":41,"width":19,"height":32,"xoffset":-4,"yoffset":6,"xadvance":13,"page":0,"chnl":0},{"id":121,"x":146,"y":41,"width":27,"height":32,"xoffset":-4,"yoffset":12,"xadvance":17,"page":0,"chnl":0},{"id":113,"x":173,"y":41,"width":25,"height":32,"xoffset":-3,"yoffset":12,"xadvance":19,"page":0,"chnl":0},{"id":112,"x":198,"y":41,"width":25,"height":32,"xoffset":-2,"yoffset":12,"xadvance":19,"page":0,"chnl":0},{"id":108,"x":223,"y":41,"width":17,"height":32,"xoffset":-2,"yoffset":6,"xadvance":10,"page":0,"chnl":0},{"id":107,"x":240,"y":41,"width":24,"height":32,"xoffset":-2,"yoffset":6,"xadvance":17,"page":0,"chnl":0},{"id":105,"x":264,"y":41,"width":14,"height":32,"xoffset":-2,"yoffset":6,"xadvance":8,"page":0,"chnl":0},{"id":104,"x":278,"y":41,"width":24,"height":32,"xoffset":-2,"yoffset":6,"xadvance":19,"page":0,"chnl":0},{"id":103,"x":302,"y":41,"width":27,"height":32,"xoffset":-4,"yoffset":12,"xadvance":18,"page":0,"chnl":0},{"id":100,"x":329,"y":41,"width":25,"height":32,"xoffset":-3,"yoffset":6,"xadvance":19,"page":0,"chnl":0},{"id":98,"x":354,"y":41,"width":25,"height":32,"xoffset":-2,"yoffset":6,"xadvance":19,"page":0,"chnl":0},{"id":90,"x":379,"y":41,"width":25,"height":32,"xoffset":-3,"yoffset":6,"xadvance":18,"page":0,"chnl":0},{"id":89,"x":404,"y":41,"width":28,"height":32,"xoffset":-4,"yoffset":6,"xadvance":19,"page":0,"chnl":0},{"id":88,"x":432,"y":41,"width":29,"height":32,"xoffset":-4,"yoffset":6,"xadvance":20,"page":0,"chnl":0},{"id":87,"x":461,"y":41,"width":39,"height":32,"xoffset":-4,"yoffset":6,"xadvance":31,"page":0,"chnl":0},{"id":86,"x":0,"y":73,"width":29,"height":32,"xoffset":-4,"yoffset":6,"xadvance":20,"page":0,"chnl":0},{"id":85,"x":29,"y":73,"width":27,"height":32,"xoffset":-2,"yoffset":6,"xadvance":21,"page":0,"chnl":0},{"id":84,"x":56,"y":73,"width":28,"height":32,"xoffset":-4,"yoffset":6,"xadvance":19,"page":0,"chnl":0},{"id":83,"x":84,"y":73,"width":25,"height":32,"xoffset":-3,"yoffset":6,"xadvance":18,"page":0,"chnl":0},{"id":82,"x":109,"y":73,"width":26,"height":32,"xoffset":-2,"yoffset":6,"xadvance":20,"page":0,"chnl":0},{"id":80,"x":135,"y":73,"width":26,"height":32,"xoffset":-2,"yoffset":6,"xadvance":19,"page":0,"chnl":0},{"id":79,"x":161,"y":73,"width":28,"height":32,"xoffset":-3,"yoffset":6,"xadvance":22,"page":0,"chnl":0},{"id":78,"x":189,"y":73,"width":28,"height":32,"xoffset":-2,"yoffset":6,"xadvance":23,"page":0,"chnl":0},{"id":77,"x":217,"y":73,"width":34,"height":32,"xoffset":-2,"yoffset":6,"xadvance":29,"page":0,"chnl":0},{"id":76,"x":251,"y":73,"width":24,"height":32,"xoffset":-2,"yoffset":6,"xadvance":17,"page":0,"chnl":0},{"id":75,"x":275,"y":73,"width":27,"height":32,"xoffset":-2,"yoffset":6,"xadvance":20,"page":0,"chnl":0},{"id":74,"x":302,"y":73,"width":18,"height":32,"xoffset":-4,"yoffset":6,"xadvance":11,"page":0,"chnl":0},{"id":73,"x":320,"y":73,"width":14,"height":32,"xoffset":-2,"yoffset":6,"xadvance":9,"page":0,"chnl":0},{"id":72,"x":334,"y":73,"width":27,"height":32,"xoffset":-2,"yoffset":6,"xadvance":22,"page":0,"chnl":0},{"id":71,"x":361,"y":73,"width":27,"height":32,"xoffset":-3,"yoffset":6,"xadvance":20,"page":0,"chnl":0},{"id":70,"x":388,"y":73,"width":24,"height":32,"xoffset":-2,"yoffset":6,"xadvance":17,"page":0,"chnl":0},{"id":69,"x":412,"y":73,"width":24,"height":32,"xoffset":-2,"yoffset":6,"xadvance":18,"page":0,"chnl":0},{"id":68,"x":436,"y":73,"width":27,"height":32,"xoffset":-2,"yoffset":6,"xadvance":21,"page":0,"chnl":0},{"id":67,"x":463,"y":73,"width":26,"height":32,"xoffset":-3,"yoffset":6,"xadvance":19,"page":0,"chnl":0},{"id":66,"x":0,"y":105,"width":26,"height":32,"xoffset":-2,"yoffset":6,"xadvance":20,"page":0,"chnl":0},{"id":65,"x":26,"y":105,"width":30,"height":32,"xoffset":-4,"yoffset":6,"xadvance":20,"page":0,"chnl":0},{"id":64,"x":56,"y":105,"width":29,"height":31,"xoffset":-2,"yoffset":9,"xadvance":24,"page":0,"chnl":0},{"id":116,"x":85,"y":105,"width":22,"height":30,"xoffset":-4,"yoffset":8,"xadvance":13,"page":0,"chnl":0},{"id":59,"x":107,"y":105,"width":14,"height":29,"xoffset":-2,"yoffset":14,"xadvance":8,"page":0,"chnl":0},{"id":122,"x":121,"y":105,"width":24,"height":26,"xoffset":-3,"yoffset":12,"xadvance":17,"page":0,"chnl":0},{"id":120,"x":145,"y":105,"width":26,"height":26,"xoffset":-4,"yoffset":12,"xadvance":17,"page":0,"chnl":0},{"id":119,"x":171,"y":105,"width":36,"height":26,"xoffset":-4,"yoffset":12,"xadvance":27,"page":0,"chnl":0},{"id":118,"x":207,"y":105,"width":27,"height":26,"xoffset":-4,"yoffset":12,"xadvance":17,"page":0,"chnl":0},{"id":117,"x":234,"y":105,"width":24,"height":26,"xoffset":-2,"yoffset":12,"xadvance":19,"page":0,"chnl":0},{"id":115,"x":258,"y":105,"width":24,"height":26,"xoffset":-3,"yoffset":12,"xadvance":17,"page":0,"chnl":0},{"id":114,"x":282,"y":105,"width":20,"height":26,"xoffset":-2,"yoffset":12,"xadvance":13,"page":0,"chnl":0},{"id":111,"x":302,"y":105,"width":25,"height":26,"xoffset":-3,"yoffset":12,"xadvance":18,"page":0,"chnl":0},{"id":110,"x":327,"y":105,"width":24,"height":26,"xoffset":-2,"yoffset":12,"xadvance":19,"page":0,"chnl":0},{"id":109,"x":351,"y":105,"width":33,"height":26,"xoffset":-2,"yoffset":12,"xadvance":28,"page":0,"chnl":0},{"id":101,"x":384,"y":105,"width":25,"height":26,"xoffset":-3,"yoffset":12,"xadvance":18,"page":0,"chnl":0},{"id":99,"x":409,"y":105,"width":23,"height":26,"xoffset":-3,"yoffset":12,"xadvance":16,"page":0,"chnl":0},{"id":97,"x":432,"y":105,"width":24,"height":26,"xoffset":-3,"yoffset":12,"xadvance":18,"page":0,"chnl":0},{"id":43,"x":456,"y":105,"width":24,"height":24,"xoffset":-3,"yoffset":11,"xadvance":17,"page":0,"chnl":0},{"id":62,"x":480,"y":105,"width":23,"height":24,"xoffset":-2,"yoffset":12,"xadvance":17,"page":0,"chnl":0},{"id":60,"x":0,"y":137,"width":23,"height":24,"xoffset":-3,"yoffset":12,"xadvance":17,"page":0,"chnl":0},{"id":58,"x":23,"y":137,"width":14,"height":24,"xoffset":-3,"yoffset":14,"xadvance":8,"page":0,"chnl":0},{"id":42,"x":37,"y":137,"width":21,"height":21,"xoffset":-3,"yoffset":6,"xadvance":14,"page":0,"chnl":0},{"id":61,"x":58,"y":137,"width":24,"height":20,"xoffset":-2,"yoffset":13,"xadvance":19,"page":0,"chnl":0},{"id":94,"x":82,"y":137,"width":23,"height":19,"xoffset":-4,"yoffset":8,"xadvance":14,"page":0,"chnl":0},{"id":44,"x":105,"y":137,"width":14,"height":19,"xoffset":-3,"yoffset":24,"xadvance":8,"page":0,"chnl":0},{"id":39,"x":119,"y":137,"width":13,"height":17,"xoffset":-3,"yoffset":6,"xadvance":7,"page":0,"chnl":0},{"id":96,"x":132,"y":137,"width":18,"height":17,"xoffset":-4,"yoffset":5,"xadvance":11,"page":0,"chnl":0},{"id":34,"x":150,"y":137,"width":18,"height":17,"xoffset":-3,"yoffset":6,"xadvance":12,"page":0,"chnl":0},{"id":126,"x":168,"y":137,"width":22,"height":14,"xoffset":-2,"yoffset":17,"xadvance":17,"page":0,"chnl":0},{"id":46,"x":190,"y":137,"width":14,"height":14,"xoffset":-3,"yoffset":24,"xadvance":8,"page":0,"chnl":0},{"id":95,"x":204,"y":137,"width":24,"height":13,"xoffset":-2,"yoffset":28,"xadvance":18,"page":0,"chnl":0},{"id":45,"x":228,"y":137,"width":19,"height":13,"xoffset":-2,"yoffset":18,"xadvance":14,"page":0,"chnl":0}],"kernings":[],"info":{"face":"Exo 2 Semi Bold","size":32,"bold":0,"italic":0,"charset":"","unicode":0,"stretchH":100,"smooth":1,"aa":1,"padding":[4,4,4,4],"spacing":[-8,-8]},"common":{"lineHeight":40,"base":33,"scaleW":512,"scaleH":512,"pages":1,"packed":0}}
},{}],"/projects/blackice/index.js":[function(require,module,exports){
(function (global){
require('raf.js')

var THREE = (typeof window !== "undefined" ? window.THREE : typeof global !== "undefined" ? global.THREE : null)
var Renderer = require('./lib/renderer')
var createFont = require('./lib/create-font')
var xtend = require('xtend')

module.exports = function(opt) {
    opt = opt||{}
    var app = require('canvas-app')(render, xtend({
        context: 'webgl',
        contextAttributes: { antialias: false, alpha: false },
        retina: true,
        onResize: handleResize
    }, opt))

    
    var renderer

    app.load = function(cb) {
        cb = cb || function() {}
        var gl = app.context
        createFont(gl, function(err, font) {
            renderer = Renderer({
                gl: gl, 
                width: app.width, 
                height: app.height,
                font: font
            })
            cb(err)
        })
    }

    return app

    function render(gl, width, height, dt) {
        if (renderer)
            renderer.draw(dt)
    }

    function handleResize(width, height) {
        if (renderer)
            renderer.resize(width, height)
    }

    function setupSmoothTex(gl, t) {
        t.minFilter = gl.LINEAR_MIPMAP_LINEAR
        t.magFilter = gl.LINEAR

        var ext = (gl.getExtension('EXT_texture_filter_anisotropic') 
                        || gl.getExtension("MOZ_EXT_texture_filter_anisotropic"));
        if (ext) {
            var maxAnistrophy = gl.getParameter(ext.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
            gl.texParameterf(gl.TEXTURE_2D, ext.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(16, maxAnistrophy));
        }

        t.generateMipmap()
    }

    function setupNearestTex(gl, t) {
        t.minFilter = t.magFilter = gl.NEAREST
    }
}
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./lib/create-font":"/projects/blackice/lib/create-font.js","./lib/renderer":"/projects/blackice/lib/renderer.js","canvas-app":"/projects/blackice/node_modules/canvas-app/index.js","raf.js":"/projects/blackice/node_modules/raf.js/raf.js","xtend":"/projects/blackice/node_modules/xtend/immutable.js"}],"/projects/blackice/lib/RigScene.js":[function(require,module,exports){
(function (global){
var THREE = (typeof window !== "undefined" ? window.THREE : typeof global !== "undefined" ? global.THREE : null)
var inherits = require('inherits')
var mixes = require('mixes')
var Base = THREE.Scene

var YOFF = 2.5

function RigScene(opt) {
    if (!(this instanceof RigScene))
        return new RigScene(opt)
    Base.call(this)
    this.fog = new THREE.FogExp2( 0x0b0516, 0.00015 );


    // var box = new THREE.Mesh(
    //     new THREE.BoxGeometry(20, 20, 10),
    //     new THREE.MeshBasicMaterial({ color: 0xaaaaaa, wireframe: false })
    // )

    // this.add(box)


    this.time = 0
    this.cubeMap = null
    this.updateMaterial()

    var loader = new THREE.OBJMTLLoader()
    loader.load('model/Prirazlomnayawithpipes3.obj', 'model/Prirazlomnayawithpipes3.mtl', function(object, materials) {
        var s = 0.3
        console.log(object, materials)
        object.scale.set(s,s,s)
        object.position.y -= YOFF
        this.mesh = object

        this.mesh.traverse(function(obj) {
            if (obj instanceof THREE.Mesh) {
                obj.castShadow = true
                obj.receiveShadow = true
                obj.material.shininess = 1
                if (obj.material.map) {
                    obj.material.transparent = true
                }
                // console.log(obj.material.uniforms)
            }
        })

        this.add(object)
    }.bind(this))
    

    // var geometry = new THREE.TorusKnotGeometry( 10, 3, 100, 16 );
    // var material = new THREE.MeshBasicMaterial( { color: 0xffff00 } );
    // var torusKnot = new THREE.Mesh( geometry, material );
    // this.add( torusKnot );
    // torusKnot.castShadow = true
    // torusKnot.receiveShadow = true

    this.lights = [
        [ new THREE.Vector3(-10, 20, -20), 1 ],
        [ new THREE.Vector3(15, 10, 15), 0.5 ]
    ].map(function(args, i) {
        var light = new THREE.DirectionalLight( 0xddf4fd, args[1] )
        light.position.copy(args[0])
        light.castShadow = true
        light.shadowMapWidth = 1024
        light.shadowMapHeight = 1024
        light.shadowCameraNear = 1
        light.shadowCameraFar = 100

        // light.helper = new THREE.DirectionalLightHelper(light, 4)
        // this.add(light.helper)
        this.add(light)
        return light
    },this)
}

inherits(RigScene, Base)

mixes(RigScene, {

    updateMaterial: function() {
        this.material = new THREE.MeshLambertMaterial({
            color: 0xaaaaaa,
            reflectivity: 0.4,
            envMap: this.cubeMap
        })

    },

    update: function(dt) {
        this.time += Math.min(dt, 30)/1000
        var m = this.mesh
        if (!m)
            return
        var anim = Math.sin(this.time)

        // this.lights.forEach(function(light) { light.helper.update() })
        // m.position.y = YOFF + anim*0.2
        // m.position.x = Math.sin(this.time*0.1)*0.05
        // m.position.z = Math.sin(this.time*0.2)*0.1
        // m.rotation.x = anim*0.03
        // m.rotation.y = Math.sin(this.time*Math.cos(this.time*0.1))*0.005
    }
})

module.exports = RigScene
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"inherits":"/projects/blackice/node_modules/inherits/inherits_browser.js","mixes":"/projects/blackice/node_modules/mixes/index.js"}],"/projects/blackice/lib/TextPass.js":[function(require,module,exports){
(function (global){
var THREE = (typeof window !== "undefined" ? window.THREE : typeof global !== "undefined" ? global.THREE : null);
var EffectComposer = require("three-effectcomposer")(THREE);
var inherits = require("inherits");
var Base = EffectComposer.RenderPass;
var plucker = require("plucker");
var number = require("as-number");
var TextElement = require("three-sdf-text")(THREE);
var xtend = require("xtend");
var UNIT_SCALE = 0.1;
var SCALE = [UNIT_SCALE, UNIT_SCALE, UNIT_SCALE];

var mat4 = {
    scale: require("gl-mat4/scale"),
    identity: require("gl-mat4/identity"),
    multiply: require("gl-mat4/multiply"),
    translate: require("gl-mat4/translate")
};

var setVec3 = require("gl-vec3/set");
var tmpVec3 = [0, 0, 0];
var pluckPanels = plucker("panels");
var glslify = require("glslify");
var createSDFShader = require("glslify/adapter.js")("\n#define GLSLIFY 1\n\nattribute vec4 position;\nattribute vec4 color;\nattribute vec2 texcoord0;\nuniform mat4 projection;\nuniform mat4 view;\nuniform mat4 model;\nvarying vec4 v_col;\nvarying vec2 v_tex0;\nvarying float animOffset;\nvoid main() {\n  gl_Position = projection * view * model * position;\n  v_col = color;\n  v_tex0 = texcoord0;\n  gl_PointSize = 1.0;\n  animOffset = position.x / 100.0;\n}", "\n#define GLSLIFY 1\n\n#ifdef GL_ES\n\nprecision mediump float;\n#endif\n\nvarying vec4 v_col;\nvarying vec2 v_tex0;\nvarying float animOffset;\nuniform sampler2D texture0;\nuniform sampler2D texture1;\nuniform float smoothing;\nuniform float fade;\nconst vec2 shadowOffset = vec2(-1.0 / 512.0);\nconst vec4 glowColor = vec4(vec3(0.1), 1.0);\nconst float glowMin = 0.4;\nconst float glowMax = 0.8;\nvoid main() {\n  float anim = fade * animOffset;\n  anim = clamp(mix(anim, 1.0, fade * fade), 0.0, 1.0);\n  vec4 smoothColor = vec4(0.0);\n  vec4 texColor = texture2D(texture0, v_tex0);\n  float dst = texColor.a;\n  float smoothAmt = mix(1.5, smoothing, anim);\n  float alpha = smoothstep(0.5 - smoothAmt, 0.5 + smoothAmt, dst);\n  vec4 base = v_col * vec4(alpha);\n  float glowDst = texture2D(texture0, v_tex0 + shadowOffset).a;\n  vec4 glow = glowColor * smoothstep(glowMin, glowMax, glowDst);\n  float mask = 1.0 - alpha;\n  gl_FragColor = mix(vec4(0.0), base, anim);\n  if(gl_FragColor.a < 0.1)\n    discard;\n  \n}", [{"name":"projection","type":"mat4"},{"name":"view","type":"mat4"},{"name":"model","type":"mat4"},{"name":"texture0","type":"sampler2D"},{"name":"texture1","type":"sampler2D"},{"name":"smoothing","type":"float"},{"name":"fade","type":"float"}], [{"name":"position","type":"vec4"},{"name":"color","type":"vec4"},{"name":"texcoord0","type":"vec2"}]);
var sdfShader;

function TextPass(opt) {
    if (!(this instanceof TextPass))
        return new TextPass(opt);

    opt = opt || {};
    var renderer = opt.renderer;
    var camera = opt.camera;
    var scene = opt.scene;
    Base.call(this, scene, camera);
    var font = opt.font;

    if (!sdfShader)
        sdfShader = createSDFShader(renderer.getContext());

    this.groups = (opt.groups || []).map(createGroups(renderer, font));
    window.groups = this.groups;
}

function createGroups(renderer, font) {
    return function(group, groupIndex) {
        group.elements = group.panels.map(function(panel, index) {
            var side = (index === 0 ? 1 : -1);

            return panel.labels.map(function(label) {
                return createElement(label, side, renderer, font);
            });
        }).reduce(function(prev, b) {
            return prev.concat(b);
        }, []);

        group._opacity = 1;
        group.fade = 1;
        group.showing = true;
        group.animatingOut = false;

        Object.defineProperty(group, "opacity", {
            get: function() {
                return group._opacity;
            },

            set: function(val) {
                group._opacity = val;

                group.elements.forEach(function(e) {
                    e.text.opacity = val;
                });

                group.panels.forEach(function(p) {
                    p.container.visible = val > 0.01;

                    p.shapes.forEach(function(shape) {
                        shape.material.opacity = val;
                        shape.visible = val > 0.01;
                    });
                });
            }
        });

        return group;
    };
}

function createElement(label, side, renderer, font) {
    var textOpt = xtend(label, {
        font: font,
        textures: font.textures,
        shader: sdfShader
    });

    var textEl = TextElement(renderer, textOpt);

    return xtend(label, {
        text: textEl,
        side: side
    });
}

function renderElement(camera, e, fade) {
    e.object3d.updateMatrixWorld(true);
    var transform = e.text.transform;
    mat4.identity(transform);
    mat4.scale(transform, transform, SCALE);
    setVec3(tmpVec3, e.translation[0], e.translation[1], e.translation[2]);
    mat4.translate(transform, transform, tmpVec3);
    setVec3(tmpVec3, e.size, e.size, e.size);
    mat4.scale(transform, transform, tmpVec3);
    e.text.shader.bind();
    e.text.shader.uniforms.fade = fade;
    e.text.draw(camera, e.object3d);
}

inherits(TextPass, Base);

TextPass.prototype.render = function(renderer, writeBuffer, readBuffer, delta) {
    Base.prototype.render.call(this, renderer, writeBuffer, readBuffer, delta);
    var camera = this.camera;

    this.groups.forEach(function(g) {
        g.elements.forEach(function(e) {
            if (!g.showing)
                return;

            renderElement(camera, e, g.fade);
        });
    });

    renderer.resetGLState();
    renderer.resetAttributes();
};

module.exports = TextPass;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"as-number":"/projects/blackice/node_modules/as-number/index.js","gl-mat4/identity":"/projects/blackice/node_modules/gl-mat4/identity.js","gl-mat4/multiply":"/projects/blackice/node_modules/gl-mat4/multiply.js","gl-mat4/scale":"/projects/blackice/node_modules/gl-mat4/scale.js","gl-mat4/translate":"/projects/blackice/node_modules/gl-mat4/translate.js","gl-vec3/set":"/projects/blackice/node_modules/gl-vec3/set.js","glslify":"/projects/blackice/node_modules/glslify/browser.js","glslify/adapter.js":"/projects/blackice/node_modules/glslify/adapter.js","inherits":"/projects/blackice/node_modules/inherits/inherits_browser.js","plucker":"/projects/blackice/node_modules/plucker/index.js","three-effectcomposer":"/projects/blackice/node_modules/three-effectcomposer/index.js","three-sdf-text":"/projects/blackice/node_modules/three-sdf-text/index.js","xtend":"/projects/blackice/node_modules/xtend/immutable.js"}],"/projects/blackice/lib/animate-labels.js":[function(require,module,exports){
(function (global){
var TweenMax = (typeof window !== "undefined" ? window.TweenMax : typeof global !== "undefined" ? global.TweenMax : null)
var clamp = require('clamp')
var smoothstep = require('smoothstep')

var lastIndex = -1

module.exports = function(controller, labels) {
    var closeIndex = closest(controller, labels)

    // console.log(controller.theta)
    labels.forEach(function(label, i) {
        // setShowing(label, true)
        var visible = i===closeIndex
        if (visible && !label.showing) {
            animateInFeature(label)
        } else if (!visible && label.showing) {
            animateOutFeature(label)
        }
    })
}

module.exports.hideAll = function(features) {
    features.forEach(function(f) {
        setShowing(f, false)
    })
}

function distance(controller, label) {
    //signed distance
    var x = -label.theta, 
        y = controller.theta

    var abdist = Math.abs(x - y)
    return Math.min((2 * Math.PI) - abdist, abdist)

}

function closest(controller, labels) {
    var minDist = Number.MAX_VALUE
    var ret = -1
    labels.forEach(function(label, index) {
        var dist = distance(controller, label)
        
        if (dist < minDist) {
            minDist = dist
            ret = index
        }
    })
    return ret
}

function setShowing(feature, showing) {
    feature.showing = showing
}

function animateInFeature(feature) {
    feature.showing = true
    feature.fade = 0
    TweenMax.killTweensOf(feature)
    TweenMax.to(feature, 0.5, {
        fade: 1.0,
        ease: "easeOutQuad"
    })
}

function animateOutFeature(feature) {
    if (feature.animatingOut)
        return

    feature.animatingOut = true
    TweenMax.to(feature, 0.5, {
        fade: 0,
        ease: 'easeOutQuad',
        onComplete: hideFeature.bind(null, feature)
    })
}

function hideFeature(feature) {
    feature.animatingOut = false
    feature.showing = false
}
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"clamp":"/projects/blackice/node_modules/clamp/index.js","smoothstep":"/projects/blackice/node_modules/smoothstep/index.js"}],"/projects/blackice/lib/create-font.js":[function(require,module,exports){
var Font = require('../fonts/Exo2SemiBold.json')
var fontImage = 'fonts/Exo2SemiBold.png'
var img = require('img')
var createTexture = require('gl-texture2d')

module.exports = function(gl, cb) {
    img(fontImage, function(err, res) {
        if (err) {
            cb(err)
            return
        }

        Font.textures = [res].map(function(i) {
            var t = createTexture(gl, i)

            t.minFilter = gl.LINEAR_MIPMAP_LINEAR
            t.magFilter = gl.LINEAR

            var ext = (gl.getExtension('EXT_texture_filter_anisotropic') 
                            || gl.getExtension("MOZ_EXT_texture_filter_anisotropic"));
            if (ext) {
                var maxAnistrophy = gl.getParameter(ext.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
                gl.texParameterf(gl.TEXTURE_2D, ext.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(16, maxAnistrophy));
            }

            t.generateMipmap()
            return t
        })
        
        cb(null, Font)
    })
}
},{"../fonts/Exo2SemiBold.json":"/projects/blackice/fonts/Exo2SemiBold.json","gl-texture2d":"/projects/blackice/node_modules/gl-texture2d/texture.js","img":"/projects/blackice/node_modules/img/index.js"}],"/projects/blackice/lib/create-text-pass.js":[function(require,module,exports){
(function (global){
var TextPass = require('./TextPass')
var THREE = (typeof window !== "undefined" ? window.THREE : typeof global !== "undefined" ? global.THREE : null)
var xtend = require('xtend')
var getSVG = require('./get-svg')
var getPoly = require('./get-polygon')
var Complex = require('three-simplicial-complex')(THREE)

var UNIT_SCALE = 0.1

var data = require('./text-data')

module.exports = function(opt) {
    var groups = createGroups()
    
    groups.forEach(function(group) {
        // var len = 100
        // var dir = new THREE.Vector3(Math.cos(group.theta), 0, Math.sin(group.theta))
        // var arrow = new THREE.ArrowHelper(dir, new THREE.Vector3(), len)
        // opt.scene.add(arrow)

        group.panels.forEach(function(panel) {
            opt.scene.add(panel.container)
        })
    })

    return TextPass(xtend(opt, {
        groups: groups
    }))
}

function createGroups() {
    return data.map(function(group, i, list) {
        var theta = i/(list.length+1) * Math.PI * 2
        group = xtend(group, {
            panels: group.panels.map(function(panel, index) {
                return createPanel(panel, index, theta)
            }),
            theta: theta
        })
        return group
    })
}

function createPanel(data, index, rotation) {
    var container = new THREE.Object3D()
    var mirror = index === 1

    var radius = 20
    if (mirror) {
        rotation += Math.PI*2
        radius *= -1
    }

    //make text perpendicular to theta rotation
    // rotation -= Math.PI/2 

    container.position.set(
        Math.cos(rotation) * radius,
        15,
        Math.sin(rotation) * radius
    )
    

    // container.position.copy(data.origin)

    var pos = container.position
    var dir = pos.clone().sub(new THREE.Vector3(0,pos.y,0)).normalize()

    var rotOff = 0//Math.PI/10 * (mirror ? -1 : 1)

    var dx = pos.x,
        dz = pos.z,
        theta = -Math.atan2(dz, dx) - rotOff
    // container.rotation.y = theta
    container.rotation.y = theta
    container.rotation.x = 0
    
    if (mirror) {
        container.scale.x *= -1
    }

    var labels = data.labels.map(function(label) {
        var obj = new THREE.Object3D()
        container.add(obj)
        if (mirror)
            obj.position.x = -data.width||0
        return xtend({ size: 1, translation: [0, 0, 0] }, label, { 
            object3d: obj, 
            // theta: theta
        })
    })

    var shapes = (data.shapes||[]).map(function(shape) {
        var complex = shape.path ? getSVG(shape.path) : getPoly(shape.points)
        var geo = Complex(complex)
        var mesh = new THREE.Mesh(geo, new THREE.MeshBasicMaterial({ 
            color: 0xffffff,
            side: THREE.DoubleSide,
            opacity: 1,
            transparent: true
        }))
        
        if (shape.position) mesh.position.fromArray(shape.position)
        if (shape.scale) mesh.scale.fromArray(shape.scale)

        container.add(mesh)
        return mesh
    })

    return {
        labels: labels,
        shapes: shapes,
        container: container
    }
}
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./TextPass":"/projects/blackice/lib/TextPass.js","./get-polygon":"/projects/blackice/lib/get-polygon.js","./get-svg":"/projects/blackice/lib/get-svg.js","./text-data":"/projects/blackice/lib/text-data.js","three-simplicial-complex":"/projects/blackice/node_modules/three-simplicial-complex/index.js","xtend":"/projects/blackice/node_modules/xtend/immutable.js"}],"/projects/blackice/lib/get-polygon.js":[function(require,module,exports){
var triangulate = require('triangulate-contours')
var normalize = require('normalize-path-scale')

module.exports = function(points) {
    points = points.split(' ').map(function(p) {
        return p.split(',').map(function(n) {
            return parseFloat(n, 10)
        })
    })

    points = normalize(points)

    var triangulated = triangulate([ points ])
    triangulated.positions = triangulated.positions.map(function(p) {
        return [p[0], p[1], 0]
    })
    return triangulated
}
},{"normalize-path-scale":"/projects/blackice/node_modules/normalize-path-scale/index.js","triangulate-contours":"/projects/blackice/node_modules/triangulate-contours/index.js"}],"/projects/blackice/lib/get-svg.js":[function(require,module,exports){
var parse = require('parse-svg-path')
var contours = require('svg-path-contours')
var simplify = require('simplify-path')
var triangulate = require('triangulate-contours')
var normalize = require('normalize-path-scale')

module.exports = function(contents) {
    var parsed = parse(contents)
    console.log(parsed, contents)
    //get a list of polylines/contours from svg contents
    var lines = contours(parsed)

    //simplify the contours before triangulation
    // lines = lines.map(function(path) {
    //     return simplify(path, threshold)
    // })
    
    //turns into triangles, returns { positions, cells }
    var shape = triangulate(lines)

    //normalize(shape.positions)

    shape.positions = shape.positions.map(function(p) {
        return [p[0], p[1], 0]
    })
    return shape
}
},{"normalize-path-scale":"/projects/blackice/node_modules/normalize-path-scale/index.js","parse-svg-path":"/projects/blackice/node_modules/parse-svg-path/index.js","simplify-path":"/projects/blackice/node_modules/simplify-path/index.js","svg-path-contours":"/projects/blackice/node_modules/svg-path-contours/index.js","triangulate-contours":"/projects/blackice/node_modules/triangulate-contours/index.js"}],"/projects/blackice/lib/renderer.js":[function(require,module,exports){
(function (global){
var THREE = (typeof window !== "undefined" ? window.THREE : typeof global !== "undefined" ? global.THREE : null)

var RigScene = require('./RigScene')
var OrbitController = require('./three-orbit-camera')(THREE)
var Effects = require('./setup-effects')

var TweenMax = (typeof window !== "undefined" ? window.TweenMax : typeof global !== "undefined" ? global.TweenMax : null)
var animateLabels = require('./animate-labels')
var hideLabels = animateLabels.hideAll

var clamp = require('clamp')
var pluck = require('plucker')
var number = require('as-number')
var smoothstep = require('smoothstep')
var lerp = require('lerp')
var unlerp = require('unlerp')

module.exports = function(opt) {
    opt = opt||{}

    var Font = opt.font

    if (!Font || !Font.textures)
        throw new Error('must specify font with textures')

    var renderer,
        scene,
        camera,
        controller,
        features,
        water,
        effects,
        labels = [],
        time = 0

    if (!opt.gl)
        throw new Error('must specify GL context')

    setup(opt.gl, opt.width||0, opt.height||0)

    function draw(dt) {
        time +=  Math.min(dt, 30) / 1000
        renderer.resetAttributes()
        renderer.resetGLState()

        water.material.uniforms.time.value = time * 0.1
        water.render()

        controller.update()
        
        scene.update(dt)
        effects.render(dt)

        animateLabels(controller, labels)

        var t = unlerp(0.6, 1.4, controller.phi)
        t = smoothstep(1.4, 0.45, t)
        var range = clamp(t, 0, 1)
        water.alpha = range||0
    }

    function setup(gl, width, height) {
        renderer = new THREE.WebGLRenderer({ 
            canvas: gl.canvas,
            antialias: false,
            alpha: false
        })
        renderer.setClearColor(0xffffff, 0)
        renderer.shadowMapType = THREE.BasicShadowMap
        // renderer.shadowMapEnabled = true

        opt.fov = number(opt.fov, 50)
        camera = new THREE.PerspectiveCamera(opt.fov, width/height, 0.5, 20000)
        camera.position.x = -60
        camera.position.z = -40
        camera.position.y = 38
        camera.lookAt(new THREE.Vector3())

        controller = new OrbitController(camera)
        controller.userPan = false
        controller.userPanSpeed = 0.0
        controller.zoomSpeed = 0.1
        controller.rotateSpeed = 0.2
        controller.minDistance = 30
        controller.maxDistance = 200.0
        controller.maxPolarAngle = 90 * Math.PI/180
        controller.minPolarAngle = 40 * Math.PI/180
        controller.center.set( 0, 5, 0 )
        scene = RigScene()

        water = require('./setup-water')(renderer, camera, scene)
        
        scene.cubeMap = water.cubeMap
        scene.updateMaterial()

        var pass = require('./create-text-pass')({
            renderer: renderer,
            scene: scene,
            camera: camera,
            font: Font
        })

        labels = pass.groups

        effects = Effects({
            renderer: renderer,
            scene: scene,
            camera: camera,
            width: width,
            blur: false,
            height: height,
            renderPass: pass
        })

        hideLabels(labels)
    }

    function handleResize(width, height) {
        renderer.setSize(width, height)
        camera.aspect = width/height
        camera.updateProjectionMatrix()

        effects.resize(width, height)
    }

    return {
        draw: draw,
        resize: handleResize
    }
}
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./RigScene":"/projects/blackice/lib/RigScene.js","./animate-labels":"/projects/blackice/lib/animate-labels.js","./create-text-pass":"/projects/blackice/lib/create-text-pass.js","./setup-effects":"/projects/blackice/lib/setup-effects.js","./setup-water":"/projects/blackice/lib/setup-water.js","./three-orbit-camera":"/projects/blackice/lib/three-orbit-camera/index.js","as-number":"/projects/blackice/node_modules/as-number/index.js","clamp":"/projects/blackice/node_modules/clamp/index.js","lerp":"/projects/blackice/node_modules/lerp/index.js","plucker":"/projects/blackice/node_modules/plucker/index.js","smoothstep":"/projects/blackice/node_modules/smoothstep/index.js","unlerp":"/projects/blackice/node_modules/unlerp/index.js"}],"/projects/blackice/lib/setup-effects.js":[function(require,module,exports){
(function (global){
var THREE = (typeof window !== "undefined" ? window.THREE : typeof global !== "undefined" ? global.THREE : null)
var EffectComposer = require('three-effectcomposer')(THREE)
var createFXAA = require('three-shader-fxaa')(THREE)
var createBlur = require('./shaders/blur')
var createLens = require('./shaders/lens')
var createEmpty = require('./shaders/pass')
// var TextPass = require('./TextPass')

module.exports = Effects

function Effects(opt) {
    if (!(this instanceof Effects)) 
        return new Effects(opt)
    opt = opt||{}


    var parameters = { 
        minFilter: THREE.LinearFilter, 
        magFilter: THREE.LinearFilter, 
        format: THREE.RGBFormat, 
        stencilBuffer: false 
    }
    var width = opt.width
    var height = opt.height
    var renderTarget = new THREE.WebGLRenderTarget(width, height, parameters);

    this.composer = new EffectComposer(opt.renderer, renderTarget)
    this.composer.addPass(opt.renderPass)
    
    this.shaders = []
    this.noiseDelay = 33
    this.noiseTime = 0

    // this.shaders.push(new EffectComposer.ShaderPass(createEmpty()))


    var fxaaShader = new EffectComposer.ShaderPass(createFXAA())
    this.shaders.push(fxaaShader)

    if (opt.blur !== false) {
        var blur = createBlur()
        var iterations = 1;
        for (var i=0; i<iterations; i++) {
            var r = (i+1)*2;

            var horiz = new EffectComposer.ShaderPass( blur );
            horiz.uniforms.radius.value = r
            horiz.uniforms.strength.value = 1
            horiz.uniforms.dir.value.set(1,0)

            var vert = new EffectComposer.ShaderPass( blur );
            vert.uniforms.radius.value = r
            vert.uniforms.strength.value = 1
            vert.uniforms.dir.value.set(0,1)

            this.shaders.push(horiz, vert)
        }
    }

    var lensPass = new EffectComposer.ShaderPass(createLens())
    this.shaders.push(lensPass)

    //default values to avoid div by zero
    lensPass.uniforms.overlayResolution.value.set(1, 1)
    lensPass.uniforms.tLookup.value = loadTexture('img/lookup.png', { 
        generateMipmaps: false,
        filter: THREE.LinearFilter 
    })
    lensPass.uniforms.tOverlay.value = loadTexture('img/dust.jpg', {
        generateMipmaps: false,
        filter: THREE.LinearFilter
    }, function(err, tex) {
        lensPass.uniforms.overlayResolution.value.set(tex.image.width, tex.image.height)
    })

    this.shaders.forEach(function(pass, i, self) {
        this.composer.addPass(pass)
        if (i === self.length-1)
            pass.renderToScreen = true
    }, this)  
    if (opt.width && opt.height) 
        this.resize(opt.width, opt.height)
}


function loadTexture(path, opt, cb) {
    if (typeof opt === 'function') {
        cb = opt
        opt = {}
    }

    return THREE.ImageUtils.loadTexture(path, undefined, function(tex) {
        if (opt.filter) tex.minFilter = tex.magFilter = opt.filter
        if (opt.wrap) tex.wrapS = tex.wrapT = opt.wrap
        tex.generateMipmaps = opt.generateMipmaps
        if (typeof cb === 'function') 
            cb(null, tex)
    })
}

require('mixes')(Effects, {

    render: function(dt) {
        this.noiseTime += dt
        if (this.noiseTime > this.noiseDelay) {
            this.noiseTime = 0
            this.shaders.forEach(function(pass) {
                if (pass.uniforms.tick)
                    pass.uniforms.tick.value += 0.005
            })
        }

        this.composer.render()
    },

    resize: function(width, height) {
        width *= 2
        height *= 2
        this.composer.setSize(width, height)
        this.shaders.forEach(function(pass) {
            var dpr = 1
            // var dpr = (window.devicePixelRatio||1)
            if (pass.uniforms.resolution)
                pass.uniforms.resolution.value.set(width*dpr, height*dpr)
            
        })
    }
})
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./shaders/blur":"/projects/blackice/lib/shaders/blur.js","./shaders/lens":"/projects/blackice/lib/shaders/lens.js","./shaders/pass":"/projects/blackice/lib/shaders/pass.js","mixes":"/projects/blackice/node_modules/mixes/index.js","three-effectcomposer":"/projects/blackice/node_modules/three-effectcomposer/index.js","three-shader-fxaa":"/projects/blackice/node_modules/three-shader-fxaa/index.js"}],"/projects/blackice/lib/setup-water.js":[function(require,module,exports){
var cubeShader = {

    uniforms: THREE.UniformsUtils.merge( [
        { "tCube": { type: "t", value: null },
        "tFlip": { type: "f", value: - 1 } },
        THREE.UniformsLib[ "fog" ]
    ] ),

    vertexShader: [

        "varying vec3 vWorldPosition;",

        THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

        "void main() {",

        "   vec4 worldPosition = modelMatrix * vec4( position, 1.0 );",
        "   vWorldPosition = worldPosition.xyz;",

        "   gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

            THREE.ShaderChunk[ "logdepthbuf_vertex" ],

        "}"

    ].join("\n"),

    fragmentShader: [

        "uniform samplerCube tCube;",
        "uniform float tFlip;",

        "varying vec3 vWorldPosition;",
        THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],
        THREE.ShaderChunk[ "fog_pars_fragment" ],
        "void main() {",
        "   gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );",
            THREE.ShaderChunk[ "logdepthbuf_fragment" ],
            THREE.ShaderChunk[ "fog_fragment" ],
        "}"

    ].join("\n")

}
module.exports = function(renderer, camera, scene) {
    var light = new THREE.HemisphereLight(0xbbe9ff, 0x080820, 1)
    light.position.set(-1, 1, -1)
    scene.add(light)

    var waterNormals = new THREE.ImageUtils.loadTexture('img/waternormals5.jpg')
    waterNormals.wrapS = waterNormals.wrapT = THREE.RepeatWrapping

    var water = new THREE.Water(renderer, camera, scene, {
        textureWidth: 512,
        textureHeight: 512,
        waterNormals: waterNormals,
        alpha: 0.9,
        sunDirection: light.position.clone().normalize(),
        sunColor: 0xffffff,
        waterColor: 0x020d15,
        distortionScale: 80.0,
    })

    var mirrorMesh = new THREE.Mesh(
        new THREE.PlaneBufferGeometry(5000, 5000),
        water.material
    )

    mirrorMesh.add(water)
    mirrorMesh.rotation.x = -Math.PI * 0.5
    scene.add(mirrorMesh)


    // load skybox

    var cubeMap = new THREE.CubeTexture([])
    cubeMap.format = THREE.RGBFormat
    cubeMap.flipY = false

    var loader = new THREE.ImageLoader()
    loader.load('img/cloudy_night2.jpg', function(image) {

        var getSide = function(x, y) {

            var size = 1024

            var canvas = document.createElement('canvas')
            canvas.width = size
            canvas.height = size

            var context = canvas.getContext('2d')
            context.drawImage(image, -x * size, -y * size)

            return canvas

        }

        cubeMap.images[0] = getSide(2, 1) // px
        cubeMap.images[1] = getSide(0, 1) // nx
        cubeMap.images[2] = getSide(1, 0) // py
        cubeMap.images[3] = getSide(1, 2) // ny
        cubeMap.images[4] = getSide(1, 1) // pz
        cubeMap.images[5] = getSide(3, 1) // nz
        cubeMap.needsUpdate = true

    })

    cubeShader.uniforms.tCube.value = cubeMap

    var skyBoxMaterial = new THREE.ShaderMaterial({
        fragmentShader: cubeShader.fragmentShader,
        vertexShader: cubeShader.vertexShader,
        uniforms: cubeShader.uniforms,
        // depthWrite: false,
        side: THREE.BackSide,
        fog: true,
    })

    var skyBox = new THREE.Mesh(
        new THREE.BoxGeometry(5000, 5000, 5000),
        skyBoxMaterial
    )
    
    water.cubeMap = cubeMap

    scene.add(skyBox)
    return water
}
},{}],"/projects/blackice/lib/shaders/blur.js":[function(require,module,exports){
var glslify = require("glslify");
var source = require("glslify/simple-adapter.js")("\n#define GLSLIFY 1\n\nvarying vec2 vUv;\nvoid main() {\n  vUv = uv;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}", "\n#define GLSLIFY 1\n\nuniform vec2 resolution;\nuniform float radius;\nuniform vec2 dir;\nuniform float strength;\nuniform sampler2D tDiffuse;\nvarying vec2 vUv;\nvec4 a_x_blur(sampler2D tex, vec2 uv, vec2 blur, vec2 direction) {\n  vec4 sum = vec4(0.0);\n  sum += texture2D(tex, vec2(uv.x - 4.0 * blur.x * direction.x, uv.y - 4.0 * blur.y * direction.y)) * 0.0162162162;\n  sum += texture2D(tex, vec2(uv.x - 3.0 * blur.x * direction.x, uv.y - 3.0 * blur.y * direction.y)) * 0.0540540541;\n  sum += texture2D(tex, vec2(uv.x - 2.0 * blur.x * direction.x, uv.y - 2.0 * blur.y * direction.y)) * 0.1216216216;\n  sum += texture2D(tex, vec2(uv.x - 1.0 * blur.x * direction.x, uv.y - 1.0 * blur.y * direction.y)) * 0.1945945946;\n  sum += texture2D(tex, vec2(uv.x, uv.y)) * 0.2270270270;\n  sum += texture2D(tex, vec2(uv.x + 1.0 * blur.x * direction.x, uv.y + 1.0 * blur.y * direction.y)) * 0.1945945946;\n  sum += texture2D(tex, vec2(uv.x + 2.0 * blur.x * direction.x, uv.y + 2.0 * blur.y * direction.y)) * 0.1216216216;\n  sum += texture2D(tex, vec2(uv.x + 3.0 * blur.x * direction.x, uv.y + 3.0 * blur.y * direction.y)) * 0.0540540541;\n  sum += texture2D(tex, vec2(uv.x + 4.0 * blur.x * direction.x, uv.y + 4.0 * blur.y * direction.y)) * 0.0162162162;\n  return sum;\n}\nvoid main() {\n  vec2 blurAmt = vec2(radius) / resolution;\n  vec4 sum = a_x_blur(tDiffuse, vUv, blurAmt, dir);\n  vec2 p = (gl_FragCoord.xy / resolution.xy - 0.5);\n  p.x *= resolution.x / resolution.y;\n  float len = smoothstep(0.5, 1.2, length(p));\n  vec3 orig = texture2D(tDiffuse, vUv).rgb;\n  gl_FragColor.rgb = mix(orig, sum.rgb, len + 0.1);\n  gl_FragColor.a = 1.0;\n}", [{"name":"resolution","type":"vec2"},{"name":"radius","type":"float"},{"name":"dir","type":"vec2"},{"name":"strength","type":"float"},{"name":"tDiffuse","type":"sampler2D"}], []);
module.exports = require("./create")(source);
},{"./create":"/projects/blackice/lib/shaders/create.js","glslify":"/projects/blackice/node_modules/glslify/browser.js","glslify/simple-adapter.js":"/projects/blackice/node_modules/glslify/simple-adapter.js"}],"/projects/blackice/lib/shaders/create.js":[function(require,module,exports){
(function (global){
var THREE = (typeof window !== "undefined" ? window.THREE : typeof global !== "undefined" ? global.THREE : null)
var threeify = require('three-glslify')(THREE)
var xtend = require('xtend') 
 
module.exports = function(source) {
    return function(opt) {
        return xtend(threeify(source), opt)
    }
}
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"three-glslify":"/projects/blackice/node_modules/three-glslify/index.js","xtend":"/projects/blackice/node_modules/xtend/immutable.js"}],"/projects/blackice/lib/shaders/lens.js":[function(require,module,exports){
var glslify = require("glslify");
var source = require("glslify/simple-adapter.js")("\n#define GLSLIFY 1\n\nuniform vec2 overlayResolution;\nuniform vec2 resolution;\nvarying vec2 vUv;\nvarying vec2 overlayUV;\nvoid main() {\n  vUv = uv;\n  float aspect = overlayResolution.x / overlayResolution.y;\n  float ratio = resolution.x / resolution.y;\n  overlayUV = uv;\n  float tAspect = overlayResolution.x / overlayResolution.y;\n  float pAspect = resolution.x / resolution.y;\n  overlayUV = uv;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}", "\n#define GLSLIFY 1\n\nuniform float tick;\nuniform sampler2D tDiffuse;\nuniform sampler2D tLookup;\nuniform sampler2D tOverlay;\nvarying vec2 vUv;\nvarying vec2 overlayUV;\nhighp float a_x_random(vec2 co) {\n  highp float a = 12.9898;\n  highp float b = 78.233;\n  highp float c = 43758.5453;\n  highp float dt = dot(co.xy, vec2(a, b));\n  highp float sn = mod(dt, 3.14);\n  return fract(sin(sn) * c);\n}\nvec3 b_x_blendOverlay(vec3 base, vec3 blend) {\n  return vec3(base.r < 0.5 ? (2.0 * base.r * blend.r) : (1.0 - 2.0 * (1.0 - base.r) * (1.0 - blend.r)), base.g < 0.5 ? (2.0 * base.g * blend.g) : (1.0 - 2.0 * (1.0 - base.g) * (1.0 - blend.g)), base.b < 0.5 ? (2.0 * base.b * blend.b) : (1.0 - 2.0 * (1.0 - base.b) * (1.0 - blend.b)));\n}\nfloat c_x_luma(vec3 color) {\n  return dot(color, vec3(0.299, 0.587, 0.114));\n}\nfloat c_x_luma(vec4 color) {\n  return dot(color.rgb, vec3(0.299, 0.587, 0.114));\n}\n#define LUT_FLIP_Y\n\nvec4 e_x_lookup(in vec4 textureColor, in sampler2D lookupTable) {\n  \n  #ifndef LUT_NO_CLAMP\n  textureColor = clamp(textureColor, 0.0, 1.0);\n  #endif\n  mediump float blueColor = textureColor.b * 63.0;\n  mediump vec2 quad1;\n  quad1.y = floor(floor(blueColor) / 8.0);\n  quad1.x = floor(blueColor) - (quad1.y * 8.0);\n  mediump vec2 quad2;\n  quad2.y = floor(ceil(blueColor) / 8.0);\n  quad2.x = ceil(blueColor) - (quad2.y * 8.0);\n  highp vec2 texPos1;\n  texPos1.x = (quad1.x * 0.125) + 0.5 / 512.0 + ((0.125 - 1.0 / 512.0) * textureColor.r);\n  texPos1.y = (quad1.y * 0.125) + 0.5 / 512.0 + ((0.125 - 1.0 / 512.0) * textureColor.g);\n  #ifdef LUT_FLIP_Y\n  texPos1.y = 1.0 - texPos1.y;\n  #endif\n  highp vec2 texPos2;\n  texPos2.x = (quad2.x * 0.125) + 0.5 / 512.0 + ((0.125 - 1.0 / 512.0) * textureColor.r);\n  texPos2.y = (quad2.y * 0.125) + 0.5 / 512.0 + ((0.125 - 1.0 / 512.0) * textureColor.g);\n  #ifdef LUT_FLIP_Y\n  texPos2.y = 1.0 - texPos2.y;\n  #endif\n  lowp vec4 newColor1 = texture2D(lookupTable, texPos1);\n  lowp vec4 newColor2 = texture2D(lookupTable, texPos2);\n  lowp vec4 newColor = mix(newColor1, newColor2, fract(blueColor));\n  return newColor;\n}\nvoid main() {\n  vec3 texColor = texture2D(tDiffuse, vUv).rgb;\n  float luminance = c_x_luma(texColor);\n  float noiseMap = smoothstep(luminance, 0.5, 0.0);\n  vec2 tUv = vUv + tick;\n  vec3 noise = vec3(a_x_random(tUv), a_x_random(tUv * 1.5), a_x_random(tUv * 0.5));\n  vec3 noiseColor = mix(noise, vec3(0.5), noiseMap);\n  vec3 color = mix(texColor, b_x_blendOverlay(texColor, noise), 0.15);\n  vec3 corrected = e_x_lookup(vec4(color, 1.0), tLookup).rgb;\n  color = mix(color, corrected, 0.9);\n  gl_FragColor = vec4(color, 1.0);\n  vec4 scratches = texture2D(tOverlay, overlayUV);\n  vec3 scratchBlend = gl_FragColor.rgb + scratches.rgb;\n  float center = smoothstep(0.0, 0.6, length(vUv - 0.5));\n  float dirtMap = smoothstep(0.1, 0.4, luminance * center);\n  gl_FragColor.rgb = mix(gl_FragColor.rgb, scratchBlend, dirtMap);\n}", [{"name":"overlayResolution","type":"vec2"},{"name":"resolution","type":"vec2"},{"name":"tick","type":"float"},{"name":"tDiffuse","type":"sampler2D"},{"name":"tLookup","type":"sampler2D"},{"name":"tOverlay","type":"sampler2D"}], []);
module.exports = require("./create")(source);
},{"./create":"/projects/blackice/lib/shaders/create.js","glslify":"/projects/blackice/node_modules/glslify/browser.js","glslify/simple-adapter.js":"/projects/blackice/node_modules/glslify/simple-adapter.js"}],"/projects/blackice/lib/shaders/pass.js":[function(require,module,exports){
var glslify = require("glslify");
var source = require("glslify/simple-adapter.js")("\n#define GLSLIFY 1\n\nvarying vec2 vUv;\nvoid main() {\n  vUv = uv;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}", "\n#define GLSLIFY 1\n\nuniform sampler2D tDiffuse;\nvarying vec2 vUv;\nvoid main() {\n  gl_FragColor = texture2D(tDiffuse, vUv);\n}", [{"name":"tDiffuse","type":"sampler2D"}], []);
module.exports = require("./create")(source);
},{"./create":"/projects/blackice/lib/shaders/create.js","glslify":"/projects/blackice/node_modules/glslify/browser.js","glslify/simple-adapter.js":"/projects/blackice/node_modules/glslify/simple-adapter.js"}],"/projects/blackice/lib/text-data.js":[function(require,module,exports){
(function (global){
var THREE = (typeof window !== "undefined" ? window.THREE : typeof global !== "undefined" ? global.THREE : null)
var lineHeight = 22
var big = 0.7
var small = 0.5

var panelWidth = 20
module.exports = [
    
    {
        name: 'tonnes',
        panels: [ {
            // origin: new THREE.Vector3(18, 10, 2),
            labels: [
                { text: '5 million tonnes', size: big },
                { text: 'estimated oil spilt in Russia each year', size: small, translation: [-2, -lineHeight, 0] },
            ]
        }, 
        {
            // origin: new THREE.Vector3(-20, 10, 2),
            width: panelWidth,
            labels: [
                { text: '6 million tonnes', size: big },
                { text: 'expected yearly output of this platform', size: small, translation: [0, -lineHeight, 0] },
            ]
        } 
        ]
    },
    {
        name: 'top',
        panels: [ {
            labels: [
                { text: 'Technologically outdated', size: big },
                { text: 'using secondhand components', size: small, translation: [0, -lineHeight, 0] },
            ]
        },
        {
            width: panelWidth,
            labels: [
                { text: '$3.2 billion over budget', size: big },
                { text: '18 years to construct', size: small, translation: [0, -lineHeight, 0] },
            ]
        } ]
    },
    {
        name: 'nature',
        panels: [ {
            labels: [
                { text: '50 km from Nature reserve', size: big },
                { text: 'Less than 20hrs for oil to reach', size: small, translation: [0, -lineHeight, 0] },
            ]
        },
        {
            width: panelWidth,
            labels: [
                { text: 'Crucial breeding grounds', size: big },
                { text: 'for walrus, whales & polar bears', size: small, translation: [0, -lineHeight, 0] },
            ]
        } ]
    },
    {
        name: 'response',
        panels: [ {
            labels: [
                { text: 'Large scale spill equipment ', size: big },
                { text: '1000km (3 days sailing) away', size: small, translation: [0, -lineHeight, 0] },
            ]
        },
        {
            width: panelWidth*1.5,
            labels: [
                { text: '15 buckets and 3 axes', size: big },
                { text: 'included in previous response plan', size: small, translation: [0, -lineHeight, 0] },
            ]
        } ]
    },
    {
        name: 'spill',
        panels: [ {
            labels: [
                { text: 'Arctic Oil spills', size: big },
                { text: 'are close to impossible to clean up', size: small, translation: [0, -lineHeight, 0] },
            ]
        },
        {
            width: panelWidth,
            labels: [
                { text: 'Offshore drilling for arctic oil', size: big },
                { text: 'spills are virtually inevitable', size: small, translation: [0, -lineHeight, 0] },
            ]
        } ]
    },
    {
        name: 'weather',
        panels: [ {
            labels: [
                { text: 'As cold as -50c /122f', size: big },
                { text: 'two thirds of the year surrounded by ice', size: small, translation: [0, -lineHeight, 0] },
            ]
        },
        {
            width: panelWidth,
            labels: [
                { text: 'Plagued by bad weather', size: big },
                { text: 'waves as high as 12m', size: small, translation: [0, -lineHeight, 0] },
            ]
        } ]
    },
]

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],"/projects/blackice/lib/three-orbit-camera/index.js":[function(require,module,exports){
(function (global){
var inherits = require('inherits')
var TweenMax = (typeof window !== "undefined" ? window.TweenMax : typeof global !== "undefined" ? global.TweenMax : null)

module.exports = function(THREE) {
    if (!THREE.MOUSE)
        THREE.MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };

    /**
     * @author qiao / https://github.com/qiao
     * @author mrdoob / http://mrdoob.com
     * @author alteredq / http://alteredqualia.com/
     * @author WestLangley / http://github.com/WestLangley
     * @author erich666 / http://erichaines.com
     */
    /*global THREE, console */

    // This set of controls performs orbiting, dollying (zooming), and panning. It maintains
    // the "up" direction as +Y, unlike the TrackballControls. Touch on tablet and phones is
    // supported.
    //
    //    Orbit - left mouse / touch: one finger move
    //    Zoom - middle mouse, or mousewheel / touch: two finger spread or squish
    //    Pan - right mouse, or arrow keys / touch: three finter swipe
    //
    // This is a drop-in replacement for (most) TrackballControls used in examples.
    // That is, include this js file and wherever you see:
    //      controls = new THREE.TrackballControls( camera );
    //      controls.target.z = 150;
    // Simple substitute "OrbitControls" and the control should work as-is.

    function OrbitControls( object, domElement ) {

        this.object = object;
        this.domElement = ( domElement !== undefined ) ? domElement : document;

        // API

        // Set to false to disable this control
        this.enabled = true;

        // "target" sets the location of focus, where the control orbits around
        // and where it pans with respect to.
        this.target = new THREE.Vector3();

        // center is old, deprecated; use "target" instead
        this.center = this.target;

        // This option actually enables dollying in and out; left as "zoom" for
        // backwards compatibility
        this.noZoom = false;
        this.zoomSpeed = 1.0;

        // Limits to how far you can dolly in and out
        this.minDistance = 0;
        this.maxDistance = Infinity;

        // Set to true to disable this control
        this.noRotate = false;
        this.rotateSpeed = 1.0;

        // Set to true to disable this control
        this.noPan = false;
        this.keyPanSpeed = 7.0; // pixels moved per arrow key push

        // Set to true to automatically rotate around the target
        this.autoRotate = false;
        this.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60

        // How far you can orbit vertically, upper and lower limits.
        // Range is 0 to Math.PI radians.
        this.minPolarAngle = 0; // radians
        this.maxPolarAngle = Math.PI; // radians

        // Set to true to disable use of the keys
        this.noKeys = false;

        this.phi = 0
        this.theta = 0 

        // The four arrow keys
        this.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 };

        this.constrainDelta = { x: 0, y: 0 };

        ////////////
        // internals

        var scope = this;

        var EPS = 0.000001;

        var rotateStart = new THREE.Vector2();
        var rotateEnd = new THREE.Vector2();
        var rotateDelta = new THREE.Vector2();

        var panStart = new THREE.Vector2();
        var panEnd = new THREE.Vector2();
        var panDelta = new THREE.Vector2();
        var panOffset = new THREE.Vector3();

        var offset = new THREE.Vector3();

        var dollyStart = new THREE.Vector2();
        var dollyEnd = new THREE.Vector2();
        var dollyDelta = new THREE.Vector2();

        var phiDelta = 0;
        var thetaDelta = 0;
        var scale = 1;
        var pan = new THREE.Vector3();

        var lastPosition = new THREE.Vector3();

        var STATE = { NONE : -1, ROTATE : 0, DOLLY : 1, PAN : 2, TOUCH_ROTATE : 3, TOUCH_DOLLY : 4, TOUCH_PAN : 5 };

        var state = STATE.NONE;

        // for reset

        this.target0 = this.target.clone();
        this.position0 = this.object.position.clone();

        // so camera.up is the orbit axis

        var quat = new THREE.Quaternion().setFromUnitVectors( object.up, new THREE.Vector3( 0, 1, 0 ) );
        var quatInverse = quat.clone().inverse();

        // events

        var changeEvent = { type: 'change' };
        var startEvent = { type: 'start'};
        var endEvent = { type: 'end'};

        this.rotateLeft = function ( angle ) {

            if ( angle === undefined ) {

                angle = getAutoRotationAngle();

            }

            thetaDelta -= angle;

        };

        this.rotateUp = function ( angle ) {

            if ( angle === undefined ) {

                angle = getAutoRotationAngle();

            }

            phiDelta -= angle;

        };

        // pass in distance in world space to move left
        this.panLeft = function ( distance ) {

            var te = this.object.matrix.elements;

            // get X column of matrix
            panOffset.set( te[ 0 ], te[ 1 ], te[ 2 ] );
            panOffset.multiplyScalar( - distance );
            
            pan.add( panOffset );

        };

        // pass in distance in world space to move up
        this.panUp = function ( distance ) {

            var te = this.object.matrix.elements;

            // get Y column of matrix
            panOffset.set( te[ 4 ], te[ 5 ], te[ 6 ] );
            panOffset.multiplyScalar( distance );
            
            pan.add( panOffset );

        };
        
        // pass in x,y of change desired in pixel space,
        // right and down are positive
        this.pan = function ( deltaX, deltaY ) {

            var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

            if ( scope.object.fov !== undefined ) {

                // perspective
                var position = scope.object.position;
                var offset = position.clone().sub( scope.target );
                var targetDistance = offset.length();

                // half of the fov is center to top of screen
                targetDistance *= Math.tan( ( scope.object.fov / 2 ) * Math.PI / 180.0 );

                // we actually don't use screenWidth, since perspective camera is fixed to screen height
                scope.panLeft( 2 * deltaX * targetDistance / element.clientHeight );
                scope.panUp( 2 * deltaY * targetDistance / element.clientHeight );

            } else if ( scope.object.top !== undefined ) {

                // orthographic
                scope.panLeft( deltaX * (scope.object.right - scope.object.left) / element.clientWidth );
                scope.panUp( deltaY * (scope.object.top - scope.object.bottom) / element.clientHeight );

            } else {

                // camera neither orthographic or perspective
                console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.' );

            }

        };

        this.dollyIn = function ( dollyScale ) {

            if ( dollyScale === undefined ) {

                dollyScale = getZoomScale();

            }

            scale /= dollyScale;

        };

        this.dollyOut = function ( dollyScale ) {

            if ( dollyScale === undefined ) {

                dollyScale = getZoomScale();

            }

            scale *= dollyScale;

        };

        this.update = function () {

            var position = this.object.position;

            // // rotating across whole screen goes 360 degrees around
            scope.rotateLeft( 2 * Math.PI * scope.constrainDelta.x / window.innerWidth * scope.rotateSpeed );

            // // rotating up and down along whole screen attempts to go 360, but limited to 180
            scope.rotateUp( 2 * Math.PI * scope.constrainDelta.y / window.innerHeight * scope.rotateSpeed );

            offset.copy( position ).sub( this.target );

            // rotate offset to "y-axis-is-up" space
            offset.applyQuaternion( quat );

            // angle from z-axis around y-axis

            var theta = Math.atan2( offset.x, offset.z );

            // angle from y-axis

            var phi = Math.atan2( Math.sqrt( offset.x * offset.x + offset.z * offset.z ), offset.y );

            if ( this.autoRotate ) {

                this.rotateLeft( getAutoRotationAngle() );

            }

            theta += thetaDelta;
            phi += phiDelta;

            // restrict phi to be between desired limits
            phi = Math.max( this.minPolarAngle, Math.min( this.maxPolarAngle, phi ) );

            // restrict phi to be betwee EPS and PI-EPS
            phi = Math.max( EPS, Math.min( Math.PI - EPS, phi ) );

            var radius = offset.length() * scale;

            // restrict radius to be between desired limits
            radius = Math.max( this.minDistance, Math.min( this.maxDistance, radius ) );
            
            // move target to panned location
            this.target.add( pan );

            scope.phi = phi
            scope.theta = theta

            offset.x = radius * Math.sin( phi ) * Math.sin( theta );
            offset.y = radius * Math.cos( phi );
            offset.z = radius * Math.sin( phi ) * Math.cos( theta );

            // rotate offset back to "camera-up-vector-is-up" space
            offset.applyQuaternion( quatInverse );

            position.copy( this.target ).add( offset );

            this.object.lookAt( this.target );

            thetaDelta = 0;
            phiDelta = 0;
            scale = 1;
            pan.set( 0, 0, 0 );

            if ( lastPosition.distanceToSquared( this.object.position ) > EPS ) {

                this.dispatchEvent( changeEvent );

                lastPosition.copy( this.object.position );

            }

        };


        this.reset = function () {

            state = STATE.NONE;

            this.target.copy( this.target0 );
            this.object.position.copy( this.position0 );

            this.update();

        };

        function getAutoRotationAngle() {

            return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;

        }

        function getZoomScale() {

            return Math.pow( 0.95, scope.zoomSpeed );

        }

        function onMouseDown( event ) {

            if ( scope.enabled === false ) return;
            event.preventDefault();

            if ( event.button === 0 ) {
                if ( scope.noRotate === true ) return;

                state = STATE.ROTATE;

                rotateStart.set( event.clientX, event.clientY );

            } else if ( event.button === 1 ) {
                if ( scope.noZoom === true ) return;

                state = STATE.DOLLY;

                dollyStart.set( event.clientX, event.clientY );

            } else if ( event.button === 2 ) {
                if ( scope.noPan === true ) return;

                state = STATE.PAN;

                panStart.set( event.clientX, event.clientY );

            }

            scope.domElement.addEventListener( 'mousemove', onMouseMove, false );
            scope.domElement.addEventListener( 'mouseup', onMouseUp, false );
            scope.dispatchEvent( startEvent );

        }

        function onMouseMove( event ) {

            if ( scope.enabled === false ) return;

            event.preventDefault();

            var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

            if ( state === STATE.ROTATE ) {

                if ( scope.noRotate === true ) return;

                rotateEnd.set( event.clientX, event.clientY );
                rotateDelta.subVectors( rotateEnd, rotateStart );

                scope.constrainDelta.x = rotateDelta.x;
                scope.constrainDelta.y = rotateDelta.y;
                
                TweenMax.killTweensOf(scope.constrainDelta);
                TweenMax.to(scope.constrainDelta, 0.50, {
                    x: 0,
                    y: 0,
                    ease: 'easeOutQuad',
                    delay: 0.0
                });

                rotateStart.copy( rotateEnd );

            } else if ( state === STATE.DOLLY ) {

                if ( scope.noZoom === true ) return;

                dollyEnd.set( event.clientX, event.clientY );
                dollyDelta.subVectors( dollyEnd, dollyStart );

                if ( dollyDelta.y > 0 ) {

                    scope.dollyIn();

                } else {

                    scope.dollyOut();

                }

                dollyStart.copy( dollyEnd );

            } else if ( state === STATE.PAN ) {

                if ( scope.noPan === true ) return;

                panEnd.set( event.clientX, event.clientY );
                panDelta.subVectors( panEnd, panStart );
                
                scope.pan( panDelta.x, panDelta.y );

                panStart.copy( panEnd );

            }

            scope.update();

        }

        function onMouseUp( /* event */ ) {

            if ( scope.enabled === false ) return;

            scope.domElement.removeEventListener( 'mousemove', onMouseMove, false );
            scope.domElement.removeEventListener( 'mouseup', onMouseUp, false );
            scope.dispatchEvent( endEvent );
            state = STATE.NONE;

        }

        function onMouseWheel( event ) {

            if ( scope.enabled === false || scope.noZoom === true ) return;

            event.preventDefault();
            event.stopPropagation();

            var delta = 0;

            if ( event.wheelDelta !== undefined ) { // WebKit / Opera / Explorer 9

                delta = event.wheelDelta;

            } else if ( event.detail !== undefined ) { // Firefox

                delta = - event.detail;

            }

            if ( delta > 0 ) {

                scope.dollyOut();

            } else {

                scope.dollyIn();

            }

            scope.update();
            scope.dispatchEvent( startEvent );
            scope.dispatchEvent( endEvent );

        }

        function onKeyDown( event ) {

            if ( scope.enabled === false || scope.noKeys === true || scope.noPan === true ) return;
            
            switch ( event.keyCode ) {

                case scope.keys.UP:
                    scope.pan( 0, scope.keyPanSpeed );
                    scope.update();
                    break;

                case scope.keys.BOTTOM:
                    scope.pan( 0, - scope.keyPanSpeed );
                    scope.update();
                    break;

                case scope.keys.LEFT:
                    scope.pan( scope.keyPanSpeed, 0 );
                    scope.update();
                    break;

                case scope.keys.RIGHT:
                    scope.pan( - scope.keyPanSpeed, 0 );
                    scope.update();
                    break;

            }

        }

        function touchstart( event ) {

            if ( scope.enabled === false ) return;

            switch ( event.touches.length ) {

                case 1: // one-fingered touch: rotate

                    if ( scope.noRotate === true ) return;

                    state = STATE.TOUCH_ROTATE;

                    rotateStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );
                    break;

                case 2: // two-fingered touch: dolly

                    if ( scope.noZoom === true ) return;

                    state = STATE.TOUCH_DOLLY;

                    var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;
                    var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;
                    var distance = Math.sqrt( dx * dx + dy * dy );
                    dollyStart.set( 0, distance );
                    break;

                case 3: // three-fingered touch: pan

                    if ( scope.noPan === true ) return;

                    state = STATE.TOUCH_PAN;

                    panStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );
                    break;

                default:

                    state = STATE.NONE;

            }

            scope.dispatchEvent( startEvent );

        }

        function touchmove( event ) {

            if ( scope.enabled === false ) return;

            event.preventDefault();
            event.stopPropagation();

            var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

            switch ( event.touches.length ) {

                case 1: // one-fingered touch: rotate

                    if ( scope.noRotate === true ) return;
                    if ( state !== STATE.TOUCH_ROTATE ) return;

                    rotateEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );
                    rotateDelta.subVectors( rotateEnd, rotateStart );

                    // rotating across whole screen goes 360 degrees around
                    scope.rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed );
                    // rotating up and down along whole screen attempts to go 360, but limited to 180
                    scope.rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed );

                    rotateStart.copy( rotateEnd );

                    scope.update();
                    break;

                case 2: // two-fingered touch: dolly

                    if ( scope.noZoom === true ) return;
                    if ( state !== STATE.TOUCH_DOLLY ) return;

                    var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;
                    var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;
                    var distance = Math.sqrt( dx * dx + dy * dy );

                    dollyEnd.set( 0, distance );
                    dollyDelta.subVectors( dollyEnd, dollyStart );

                    if ( dollyDelta.y > 0 ) {

                        scope.dollyOut();

                    } else {

                        scope.dollyIn();

                    }

                    dollyStart.copy( dollyEnd );

                    scope.update();
                    break;

                case 3: // three-fingered touch: pan

                    if ( scope.noPan === true ) return;
                    if ( state !== STATE.TOUCH_PAN ) return;

                    panEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );
                    panDelta.subVectors( panEnd, panStart );
                    
                    scope.pan( panDelta.x, panDelta.y );

                    panStart.copy( panEnd );

                    scope.update();
                    break;

                default:

                    state = STATE.NONE;

            }

        }

        function touchend( /* event */ ) {

            if ( scope.enabled === false ) return;

            scope.dispatchEvent( endEvent );
            state = STATE.NONE;

        }

        this.domElement.addEventListener( 'contextmenu', function ( event ) { event.preventDefault(); }, false );
        this.domElement.addEventListener( 'mousedown', onMouseDown, false );
        this.domElement.addEventListener( 'mousewheel', onMouseWheel, false );
        this.domElement.addEventListener( 'DOMMouseScroll', onMouseWheel, false ); // firefox

        this.domElement.addEventListener( 'touchstart', touchstart, false );
        this.domElement.addEventListener( 'touchend', touchend, false );
        this.domElement.addEventListener( 'touchmove', touchmove, false );

        window.addEventListener( 'keydown', onKeyDown, false );

        // force an update at start
        this.update();

    };

    inherits(OrbitControls, THREE.EventDispatcher)
    return OrbitControls
}
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"inherits":"/projects/blackice/node_modules/inherits/inherits_browser.js"}],"/projects/blackice/node_modules/as-number/index.js":[function(require,module,exports){
module.exports = function numtype(num, def) {
	return typeof num === 'number'
		? num 
		: (typeof def === 'number' ? def : 0)
}
},{}],"/projects/blackice/node_modules/browserify/node_modules/buffer/index.js":[function(require,module,exports){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var isArray = require('is-array')

exports.Buffer = Buffer
exports.SlowBuffer = Buffer
exports.INSPECT_MAX_BYTES = 50
Buffer.poolSize = 8192 // not used by this implementation

var kMaxLength = 0x3fffffff

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Note:
 *
 * - Implementation must support adding new properties to `Uint8Array` instances.
 *   Firefox 4-29 lacked support, fixed in Firefox 30+.
 *   See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *  - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *  - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *    incorrect length in some situations.
 *
 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they will
 * get the Object implementation, which is slower but will work correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = (function () {
  try {
    var buf = new ArrayBuffer(0)
    var arr = new Uint8Array(buf)
    arr.foo = function () { return 42 }
    return 42 === arr.foo() && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        new Uint8Array(1).subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
})()

/**
 * Class: Buffer
 * =============
 *
 * The Buffer constructor returns instances of `Uint8Array` that are augmented
 * with function properties for all the node `Buffer` API functions. We use
 * `Uint8Array` so that square bracket notation works as expected -- it returns
 * a single octet.
 *
 * By augmenting the instances, we can avoid modifying the `Uint8Array`
 * prototype.
 */
function Buffer (subject, encoding, noZero) {
  if (!(this instanceof Buffer))
    return new Buffer(subject, encoding, noZero)

  var type = typeof subject

  // Find the length
  var length
  if (type === 'number')
    length = subject > 0 ? subject >>> 0 : 0
  else if (type === 'string') {
    if (encoding === 'base64')
      subject = base64clean(subject)
    length = Buffer.byteLength(subject, encoding)
  } else if (type === 'object' && subject !== null) { // assume object is array-like
    if (subject.type === 'Buffer' && isArray(subject.data))
      subject = subject.data
    length = +subject.length > 0 ? Math.floor(+subject.length) : 0
  } else
    throw new TypeError('must start with number, buffer, array or string')

  if (this.length > kMaxLength)
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
      'size: 0x' + kMaxLength.toString(16) + ' bytes')

  var buf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Preferred: Return an augmented `Uint8Array` instance for best performance
    buf = Buffer._augment(new Uint8Array(length))
  } else {
    // Fallback: Return THIS instance of Buffer (created by `new`)
    buf = this
    buf.length = length
    buf._isBuffer = true
  }

  var i
  if (Buffer.TYPED_ARRAY_SUPPORT && typeof subject.byteLength === 'number') {
    // Speed optimization -- use set if we're copying from a typed array
    buf._set(subject)
  } else if (isArrayish(subject)) {
    // Treat array-ish objects as a byte array
    if (Buffer.isBuffer(subject)) {
      for (i = 0; i < length; i++)
        buf[i] = subject.readUInt8(i)
    } else {
      for (i = 0; i < length; i++)
        buf[i] = ((subject[i] % 256) + 256) % 256
    }
  } else if (type === 'string') {
    buf.write(subject, 0, encoding)
  } else if (type === 'number' && !Buffer.TYPED_ARRAY_SUPPORT && !noZero) {
    for (i = 0; i < length; i++) {
      buf[i] = 0
    }
  }

  return buf
}

Buffer.isBuffer = function (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b))
    throw new TypeError('Arguments must be Buffers')

  var x = a.length
  var y = b.length
  for (var i = 0, len = Math.min(x, y); i < len && a[i] === b[i]; i++) {}
  if (i !== len) {
    x = a[i]
    y = b[i]
  }
  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'raw':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function (list, totalLength) {
  if (!isArray(list)) throw new TypeError('Usage: Buffer.concat(list[, length])')

  if (list.length === 0) {
    return new Buffer(0)
  } else if (list.length === 1) {
    return list[0]
  }

  var i
  if (totalLength === undefined) {
    totalLength = 0
    for (i = 0; i < list.length; i++) {
      totalLength += list[i].length
    }
  }

  var buf = new Buffer(totalLength)
  var pos = 0
  for (i = 0; i < list.length; i++) {
    var item = list[i]
    item.copy(buf, pos)
    pos += item.length
  }
  return buf
}

Buffer.byteLength = function (str, encoding) {
  var ret
  str = str + ''
  switch (encoding || 'utf8') {
    case 'ascii':
    case 'binary':
    case 'raw':
      ret = str.length
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = str.length * 2
      break
    case 'hex':
      ret = str.length >>> 1
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8ToBytes(str).length
      break
    case 'base64':
      ret = base64ToBytes(str).length
      break
    default:
      ret = str.length
  }
  return ret
}

// pre-set for values that may exist in the future
Buffer.prototype.length = undefined
Buffer.prototype.parent = undefined

// toString(encoding, start=0, end=buffer.length)
Buffer.prototype.toString = function (encoding, start, end) {
  var loweredCase = false

  start = start >>> 0
  end = end === undefined || end === Infinity ? this.length : end >>> 0

  if (!encoding) encoding = 'utf8'
  if (start < 0) start = 0
  if (end > this.length) end = this.length
  if (end <= start) return ''

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'binary':
        return binarySlice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase)
          throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.equals = function (b) {
  if(!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max)
      str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  return Buffer.compare(this, b)
}

// `get` will be removed in Node 0.13+
Buffer.prototype.get = function (offset) {
  console.log('.get() is deprecated. Access using array indexes instead.')
  return this.readUInt8(offset)
}

// `set` will be removed in Node 0.13+
Buffer.prototype.set = function (v, offset) {
  console.log('.set() is deprecated. Access using array indexes instead.')
  return this.writeUInt8(v, offset)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new Error('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; i++) {
    var byte = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(byte)) throw new Error('Invalid hex string')
    buf[offset + i] = byte
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  var charsWritten = blitBuffer(utf8ToBytes(string), buf, offset, length)
  return charsWritten
}

function asciiWrite (buf, string, offset, length) {
  var charsWritten = blitBuffer(asciiToBytes(string), buf, offset, length)
  return charsWritten
}

function binaryWrite (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  var charsWritten = blitBuffer(base64ToBytes(string), buf, offset, length)
  return charsWritten
}

function utf16leWrite (buf, string, offset, length) {
  var charsWritten = blitBuffer(utf16leToBytes(string), buf, offset, length)
  return charsWritten
}

Buffer.prototype.write = function (string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length
      length = undefined
    }
  } else {  // legacy
    var swap = encoding
    encoding = offset
    offset = length
    length = swap
  }

  offset = Number(offset) || 0
  var remaining = this.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase()

  var ret
  switch (encoding) {
    case 'hex':
      ret = hexWrite(this, string, offset, length)
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8Write(this, string, offset, length)
      break
    case 'ascii':
      ret = asciiWrite(this, string, offset, length)
      break
    case 'binary':
      ret = binaryWrite(this, string, offset, length)
      break
    case 'base64':
      ret = base64Write(this, string, offset, length)
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = utf16leWrite(this, string, offset, length)
      break
    default:
      throw new TypeError('Unknown encoding: ' + encoding)
  }
  return ret
}

Buffer.prototype.toJSON = function () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  var res = ''
  var tmp = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    if (buf[i] <= 0x7F) {
      res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i])
      tmp = ''
    } else {
      tmp += '%' + buf[i].toString(16)
    }
  }

  return res + decodeUtf8Char(tmp)
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function binarySlice (buf, start, end) {
  return asciiSlice(buf, start, end)
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; i++) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len;
    if (start < 0)
      start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0)
      end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start)
    end = start

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    return Buffer._augment(this.subarray(start, end))
  } else {
    var sliceLen = end - start
    var newBuf = new Buffer(sliceLen, undefined, true)
    for (var i = 0; i < sliceLen; i++) {
      newBuf[i] = this[i + start]
    }
    return newBuf
  }
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0)
    throw new RangeError('offset is not uint')
  if (offset + ext > length)
    throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUInt8 = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
      ((this[offset + 1] << 16) |
      (this[offset + 2] << 8) |
      this[offset + 3])
}

Buffer.prototype.readInt8 = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80))
    return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)

  return (this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16) |
      (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
      (this[offset + 1] << 16) |
      (this[offset + 2] << 8) |
      (this[offset + 3])
}

Buffer.prototype.readFloatLE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')
  if (value > max || value < min) throw new TypeError('value is out of bounds')
  if (offset + ext > buf.length) throw new TypeError('index out of range')
}

Buffer.prototype.writeUInt8 = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = value
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
  } else objectWriteUInt16(this, value, offset, true)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = value
  } else objectWriteUInt16(this, value, offset, false)
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = value
  } else objectWriteUInt32(this, value, offset, true)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = value
  } else objectWriteUInt32(this, value, offset, false)
  return offset + 4
}

Buffer.prototype.writeInt8 = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = value
  return offset + 1
}

Buffer.prototype.writeInt16LE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
  } else objectWriteUInt16(this, value, offset, true)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = value
  } else objectWriteUInt16(this, value, offset, false)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else objectWriteUInt32(this, value, offset, true)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = value
  } else objectWriteUInt32(this, value, offset, false)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (value > max || value < min) throw new TypeError('value is out of bounds')
  if (offset + ext > buf.length) throw new TypeError('index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert)
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert)
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function (target, target_start, start, end) {
  var source = this

  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (!target_start) target_start = 0

  // Copy 0 bytes; we're done
  if (end === start) return
  if (target.length === 0 || source.length === 0) return

  // Fatal error conditions
  if (end < start) throw new TypeError('sourceEnd < sourceStart')
  if (target_start < 0 || target_start >= target.length)
    throw new TypeError('targetStart out of bounds')
  if (start < 0 || start >= source.length) throw new TypeError('sourceStart out of bounds')
  if (end < 0 || end > source.length) throw new TypeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length)
    end = this.length
  if (target.length - target_start < end - start)
    end = target.length - target_start + start

  var len = end - start

  if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < len; i++) {
      target[i + target_start] = this[i + start]
    }
  } else {
    target._set(this.subarray(start, start + len), target_start)
  }
}

// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function (value, start, end) {
  if (!value) value = 0
  if (!start) start = 0
  if (!end) end = this.length

  if (end < start) throw new TypeError('end < start')

  // Fill 0 bytes; we're done
  if (end === start) return
  if (this.length === 0) return

  if (start < 0 || start >= this.length) throw new TypeError('start out of bounds')
  if (end < 0 || end > this.length) throw new TypeError('end out of bounds')

  var i
  if (typeof value === 'number') {
    for (i = start; i < end; i++) {
      this[i] = value
    }
  } else {
    var bytes = utf8ToBytes(value.toString())
    var len = bytes.length
    for (i = start; i < end; i++) {
      this[i] = bytes[i % len]
    }
  }

  return this
}

/**
 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
 */
Buffer.prototype.toArrayBuffer = function () {
  if (typeof Uint8Array !== 'undefined') {
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      return (new Buffer(this)).buffer
    } else {
      var buf = new Uint8Array(this.length)
      for (var i = 0, len = buf.length; i < len; i += 1) {
        buf[i] = this[i]
      }
      return buf.buffer
    }
  } else {
    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')
  }
}

// HELPER FUNCTIONS
// ================

var BP = Buffer.prototype

/**
 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
 */
Buffer._augment = function (arr) {
  arr.constructor = Buffer
  arr._isBuffer = true

  // save reference to original Uint8Array get/set methods before overwriting
  arr._get = arr.get
  arr._set = arr.set

  // deprecated, will be removed in node 0.13+
  arr.get = BP.get
  arr.set = BP.set

  arr.write = BP.write
  arr.toString = BP.toString
  arr.toLocaleString = BP.toString
  arr.toJSON = BP.toJSON
  arr.equals = BP.equals
  arr.compare = BP.compare
  arr.copy = BP.copy
  arr.slice = BP.slice
  arr.readUInt8 = BP.readUInt8
  arr.readUInt16LE = BP.readUInt16LE
  arr.readUInt16BE = BP.readUInt16BE
  arr.readUInt32LE = BP.readUInt32LE
  arr.readUInt32BE = BP.readUInt32BE
  arr.readInt8 = BP.readInt8
  arr.readInt16LE = BP.readInt16LE
  arr.readInt16BE = BP.readInt16BE
  arr.readInt32LE = BP.readInt32LE
  arr.readInt32BE = BP.readInt32BE
  arr.readFloatLE = BP.readFloatLE
  arr.readFloatBE = BP.readFloatBE
  arr.readDoubleLE = BP.readDoubleLE
  arr.readDoubleBE = BP.readDoubleBE
  arr.writeUInt8 = BP.writeUInt8
  arr.writeUInt16LE = BP.writeUInt16LE
  arr.writeUInt16BE = BP.writeUInt16BE
  arr.writeUInt32LE = BP.writeUInt32LE
  arr.writeUInt32BE = BP.writeUInt32BE
  arr.writeInt8 = BP.writeInt8
  arr.writeInt16LE = BP.writeInt16LE
  arr.writeInt16BE = BP.writeInt16BE
  arr.writeInt32LE = BP.writeInt32LE
  arr.writeInt32BE = BP.writeInt32BE
  arr.writeFloatLE = BP.writeFloatLE
  arr.writeFloatBE = BP.writeFloatBE
  arr.writeDoubleLE = BP.writeDoubleLE
  arr.writeDoubleBE = BP.writeDoubleBE
  arr.fill = BP.fill
  arr.inspect = BP.inspect
  arr.toArrayBuffer = BP.toArrayBuffer

  return arr
}

var INVALID_BASE64_RE = /[^+\/0-9A-z]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function isArrayish (subject) {
  return isArray(subject) || Buffer.isBuffer(subject) ||
      subject && typeof subject === 'object' &&
      typeof subject.length === 'number'
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    var b = str.charCodeAt(i)
    if (b <= 0x7F) {
      byteArray.push(b)
    } else {
      var start = i
      if (b >= 0xD800 && b <= 0xDFFF) i++
      var h = encodeURIComponent(str.slice(start, i+1)).substr(1).split('%')
      for (var j = 0; j < h.length; j++) {
        byteArray.push(parseInt(h[j], 16))
      }
    }
  }
  return byteArray
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(str)
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; i++) {
    if ((i + offset >= dst.length) || (i >= src.length))
      break
    dst[i + offset] = src[i]
  }
  return i
}

function decodeUtf8Char (str) {
  try {
    return decodeURIComponent(str)
  } catch (err) {
    return String.fromCharCode(0xFFFD) // UTF 8 invalid char
  }
}

},{"base64-js":"/projects/blackice/node_modules/browserify/node_modules/buffer/node_modules/base64-js/lib/b64.js","ieee754":"/projects/blackice/node_modules/browserify/node_modules/buffer/node_modules/ieee754/index.js","is-array":"/projects/blackice/node_modules/browserify/node_modules/buffer/node_modules/is-array/index.js"}],"/projects/blackice/node_modules/browserify/node_modules/buffer/node_modules/base64-js/lib/b64.js":[function(require,module,exports){
var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

;(function (exports) {
	'use strict';

  var Arr = (typeof Uint8Array !== 'undefined')
    ? Uint8Array
    : Array

	var PLUS   = '+'.charCodeAt(0)
	var SLASH  = '/'.charCodeAt(0)
	var NUMBER = '0'.charCodeAt(0)
	var LOWER  = 'a'.charCodeAt(0)
	var UPPER  = 'A'.charCodeAt(0)

	function decode (elt) {
		var code = elt.charCodeAt(0)
		if (code === PLUS)
			return 62 // '+'
		if (code === SLASH)
			return 63 // '/'
		if (code < NUMBER)
			return -1 //no match
		if (code < NUMBER + 10)
			return code - NUMBER + 26 + 26
		if (code < UPPER + 26)
			return code - UPPER
		if (code < LOWER + 26)
			return code - LOWER + 26
	}

	function b64ToByteArray (b64) {
		var i, j, l, tmp, placeHolders, arr

		if (b64.length % 4 > 0) {
			throw new Error('Invalid string. Length must be a multiple of 4')
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		var len = b64.length
		placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

		// base64 is 4/3 + up to two characters of the original data
		arr = new Arr(b64.length * 3 / 4 - placeHolders)

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length

		var L = 0

		function push (v) {
			arr[L++] = v
		}

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
			push((tmp & 0xFF0000) >> 16)
			push((tmp & 0xFF00) >> 8)
			push(tmp & 0xFF)
		}

		if (placeHolders === 2) {
			tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
			push(tmp & 0xFF)
		} else if (placeHolders === 1) {
			tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
			push((tmp >> 8) & 0xFF)
			push(tmp & 0xFF)
		}

		return arr
	}

	function uint8ToBase64 (uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length

		function encode (num) {
			return lookup.charAt(num)
		}

		function tripletToBase64 (num) {
			return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
		}

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
			output += tripletToBase64(temp)
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1]
				output += encode(temp >> 2)
				output += encode((temp << 4) & 0x3F)
				output += '=='
				break
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
				output += encode(temp >> 10)
				output += encode((temp >> 4) & 0x3F)
				output += encode((temp << 2) & 0x3F)
				output += '='
				break
		}

		return output
	}

	exports.toByteArray = b64ToByteArray
	exports.fromByteArray = uint8ToBase64
}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))

},{}],"/projects/blackice/node_modules/browserify/node_modules/buffer/node_modules/ieee754/index.js":[function(require,module,exports){
exports.read = function(buffer, offset, isLE, mLen, nBytes) {
  var e, m,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      nBits = -7,
      i = isLE ? (nBytes - 1) : 0,
      d = isLE ? -1 : 1,
      s = buffer[offset + i];

  i += d;

  e = s & ((1 << (-nBits)) - 1);
  s >>= (-nBits);
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);

  m = e & ((1 << (-nBits)) - 1);
  e >>= (-nBits);
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity);
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
      i = isLE ? 0 : (nBytes - 1),
      d = isLE ? 1 : -1,
      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);

  e = (e << mLen) | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);

  buffer[offset + i - d] |= s * 128;
};

},{}],"/projects/blackice/node_modules/browserify/node_modules/buffer/node_modules/is-array/index.js":[function(require,module,exports){

/**
 * isArray
 */

var isArray = Array.isArray;

/**
 * toString
 */

var str = Object.prototype.toString;

/**
 * Whether or not the given `val`
 * is an array.
 *
 * example:
 *
 *        isArray([]);
 *        // > true
 *        isArray(arguments);
 *        // > false
 *        isArray('');
 *        // > false
 *
 * @param {mixed} val
 * @return {bool}
 */

module.exports = isArray || function (val) {
  return !! val && '[object Array]' == str.call(val);
};

},{}],"/projects/blackice/node_modules/canvas-app/index.js":[function(require,module,exports){
var isGL = require('is-webgl-context');
var getGL = require('webgl-context');
var debounce = require('debounce');
var addEvent = require('add-event-listener');

function isCanvasContext(obj) {
    var ctx2d = typeof CanvasRenderingContext2D !== 'undefined' && obj instanceof CanvasRenderingContext2D;
    return obj && (ctx2d || isGL(obj));
}

function CanvasApp(render, options) {
    if (!(this instanceof CanvasApp))
        return new CanvasApp(render, options);

    //allow options to be passed as first argument
    if (typeof render === 'object' && render) {
        options = render;
        render = null;
    }

    render = typeof render === 'function' ? render : options.onRender;

    options = options||{};
    options.retina = typeof options.retina === "boolean" ? options.retina : true;
    
    var hasWidth = typeof options.width === "number", 
        hasHeight = typeof options.height === "number";

    //if either width or height is specified, don't auto-resize to the window...
    if (hasWidth || hasHeight) 
        options.ignoreResize = true;

    options.width = hasWidth ? options.width : window.innerWidth;
    options.height = hasHeight ? options.height : window.innerHeight;

    var DPR = options.retina ? (window.devicePixelRatio||1) : 1; 

    //setup the canvas
    var canvas,
        context,
        attribs = options.contextAttributes||{};

    this.isWebGL = false;

    //if user provided a context object
    if (isCanvasContext(options.context)) {
        context = options.context;
        canvas = context.canvas;
    }

    //otherwise allow for a string to set one up
    if (!canvas)
        canvas = options.canvas || document.createElement("canvas");

    canvas.width = options.width * DPR;
    canvas.height = options.height * DPR;

    if (!context) {
        if (options.context === "webgl" || options.context === "experimental-webgl") {
            context = getGL({ canvas: canvas, attributes: attribs });
            if (!context) {
                throw "WebGL Context Not Supported -- try enabling it or using a different browser";
            }
        } else {
            context = canvas.getContext(options.context||"2d", attribs);
        }
    }

    this.isWebGL = isGL(context);

    if (options.retina) {
        canvas.style.width = options.width + 'px';
        canvas.style.height = options.height + 'px';
    }

    this.running = false;
    this.width = options.width;
    this.height = options.height;
    this.canvas = canvas;
    this.context = context;
    this.onResize = options.onResize;
    this._DPR = DPR;
    this._retina = options.retina;
    this._once = options.once;
    this._ignoreResize = options.ignoreResize;
    this._lastFrame = null;
    this._then = Date.now();

    //FPS counter
    this.fps = 60;
    this._frames = 0;
    this._prevTime = this._then;

    if (!this._ignoreResize) {
        options.resizeDebounce = typeof options.resizeDebounce === 'number'
                    ? options.resizeDebounce : 50;
        addEvent(window, "resize", debounce(function() {
            this.resize(window.innerWidth, window.innerHeight);
        }.bind(this), options.resizeDebounce, false));

        addEvent(window, "orientationchange", function() {
            this.resize(window.innerWidth, window.innerHeight);
        }.bind(this));
    }

    if (typeof render === "function") {
        this.onRender = render.bind(this);   
    } else {
        //dummy render function
        this.onRender = function (context, width, height, dt) { };
    }

    this.renderOnce = function() {
        var now = Date.now();
        var dt = (now-this._then);

        this._frames++;
        if (now > this._prevTime + 1000) {
            this.fps = Math.round((this._frames * 1000) / (now - this._prevTime));

            this._prevTime = now;
            this._frames = 0;
        }

        if (!this.isWebGL) {
            this.context.save();
            this.context.scale(this._DPR, this._DPR);
        } else {
            this.context.viewport(0, 0, this.width * this._DPR, this.height * this._DPR);
        }
        
        this.onRender(this.context, this.width, this.height, dt);

        if (!this.isWebGL)
            this.context.restore();

        this._then = now;
    };

    this._renderHandler = function() {
        if (!this.running) 
            return;
        
        if (!this._once) {
            this._lastFrame = requestAnimationFrame(this._renderHandler);
        }

        this.renderOnce();
    }.bind(this);

    if (typeof options.onReady === "function") {
        options.onReady.call(this, context, this.width, this.height);
    }
}

Object.defineProperty(CanvasApp.prototype, 'retinaEnabled', {

    set: function(v) {
        this._retina = v;
        this._DPR = this._retina ? (window.devicePixelRatio||1) : 1;
        this.resize(this.width, this.height);
    },

    get: function() {
        return this._retina;
    }
});

Object.defineProperty(CanvasApp.prototype, 'deviceWidth', {

    get: function() {
        return this.width * this._DPR;
    }
});

Object.defineProperty(CanvasApp.prototype, 'deviceHeight', {

    get: function() {
        return this.height * this._DPR;
    }
});

CanvasApp.prototype.resetFPS = function() {
    this._frames = 0;
    this._prevTime = Date.now();
    this._then = this._prevTime;
    this.fps = 60;
};

CanvasApp.prototype.start = function() {
    if (this.running)
        return;
    
    if (this._lastFrame) 
        cancelAnimationFrame(this._lastFrame);

    //reset FPS counter
    this.resetFPS();

    this.running = true;
    this._lastFrame = requestAnimationFrame(this._renderHandler);
};

CanvasApp.prototype.stop = function() {
    if (this._lastFrame) {
        cancelAnimationFrame(this._lastFrame);
        this._lastFrame = null;
    }
    this.running = false;
};

CanvasApp.prototype.resize = function(width, height) {
    var canvas = this.canvas;

    this.width = width;
    this.height = height;
    canvas.width = this.width * this._DPR;
    canvas.height = this.height * this._DPR;

    if (this._retina) {
        canvas.style.width = this.width + 'px';
        canvas.style.height = this.height + 'px';
    }

    if (this._once)
        requestAnimationFrame(this._renderHandler);
    if (typeof this.onResize === "function")
        this.onResize(this.width, this.height);
};

module.exports = CanvasApp;
},{"add-event-listener":"/projects/blackice/node_modules/canvas-app/node_modules/add-event-listener/index.js","debounce":"/projects/blackice/node_modules/canvas-app/node_modules/debounce/index.js","is-webgl-context":"/projects/blackice/node_modules/canvas-app/node_modules/is-webgl-context/index.js","webgl-context":"/projects/blackice/node_modules/canvas-app/node_modules/webgl-context/index.js"}],"/projects/blackice/node_modules/canvas-app/node_modules/add-event-listener/index.js":[function(require,module,exports){
addEventListener.removeEventListener = removeEventListener
addEventListener.addEventListener = addEventListener

module.exports = addEventListener

var Events = null

function addEventListener(el, eventName, listener, useCapture) {
  Events = Events || (
    document.addEventListener ?
    {add: stdAttach, rm: stdDetach} :
    {add: oldIEAttach, rm: oldIEDetach}
  )
  
  return Events.add(el, eventName, listener, useCapture)
}

function removeEventListener(el, eventName, listener, useCapture) {
  Events = Events || (
    document.addEventListener ?
    {add: stdAttach, rm: stdDetach} :
    {add: oldIEAttach, rm: oldIEDetach}
  )
  
  return Events.rm(el, eventName, listener, useCapture)
}

function stdAttach(el, eventName, listener, useCapture) {
  el.addEventListener(eventName, listener, useCapture)
}

function stdDetach(el, eventName, listener, useCapture) {
  el.removeEventListener(eventName, listener, useCapture)
}

function oldIEAttach(el, eventName, listener, useCapture) {
  if(useCapture) {
    throw new Error('cannot useCapture in oldIE')
  }

  el.attachEvent('on' + eventName, listener)
}

function oldIEDetach(el, eventName, listener, useCapture) {
  el.detachEvent('on' + eventName, listener)
}

},{}],"/projects/blackice/node_modules/canvas-app/node_modules/debounce/index.js":[function(require,module,exports){

/**
 * Module dependencies.
 */

var now = require('date-now');

/**
 * Returns a function, that, as long as it continues to be invoked, will not
 * be triggered. The function will be called after it stops being called for
 * N milliseconds. If `immediate` is passed, trigger the function on the
 * leading edge, instead of the trailing.
 *
 * @source underscore.js
 * @see http://unscriptable.com/2009/03/20/debouncing-javascript-methods/
 * @param {Function} function to wrap
 * @param {Number} timeout in ms (`100`)
 * @param {Boolean} whether to execute at the beginning (`false`)
 * @api public
 */

module.exports = function debounce(func, wait, immediate){
  var timeout, args, context, timestamp, result;
  if (null == wait) wait = 100;

  function later() {
    var last = now() - timestamp;

    if (last < wait && last > 0) {
      timeout = setTimeout(later, wait - last);
    } else {
      timeout = null;
      if (!immediate) {
        result = func.apply(context, args);
        if (!timeout) context = args = null;
      }
    }
  };

  return function debounced() {
    context = this;
    args = arguments;
    timestamp = now();
    var callNow = immediate && !timeout;
    if (!timeout) timeout = setTimeout(later, wait);
    if (callNow) {
      result = func.apply(context, args);
      context = args = null;
    }

    return result;
  };
};

},{"date-now":"/projects/blackice/node_modules/canvas-app/node_modules/debounce/node_modules/date-now/index.js"}],"/projects/blackice/node_modules/canvas-app/node_modules/debounce/node_modules/date-now/index.js":[function(require,module,exports){
module.exports = Date.now || now

function now() {
    return new Date().getTime()
}

},{}],"/projects/blackice/node_modules/canvas-app/node_modules/is-webgl-context/index.js":[function(require,module,exports){
module.exports = function(ctx) {
	if (!ctx) return false
	var gl = ctx
	//compatibility with Chrome WebGL Inspector Addon
	if (typeof ctx.rawgl !== 'undefined')
		gl = ctx.rawgl
	if (typeof WebGLRenderingContext !== 'undefined' && gl instanceof WebGLRenderingContext)
		return true
	return false
}
},{}],"/projects/blackice/node_modules/canvas-app/node_modules/webgl-context/index.js":[function(require,module,exports){
module.exports = function(opts) {
    opts = opts||{};
    var canvas = opts.canvas || document.createElement("canvas");
    if (typeof opts.width === "number")
        canvas.width = opts.width;
    if (typeof opts.height === "number")
        canvas.height = opts.height;
    
    var attribs = (opts.attributes || opts.attribs || {});
    try {
        gl = (canvas.getContext('webgl', attribs) || canvas.getContext('experimental-webgl', attribs));
    } catch (e) {
        gl = null;
    }
    return gl;
};
},{}],"/projects/blackice/node_modules/clamp/index.js":[function(require,module,exports){
module.exports = clamp

function clamp(value, min, max) {
  return min < max
    ? (value < min ? min : value > max ? max : value)
    : (value < max ? max : value > min ? min : value)
}

},{}],"/projects/blackice/node_modules/domready/ready.js":[function(require,module,exports){
/*!
  * domready (c) Dustin Diaz 2014 - License MIT
  */
!function (name, definition) {

  if (typeof module != 'undefined') module.exports = definition()
  else if (typeof define == 'function' && typeof define.amd == 'object') define(definition)
  else this[name] = definition()

}('domready', function () {

  var fns = [], listener
    , doc = document
    , hack = doc.documentElement.doScroll
    , domContentLoaded = 'DOMContentLoaded'
    , loaded = (hack ? /^loaded|^c/ : /^loaded|^i|^c/).test(doc.readyState)


  if (!loaded)
  doc.addEventListener(domContentLoaded, listener = function () {
    doc.removeEventListener(domContentLoaded, listener)
    loaded = 1
    while (listener = fns.shift()) listener()
  })

  return function (fn) {
    loaded ? fn() : fns.push(fn)
  }

});

},{}],"/projects/blackice/node_modules/gl-mat4/identity.js":[function(require,module,exports){
module.exports = identity;

/**
 * Set a mat4 to the identity matrix
 *
 * @param {mat4} out the receiving matrix
 * @returns {mat4} out
 */
function identity(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
};
},{}],"/projects/blackice/node_modules/gl-mat4/multiply.js":[function(require,module,exports){
module.exports = multiply;

/**
 * Multiplies two mat4's
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
function multiply(out, a, b) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

    // Cache only the current line of the second matrix
    var b0  = b[0], b1 = b[1], b2 = b[2], b3 = b[3];  
    out[0] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[1] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[2] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[3] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[4]; b1 = b[5]; b2 = b[6]; b3 = b[7];
    out[4] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[5] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[6] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[7] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[8]; b1 = b[9]; b2 = b[10]; b3 = b[11];
    out[8] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[9] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[10] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[11] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[12]; b1 = b[13]; b2 = b[14]; b3 = b[15];
    out[12] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[13] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[14] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[15] = b0*a03 + b1*a13 + b2*a23 + b3*a33;
    return out;
};
},{}],"/projects/blackice/node_modules/gl-mat4/scale.js":[function(require,module,exports){
module.exports = scale;

/**
 * Scales the mat4 by the dimensions in the given vec3
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {vec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 **/
function scale(out, a, v) {
    var x = v[0], y = v[1], z = v[2];

    out[0] = a[0] * x;
    out[1] = a[1] * x;
    out[2] = a[2] * x;
    out[3] = a[3] * x;
    out[4] = a[4] * y;
    out[5] = a[5] * y;
    out[6] = a[6] * y;
    out[7] = a[7] * y;
    out[8] = a[8] * z;
    out[9] = a[9] * z;
    out[10] = a[10] * z;
    out[11] = a[11] * z;
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};
},{}],"/projects/blackice/node_modules/gl-mat4/translate.js":[function(require,module,exports){
module.exports = translate;

/**
 * Translate a mat4 by the given vector
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to translate
 * @param {vec3} v vector to translate by
 * @returns {mat4} out
 */
function translate(out, a, v) {
    var x = v[0], y = v[1], z = v[2],
        a00, a01, a02, a03,
        a10, a11, a12, a13,
        a20, a21, a22, a23;

    if (a === out) {
        out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
        out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
        out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
        out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
    } else {
        a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
        a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
        a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

        out[0] = a00; out[1] = a01; out[2] = a02; out[3] = a03;
        out[4] = a10; out[5] = a11; out[6] = a12; out[7] = a13;
        out[8] = a20; out[9] = a21; out[10] = a22; out[11] = a23;

        out[12] = a00 * x + a10 * y + a20 * z + a[12];
        out[13] = a01 * x + a11 * y + a21 * z + a[13];
        out[14] = a02 * x + a12 * y + a22 * z + a[14];
        out[15] = a03 * x + a13 * y + a23 * z + a[15];
    }

    return out;
};
},{}],"/projects/blackice/node_modules/gl-texture2d/node_modules/ndarray-ops/ndarray-ops.js":[function(require,module,exports){
"use strict"

var compile = require("cwise-compiler")

var EmptyProc = {
  body: "",
  args: [],
  thisVars: [],
  localVars: []
}

function fixup(x) {
  if(!x) {
    return EmptyProc
  }
  for(var i=0; i<x.args.length; ++i) {
    var a = x.args[i]
    if(i === 0) {
      x.args[i] = {name: a, lvalue:true, rvalue: !!x.rvalue, count:x.count||1 }
    } else {
      x.args[i] = {name: a, lvalue:false, rvalue:true, count: 1}
    }
  }
  if(!x.thisVars) {
    x.thisVars = []
  }
  if(!x.localVars) {
    x.localVars = []
  }
  return x
}

function pcompile(user_args) {
  return compile({
    args:     user_args.args,
    pre:      fixup(user_args.pre),
    body:     fixup(user_args.body),
    post:     fixup(user_args.proc),
    funcName: user_args.funcName
  })
}

function makeOp(user_args) {
  var args = []
  for(var i=0; i<user_args.args.length; ++i) {
    args.push("a"+i)
  }
  var wrapper = new Function("P", [
    "return function ", user_args.funcName, "_ndarrayops(", args.join(","), ") {P(", args.join(","), ");return a0}"
  ].join(""))
  return wrapper(pcompile(user_args))
}

var assign_ops = {
  add:  "+",
  sub:  "-",
  mul:  "*",
  div:  "/",
  mod:  "%",
  band: "&",
  bor:  "|",
  bxor: "^",
  lshift: "<<",
  rshift: ">>",
  rrshift: ">>>"
}
;(function(){
  for(var id in assign_ops) {
    var op = assign_ops[id]
    exports[id] = makeOp({
      args: ["array","array","array"],
      body: {args:["a","b","c"],
             body: "a=b"+op+"c"},
      funcName: id
    })
    exports[id+"eq"] = makeOp({
      args: ["array","array"],
      body: {args:["a","b"],
             body:"a"+op+"=b"},
      rvalue: true,
      funcName: id+"eq"
    })
    exports[id+"s"] = makeOp({
      args: ["array", "array", "scalar"],
      body: {args:["a","b","s"],
             body:"a=b"+op+"s"},
      funcName: id+"s"
    })
    exports[id+"seq"] = makeOp({
      args: ["array","scalar"],
      body: {args:["a","s"],
             body:"a"+op+"=s"},
      rvalue: true,
      funcName: id+"seq"
    })
  }
})();

var unary_ops = {
  not: "!",
  bnot: "~",
  neg: "-",
  recip: "1.0/"
}
;(function(){
  for(var id in unary_ops) {
    var op = unary_ops[id]
    exports[id] = makeOp({
      args: ["array", "array"],
      body: {args:["a","b"],
             body:"a="+op+"b"},
      funcName: id
    })
    exports[id+"eq"] = makeOp({
      args: ["array"],
      body: {args:["a"],
             body:"a="+op+"a"},
      rvalue: true,
      count: 2,
      funcName: id+"eq"
    })
  }
})();

var binary_ops = {
  and: "&&",
  or: "||",
  eq: "===",
  neq: "!==",
  lt: "<",
  gt: ">",
  leq: "<=",
  geq: ">="
}
;(function() {
  for(var id in binary_ops) {
    var op = binary_ops[id]
    exports[id] = makeOp({
      args: ["array","array","array"],
      body: {args:["a", "b", "c"],
             body:"a=b"+op+"c"},
      funcName: id
    })
    exports[id+"s"] = makeOp({
      args: ["array","array","scalar"],
      body: {args:["a", "b", "s"],
             body:"a=b"+op+"s"},
      funcName: id+"s"
    })
    exports[id+"eq"] = makeOp({
      args: ["array", "array"],
      body: {args:["a", "b"],
             body:"a=a"+op+"b"},
      rvalue:true,
      count:2,
      funcName: id+"eq"
    })
    exports[id+"seq"] = makeOp({
      args: ["array", "scalar"],
      body: {args:["a","s"],
             body:"a=a"+op+"s"},
      rvalue:true,
      count:2,
      funcName: id+"seq"
    })
  }
})();

var math_unary = [
  "abs",
  "acos",
  "asin",
  "atan",
  "ceil",
  "cos",
  "exp",
  "floor",
  "log",
  "round",
  "sin",
  "sqrt",
  "tan"
]
;(function() {
  for(var i=0; i<math_unary.length; ++i) {
    var f = math_unary[i]
    exports[f] = makeOp({
                    args: ["array", "array"],
                    pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
                    body: {args:["a","b"], body:"a=this_f(b)", thisVars:["this_f"]},
                    funcName: f
                  })
    exports[f+"eq"] = makeOp({
                      args: ["array"],
                      pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
                      body: {args: ["a"], body:"a=this_f(a)", thisVars:["this_f"]},
                      rvalue: true,
                      count: 2,
                      funcName: f+"eq"
                    })
  }
})();

var math_comm = [
  "max",
  "min",
  "atan2",
  "pow"
]
;(function(){
  for(var i=0; i<math_comm.length; ++i) {
    var f= math_comm[i]
    exports[f] = makeOp({
                  args:["array", "array", "array"],
                  pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
                  body: {args:["a","b","c"], body:"a=this_f(b,c)", thisVars:["this_f"]},
                  funcName: f
                })
    exports[f+"s"] = makeOp({
                  args:["array", "array", "scalar"],
                  pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
                  body: {args:["a","b","c"], body:"a=this_f(b,c)", thisVars:["this_f"]},
                  funcName: f+"s"
                  })
    exports[f+"eq"] = makeOp({ args:["array", "array"],
                  pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
                  body: {args:["a","b"], body:"a=this_f(a,b)", thisVars:["this_f"]},
                  rvalue: true,
                  count: 2,
                  funcName: f+"eq"
                  })
    exports[f+"seq"] = makeOp({ args:["array", "scalar"],
                  pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
                  body: {args:["a","b"], body:"a=this_f(a,b)", thisVars:["this_f"]},
                  rvalue:true,
                  count:2,
                  funcName: f+"seq"
                  })
  }
})();

var math_noncomm = [
  "atan2",
  "pow"
]
;(function(){
  for(var i=0; i<math_noncomm.length; ++i) {
    var f= math_noncomm[i]
    exports[f+"op"] = makeOp({
                  args:["array", "array", "array"],
                  pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
                  body: {args:["a","b","c"], body:"a=this_f(c,b)", thisVars:["this_f"]},
                  funcName: f+"op"
                })
    exports[f+"ops"] = makeOp({
                  args:["array", "array", "scalar"],
                  pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
                  body: {args:["a","b","c"], body:"a=this_f(c,b)", thisVars:["this_f"]},
                  funcName: f+"ops"
                  })
    exports[f+"opeq"] = makeOp({ args:["array", "array"],
                  pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
                  body: {args:["a","b"], body:"a=this_f(b,a)", thisVars:["this_f"]},
                  rvalue: true,
                  count: 2,
                  funcName: f+"opeq"
                  })
    exports[f+"opseq"] = makeOp({ args:["array", "scalar"],
                  pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
                  body: {args:["a","b"], body:"a=this_f(b,a)", thisVars:["this_f"]},
                  rvalue:true,
                  count:2,
                  funcName: f+"opseq"
                  })
  }
})();

exports.any = compile({
  args:["array"],
  pre: EmptyProc,
  body: {args:[{name:"a", lvalue:false, rvalue:true, count:1}], body: "if(a){return true}", localVars: [], thisVars: []},
  post: {args:[], localVars:[], thisVars:[], body:"return false"},
  funcName: "any"
})

exports.all = compile({
  args:["array"],
  pre: EmptyProc,
  body: {args:[{name:"x", lvalue:false, rvalue:true, count:1}], body: "if(!x){return false}", localVars: [], thisVars: []},
  post: {args:[], localVars:[], thisVars:[], body:"return true"},
  funcName: "all"
})

exports.sum = compile({
  args:["array"],
  pre: {args:[], localVars:[], thisVars:["this_s"], body:"this_s=0"},
  body: {args:[{name:"a", lvalue:false, rvalue:true, count:1}], body: "this_s+=a", localVars: [], thisVars: ["this_s"]},
  post: {args:[], localVars:[], thisVars:["this_s"], body:"return this_s"},
  funcName: "sum"
})

exports.prod = compile({
  args:["array"],
  pre: {args:[], localVars:[], thisVars:["this_s"], body:"this_s=1"},
  body: {args:[{name:"a", lvalue:false, rvalue:true, count:1}], body: "this_s*=a", localVars: [], thisVars: ["this_s"]},
  post: {args:[], localVars:[], thisVars:["this_s"], body:"return this_s"},
  funcName: "prod"
})

exports.norm2squared = compile({
  args:["array"],
  pre: {args:[], localVars:[], thisVars:["this_s"], body:"this_s=0"},
  body: {args:[{name:"a", lvalue:false, rvalue:true, count:2}], body: "this_s+=a*a", localVars: [], thisVars: ["this_s"]},
  post: {args:[], localVars:[], thisVars:["this_s"], body:"return this_s"},
  funcName: "norm2squared"
})
  
exports.norm2 = compile({
  args:["array"],
  pre: {args:[], localVars:[], thisVars:["this_s"], body:"this_s=0"},
  body: {args:[{name:"a", lvalue:false, rvalue:true, count:2}], body: "this_s+=a*a", localVars: [], thisVars: ["this_s"]},
  post: {args:[], localVars:[], thisVars:["this_s"], body:"return Math.sqrt(this_s)"},
  funcName: "norm2"
})
  

exports.norminf = compile({
  args:["array"],
  pre: {args:[], localVars:[], thisVars:["this_s"], body:"this_s=0"},
  body: {args:[{name:"a", lvalue:false, rvalue:true, count:4}], body:"if(-a>this_s){this_s=-a}else if(a>this_s){this_s=a}", localVars: [], thisVars: ["this_s"]},
  post: {args:[], localVars:[], thisVars:["this_s"], body:"return this_s"},
  funcName: "norminf"
})

exports.norm1 = compile({
  args:["array"],
  pre: {args:[], localVars:[], thisVars:["this_s"], body:"this_s=0"},
  body: {args:[{name:"a", lvalue:false, rvalue:true, count:3}], body: "this_s+=a<0?-a:a", localVars: [], thisVars: ["this_s"]},
  post: {args:[], localVars:[], thisVars:["this_s"], body:"return this_s"},
  funcName: "norm1"
})

exports.sup = compile({
  args: [ "array" ],
  pre:
   { body: "this_h=-Infinity",
     args: [],
     thisVars: [ "this_h" ],
     localVars: [] },
  body:
   { body: "if(_inline_1_arg0_>this_h)this_h=_inline_1_arg0_",
     args: [{"name":"_inline_1_arg0_","lvalue":false,"rvalue":true,"count":2} ],
     thisVars: [ "this_h" ],
     localVars: [] },
  post:
   { body: "return this_h",
     args: [],
     thisVars: [ "this_h" ],
     localVars: [] }
 })

exports.inf = compile({
  args: [ "array" ],
  pre:
   { body: "this_h=Infinity",
     args: [],
     thisVars: [ "this_h" ],
     localVars: [] },
  body:
   { body: "if(_inline_1_arg0_<this_h)this_h=_inline_1_arg0_",
     args: [{"name":"_inline_1_arg0_","lvalue":false,"rvalue":true,"count":2} ],
     thisVars: [ "this_h" ],
     localVars: [] },
  post:
   { body: "return this_h",
     args: [],
     thisVars: [ "this_h" ],
     localVars: [] }
 })

exports.argmin = compile({
  args:["index","array","shape"],
  pre:{
    body:"{this_v=Infinity;this_i=_inline_0_arg2_.slice(0)}",
    args:[
      {name:"_inline_0_arg0_",lvalue:false,rvalue:false,count:0},
      {name:"_inline_0_arg1_",lvalue:false,rvalue:false,count:0},
      {name:"_inline_0_arg2_",lvalue:false,rvalue:true,count:1}
      ],
    thisVars:["this_i","this_v"],
    localVars:[]},
  body:{
    body:"{if(_inline_1_arg1_<this_v){this_v=_inline_1_arg1_;for(var _inline_1_k=0;_inline_1_k<_inline_1_arg0_.length;++_inline_1_k){this_i[_inline_1_k]=_inline_1_arg0_[_inline_1_k]}}}",
    args:[
      {name:"_inline_1_arg0_",lvalue:false,rvalue:true,count:2},
      {name:"_inline_1_arg1_",lvalue:false,rvalue:true,count:2}],
    thisVars:["this_i","this_v"],
    localVars:["_inline_1_k"]},
  post:{
    body:"{return this_i}",
    args:[],
    thisVars:["this_i"],
    localVars:[]}
})

exports.argmax = compile({
  args:["index","array","shape"],
  pre:{
    body:"{this_v=-Infinity;this_i=_inline_0_arg2_.slice(0)}",
    args:[
      {name:"_inline_0_arg0_",lvalue:false,rvalue:false,count:0},
      {name:"_inline_0_arg1_",lvalue:false,rvalue:false,count:0},
      {name:"_inline_0_arg2_",lvalue:false,rvalue:true,count:1}
      ],
    thisVars:["this_i","this_v"],
    localVars:[]},
  body:{
    body:"{if(_inline_1_arg1_>this_v){this_v=_inline_1_arg1_;for(var _inline_1_k=0;_inline_1_k<_inline_1_arg0_.length;++_inline_1_k){this_i[_inline_1_k]=_inline_1_arg0_[_inline_1_k]}}}",
    args:[
      {name:"_inline_1_arg0_",lvalue:false,rvalue:true,count:2},
      {name:"_inline_1_arg1_",lvalue:false,rvalue:true,count:2}],
    thisVars:["this_i","this_v"],
    localVars:["_inline_1_k"]},
  post:{
    body:"{return this_i}",
    args:[],
    thisVars:["this_i"],
    localVars:[]}
})  

exports.random = makeOp({
  args: ["array"],
  pre: {args:[], body:"this_f=Math.random", thisVars:["this_f"]},
  body: {args: ["a"], body:"a=this_f()", thisVars:["this_f"]},
  funcName: "random"
})

exports.assign = makeOp({
  args:["array", "array"],
  body: {args:["a", "b"], body:"a=b"},
  funcName: "assign" })

exports.assigns = makeOp({
  args:["array", "scalar"],
  body: {args:["a", "b"], body:"a=b"},
  funcName: "assigns" })


exports.equals = compile({
  args:["array", "array"],
  pre: EmptyProc,
  body: {args:[{name:"x", lvalue:false, rvalue:true, count:1},
               {name:"y", lvalue:false, rvalue:true, count:1}], 
        body: "if(x!==y){return false}", 
        localVars: [], 
        thisVars: []},
  post: {args:[], localVars:[], thisVars:[], body:"return true"},
  funcName: "equals"
})



},{"cwise-compiler":"/projects/blackice/node_modules/gl-texture2d/node_modules/ndarray-ops/node_modules/cwise-compiler/compiler.js"}],"/projects/blackice/node_modules/gl-texture2d/node_modules/ndarray-ops/node_modules/cwise-compiler/compiler.js":[function(require,module,exports){
"use strict"

var createThunk = require("./lib/thunk.js")

function Procedure() {
  this.argTypes = []
  this.shimArgs = []
  this.arrayArgs = []
  this.scalarArgs = []
  this.offsetArgs = []
  this.offsetArgIndex = []
  this.indexArgs = []
  this.shapeArgs = []
  this.funcName = ""
  this.pre = null
  this.body = null
  this.post = null
  this.debug = false
}

function compileCwise(user_args) {
  //Create procedure
  var proc = new Procedure()
  
  //Parse blocks
  proc.pre    = user_args.pre
  proc.body   = user_args.body
  proc.post   = user_args.post

  //Parse arguments
  var proc_args = user_args.args.slice(0)
  proc.argTypes = proc_args
  for(var i=0; i<proc_args.length; ++i) {
    var arg_type = proc_args[i]
    if(arg_type === "array") {
      proc.arrayArgs.push(i)
      proc.shimArgs.push("array" + i)
      if(i < proc.pre.args.length && proc.pre.args[i].count>0) {
        throw new Error("cwise: pre() block may not reference array args")
      }
      if(i < proc.post.args.length && proc.post.args[i].count>0) {
        throw new Error("cwise: post() block may not reference array args")
      }
    } else if(arg_type === "scalar") {
      proc.scalarArgs.push(i)
      proc.shimArgs.push("scalar" + i)
    } else if(arg_type === "index") {
      proc.indexArgs.push(i)
      if(i < proc.pre.args.length && proc.pre.args[i].count > 0) {
        throw new Error("cwise: pre() block may not reference array index")
      }
      if(i < proc.body.args.length && proc.body.args[i].lvalue) {
        throw new Error("cwise: body() block may not write to array index")
      }
      if(i < proc.post.args.length && proc.post.args[i].count > 0) {
        throw new Error("cwise: post() block may not reference array index")
      }
    } else if(arg_type === "shape") {
      proc.shapeArgs.push(i)
      if(i < proc.pre.args.length && proc.pre.args[i].lvalue) {
        throw new Error("cwise: pre() block may not write to array shape")
      }
      if(i < proc.body.args.length && proc.body.args[i].lvalue) {
        throw new Error("cwise: body() block may not write to array shape")
      }
      if(i < proc.post.args.length && proc.post.args[i].lvalue) {
        throw new Error("cwise: post() block may not write to array shape")
      }
    } else if(typeof arg_type === "object" && arg_type.offset) {
      proc.argTypes[i] = "offset"
      proc.offsetArgs.push({ array: arg_type.array, offset:arg_type.offset })
      proc.offsetArgIndex.push(i)
    } else {
      throw new Error("cwise: Unknown argument type " + proc_args[i])
    }
  }
  
  //Make sure at least one array argument was specified
  if(proc.arrayArgs.length <= 0) {
    throw new Error("cwise: No array arguments specified")
  }
  
  //Make sure arguments are correct
  if(proc.pre.args.length > proc_args.length) {
    throw new Error("cwise: Too many arguments in pre() block")
  }
  if(proc.body.args.length > proc_args.length) {
    throw new Error("cwise: Too many arguments in body() block")
  }
  if(proc.post.args.length > proc_args.length) {
    throw new Error("cwise: Too many arguments in post() block")
  }

  //Check debug flag
  proc.debug = !!user_args.printCode || !!user_args.debug
  
  //Retrieve name
  proc.funcName = user_args.funcName || "cwise"
  
  //Read in block size
  proc.blockSize = user_args.blockSize || 64

  return createThunk(proc)
}

module.exports = compileCwise

},{"./lib/thunk.js":"/projects/blackice/node_modules/gl-texture2d/node_modules/ndarray-ops/node_modules/cwise-compiler/lib/thunk.js"}],"/projects/blackice/node_modules/gl-texture2d/node_modules/ndarray-ops/node_modules/cwise-compiler/lib/compile.js":[function(require,module,exports){
"use strict"

var uniq = require("uniq")

function innerFill(order, proc, body) {
  var dimension = order.length
    , nargs = proc.arrayArgs.length
    , has_index = proc.indexArgs.length>0
    , code = []
    , vars = []
    , idx=0, pidx=0, i, j
  for(i=0; i<dimension; ++i) {
    vars.push(["i",i,"=0"].join(""))
  }
  //Compute scan deltas
  for(j=0; j<nargs; ++j) {
    for(i=0; i<dimension; ++i) {
      pidx = idx
      idx = order[i]
      if(i === 0) {
        vars.push(["d",j,"s",i,"=t",j,"p",idx].join(""))
      } else {
        vars.push(["d",j,"s",i,"=(t",j,"p",idx,"-s",pidx,"*t",j,"p",pidx,")"].join(""))
      }
    }
  }
  code.push("var " + vars.join(","))
  //Scan loop
  for(i=dimension-1; i>=0; --i) {
    idx = order[i]
    code.push(["for(i",i,"=0;i",i,"<s",idx,";++i",i,"){"].join(""))
  }
  //Push body of inner loop
  code.push(body)
  //Advance scan pointers
  for(i=0; i<dimension; ++i) {
    pidx = idx
    idx = order[i]
    for(j=0; j<nargs; ++j) {
      code.push(["p",j,"+=d",j,"s",i].join(""))
    }
    if(has_index) {
      if(i > 0) {
        code.push(["index[",pidx,"]-=s",pidx].join(""))
      }
      code.push(["++index[",idx,"]"].join(""))
    }
    code.push("}")
  }
  return code.join("\n")
}

function outerFill(matched, order, proc, body) {
  var dimension = order.length
    , nargs = proc.arrayArgs.length
    , blockSize = proc.blockSize
    , has_index = proc.indexArgs.length > 0
    , code = []
  for(var i=0; i<nargs; ++i) {
    code.push(["var offset",i,"=p",i].join(""))
  }
  //Generate matched loops
  for(var i=matched; i<dimension; ++i) {
    code.push(["for(var j"+i+"=SS[", order[i], "]|0;j", i, ">0;){"].join(""))
    code.push(["if(j",i,"<",blockSize,"){"].join(""))
    code.push(["s",order[i],"=j",i].join(""))
    code.push(["j",i,"=0"].join(""))
    code.push(["}else{s",order[i],"=",blockSize].join(""))
    code.push(["j",i,"-=",blockSize,"}"].join(""))
    if(has_index) {
      code.push(["index[",order[i],"]=j",i].join(""))
    }
  }
  for(var i=0; i<nargs; ++i) {
    var indexStr = ["offset"+i]
    for(var j=matched; j<dimension; ++j) {
      indexStr.push(["j",j,"*t",i,"p",order[j]].join(""))
    }
    code.push(["p",i,"=(",indexStr.join("+"),")"].join(""))
  }
  code.push(innerFill(order, proc, body))
  for(var i=matched; i<dimension; ++i) {
    code.push("}")
  }
  return code.join("\n")
}

//Count the number of compatible inner orders
function countMatches(orders) {
  var matched = 0, dimension = orders[0].length
  while(matched < dimension) {
    for(var j=1; j<orders.length; ++j) {
      if(orders[j][matched] !== orders[0][matched]) {
        return matched
      }
    }
    ++matched
  }
  return matched
}

//Processes a block according to the given data types
function processBlock(block, proc, dtypes) {
  var code = block.body
  var pre = []
  var post = []
  for(var i=0; i<block.args.length; ++i) {
    var carg = block.args[i]
    if(carg.count <= 0) {
      continue
    }
    var re = new RegExp(carg.name, "g")
    var ptrStr = ""
    var arrNum = proc.arrayArgs.indexOf(i)
    switch(proc.argTypes[i]) {
      case "offset":
        var offArgIndex = proc.offsetArgIndex.indexOf(i)
        var offArg = proc.offsetArgs[offArgIndex]
        arrNum = offArg.array
        ptrStr = "+q" + offArgIndex
      case "array":
        ptrStr = "p" + arrNum + ptrStr
        var localStr = "l" + i
        var arrStr = "a" + arrNum
        if(carg.count === 1) {
          if(dtypes[arrNum] === "generic") {
            if(carg.lvalue) {
              pre.push(["var ", localStr, "=", arrStr, ".get(", ptrStr, ")"].join(""))
              code = code.replace(re, localStr)
              post.push([arrStr, ".set(", ptrStr, ",", localStr,")"].join(""))
            } else {
              code = code.replace(re, [arrStr, ".get(", ptrStr, ")"].join(""))
            }
          } else {
            code = code.replace(re, [arrStr, "[", ptrStr, "]"].join(""))
          }
        } else if(dtypes[arrNum] === "generic") {
          pre.push(["var ", localStr, "=", arrStr, ".get(", ptrStr, ")"].join(""))
          code = code.replace(re, localStr)
          if(carg.lvalue) {
            post.push([arrStr, ".set(", ptrStr, ",", localStr,")"].join(""))
          }
        } else {
          pre.push(["var ", localStr, "=", arrStr, "[", ptrStr, "]"].join(""))
          code = code.replace(re, localStr)
          if(carg.lvalue) {
            post.push([arrStr, "[", ptrStr, "]=", localStr].join(""))
          }
        }
      break
      case "scalar":
        code = code.replace(re, "Y" + proc.scalarArgs.indexOf(i))
      break
      case "index":
        code = code.replace(re, "index")
      break
      case "shape":
        code = code.replace(re, "shape")
      break
    }
  }
  return [pre.join("\n"), code, post.join("\n")].join("\n").trim()
}

function typeSummary(dtypes) {
  var summary = new Array(dtypes.length)
  var allEqual = true
  for(var i=0; i<dtypes.length; ++i) {
    var t = dtypes[i]
    var digits = t.match(/\d+/)
    if(!digits) {
      digits = ""
    } else {
      digits = digits[0]
    }
    if(t.charAt(0) === 0) {
      summary[i] = "u" + t.charAt(1) + digits
    } else {
      summary[i] = t.charAt(0) + digits
    }
    if(i > 0) {
      allEqual = allEqual && summary[i] === summary[i-1]
    }
  }
  if(allEqual) {
    return summary[0]
  }
  return summary.join("")
}

//Generates a cwise operator
function generateCWiseOp(proc, typesig) {

  //Compute dimension
  var dimension = typesig[1].length|0
  var orders = new Array(proc.arrayArgs.length)
  var dtypes = new Array(proc.arrayArgs.length)

  //First create arguments for procedure
  var arglist = ["SS"]
  var code = ["'use strict'"]
  var vars = []
  
  for(var j=0; j<dimension; ++j) {
    vars.push(["s", j, "=SS[", j, "]"].join(""))
  }
  for(var i=0; i<proc.arrayArgs.length; ++i) {
    arglist.push("a"+i)
    arglist.push("t"+i)
    arglist.push("p"+i)
    dtypes[i] = typesig[2*i]
    orders[i] = typesig[2*i+1]
    
    for(var j=0; j<dimension; ++j) {
      vars.push(["t",i,"p",j,"=t",i,"[",j,"]"].join(""))
    }
  }
  for(var i=0; i<proc.scalarArgs.length; ++i) {
    arglist.push("Y" + i)
  }
  if(proc.shapeArgs.length > 0) {
    vars.push("shape=SS.slice(0)")
  }
  if(proc.indexArgs.length > 0) {
    var zeros = new Array(dimension)
    for(var i=0; i<dimension; ++i) {
      zeros[i] = "0"
    }
    vars.push(["index=[", zeros.join(","), "]"].join(""))
  }
  for(var i=0; i<proc.offsetArgs.length; ++i) {
    var off_arg = proc.offsetArgs[i]
    var init_string = []
    for(var j=0; j<off_arg.offset.length; ++j) {
      if(off_arg.offset[j] === 0) {
        continue
      } else if(off_arg.offset[j] === 1) {
        init_string.push(["t", off_arg.array, "p", j].join(""))      
      } else {
        init_string.push([off_arg.offset[j], "*t", off_arg.array, "p", j].join(""))
      }
    }
    if(init_string.length === 0) {
      vars.push("q" + i + "=0")
    } else {
      vars.push(["q", i, "=", init_string.join("+")].join(""))
    }
  }

  //Prepare this variables
  var thisVars = uniq([].concat(proc.pre.thisVars)
                      .concat(proc.body.thisVars)
                      .concat(proc.post.thisVars))
  vars = vars.concat(thisVars)
  code.push("var " + vars.join(","))
  for(var i=0; i<proc.arrayArgs.length; ++i) {
    code.push("p"+i+"|=0")
  }
  
  //Inline prelude
  if(proc.pre.body.length > 3) {
    code.push(processBlock(proc.pre, proc, dtypes))
  }

  //Process body
  var body = processBlock(proc.body, proc, dtypes)
  var matched = countMatches(orders)
  if(matched < dimension) {
    code.push(outerFill(matched, orders[0], proc, body))
  } else {
    code.push(innerFill(orders[0], proc, body))
  }

  //Inline epilog
  if(proc.post.body.length > 3) {
    code.push(processBlock(proc.post, proc, dtypes))
  }
  
  if(proc.debug) {
    console.log("Generated cwise routine for ", typesig, ":\n\n", code.join("\n"))
  }
  
  var loopName = [(proc.funcName||"unnamed"), "_cwise_loop_", orders[0].join("s"),"m",matched,typeSummary(dtypes)].join("")
  var f = new Function(["function ",loopName,"(", arglist.join(","),"){", code.join("\n"),"} return ", loopName].join(""))
  return f()
}
module.exports = generateCWiseOp
},{"uniq":"/projects/blackice/node_modules/gl-texture2d/node_modules/ndarray-ops/node_modules/cwise-compiler/node_modules/uniq/uniq.js"}],"/projects/blackice/node_modules/gl-texture2d/node_modules/ndarray-ops/node_modules/cwise-compiler/lib/thunk.js":[function(require,module,exports){
"use strict"

var compile = require("./compile.js")

function createThunk(proc) {
  var code = ["'use strict'", "var CACHED={}"]
  var vars = []
  var thunkName = proc.funcName + "_cwise_thunk"
  
  //Build thunk
  code.push(["return function ", thunkName, "(", proc.shimArgs.join(","), "){"].join(""))
  var typesig = []
  var string_typesig = []
  var proc_args = [["array",proc.arrayArgs[0],".shape"].join("")]
  for(var i=0; i<proc.arrayArgs.length; ++i) {
    var j = proc.arrayArgs[i]
    vars.push(["t", j, "=array", j, ".dtype,",
               "r", j, "=array", j, ".order"].join(""))
    typesig.push("t" + j)
    typesig.push("r" + j)
    string_typesig.push("t"+j)
    string_typesig.push("r"+j+".join()")
    proc_args.push("array" + j + ".data")
    proc_args.push("array" + j + ".stride")
    proc_args.push("array" + j + ".offset|0")
  }
  for(var i=0; i<proc.scalarArgs.length; ++i) {
    proc_args.push("scalar" + proc.scalarArgs[i])
  }
  vars.push(["type=[", string_typesig.join(","), "].join()"].join(""))
  vars.push("proc=CACHED[type]")
  code.push("var " + vars.join(","))
  
  code.push(["if(!proc){",
             "CACHED[type]=proc=compile([", typesig.join(","), "])}",
             "return proc(", proc_args.join(","), ")}"].join(""))

  if(proc.debug) {
    console.log("Generated thunk:", code.join("\n"))
  }
  
  //Compile thunk
  var thunk = new Function("compile", code.join("\n"))
  return thunk(compile.bind(undefined, proc))
}

module.exports = createThunk

},{"./compile.js":"/projects/blackice/node_modules/gl-texture2d/node_modules/ndarray-ops/node_modules/cwise-compiler/lib/compile.js"}],"/projects/blackice/node_modules/gl-texture2d/node_modules/ndarray-ops/node_modules/cwise-compiler/node_modules/uniq/uniq.js":[function(require,module,exports){
"use strict"

function unique_pred(list, compare) {
  var ptr = 1
    , len = list.length
    , a=list[0], b=list[0]
  for(var i=1; i<len; ++i) {
    b = a
    a = list[i]
    if(compare(a, b)) {
      if(i === ptr) {
        ptr++
        continue
      }
      list[ptr++] = a
    }
  }
  list.length = ptr
  return list
}

function unique_eq(list) {
  var ptr = 1
    , len = list.length
    , a=list[0], b = list[0]
  for(var i=1; i<len; ++i, b=a) {
    b = a
    a = list[i]
    if(a !== b) {
      if(i === ptr) {
        ptr++
        continue
      }
      list[ptr++] = a
    }
  }
  list.length = ptr
  return list
}

function unique(list, compare, sorted) {
  if(list.length === 0) {
    return list
  }
  if(compare) {
    if(!sorted) {
      list.sort(compare)
    }
    return unique_pred(list, compare)
  }
  if(!sorted) {
    list.sort()
  }
  return unique_eq(list)
}

module.exports = unique

},{}],"/projects/blackice/node_modules/gl-texture2d/node_modules/ndarray/ndarray.js":[function(require,module,exports){
(function (Buffer){
var iota = require("iota-array")

var arrayMethods = [
  "concat",
  "join",
  "slice",
  "toString",
  "indexOf",
  "lastIndexOf",
  "forEach",
  "every",
  "some",
  "filter",
  "map",
  "reduce",
  "reduceRight"
]

var hasTypedArrays  = ((typeof Float64Array) !== "undefined")
var hasBuffer       = ((typeof Buffer) !== "undefined")

function compare1st(a, b) {
  return a[0] - b[0]
}

function order() {
  var stride = this.stride
  var terms = new Array(stride.length)
  var i
  for(i=0; i<terms.length; ++i) {
    terms[i] = [Math.abs(stride[i]), i]
  }
  terms.sort(compare1st)
  var result = new Array(terms.length)
  for(i=0; i<result.length; ++i) {
    result[i] = terms[i][1]
  }
  return result
}

function compileConstructor(dtype, dimension) {
  var className = ["View", dimension, "d", dtype].join("")
  if(dimension < 0) {
    className = "View_Nil" + dtype
  }
  var useGetters = (dtype === "generic")
  
  if(dimension === -1) {
    //Special case for trivial arrays
    var code = 
      "function "+className+"(a){this.data=a;};\
var proto="+className+".prototype;\
proto.dtype='"+dtype+"';\
proto.index=function(){return -1};\
proto.size=0;\
proto.dimension=-1;\
proto.shape=proto.stride=proto.order=[];\
proto.lo=proto.hi=proto.transpose=proto.step=\
function(){return new "+className+"(this.data);};\
proto.get=proto.set=function(){};\
proto.pick=function(){return null};\
return function construct_"+className+"(a){return new "+className+"(a);}"
    var procedure = new Function(code)
    return procedure()
  } else if(dimension === 0) {
    //Special case for 0d arrays
    var code =
      "function "+className+"(a,d) {\
this.data = a;\
this.offset = d\
};\
var proto="+className+".prototype;\
proto.dtype='"+dtype+"';\
proto.index=function(){return this.offset};\
proto.dimension=0;\
proto.size=1;\
proto.shape=\
proto.stride=\
proto.order=[];\
proto.lo=\
proto.hi=\
proto.transpose=\
proto.step=function "+className+"_copy() {\
return new "+className+"(this.data,this.offset)\
};\
proto.pick=function "+className+"_pick(){\
return TrivialArray(this.data);\
};\
proto.valueOf=proto.get=function "+className+"_get(){\
return "+(useGetters ? "this.data.get(this.offset)" : "this.data[this.offset]")+
"};\
proto.set=function "+className+"_set(v){\
return "+(useGetters ? "this.data.set(this.offset,v)" : "this.data[this.offset]=v")+"\
};\
return function construct_"+className+"(a,b,c,d){return new "+className+"(a,d)}"
    var procedure = new Function("TrivialArray", code)
    return procedure(CACHED_CONSTRUCTORS[dtype][0])
  }

  var code = ["'use strict'"]
    
  //Create constructor for view
  var indices = iota(dimension)
  var args = indices.map(function(i) { return "i"+i })
  var index_str = "this.offset+" + indices.map(function(i) {
        return "this._stride" + i + "*i" + i
      }).join("+")
  code.push("function "+className+"(a,"+
    indices.map(function(i) {
      return "b"+i
    }).join(",") + "," +
    indices.map(function(i) {
      return "c"+i
    }).join(",") + ",d){this.data=a")
  for(var i=0; i<dimension; ++i) {
    code.push("this._shape"+i+"=b"+i+"|0")
  }
  for(var i=0; i<dimension; ++i) {
    code.push("this._stride"+i+"=c"+i+"|0")
  }
  code.push("this.offset=d|0}",
    "var proto="+className+".prototype",
    "proto.dtype='"+dtype+"'",
    "proto.dimension="+dimension)
  
  //view.stride and view.shape
  var strideClassName = "VStride" + dimension + "d" + dtype
  var shapeClassName = "VShape" + dimension + "d" + dtype
  var props = {"stride":strideClassName, "shape":shapeClassName}
  for(var prop in props) {
    var arrayName = props[prop]
    code.push(
      "function " + arrayName + "(v) {this._v=v} var aproto=" + arrayName + ".prototype",
      "aproto.length="+dimension)
    
    var array_elements = []
    for(var i=0; i<dimension; ++i) {
      array_elements.push(["this._v._", prop, i].join(""))
    }
    code.push(
      "aproto.toJSON=function " + arrayName + "_toJSON(){return [" + array_elements.join(",") + "]}",
      "aproto.valueOf=aproto.toString=function " + arrayName + "_toString(){return [" + array_elements.join(",") + "].join()}")
    
    for(var i=0; i<dimension; ++i) {
      code.push("Object.defineProperty(aproto,"+i+",{get:function(){return this._v._"+prop+i+"},set:function(v){return this._v._"+prop+i+"=v|0},enumerable:true})")
    }
    for(var i=0; i<arrayMethods.length; ++i) {
      if(arrayMethods[i] in Array.prototype) {
        code.push("aproto."+arrayMethods[i]+"=Array.prototype."+arrayMethods[i])
      }
    }
    code.push(["Object.defineProperty(proto,'",prop,"',{get:function ", arrayName, "_get(){return new ", arrayName, "(this)},set: function ", arrayName, "_set(v){"].join(""))
    for(var i=0; i<dimension; ++i) {
      code.push("this._"+prop+i+"=v["+i+"]|0")
    }
    code.push("return v}})")
  }
  
  //view.size:
  code.push("Object.defineProperty(proto,'size',{get:function "+className+"_size(){\
return "+indices.map(function(i) { return "this._shape"+i }).join("*"),
"}})")

  //view.order:
  if(dimension === 1) {
    code.push("proto.order=[0]")
  } else {
    code.push("Object.defineProperty(proto,'order',{get:")
    if(dimension < 4) {
      code.push("function "+className+"_order(){")
      if(dimension === 2) {
        code.push("return (Math.abs(this._stride0)>Math.abs(this._stride1))?[1,0]:[0,1]}})")
      } else if(dimension === 3) {
        code.push(
"var s0=Math.abs(this._stride0),s1=Math.abs(this._stride1),s2=Math.abs(this._stride2);\
if(s0>s1){\
if(s1>s2){\
return [2,1,0];\
}else if(s0>s2){\
return [1,2,0];\
}else{\
return [1,0,2];\
}\
}else if(s0>s2){\
return [2,0,1];\
}else if(s2>s1){\
return [0,1,2];\
}else{\
return [0,2,1];\
}}})")
      }
    } else {
      code.push("ORDER})")
    }
  }
  
  //view.set(i0, ..., v):
  code.push(
"proto.set=function "+className+"_set("+args.join(",")+",v){")
  if(useGetters) {
    code.push("return this.data.set("+index_str+",v)}")
  } else {
    code.push("return this.data["+index_str+"]=v}")
  }
  
  //view.get(i0, ...):
  code.push("proto.get=function "+className+"_get("+args.join(",")+"){")
  if(useGetters) {
    code.push("return this.data.get("+index_str+")}")
  } else {
    code.push("return this.data["+index_str+"]}")
  }
  
  //view.index:
  code.push(
    "proto.index=function "+className+"_index(", args.join(), "){return "+index_str+"}")

  //view.hi():
  code.push("proto.hi=function "+className+"_hi("+args.join(",")+"){return new "+className+"(this.data,"+
    indices.map(function(i) {
      return ["(typeof i",i,"!=='number'||i",i,"<0)?this._shape", i, ":i", i,"|0"].join("")
    }).join(",")+","+
    indices.map(function(i) {
      return "this._stride"+i
    }).join(",")+",this.offset)}")
  
  //view.lo():
  var a_vars = indices.map(function(i) { return "a"+i+"=this._shape"+i })
  var c_vars = indices.map(function(i) { return "c"+i+"=this._stride"+i })
  code.push("proto.lo=function "+className+"_lo("+args.join(",")+"){var b=this.offset,d=0,"+a_vars.join(",")+","+c_vars.join(","))
  for(var i=0; i<dimension; ++i) {
    code.push(
"if(typeof i"+i+"==='number'&&i"+i+">=0){\
d=i"+i+"|0;\
b+=c"+i+"*d;\
a"+i+"-=d}")
  }
  code.push("return new "+className+"(this.data,"+
    indices.map(function(i) {
      return "a"+i
    }).join(",")+","+
    indices.map(function(i) {
      return "c"+i
    }).join(",")+",b)}")
  
  //view.step():
  code.push("proto.step=function "+className+"_step("+args.join(",")+"){var "+
    indices.map(function(i) {
      return "a"+i+"=this._shape"+i
    }).join(",")+","+
    indices.map(function(i) {
      return "b"+i+"=this._stride"+i
    }).join(",")+",c=this.offset,d=0,ceil=Math.ceil")
  for(var i=0; i<dimension; ++i) {
    code.push(
"if(typeof i"+i+"==='number'){\
d=i"+i+"|0;\
if(d<0){\
c+=b"+i+"*(a"+i+"-1);\
a"+i+"=ceil(-a"+i+"/d)\
}else{\
a"+i+"=ceil(a"+i+"/d)\
}\
b"+i+"*=d\
}")
  }
  code.push("return new "+className+"(this.data,"+
    indices.map(function(i) {
      return "a" + i
    }).join(",")+","+
    indices.map(function(i) {
      return "b" + i
    }).join(",")+",c)}")
  
  //view.transpose():
  var tShape = new Array(dimension)
  var tStride = new Array(dimension)
  for(var i=0; i<dimension; ++i) {
    tShape[i] = "a[i"+i+"]"
    tStride[i] = "b[i"+i+"]"
  }
  code.push("proto.transpose=function "+className+"_transpose("+args+"){"+
    args.map(function(n,idx) { return n + "=(" + n + "===undefined?" + idx + ":" + n + "|0)"}).join(";"),
    "var a=this.shape,b=this.stride;return new "+className+"(this.data,"+tShape.join(",")+","+tStride.join(",")+",this.offset)}")
  
  //view.pick():
  code.push("proto.pick=function "+className+"_pick("+args+"){var a=[],b=[],c=this.offset")
  for(var i=0; i<dimension; ++i) {
    code.push("if(typeof i"+i+"==='number'&&i"+i+">=0){c=(c+this._stride"+i+"*i"+i+")|0}else{a.push(this._shape"+i+");b.push(this._stride"+i+")}")
  }
  code.push("var ctor=CTOR_LIST[a.length+1];return ctor(this.data,a,b,c)}")
    
  //Add return statement
  code.push("return function construct_"+className+"(data,shape,stride,offset){return new "+className+"(data,"+
    indices.map(function(i) {
      return "shape["+i+"]"
    }).join(",")+","+
    indices.map(function(i) {
      return "stride["+i+"]"
    }).join(",")+",offset)}")

  //Compile procedure
  var procedure = new Function("CTOR_LIST", "ORDER", code.join("\n"))
  return procedure(CACHED_CONSTRUCTORS[dtype], order)
}

function arrayDType(data) {
  if(hasBuffer) {
    if(Buffer.isBuffer(data)) {
      return "buffer"
    }
  }
  if(hasTypedArrays) {
    switch(Object.prototype.toString.call(data)) {
      case "[object Float64Array]":
        return "float64"
      case "[object Float32Array]":
        return "float32"
      case "[object Int8Array]":
        return "int8"
      case "[object Int16Array]":
        return "int16"
      case "[object Int32Array]":
        return "int32"
      case "[object Uint8Array]":
        return "uint8"
      case "[object Uint16Array]":
        return "uint16"
      case "[object Uint32Array]":
        return "uint32"
      case "[object Uint8ClampedArray]":
        return "uint8_clamped"
    }
  }
  if(Array.isArray(data)) {
    return "array"
  }
  return "generic"
}

var CACHED_CONSTRUCTORS = {
  "float32":[],
  "float64":[],
  "int8":[],
  "int16":[],
  "int32":[],
  "uint8":[],
  "uint16":[],
  "uint32":[],
  "array":[],
  "uint8_clamped":[],
  "buffer":[],
  "generic":[]
}

;(function() {
  for(var id in CACHED_CONSTRUCTORS) {
    CACHED_CONSTRUCTORS[id].push(compileConstructor(id, -1))
  }
});

function wrappedNDArrayCtor(data, shape, stride, offset) {
  if(data === undefined) {
    var ctor = CACHED_CONSTRUCTORS.array[0]
    return ctor([])
  } else if(typeof data === "number") {
    data = [data]
  }
  if(shape === undefined) {
    shape = [ data.length ]
  }
  var d = shape.length
  if(stride === undefined) {
    stride = new Array(d)
    for(var i=d-1, sz=1; i>=0; --i) {
      stride[i] = sz
      sz *= shape[i]
    }
  }
  if(offset === undefined) {
    offset = 0
    for(var i=0; i<d; ++i) {
      if(stride[i] < 0) {
        offset -= (shape[i]-1)*stride[i]
      }
    }
  }
  var dtype = arrayDType(data)
  var ctor_list = CACHED_CONSTRUCTORS[dtype]
  while(ctor_list.length <= d+1) {
    ctor_list.push(compileConstructor(dtype, ctor_list.length-1))
  }
  var ctor = ctor_list[d+1]
  return ctor(data, shape, stride, offset)
}

module.exports = wrappedNDArrayCtor
}).call(this,require("buffer").Buffer)
},{"buffer":"/projects/blackice/node_modules/browserify/node_modules/buffer/index.js","iota-array":"/projects/blackice/node_modules/gl-texture2d/node_modules/ndarray/node_modules/iota-array/iota.js"}],"/projects/blackice/node_modules/gl-texture2d/node_modules/ndarray/node_modules/iota-array/iota.js":[function(require,module,exports){
"use strict"

function iota(n) {
  var result = new Array(n)
  for(var i=0; i<n; ++i) {
    result[i] = i
  }
  return result
}

module.exports = iota
},{}],"/projects/blackice/node_modules/gl-texture2d/node_modules/typedarray-pool/node_modules/bit-twiddle/twiddle.js":[function(require,module,exports){
/**
 * Bit twiddling hacks for JavaScript.
 *
 * Author: Mikola Lysenko
 *
 * Ported from Stanford bit twiddling hack library:
 *    http://graphics.stanford.edu/~seander/bithacks.html
 */

"use strict"; "use restrict";

//Number of bits in an integer
var INT_BITS = 32;

//Constants
exports.INT_BITS  = INT_BITS;
exports.INT_MAX   =  0x7fffffff;
exports.INT_MIN   = -1<<(INT_BITS-1);

//Returns -1, 0, +1 depending on sign of x
exports.sign = function(v) {
  return (v > 0) - (v < 0);
}

//Computes absolute value of integer
exports.abs = function(v) {
  var mask = v >> (INT_BITS-1);
  return (v ^ mask) - mask;
}

//Computes minimum of integers x and y
exports.min = function(x, y) {
  return y ^ ((x ^ y) & -(x < y));
}

//Computes maximum of integers x and y
exports.max = function(x, y) {
  return x ^ ((x ^ y) & -(x < y));
}

//Checks if a number is a power of two
exports.isPow2 = function(v) {
  return !(v & (v-1)) && (!!v);
}

//Computes log base 2 of v
exports.log2 = function(v) {
  var r, shift;
  r =     (v > 0xFFFF) << 4; v >>>= r;
  shift = (v > 0xFF  ) << 3; v >>>= shift; r |= shift;
  shift = (v > 0xF   ) << 2; v >>>= shift; r |= shift;
  shift = (v > 0x3   ) << 1; v >>>= shift; r |= shift;
  return r | (v >> 1);
}

//Computes log base 10 of v
exports.log10 = function(v) {
  return  (v >= 1000000000) ? 9 : (v >= 100000000) ? 8 : (v >= 10000000) ? 7 :
          (v >= 1000000) ? 6 : (v >= 100000) ? 5 : (v >= 10000) ? 4 :
          (v >= 1000) ? 3 : (v >= 100) ? 2 : (v >= 10) ? 1 : 0;
}

//Counts number of bits
exports.popCount = function(v) {
  v = v - ((v >>> 1) & 0x55555555);
  v = (v & 0x33333333) + ((v >>> 2) & 0x33333333);
  return ((v + (v >>> 4) & 0xF0F0F0F) * 0x1010101) >>> 24;
}

//Counts number of trailing zeros
function countTrailingZeros(v) {
  var c = 32;
  v &= -v;
  if (v) c--;
  if (v & 0x0000FFFF) c -= 16;
  if (v & 0x00FF00FF) c -= 8;
  if (v & 0x0F0F0F0F) c -= 4;
  if (v & 0x33333333) c -= 2;
  if (v & 0x55555555) c -= 1;
  return c;
}
exports.countTrailingZeros = countTrailingZeros;

//Rounds to next power of 2
exports.nextPow2 = function(v) {
  v += v === 0;
  --v;
  v |= v >>> 1;
  v |= v >>> 2;
  v |= v >>> 4;
  v |= v >>> 8;
  v |= v >>> 16;
  return v + 1;
}

//Rounds down to previous power of 2
exports.prevPow2 = function(v) {
  v |= v >>> 1;
  v |= v >>> 2;
  v |= v >>> 4;
  v |= v >>> 8;
  v |= v >>> 16;
  return v - (v>>>1);
}

//Computes parity of word
exports.parity = function(v) {
  v ^= v >>> 16;
  v ^= v >>> 8;
  v ^= v >>> 4;
  v &= 0xf;
  return (0x6996 >>> v) & 1;
}

var REVERSE_TABLE = new Array(256);

(function(tab) {
  for(var i=0; i<256; ++i) {
    var v = i, r = i, s = 7;
    for (v >>>= 1; v; v >>>= 1) {
      r <<= 1;
      r |= v & 1;
      --s;
    }
    tab[i] = (r << s) & 0xff;
  }
})(REVERSE_TABLE);

//Reverse bits in a 32 bit word
exports.reverse = function(v) {
  return  (REVERSE_TABLE[ v         & 0xff] << 24) |
          (REVERSE_TABLE[(v >>> 8)  & 0xff] << 16) |
          (REVERSE_TABLE[(v >>> 16) & 0xff] << 8)  |
           REVERSE_TABLE[(v >>> 24) & 0xff];
}

//Interleave bits of 2 coordinates with 16 bits.  Useful for fast quadtree codes
exports.interleave2 = function(x, y) {
  x &= 0xFFFF;
  x = (x | (x << 8)) & 0x00FF00FF;
  x = (x | (x << 4)) & 0x0F0F0F0F;
  x = (x | (x << 2)) & 0x33333333;
  x = (x | (x << 1)) & 0x55555555;

  y &= 0xFFFF;
  y = (y | (y << 8)) & 0x00FF00FF;
  y = (y | (y << 4)) & 0x0F0F0F0F;
  y = (y | (y << 2)) & 0x33333333;
  y = (y | (y << 1)) & 0x55555555;

  return x | (y << 1);
}

//Extracts the nth interleaved component
exports.deinterleave2 = function(v, n) {
  v = (v >>> n) & 0x55555555;
  v = (v | (v >>> 1))  & 0x33333333;
  v = (v | (v >>> 2))  & 0x0F0F0F0F;
  v = (v | (v >>> 4))  & 0x00FF00FF;
  v = (v | (v >>> 16)) & 0x000FFFF;
  return (v << 16) >> 16;
}


//Interleave bits of 3 coordinates, each with 10 bits.  Useful for fast octree codes
exports.interleave3 = function(x, y, z) {
  x &= 0x3FF;
  x  = (x | (x<<16)) & 4278190335;
  x  = (x | (x<<8))  & 251719695;
  x  = (x | (x<<4))  & 3272356035;
  x  = (x | (x<<2))  & 1227133513;

  y &= 0x3FF;
  y  = (y | (y<<16)) & 4278190335;
  y  = (y | (y<<8))  & 251719695;
  y  = (y | (y<<4))  & 3272356035;
  y  = (y | (y<<2))  & 1227133513;
  x |= (y << 1);
  
  z &= 0x3FF;
  z  = (z | (z<<16)) & 4278190335;
  z  = (z | (z<<8))  & 251719695;
  z  = (z | (z<<4))  & 3272356035;
  z  = (z | (z<<2))  & 1227133513;
  
  return x | (z << 2);
}

//Extracts nth interleaved component of a 3-tuple
exports.deinterleave3 = function(v, n) {
  v = (v >>> n)       & 1227133513;
  v = (v | (v>>>2))   & 3272356035;
  v = (v | (v>>>4))   & 251719695;
  v = (v | (v>>>8))   & 4278190335;
  v = (v | (v>>>16))  & 0x3FF;
  return (v<<22)>>22;
}

//Computes next combination in colexicographic order (this is mistakenly called nextPermutation on the bit twiddling hacks page)
exports.nextCombination = function(v) {
  var t = v | (v - 1);
  return (t + 1) | (((~t & -~t) - 1) >>> (countTrailingZeros(v) + 1));
}


},{}],"/projects/blackice/node_modules/gl-texture2d/node_modules/typedarray-pool/node_modules/dup/dup.js":[function(require,module,exports){
"use strict"

function dupe_array(count, value, i) {
  var c = count[i]|0
  if(c <= 0) {
    return []
  }
  var result = new Array(c), j
  if(i === count.length-1) {
    for(j=0; j<c; ++j) {
      result[j] = value
    }
  } else {
    for(j=0; j<c; ++j) {
      result[j] = dupe_array(count, value, i+1)
    }
  }
  return result
}

function dupe_number(count, value) {
  var result, i
  result = new Array(count)
  for(i=0; i<count; ++i) {
    result[i] = value
  }
  return result
}

function dupe(count, value) {
  if(typeof value === "undefined") {
    value = 0
  }
  switch(typeof count) {
    case "number":
      if(count > 0) {
        return dupe_number(count|0, value)
      }
    break
    case "object":
      if(typeof (count.length) === "number") {
        return dupe_array(count, value, 0)
      }
    break
  }
  return []
}

module.exports = dupe
},{}],"/projects/blackice/node_modules/gl-texture2d/node_modules/typedarray-pool/pool.js":[function(require,module,exports){
(function (global,Buffer){
'use strict'

var bits = require('bit-twiddle')
var dup = require('dup')

//Legacy pool support
if(!global.__TYPEDARRAY_POOL) {
  global.__TYPEDARRAY_POOL = {
      UINT8   : dup([32, 0])
    , UINT16  : dup([32, 0])
    , UINT32  : dup([32, 0])
    , INT8    : dup([32, 0])
    , INT16   : dup([32, 0])
    , INT32   : dup([32, 0])
    , FLOAT   : dup([32, 0])
    , DOUBLE  : dup([32, 0])
    , DATA    : dup([32, 0])
    , UINT8C  : dup([32, 0])
    , BUFFER  : dup([32, 0])
  }
}

var hasUint8C = (typeof Uint8ClampedArray) !== 'undefined'
var POOL = global.__TYPEDARRAY_POOL

//Upgrade pool
if(!POOL.UINT8C) {
  POOL.UINT8C = dup([32, 0])
}
if(!POOL.BUFFER) {
  POOL.BUFFER = dup([32, 0])
}

//New technique: Only allocate from ArrayBufferView and Buffer
var DATA    = POOL.DATA
  , BUFFER  = POOL.BUFFER

exports.free = function free(array) {
  if(Buffer.isBuffer(array)) {
    BUFFER[bits.log2(array.length)].push(array)
  } else {
    if(Object.prototype.toString.call(array) !== '[object ArrayBuffer]') {
      array = array.buffer
    }
    if(!array) {
      return
    }
    var n = array.length || array.byteLength
    var log_n = bits.log2(n)|0
    DATA[log_n].push(array)
  }
}

function freeArrayBuffer(buffer) {
  if(!buffer) {
    return
  }
  var n = buffer.length || buffer.byteLength
  var log_n = bits.log2(n)
  DATA[log_n].push(buffer)
}

function freeTypedArray(array) {
  freeArrayBuffer(array.buffer)
}

exports.freeUint8 =
exports.freeUint16 =
exports.freeUint32 =
exports.freeInt8 =
exports.freeInt16 =
exports.freeInt32 =
exports.freeFloat32 = 
exports.freeFloat =
exports.freeFloat64 = 
exports.freeDouble = 
exports.freeUint8Clamped = 
exports.freeDataView = freeTypedArray

exports.freeArrayBuffer = freeArrayBuffer

exports.freeBuffer = function freeBuffer(array) {
  BUFFER[bits.log2(array.length)].push(array)
}

exports.malloc = function malloc(n, dtype) {
  if(dtype === undefined || dtype === 'arraybuffer') {
    return mallocArrayBuffer(n)
  } else {
    switch(dtype) {
      case 'uint8':
        return mallocUint8(n)
      case 'uint16':
        return mallocUint16(n)
      case 'uint32':
        return mallocUint32(n)
      case 'int8':
        return mallocInt8(n)
      case 'int16':
        return mallocInt16(n)
      case 'int32':
        return mallocInt32(n)
      case 'float':
      case 'float32':
        return mallocFloat(n)
      case 'double':
      case 'float64':
        return mallocDouble(n)
      case 'uint8_clamped':
        return mallocUint8Clamped(n)
      case 'buffer':
        return mallocBuffer(n)
      case 'data':
      case 'dataview':
        return mallocDataView(n)

      default:
        return null
    }
  }
  return null
}

function mallocArrayBuffer(n) {
  var n = bits.nextPow2(n)
  var log_n = bits.log2(n)
  var d = DATA[log_n]
  if(d.length > 0) {
    return d.pop()
  }
  return new ArrayBuffer(n)
}
exports.mallocArrayBuffer = mallocArrayBuffer

function mallocUint8(n) {
  return new Uint8Array(mallocArrayBuffer(n), 0, n)
}
exports.mallocUint8 = mallocUint8

function mallocUint16(n) {
  return new Uint16Array(mallocArrayBuffer(2*n), 0, n)
}
exports.mallocUint16 = mallocUint16

function mallocUint32(n) {
  return new Uint32Array(mallocArrayBuffer(4*n), 0, n)
}
exports.mallocUint32 = mallocUint32

function mallocInt8(n) {
  return new Int8Array(mallocArrayBuffer(n), 0, n)
}
exports.mallocInt8 = mallocInt8

function mallocInt16(n) {
  return new Int16Array(mallocArrayBuffer(2*n), 0, n)
}
exports.mallocInt16 = mallocInt16

function mallocInt32(n) {
  return new Int32Array(mallocArrayBuffer(4*n), 0, n)
}
exports.mallocInt32 = mallocInt32

function mallocFloat(n) {
  return new Float32Array(mallocArrayBuffer(4*n), 0, n)
}
exports.mallocFloat32 = exports.mallocFloat = mallocFloat

function mallocDouble(n) {
  return new Float64Array(mallocArrayBuffer(8*n), 0, n)
}
exports.mallocFloat64 = exports.mallocDouble = mallocDouble

function mallocUint8Clamped(n) {
  if(hasUint8C) {
    return new Uint8ClampedArray(mallocArrayBuffer(n), 0, n)
  } else {
    return mallocUint8(n)
  }
}
exports.mallocUint8Clamped = mallocUint8Clamped

function mallocDataView(n) {
  return new DataView(mallocArrayBuffer(n), 0, n)
}
exports.mallocDataView = mallocDataView

function mallocBuffer(n) {
  n = bits.nextPow2(n)
  var log_n = bits.log2(n)
  var cache = BUFFER[log_n]
  if(cache.length > 0) {
    return cache.pop()
  }
  return new Buffer(n)
}
exports.mallocBuffer = mallocBuffer

exports.clearCache = function clearCache() {
  for(var i=0; i<32; ++i) {
    POOL.UINT8[i].length = 0
    POOL.UINT16[i].length = 0
    POOL.UINT32[i].length = 0
    POOL.INT8[i].length = 0
    POOL.INT16[i].length = 0
    POOL.INT32[i].length = 0
    POOL.FLOAT[i].length = 0
    POOL.DOUBLE[i].length = 0
    POOL.UINT8C[i].length = 0
    DATA[i].length = 0
    BUFFER[i].length = 0
  }
}
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer)
},{"bit-twiddle":"/projects/blackice/node_modules/gl-texture2d/node_modules/typedarray-pool/node_modules/bit-twiddle/twiddle.js","buffer":"/projects/blackice/node_modules/browserify/node_modules/buffer/index.js","dup":"/projects/blackice/node_modules/gl-texture2d/node_modules/typedarray-pool/node_modules/dup/dup.js"}],"/projects/blackice/node_modules/gl-texture2d/node_modules/webglew/node_modules/weakmap/weakmap.js":[function(require,module,exports){
/* (The MIT License)
 *
 * Copyright (c) 2012 Brandon Benvie <http://bbenvie.com>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
 * associated documentation files (the 'Software'), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge, publish, distribute,
 * sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included with all copies or
 * substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
 * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY  CLAIM,
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

// Original WeakMap implementation by Gozala @ https://gist.github.com/1269991
// Updated and bugfixed by Raynos @ https://gist.github.com/1638059
// Expanded by Benvie @ https://github.com/Benvie/harmony-collections

void function(global, undefined_, undefined){
  var getProps = Object.getOwnPropertyNames,
      defProp  = Object.defineProperty,
      toSource = Function.prototype.toString,
      create   = Object.create,
      hasOwn   = Object.prototype.hasOwnProperty,
      funcName = /^\n?function\s?(\w*)?_?\(/;


  function define(object, key, value){
    if (typeof key === 'function') {
      value = key;
      key = nameOf(value).replace(/_$/, '');
    }
    return defProp(object, key, { configurable: true, writable: true, value: value });
  }

  function nameOf(func){
    return typeof func !== 'function'
          ? '' : 'name' in func
          ? func.name : toSource.call(func).match(funcName)[1];
  }

  // ############
  // ### Data ###
  // ############

  var Data = (function(){
    var dataDesc = { value: { writable: true, value: undefined } },
        datalock = 'return function(k){if(k===s)return l}',
        uids     = create(null),

        createUID = function(){
          var key = Math.random().toString(36).slice(2);
          return key in uids ? createUID() : uids[key] = key;
        },

        globalID = createUID(),

        storage = function(obj){
          if (hasOwn.call(obj, globalID))
            return obj[globalID];

          if (!Object.isExtensible(obj))
            throw new TypeError("Object must be extensible");

          var store = create(null);
          defProp(obj, globalID, { value: store });
          return store;
        };

    // common per-object storage area made visible by patching getOwnPropertyNames'
    define(Object, function getOwnPropertyNames(obj){
      var props = getProps(obj);
      if (hasOwn.call(obj, globalID))
        props.splice(props.indexOf(globalID), 1);
      return props;
    });

    function Data(){
      var puid = createUID(),
          secret = {};

      this.unlock = function(obj){
        var store = storage(obj);
        if (hasOwn.call(store, puid))
          return store[puid](secret);

        var data = create(null, dataDesc);
        defProp(store, puid, {
          value: new Function('s', 'l', datalock)(secret, data)
        });
        return data;
      }
    }

    define(Data.prototype, function get(o){ return this.unlock(o).value });
    define(Data.prototype, function set(o, v){ this.unlock(o).value = v });

    return Data;
  }());


  var WM = (function(data){
    var validate = function(key){
      if (key == null || typeof key !== 'object' && typeof key !== 'function')
        throw new TypeError("Invalid WeakMap key");
    }

    var wrap = function(collection, value){
      var store = data.unlock(collection);
      if (store.value)
        throw new TypeError("Object is already a WeakMap");
      store.value = value;
    }

    var unwrap = function(collection){
      var storage = data.unlock(collection).value;
      if (!storage)
        throw new TypeError("WeakMap is not generic");
      return storage;
    }

    var initialize = function(weakmap, iterable){
      if (iterable !== null && typeof iterable === 'object' && typeof iterable.forEach === 'function') {
        iterable.forEach(function(item, i){
          if (item instanceof Array && item.length === 2)
            set.call(weakmap, iterable[i][0], iterable[i][1]);
        });
      }
    }


    function WeakMap(iterable){
      if (this === global || this == null || this === WeakMap.prototype)
        return new WeakMap(iterable);

      wrap(this, new Data);
      initialize(this, iterable);
    }

    function get(key){
      validate(key);
      var value = unwrap(this).get(key);
      return value === undefined_ ? undefined : value;
    }

    function set(key, value){
      validate(key);
      // store a token for explicit undefined so that "has" works correctly
      unwrap(this).set(key, value === undefined ? undefined_ : value);
    }

    function has(key){
      validate(key);
      return unwrap(this).get(key) !== undefined;
    }

    function delete_(key){
      validate(key);
      var data = unwrap(this),
          had = data.get(key) !== undefined;
      data.set(key, undefined);
      return had;
    }

    function toString(){
      unwrap(this);
      return '[object WeakMap]';
    }

    try {
      var src = ('return '+delete_).replace('e_', '\\u0065'),
          del = new Function('unwrap', 'validate', src)(unwrap, validate);
    } catch (e) {
      var del = delete_;
    }

    var src = (''+Object).split('Object');
    var stringifier = function toString(){
      return src[0] + nameOf(this) + src[1];
    };

    define(stringifier, stringifier);

    var prep = { __proto__: [] } instanceof Array
      ? function(f){ f.__proto__ = stringifier }
      : function(f){ define(f, stringifier) };

    prep(WeakMap);

    [toString, get, set, has, del].forEach(function(method){
      define(WeakMap.prototype, method);
      prep(method);
    });

    return WeakMap;
  }(new Data));

  var defaultCreator = Object.create
    ? function(){ return Object.create(null) }
    : function(){ return {} };

  function createStorage(creator){
    var weakmap = new WM;
    creator || (creator = defaultCreator);

    function storage(object, value){
      if (value || arguments.length === 2) {
        weakmap.set(object, value);
      } else {
        value = weakmap.get(object);
        if (value === undefined) {
          value = creator(object);
          weakmap.set(object, value);
        }
      }
      return value;
    }

    return storage;
  }


  if (typeof module !== 'undefined') {
    module.exports = WM;
  } else if (typeof exports !== 'undefined') {
    exports.WeakMap = WM;
  } else if (!('WeakMap' in global)) {
    global.WeakMap = WM;
  }

  WM.createStorage = createStorage;
  if (global.WeakMap)
    global.WeakMap.createStorage = createStorage;
}((0, eval)('this'));

},{}],"/projects/blackice/node_modules/gl-texture2d/node_modules/webglew/webglew.js":[function(require,module,exports){
'use strict'

var weakMap = typeof WeakMap === 'undefined' ? require('weakmap') : WeakMap

var WebGLEWStruct = new weakMap()

function baseName(ext_name) {
  return ext_name.replace(/^[A-Z]+_/, '')
}

function initWebGLEW(gl) {
  var struct = WebGLEWStruct.get(gl)
  if(struct) {
    return struct
  }
  var extensions = {}
  var supported = gl.getSupportedExtensions()
  for(var i=0; i<supported.length; ++i) {
    var extName = supported[i]

    //Skip MOZ_ extensions
    if(extName.indexOf('MOZ_') === 0) {
      continue
    }
    var ext = gl.getExtension(supported[i])
    if(!ext) {
      continue
    }
    while(true) {
      extensions[extName] = ext
      var base = baseName(extName)
      if(base === extName) {
        break
      }
      extName = base
    }
  }
  WebGLEWStruct.set(gl, extensions)
  return extensions
}
module.exports = initWebGLEW
},{"weakmap":"/projects/blackice/node_modules/gl-texture2d/node_modules/webglew/node_modules/weakmap/weakmap.js"}],"/projects/blackice/node_modules/gl-texture2d/texture.js":[function(require,module,exports){
'use strict'

var ndarray = require('ndarray')
var ops     = require('ndarray-ops')
var pool    = require('typedarray-pool')
var webglew = require('webglew')

module.exports = createTexture2D

var linearTypes = null
var filterTypes = null
var wrapTypes   = null

function lazyInitLinearTypes(gl) {
  linearTypes = [
    gl.LINEAR,
    gl.NEAREST_MIPMAP_LINEAR,
    gl.LINEAR_MIPMAP_NEAREST,
    gl.LINEAR_MIPMAP_NEAREST
  ]
  filterTypes = [
    gl.NEAREST,
    gl.LINEAR,
    gl.NEAREST_MIPMAP_NEAREST,
    gl.NEAREST_MIPMAP_LINEAR,
    gl.LINEAR_MIPMAP_NEAREST,
    gl.LINEAR_MIPMAP_LINEAR
  ]
  wrapTypes = [
    gl.REPEAT,
    gl.CLAMP_TO_EDGE,
    gl.MIRRORED_REPEAT
  ]
}

var convertFloatToUint8 = function(out, inp) {
  ops.muls(out, inp, 255.0)
}

function reshapeTexture(tex, w, h) {
  var gl = tex.gl
  var maxSize = gl.getParameter(gl.MAX_TEXTURE_SIZE)
  if(w < 0 || w > maxSize || h < 0 || h > maxSize) {
    throw new Error('gl-texture2d: Invalid texture size')
  }
  tex._shape = [w, h]
  tex.bind()
  gl.texImage2D(gl.TEXTURE_2D, 0, tex.format, w, h, 0, tex.format, tex.type, null)
  tex._mipLevels = [0]
  return tex
}

function Texture2D(gl, handle, width, height, format, type) {
  this.gl = gl
  this.handle = handle
  this.format = format
  this.type = type
  this._shape = [width, height]
  this._mipLevels = [0]
  this._magFilter = gl.NEAREST
  this._minFilter = gl.NEAREST
  this._wrapS = gl.CLAMP_TO_EDGE
  this._wrapT = gl.CLAMP_TO_EDGE
  this._anisoSamples = 1

  var parent = this
  var wrapVector = [this._wrapS, this._wrapT]
  Object.defineProperties(wrapVector, [
    {
      get: function() {
        return parent._wrapS
      },
      set: function(v) {
        return parent.wrapS = v
      }
    },
    {
      get: function() {
        return parent._wrapT
      },
      set: function(v) {
        return parent.wrapT = v
      }
    }
  ])
  this._wrapVector = wrapVector

  var shapeVector = [this._shape[0], this._shape[1]]
  Object.defineProperties(shapeVector, [
    {
      get: function() {
        return parent._shape[0]
      },
      set: function(v) {
        return parent.width = v
      }
    },
    {
      get: function() {
        return parent._shape[1]
      },
      set: function(v) {
        return parent.height = v
      }
    }
  ])
  this._shapeVector = shapeVector
}

var proto = Texture2D.prototype

Object.defineProperties(proto, {
  minFilter: {
    get: function() {
      return this._minFilter
    },
    set: function(v) {
      this.bind()
      var gl = this.gl
      if(this.type === gl.FLOAT && linearTypes.indexOf(v) >= 0) {
        if(!webglew(gl).texture_float_linear) {
          v = gl.NEAREST
        }
      }
      if(filterTypes.indexOf(v) < 0) {
        throw new Error('gl-texture2d: Unknown filter mode ' + v)
      }
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, v)
      return this._minFilter = v
    }
  },
  magFilter: {
    get: function() {
      return this._magFilter
    },
    set: function(v) {
      this.bind()
      var gl = this.gl
      if(this.type === gl.FLOAT && linearTypes.indexOf(v) >= 0) {
        if(!webglew(gl).texture_float_linear) {
          v = gl.NEAREST
        }
      }
      if(filterTypes.indexOf(v) < 0) {
        throw new Error('gl-texture2d: Unknown filter mode ' + v)
      }
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, v)
      return this._magFilter = v
    }
  },
  mipSamples: {
    get: function() {
      return this._anisoSamples
    },
    set: function(i) {
      var psamples = this._anisoSamples
      this._anisoSamples = Math.max(i, 1)|0
      if(psamples !== this._anisoSamples) {
        var ext = webglew(this.gl).EXT_texture_filter_anisotropic
        if(ext) {
          this.gl.texParameterf(this.gl.TEXTURE_2D, ext.TEXTURE_MAX_ANISOTROPY_EXT, this._anisoSamples)
        }
      }
      return this._anisoSamples
    }
  },
  wrapS: {
    get: function() {
      return this._wrapS
    },
    set: function(v) {
      this.bind()
      if(wrapTypes.indexOf(v) < 0) {
        throw new Error('gl-texture2d: Unknown wrap mode ' + v)
      }
      this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, v)
      return this._wrapS = v
    }
  },
  wrapT: {
    get: function() {
      return this._wrapT
    },
    set: function(v) {
      this.bind()
      if(wrapTypes.indexOf(v) < 0) {
        throw new Error('gl-texture2d: Unknown wrap mode ' + v)
      }
      this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, v)
      return this._wrapT = v
    }
  },
  wrap: {
    get: function() {
      return this._wrapVector
    },
    set: function(v) {
      if(!Array.isArray(v)) {
        v = [v,v]
      }
      if(v.length !== 2) {
        throw new Error('gl-texture2d: Must specify wrap mode for rows and columns')
      }
      for(var i=0; i<2; ++i) {
        if(wrapTypes.indexOf(v[i]) < 0) {
          throw new Error('gl-texture2d: Unknown wrap mode ' + v)
        }
      }
      this._wrapS = v[0]
      this._wrapT = v[1]

      var gl = this.gl
      this.bind()
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, this._wrapS)
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, this._wrapT)

      return v
    }
  },
  shape: {
    get: function() {
      return this._shapeVector
    }, 
    set: function(x) {
      if(!Array.isArray(x)) {
        x = [x|0,x|0]
      } else {
        if(x.length !== 2) {
          throw new Error('gl-texture2d: Invalid texture shape')
        }
      }
      reshapeTexture(this, x[0]|0, x[1]|0)
      return [x[0]|0, x[1]|0]
    }
  },
  width: {
    get: function() {
      return this._shape[0]
    },
    set: function(w) {
      w = w|0
      reshapeTexture(this, w, this._shape[1])
      return w
    }
  },
  height: {
    get: function() {
      return this._shape[1]
    },
    set: function(h) {
      h = h|0
      reshapeTexture(this, this._shape[0], h)
      return h
    }
  }
})

proto.bind = function(unit) {
  var gl = this.gl
  if(unit !== undefined) {
    gl.activeTexture(gl.TEXTURE0 + (unit|0))
  }
  gl.bindTexture(gl.TEXTURE_2D, this.handle)
  if(unit !== undefined) {
    return (unit|0)
  }
  return gl.getParameter(gl.ACTIVE_TEXTURE) - gl.TEXTURE0
}

proto.dispose = function() {
  this.gl.deleteTexture(this.handle)
}

proto.generateMipmap = function() {
  this.bind()
  this.gl.generateMipmap(this.gl.TEXTURE_2D)
  
  //Update mip levels
  var l = Math.min(this._shape[0], this._shape[1])
  for(var i=0; l>0; ++i, l>>>=1) {
    if(this._mipLevels.indexOf(i) < 0) {
      this._mipLevels.push(i)
    }
  }
}

proto.setPixels = function(data, x_off, y_off, mip_level) {
  var gl = this.gl
  this.bind()
  if(Array.isArray(x_off)) {
    mip_level = y_off
    y_off = x_off[1]|0
    x_off = x_off[0]|0
  } else {
    x_off = x_off || 0
    y_off = y_off || 0
  }
  mip_level = mip_level || 0
  if(data instanceof HTMLCanvasElement ||
     data instanceof ImageData ||
     data instanceof HTMLImageElement ||
     data instanceof HTMLVideoElement) {
    var needsMip = this._mipLevels.indexOf(mip_level) < 0
    if(needsMip) {
      gl.texImage2D(gl.TEXTURE_2D, 0, this.format, this.format, this.type, data)
      this._mipLevels.push(mip_level)
    } else {
      gl.texSubImage2D(gl.TEXTURE_2D, mip_level, x_off, y_off, this.format, this.type, data)
    }
  } else if(data.shape && data.stride && data.data) {
    if(data.shape.length < 2 ||
       x_off + data.shape[1] > this._shape[1]>>>mip_level ||
       y_off + data.shape[0] > this._shape[0]>>>mip_level ||
       x_off < 0 ||
       y_off < 0) {
      throw new Error('gl-texture2d: Texture dimensions are out of bounds')
    }
    texSubImageArray(gl, x_off, y_off, mip_level, this.format, this.type, this._mipLevels, data)
  } else {
    throw new Error('gl-texture2d: Unsupported data type')
  }
}


function isPacked(shape, stride) {
  if(shape.length === 3) {
    return  (stride[2] === 1) && 
            (stride[1] === shape[0]*shape[2]) &&
            (stride[0] === shape[2])
  }
  return  (stride[0] === 1) && 
          (stride[1] === shape[0])
}

function texSubImageArray(gl, x_off, y_off, mip_level, cformat, ctype, mipLevels, array) {
  var dtype = array.dtype
  var shape = array.shape.slice()
  if(shape.length < 2 || shape.length > 3) {
    throw new Error('gl-texture2d: Invalid ndarray, must be 2d or 3d')
  }
  var type = 0, format = 0
  var packed = isPacked(shape, array.stride.slice())
  if(dtype === 'float32') {
    type = gl.FLOAT
  } else if(dtype === 'float64') {
    type = gl.FLOAT
    packed = false
    dtype = 'float32'
  } else if(dtype === 'uint8') {
    type = gl.UNSIGNED_BYTE
  } else {
    type = gl.UNSIGNED_BYTE
    packed = false
    dtype = 'uint8'
  }
  var channels = 1
  if(shape.length === 2) {
    format = gl.LUMINANCE
    shape = [shape[0], shape[1], 1]
    array = ndarray(array.data, shape, [array.stride[0], array.stride[1], 1], array.offset)
  } else if(shape.length === 3) {
    if(shape[2] === 1) {
      format = gl.ALPHA
    } else if(shape[2] === 2) {
      format = gl.LUMINANCE_ALPHA
    } else if(shape[2] === 3) {
      format = gl.RGB
    } else if(shape[2] === 4) {
      format = gl.RGBA
    } else {
      throw new Error('gl-texture2d: Invalid shape for pixel coords')
    }
    channels = shape[2]
  } else {
    throw new Error('gl-texture2d: Invalid shape for texture')
  }
  //For 1-channel textures allow conversion between formats
  if((format  === gl.LUMINANCE || format  === gl.ALPHA) &&
     (cformat === gl.LUMINANCE || cformat === gl.ALPHA)) {
    format = cformat
  }
  if(format !== cformat) {
    throw new Error('gl-texture2d: Incompatible texture format for setPixels')
  }
  var size = array.size
  var needsMip = mipLevels.indexOf(mip_level) < 0
  if(needsMip) {
    mipLevels.push(mip_level)
  }
  if(type === ctype && packed) {
    //Array data types are compatible, can directly copy into texture
    if(array.offset === 0 && array.data.length === size) {
      if(needsMip) {
        gl.texImage2D(gl.TEXTURE_2D, mip_level, cformat, shape[0], shape[1], 0, cformat, ctype, array.data)
      } else {
        gl.texSubImage2D(gl.TEXTURE_2D, mip_level, x_off, y_off, shape[0], shape[1], cformat, ctype, array.data)
      }
    } else {
      if(needsMip) {
        gl.texImage2D(gl.TEXTURE_2D, mip_level, cformat, shape[0], shape[1], 0, cformat, ctype, array.data.subarray(array.offset, array.offset+size))
      } else {
        gl.texSubImage2D(gl.TEXTURE_2D, mip_level, x_off, y_off, shape[0], shape[1], cformat, ctype, array.data.subarray(array.offset, array.offset+size))
      }
    }
  } else {
    //Need to do type conversion to pack data into buffer
    var pack_buffer
    if(ctype === gl.FLOAT) {
      pack_buffer = pool.mallocFloat32(size)
    } else {
      pack_buffer = pool.mallocUint8(size)
    }
    var pack_view = ndarray(pack_buffer, shape, [shape[2], shape[2]*shape[0], 1])
    if(type === gl.FLOAT && ctype === gl.UNSIGNED_BYTE) {
      convertFloatToUint8(pack_view, array)
    } else {
      ops.assign(pack_view, array)
    }
    if(needsMip) {
      gl.texImage2D(gl.TEXTURE_2D, mip_level, cformat, shape[0], shape[1], 0, cformat, ctype, pack_buffer.subarray(0, size))
    } else {
      gl.texSubImage2D(gl.TEXTURE_2D, mip_level, x_off, y_off, shape[0], shape[1], cformat, ctype, pack_buffer.subarray(0, size))
    }
    if(ctype === gl.FLOAT) {
      pool.freeFloat32(pack_buffer)
    } else {
      pool.freeUint8(pack_buffer)
    }
  }
}

function initTexture(gl) {
  var tex = gl.createTexture()
  gl.bindTexture(gl.TEXTURE_2D, tex)
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST)
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST)
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE)
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE)
  return tex
}

function createTextureShape(gl, width, height, format, type) {
  var maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE)
  if(width < 0 || width > maxTextureSize || height < 0 || height  > maxTextureSize) {
    throw new Error('gl-texture2d: Invalid texture shape')
  }
  if(type === gl.FLOAT && !webglew(gl).texture_float) {
    throw new Error('gl-texture2d: Floating point textures not supported on this platform')
  }
  var tex = initTexture(gl)
  gl.texImage2D(gl.TEXTURE_2D, 0, format, width, height, 0, format, type, null)
  return new Texture2D(gl, tex, width, height, format, type)
}

function createTextureDOM(gl, element, format, type) {
  var tex = initTexture(gl)
  gl.texImage2D(gl.TEXTURE_2D, 0, format, format, type, element)
  return new Texture2D(gl, tex, element.width|0, element.height|0, format, type)
}

//Creates a texture from an ndarray
function createTextureArray(gl, array) {
  var dtype = array.dtype
  var shape = array.shape.slice()
  var maxSize = gl.getParameter(gl.MAX_TEXTURE_SIZE)
  if(shape[0] < 0 || shape[0] > maxSize || shape[1] < 0 || shape[1] > maxSize) {
    throw new Error('gl-texture2d: Invalid texture size')
  }
  var packed = isPacked(shape, array.stride.slice())
  var type = 0
  if(dtype === 'float32') {
    type = gl.FLOAT
  } else if(dtype === 'float64') {
    type = gl.FLOAT
    packed = false
    dtype = 'float32'
  } else if(dtype === 'uint8') {
    type = gl.UNSIGNED_BYTE
  } else {
    type = gl.UNSIGNED_BYTE
    packed = false
    dtype = 'uint8'
  }
  var format = 0
  if(shape.length === 2) {
    format = gl.LUMINANCE
    shape = [shape[0], shape[1], 1]
    array = ndarray(array.data, shape, [array.stride[0], array.stride[1], 1], array.offset)
  } else if(shape.length === 3) {
    if(shape[2] === 1) {
      format = gl.ALPHA
    } else if(shape[2] === 2) {
      format = gl.LUMINANCE_ALPHA
    } else if(shape[2] === 3) {
      format = gl.RGB
    } else if(shape[2] === 4) {
      format = gl.RGBA
    } else {
      throw new Error('gl-texture2d: Invalid shape for pixel coords')
    }
  } else {
    throw new Error('gl-texture2d: Invalid shape for texture')
  }
  if(type === gl.FLOAT && !webglew(gl).texture_float) {
    type = gl.UNSIGNED_BYTE
    packed = false
  }
  var buffer, buf_store
  var size = array.size
  if(!packed) {
    var stride = [shape[2], shape[2]*shape[0], 1]
    buf_store = pool.malloc(size, dtype)
    var buf_array = ndarray(buf_store, shape, stride, 0)
    if((dtype === 'float32' || dtype === 'float64') && type === gl.UNSIGNED_BYTE) {
      convertFloatToUint8(buf_array, array)
    } else {
      ops.assign(buf_array, array)
    }
    buffer = buf_store.subarray(0, size)
  } else if (array.offset === 0 && array.data.length === size) {
    buffer = array.data
  } else {
    buffer = array.data.subarray(array.offset, array.offset + size)
  }
  var tex = initTexture(gl)
  gl.texImage2D(gl.TEXTURE_2D, 0, format, shape[0], shape[1], 0, format, type, buffer)
  if(!packed) {
    pool.free(buf_store)
  }
  return new Texture2D(gl, tex, shape[0], shape[1], format, type)
}

function createTexture2D(gl) {
  if(arguments.length <= 1) {
    throw new Error('gl-texture2d: Missing arguments for texture2d constructor')
  }
  if(!linearTypes) {
    lazyInitLinearTypes(gl)
  }
  if(typeof arguments[1] === 'number') {
    return createTextureShape(gl, arguments[1], arguments[2], arguments[3]||gl.RGBA, arguments[4]||gl.UNSIGNED_BYTE)
  }
  if(Array.isArray(arguments[1])) {
    return createTextureShape(gl, arguments[1][0]|0, arguments[1][1]|0, arguments[2]||gl.RGBA, arguments[3]||gl.UNSIGNED_BYTE)
  }
  if(typeof arguments[1] === 'object') {
    var obj = arguments[1]
    if(obj instanceof HTMLCanvasElement ||
       obj instanceof HTMLImageElement ||
       obj instanceof HTMLVideoElement ||
       obj instanceof ImageData) {
      return createTextureDOM(gl, obj, arguments[2]||gl.RGBA, arguments[3]||gl.UNSIGNED_BYTE)
    } else if(obj.shape && obj.data && obj.stride) {
      return createTextureArray(gl, obj)
    }
  }
  throw new Error('gl-texture2d: Invalid arguments for texture2d constructor')
}

},{"ndarray":"/projects/blackice/node_modules/gl-texture2d/node_modules/ndarray/ndarray.js","ndarray-ops":"/projects/blackice/node_modules/gl-texture2d/node_modules/ndarray-ops/ndarray-ops.js","typedarray-pool":"/projects/blackice/node_modules/gl-texture2d/node_modules/typedarray-pool/pool.js","webglew":"/projects/blackice/node_modules/gl-texture2d/node_modules/webglew/webglew.js"}],"/projects/blackice/node_modules/gl-vec3/set.js":[function(require,module,exports){
module.exports = set;

/**
 * Set the components of a vec3 to the given values
 *
 * @param {vec3} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} out
 */
function set(out, x, y, z) {
    out[0] = x
    out[1] = y
    out[2] = z
    return out
}
},{}],"/projects/blackice/node_modules/glslify/adapter.js":[function(require,module,exports){
module.exports = programify

var shader = require('gl-shader-core')

function programify(vertex, fragment, uniforms, attributes) {
  return function(gl) {
    return shader(gl, vertex, fragment, uniforms, attributes)
  }
}

},{"gl-shader-core":"/projects/blackice/node_modules/glslify/node_modules/gl-shader-core/shader-core.js"}],"/projects/blackice/node_modules/glslify/browser.js":[function(require,module,exports){
module.exports = noop

function noop() {
  throw new Error(
      'You should bundle your code ' +
      'using `glslify` as a transform.'
  )
}

},{}],"/projects/blackice/node_modules/glslify/node_modules/gl-shader-core/lib/create-attributes.js":[function(require,module,exports){
'use strict'

module.exports = createAttributeWrapper

//Shader attribute class
function ShaderAttribute(gl, program, location, dimension, name, constFunc, relink) {
  this._gl = gl
  this._program = program
  this._location = location
  this._dimension = dimension
  this._name = name
  this._constFunc = constFunc
  this._relink = relink
}

var proto = ShaderAttribute.prototype

proto.pointer = function setAttribPointer(type, normalized, stride, offset) {
  var gl = this._gl
  gl.vertexAttribPointer(this._location, this._dimension, type||gl.FLOAT, !!normalized, stride||0, offset||0)
  this._gl.enableVertexAttribArray(this._location)
}

Object.defineProperty(proto, 'location', {
  get: function() {
    return this._location
  }
  , set: function(v) {
    if(v !== this._location) {
      this._location = v
      this._gl.bindAttribLocation(this._program, v, this._name)
      this._gl.linkProgram(this._program)
      this._relink()
    }
  }
})


//Adds a vector attribute to obj
function addVectorAttribute(gl, program, location, dimension, obj, name, doLink) {
  var constFuncArgs = [ 'gl', 'v' ]
  var varNames = []
  for(var i=0; i<dimension; ++i) {
    constFuncArgs.push('x'+i)
    varNames.push('x'+i)
  }
  constFuncArgs.push([
    'if(x0.length===void 0){return gl.vertexAttrib', dimension, 'f(v,', varNames.join(), ')}else{return gl.vertexAttrib', dimension, 'fv(v,x0)}'
  ].join(''))
  var constFunc = Function.apply(undefined, constFuncArgs)
  var attr = new ShaderAttribute(gl, program, location, dimension, name, constFunc, doLink)
  Object.defineProperty(obj, name, {
    set: function(x) {
      gl.disableVertexAttribArray(attr._location)
      constFunc(gl, attr._location, x)
      return x
    }
    , get: function() {
      return attr
    }
    , enumerable: true
  })
}

//Create shims for attributes
function createAttributeWrapper(gl, program, attributes, doLink) {
  var obj = {}
  for(var i=0, n=attributes.length; i<n; ++i) {
    var a = attributes[i]
    var name = a.name
    var type = a.type
    var location = gl.getAttribLocation(program, name)
    
    switch(type) {
      case 'bool':
      case 'int':
      case 'float':
        addVectorAttribute(gl, program, location, 1, obj, name, doLink)
      break
      
      default:
        if(type.indexOf('vec') >= 0) {
          var d = type.charCodeAt(type.length-1) - 48
          if(d < 2 || d > 4) {
            throw new Error('gl-shader: Invalid data type for attribute ' + name + ': ' + type)
          }
          addVectorAttribute(gl, program, location, d, obj, name, doLink)
        } else {
          throw new Error('gl-shader: Unknown data type for attribute ' + name + ': ' + type)
        }
      break
    }
  }
  return obj
}
},{}],"/projects/blackice/node_modules/glslify/node_modules/gl-shader-core/lib/create-uniforms.js":[function(require,module,exports){
'use strict'

var dup = require('dup')
var coallesceUniforms = require('./reflect')

module.exports = createUniformWrapper

//Binds a function and returns a value
function identity(x) {
  var c = new Function('y', 'return function(){return y}')
  return c(x)
}

//Create shims for uniforms
function createUniformWrapper(gl, program, uniforms, locations) {

  function makeGetter(index) {
    var proc = new Function('gl', 'prog', 'locations', 
      'return function(){return gl.getUniform(prog,locations[' + index + '])}') 
    return proc(gl, program, locations)
  }

  function makePropSetter(path, index, type) {
    switch(type) {
      case 'bool':
      case 'int':
      case 'sampler2D':
      case 'samplerCube':
        return 'gl.uniform1i(locations[' + index + '],obj' + path + ')'
      case 'float':
        return 'gl.uniform1f(locations[' + index + '],obj' + path + ')'
      default:
        var vidx = type.indexOf('vec')
        if(0 <= vidx && vidx <= 1 && type.length === 4 + vidx) {
          var d = type.charCodeAt(type.length-1) - 48
          if(d < 2 || d > 4) {
            throw new Error('gl-shader: Invalid data type')
          }
          switch(type.charAt(0)) {
            case 'b':
            case 'i':
              return 'gl.uniform' + d + 'iv(locations[' + index + '],obj' + path + ')'
            case 'v':
              return 'gl.uniform' + d + 'fv(locations[' + index + '],obj' + path + ')'
            default:
              throw new Error('gl-shader: Unrecognized data type for vector ' + name + ': ' + type)
          }
        } else if(type.indexOf('mat') === 0 && type.length === 4) {
          var d = type.charCodeAt(type.length-1) - 48
          if(d < 2 || d > 4) {
            throw new Error('gl-shader: Invalid uniform dimension type for matrix ' + name + ': ' + type)
          }
          return 'gl.uniformMatrix' + d + 'fv(locations[' + index + '],false,obj' + path + ')'
        } else {
          throw new Error('gl-shader: Unknown uniform data type for ' + name + ': ' + type)
        }
      break
    }
  }

  function enumerateIndices(prefix, type) {
    if(typeof type !== 'object') {
      return [ [prefix, type] ]
    }
    var indices = []
    for(var id in type) {
      var prop = type[id]
      var tprefix = prefix
      if(parseInt(id) + '' === id) {
        tprefix += '[' + id + ']'
      } else {
        tprefix += '.' + id
      }
      if(typeof prop === 'object') {
        indices.push.apply(indices, enumerateIndices(tprefix, prop))
      } else {
        indices.push([tprefix, prop])
      }
    }
    return indices
  }

  function makeSetter(type) {
    var code = [ 'return function updateProperty(obj){' ]
    var indices = enumerateIndices('', type)
    for(var i=0; i<indices.length; ++i) {
      var item = indices[i]
      var path = item[0]
      var idx  = item[1]
      if(locations[idx]) {
        code.push(makePropSetter(path, idx, uniforms[idx].type))
      }
    }
    code.push('return obj}')
    var proc = new Function('gl', 'prog', 'locations', code.join('\n'))
    return proc(gl, program, locations)
  }

  function defaultValue(type) {
    switch(type) {
      case 'bool':
        return false
      case 'int':
      case 'sampler2D':
      case 'samplerCube':
        return 0
      case 'float':
        return 0.0
      default:
        var vidx = type.indexOf('vec')
        if(0 <= vidx && vidx <= 1 && type.length === 4 + vidx) {
          var d = type.charCodeAt(type.length-1) - 48
          if(d < 2 || d > 4) {
            throw new Error('gl-shader: Invalid data type')
          }
          if(type.charAt(0) === 'b') {
            return dup(d, false)
          }
          return dup(d)
        } else if(type.indexOf('mat') === 0 && type.length === 4) {
          var d = type.charCodeAt(type.length-1) - 48
          if(d < 2 || d > 4) {
            throw new Error('gl-shader: Invalid uniform dimension type for matrix ' + name + ': ' + type)
          }
          return dup([d,d])
        } else {
          throw new Error('gl-shader: Unknown uniform data type for ' + name + ': ' + type)
        }
      break
    }
  }

  function storeProperty(obj, prop, type) {
    if(typeof type === 'object') {
      var child = processObject(type)
      Object.defineProperty(obj, prop, {
        get: identity(child),
        set: makeSetter(type),
        enumerable: true,
        configurable: false
      })
    } else {
      if(locations[type]) {
        Object.defineProperty(obj, prop, {
          get: makeGetter(type),
          set: makeSetter(type),
          enumerable: true,
          configurable: false
        })
      } else {
        obj[prop] = defaultValue(uniforms[type].type)
      }
    }
  }

  function processObject(obj) {
    var result
    if(Array.isArray(obj)) {
      result = new Array(obj.length)
      for(var i=0; i<obj.length; ++i) {
        storeProperty(result, i, obj[i])
      }
    } else {
      result = {}
      for(var id in obj) {
        storeProperty(result, id, obj[id])
      }
    }
    return result
  }

  //Return data
  var coallesced = coallesceUniforms(uniforms, true)
  return {
    get: identity(processObject(coallesced)),
    set: makeSetter(coallesced),
    enumerable: true,
    configurable: true
  }
}

},{"./reflect":"/projects/blackice/node_modules/glslify/node_modules/gl-shader-core/lib/reflect.js","dup":"/projects/blackice/node_modules/glslify/node_modules/gl-shader-core/node_modules/dup/dup.js"}],"/projects/blackice/node_modules/glslify/node_modules/gl-shader-core/lib/reflect.js":[function(require,module,exports){
'use strict'

module.exports = makeReflectTypes

//Construct type info for reflection.
//
// This iterates over the flattened list of uniform type values and smashes them into a JSON object.
//
// The leaves of the resulting object are either indices or type strings representing primitive glslify types
function makeReflectTypes(uniforms, useIndex) {
  var obj = {}
  for(var i=0; i<uniforms.length; ++i) {
    var n = uniforms[i].name
    var parts = n.split(".")
    var o = obj
    for(var j=0; j<parts.length; ++j) {
      var x = parts[j].split("[")
      if(x.length > 1) {
        if(!(x[0] in o)) {
          o[x[0]] = []
        }
        o = o[x[0]]
        for(var k=1; k<x.length; ++k) {
          var y = parseInt(x[k])
          if(k<x.length-1 || j<parts.length-1) {
            if(!(y in o)) {
              if(k < x.length-1) {
                o[y] = []
              } else {
                o[y] = {}
              }
            }
            o = o[y]
          } else {
            if(useIndex) {
              o[y] = i
            } else {
              o[y] = uniforms[i].type
            }
          }
        }
      } else if(j < parts.length-1) {
        if(!(x[0] in o)) {
          o[x[0]] = {}
        }
        o = o[x[0]]
      } else {
        if(useIndex) {
          o[x[0]] = i
        } else {
          o[x[0]] = uniforms[i].type
        }
      }
    }
  }
  return obj
}
},{}],"/projects/blackice/node_modules/glslify/node_modules/gl-shader-core/node_modules/dup/dup.js":[function(require,module,exports){
module.exports=require("/projects/blackice/node_modules/gl-texture2d/node_modules/typedarray-pool/node_modules/dup/dup.js")
},{"/projects/blackice/node_modules/gl-texture2d/node_modules/typedarray-pool/node_modules/dup/dup.js":"/projects/blackice/node_modules/gl-texture2d/node_modules/typedarray-pool/node_modules/dup/dup.js"}],"/projects/blackice/node_modules/glslify/node_modules/gl-shader-core/shader-core.js":[function(require,module,exports){
'use strict'

var createUniformWrapper = require('./lib/create-uniforms')
var createAttributeWrapper = require('./lib/create-attributes')
var makeReflect = require('./lib/reflect')

//Shader object
function Shader(gl, prog, vertShader, fragShader) {
  this.gl = gl
  this.handle = prog
  this.attributes = null
  this.uniforms = null
  this.types = null
  this.vertexShader = vertShader
  this.fragmentShader = fragShader
}

//Binds the shader
Shader.prototype.bind = function() {
  this.gl.useProgram(this.handle)
}

//Destroy shader, release resources
Shader.prototype.dispose = function() {
  var gl = this.gl
  gl.deleteShader(this.vertexShader)
  gl.deleteShader(this.fragmentShader)
  gl.deleteProgram(this.handle)
}

Shader.prototype.updateExports = function(uniforms, attributes) {
  var locations = new Array(uniforms.length)
  var program = this.handle
  var gl = this.gl

  var doLink = relinkUniforms.bind(void 0,
    gl,
    program,
    locations,
    uniforms
  )
  doLink()

  this.types = {
    uniforms: makeReflect(uniforms),
    attributes: makeReflect(attributes)
  }

  this.attributes = createAttributeWrapper(
    gl,
    program,
    attributes,
    doLink
  )

  Object.defineProperty(this, 'uniforms', createUniformWrapper(
    gl,
    program,
    uniforms,
    locations
  ))
}

//Relinks all uniforms
function relinkUniforms(gl, program, locations, uniforms) {
  for(var i=0; i<uniforms.length; ++i) {
    locations[i] = gl.getUniformLocation(program, uniforms[i].name)
  }
}

//Compiles and links a shader program with the given attribute and vertex list
function createShader(
    gl
  , vertSource
  , fragSource
  , uniforms
  , attributes) {
  
  //Compile vertex shader
  var vertShader = gl.createShader(gl.VERTEX_SHADER)
  gl.shaderSource(vertShader, vertSource)
  gl.compileShader(vertShader)
  if(!gl.getShaderParameter(vertShader, gl.COMPILE_STATUS)) {
    var errLog = gl.getShaderInfoLog(vertShader)
    console.error('gl-shader: Error compling vertex shader:', errLog)
    throw new Error('gl-shader: Error compiling vertex shader:' + errLog)
  }
  
  //Compile fragment shader
  var fragShader = gl.createShader(gl.FRAGMENT_SHADER)
  gl.shaderSource(fragShader, fragSource)
  gl.compileShader(fragShader)
  if(!gl.getShaderParameter(fragShader, gl.COMPILE_STATUS)) {
    var errLog = gl.getShaderInfoLog(fragShader)
    console.error('gl-shader: Error compiling fragment shader:', errLog)
    throw new Error('gl-shader: Error compiling fragment shader:' + errLog)
  }
  
  //Link program
  var program = gl.createProgram()
  gl.attachShader(program, fragShader)
  gl.attachShader(program, vertShader)

  //Optional default attriubte locations
  attributes.forEach(function(a) {
    if (typeof a.location === 'number') 
      gl.bindAttribLocation(program, a.location, a.name)
  })

  gl.linkProgram(program)
  if(!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    var errLog = gl.getProgramInfoLog(program)
    console.error('gl-shader: Error linking shader program:', errLog)
    throw new Error('gl-shader: Error linking shader program:' + errLog)
  }
  
  //Return final linked shader object
  var shader = new Shader(
    gl,
    program,
    vertShader,
    fragShader
  )
  shader.updateExports(uniforms, attributes)

  return shader
}

module.exports = createShader

},{"./lib/create-attributes":"/projects/blackice/node_modules/glslify/node_modules/gl-shader-core/lib/create-attributes.js","./lib/create-uniforms":"/projects/blackice/node_modules/glslify/node_modules/gl-shader-core/lib/create-uniforms.js","./lib/reflect":"/projects/blackice/node_modules/glslify/node_modules/gl-shader-core/lib/reflect.js"}],"/projects/blackice/node_modules/glslify/simple-adapter.js":[function(require,module,exports){
module.exports = programify

function programify(vertex, fragment, uniforms, attributes) {
  return {
    vertex: vertex, 
    fragment: fragment,
    uniforms: uniforms, 
    attributes: attributes
  };
}

},{}],"/projects/blackice/node_modules/img/index.js":[function(require,module,exports){
module.exports = img;

function img (src, opt, callback) {
  if (typeof opt === 'function') {
    callback = opt
    opt = null
  }


  var el = document.createElement('img');
  var locked;

  el.onload = function () {
    if (locked) return;
    locked = true;

    callback && callback(undefined, el);
  };

  el.onerror = function (err) {
    if (locked) return;
    locked = true;

    callback && callback(new Error('Unable to load "' + src + '"'), el);
  };
  
  if (opt && opt.crossOrigin)
    el.crossOrigin = opt.crossOrigin;

  el.src = src;

  return el;
}

},{}],"/projects/blackice/node_modules/inherits/inherits_browser.js":[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],"/projects/blackice/node_modules/lerp/index.js":[function(require,module,exports){
function lerp(v0, v1, t) {
    return v0*(1-t)+v1*t
}
module.exports = lerp
},{}],"/projects/blackice/node_modules/mixes/index.js":[function(require,module,exports){
var xtend = require('xtend')

var defaults = {
	enumerable: true,
	configurable: true
}

function mix(obj, entries) {
	for (var k in entries) {
		if (!entries.hasOwnProperty(k))
			continue
		var f = entries[k]
		if (typeof f === 'function') {
			obj[k] = f
		} else if (f && typeof f === 'object') {
			var def = xtend(defaults, f)
			Object.defineProperty(obj, k, def);
		}
	}
}

module.exports = function mixes(ctor, entries) {
	mix(ctor.prototype, entries)
}

module.exports.mix = mix
},{"xtend":"/projects/blackice/node_modules/xtend/immutable.js"}],"/projects/blackice/node_modules/normalize-path-scale/index.js":[function(require,module,exports){
var bounds = require('getboundingbox')
var unlerp = require('unlerp')

module.exports = function normalize(path, box) {
    var b
    if (box && typeof box === 'object') {
        b = box
    } else
        b = bounds(path)

    //TODO: hmm, doesn't really handle div by zero
    //in any sane manner

    var w = (b.maxX-b.minX),
        h = (b.maxY-b.minY)

    var aspectX = w>h ? 1 : h/w,
        aspectY = w>h ? w/h : 1

    return path.map(function(p) {
        return [
            range(b.minX, b.maxX, p[0])*1/aspectX,
            range(b.minY, b.maxY, p[1])*1/aspectY
        ]
    })
}

function range(min, max, value) {
    return ((max-min===0) ? 0 : unlerp(min, max, value))*2-1
}
},{"getboundingbox":"/projects/blackice/node_modules/normalize-path-scale/node_modules/getboundingbox/index.js","unlerp":"/projects/blackice/node_modules/unlerp/index.js"}],"/projects/blackice/node_modules/normalize-path-scale/node_modules/getboundingbox/index.js":[function(require,module,exports){
module.exports = function( path, box, xKey, yKey ) {
    xKey = typeof xKey === 'string' ? xKey : 0;
    yKey = typeof yKey === 'string' ? yKey : 1;
    if (!box || typeof box === 'number')
        box = {};

    box.minX = Infinity;
    box.minY = Infinity;
    box.maxX = -Infinity;
    box.maxY = -Infinity;

    for (var i=0; i<path.length; i++) {
        var x = path[i][ xKey ],
            y = path[i][ yKey ];
        box.minX = Math.min( box.minX, x );
        box.minY = Math.min( box.minY, y );
        box.maxX = Math.max( box.maxX, x );
        box.maxY = Math.max( box.maxY, y );
    }
    
    if (path.length === 0) 
        box.minX = box.maxX = box.minY = box.maxY = 0
    return box;
};
},{}],"/projects/blackice/node_modules/parse-svg-path/index.js":[function(require,module,exports){

module.exports = parse

/**
 * expected argument lengths
 * @type {Object}
 */

var length = {a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0}

/**
 * segment pattern
 * @type {RegExp}
 */

var segment = /([astvzqmhlc])([^astvzqmhlc]*)/ig

/**
 * parse an svg path data string. Generates an Array
 * of commands where each command is an Array of the
 * form `[command, arg1, arg2, ...]`
 *
 * @param {String} path
 * @return {Array}
 */

function parse(path) {
	var data = []
	path.replace(segment, function(_, command, args){
		var type = command.toLowerCase()
		args = parseValues(args)

		// overloaded moveTo
		if (type == 'm' && args.length > 2) {
			data.push([command].concat(args.splice(0, 2)))
			type = 'l'
			command = command == 'm' ? 'l' : 'L'
		}

		while (true) {
			if (args.length == length[type]) {
				args.unshift(command)
				return data.push(args)
			}
			if (args.length < length[type]) throw new Error('malformed path data')
			data.push([command].concat(args.splice(0, length[type])))
		}
	})
	return data
}

function parseValues(args){
	args = args.match(/-?[.0-9]+(?:e[-+]?\d+)?/ig)
	return args ? args.map(Number) : []
}

},{}],"/projects/blackice/node_modules/plucker/index.js":[function(require,module,exports){
module.exports = plucker

function plucker(path, object) {
  return arguments.length >= 2
    ? pluck(path)(object)
    : pluck(path)
}

function pluck(path) {
  path = typeof path === 'string'
    ? String(path).trim().split('.')
    : path

  if (path.length < 2) {
    path = path[0]
    return pluckSingle
  } else {
    var l = path.length
    return pluckPath
  }

  function pluckSingle(object) {
    return object[path]
  }

  function pluckPath(object) {
    for (var i = 0; i < l; i++) {
      if (typeof object === 'undefined') break

      object = object[path[i]]
    }

    return object
  }
}

},{}],"/projects/blackice/node_modules/raf.js/raf.js":[function(require,module,exports){
/*
 * raf.js
 * https://github.com/ngryman/raf.js
 *
 * original requestAnimationFrame polyfill by Erik Mller
 * inspired from paul_irish gist and post
 *
 * Copyright (c) 2013 ngryman
 * Licensed under the MIT license.
 */

(function(window) {
	var lastTime = 0,
		vendors = ['webkit', 'moz'],
		requestAnimationFrame = window.requestAnimationFrame,
		cancelAnimationFrame = window.cancelAnimationFrame,
		i = vendors.length;

	// try to un-prefix existing raf
	while (--i >= 0 && !requestAnimationFrame) {
		requestAnimationFrame = window[vendors[i] + 'RequestAnimationFrame'];
		cancelAnimationFrame = window[vendors[i] + 'CancelAnimationFrame'];
	}

	// polyfill with setTimeout fallback
	// heavily inspired from @darius gist mod: https://gist.github.com/paulirish/1579671#comment-837945
	if (!requestAnimationFrame || !cancelAnimationFrame) {
		requestAnimationFrame = function(callback) {
			var now = +new Date(), nextTime = Math.max(lastTime + 16, now);
			return setTimeout(function() {
				callback(lastTime = nextTime);
			}, nextTime - now);
		};

		cancelAnimationFrame = clearTimeout;
	}

	// export to window
	window.requestAnimationFrame = requestAnimationFrame;
	window.cancelAnimationFrame = cancelAnimationFrame;
}(window));

},{}],"/projects/blackice/node_modules/simplify-path/douglas-peucker.js":[function(require,module,exports){
// square distance from a point to a segment
function getSqSegDist(p, p1, p2) {
    var x = p1[0],
        y = p1[1],
        dx = p2[0] - x,
        dy = p2[1] - y;

    if (dx !== 0 || dy !== 0) {

        var t = ((p[0] - x) * dx + (p[1] - y) * dy) / (dx * dx + dy * dy);

        if (t > 1) {
            x = p2[0];
            y = p2[1];

        } else if (t > 0) {
            x += dx * t;
            y += dy * t;
        }
    }

    dx = p[0] - x;
    dy = p[1] - y;

    return dx * dx + dy * dy;
}

// simplification using optimized Douglas-Peucker algorithm with recursion elimination
module.exports = function simplifyDouglasPeucker(points, tolerance) {
    if (points.length<=1)
        return points;
    tolerance = typeof tolerance === 'number' ? tolerance : 1;
    var sqTolerance = tolerance * tolerance;

    var len = points.length,
        MarkerArray = typeof Uint8Array !== 'undefined' ? Uint8Array : Array,
        markers = new MarkerArray(len),
        first = 0,
        last = len - 1,
        stack = [],
        newPoints = [],
        i, maxSqDist, sqDist, index;

    markers[first] = markers[last] = 1;

    while (last) {

        maxSqDist = 0;

        for (i = first + 1; i < last; i++) {
            sqDist = getSqSegDist(points[i], points[first], points[last]);

            if (sqDist > maxSqDist) {
                index = i;
                maxSqDist = sqDist;
            }
        }

        if (maxSqDist > sqTolerance) {
            markers[index] = 1;
            stack.push(first, index, index, last);
        }

        last = stack.pop();
        first = stack.pop();
    }

    for (i = 0; i < len; i++) {
        if (markers[i]) newPoints.push(points[i]);
    }

    return newPoints;
}
},{}],"/projects/blackice/node_modules/simplify-path/index.js":[function(require,module,exports){
var simplifyRadialDist = require('./radial-distance')
var simplifyDouglasPeucker = require('./douglas-peucker')

//simplifies using both algorithms
module.exports = function simplify(points, tolerance) {
    points = simplifyRadialDist(points, tolerance);
    points = simplifyDouglasPeucker(points, tolerance);
    return points;
}

module.exports.radialDistance = simplifyRadialDist;
module.exports.douglasPeucker = simplifyDouglasPeucker;
},{"./douglas-peucker":"/projects/blackice/node_modules/simplify-path/douglas-peucker.js","./radial-distance":"/projects/blackice/node_modules/simplify-path/radial-distance.js"}],"/projects/blackice/node_modules/simplify-path/radial-distance.js":[function(require,module,exports){
function getSqDist(p1, p2) {
    var dx = p1[0] - p2[0],
        dy = p1[1] - p2[1];

    return dx * dx + dy * dy;
}

// basic distance-based simplification
module.exports = function simplifyRadialDist(points, tolerance) {
    if (points.length<=1)
        return points;
    tolerance = typeof tolerance === 'number' ? tolerance : 1;
    var sqTolerance = tolerance * tolerance;
    
    var prevPoint = points[0],
        newPoints = [prevPoint],
        point;

    for (var i = 1, len = points.length; i < len; i++) {
        point = points[i];

        if (getSqDist(point, prevPoint) > sqTolerance) {
            newPoints.push(point);
            prevPoint = point;
        }
    }

    if (prevPoint !== point) newPoints.push(point);

    return newPoints;
}
},{}],"/projects/blackice/node_modules/smoothstep/index.js":[function(require,module,exports){
module.exports = function smoothstep (min, max, value) {
  var x = Math.max(0, Math.min(1, (value-min)/(max-min)));
  return x*x*(3 - 2*x);
};

},{}],"/projects/blackice/node_modules/svg-path-contours/index.js":[function(require,module,exports){
var bezier = require('adaptive-bezier-curve')
var abs = require('abs-svg-path')
var norm = require('normalize-svg-path')
var copy = require('vec2-copy')

function set(out, x, y) {
    out[0] = x
    out[1] = y
    return out
}

var tmp1 = [0,0],
    tmp2 = [0,0],
    tmp3 = [0,0]

function bezierTo(points, scale, start, seg) {
    bezier(start, 
        set(tmp1, seg[1], seg[2]), 
        set(tmp2, seg[3], seg[4]),
        set(tmp3, seg[5], seg[6]), scale, points)
}

module.exports = function contours(svg, scale) {
    var paths = []

    var points = []
    var pen = [0, 0]
    norm(abs(svg)).forEach(function(segment, i, self) {
        if (segment[0] === 'M') {
            copy(pen, segment.slice(1))
            if (points.length>0) {
                paths.push(points)
                points = []
            }
            points.push(pen)
        } else if (segment[0] === 'C') {
            bezierTo(points, scale, pen, segment)
            set(pen, segment[5], segment[6])
        } else {
            throw new Error('illegal type in SVG: '+segment[0])
        }
    })
    if (points.length>0)
        paths.push(points)
    return paths
}
},{"abs-svg-path":"/projects/blackice/node_modules/svg-path-contours/node_modules/abs-svg-path/index.js","adaptive-bezier-curve":"/projects/blackice/node_modules/svg-path-contours/node_modules/adaptive-bezier-curve/index.js","normalize-svg-path":"/projects/blackice/node_modules/svg-path-contours/node_modules/normalize-svg-path/index.js","vec2-copy":"/projects/blackice/node_modules/svg-path-contours/node_modules/vec2-copy/index.js"}],"/projects/blackice/node_modules/svg-path-contours/node_modules/abs-svg-path/index.js":[function(require,module,exports){

module.exports = absolutize

/**
 * redefine `path` with absolute coordinates
 *
 * @param {Array} path
 * @return {Array}
 */

function absolutize(path){
	var startX = 0
	var startY = 0
	var x = 0
	var y = 0

	return path.map(function(seg){
		seg = seg.slice()
		var type = seg[0]
		var command = type.toUpperCase()

		// is relative
		if (type != command) {
			seg[0] = command
			switch (type) {
				case 'a':
					seg[6] += x
					seg[7] += y
					break
				case 'v':
					seg[1] += y
					break
				case 'h':
					seg[1] += x
					break
				default:
					for (var i = 1; i < seg.length;) {
						seg[i++] += x
						seg[i++] += y
					}
			}
		}

		// update cursor state
		switch (command) {
			case 'Z':
				x = startX
				y = startY
				break
			case 'H':
				x = seg[1]
				break
			case 'V':
				y = seg[1]
				break
			case 'M':
				x = startX = seg[1]
				y = startY = seg[2]
				break
			default:
				x = seg[seg.length - 2]
				y = seg[seg.length - 1]
		}

		return seg
	})
}

},{}],"/projects/blackice/node_modules/svg-path-contours/node_modules/adaptive-bezier-curve/function.js":[function(require,module,exports){
function clone(point) { //TODO: use gl-vec2 for this
    return [point[0], point[1]]
}

function vec2(x, y) {
    return [x, y]
}

module.exports = function createBezierBuilder(opt) {
    opt = opt||{}

    var RECURSION_LIMIT = typeof opt.recursion === 'number' ? opt.recursion : 8
    var FLT_EPSILON = typeof opt.epsilon === 'number' ? opt.epsilon : 1.19209290e-7
    var PATH_DISTANCE_EPSILON = typeof opt.pathEpsilon === 'number' ? opt.pathEpsilon : 1.0

    var curve_angle_tolerance_epsilon = typeof opt.angleEpsilon === 'number' ? opt.angleEpsilon : 0.01
    var m_angle_tolerance = opt.angleTolerance || 0
    var m_cusp_limit = opt.cuspLimit || 0

    return function bezierCurve(start, c1, c2, end, scale, points) {
        if (!points)
            points = []

        scale = typeof scale === 'number' ? scale : 1.0
        var distanceTolerance = PATH_DISTANCE_EPSILON / scale
        distanceTolerance *= distanceTolerance
        begin(start, c1, c2, end, points, distanceTolerance)
        return points
    }


    ////// Based on:
    ////// https://github.com/pelson/antigrain/blob/master/agg-2.4/src/agg_curves.cpp

    function begin(start, c1, c2, end, points, distanceTolerance) {
        points.push(clone(start))
        var x1 = start[0],
            y1 = start[1],
            x2 = c1[0],
            y2 = c1[1],
            x3 = c2[0],
            y3 = c2[1],
            x4 = end[0],
            y4 = end[1]
        recursive(x1, y1, x2, y2, x3, y3, x4, y4, points, distanceTolerance, 0)
        points.push(clone(end))
    }

    function recursive(x1, y1, x2, y2, x3, y3, x4, y4, points, distanceTolerance, level) {
        if(level > RECURSION_LIMIT) 
            return

        var pi = Math.PI

        // Calculate all the mid-points of the line segments
        //----------------------
        var x12   = (x1 + x2) / 2
        var y12   = (y1 + y2) / 2
        var x23   = (x2 + x3) / 2
        var y23   = (y2 + y3) / 2
        var x34   = (x3 + x4) / 2
        var y34   = (y3 + y4) / 2
        var x123  = (x12 + x23) / 2
        var y123  = (y12 + y23) / 2
        var x234  = (x23 + x34) / 2
        var y234  = (y23 + y34) / 2
        var x1234 = (x123 + x234) / 2
        var y1234 = (y123 + y234) / 2

        if(level > 0) { // Enforce subdivision first time
            // Try to approximate the full cubic curve by a single straight line
            //------------------
            var dx = x4-x1
            var dy = y4-y1

            var d2 = Math.abs((x2 - x4) * dy - (y2 - y4) * dx)
            var d3 = Math.abs((x3 - x4) * dy - (y3 - y4) * dx)

            var da1, da2

            if(d2 > FLT_EPSILON && d3 > FLT_EPSILON) {
                // Regular care
                //-----------------
                if((d2 + d3)*(d2 + d3) <= distanceTolerance * (dx*dx + dy*dy)) {
                    // If the curvature doesn't exceed the distanceTolerance value
                    // we tend to finish subdivisions.
                    //----------------------
                    if(m_angle_tolerance < curve_angle_tolerance_epsilon) {
                        points.push(vec2(x1234, y1234))
                        return
                    }

                    // Angle & Cusp Condition
                    //----------------------
                    var a23 = Math.atan2(y3 - y2, x3 - x2)
                    da1 = Math.abs(a23 - Math.atan2(y2 - y1, x2 - x1))
                    da2 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - a23)
                    if(da1 >= pi) da1 = 2*pi - da1
                    if(da2 >= pi) da2 = 2*pi - da2

                    if(da1 + da2 < m_angle_tolerance) {
                        // Finally we can stop the recursion
                        //----------------------
                        points.push(vec2(x1234, y1234))
                        return
                    }

                    if(m_cusp_limit !== 0.0) {
                        if(da1 > m_cusp_limit) {
                            points.push(vec2(x2, y2))
                            return
                        }

                        if(da2 > m_cusp_limit) {
                            points.push(vec2(x3, y3))
                            return
                        }
                    }
                }
            }
            else {
                if(d2 > FLT_EPSILON) {
                    // p1,p3,p4 are collinear, p2 is considerable
                    //----------------------
                    if(d2 * d2 <= distanceTolerance * (dx*dx + dy*dy)) {
                        if(m_angle_tolerance < curve_angle_tolerance_epsilon) {
                            points.push(vec2(x1234, y1234))
                            return
                        }

                        // Angle Condition
                        //----------------------
                        da1 = Math.abs(Math.atan2(y3 - y2, x3 - x2) - Math.atan2(y2 - y1, x2 - x1))
                        if(da1 >= pi) da1 = 2*pi - da1

                        if(da1 < m_angle_tolerance) {
                            points.push(vec2(x2, y2))
                            points.push(vec2(x3, y3))
                            return
                        }

                        if(m_cusp_limit !== 0.0) {
                            if(da1 > m_cusp_limit) {
                                points.push(vec2(x2, y2))
                                return
                            }
                        }
                    }
                }
                else if(d3 > FLT_EPSILON) {
                    // p1,p2,p4 are collinear, p3 is considerable
                    //----------------------
                    if(d3 * d3 <= distanceTolerance * (dx*dx + dy*dy)) {
                        if(m_angle_tolerance < curve_angle_tolerance_epsilon) {
                            points.push(vec2(x1234, y1234))
                            return
                        }

                        // Angle Condition
                        //----------------------
                        da1 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - Math.atan2(y3 - y2, x3 - x2))
                        if(da1 >= pi) da1 = 2*pi - da1

                        if(da1 < m_angle_tolerance) {
                            points.push(vec2(x2, y2))
                            points.push(vec2(x3, y3))
                            return
                        }

                        if(m_cusp_limit !== 0.0) {
                            if(da1 > m_cusp_limit)
                            {
                                points.push(vec2(x3, y3))
                                return
                            }
                        }
                    }
                }
                else {
                    // Collinear case
                    //-----------------
                    dx = x1234 - (x1 + x4) / 2
                    dy = y1234 - (y1 + y4) / 2
                    if(dx*dx + dy*dy <= distanceTolerance) {
                        points.push(vec2(x1234, y1234))
                        return
                    }
                }
            }
        }

        // Continue subdivision
        //----------------------
        recursive(x1, y1, x12, y12, x123, y123, x1234, y1234, points, distanceTolerance, level + 1) 
        recursive(x1234, y1234, x234, y234, x34, y34, x4, y4, points, distanceTolerance, level + 1) 
    }
}

},{}],"/projects/blackice/node_modules/svg-path-contours/node_modules/adaptive-bezier-curve/index.js":[function(require,module,exports){
module.exports = require('./function')()
},{"./function":"/projects/blackice/node_modules/svg-path-contours/node_modules/adaptive-bezier-curve/function.js"}],"/projects/blackice/node_modules/svg-path-contours/node_modules/normalize-svg-path/index.js":[function(require,module,exports){

var  = Math.PI
var _120 = radians(120)

module.exports = normalize

/**
 * describe `path` in terms of cubic bzier 
 * curves and move commands
 *
 * @param {Array} path
 * @return {Array}
 */

function normalize(path){
	// init state
	var prev
	var result = []
	var bezierX = 0
	var bezierY = 0
	var startX = 0
	var startY = 0
	var quadX = null
	var quadY = null
	var x = 0
	var y = 0

	for (var i = 0, len = path.length; i < len; i++) {
		var seg = path[i]
		var command = seg[0]
		switch (command) {
			case 'M':
				startX = seg[1]
				startY = seg[2]
				break
			case 'A':
				seg = arc(x, y,seg[1],seg[2],radians(seg[3]),seg[4],seg[5],seg[6],seg[7])
				// split multi part
				seg.unshift('C')
				if (seg.length > 7) {
					result.push(seg.splice(0, 7))
					seg.unshift('C')
				}
				break
			case 'S':
				// default control point
				var cx = x
				var cy = y
				if (prev == 'C' || prev == 'S') {
					cx += cx - bezierX // reflect the previous command's control
					cy += cy - bezierY // point relative to the current point
				}
				seg = ['C', cx, cy, seg[1], seg[2], seg[3], seg[4]]
				break
			case 'T':
				if (prev == 'Q' || prev == 'T') {
					quadX = x * 2 - quadX // as with 'S' reflect previous control point
					quadY = y * 2 - quadY
				} else {
					quadX = x
					quadY = y
				}
				seg = quadratic(x, y, quadX, quadY, seg[1], seg[2])
				break
			case 'Q':
				quadX = seg[1]
				quadY = seg[2]
				seg = quadratic(x, y, seg[1], seg[2], seg[3], seg[4])
				break
			case 'L':
				seg = line(x, y, seg[1], seg[2])
				break
			case 'H':
				seg = line(x, y, seg[1], y)
				break
			case 'V':
				seg = line(x, y, x, seg[1])
				break
			case 'Z':
				seg = line(x, y, startX, startY)
				break
		}

		// update state
		prev = command
		x = seg[seg.length - 2]
		y = seg[seg.length - 1]
		if (seg.length > 4) {
			bezierX = seg[seg.length - 4]
			bezierY = seg[seg.length - 3]
		} else {
			bezierX = x
			bezierY = y
		}
		result.push(seg)
	}

	return result
}

function line(x1, y1, x2, y2){
	return ['C', x1, y1, x2, y2, x2, y2]
}

function quadratic(x1, y1, cx, cy, x2, y2){
	return [
		'C',
		x1/3 + (2/3) * cx,
		y1/3 + (2/3) * cy,
		x2/3 + (2/3) * cx,
		y2/3 + (2/3) * cy,
		x2,
		y2
	]
}

// This function is ripped from 
// github.com/DmitryBaranovskiy/raphael/blob/4d97d4/raphael.js#L2216-L2304 
// which references w3.org/TR/SVG11/implnote.html#ArcImplementationNotes
// TODO: make it human readable

function arc(x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {
	if (!recursive) {
		var xy = rotate(x1, y1, -angle)
		x1 = xy.x
		y1 = xy.y
		xy = rotate(x2, y2, -angle)
		x2 = xy.x
		y2 = xy.y
		var x = (x1 - x2) / 2
		var y = (y1 - y2) / 2
		var h = (x * x) / (rx * rx) + (y * y) / (ry * ry)
		if (h > 1) {
			h = Math.sqrt(h)
			rx = h * rx
			ry = h * ry
		}
		var rx2 = rx * rx
		var ry2 = ry * ry
		var k = (large_arc_flag == sweep_flag ? -1 : 1)
			* Math.sqrt(Math.abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x)))
		if (k == Infinity) k = 1 // neutralize
		var cx = k * rx * y / ry + (x1 + x2) / 2
		var cy = k * -ry * x / rx + (y1 + y2) / 2
		var f1 = Math.asin(((y1 - cy) / ry).toFixed(9))
		var f2 = Math.asin(((y2 - cy) / ry).toFixed(9))

		f1 = x1 < cx ?  - f1 : f1
		f2 = x2 < cx ?  - f2 : f2
		if (f1 < 0) f1 =  * 2 + f1
		if (f2 < 0) f2 =  * 2 + f2
		if (sweep_flag && f1 > f2) f1 = f1 -  * 2
		if (!sweep_flag && f2 > f1) f2 = f2 -  * 2
	} else {
		f1 = recursive[0]
		f2 = recursive[1]
		cx = recursive[2]
		cy = recursive[3]
	}
	// greater than 120 degrees requires multiple segments
	if (Math.abs(f2 - f1) > _120) {
		var f2old = f2
		var x2old = x2
		var y2old = y2
		f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1)
		x2 = cx + rx * Math.cos(f2)
		y2 = cy + ry * Math.sin(f2)
		var res = arc(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy])
	}
	var t = Math.tan((f2 - f1) / 4)
	var hx = 4 / 3 * rx * t
	var hy = 4 / 3 * ry * t
	var curve = [
		2 * x1 - (x1 + hx * Math.sin(f1)),
		2 * y1 - (y1 - hy * Math.cos(f1)),
		x2 + hx * Math.sin(f2),
		y2 - hy * Math.cos(f2),
		x2,
		y2
	]
	if (recursive) return curve
	if (res) curve = curve.concat(res)
	for (var i = 0; i < curve.length;) {
		var rot = rotate(curve[i], curve[i+1], angle)
		curve[i++] = rot.x
		curve[i++] = rot.y
	}
	return curve
}

function rotate(x, y, rad){
	return {
		x: x * Math.cos(rad) - y * Math.sin(rad),
		y: x * Math.sin(rad) + y * Math.cos(rad)
	}
}

function radians(degress){
	return degress * ( / 180)
}

},{}],"/projects/blackice/node_modules/svg-path-contours/node_modules/vec2-copy/index.js":[function(require,module,exports){
module.exports = function vec2Copy(out, a) {
    out[0] = a[0]
    out[1] = a[1]
    return out
}
},{}],"/projects/blackice/node_modules/three-effectcomposer/index.js":[function(require,module,exports){
/**
 * @author alteredq / http://alteredqualia.com/
 */

module.exports = function(THREE) {
  var CopyShader = EffectComposer.CopyShader = require('three-copyshader')
    , RenderPass = EffectComposer.RenderPass = require('./lib/renderpass')(THREE)
    , ShaderPass = EffectComposer.ShaderPass = require('./lib/shaderpass')(THREE, EffectComposer)
    , MaskPass = EffectComposer.MaskPass = require('./lib/maskpass')(THREE)
    , ClearMaskPass = EffectComposer.ClearMaskPass = require('./lib/clearmaskpass')(THREE)

  function EffectComposer( renderer, renderTarget ) {
    this.renderer = renderer;

    if ( renderTarget === undefined ) {
      var width = window.innerWidth || 1;
      var height = window.innerHeight || 1;
      var parameters = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBFormat, stencilBuffer: false };

      renderTarget = new THREE.WebGLRenderTarget( width, height, parameters );
    }

    this.renderTarget1 = renderTarget;
    this.renderTarget2 = renderTarget.clone();

    this.writeBuffer = this.renderTarget1;
    this.readBuffer = this.renderTarget2;

    this.passes = [];

    this.copyPass = new ShaderPass( CopyShader );
  };

  EffectComposer.prototype = {
    swapBuffers: function() {

      var tmp = this.readBuffer;
      this.readBuffer = this.writeBuffer;
      this.writeBuffer = tmp;

    },

    addPass: function ( pass ) {

      this.passes.push( pass );

    },

    insertPass: function ( pass, index ) {

      this.passes.splice( index, 0, pass );

    },

    render: function ( delta ) {

      this.writeBuffer = this.renderTarget1;
      this.readBuffer = this.renderTarget2;

      var maskActive = false;

      var pass, i, il = this.passes.length;

      for ( i = 0; i < il; i ++ ) {

        pass = this.passes[ i ];

        if ( !pass.enabled ) continue;

        pass.render( this.renderer, this.writeBuffer, this.readBuffer, delta, maskActive );

        if ( pass.needsSwap ) {

          if ( maskActive ) {

            var context = this.renderer.context;

            context.stencilFunc( context.NOTEQUAL, 1, 0xffffffff );

            this.copyPass.render( this.renderer, this.writeBuffer, this.readBuffer, delta );

            context.stencilFunc( context.EQUAL, 1, 0xffffffff );

          }

          this.swapBuffers();

        }

        if ( pass instanceof MaskPass ) {

          maskActive = true;

        } else if ( pass instanceof ClearMaskPass ) {

          maskActive = false;

        }

      }

    },

    reset: function ( renderTarget ) {

      if ( renderTarget === undefined ) {

        renderTarget = this.renderTarget1.clone();

        renderTarget.width = window.innerWidth;
        renderTarget.height = window.innerHeight;

      }

      this.renderTarget1 = renderTarget;
      this.renderTarget2 = renderTarget.clone();

      this.writeBuffer = this.renderTarget1;
      this.readBuffer = this.renderTarget2;

    },

    setSize: function ( width, height ) {

      var renderTarget = this.renderTarget1.clone();

      renderTarget.width = width;
      renderTarget.height = height;

      this.reset( renderTarget );

    }

  };

  // shared ortho camera

  EffectComposer.camera = new THREE.OrthographicCamera( -1, 1, 1, -1, 0, 1 );

  EffectComposer.quad = new THREE.Mesh( new THREE.PlaneGeometry( 2, 2 ), null );

  EffectComposer.scene = new THREE.Scene();
  EffectComposer.scene.add( EffectComposer.quad );

  return EffectComposer
};
},{"./lib/clearmaskpass":"/projects/blackice/node_modules/three-effectcomposer/lib/clearmaskpass.js","./lib/maskpass":"/projects/blackice/node_modules/three-effectcomposer/lib/maskpass.js","./lib/renderpass":"/projects/blackice/node_modules/three-effectcomposer/lib/renderpass.js","./lib/shaderpass":"/projects/blackice/node_modules/three-effectcomposer/lib/shaderpass.js","three-copyshader":"/projects/blackice/node_modules/three-effectcomposer/node_modules/three-copyshader/index.js"}],"/projects/blackice/node_modules/three-effectcomposer/lib/clearmaskpass.js":[function(require,module,exports){
/**
 * @author alteredq / http://alteredqualia.com/
 */

module.exports = function(THREE) {
  function ClearMaskPass() {
    if (!(this instanceof ClearMaskPass)) return new ClearMaskPass(scene, camera);
    this.enabled = true;
  };

  ClearMaskPass.prototype = {
    render: function ( renderer, writeBuffer, readBuffer, delta ) {
      var context = renderer.context;
      context.disable( context.STENCIL_TEST );
    }
  };

  return ClearMaskPass
};
},{}],"/projects/blackice/node_modules/three-effectcomposer/lib/maskpass.js":[function(require,module,exports){
/**
 * @author alteredq / http://alteredqualia.com/
 */

module.exports = function(THREE) {
  function MaskPass( scene, camera ) {
    if (!(this instanceof MaskPass)) return new MaskPass(scene, camera);

    this.scene = scene;
    this.camera = camera;

    this.enabled = true;
    this.clear = true;
    this.needsSwap = false;

    this.inverse = false;
  };

  MaskPass.prototype = {

    render: function ( renderer, writeBuffer, readBuffer, delta ) {

      var context = renderer.context;

      // don't update color or depth

      context.colorMask( false, false, false, false );
      context.depthMask( false );

      // set up stencil

      var writeValue, clearValue;

      if ( this.inverse ) {

        writeValue = 0;
        clearValue = 1;

      } else {

        writeValue = 1;
        clearValue = 0;

      }

      context.enable( context.STENCIL_TEST );
      context.stencilOp( context.REPLACE, context.REPLACE, context.REPLACE );
      context.stencilFunc( context.ALWAYS, writeValue, 0xffffffff );
      context.clearStencil( clearValue );

      // draw into the stencil buffer

      renderer.render( this.scene, this.camera, readBuffer, this.clear );
      renderer.render( this.scene, this.camera, writeBuffer, this.clear );

      // re-enable update of color and depth

      context.colorMask( true, true, true, true );
      context.depthMask( true );

      // only render where stencil is set to 1

      context.stencilFunc( context.EQUAL, 1, 0xffffffff );  // draw if == 1
      context.stencilOp( context.KEEP, context.KEEP, context.KEEP );

    }

  };

  return MaskPass
};

},{}],"/projects/blackice/node_modules/three-effectcomposer/lib/renderpass.js":[function(require,module,exports){
/**
 * @author alteredq / http://alteredqualia.com/
 */

module.exports = function(THREE) {
  function RenderPass( scene, camera, overrideMaterial, clearColor, clearAlpha ) {
    if (!(this instanceof RenderPass)) return new RenderPass(scene, camera, overrideMaterial, clearColor, clearAlpha);

    this.scene = scene;
    this.camera = camera;

    this.overrideMaterial = overrideMaterial;

    this.clearColor = clearColor;
    this.clearAlpha = ( clearAlpha !== undefined ) ? clearAlpha : 1;

    this.oldClearColor = new THREE.Color();
    this.oldClearAlpha = 1;

    this.enabled = true;
    this.clear = true;
    this.needsSwap = false;

  };

  RenderPass.prototype = {

    render: function ( renderer, writeBuffer, readBuffer, delta ) {

      this.scene.overrideMaterial = this.overrideMaterial;

      if ( this.clearColor ) {

        this.oldClearColor.copy( renderer.getClearColor() );
        this.oldClearAlpha = renderer.getClearAlpha();

        renderer.setClearColor( this.clearColor, this.clearAlpha );

      }

      renderer.render( this.scene, this.camera, readBuffer, this.clear );

      if ( this.clearColor ) {

        renderer.setClearColor( this.oldClearColor, this.oldClearAlpha );

      }

      this.scene.overrideMaterial = null;

    }

  };

  return RenderPass;

};

},{}],"/projects/blackice/node_modules/three-effectcomposer/lib/shaderpass.js":[function(require,module,exports){
/**
 * @author alteredq / http://alteredqualia.com/
 */

module.exports = function(THREE, EffectComposer) {
  function ShaderPass( shader, textureID ) {
    if (!(this instanceof ShaderPass)) return new ShaderPass(shader, textureID);

    this.textureID = ( textureID !== undefined ) ? textureID : "tDiffuse";

    this.uniforms = THREE.UniformsUtils.clone( shader.uniforms );

    this.material = new THREE.ShaderMaterial( {

      uniforms: this.uniforms,
      vertexShader: shader.vertexShader,
      fragmentShader: shader.fragmentShader

    } );

    this.renderToScreen = false;

    this.enabled = true;
    this.needsSwap = true;
    this.clear = false;

  };

  ShaderPass.prototype = {

    render: function ( renderer, writeBuffer, readBuffer, delta ) {

      if ( this.uniforms[ this.textureID ] ) {

        this.uniforms[ this.textureID ].value = readBuffer;

      }

      EffectComposer.quad.material = this.material;

      if ( this.renderToScreen ) {

        renderer.render( EffectComposer.scene, EffectComposer.camera );

      } else {

        renderer.render( EffectComposer.scene, EffectComposer.camera, writeBuffer, this.clear );

      }

    }

  };

  return ShaderPass;

};
},{}],"/projects/blackice/node_modules/three-effectcomposer/node_modules/three-copyshader/index.js":[function(require,module,exports){
/**
 * @author alteredq / http://alteredqualia.com/
 *
 * Full-screen textured quad shader
 */

module.exports = {
  uniforms: {
    "tDiffuse": { type: "t", value: null },
    "opacity":  { type: "f", value: 1.0 }
  },
  vertexShader: [
    "varying vec2 vUv;",

    "void main() {",

      "vUv = uv;",
      "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

    "}"
  ].join("\n"),
  fragmentShader: [
    "uniform float opacity;",

    "uniform sampler2D tDiffuse;",

    "varying vec2 vUv;",

    "void main() {",

      "vec4 texel = texture2D( tDiffuse, vUv );",
      "gl_FragColor = opacity * texel;",

    "}"
  ].join("\n")
};

},{}],"/projects/blackice/node_modules/three-glslify/index.js":[function(require,module,exports){
var createTypes = require('./types')


module.exports = function(THREE) {

    var types = createTypes(THREE) 

    return function create(glShader, opts) {
        opts = opts||{}

        if (typeof opts.colors === 'string')
            opts.colors = [opts.colors]
        
        var tUniforms = types( glShader.uniforms, opts.colors )
        var tAttribs = types( glShader.attributes, opts.colors )
            
        //clear the attribute arrays
        for (var k in tAttribs) {
            tAttribs[k].value = []
        }

        return {
            vertexShader: glShader.vertex,
            fragmentShader: glShader.fragment,
            uniforms: tUniforms,
            attributes: tAttribs
        }
    }
}
},{"./types":"/projects/blackice/node_modules/three-glslify/types.js"}],"/projects/blackice/node_modules/three-glslify/types.js":[function(require,module,exports){
var typeMap = {
    'int': 'i',
    'float': 'f',
    'ivec2': 'i2',
    'ivec3': 'i3',
    'ivec4': 'i4',
    'vec2': 'v2',
    'vec3': 'v3',
    'vec4': 'v4',
    'mat4': 'm4',
    'mat3': 'm3',
    'sampler2D': 't',
    'samplerCube': 't'
}

function create(THREE) {
    function newInstance(type, isArray) {
        switch (type) {
            case 'float': 
            case 'int':
                return 0
            case 'vec2':
            case 'ivec2':
                return new THREE.Vector2()
            case 'vec3':
            case 'ivec3':
                return new THREE.Vector3()
            case 'vec4':
            case 'ivec4':
                return new THREE.Vector4()
            case 'mat4':
                return new THREE.Matrix4()
            case 'mat3':
                return new THREE.Matrix3()
            case 'samplerCube':
            case 'sampler2D':
                return new THREE.Texture()
            default:
                return undefined
        }
    }

    function defaultValue(type, isArray, arrayLen) {
        if (isArray) {
            //ThreeJS flattens ivec3 type
            //(we don't support 'fv' type)
            if (type === 'ivec3')
                arrayLen *= 3
            var ar = new Array(arrayLen)
            for (var i=0; i<ar.length; i++)
                ar[i] = newInstance(type, isArray)
            return ar
        }  
        return newInstance(type)
    }

    function getType(type, isArray) {
        if (!isArray)
            return typeMap[type]

        if (type === 'int')
            return 'iv1'
        else if (type === 'float')
            return 'fv1'
        else
            return typeMap[type]+'v'
    }

    return function setupUniforms(glUniforms, colorNames) {
        if (!Array.isArray(colorNames))
            colorNames = Array.prototype.slice.call(arguments, 1)

        var result = {}
        var arrays = {}

        //map uniform types
        glUniforms.forEach(function(uniform) {
            var name = uniform.name
            var isArray = /(.+)\[[0-9]+\]/.exec(name)

            //special case: colors...
            if (colorNames && colorNames.indexOf(name) !== -1) {
                if (isArray)
                    throw new Error("array of color uniforms not supported")
                if (uniform.type !== 'vec3')
                    throw new Error("ThreeJS expects vec3 for Color uniforms") 
                result[name] = {
                    type: 'c',
                    value: new THREE.Color()
                }
                return
            }

            if (isArray) {
                name = isArray[1]
                if (name in arrays) 
                    arrays[name].count++ 
                else
                    arrays[name] = { count: 1, type: uniform.type }
            }
            result[name] = { 
                type: getType(uniform.type, isArray), 
                value: isArray ? null : defaultValue(uniform.type) 
            }
        })

        //now clean up any array values
        for (var k in result) {
            var u = result[k]
            if (k in arrays) { //is an array
                var a = arrays[k]
                u.value = defaultValue(a.type, true, a.count)
            }
        }
        return result
    }
}

module.exports = create
},{}],"/projects/blackice/node_modules/three-sdf-text/index.js":[function(require,module,exports){
module.exports = require('./lib/renderer')
},{"./lib/renderer":"/projects/blackice/node_modules/three-sdf-text/lib/renderer.js"}],"/projects/blackice/node_modules/three-sdf-text/lib/renderer.js":[function(require,module,exports){
var createText = require('gl-sprite-text')
var mat4 = {
    create: require('gl-mat4/create'),
    scale: require('gl-mat4/scale'),
    multiply: require('gl-mat4/multiply')
}

var modelTransform = mat4.create()
var flip = mat4.create()
mat4.scale(flip, flip, [1, -1, 1])

var WrapTexture = require('./texture-wrap')
var number = require('as-number')
var xtend = require('xtend')

var createShader = require('gl-shader-core')
var vertex = 'attribute vec4 position;\nattribute vec4 color;\nattribute vec2 texcoord0;\n\nuniform mat4 projection;\nuniform mat4 view;\nuniform mat4 model;\n\nvarying vec4 v_col;\nvarying vec2 v_tex0;\n\nvoid main() {\n gl_Position = projection * view * model * position;\n v_col = color;\n v_tex0 = texcoord0;\n gl_PointSize = 1.0;\n}'
var fragment = '#ifdef GL_ES\nprecision mediump float;\n#endif\n\nvarying vec4 v_col;\nvarying vec2 v_tex0;\nuniform sampler2D texture0;\n\nuniform float smoothing;\n// = 1.0/32.0;\n\n// drop shadow computed in fragment shader\nvoid main() {\n vec4 texColor = texture2D(texture0, v_tex0);\n\n float dst = texColor.a;\n float alpha = smoothstep(0.5 - smoothing, 0.5 + smoothing, dst);\n vec4 base = v_col * vec4(alpha);\n\n gl_FragColor = base;\n if (gl_FragColor.a<0.1)\n discard;\n}'

var uniforms = [
        { type: 'float', name: 'smoothing' },
        { type: 'sampler2D', name: 'texture0' },
        { type: 'mat4', name: 'projection' },
        { type: 'mat4', name: 'view' },
        { type: 'mat4', name: 'model' }        
    ],
    attributes = [
        { type: 'vec4', name: 'position' },
        { type: 'vec4', name: 'color' },
        { type: 'vec2', name: 'texcoord0' }
    ]



function copyColor(out, color, opacity) {
    out[0] = color.r
    out[1] = color.g 
    out[2] = color.b 
    out[3] = opacity
}

module.exports = function(THREE) {
    var sharedShader

    function TextRenderer(renderer, opt) {
        if (!(this instanceof TextRenderer))
            return new TextRenderer(renderer, opt)
        opt=opt||{}

        var gl = renderer.getContext()
        this.gl = gl
        this.color = new THREE.Color()
        if (opt.color !== null && typeof opt.color !== 'undefined')
            this.color.set(opt.color)
        this.opacity = number(opt.opacity, 1.0)

        //if no textures are given, presume they are base64 packed
        //into the Font object (like with bmfont-lato)
        var textOpts = xtend(opt)
        if (textOpts.textures) {
            textOpts.textures = textOpts.textures.map(function(tex) {
                // return require('gl-texture2d')(gl, tex.image)
                if (tex instanceof THREE.Texture)
                    return WrapTexture(renderer, tex)
                return tex
            })
        }
        
        this.element = createText(gl, textOpts)
        this.transform = mat4.create()

        if (!sharedShader && !opt.shader)
            sharedShader = createShader(gl, vertex, fragment, uniforms, attributes)
        this.shader = opt.shader || sharedShader
        this.shader.bind()

        this.padding = number(opt.padding, 0)

        var s = number(opt.smoothing, 1.0/32.0)
        this.shader.uniforms.smoothing = s
        this.shader.uniforms.texture0 = 0
    }

    TextRenderer.prototype.draw = function(camera, object) {
        var gl = this.gl

        if (!object.visible)
            return

        if (!this.element.textures || this.element.textures.length === 0)
            return

        gl.enable(gl.BLEND)
        // gl.bindFramebuffer(gl.FRAMEBUFFER, null)

        gl.enable(gl.DEPTH_TEST)
        gl.depthFunc(gl.LEQUAL)

        // gl.frontFace( gl.CCW )    
        gl.enable(gl.CULL_FACE)
        // gl.cullFace( gl.FRONT )
        gl.colorMask(true, true, true, true)
        gl.disable(gl.STENCIL_TEST)
        gl.activeTexture(gl.TEXTURE0)
        gl.depthMask(true)
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA)

        this.shader.bind()
        this.element.textures[0].bind(0)

        // gl.colorMask(true, true, true, true)

        gl.cullFace(gl.FRONT)

        mat4.multiply(modelTransform, object.matrixWorld.elements, this.transform)
        mat4.multiply(modelTransform, modelTransform, flip)

        this.shader.bind()
        this.shader.uniforms.projection = camera.projectionMatrix.elements
        this.shader.uniforms.view = camera.matrixWorldInverse.elements
        this.shader.uniforms.model = modelTransform
            
        copyColor(this.element.batch.color, this.color, this.opacity)
        this.element.draw(this.shader, this.padding, this.padding)

        gl.cullFace( gl.BACK )
    }


    return TextRenderer
}
},{"./texture-wrap":"/projects/blackice/node_modules/three-sdf-text/lib/texture-wrap.js","as-number":"/projects/blackice/node_modules/three-sdf-text/node_modules/as-number/index.js","gl-mat4/create":"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-mat4/create.js","gl-mat4/multiply":"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-mat4/multiply.js","gl-mat4/scale":"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-mat4/scale.js","gl-shader-core":"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-shader-core/shader-core.js","gl-sprite-text":"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/index.js","xtend":"/projects/blackice/node_modules/three-sdf-text/node_modules/xtend/immutable.js"}],"/projects/blackice/node_modules/three-sdf-text/lib/texture-wrap.js":[function(require,module,exports){
// in time this will be replaced with a solution
// that better supported ThreeJS Texture objects


function TextureWrap(renderer, tex) {
    if (!(this instanceof TextureWrap))
        return new TextureWrap(renderer, tex)
    this.renderer = renderer
    this.texture = tex
    this._shape = [0, 0]
}

TextureWrap.prototype.bind = function(unit) {
    updateSize(this._shape, this.texture)


    var gl = this.renderer.getContext()
    this.renderer.setTexture(this.texture, unit|0)
    
    gl.bindTexture(gl.TEXTURE_2D, this.texture.__webglTexture)
}

Object.defineProperty(TextureWrap.prototype, "shape", {

    get: function() {
        updateSize(this._shape, this.texture)
        return this._shape
    }
})

function updateSize(shape, texture) {
    shape[0] = (texture.image && texture.image.width)  |0
    shape[1] = (texture.image && texture.image.height) |0
}

module.exports = TextureWrap
},{}],"/projects/blackice/node_modules/three-sdf-text/node_modules/as-number/index.js":[function(require,module,exports){
module.exports=require("/projects/blackice/node_modules/as-number/index.js")
},{"/projects/blackice/node_modules/as-number/index.js":"/projects/blackice/node_modules/as-number/index.js"}],"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-mat4/create.js":[function(require,module,exports){
module.exports = create;

/**
 * Creates a new identity mat4
 *
 * @returns {mat4} a new 4x4 matrix
 */
function create() {
    var out = new Float32Array(16);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
};
},{}],"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-mat4/multiply.js":[function(require,module,exports){
module.exports=require("/projects/blackice/node_modules/gl-mat4/multiply.js")
},{"/projects/blackice/node_modules/gl-mat4/multiply.js":"/projects/blackice/node_modules/gl-mat4/multiply.js"}],"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-mat4/scale.js":[function(require,module,exports){
module.exports=require("/projects/blackice/node_modules/gl-mat4/scale.js")
},{"/projects/blackice/node_modules/gl-mat4/scale.js":"/projects/blackice/node_modules/gl-mat4/scale.js"}],"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-shader-core/shader-core.js":[function(require,module,exports){
module.exports=require("/projects/blackice/node_modules/glslify/node_modules/gl-shader-core/shader-core.js")
},{"/projects/blackice/node_modules/glslify/node_modules/gl-shader-core/shader-core.js":"/projects/blackice/node_modules/glslify/node_modules/gl-shader-core/shader-core.js"}],"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/index.js":[function(require,module,exports){
var Base = require('fontpath-simple-renderer')
var inherits = require('inherits')
var bmfont2fontpath = require('fontpath-bmfont')
var texcoord = require('texcoord')
var xtend = require('xtend')
var createTexture = require('gl-texture2d')

var Batch = require('gl-sprite-batch')

var tmpPos = [0, 0],
    tmpShape = [0, 0],
    tmp1 = [0, 0],
    tmp2 = [0, 0]
var DEFAULT_TEXCOORD = [0, 0, 1, 1]
var maxInitialCapacity = 500

function texcoordGlyph(glyph, atlas, out) {
    tmp1[0] = glyph.x
    tmp1[1] = glyph.y
    tmp2[0] = glyph.width
    tmp2[1] = glyph.height
    return texcoord(tmp1, tmp2, atlas, out)
}

function TextRenderer(gl, opt) {
    if (!(this instanceof TextRenderer))
        return new TextRenderer(gl, opt)
    opt = opt||{}

    if (!opt.font) 
        throw new Error('must specify bmfont at creation time')

    //if the font has Image/ndarray array
    if (!opt.textures && Array.isArray(opt.font.images)) {
        opt.textures = opt.font.images.map(function(img) {
            return createTexture(gl, img)
        })
    }

    opt.font = bmfont2fontpath(opt.font)

    Base.call(this, opt)

    this.textures = opt.textures || []
    this.gl = gl
    if (!gl)
        throw new Error("must specify gl context")
    
    //assume text will be used dynamically 
    if (typeof opt.dynamic !== 'boolean')
        opt.dynamic = true

    var batch = opt.batch
    if (!batch)
        this.defaultBatch = Batch(gl, opt)
    this.batch = batch || this.defaultBatch

    if (typeof opt.wrapWidth !== 'number')
        this.layout()
}

inherits(TextRenderer, Base)

TextRenderer.prototype.dispose = function(textures) {
    if (this.defaultBatch)
        this.defaultBatch.dispose()
    if (textures) {
        this.textures.forEach(function(t) {
            if (typeof t.dispose === 'function')
                t.dispose()
        })
    }
    return this
}

TextRenderer.prototype.uncache = function() {
    this._cache = false
    this.batch.clear()
    return this
}

TextRenderer.prototype.cache = function(x, y, start, end) {
    // if (this.underline || this.font.pages.length > 1)
    //     throw new Error('currently cached text does not support underlines or multiple texture pages')
    
    this._cache = true
    this.batch.ensureCapacity(this.text.length)
    this.batch.clear()
    this._build(x, y, start, end)
    return this
}

TextRenderer.prototype.draw = function(shader, x, y, start, end) {
    var batch = this.batch
    batch.bind(shader)

    //if we're drawing dynamically
    if (!this._cache) {
        batch.clear()
        this._build(x, y, start, end)
    }
    
    batch.draw()
    batch.unbind()
    return this
}

TextRenderer.prototype._build = function(x, y, start, end) {
    var result = this.render(x, y, start, end)

    var batch = this.batch
    var i = 0
    
    //underlines currently not supported with cache()
    if (!this._cache) {
        batch.texcoord = DEFAULT_TEXCOORD
        batch.texture = null

        for (i = 0; i < result.underlines.length; i++) {
            var underline = result.underlines[i]
            batch.position = underline.position
            batch.shape = underline.size
            batch.push()
        }
    }

    //now draw our glyphs into the batch...
    for (i = 0; i < result.glyphs.length; i++) {
        var g = result.glyphs[i]
        this._drawGlyph(batch, g)
    }
}

TextRenderer.prototype._drawGlyph = function(batch, data) {
    //... we could sort these by texture page to reduce draws
    var glyph = data.glyph
    var img = this.textures[glyph.page]
    tmpPos[0] = data.position[0]+glyph.hbx
    tmpPos[1] = data.position[1]+glyph.hby - this.font.descender
    tmpShape[0] = glyph.width * data.scale[0]
    tmpShape[1] = glyph.height * data.scale[1]
    
    batch.texture = img
    texcoordGlyph(glyph, img && img.shape, batch.texcoord)
    batch.position = tmpPos
    batch.shape = tmpShape
    batch.push()
}

module.exports = TextRenderer
},{"fontpath-bmfont":"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/fontpath-bmfont/index.js","fontpath-simple-renderer":"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/fontpath-simple-renderer/index.js","gl-sprite-batch":"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/index.js","gl-texture2d":"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-texture2d/texture.js","inherits":"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/inherits/inherits_browser.js","texcoord":"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/texcoord/index.js","xtend":"/projects/blackice/node_modules/three-sdf-text/node_modules/xtend/immutable.js"}],"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/fontpath-bmfont/index.js":[function(require,module,exports){
function glyph(data) {
    return {
        page: data.page,
        hbx: data.xoffset,
        hby: data.yoffset,
        width: data.width,
        height: data.height,
        xoff: data.xadvance,
        x: data.x,
        y: data.y
    }
}

function glyphs(chars) {
    var out = {}
    chars.forEach(function(c) {
        out[String.fromCharCode(c.id)] = glyph(c)
    })
    return out
}

module.exports = function(bmfont) {
    return {
        pages: bmfont.pages,
        resolution: 72,
        size: bmfont.info.size,
        units_per_EM: 1,
        bitmap: true,
        family_name: bmfont.info.face,
        height: bmfont.common.lineHeight,
        descender: bmfont.common.base,
        ascender: bmfont.common.base,
        glyphs: glyphs(bmfont.chars),
        kerning: bmfont.kernings.map(function(k) {
            return [String.fromCharCode(k.first),String.fromCharCode(k.second),k.amount]
        })
    }
}
},{}],"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/fontpath-simple-renderer/index.js":[function(require,module,exports){
var Base = require('fontpath-renderer')
var inherits = require('inherits')

//TODO: Eventually lots of this code will just replace fontpath-renderer...

function FontpathRenderer(options) {
    if (!(this instanceof FontpathRenderer))
        return new FontpathRenderer(options)
    Base.call(this, options)

    this.data = {
        glyphs: [],
        underlines: []
    }
}

inherits(FontpathRenderer, Base)

FontpathRenderer.prototype.renderGlyph = function(i, glyph, scale, x, y) {
    this.data.glyphs.push(new Glyph(i, glyph, 
                this.text.charCodeAt(i), 
                [ scale, this.font.bitmap ? scale : -scale ],
                [ x, y ]))
}

FontpathRenderer.prototype.renderUnderline = function(x, y, width, height) {
    this.data.underlines.push(new Underline(
        [ x, y ],
        [ width, height ]
    ))
}

FontpathRenderer.prototype.render = function(x, y, start, end) {
    //new data for result
    this.data.glyphs.length = 0
    this.data.underlines.length = 0
    Base.prototype.render.call(this, x, y, start, end)
    return this.data
}

function Glyph(index, glyph, charCode, scale, position) {
    this.glyph = glyph
    this.index = index
    this.charCode = charCode
    this.position = position
    this.scale = scale
}

function Underline(position, size) {
    this.position = position
    this.size = size
}

module.exports = FontpathRenderer
},{"fontpath-renderer":"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/fontpath-simple-renderer/node_modules/fontpath-renderer/index.js","inherits":"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/inherits/inherits_browser.js"}],"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/fontpath-simple-renderer/node_modules/fontpath-renderer/index.js":[function(require,module,exports){
var GlyphIterator = require('fontpath-glyph-iterator');
var WordWrap = require('fontpath-wordwrap');

var tmpBounds = { x: 0, y: 0, width: 0, height: 0, glyphs: 0 };

function TextRenderer(options) {
    if (!(this instanceof TextRenderer))
        return new TextRenderer(options);
    options = options||{}

    this.iterator = new GlyphIterator(options.font, options.fontSize);
    this.wordwrap = new WordWrap();

    this.align = 'left';
    this.underline = false;

    this.underlineThickness = undefined;
    this.underlinePosition = undefined;
    this._text = "";

    if (typeof options.align === 'string')
        this.align = options.align;
    if (typeof options.underline === 'boolean')
        this.underline = options.underline;
    if (typeof options.underlineThickness === 'number')
        this.underlineThickness = options.underlineThickness;
    if (typeof options.underlinePosition === 'number')
        this.underlinePosition = options.underlinePosition;
    if (typeof options.text === 'string')
        this.text = options.text;
    if (typeof options.lineHeight === 'number')
        this.lineHeight = options.lineHeight;
    if (typeof options.letterSpacing === 'number')
        this.letterSpacing = options.letterSpacing;
    if (typeof options.wrapMode === 'string')
        this.wordwrap.mode = options.wrapMode;
    if (typeof options.wrapWidth === 'number')
        this.layout(options.wrapWidth);
}

//Internally we will use integers to avoid string comparison for each glyph
var LEFT_ALIGN = 0, CENTER_ALIGN = 1, RIGHT_ALIGN = 2;
var ALIGN_ARRAY = [
    'left', 
    'center', 
    'right'
];
    
Object.defineProperties(TextRenderer.prototype, {
    /**
     * If the new font differs from the last, the text layout is cleared
     * and placed onto a single line. Users must manually re-layout the text 
     * for word wrapping.
     */
    "font": {
        get: function() {
            return this.iterator.font;
        },
        set: function(val) {
            var oldFont = this.iterator.font;
            this.iterator.font = val;
            if (oldFont !== this.iterator.font)
                this.clearLayout();
        },
    },

    /**
     * If the new font size differs from the last, the text layout is cleared
     * and placed onto a single line. Users must manually re-layout the text 
     * for word wrapping.
     */
    "fontSize": {
        get: function() {
            return this.iterator.fontSize;
        },
        set: function(val) {
            var oldSize = this.iterator.fontSize;

            this.iterator.fontSize = val;

            if (oldSize !== this.iterator.fontSize)
                this.clearLayout();
        },
    },
    "lineHeight": {
        get: function() {
            return this.iterator.lineHeight;
        },
        set: function(val) {
            this.iterator.lineHeight = val;
        },
    },
    "letterSpacing": {
         get: function() {
            return this.iterator.letterSpacing;
        },
        set: function(val) {
            this.iterator.letterSpacing = val;
        },
    },

    /**
     * If the new text is different from the last, the layout (i.e. word-wrapping)
     * is cleared and the result is a single line of text (similar to HTML5 canvas text
     * rendering).
     * 
     * The text then needs to be re-wordwrapped with a call to `layout()`.
     */
    "text": {
        get: function() {
            return this._text;
        },

        set: function(text) {
            text = text||"";

            var old = this._text;
            this._text = text;
            this.wordwrap.text = this.text;

            if (this._text !== old) 
                this.clearLayout();
        }
    }
});

/**
 * Clears the text layout and word-wrapping, placing all of it on a single line.
 */
TextRenderer.prototype.clearLayout = function() {
    this.wordwrap.text = this.text;
    this.wordwrap.empty();

    if (this.iterator.font) //font might not have been passed at constructor
        this.wordwrap.clearLayout(this.iterator);
};

/**
 * Calls the word wrapper to layout the current text string,
 * based on the wrap width and any current wordwrapping options.
 *
 * This is called when the text is changed. 
 * 
 * @return {[type]} [description]
 */
TextRenderer.prototype.layout = function(wrapWidth) {
    this.wordwrap.text = this.text;
    this.wordwrap.empty();
    this.wordwrap.layout(this.iterator, wrapWidth);
};

/**
 * "Renders" this glyph at the given location. This may involve filling
 * a VBO with vertex data, or it may be a direct call to draw a bitmap glyph
 * or shape outline.
 * @return {[type]} [description]
 */
TextRenderer.prototype.renderGlyph = function() {

};

TextRenderer.prototype.renderUnderline = function() {

};

/**
 * Returns the bounds of the current text layout. 
 *
 * The height does not extend past the baseline of the
 * last line; unless `includeUnderline` is true, in which
 * case the underline's position and height is included
 * in the calculation. 
 *
 * The bounding y position is offset so that the box has an upper-left
 * origin, for parity with HTML5 canvas rendering.
 * 
 * @param {Boolean} includeUnderline whether to include the underline in the calculation, default false
 * @param {Object} out an optional {width, height} object for re-use
 * @return {Object} a size with { width, height } properties
 */
TextRenderer.prototype.getBounds = function (includeUnderline, out) {
    if (!out)
        out = { x: 0, y: 0, width: 0, height: 0 };

    var wordwrapper = this.wordwrap;
    var itr = this.iterator;

    //tighten the bounding box around the first line..
    var firstLineHeight = 0;
    if (wordwrapper.lines.length > 0) {
        var firstLine = wordwrapper.lines[0];
        itr.getBounds(this.text, firstLine.start, firstLine.end, undefined, tmpBounds);
        firstLineHeight = tmpBounds.height;
    }

    out.width = wordwrapper.getMaxLineWidth();   
    out.height = Math.max(0, wordwrapper.lines.length-1) * itr.getLineGap() + firstLineHeight;

    out.x = 0;
    out.y = -out.height;

    if (includeUnderline) {
        var underlineHeight = this.computeUnderlineHeight();
        var underlinePosition = this.computeUnderlinePosition();
        var underlineOff = underlinePosition+underlineHeight/2;
        out.height += underlineOff;
    }

    return out;
};

/**
 * Computes the scaled underline height as pixels, based on 
 * the explicit `underlineHeight` (in pixels). If `underlineHeight` is
 * undefined or null, it will try to use the font's non-zero underline height, 
 * otherwise default to 1/8 of the font's EM square.
 * 
 * @return {Number} the pixel height of the underline 
 */
TextRenderer.prototype.computeUnderlineHeight = function () {
    var font = this.font;
    var scale = this.iterator.fontScale;
    if (this.underlineThickness===0||this.underlineThickness) {
        return this.underlineThickness; 
    } else if (font.underline_thickness) {
        return font.underline_thickness * scale; 
    } else if (font.bitmap)
        return font.size/8;
    else
        return (font.units_per_EM/8)*scale;
};

/**
 * Computes the scaled underline height as pixels, based on 
 * the explicit `underlinePosition` (in pixels). If `underlinePosition` is
 * undefined or null, it will try to use the font's non-zero underline position, 
 * otherwise default to 1/4 of the font's EM square.
 *
 * This is the Y offset from the text baseline to the center of the underline 
 * bar, in pixels. It is generally a positive value.
 * 
 * @return {Number} the pixel position of the underline 
 */
TextRenderer.prototype.computeUnderlinePosition = function () {
    var font = this.font;
    var scale = this.iterator.fontScale;
        
    if (this.underlinePosition===0||this.underlinePosition) {
        return this.underlinePosition; 
    } else if (font.underline_position) {
        return -font.underline_position * scale; 
    } else if (font.bitmap) {
        return font.size/4;
    } else {
        return (font.units_per_EM/4)*scale;
    }
};

/**
 * Gets the descent of the current font (assumes its size 
 * is already set). This is an absolute (positive) value.
 * 
 * @return {[type]} [description]
 */
TextRenderer.prototype.getDescender = function () {
    return Math.abs(this.iterator.fontScale * this.iterator.font.descender);
};

/**
 * Gets the descent of the current font (assumes its size 
 * is already set). This is an absolute (positive) value.
 * 
 * @return {[type]} [description]
 */
TextRenderer.prototype.getAscender = function () {
    return Math.abs(this.iterator.fontScale * this.iterator.font.ascender);
};

//Signals for subclasses to optionally implmeent
//This may be useful to stop/start paths with different fills
TextRenderer.prototype.onBegin = function() { }
TextRenderer.prototype.onEnd = function() { }
TextRenderer.prototype.onBeginLine = function(lineIndex) { }
TextRenderer.prototype.onEndLine = function(lineIndex) { }

/**
 * Renders the current text layout, where lower-left is 
 * the origin. Multiple lines will be positioned above the
 * origin.
 */
TextRenderer.prototype.render = function (x, y, start, end) {
    x = x||0;
    y = y||0;

    var text = this.text;
    var wordwrapper = this.wordwrap;

    //if we have nothing to draw
    if (!text || wordwrapper.lines.length === 0)
        return;

    //default start/end params
    start = start||0;
    end = typeof end === "number" ? end : text.length;

    var itr = this.iterator;
    var scale = itr.fontScale;
    var font = itr.font;
    var underline = this.underline;

    //used for alignment...
    var maxLineWidth = wordwrapper.getMaxLineWidth();
    
    y -= Math.max(0, wordwrapper.lines.length-1) * itr.getLineGap();


    //use numbers to avoid str compare for each glyph
    var alignType = ALIGN_ARRAY.indexOf(this.align||"");
    if (alignType===-1)
        alignType = LEFT_ALIGN;

    var underlineX = 0;
    var underlineStartX = 0;
    var underlineY = 0;
    var underlineWidth = 0;

    var underlineStarted = false;

    //Try to use user-specified underline settings, otherwise use the font if possible,
    //otherwise just use a rough default based on EM square.    
    var underlinePos = this.computeUnderlinePosition();
    var underlineHeight = this.computeUnderlineHeight();

    this.onBegin();
    
    //set the origin and pen position
    itr.begin(x, y);
    for (var k=0; k<wordwrapper.lines.length; k++) {
        var line = wordwrapper.lines[k];
        underlineStarted = false;

        var lastAdvance = 0;

        var lineX = itr.pen.x;
        var lineY = itr.pen.y;

        this.onBeginLine(k);

        //TODO: use multiple Nodes inside a single line
        //a node will have attributes like font, size, color, 
        //letter-spacing, underline, etc.
        //This will affect the line height, as it will have to be the max of all nodes.

        for (var i=line.start; i<line.end; i++) {
            var chr = text.charAt(i);

            //Step the iterator, moving forward based on kerning from last char
            var glyph = itr.step(text, i);

            if (!glyph)
                continue;

            //within desired range
            if (i >= start && i < end) {
                var tx = itr.pen.x;
                var ty = itr.pen.y;

                if (alignType === CENTER_ALIGN) {
                    tx += (maxLineWidth-line.width)/2;
                } else if (alignType === RIGHT_ALIGN) {
                    tx += (maxLineWidth-line.width);
                }

                if (!underlineStarted) {
                    underlineX = tx;
                    underlineStartX = tx;
                    underlineY = ty + underlinePos;
                    underlineWidth = 0;
                    underlineStarted = true;
                } else {
                    underlineWidth = tx - underlineStartX;
                }

                this.renderGlyph(i, glyph, scale, tx, ty);
            }

            //Advance the iterator to the next glyph in the string
            var newAdvance = itr.advance(glyph);

            if (i >= start && i < end)
                lastAdvance = newAdvance;
        }

        this.onEndLine(k);

        if (underline) {
            underlineWidth += lastAdvance;
            this.renderUnderline(underlineX, underlineY-underlineHeight/2, underlineWidth, underlineHeight);
        }
        
        //Steps down a line...
        if (k < wordwrapper.lines.length-1) {
            itr.advanceLine();
        }
    }

    //finish the iterator...
    itr.end();
    this.onEnd();
};

module.exports = TextRenderer;
},{"fontpath-glyph-iterator":"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/fontpath-simple-renderer/node_modules/fontpath-renderer/node_modules/fontpath-glyph-iterator/index.js","fontpath-wordwrap":"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/fontpath-simple-renderer/node_modules/fontpath-renderer/node_modules/fontpath-wordwrap/index.js"}],"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/fontpath-simple-renderer/node_modules/fontpath-renderer/node_modules/fontpath-glyph-iterator/index.js":[function(require,module,exports){
var util = require('fontpath-util');

var DEFAULT_TAB_WIDTH = 4;

function GlyphIterator(font, fontSize) {
    this._fontSize = undefined;
    this._fontScale = undefined;
    this._font = undefined;
    this.fontScale = 1.0;
    this.kerning = true;
    this.letterSpacing = 0;
    this.lineHeight = undefined;
    
    this.fontSize = typeof fontSize === 'number'
            ? fontSize
            : (font ? font.size : undefined);
    this.font = font;

    //Number of spaces for a tab character
    this.tabWidth = DEFAULT_TAB_WIDTH;
    this._tabGlyph = null;

    this.origin = { x: 0, y: 0 };
    this.pen = { x: 0, y: 0 };
}

Object.defineProperty(GlyphIterator.prototype, "font", {
    get: function() {
        return this._font;
    },

    set: function(font) {
        this._font = font;

        //Determine the new scaling factor...
        if (font) {
            this.fontScale = util.getPxScale(font, this.fontSize);

            //Updates the tab glyph
            this.tabWidth = this._tabWidth;
        }
    },
});

//There might be a better way of handling tab width using FreeType ? 
Object.defineProperty(GlyphIterator.prototype, "tabWidth", {

    get: function() {
        return this._tabWidth;
    },

    set: function(val) {
        this._tabWidth = val===0 || val ? val : DEFAULT_TAB_WIDTH;
        this._tabGlyph = {};

        var spaceGlyph = this.font ? this.font.glyphs[" "] : null;
        if (spaceGlyph) {
            this._tabGlyph = {};
            for (var k in spaceGlyph) {
                this._tabGlyph[k] = spaceGlyph[k];
            }
            if (this._tabGlyph.xoff)
                this._tabGlyph.xoff *= this._tabWidth;
        }
    },
});

Object.defineProperty(GlyphIterator.prototype, "fontSize", {
    get: function() {
        if (typeof this._fontSize !== 'number')
            return this.font.bitmap 
                ? this.font.size 
                : util.pointToPixel(this.font.size)
        return this._fontSize;
    },

    set: function(val) {
        this._fontSize = val;

        //If the font is already set, determine the new scaling factor
        if (this._font) {
            this.fontScale = util.getPxScale(this._font, this._fontSize);
        }
    },
});

GlyphIterator.prototype.getKerning = function(left, right) {
    var font = this.font;

    if (!font || !font.kerning)
        return 0;

    var table = this.kerningTable;

    for (var i=0; i<font.kerning.length; i++) {
        var k = font.kerning[i];
        if (k[0] === left && k[1] === right) 
            return k[2];
    }
    return 0;
};

GlyphIterator.prototype.begin = function(x, y) {
    this.origin.x = x||0;
    this.origin.y = y||0;

    this.pen.x = this.origin.x;
    this.pen.y = this.origin.y;
};

GlyphIterator.prototype.end = function() {
    //.. mainly for consistency with begin()
    //Might be useful later on
};

GlyphIterator.prototype.getLineGap = function() {
    //Line height handling is a mess in browsers.
    //Maybe the best solution is to encourage users to 
    //specify pixel line heights if they want to match browser standards,
    //otherwise it's unreasonable to expect the line gaps to line up exactly
    //across all browsers. Example of the disaster:
    //http://lists.w3.org/Archives/Public/www-style/2008Jan/0413.html

    //For reference, some baseline-to-baseline calculations:
    //http://www.microsoft.com/typography/otspec/recom.htm
    //freetype.org/freetype2/docs/reference/ft2-base_interface.html
    //http://www.freetype.org/freetype2/docs/glyphs/glyphs-3.html

    //Unfortunately none of these are producing line-heights that avoid overlapping
    //or resemble browser rendering in any way. 

    // If CSS uses 1em or 1, the browser offsets the line by the 
    // font's pixel size. If an exact pixel line-height is specified,
    // the browser will use that + a computed "linegap." 
    // If 'auto' is specified for line-height, the calculations seem
    // much more complex and browser/platform dependent (not included here).
    
    var font = this.font,
        scale = this.fontScale;
    var gap = (font.height - font.ascender + Math.abs(font.descender)) * scale;    
    var lineHeight = this.lineHeight;
    
    lineHeight = (lineHeight===0||lineHeight) 
            ? (lineHeight + gap)
            : this.fontSize;
    return lineHeight;
};

GlyphIterator.prototype.translate = function(x, y) {
    this.origin.x += x||0;
    this.origin.y += y||0;

    this.pen.x += x||0;
    this.pen.y += y||0;
};

GlyphIterator.prototype.step = function(text, index) {
    var scale = this.fontScale,
        font = this._font;

    var chr = text.charAt(index); 

    if (chr === '\t' && this._tabGlyph) {
        return this._tabGlyph;
    }

    //Skip missing characters...
    if (!(chr in font.glyphs))
        return;
    
    var glyph = font.glyphs[chr];

    //If we have a char to the left, determine its kerning
    if (index > 0 && this.kerning) {
        var kern = this.getKerning(text.charAt(index-1), chr);
        this.pen.x += (kern*scale);
    }

    return glyph;
};

GlyphIterator.prototype.advanceLine = function() {
    this.pen.y += this.getLineGap();
    this.pen.x = this.origin.x;
};

/**
 * Called after step. 
 */
GlyphIterator.prototype.advance = function(glyph) {
    var advance = (glyph.xoff * this.fontScale);
    // Advance to next pen position
    this.pen.x += advance + this.letterSpacing;
    return advance;
};

/**
 * This is a utility function that provides the bounds of the given
 * text (from start and end positions) as if they were laid out horizontally,
 * left to right.
 *
 * For convenience, this will not alter the current pen and origin positions.
 * This way it can be utilized inside a glyph iteration (i.e. for rendering).
 *
 * If `availableWidth` is specified, this will break before reaching the specified
 * pixel width, to ensure that all glyphs will fit inside the bounds. 
 *
 * The return object also includes a `glyphs` property, which is the number of glyphs
 * that are visible within the returned bounds. 
 *
 * If `out` is specified (an object with x, y, width, height, and glyph properties),
 * it will be re-used. Otherwise a new object is created.
 * 
 * @param {String} text the text to check
 * @param {Number} start the start position, defaults to 0
 * @param {Number} end the end position, exclusive, defaults to text length
 * @param {Number} availableWidth the width before stopping the bound check
 * @param {Object} out an object to re-use for the return value
 * @return {Object} the bounds and glyph count {x,y,width,height,glyphs}
 */
GlyphIterator.prototype.getBounds = function(text, start, end, availableWidth, out) {
    if (!out)
        out = { x:0, y:0, width: 0, height: 0, glyphs: 0 };

    var checkWidth = availableWidth===0||availableWidth;

    start = start||0;
    end = end===0||end ? end : text.length;

    var maxHeight = 0;

    out.x = 0;
    out.y = 0;
    out.glyphs = 0;

    var oldPenX = this.pen.x,
        oldPenY = this.pen.y,
        oldOriginX = this.origin.x,
        oldOriginY = this.origin.y;


    var font = this.font;
    this.begin();
    for (var i=start; i<end; i++) {
        var chr = text.charAt(i);

        //step the iterator
        var glyph = this.step(text, i);

        //if the glyph is valid, we can advance past it and calculate new height
        if (glyph) {
            var height = (glyph.height)*this.fontScale;

            out.y = Math.max(out.y, this.fontScale*(glyph.height-glyph.hby));

            maxHeight = Math.max(maxHeight, height);
            var lastAdvance = this.advance(glyph);

            //if we're past the available width
            var newWidth = this.pen.x - this.origin.x;
            if (checkWidth && (newWidth - availableWidth > 0.001)) {
                this.pen.x -= lastAdvance;
                break;
            }

            out.glyphs++;
        }
    }
    this.end();

    out.width = this.pen.x - this.origin.x;
    out.height = maxHeight;

    this.pen.x = oldPenX;
    this.pen.y = oldPenY;
    this.origin.x = oldOriginX;
    this.origin.y = oldOriginY;

    return out;
};

module.exports = GlyphIterator;
},{"fontpath-util":"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/fontpath-simple-renderer/node_modules/fontpath-renderer/node_modules/fontpath-util/index.js"}],"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/fontpath-simple-renderer/node_modules/fontpath-renderer/node_modules/fontpath-util/index.js":[function(require,module,exports){
// module.exports.pointsToPixels = function(pointSize, resolution) {
// 	resolution = typeof resolution === "number" ? resolution : 72;
// 	return pointSize * resolution / 72;
// };

// module.exports.coordToPixel = function(coord, pixelSize, emSize) {
// 	emSize = typeof emSize === "number" ? emSize : 2048;
// 	return coord * pixelSize / emSize;
// };

/**
 * Converts a pt size to px size, namely useful for matching
 * size with CSS styles. If no DPI is specified, 96 is assumed
 * (as it leads to correct rendering in all browsers).
 * 
 * @param  {Number} fontSize the desired font size in points
 * @param  {Number} dpi      the expected DPI, generally 96 for browsers
 * @return {Number}          the rounded pixel font size
 */
module.exports.pointToPixel = function(fontSize, dpi) {
    dpi = dpi||dpi===0 ? dpi : 96;
    fontSize = fontSize * dpi / 72;
    return Math.round(fontSize);
};

/**
 * For the given font and (pixel) font size, this method returns the
 * scale that will need to be applied to EM units (i.e. font paths) 
 * to have the font render at the expected size (i.e. to match the browser).
 *
 * If no font size is specified, we will use the default font size (which is in points)
 * and convert it to pixels. 
 * 
 * @param  {Font} font     a font object from the fontpath tool
 * @param  {Number} fontSize the desired font size, defaults to the font's default size
 * @return {Number} returns the scale for this font size         
 */
module.exports.getPxScale = function(font, fontSize) {
    if (font.bitmap)
        return 1.0;

    //If no fontSize is specified, it will just fall back to using the font's own size with 96 DPI.
    fontSize = typeof fontSize === "number" ? fontSize : this.pointToPixel(font.size);

    //Takes in a font size in PIXELS and gives us the expected scaling factor
    var sz = font.units_per_EM/64;
    sz = (sz/font.size * fontSize);

    return ((font.resolution * 1/72 * sz) / font.units_per_EM);
};

/**
 * For the given font and (point) font size, this method returns the
 * scale that will need to be applied to EM units (i.e. font paths) 
 * to have the font render at the expected size (i.e. to match the browser).
 * 
 * If no font size is specified, we will use the default font size.
 * 
 * @param  {Font} font       a font object from the fontpath tool
 * @param  {Number} fontSize the desired font size, defaults to the font's default size
 * @return {Number}          the scale for this font size
 */
module.exports.getPtScale = function(font, fontSize) {
    fontSize = typeof fontSize === "number" ? fontSize : font.size;
    fontSize = this.pointToPixel(fontSize);
    return this.getPxScale(font, fontSize);
};

},{}],"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/fontpath-simple-renderer/node_modules/fontpath-renderer/node_modules/fontpath-wordwrap/index.js":[function(require,module,exports){
var tmpBounds = { x: 0, y: 0, width: 0, height: 0, glyphs: 0 };

function isWhitespace(chr) {
	return chr===' '
		|| chr==='\n'
		|| chr==='\r'
		|| chr==='\t';
}

function idxOf(text, chr, start, end) {
	var idx = text.indexOf(chr, start);
	if (idx === -1 || idx > end)
		return end;
	return idx;
}

function WordWrap(text) {
	/**
	 * The text being operated on.
	 * @param {String} text
	 */
	this.text = text||"";

	/**
	 * An array of lines representing the state of this word wrapper.
	 * @param {Array} lines
	 */
	this.lines = [];

	/** 
	 * The newline character to break on, default '\n'
	 * @param {String} newline
	 */
	this.newline = '\n';

	/**
	 * Whether to clip non-breaking text (nowrap and pre)
	 * if the wrapWidth is too small. 
	 *  
	 * @param {Boolean} clip
	 */
	this.clip = false;

	/**
	 * The mode for wordwrapping: 'pre', 'normal', or 'nowrap'.
	 *
	 * You can also use the `PRE`, `NORMAL`, and `NOWRAP` constants
	 * in `WordWrap.Mode`.
	 * 
	 * @param {String} mode
	 */
	this.mode = WordWrap.Mode.NORMAL;
}

WordWrap.Mode = {
	PRE: 'pre',       //whitespace isn't collapsed
	NORMAL: 'normal', //whitespace is collapsed
	NOWRAP: 'nowrap'  //only break on '\n'
};

/**
 * Clears any multi-line layout by placing all the text in a single Line object.
 * 
 * @param {GlyphIterator} iterator the iterator to use 
 * @method  clearLayout
 */
WordWrap.prototype.clearLayout = function(iterator) {
	this.lines.length = 0;
	
	if (this.text.length > 0) {
		iterator.getBounds(this.text, 0, this.text.length, undefined, tmpBounds);
		
		var line = new WordWrap.Line(0, this.text.length, tmpBounds.width);
		this.lines.push(line);
	}
};

/**
 * Resets the word wrapper by emptying all current lines.
 * @method  empty
 */
WordWrap.prototype.empty = function() {
	this.lines.length = 0;
};

/**
 * Word-wraps the given text into multiple lines.
 * @param  {[type]} iterator [description]
 * @param  {[type]} width    [description]
 * @param  {[type]} start    [description]
 * @param  {[type]} end      [description]
 * @return {[type]}          [description]
 */
WordWrap.prototype.layout = function(iterator, wrapWidth, start, end) {
	var text = this.text;

	var lines = this.lines;

	start = Math.max(0, start||0);
	end = (end===0||end) ? end : text.length;

	iterator.begin();

	//default wrap width...
	wrapWidth = (wrapWidth===0 || wrapWidth) ? wrapWidth : Number.MAX_VALUE;

	//<pre> mode just uses a simple algorithm...
	if (this.mode === WordWrap.Mode.PRE) {
		var lineStart = start;
		for (var i=start; i<end; i++) {
			var chr = text.charAt(i);

			//If we've reached a newline, then step down a line
			//Or if we've reached the EOF
			if ( chr === this.newline || i===end-1) {
				var availableWidth = this.clip ? wrapWidth : undefined;
				iterator.getBounds(text, lineStart, i+1, availableWidth, tmpBounds);
				lines.push( new WordWrap.Line(lineStart, lineStart+tmpBounds.glyphs, tmpBounds.width) );
				lineStart = i+1;
			}
		}
	} 
	//'normal' mode uses LibGDX's word wrapping algorithm:
	//https://github.com/libgdx/libgdx/blob/master/gdx/src/com/badlogic/gdx/graphics/g2d/BitmapFontCache.java
	else {
		//if 'nowrap' is specified, we only wrap on newline chars
		
		var testWidth = wrapWidth;
		if (this.mode === WordWrap.Mode.NOWRAP) {
			testWidth = Number.MAX_VALUE;
		}

		while (start < end) {
			//get next newline position
			var newLine = idxOf(text, this.newline, start, end);

			//eat whitespace at start of line
			while (start < newLine) {
				if (!isWhitespace( text.charAt(start) ))
					break;
				start++;
			}

			//determine visible # of glyphs for the available width
			iterator.getBounds(text, start, newLine, testWidth, tmpBounds)

			var lineEnd = start + tmpBounds.glyphs;
			var nextStart = lineEnd + this.newline.length;

			//if we had to cut the line before the next newline...
			if (lineEnd < newLine) {
				//find char to break on
				while (lineEnd > start) {
					if (isWhitespace(text.charAt(lineEnd)))
						break;
					lineEnd--;
				}
				if (lineEnd === start) {
					if (nextStart > start + this.newline.length) nextStart--;
					lineEnd = nextStart; // If no characters to break, show all.
				} else {
					nextStart = lineEnd;
					//eat whitespace at end of line
					while (lineEnd > start) {
						if (!isWhitespace(text.charAt(lineEnd - this.newline.length)))
							break;
						lineEnd--;
					}
				}
			}

			if (lineEnd > start) {
				//to clip, use the original wrap width (unaltered by mode)
				var availableWidth = this.clip ? wrapWidth : undefined;
				iterator.getBounds(text, start, lineEnd, availableWidth, tmpBounds);
				var lineWidth = tmpBounds.width;

				var rLineEnd = this.clip ? start+tmpBounds.glyphs : lineEnd;
				lines.push( new WordWrap.Line(start, rLineEnd, lineWidth) );
			}
			start = nextStart;

		}
	}

	iterator.end();
};

/**
 * A convenience method to return the maximum width of all current lines.
 * This is useful for aligning blocks of text.
 *
 * @method  getMaxLineWidth
 * @return {Number} the maximum width of all lines
 */
WordWrap.prototype.getMaxLineWidth = function() {
	var maxWidth = 0;
	for (var i=0; i<this.lines.length; i++) {
		var line = this.lines[i];
		maxWidth = Math.max(line.width, maxWidth);
	}
	return maxWidth;
};

/**
 * The Line object holds the start and end indices into the string,
 * and the width as computed by GlyphIterator.
 * 
 * @class  WordWrap.Line
 * @param {Number} start the start index, inclusive
 * @param {Number} end   the end index, exclusive
 * @param {Number} width the computed width of this line
 */
WordWrap.Line = function(start, end, width) {
	this.start = start;
	this.end = end;
	this.width = width;
};

module.exports = WordWrap;
},{}],"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/common.js":[function(require,module,exports){
var createVAO = require('gl-aliased-vao') //TODO: improve this with gl-vao
var createBuffer = require('gl-buffer')

module.exports.floatsPerVertex = 5

function createIndices(capacity) {
    var numIndices = capacity * 6
    var indices = new Uint16Array(numIndices)

    for (var i = 0, j = 0; i < numIndices; i += 6, j += 4) {
        indices[i + 0] = j + 0
        indices[i + 1] = j + 1
        indices[i + 2] = j + 2
        indices[i + 3] = j + 0
        indices[i + 4] = j + 2
        indices[i + 5] = j + 3
    }
    return indices
}

module.exports.mixins = {

    create: function create(opt) {
        opt = opt||{}
        this.clear()

        //dispose before building...
        if (this.vao)
            this.dispose()

        var capacity = typeof opt.capacity === 'number' ? opt.capacity : 100

        // 65535 is max index, so 65535 / 6 = 10922.
        if (capacity > 10922)
            throw new Error("Can't have more than 10922 quads per batch: " + capacity)

        this._capacity = capacity

        //the total number of floats in our batch
        var numVerts = capacity * 4 * module.exports.floatsPerVertex

        this.vertices = new Float32Array(numVerts)
        this.indices = createIndices(capacity)

        var gl = this.gl
        var usage = opt.dynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW
        this.vertexBuffer = createBuffer(gl, this.vertices, gl.ARRAY_BUFFER, usage)
        this.indexBuffer = createBuffer(gl, this.indices, gl.ELEMENT_ARRAY_BUFFER, gl.STATIC_DRAW)

        var stride = 5 * 4
        this.vao = createVAO(gl, [{ //position XY
            name: 'position',
            buffer: this.vertexBuffer,
            size: 2,
            stride: stride
        }, { //texcoord UV
            name: 'texcoord0',
            buffer: this.vertexBuffer,
            size: 2,
            offset: 2 * 4,
            stride: stride
        }, { //color (packed) C
            name: 'color',
            buffer: this.vertexBuffer,
            size: 4,
            stride: stride,
            offset: 4 * 4,
            type: gl.UNSIGNED_BYTE,
            normalized: true
        }], this.indexBuffer)
        return this
    },

    ensureCapacity: function(capacity) {
        if (this.capacity < capacity)
            this.create({ capacity: capacity })
        return this
    }
}
},{"gl-aliased-vao":"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/gl-aliased-vao/index.js","gl-buffer":"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/gl-buffer/buffer.js"}],"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/index.js":[function(require,module,exports){
var colorToFloat = require('./pack-rgba-float')
var mixes = require('mixes')
var premult = require('premultiplied-rgba')
var WhiteTex = require('gl-white-texture')

var vertNumFloats = require('./common').floatsPerVertex

//Temporary arrays to avoid GC thrashing
var position = [0, 0],
    shape = [0, 0],
    texcoord = [0, 0, 0, 0],
    color = [0, 0, 0, 0]

var tmp4 = [0, 0, 0, 0],
    rotOrigin = [0, 0],
    tmp2 = [0, 0]

function SpriteBatch(gl, opt) {
    if (!(this instanceof SpriteBatch))
        return new SpriteBatch(gl, opt)
    if (!gl)
        throw new Error("must specify gl context")
    this.gl = gl
    opt = opt || {}
    
    this._bound = false
    this.idx = 0

    //no transform means identity
    this.transform = null

    //white texture is akin to "no texture" (without switching shaders)
    this._defaultTexture = opt.defaultTexture || WhiteTex(gl)
    this._ownsDefault = !opt.defaultTexture
    this._lastTexture = this._defaultTexture
    this._texture = this._defaultTexture
    this.texture = null

    this.mode = typeof opt.mode === 'number' ? opt.mode : gl.TRIANGLES
    this.premultiplied = opt.premultiplied || false

    this._dirty = true
    this.create(opt)

    //set default attributes
    this.defaults()
}

//mix in create() and ensureCapacity() functions
mixes(SpriteBatch, require('./common').mixins)

mixes(SpriteBatch, {

    capacity: {
        get: function() {
            return this._capacity
        }
    },

    texture: {
        get: function() {
            return this._texture
        },

        set: function(tex) {
            this._texture = tex || this._defaultTexture
        }
    },

    dispose: function() {
        if (this.vertexBuffer)
            this.vertexBuffer.dispose()
        if (this.indexBuffer)
            this.indexBuffer.dispose()
        if (this.vao)
            this.vao.dispose()
        if (this._ownsDefault)
            this._defaultTexture.dispose()
    },

    clear: function() {
        this.idx = 0
        return this
    },

    bind: function(shader) {
        shader.bind()
        this.vao.bind(shader)
        this._bound = true
    },

    unbind: function() {
        this.vao.unbind()
        this._bound = false
    },

    defaults: function() {
        this.position = copy2(position, 0, 0)
        this.texcoord = copy4(texcoord, 0, 0, 1, 1)
        this.color = copy4(color, 1, 1, 1, 1)
        this.shape = copy2(shape, 0, 0)
        return this
    },

    push: function(sprite) {
        //if we are defining attributes on the fly
        if (sprite) {
            this.texture = sprite.texture
            this.position = sprite.position || copy2(position, 0, 0)
            this.texcoord = sprite.texcoord || copy4(texcoord, 0, 0, 1, 1)
            this.color = sprite.color || copy4(color, 1, 1, 1, 1)
            this.shape = sprite.shape || copy2(shape, 0, 0)
        }

        if (this.texture !== this._lastTexture) {
            //new texture, flush previous data
            if (this._bound)
                this.flush()
            this._lastTexture = this.texture
        } else if (this.idx === this.vertices.length) {
            //if we AREN'T bound, we need to stop pushing vertex data!
            if (!this._bound)
                return this

            //if we ARE bound, we can flush the batch and continue drawing
            this.flush()
        }

        this._dirty = true

        //get RGBA components and pack into a single float
        var colorRGBA = this.premultiplied ? premult(this.color, tmp4) : this.color
        var c = colorToFloat(colorRGBA)

        var u1 = this.texcoord[0],
            v1 = this.texcoord[1],
            u2 = this.texcoord[2],
            v2 = this.texcoord[3]

        var x = this.position[0],
            y = this.position[1],
            width = this.shape[0],
            height = this.shape[1]

        this._vert(x, y, u1, v1, c)
        this._vert(x+width, y, u2, v1, c)
        this._vert(x+width, y+height, u2, v2, c)
        this._vert(x, y+height, u1, v2, c)
        
        return this
    },

    _vert: function(x1, y1, u1, v1, c) {
        var idx = this.idx,
            verts = this.vertices,
            transform = this.transform

        if (transform) {
            var x = x1, y = y1
            x1 = transform[0] * x + transform[4] * y + transform[12]
            y1 = transform[1] * x + transform[5] * y + transform[13]
        }

        //xy
        verts[idx++] = x1
        verts[idx++] = y1
        //uv
        verts[idx++] = u1
        verts[idx++] = v1
        //color
        verts[idx++] = c
        this.idx = idx
    },

    flush: function() {
        this.draw()
        return this.clear()
    },

    draw: function() {
        //If we've reached a new texture or capacity
        //while not bound, then we will just clear the batch
        //to zero and draw nothing
        if (this.idx === 0 || !this._bound)
            return this

        var gl = this.gl
        
        if (this._dirty) {
            var view = this.vertices.subarray(0, this.idx)
            this.vertexBuffer.update(view, 0)
            this._dirty = false
        }

        if (this._lastTexture)
            this._lastTexture.bind()
        this._lastTexture = this.texture

        var sprites = (this.idx / (vertNumFloats * 4))
        if (sprites > 0)
            this.vao.draw(this.mode, sprites * 6, 0)
        return this
    },
})

module.exports = SpriteBatch

//TODO: will use modular gl-matrix for these...
function copy2(out, x, y) {
    out[0] = x
    out[1] = y
    return out
}

function copy4(out, x, y, z, w) {
    out[0] = x
    out[1] = y
    out[2] = z
    out[3] = w
    return out
}

function copyVec2(out, vec) {
    return copy2(out, vec[0], vec[1])
}

function transformMat4(out, a, m) {
    var x = a[0], 
        y = a[1]
    out[0] = m[0] * x + m[4] * y + m[12]
    out[1] = m[1] * x + m[5] * y + m[13]
    return out
}
},{"./common":"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/common.js","./pack-rgba-float":"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/pack-rgba-float.js","gl-white-texture":"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/gl-white-texture/index.js","mixes":"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/mixes/index.js","premultiplied-rgba":"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/premultiplied-rgba/index.js"}],"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/gl-aliased-vao/index.js":[function(require,module,exports){
var createVAOEmulated = require("./lib/vao-emulated.js")

function createVAO(gl, attributes, elements, elementsType) {
  var vao = createVAOEmulated(gl)
  vao.update(attributes, elements, elementsType)
  return vao
}

module.exports = createVAO
},{"./lib/vao-emulated.js":"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/gl-aliased-vao/lib/vao-emulated.js"}],"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/gl-aliased-vao/lib/do-bind.js":[function(require,module,exports){
function getAttributeLocation(name, shader) {
    if (!name)
        return null
    var attr = shader.attributes
    if (attr[name]) 
        return attr[name].location
    return null
}

var nattribs = null
var bound = null

function doBind(gl, elements, attributes, shader) {
    if (elements) {
        elements.bind()
    } else {
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null)
    }
    if (nattribs === null) {
      nattribs = gl.getParameter(gl.MAX_VERTEX_ATTRIBS) | 0
      bound = new Array(nattribs)
    }

    if (attributes) {
        if (attributes.length > nattribs) {
            throw new Error("gl-vao: Too many vertex attributes")
        }

        var lastBound = null

        for (i=0; i<nattribs; i++)
          bound[i] = false

        //now bind aliased attributes
        for (i=0; i<attributes.length; i++) {
            var attrib = attributes[i]
            var loc = getAttributeLocation(attrib.name, shader)
            if (loc === null)
                continue

            bound[loc] = true

            if(attrib.buffer) {
              var buffer = attrib.buffer
              var size = attrib.size || 4
              var type = attrib.type || gl.FLOAT
              var normalized = !!attrib.normalized
              var stride = attrib.stride || 0
              var offset = attrib.offset || 0
              if (lastBound !== buffer) {
                buffer.bind()
                lastBound = buffer
              }
              gl.enableVertexAttribArray(loc)
              gl.vertexAttribPointer(loc, size, type, normalized, stride, offset)
            } else {
              if(typeof attrib === "number") {
                gl.vertexAttrib1f(loc, attrib)
              } else if(attrib.length === 1) {
                gl.vertexAttrib1f(loc, attrib[0])
              } else if(attrib.length === 2) {
                gl.vertexAttrib2f(loc, attrib[0], attrib[1])
              } else if(attrib.length === 3) {
                gl.vertexAttrib3f(loc, attrib[0], attrib[1], attrib[2])
              } else if(attrib.length === 4) {
                gl.vertexAttrib4f(loc, attrib[0], attrib[1], attrib[2], attrib[3])
              } else {
                throw new Error("gl-vao: Invalid vertex attribute")
              }
              gl.disableVertexAttribArray(loc)
            }

        }
        
        for (i=0; i<nattribs; i++) {
          if (!bound[i])
            gl.disableVertexAttribArray(i)
        }
    } else {
      gl.bindBuffer(gl.ARRAY_BUFFER, null)
      for(var i=0; i<nattribs; ++i) {
        gl.disableVertexAttribArray(i)
      }
    }
}

module.exports = doBind
},{}],"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/gl-aliased-vao/lib/vao-emulated.js":[function(require,module,exports){
var bindAttribs = require("./do-bind.js")

function VAOEmulated(gl) {
  this.gl = gl
  this._elements = null
  this._attributes = null
  this._elementsType = gl.UNSIGNED_SHORT
}

VAOEmulated.prototype.bind = function(shader) {
  if (!shader)
    throw new Error('must associate shader with vertex array')
  bindAttribs(this.gl, this._elements, this._attributes, shader)
}

VAOEmulated.prototype.update = function(attributes, elements, elementsType) {
  this._elements = elements
  this._attributes = attributes
  this._elementsType = elementsType || this.gl.UNSIGNED_SHORT
}

VAOEmulated.prototype.dispose = function() { }
VAOEmulated.prototype.unbind = function() {
  bindAttribs(this.gl)
}

VAOEmulated.prototype.draw = function(mode, count, offset) {
  offset = offset || 0
  var gl = this.gl
  if(this._elements) {
    gl.drawElements(mode, count, this._elementsType, offset)
  } else {
    gl.drawArrays(mode, offset, count)
  }
}

function createVAOEmulated(gl) {
  return new VAOEmulated(gl)
}

module.exports = createVAOEmulated
},{"./do-bind.js":"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/gl-aliased-vao/lib/do-bind.js"}],"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/gl-buffer/buffer.js":[function(require,module,exports){
"use strict"

var pool = require("typedarray-pool")
var ops = require("ndarray-ops")
var ndarray = require("ndarray")
var webglew = require("webglew")

var SUPPORTED_TYPES = [
  "uint8",
  "uint8_clamped",
  "uint16",
  "uint32",
  "int8",
  "int16",
  "int32",
  "float32" ]

function GLBuffer(gl, type, handle, length, usage) {
  this.gl = gl
  this.type = type
  this.handle = handle
  this.length = length
  this.usage = usage
}

var proto = GLBuffer.prototype

proto.bind = function() {
  this.gl.bindBuffer(this.type, this.handle)
}

proto.unbind = function() {
  this.gl.bindBuffer(this.type, null)
}

proto.dispose = function() {
  this.gl.deleteBuffer(this.handle)
}

function updateTypeArray(gl, type, len, usage, data, offset) {
  var dataLen = data.length * data.BYTES_PER_ELEMENT 
  if(offset < 0) {
    gl.bufferData(type, data, usage)
    return dataLen
  }
  if(dataLen + offset > len) {
    throw new Error("gl-buffer: If resizing buffer, must not specify offset")
  }
  gl.bufferSubData(type, offset, data)
  return len
}

function makeScratchTypeArray(array, dtype) {
  var res = pool.malloc(array.length, dtype)
  var n = array.length
  for(var i=0; i<n; ++i) {
    res[i] = array[i]
  }
  return res
}

function isPacked(shape, stride) {
  var n = 1
  for(var i=stride.length-1; i>=0; --i) {
    if(stride[i] !== n) {
      return false
    }
    n *= shape[i]
  }
  return true
}

proto.update = function(array, offset) {
  if(typeof offset !== "number") {
    offset = -1
  }
  this.bind()
  if(typeof array === "object" && typeof array.shape !== "undefined") { //ndarray
    var dtype = array.dtype
    if(SUPPORTED_TYPES.indexOf(dtype) < 0) {
      dtype = "float32"
    }
    if(this.type === this.gl.ELEMENT_ARRAY_BUFFER) {
      var wgl = webglew(this.gl)
      var ext = wgl.OES_element_index_uint
      if(ext && dtype !== "uint16") {
        dtype = "uint32"
      } else {
        dtype = "uint16"
      }
    }
    if(dtype === array.dtype && isPacked(array.shape, array.stride)) {
      if(array.offset === 0 && array.data.length === array.shape[0]) {
        this.length = updateTypeArray(this.gl, this.type, this.length, this.usage, array.data, offset)
      } else {
        this.length = updateTypeArray(this.gl, this.type, this.length, this.usage, array.data.subarray(array.offset, array.shape[0]), offset)
      }
    } else {
      var tmp = pool.malloc(array.size, dtype)
      var ndt = ndarray(tmp, array.shape)
      ops.assign(ndt, array)
      if(offset < 0) {
        this.length = updateTypeArray(this.gl, this.type, this.length, this.usage, tmp, offset)  
      } else {
        this.length = updateTypeArray(this.gl, this.type, this.length, this.usage, tmp.subarray(0, array.size), offset)  
      }
      pool.free(tmp)
    }
  } else if(Array.isArray(array)) { //Vanilla array
    var t
    if(this.type === this.gl.ELEMENT_ARRAY_BUFFER) {
      t = makeScratchTypeArray(array, "uint16")
    } else {
      t = makeScratchTypeArray(array, "float32")
    }
    if(offset < 0) {
      this.length = updateTypeArray(this.gl, this.type, this.length, this.usage, t, offset)
    } else {
      this.length = updateTypeArray(this.gl, this.type, this.length, this.usage, t.subarray(0, array.length), offset)
    }
    pool.free(t)
  } else if(typeof array === "object" && typeof array.length === "number") { //Typed array
    this.length = updateTypeArray(this.gl, this.type, this.length, this.usage, array, offset)
  } else if(typeof array === "number" || array === undefined) { //Number/default
    if(offset >= 0) {
      throw new Error("gl-buffer: Cannot specify offset when resizing buffer")
    }
    array = array | 0
    if(array <= 0) {
      array = 1
    }
    this.gl.bufferData(this.type, array|0, this.usage)
    this.length = array
  } else { //Error, case should not happen
    throw new Error("gl-buffer: Invalid data type")
  }
}

function createBuffer(gl, data, type, usage) {
  webglew(gl)
  type = type || gl.ARRAY_BUFFER
  usage = usage || gl.DYNAMIC_DRAW
  if(type !== gl.ARRAY_BUFFER && type !== gl.ELEMENT_ARRAY_BUFFER) {
    throw new Error("gl-buffer: Invalid type for webgl buffer, must be either gl.ARRAY_BUFFER or gl.ELEMENT_ARRAY_BUFFER")
  }
  if(usage !== gl.DYNAMIC_DRAW && usage !== gl.STATIC_DRAW && usage !== gl.STREAM_DRAW) {
    throw new Error("gl-buffer: Invalid usage for buffer, must be either gl.DYNAMIC_DRAW, gl.STATIC_DRAW or gl.STREAM_DRAW")
  }
  var handle = gl.createBuffer()
  var result = new GLBuffer(gl, type, handle, 0, usage)
  result.update(data)
  return result
}

module.exports = createBuffer
},{"ndarray":"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/gl-buffer/node_modules/ndarray/ndarray.js","ndarray-ops":"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/gl-buffer/node_modules/ndarray-ops/ndarray-ops.js","typedarray-pool":"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/gl-buffer/node_modules/typedarray-pool/pool.js","webglew":"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/gl-buffer/node_modules/webglew/webglew.js"}],"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/gl-buffer/node_modules/ndarray-ops/ndarray-ops.js":[function(require,module,exports){
module.exports=require("/projects/blackice/node_modules/gl-texture2d/node_modules/ndarray-ops/ndarray-ops.js")
},{"/projects/blackice/node_modules/gl-texture2d/node_modules/ndarray-ops/ndarray-ops.js":"/projects/blackice/node_modules/gl-texture2d/node_modules/ndarray-ops/ndarray-ops.js"}],"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/gl-buffer/node_modules/ndarray/ndarray.js":[function(require,module,exports){
(function (Buffer){
var iota = require("iota-array")

var hasTypedArrays  = ((typeof Float64Array) !== "undefined")
var hasBuffer       = ((typeof Buffer) !== "undefined")

function compare1st(a, b) {
  return a[0] - b[0]
}

function order() {
  var stride = this.stride
  var terms = new Array(stride.length)
  var i
  for(i=0; i<terms.length; ++i) {
    terms[i] = [Math.abs(stride[i]), i]
  }
  terms.sort(compare1st)
  var result = new Array(terms.length)
  for(i=0; i<result.length; ++i) {
    result[i] = terms[i][1]
  }
  return result
}

function compileConstructor(dtype, dimension) {
  var className = ["View", dimension, "d", dtype].join("")
  if(dimension < 0) {
    className = "View_Nil" + dtype
  }
  var useGetters = (dtype === "generic")
  
  if(dimension === -1) {
    //Special case for trivial arrays
    var code = 
      "function "+className+"(a){this.data=a;};\
var proto="+className+".prototype;\
proto.dtype='"+dtype+"';\
proto.index=function(){return -1};\
proto.size=0;\
proto.dimension=-1;\
proto.shape=proto.stride=proto.order=[];\
proto.lo=proto.hi=proto.transpose=proto.step=\
function(){return new "+className+"(this.data);};\
proto.get=proto.set=function(){};\
proto.pick=function(){return null};\
return function construct_"+className+"(a){return new "+className+"(a);}"
    var procedure = new Function(code)
    return procedure()
  } else if(dimension === 0) {
    //Special case for 0d arrays
    var code =
      "function "+className+"(a,d) {\
this.data = a;\
this.offset = d\
};\
var proto="+className+".prototype;\
proto.dtype='"+dtype+"';\
proto.index=function(){return this.offset};\
proto.dimension=0;\
proto.size=1;\
proto.shape=\
proto.stride=\
proto.order=[];\
proto.lo=\
proto.hi=\
proto.transpose=\
proto.step=function "+className+"_copy() {\
return new "+className+"(this.data,this.offset)\
};\
proto.pick=function "+className+"_pick(){\
return TrivialArray(this.data);\
};\
proto.valueOf=proto.get=function "+className+"_get(){\
return "+(useGetters ? "this.data.get(this.offset)" : "this.data[this.offset]")+
"};\
proto.set=function "+className+"_set(v){\
return "+(useGetters ? "this.data.set(this.offset,v)" : "this.data[this.offset]=v")+"\
};\
return function construct_"+className+"(a,b,c,d){return new "+className+"(a,d)}"
    var procedure = new Function("TrivialArray", code)
    return procedure(CACHED_CONSTRUCTORS[dtype][0])
  }

  var code = ["'use strict'"]
    
  //Create constructor for view
  var indices = iota(dimension)
  var args = indices.map(function(i) { return "i"+i })
  var index_str = "this.offset+" + indices.map(function(i) {
        return "this.stride[" + i + "]*i" + i
      }).join("+")
  var shapeArg = indices.map(function(i) {
      return "b"+i
    }).join(",")
  var strideArg = indices.map(function(i) {
      return "c"+i
    }).join(",")
  code.push(
    "function "+className+"(a," + shapeArg + "," + strideArg + ",d){this.data=a",
      "this.shape=[" + shapeArg + "]",
      "this.stride=[" + strideArg + "]",
      "this.offset=d|0}",
    "var proto="+className+".prototype",
    "proto.dtype='"+dtype+"'",
    "proto.dimension="+dimension)
  
  //view.size:
  code.push("Object.defineProperty(proto,'size',{get:function "+className+"_size(){\
return "+indices.map(function(i) { return "this.shape["+i+"]" }).join("*"),
"}})")

  //view.order:
  if(dimension === 1) {
    code.push("proto.order=[0]")
  } else {
    code.push("Object.defineProperty(proto,'order',{get:")
    if(dimension < 4) {
      code.push("function "+className+"_order(){")
      if(dimension === 2) {
        code.push("return (Math.abs(this.stride[0])>Math.abs(this.stride[1]))?[1,0]:[0,1]}})")
      } else if(dimension === 3) {
        code.push(
"var s0=Math.abs(this.stride[0]),s1=Math.abs(this.stride[1]),s2=Math.abs(this.stride[2]);\
if(s0>s1){\
if(s1>s2){\
return [2,1,0];\
}else if(s0>s2){\
return [1,2,0];\
}else{\
return [1,0,2];\
}\
}else if(s0>s2){\
return [2,0,1];\
}else if(s2>s1){\
return [0,1,2];\
}else{\
return [0,2,1];\
}}})")
      }
    } else {
      code.push("ORDER})")
    }
  }
  
  //view.set(i0, ..., v):
  code.push(
"proto.set=function "+className+"_set("+args.join(",")+",v){")
  if(useGetters) {
    code.push("return this.data.set("+index_str+",v)}")
  } else {
    code.push("return this.data["+index_str+"]=v}")
  }
  
  //view.get(i0, ...):
  code.push("proto.get=function "+className+"_get("+args.join(",")+"){")
  if(useGetters) {
    code.push("return this.data.get("+index_str+")}")
  } else {
    code.push("return this.data["+index_str+"]}")
  }
  
  //view.index:
  code.push(
    "proto.index=function "+className+"_index(", args.join(), "){return "+index_str+"}")

  //view.hi():
  code.push("proto.hi=function "+className+"_hi("+args.join(",")+"){return new "+className+"(this.data,"+
    indices.map(function(i) {
      return ["(typeof i",i,"!=='number'||i",i,"<0)?this.shape[", i, "]:i", i,"|0"].join("")
    }).join(",")+","+
    indices.map(function(i) {
      return "this.stride["+i + "]"
    }).join(",")+",this.offset)}")
  
  //view.lo():
  var a_vars = indices.map(function(i) { return "a"+i+"=this.shape["+i+"]" })
  var c_vars = indices.map(function(i) { return "c"+i+"=this.stride["+i+"]" })
  code.push("proto.lo=function "+className+"_lo("+args.join(",")+"){var b=this.offset,d=0,"+a_vars.join(",")+","+c_vars.join(","))
  for(var i=0; i<dimension; ++i) {
    code.push(
"if(typeof i"+i+"==='number'&&i"+i+">=0){\
d=i"+i+"|0;\
b+=c"+i+"*d;\
a"+i+"-=d}")
  }
  code.push("return new "+className+"(this.data,"+
    indices.map(function(i) {
      return "a"+i
    }).join(",")+","+
    indices.map(function(i) {
      return "c"+i
    }).join(",")+",b)}")
  
  //view.step():
  code.push("proto.step=function "+className+"_step("+args.join(",")+"){var "+
    indices.map(function(i) {
      return "a"+i+"=this.shape["+i+"]"
    }).join(",")+","+
    indices.map(function(i) {
      return "b"+i+"=this.stride["+i+"]"
    }).join(",")+",c=this.offset,d=0,ceil=Math.ceil")
  for(var i=0; i<dimension; ++i) {
    code.push(
"if(typeof i"+i+"==='number'){\
d=i"+i+"|0;\
if(d<0){\
c+=b"+i+"*(a"+i+"-1);\
a"+i+"=ceil(-a"+i+"/d)\
}else{\
a"+i+"=ceil(a"+i+"/d)\
}\
b"+i+"*=d\
}")
  }
  code.push("return new "+className+"(this.data,"+
    indices.map(function(i) {
      return "a" + i
    }).join(",")+","+
    indices.map(function(i) {
      return "b" + i
    }).join(",")+",c)}")
  
  //view.transpose():
  var tShape = new Array(dimension)
  var tStride = new Array(dimension)
  for(var i=0; i<dimension; ++i) {
    tShape[i] = "a[i"+i+"]"
    tStride[i] = "b[i"+i+"]"
  }
  code.push("proto.transpose=function "+className+"_transpose("+args+"){"+
    args.map(function(n,idx) { return n + "=(" + n + "===undefined?" + idx + ":" + n + "|0)"}).join(";"),
    "var a=this.shape,b=this.stride;return new "+className+"(this.data,"+tShape.join(",")+","+tStride.join(",")+",this.offset)}")
  
  //view.pick():
  code.push("proto.pick=function "+className+"_pick("+args+"){var a=[],b=[],c=this.offset")
  for(var i=0; i<dimension; ++i) {
    code.push("if(typeof i"+i+"==='number'&&i"+i+">=0){c=(c+this.stride["+i+"]*i"+i+")|0}else{a.push(this.shape["+i+"]);b.push(this.stride["+i+"])}")
  }
  code.push("var ctor=CTOR_LIST[a.length+1];return ctor(this.data,a,b,c)}")
    
  //Add return statement
  code.push("return function construct_"+className+"(data,shape,stride,offset){return new "+className+"(data,"+
    indices.map(function(i) {
      return "shape["+i+"]"
    }).join(",")+","+
    indices.map(function(i) {
      return "stride["+i+"]"
    }).join(",")+",offset)}")

  //Compile procedure
  var procedure = new Function("CTOR_LIST", "ORDER", code.join("\n"))
  return procedure(CACHED_CONSTRUCTORS[dtype], order)
}

function arrayDType(data) {
  if(hasBuffer) {
    if(Buffer.isBuffer(data)) {
      return "buffer"
    }
  }
  if(hasTypedArrays) {
    switch(Object.prototype.toString.call(data)) {
      case "[object Float64Array]":
        return "float64"
      case "[object Float32Array]":
        return "float32"
      case "[object Int8Array]":
        return "int8"
      case "[object Int16Array]":
        return "int16"
      case "[object Int32Array]":
        return "int32"
      case "[object Uint8Array]":
        return "uint8"
      case "[object Uint16Array]":
        return "uint16"
      case "[object Uint32Array]":
        return "uint32"
      case "[object Uint8ClampedArray]":
        return "uint8_clamped"
    }
  }
  if(Array.isArray(data)) {
    return "array"
  }
  return "generic"
}

var CACHED_CONSTRUCTORS = {
  "float32":[],
  "float64":[],
  "int8":[],
  "int16":[],
  "int32":[],
  "uint8":[],
  "uint16":[],
  "uint32":[],
  "array":[],
  "uint8_clamped":[],
  "buffer":[],
  "generic":[]
}

;(function() {
  for(var id in CACHED_CONSTRUCTORS) {
    CACHED_CONSTRUCTORS[id].push(compileConstructor(id, -1))
  }
});

function wrappedNDArrayCtor(data, shape, stride, offset) {
  if(data === undefined) {
    var ctor = CACHED_CONSTRUCTORS.array[0]
    return ctor([])
  } else if(typeof data === "number") {
    data = [data]
  }
  if(shape === undefined) {
    shape = [ data.length ]
  }
  var d = shape.length
  if(stride === undefined) {
    stride = new Array(d)
    for(var i=d-1, sz=1; i>=0; --i) {
      stride[i] = sz
      sz *= shape[i]
    }
  }
  if(offset === undefined) {
    offset = 0
    for(var i=0; i<d; ++i) {
      if(stride[i] < 0) {
        offset -= (shape[i]-1)*stride[i]
      }
    }
  }
  var dtype = arrayDType(data)
  var ctor_list = CACHED_CONSTRUCTORS[dtype]
  while(ctor_list.length <= d+1) {
    ctor_list.push(compileConstructor(dtype, ctor_list.length-1))
  }
  var ctor = ctor_list[d+1]
  return ctor(data, shape, stride, offset)
}

module.exports = wrappedNDArrayCtor
}).call(this,require("buffer").Buffer)
},{"buffer":"/projects/blackice/node_modules/browserify/node_modules/buffer/index.js","iota-array":"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/gl-buffer/node_modules/ndarray/node_modules/iota-array/iota.js"}],"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/gl-buffer/node_modules/ndarray/node_modules/iota-array/iota.js":[function(require,module,exports){
module.exports=require("/projects/blackice/node_modules/gl-texture2d/node_modules/ndarray/node_modules/iota-array/iota.js")
},{"/projects/blackice/node_modules/gl-texture2d/node_modules/ndarray/node_modules/iota-array/iota.js":"/projects/blackice/node_modules/gl-texture2d/node_modules/ndarray/node_modules/iota-array/iota.js"}],"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/gl-buffer/node_modules/typedarray-pool/pool.js":[function(require,module,exports){
module.exports=require("/projects/blackice/node_modules/gl-texture2d/node_modules/typedarray-pool/pool.js")
},{"/projects/blackice/node_modules/gl-texture2d/node_modules/typedarray-pool/pool.js":"/projects/blackice/node_modules/gl-texture2d/node_modules/typedarray-pool/pool.js"}],"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/gl-buffer/node_modules/webglew/node_modules/weak-map/weak-map.js":[function(require,module,exports){
// Copyright (C) 2011 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Install a leaky WeakMap emulation on platforms that
 * don't provide a built-in one.
 *
 * <p>Assumes that an ES5 platform where, if {@code WeakMap} is
 * already present, then it conforms to the anticipated ES6
 * specification. To run this file on an ES5 or almost ES5
 * implementation where the {@code WeakMap} specification does not
 * quite conform, run <code>repairES5.js</code> first.
 *
 * <p>Even though WeakMapModule is not global, the linter thinks it
 * is, which is why it is in the overrides list below.
 *
 * <p>NOTE: Before using this WeakMap emulation in a non-SES
 * environment, see the note below about hiddenRecord.
 *
 * @author Mark S. Miller
 * @requires crypto, ArrayBuffer, Uint8Array, navigator, console
 * @overrides WeakMap, ses, Proxy
 * @overrides WeakMapModule
 */

/**
 * This {@code WeakMap} emulation is observably equivalent to the
 * ES-Harmony WeakMap, but with leakier garbage collection properties.
 *
 * <p>As with true WeakMaps, in this emulation, a key does not
 * retain maps indexed by that key and (crucially) a map does not
 * retain the keys it indexes. A map by itself also does not retain
 * the values associated with that map.
 *
 * <p>However, the values associated with a key in some map are
 * retained so long as that key is retained and those associations are
 * not overridden. For example, when used to support membranes, all
 * values exported from a given membrane will live for the lifetime
 * they would have had in the absence of an interposed membrane. Even
 * when the membrane is revoked, all objects that would have been
 * reachable in the absence of revocation will still be reachable, as
 * far as the GC can tell, even though they will no longer be relevant
 * to ongoing computation.
 *
 * <p>The API implemented here is approximately the API as implemented
 * in FF6.0a1 and agreed to by MarkM, Andreas Gal, and Dave Herman,
 * rather than the offially approved proposal page. TODO(erights):
 * upgrade the ecmascript WeakMap proposal page to explain this API
 * change and present to EcmaScript committee for their approval.
 *
 * <p>The first difference between the emulation here and that in
 * FF6.0a1 is the presence of non enumerable {@code get___, has___,
 * set___, and delete___} methods on WeakMap instances to represent
 * what would be the hidden internal properties of a primitive
 * implementation. Whereas the FF6.0a1 WeakMap.prototype methods
 * require their {@code this} to be a genuine WeakMap instance (i.e.,
 * an object of {@code [[Class]]} "WeakMap}), since there is nothing
 * unforgeable about the pseudo-internal method names used here,
 * nothing prevents these emulated prototype methods from being
 * applied to non-WeakMaps with pseudo-internal methods of the same
 * names.
 *
 * <p>Another difference is that our emulated {@code
 * WeakMap.prototype} is not itself a WeakMap. A problem with the
 * current FF6.0a1 API is that WeakMap.prototype is itself a WeakMap
 * providing ambient mutability and an ambient communications
 * channel. Thus, if a WeakMap is already present and has this
 * problem, repairES5.js wraps it in a safe wrappper in order to
 * prevent access to this channel. (See
 * PATCH_MUTABLE_FROZEN_WEAKMAP_PROTO in repairES5.js).
 */

/**
 * If this is a full <a href=
 * "http://code.google.com/p/es-lab/wiki/SecureableES5"
 * >secureable ES5</a> platform and the ES-Harmony {@code WeakMap} is
 * absent, install an approximate emulation.
 *
 * <p>If WeakMap is present but cannot store some objects, use our approximate
 * emulation as a wrapper.
 *
 * <p>If this is almost a secureable ES5 platform, then WeakMap.js
 * should be run after repairES5.js.
 *
 * <p>See {@code WeakMap} for documentation of the garbage collection
 * properties of this WeakMap emulation.
 */
(function WeakMapModule() {
  "use strict";

  if (typeof ses !== 'undefined' && ses.ok && !ses.ok()) {
    // already too broken, so give up
    return;
  }

  /**
   * In some cases (current Firefox), we must make a choice betweeen a
   * WeakMap which is capable of using all varieties of host objects as
   * keys and one which is capable of safely using proxies as keys. See
   * comments below about HostWeakMap and DoubleWeakMap for details.
   *
   * This function (which is a global, not exposed to guests) marks a
   * WeakMap as permitted to do what is necessary to index all host
   * objects, at the cost of making it unsafe for proxies.
   *
   * Do not apply this function to anything which is not a genuine
   * fresh WeakMap.
   */
  function weakMapPermitHostObjects(map) {
    // identity of function used as a secret -- good enough and cheap
    if (map.permitHostObjects___) {
      map.permitHostObjects___(weakMapPermitHostObjects);
    }
  }
  if (typeof ses !== 'undefined') {
    ses.weakMapPermitHostObjects = weakMapPermitHostObjects;
  }

  // IE 11 has no Proxy but has a broken WeakMap such that we need to patch
  // it using DoubleWeakMap; this flag tells DoubleWeakMap so.
  var doubleWeakMapCheckSilentFailure = false;

  // Check if there is already a good-enough WeakMap implementation, and if so
  // exit without replacing it.
  if (typeof WeakMap === 'function') {
    var HostWeakMap = WeakMap;
    // There is a WeakMap -- is it good enough?
    if (typeof navigator !== 'undefined' &&
        /Firefox/.test(navigator.userAgent)) {
      // We're now *assuming not*, because as of this writing (2013-05-06)
      // Firefox's WeakMaps have a miscellany of objects they won't accept, and
      // we don't want to make an exhaustive list, and testing for just one
      // will be a problem if that one is fixed alone (as they did for Event).

      // If there is a platform that we *can* reliably test on, here's how to
      // do it:
      //  var problematic = ... ;
      //  var testHostMap = new HostWeakMap();
      //  try {
      //    testHostMap.set(problematic, 1);  // Firefox 20 will throw here
      //    if (testHostMap.get(problematic) === 1) {
      //      return;
      //    }
      //  } catch (e) {}

    } else {
      // IE 11 bug: WeakMaps silently fail to store frozen objects.
      var testMap = new HostWeakMap();
      var testObject = Object.freeze({});
      testMap.set(testObject, 1);
      if (testMap.get(testObject) !== 1) {
        doubleWeakMapCheckSilentFailure = true;
        // Fall through to installing our WeakMap.
      } else {
        module.exports = WeakMap;
        return;
      }
    }
  }

  var hop = Object.prototype.hasOwnProperty;
  var gopn = Object.getOwnPropertyNames;
  var defProp = Object.defineProperty;
  var isExtensible = Object.isExtensible;

  /**
   * Security depends on HIDDEN_NAME being both <i>unguessable</i> and
   * <i>undiscoverable</i> by untrusted code.
   *
   * <p>Given the known weaknesses of Math.random() on existing
   * browsers, it does not generate unguessability we can be confident
   * of.
   *
   * <p>It is the monkey patching logic in this file that is intended
   * to ensure undiscoverability. The basic idea is that there are
   * three fundamental means of discovering properties of an object:
   * The for/in loop, Object.keys(), and Object.getOwnPropertyNames(),
   * as well as some proposed ES6 extensions that appear on our
   * whitelist. The first two only discover enumerable properties, and
   * we only use HIDDEN_NAME to name a non-enumerable property, so the
   * only remaining threat should be getOwnPropertyNames and some
   * proposed ES6 extensions that appear on our whitelist. We monkey
   * patch them to remove HIDDEN_NAME from the list of properties they
   * returns.
   *
   * <p>TODO(erights): On a platform with built-in Proxies, proxies
   * could be used to trap and thereby discover the HIDDEN_NAME, so we
   * need to monkey patch Proxy.create, Proxy.createFunction, etc, in
   * order to wrap the provided handler with the real handler which
   * filters out all traps using HIDDEN_NAME.
   *
   * <p>TODO(erights): Revisit Mike Stay's suggestion that we use an
   * encapsulated function at a not-necessarily-secret name, which
   * uses the Stiegler shared-state rights amplification pattern to
   * reveal the associated value only to the WeakMap in which this key
   * is associated with that value. Since only the key retains the
   * function, the function can also remember the key without causing
   * leakage of the key, so this doesn't violate our general gc
   * goals. In addition, because the name need not be a guarded
   * secret, we could efficiently handle cross-frame frozen keys.
   */
  var HIDDEN_NAME_PREFIX = 'weakmap:';
  var HIDDEN_NAME = HIDDEN_NAME_PREFIX + 'ident:' + Math.random() + '___';

  if (typeof crypto !== 'undefined' &&
      typeof crypto.getRandomValues === 'function' &&
      typeof ArrayBuffer === 'function' &&
      typeof Uint8Array === 'function') {
    var ab = new ArrayBuffer(25);
    var u8s = new Uint8Array(ab);
    crypto.getRandomValues(u8s);
    HIDDEN_NAME = HIDDEN_NAME_PREFIX + 'rand:' +
      Array.prototype.map.call(u8s, function(u8) {
        return (u8 % 36).toString(36);
      }).join('') + '___';
  }

  function isNotHiddenName(name) {
    return !(
        name.substr(0, HIDDEN_NAME_PREFIX.length) == HIDDEN_NAME_PREFIX &&
        name.substr(name.length - 3) === '___');
  }

  /**
   * Monkey patch getOwnPropertyNames to avoid revealing the
   * HIDDEN_NAME.
   *
   * <p>The ES5.1 spec requires each name to appear only once, but as
   * of this writing, this requirement is controversial for ES6, so we
   * made this code robust against this case. If the resulting extra
   * search turns out to be expensive, we can probably relax this once
   * ES6 is adequately supported on all major browsers, iff no browser
   * versions we support at that time have relaxed this constraint
   * without providing built-in ES6 WeakMaps.
   */
  defProp(Object, 'getOwnPropertyNames', {
    value: function fakeGetOwnPropertyNames(obj) {
      return gopn(obj).filter(isNotHiddenName);
    }
  });

  /**
   * getPropertyNames is not in ES5 but it is proposed for ES6 and
   * does appear in our whitelist, so we need to clean it too.
   */
  if ('getPropertyNames' in Object) {
    var originalGetPropertyNames = Object.getPropertyNames;
    defProp(Object, 'getPropertyNames', {
      value: function fakeGetPropertyNames(obj) {
        return originalGetPropertyNames(obj).filter(isNotHiddenName);
      }
    });
  }

  /**
   * <p>To treat objects as identity-keys with reasonable efficiency
   * on ES5 by itself (i.e., without any object-keyed collections), we
   * need to add a hidden property to such key objects when we
   * can. This raises several issues:
   * <ul>
   * <li>Arranging to add this property to objects before we lose the
   *     chance, and
   * <li>Hiding the existence of this new property from most
   *     JavaScript code.
   * <li>Preventing <i>certification theft</i>, where one object is
   *     created falsely claiming to be the key of an association
   *     actually keyed by another object.
   * <li>Preventing <i>value theft</i>, where untrusted code with
   *     access to a key object but not a weak map nevertheless
   *     obtains access to the value associated with that key in that
   *     weak map.
   * </ul>
   * We do so by
   * <ul>
   * <li>Making the name of the hidden property unguessable, so "[]"
   *     indexing, which we cannot intercept, cannot be used to access
   *     a property without knowing the name.
   * <li>Making the hidden property non-enumerable, so we need not
   *     worry about for-in loops or {@code Object.keys},
   * <li>monkey patching those reflective methods that would
   *     prevent extensions, to add this hidden property first,
   * <li>monkey patching those methods that would reveal this
   *     hidden property.
   * </ul>
   * Unfortunately, because of same-origin iframes, we cannot reliably
   * add this hidden property before an object becomes
   * non-extensible. Instead, if we encounter a non-extensible object
   * without a hidden record that we can detect (whether or not it has
   * a hidden record stored under a name secret to us), then we just
   * use the key object itself to represent its identity in a brute
   * force leaky map stored in the weak map, losing all the advantages
   * of weakness for these.
   */
  function getHiddenRecord(key) {
    if (key !== Object(key)) {
      throw new TypeError('Not an object: ' + key);
    }
    var hiddenRecord = key[HIDDEN_NAME];
    if (hiddenRecord && hiddenRecord.key === key) { return hiddenRecord; }
    if (!isExtensible(key)) {
      // Weak map must brute force, as explained in doc-comment above.
      return void 0;
    }

    // The hiddenRecord and the key point directly at each other, via
    // the "key" and HIDDEN_NAME properties respectively. The key
    // field is for quickly verifying that this hidden record is an
    // own property, not a hidden record from up the prototype chain.
    //
    // NOTE: Because this WeakMap emulation is meant only for systems like
    // SES where Object.prototype is frozen without any numeric
    // properties, it is ok to use an object literal for the hiddenRecord.
    // This has two advantages:
    // * It is much faster in a performance critical place
    // * It avoids relying on Object.create(null), which had been
    //   problematic on Chrome 28.0.1480.0. See
    //   https://code.google.com/p/google-caja/issues/detail?id=1687
    hiddenRecord = { key: key };

    // When using this WeakMap emulation on platforms where
    // Object.prototype might not be frozen and Object.create(null) is
    // reliable, use the following two commented out lines instead.
    // hiddenRecord = Object.create(null);
    // hiddenRecord.key = key;

    // Please contact us if you need this to work on platforms where
    // Object.prototype might not be frozen and
    // Object.create(null) might not be reliable.

    try {
      defProp(key, HIDDEN_NAME, {
        value: hiddenRecord,
        writable: false,
        enumerable: false,
        configurable: false
      });
      return hiddenRecord;
    } catch (error) {
      // Under some circumstances, isExtensible seems to misreport whether
      // the HIDDEN_NAME can be defined.
      // The circumstances have not been isolated, but at least affect
      // Node.js v0.10.26 on TravisCI / Linux, but not the same version of
      // Node.js on OS X.
      return void 0;
    }
  }

  /**
   * Monkey patch operations that would make their argument
   * non-extensible.
   *
   * <p>The monkey patched versions throw a TypeError if their
   * argument is not an object, so it should only be done to functions
   * that should throw a TypeError anyway if their argument is not an
   * object.
   */
  (function(){
    var oldFreeze = Object.freeze;
    defProp(Object, 'freeze', {
      value: function identifyingFreeze(obj) {
        getHiddenRecord(obj);
        return oldFreeze(obj);
      }
    });
    var oldSeal = Object.seal;
    defProp(Object, 'seal', {
      value: function identifyingSeal(obj) {
        getHiddenRecord(obj);
        return oldSeal(obj);
      }
    });
    var oldPreventExtensions = Object.preventExtensions;
    defProp(Object, 'preventExtensions', {
      value: function identifyingPreventExtensions(obj) {
        getHiddenRecord(obj);
        return oldPreventExtensions(obj);
      }
    });
  })();

  function constFunc(func) {
    func.prototype = null;
    return Object.freeze(func);
  }

  var calledAsFunctionWarningDone = false;
  function calledAsFunctionWarning() {
    // Future ES6 WeakMap is currently (2013-09-10) expected to reject WeakMap()
    // but we used to permit it and do it ourselves, so warn only.
    if (!calledAsFunctionWarningDone && typeof console !== 'undefined') {
      calledAsFunctionWarningDone = true;
      console.warn('WeakMap should be invoked as new WeakMap(), not ' +
          'WeakMap(). This will be an error in the future.');
    }
  }

  var nextId = 0;

  var OurWeakMap = function() {
    if (!(this instanceof OurWeakMap)) {  // approximate test for new ...()
      calledAsFunctionWarning();
    }

    // We are currently (12/25/2012) never encountering any prematurely
    // non-extensible keys.
    var keys = []; // brute force for prematurely non-extensible keys.
    var values = []; // brute force for corresponding values.
    var id = nextId++;

    function get___(key, opt_default) {
      var index;
      var hiddenRecord = getHiddenRecord(key);
      if (hiddenRecord) {
        return id in hiddenRecord ? hiddenRecord[id] : opt_default;
      } else {
        index = keys.indexOf(key);
        return index >= 0 ? values[index] : opt_default;
      }
    }

    function has___(key) {
      var hiddenRecord = getHiddenRecord(key);
      if (hiddenRecord) {
        return id in hiddenRecord;
      } else {
        return keys.indexOf(key) >= 0;
      }
    }

    function set___(key, value) {
      var index;
      var hiddenRecord = getHiddenRecord(key);
      if (hiddenRecord) {
        hiddenRecord[id] = value;
      } else {
        index = keys.indexOf(key);
        if (index >= 0) {
          values[index] = value;
        } else {
          // Since some browsers preemptively terminate slow turns but
          // then continue computing with presumably corrupted heap
          // state, we here defensively get keys.length first and then
          // use it to update both the values and keys arrays, keeping
          // them in sync.
          index = keys.length;
          values[index] = value;
          // If we crash here, values will be one longer than keys.
          keys[index] = key;
        }
      }
      return this;
    }

    function delete___(key) {
      var hiddenRecord = getHiddenRecord(key);
      var index, lastIndex;
      if (hiddenRecord) {
        return id in hiddenRecord && delete hiddenRecord[id];
      } else {
        index = keys.indexOf(key);
        if (index < 0) {
          return false;
        }
        // Since some browsers preemptively terminate slow turns but
        // then continue computing with potentially corrupted heap
        // state, we here defensively get keys.length first and then use
        // it to update both the keys and the values array, keeping
        // them in sync. We update the two with an order of assignments,
        // such that any prefix of these assignments will preserve the
        // key/value correspondence, either before or after the delete.
        // Note that this needs to work correctly when index === lastIndex.
        lastIndex = keys.length - 1;
        keys[index] = void 0;
        // If we crash here, there's a void 0 in the keys array, but
        // no operation will cause a "keys.indexOf(void 0)", since
        // getHiddenRecord(void 0) will always throw an error first.
        values[index] = values[lastIndex];
        // If we crash here, values[index] cannot be found here,
        // because keys[index] is void 0.
        keys[index] = keys[lastIndex];
        // If index === lastIndex and we crash here, then keys[index]
        // is still void 0, since the aliasing killed the previous key.
        keys.length = lastIndex;
        // If we crash here, keys will be one shorter than values.
        values.length = lastIndex;
        return true;
      }
    }

    return Object.create(OurWeakMap.prototype, {
      get___:    { value: constFunc(get___) },
      has___:    { value: constFunc(has___) },
      set___:    { value: constFunc(set___) },
      delete___: { value: constFunc(delete___) }
    });
  };

  OurWeakMap.prototype = Object.create(Object.prototype, {
    get: {
      /**
       * Return the value most recently associated with key, or
       * opt_default if none.
       */
      value: function get(key, opt_default) {
        return this.get___(key, opt_default);
      },
      writable: true,
      configurable: true
    },

    has: {
      /**
       * Is there a value associated with key in this WeakMap?
       */
      value: function has(key) {
        return this.has___(key);
      },
      writable: true,
      configurable: true
    },

    set: {
      /**
       * Associate value with key in this WeakMap, overwriting any
       * previous association if present.
       */
      value: function set(key, value) {
        return this.set___(key, value);
      },
      writable: true,
      configurable: true
    },

    'delete': {
      /**
       * Remove any association for key in this WeakMap, returning
       * whether there was one.
       *
       * <p>Note that the boolean return here does not work like the
       * {@code delete} operator. The {@code delete} operator returns
       * whether the deletion succeeds at bringing about a state in
       * which the deleted property is absent. The {@code delete}
       * operator therefore returns true if the property was already
       * absent, whereas this {@code delete} method returns false if
       * the association was already absent.
       */
      value: function remove(key) {
        return this.delete___(key);
      },
      writable: true,
      configurable: true
    }
  });

  if (typeof HostWeakMap === 'function') {
    (function() {
      // If we got here, then the platform has a WeakMap but we are concerned
      // that it may refuse to store some key types. Therefore, make a map
      // implementation which makes use of both as possible.

      // In this mode we are always using double maps, so we are not proxy-safe.
      // This combination does not occur in any known browser, but we had best
      // be safe.
      if (doubleWeakMapCheckSilentFailure && typeof Proxy !== 'undefined') {
        Proxy = undefined;
      }

      function DoubleWeakMap() {
        if (!(this instanceof OurWeakMap)) {  // approximate test for new ...()
          calledAsFunctionWarning();
        }

        // Preferable, truly weak map.
        var hmap = new HostWeakMap();

        // Our hidden-property-based pseudo-weak-map. Lazily initialized in the
        // 'set' implementation; thus we can avoid performing extra lookups if
        // we know all entries actually stored are entered in 'hmap'.
        var omap = undefined;

        // Hidden-property maps are not compatible with proxies because proxies
        // can observe the hidden name and either accidentally expose it or fail
        // to allow the hidden property to be set. Therefore, we do not allow
        // arbitrary WeakMaps to switch to using hidden properties, but only
        // those which need the ability, and unprivileged code is not allowed
        // to set the flag.
        //
        // (Except in doubleWeakMapCheckSilentFailure mode in which case we
        // disable proxies.)
        var enableSwitching = false;

        function dget(key, opt_default) {
          if (omap) {
            return hmap.has(key) ? hmap.get(key)
                : omap.get___(key, opt_default);
          } else {
            return hmap.get(key, opt_default);
          }
        }

        function dhas(key) {
          return hmap.has(key) || (omap ? omap.has___(key) : false);
        }

        var dset;
        if (doubleWeakMapCheckSilentFailure) {
          dset = function(key, value) {
            hmap.set(key, value);
            if (!hmap.has(key)) {
              if (!omap) { omap = new OurWeakMap(); }
              omap.set(key, value);
            }
            return this;
          };
        } else {
          dset = function(key, value) {
            if (enableSwitching) {
              try {
                hmap.set(key, value);
              } catch (e) {
                if (!omap) { omap = new OurWeakMap(); }
                omap.set___(key, value);
              }
            } else {
              hmap.set(key, value);
            }
            return this;
          };
        }

        function ddelete(key) {
          var result = !!hmap['delete'](key);
          if (omap) { return omap.delete___(key) || result; }
          return result;
        }

        return Object.create(OurWeakMap.prototype, {
          get___:    { value: constFunc(dget) },
          has___:    { value: constFunc(dhas) },
          set___:    { value: constFunc(dset) },
          delete___: { value: constFunc(ddelete) },
          permitHostObjects___: { value: constFunc(function(token) {
            if (token === weakMapPermitHostObjects) {
              enableSwitching = true;
            } else {
              throw new Error('bogus call to permitHostObjects___');
            }
          })}
        });
      }
      DoubleWeakMap.prototype = OurWeakMap.prototype;
      module.exports = DoubleWeakMap;

      // define .constructor to hide OurWeakMap ctor
      Object.defineProperty(WeakMap.prototype, 'constructor', {
        value: WeakMap,
        enumerable: false,  // as default .constructor is
        configurable: true,
        writable: true
      });
    })();
  } else {
    // There is no host WeakMap, so we must use the emulation.

    // Emulated WeakMaps are incompatible with native proxies (because proxies
    // can observe the hidden name), so we must disable Proxy usage (in
    // ArrayLike and Domado, currently).
    if (typeof Proxy !== 'undefined') {
      Proxy = undefined;
    }

    module.exports = OurWeakMap;
  }
})();

},{}],"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/gl-buffer/node_modules/webglew/webglew.js":[function(require,module,exports){
'use strict'

var weakMap = typeof WeakMap === 'undefined' ? require('weak-map') : WeakMap

var WebGLEWStruct = new weakMap()

function baseName(ext_name) {
  return ext_name.replace(/^[A-Z]+_/, '')
}

function initWebGLEW(gl) {
  var struct = WebGLEWStruct.get(gl)
  if(struct) {
    return struct
  }
  var extensions = {}
  var supported = gl.getSupportedExtensions()
  for(var i=0; i<supported.length; ++i) {
    var extName = supported[i]

    //Skip MOZ_ extensions
    if(extName.indexOf('MOZ_') === 0) {
      continue
    }
    var ext = gl.getExtension(supported[i])
    if(!ext) {
      continue
    }
    while(true) {
      extensions[extName] = ext
      var base = baseName(extName)
      if(base === extName) {
        break
      }
      extName = base
    }
  }
  WebGLEWStruct.set(gl, extensions)
  return extensions
}
module.exports = initWebGLEW
},{"weak-map":"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/gl-buffer/node_modules/webglew/node_modules/weak-map/weak-map.js"}],"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/gl-white-texture/index.js":[function(require,module,exports){
var create = require('gl-texture2d')
var ndarray = require('ndarray')

module.exports = function(gl) {
    //fill an array with 0xff
    var data = Array.apply(null, new Array(16))
            .map(Number.prototype.valueOf, 0xFF);
    //create a 2D ndarray
    var array = ndarray(new Uint8Array(data), [2, 2, 4])
    return create(gl, array)
}
},{"gl-texture2d":"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-texture2d/texture.js","ndarray":"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/gl-white-texture/node_modules/ndarray/ndarray.js"}],"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/gl-white-texture/node_modules/ndarray/ndarray.js":[function(require,module,exports){
module.exports=require("/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/gl-buffer/node_modules/ndarray/ndarray.js")
},{"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/gl-buffer/node_modules/ndarray/ndarray.js":"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/gl-buffer/node_modules/ndarray/ndarray.js"}],"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/mixes/index.js":[function(require,module,exports){
module.exports=require("/projects/blackice/node_modules/mixes/index.js")
},{"/projects/blackice/node_modules/mixes/index.js":"/projects/blackice/node_modules/mixes/index.js"}],"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/number-util/index.js":[function(require,module,exports){
var int8 = new Int8Array(4);
var int32 = new Int32Array(int8.buffer, 0, 1);
var float32 = new Float32Array(int8.buffer, 0, 1);

/**
 * A singleton for number utilities. 
 * @class NumberUtil
 */
var NumberUtil = function() {

};


/**
 * Returns a float representation of the given int bits. ArrayBuffer
 * is used for the conversion.
 *
 * @method  intBitsToFloat
 * @static
 * @param  {Number} i the int to cast
 * @return {Number}   the float
 */
NumberUtil.intBitsToFloat = function(i) {
	int32[0] = i;
	return float32[0];
};

/**
 * Returns the int bits from the given float. ArrayBuffer is used
 * for the conversion.
 *
 * @method  floatToIntBits
 * @static
 * @param  {Number} f the float to cast
 * @return {Number}   the int bits
 */
NumberUtil.floatToIntBits = function(f) {
	float32[0] = f;
	return int32[0];
};

/**
 * Encodes ABGR int as a float, with slight precision loss.
 *
 * @method  intToFloatColor
 * @static
 * @param {Number} value an ABGR packed integer
 */
NumberUtil.intToFloatColor = function(value) {
	return NumberUtil.intBitsToFloat( value & 0xfeffffff );
};

/**
 * Returns a float encoded ABGR value from the given RGBA
 * bytes (0 - 255). Useful for saving bandwidth in vertex data.
 *
 * @method  colorToFloat
 * @static
 * @param {Number} r the Red byte (0 - 255)
 * @param {Number} g the Green byte (0 - 255)
 * @param {Number} b the Blue byte (0 - 255)
 * @param {Number} a the Alpha byte (0 - 255)
 * @return {Float32}  a Float32 of the RGBA color
 */
NumberUtil.colorToFloat = function(r, g, b, a) {
	var bits = (a << 24 | b << 16 | g << 8 | r);
	return NumberUtil.intToFloatColor(bits);
};

/**
 * Returns true if the number is a power-of-two.
 *
 * @method  isPowerOfTwo
 * @param  {Number}  n the number to test
 * @return {Boolean}   true if power-of-two
 */
NumberUtil.isPowerOfTwo = function(n) {
	return (n & (n - 1)) === 0;
};

/**
 * Returns the next highest power-of-two from the specified number. 
 * 
 * @param  {Number} n the number to test
 * @return {Number}   the next highest power of two
 */
NumberUtil.nextPowerOfTwo = function(n) {
	n--;
	n |= n >> 1;
	n |= n >> 2;
	n |= n >> 4;
	n |= n >> 8;
	n |= n >> 16;
	return n+1;
};

module.exports = NumberUtil;
},{}],"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/premultiplied-rgba/index.js":[function(require,module,exports){
function premultiply(rgba, out) {
	if (!out || typeof out === 'number')
		out = [0,0,0,0]
	out[0] = rgba[0] * rgba[3]
	out[1] = rgba[1] * rgba[3]
	out[2] = rgba[2] * rgba[3]
	out[3] = rgba[3]
	return out
}
module.exports = premultiply
},{}],"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/pack-rgba-float.js":[function(require,module,exports){
var packColor = require('number-util').colorToFloat

module.exports = function colorToFloat(rgba) {
    return packColor(
        ~~(rgba[0] * 255),
        ~~(rgba[1] * 255),
        ~~(rgba[2] * 255),
        ~~(rgba[3] * 255)
    )
}
},{"number-util":"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/gl-sprite-batch/node_modules/number-util/index.js"}],"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/inherits/inherits_browser.js":[function(require,module,exports){
module.exports=require("/projects/blackice/node_modules/inherits/inherits_browser.js")
},{"/projects/blackice/node_modules/inherits/inherits_browser.js":"/projects/blackice/node_modules/inherits/inherits_browser.js"}],"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-sprite-text/node_modules/texcoord/index.js":[function(require,module,exports){
module.exports = function texcoord(position, shape, texShape, out) {
    if (!out)
        out = [0, 0, 1, 1]

    position = position || [0, 0]
    shape = shape || [1, 1]

    texShape = texShape || shape

    var invWidth = 1 / texShape[0]
    var invHeight = 1 / texShape[1]
    var x = position[0],
        y = position[1],
        w = shape[0],
        h = shape[1]

    out[0] = x * invWidth
    out[1] = y * invHeight
    out[2] = (x + w) * invWidth
    out[3] = (y + h) * invHeight
    return out
}
},{}],"/projects/blackice/node_modules/three-sdf-text/node_modules/gl-texture2d/texture.js":[function(require,module,exports){
module.exports=require("/projects/blackice/node_modules/gl-texture2d/texture.js")
},{"/projects/blackice/node_modules/gl-texture2d/texture.js":"/projects/blackice/node_modules/gl-texture2d/texture.js"}],"/projects/blackice/node_modules/three-sdf-text/node_modules/xtend/immutable.js":[function(require,module,exports){
module.exports = extend

function extend() {
    var target = {}

    for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i]

        for (var key in source) {
            if (source.hasOwnProperty(key)) {
                target[key] = source[key]
            }
        }
    }

    return target
}

},{}],"/projects/blackice/node_modules/three-shader-fxaa/index.js":[function(require,module,exports){
var glslify = require("glslify");
var threeify = require("three-glslify");
var source = require("glslify/simple-adapter.js")("\n#define GLSLIFY 1\n\nvarying vec2 vUv;\nvarying vec2 v_rgbNW;\nvarying vec2 v_rgbNE;\nvarying vec2 v_rgbSW;\nvarying vec2 v_rgbSE;\nvarying vec2 v_rgbM;\nuniform vec2 resolution;\nvoid a_x_texcoords(vec2 fragCoord, vec2 resolution, out vec2 v_rgbNW, out vec2 v_rgbNE, out vec2 v_rgbSW, out vec2 v_rgbSE, out vec2 v_rgbM) {\n  vec2 inverseVP = 1.0 / resolution.xy;\n  v_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;\n  v_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;\n  v_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;\n  v_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;\n  v_rgbM = vec2(fragCoord * inverseVP);\n}\nvoid main() {\n  vUv = uv;\n  vec2 fragCoord = uv * resolution;\n  a_x_texcoords(fragCoord, resolution, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}", "\n#define GLSLIFY 1\n\nvarying vec2 vUv;\nvarying vec2 v_rgbNW;\nvarying vec2 v_rgbNE;\nvarying vec2 v_rgbSW;\nvarying vec2 v_rgbSE;\nvarying vec2 v_rgbM;\nuniform vec2 resolution;\nuniform sampler2D tDiffuse;\n#ifndef FXAA_REDUCE_MIN\n\n#define FXAA_REDUCE_MIN   (1.0/ 128.0)\n\n#endif\n\n#ifndef FXAA_REDUCE_MUL\n\n#define FXAA_REDUCE_MUL   (1.0 / 8.0)\n\n#endif\n\n#ifndef FXAA_SPAN_MAX\n\n#define FXAA_SPAN_MAX     8.0\n\n#endif\n\nvec4 a_x_fxaa(sampler2D tex, vec2 fragCoord, vec2 resolution, vec2 v_rgbNW, vec2 v_rgbNE, vec2 v_rgbSW, vec2 v_rgbSE, vec2 v_rgbM) {\n  vec4 color;\n  mediump vec2 inverseVP = vec2(1.0 / resolution.x, 1.0 / resolution.y);\n  vec3 rgbNW = texture2D(tex, v_rgbNW).xyz;\n  vec3 rgbNE = texture2D(tex, v_rgbNE).xyz;\n  vec3 rgbSW = texture2D(tex, v_rgbSW).xyz;\n  vec3 rgbSE = texture2D(tex, v_rgbSE).xyz;\n  vec4 texColor = texture2D(tex, v_rgbM);\n  vec3 rgbM = texColor.xyz;\n  vec3 luma = vec3(0.299, 0.587, 0.114);\n  float lumaNW = dot(rgbNW, luma);\n  float lumaNE = dot(rgbNE, luma);\n  float lumaSW = dot(rgbSW, luma);\n  float lumaSE = dot(rgbSE, luma);\n  float lumaM = dot(rgbM, luma);\n  float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n  float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n  mediump vec2 dir;\n  dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n  dir.y = ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n  float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) * (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\n  float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n  dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX), max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX), dir * rcpDirMin)) * inverseVP;\n  vec3 rgbA = 0.5 * (texture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz + texture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);\n  vec3 rgbB = rgbA * 0.5 + 0.25 * (texture2D(tex, fragCoord * inverseVP + dir * -0.5).xyz + texture2D(tex, fragCoord * inverseVP + dir * 0.5).xyz);\n  float lumaB = dot(rgbB, luma);\n  if((lumaB < lumaMin) || (lumaB > lumaMax))\n    color = vec4(rgbA, texColor.a);\n  else\n    color = vec4(rgbB, texColor.a);\n  return color;\n}\nvoid main() {\n  vec2 fragCoord = vUv * resolution;\n  gl_FragColor = a_x_fxaa(tDiffuse, fragCoord, resolution, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n}", [{"name":"resolution","type":"vec2"},{"name":"resolution","type":"vec2"},{"name":"tDiffuse","type":"sampler2D"}], []);

module.exports = function(THREE) {
    var createShader = threeify(THREE);

    return function() {
        return createShader(source);
    };
};
},{"glslify":"/projects/blackice/node_modules/glslify/browser.js","glslify/simple-adapter.js":"/projects/blackice/node_modules/glslify/simple-adapter.js","three-glslify":"/projects/blackice/node_modules/three-glslify/index.js"}],"/projects/blackice/node_modules/three-simplicial-complex/index.js":[function(require,module,exports){
var inherits = require('inherits')

module.exports = function(THREE) {

    function Complex(mesh) {
        if (!(this instanceof Complex))
            return new Complex(mesh)
        THREE.Geometry.call(this)
        this.dynamic = true

        if (mesh)
            this.update(mesh)
    }

    inherits(Complex, THREE.Geometry)

    //may expose these in next version
    Complex.prototype._updatePositions = function(positions) {
        for (var i=0; i<positions.length; i++) {
            var pos = positions[i]
            if (i > this.vertices.length-1)
                this.vertices.push(new THREE.Vector3().fromArray(pos))
            else 
                this.vertices[i].fromArray(pos)
        }
        this.vertices.length = positions.length
        this.verticesNeedUpdate = true
    }

    Complex.prototype._updateCells = function(cells) {
        for (var i=0; i<cells.length; i++) {
            var face = cells[i]
            if (i > this.faces.length-1)
                this.faces.push(new THREE.Face3(face[0], face[1], face[2]))
            else {
                var tf = this.faces[i]
                tf.a = face[0]
                tf.b = face[1]
                tf.c = face[2]
            }
        }

        this.faces.length = cells.length
        this.elementsNeedUpdate = true
    }

    Complex.prototype.update = function(mesh) {
        this._updatePositions(mesh.positions)
        this._updateCells(mesh.cells)
    }

    return Complex
}
},{"inherits":"/projects/blackice/node_modules/inherits/inherits_browser.js"}],"/projects/blackice/node_modules/triangulate-contours/index.js":[function(require,module,exports){
var Tess2 = require('tess2')
var xtend = require('xtend')

module.exports = function(contours, opt) {
    opt = opt||{}
    contours = contours.filter(function(c) {
        return c.length>0
    })
    
    if (contours.length === 0) {
        return { 
            positions: [],
            cells: []
        }
    }

    if (typeof opt.vertexSize !== 'number')
        opt.vertexSize = contours[0][0].length

    //flatten for tess2.js
    contours = contours.map(function(c) {
        return c.reduce(function(a, b) {
            return a.concat(b)
        })
    })

    // Tesselate
    var res = Tess2.tesselate(xtend({
        contours: contours,
        windingRule: Tess2.WINDING_ODD,
        elementType: Tess2.POLYGONS,
        polySize: 3,
        vertexSize: 2
    }, opt))

    var positions = []
    for (var i=0; i<res.vertices.length; i+=opt.vertexSize) {
        var pos = res.vertices.slice(i, i+opt.vertexSize)
        positions.push(pos)
    }
    
    var cells = []
    for (i=0; i<res.elements.length; i+=3) {
        var a = res.elements[i],
            b = res.elements[i+1],
            c = res.elements[i+2]
        cells.push([a, b, c])
    }

    //return a simplicial complex
    return {
        positions: positions,
        cells: cells
    }
}
},{"tess2":"/projects/blackice/node_modules/triangulate-contours/node_modules/tess2/index.js","xtend":"/projects/blackice/node_modules/xtend/immutable.js"}],"/projects/blackice/node_modules/triangulate-contours/node_modules/tess2/index.js":[function(require,module,exports){
module.exports = require('./src/tess2');
},{"./src/tess2":"/projects/blackice/node_modules/triangulate-contours/node_modules/tess2/src/tess2.js"}],"/projects/blackice/node_modules/triangulate-contours/node_modules/tess2/src/tess2.js":[function(require,module,exports){
/*
** SGI FREE SOFTWARE LICENSE B (Version 2.0, Sept. 18, 2008) 
** Copyright (C) [dates of first publication] Silicon Graphics, Inc.
** All Rights Reserved.
**
** Permission is hereby granted, free of charge, to any person obtaining a copy
** of this software and associated documentation files (the "Software"), to deal
** in the Software without restriction, including without limitation the rights
** to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
** of the Software, and to permit persons to whom the Software is furnished to do so,
** subject to the following conditions:
** 
** The above copyright notice including the dates of first publication and either this
** permission notice or a reference to http://oss.sgi.com/projects/FreeB/ shall be
** included in all copies or substantial portions of the Software. 
**
** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
** INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
** PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL SILICON GRAPHICS, INC.
** BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
** TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
** OR OTHER DEALINGS IN THE SOFTWARE.
** 
** Except as contained in this notice, the name of Silicon Graphics, Inc. shall not
** be used in advertising or otherwise to promote the sale, use or other dealings in
** this Software without prior written authorization from Silicon Graphics, Inc.
*/
/*
** Author: Mikko Mononen, Aug 2013.
** The code is based on GLU libtess by Eric Veach, July 1994
*/

	"use strict";

	/* Public API */

	var Tess2 = {};

	module.exports = Tess2;
	
	Tess2.WINDING_ODD = 0;
	Tess2.WINDING_NONZERO = 1;
	Tess2.WINDING_POSITIVE = 2;
	Tess2.WINDING_NEGATIVE = 3;
	Tess2.WINDING_ABS_GEQ_TWO = 4;

	Tess2.POLYGONS = 0;
	Tess2.CONNECTED_POLYGONS = 1;
	Tess2.BOUNDARY_CONTOURS = 2;

	Tess2.tesselate = function(opts) {
		var debug =  opts.debug || false;
		var tess = new Tesselator();
		for (var i = 0; i < opts.contours.length; i++) {
			tess.addContour(opts.vertexSize || 2, opts.contours[i]);
		}
		tess.tesselate(opts.windingRule || Tess2.WINDING_ODD,
					   opts.elementType || Tess2.POLYGONS,
					   opts.polySize || 3,
					   opts.vertexSize || 2,
					   opts.normal || [0,0,1]);
		return {
			vertices: tess.vertices,
			vertexIndices: tess.vertexIndices,
			vertexCount: tess.vertexCount,
			elements: tess.elements,
			elementCount: tess.elementCount,
			mesh: debug ? tess.mesh : undefined
		};
	};

	/* Internal */

	var assert = function(cond) {
		if (!cond) {
			throw "Assertion Failed!";
		}
	}

	/* The mesh structure is similar in spirit, notation, and operations
	* to the "quad-edge" structure (see L. Guibas and J. Stolfi, Primitives
	* for the manipulation of general subdivisions and the computation of
	* Voronoi diagrams, ACM Transactions on Graphics, 4(2):74-123, April 1985).
	* For a simplified description, see the course notes for CS348a,
	* "Mathematical Foundations of Computer Graphics", available at the
	* Stanford bookstore (and taught during the fall quarter).
	* The implementation also borrows a tiny subset of the graph-based approach
	* use in Mantyla's Geometric Work Bench (see M. Mantyla, An Introduction
	* to Sold Modeling, Computer Science Press, Rockville, Maryland, 1988).
	*
	* The fundamental data structure is the "half-edge".  Two half-edges
	* go together to make an edge, but they point in opposite directions.
	* Each half-edge has a pointer to its mate (the "symmetric" half-edge Sym),
	* its origin vertex (Org), the face on its left side (Lface), and the
	* adjacent half-edges in the CCW direction around the origin vertex
	* (Onext) and around the left face (Lnext).  There is also a "next"
	* pointer for the global edge list (see below).
	*
	* The notation used for mesh navigation:
	*  Sym   = the mate of a half-edge (same edge, but opposite direction)
	*  Onext = edge CCW around origin vertex (keep same origin)
	*  Dnext = edge CCW around destination vertex (keep same dest)
	*  Lnext = edge CCW around left face (dest becomes new origin)
	*  Rnext = edge CCW around right face (origin becomes new dest)
	*
	* "prev" means to substitute CW for CCW in the definitions above.
	*
	* The mesh keeps global lists of all vertices, faces, and edges,
	* stored as doubly-linked circular lists with a dummy header node.
	* The mesh stores pointers to these dummy headers (vHead, fHead, eHead).
	*
	* The circular edge list is special; since half-edges always occur
	* in pairs (e and e->Sym), each half-edge stores a pointer in only
	* one direction.  Starting at eHead and following the e->next pointers
	* will visit each *edge* once (ie. e or e->Sym, but not both).
	* e->Sym stores a pointer in the opposite direction, thus it is
	* always true that e->Sym->next->Sym->next == e.
	*
	* Each vertex has a pointer to next and previous vertices in the
	* circular list, and a pointer to a half-edge with this vertex as
	* the origin (NULL if this is the dummy header).  There is also a
	* field "data" for client data.
	*
	* Each face has a pointer to the next and previous faces in the
	* circular list, and a pointer to a half-edge with this face as
	* the left face (NULL if this is the dummy header).  There is also
	* a field "data" for client data.
	*
	* Note that what we call a "face" is really a loop; faces may consist
	* of more than one loop (ie. not simply connected), but there is no
	* record of this in the data structure.  The mesh may consist of
	* several disconnected regions, so it may not be possible to visit
	* the entire mesh by starting at a half-edge and traversing the edge
	* structure.
	*
	* The mesh does NOT support isolated vertices; a vertex is deleted along
	* with its last edge.  Similarly when two faces are merged, one of the
	* faces is deleted (see tessMeshDelete below).  For mesh operations,
	* all face (loop) and vertex pointers must not be NULL.  However, once
	* mesh manipulation is finished, TESSmeshZapFace can be used to delete
	* faces of the mesh, one at a time.  All external faces can be "zapped"
	* before the mesh is returned to the client; then a NULL face indicates
	* a region which is not part of the output polygon.
	*/

	function TESSvertex() {
		this.next = null;	/* next vertex (never NULL) */
		this.prev = null;	/* previous vertex (never NULL) */
		this.anEdge = null;	/* a half-edge with this origin */

		/* Internal data (keep hidden) */
		this.coords = [0,0,0];	/* vertex location in 3D */
		this.s = 0.0;
		this.t = 0.0;			/* projection onto the sweep plane */
		this.pqHandle = 0;		/* to allow deletion from priority queue */
		this.n = 0;				/* to allow identify unique vertices */
		this.idx = 0;			/* to allow map result to original verts */
	} 

	function TESSface() {
		this.next = null;		/* next face (never NULL) */
		this.prev = null;		/* previous face (never NULL) */
		this.anEdge = null;		/* a half edge with this left face */

		/* Internal data (keep hidden) */
		this.trail = null;		/* "stack" for conversion to strips */
		this.n = 0;				/* to allow identiy unique faces */
		this.marked = false;	/* flag for conversion to strips */
		this.inside = false;	/* this face is in the polygon interior */
	};

	function TESShalfEdge(side) {
		this.next = null;		/* doubly-linked list (prev==Sym->next) */
		this.Sym = null;		/* same edge, opposite direction */
		this.Onext = null;		/* next edge CCW around origin */
		this.Lnext = null;		/* next edge CCW around left face */
		this.Org = null;		/* origin vertex (Overtex too long) */
		this.Lface = null;		/* left face */

		/* Internal data (keep hidden) */
		this.activeRegion = null;	/* a region with this upper edge (sweep.c) */
		this.winding = 0;			/* change in winding number when crossing
									   from the right face to the left face */
		this.side = side;
	};

	TESShalfEdge.prototype = {
		get Rface() { return this.Sym.Lface; },
		set Rface(v) { this.Sym.Lface = v; },
		get Dst() { return this.Sym.Org; },
		set Dst(v) { this.Sym.Org = v; },
		get Oprev() { return this.Sym.Lnext; },
		set Oprev(v) { this.Sym.Lnext = v; },
		get Lprev() { return this.Onext.Sym; },
		set Lprev(v) { this.Onext.Sym = v; },
		get Dprev() { return this.Lnext.Sym; },
		set Dprev(v) { this.Lnext.Sym = v; },
		get Rprev() { return this.Sym.Onext; },
		set Rprev(v) { this.Sym.Onext = v; },
		get Dnext() { return /*this.Rprev*/this.Sym.Onext.Sym; },  /* 3 pointers */
		set Dnext(v) { /*this.Rprev*/this.Sym.Onext.Sym = v; },  /* 3 pointers */
		get Rnext() { return /*this.Oprev*/this.Sym.Lnext.Sym; },  /* 3 pointers */
		set Rnext(v) { /*this.Oprev*/this.Sym.Lnext.Sym = v; },  /* 3 pointers */
	};



	function TESSmesh() {
		var v = new TESSvertex();
		var f = new TESSface();
		var e = new TESShalfEdge(0);
		var eSym = new TESShalfEdge(1);

		v.next = v.prev = v;
		v.anEdge = null;

		f.next = f.prev = f;
		f.anEdge = null;
		f.trail = null;
		f.marked = false;
		f.inside = false;

		e.next = e;
		e.Sym = eSym;
		e.Onext = null;
		e.Lnext = null;
		e.Org = null;
		e.Lface = null;
		e.winding = 0;
		e.activeRegion = null;

		eSym.next = eSym;
		eSym.Sym = e;
		eSym.Onext = null;
		eSym.Lnext = null;
		eSym.Org = null;
		eSym.Lface = null;
		eSym.winding = 0;
		eSym.activeRegion = null;

		this.vHead = v;		/* dummy header for vertex list */
		this.fHead = f;		/* dummy header for face list */
		this.eHead = e;		/* dummy header for edge list */
		this.eHeadSym = eSym;	/* and its symmetric counterpart */
	};

	/* The mesh operations below have three motivations: completeness,
	* convenience, and efficiency.  The basic mesh operations are MakeEdge,
	* Splice, and Delete.  All the other edge operations can be implemented
	* in terms of these.  The other operations are provided for convenience
	* and/or efficiency.
	*
	* When a face is split or a vertex is added, they are inserted into the
	* global list *before* the existing vertex or face (ie. e->Org or e->Lface).
	* This makes it easier to process all vertices or faces in the global lists
	* without worrying about processing the same data twice.  As a convenience,
	* when a face is split, the "inside" flag is copied from the old face.
	* Other internal data (v->data, v->activeRegion, f->data, f->marked,
	* f->trail, e->winding) is set to zero.
	*
	* ********************** Basic Edge Operations **************************
	*
	* tessMeshMakeEdge( mesh ) creates one edge, two vertices, and a loop.
	* The loop (face) consists of the two new half-edges.
	*
	* tessMeshSplice( eOrg, eDst ) is the basic operation for changing the
	* mesh connectivity and topology.  It changes the mesh so that
	*  eOrg->Onext <- OLD( eDst->Onext )
	*  eDst->Onext <- OLD( eOrg->Onext )
	* where OLD(...) means the value before the meshSplice operation.
	*
	* This can have two effects on the vertex structure:
	*  - if eOrg->Org != eDst->Org, the two vertices are merged together
	*  - if eOrg->Org == eDst->Org, the origin is split into two vertices
	* In both cases, eDst->Org is changed and eOrg->Org is untouched.
	*
	* Similarly (and independently) for the face structure,
	*  - if eOrg->Lface == eDst->Lface, one loop is split into two
	*  - if eOrg->Lface != eDst->Lface, two distinct loops are joined into one
	* In both cases, eDst->Lface is changed and eOrg->Lface is unaffected.
	*
	* tessMeshDelete( eDel ) removes the edge eDel.  There are several cases:
	* if (eDel->Lface != eDel->Rface), we join two loops into one; the loop
	* eDel->Lface is deleted.  Otherwise, we are splitting one loop into two;
	* the newly created loop will contain eDel->Dst.  If the deletion of eDel
	* would create isolated vertices, those are deleted as well.
	*
	* ********************** Other Edge Operations **************************
	*
	* tessMeshAddEdgeVertex( eOrg ) creates a new edge eNew such that
	* eNew == eOrg->Lnext, and eNew->Dst is a newly created vertex.
	* eOrg and eNew will have the same left face.
	*
	* tessMeshSplitEdge( eOrg ) splits eOrg into two edges eOrg and eNew,
	* such that eNew == eOrg->Lnext.  The new vertex is eOrg->Dst == eNew->Org.
	* eOrg and eNew will have the same left face.
	*
	* tessMeshConnect( eOrg, eDst ) creates a new edge from eOrg->Dst
	* to eDst->Org, and returns the corresponding half-edge eNew.
	* If eOrg->Lface == eDst->Lface, this splits one loop into two,
	* and the newly created loop is eNew->Lface.  Otherwise, two disjoint
	* loops are merged into one, and the loop eDst->Lface is destroyed.
	*
	* ************************ Other Operations *****************************
	*
	* tessMeshNewMesh() creates a new mesh with no edges, no vertices,
	* and no loops (what we usually call a "face").
	*
	* tessMeshUnion( mesh1, mesh2 ) forms the union of all structures in
	* both meshes, and returns the new mesh (the old meshes are destroyed).
	*
	* tessMeshDeleteMesh( mesh ) will free all storage for any valid mesh.
	*
	* tessMeshZapFace( fZap ) destroys a face and removes it from the
	* global face list.  All edges of fZap will have a NULL pointer as their
	* left face.  Any edges which also have a NULL pointer as their right face
	* are deleted entirely (along with any isolated vertices this produces).
	* An entire mesh can be deleted by zapping its faces, one at a time,
	* in any order.  Zapped faces cannot be used in further mesh operations!
	*
	* tessMeshCheckMesh( mesh ) checks a mesh for self-consistency.
	*/

	TESSmesh.prototype = {

		/* MakeEdge creates a new pair of half-edges which form their own loop.
		* No vertex or face structures are allocated, but these must be assigned
		* before the current edge operation is completed.
		*/
		//static TESShalfEdge *MakeEdge( TESSmesh* mesh, TESShalfEdge *eNext )
		makeEdge_: function(eNext) {
			var e = new TESShalfEdge(0);
			var eSym = new TESShalfEdge(1);

			/* Make sure eNext points to the first edge of the edge pair */
			if( eNext.Sym.side < eNext.side ) { eNext = eNext.Sym; }

			/* Insert in circular doubly-linked list before eNext.
			* Note that the prev pointer is stored in Sym->next.
			*/
			var ePrev = eNext.Sym.next;
			eSym.next = ePrev;
			ePrev.Sym.next = e;
			e.next = eNext;
			eNext.Sym.next = eSym;

			e.Sym = eSym;
			e.Onext = e;
			e.Lnext = eSym;
			e.Org = null;
			e.Lface = null;
			e.winding = 0;
			e.activeRegion = null;

			eSym.Sym = e;
			eSym.Onext = eSym;
			eSym.Lnext = e;
			eSym.Org = null;
			eSym.Lface = null;
			eSym.winding = 0;
			eSym.activeRegion = null;

			return e;
		},

		/* Splice( a, b ) is best described by the Guibas/Stolfi paper or the
		* CS348a notes (see mesh.h).  Basically it modifies the mesh so that
		* a->Onext and b->Onext are exchanged.  This can have various effects
		* depending on whether a and b belong to different face or vertex rings.
		* For more explanation see tessMeshSplice() below.
		*/
		// static void Splice( TESShalfEdge *a, TESShalfEdge *b )
		splice_: function(a, b) {
			var aOnext = a.Onext;
			var bOnext = b.Onext;
			aOnext.Sym.Lnext = b;
			bOnext.Sym.Lnext = a;
			a.Onext = bOnext;
			b.Onext = aOnext;
		},

		/* MakeVertex( newVertex, eOrig, vNext ) attaches a new vertex and makes it the
		* origin of all edges in the vertex loop to which eOrig belongs. "vNext" gives
		* a place to insert the new vertex in the global vertex list.  We insert
		* the new vertex *before* vNext so that algorithms which walk the vertex
		* list will not see the newly created vertices.
		*/
		//static void MakeVertex( TESSvertex *newVertex, TESShalfEdge *eOrig, TESSvertex *vNext )
		makeVertex_: function(newVertex, eOrig, vNext) {
			var vNew = newVertex;
			assert(vNew !== null);

			/* insert in circular doubly-linked list before vNext */
			var vPrev = vNext.prev;
			vNew.prev = vPrev;
			vPrev.next = vNew;
			vNew.next = vNext;
			vNext.prev = vNew;

			vNew.anEdge = eOrig;
			/* leave coords, s, t undefined */

			/* fix other edges on this vertex loop */
			var e = eOrig;
			do {
				e.Org = vNew;
				e = e.Onext;
			} while(e !== eOrig);
		},

		/* MakeFace( newFace, eOrig, fNext ) attaches a new face and makes it the left
		* face of all edges in the face loop to which eOrig belongs.  "fNext" gives
		* a place to insert the new face in the global face list.  We insert
		* the new face *before* fNext so that algorithms which walk the face
		* list will not see the newly created faces.
		*/
		// static void MakeFace( TESSface *newFace, TESShalfEdge *eOrig, TESSface *fNext )
		makeFace_: function(newFace, eOrig, fNext) {
			var fNew = newFace;
			assert(fNew !== null); 

			/* insert in circular doubly-linked list before fNext */
			var fPrev = fNext.prev;
			fNew.prev = fPrev;
			fPrev.next = fNew;
			fNew.next = fNext;
			fNext.prev = fNew;

			fNew.anEdge = eOrig;
			fNew.trail = null;
			fNew.marked = false;

			/* The new face is marked "inside" if the old one was.  This is a
			* convenience for the common case where a face has been split in two.
			*/
			fNew.inside = fNext.inside;

			/* fix other edges on this face loop */
			var e = eOrig;
			do {
				e.Lface = fNew;
				e = e.Lnext;
			} while(e !== eOrig);
		},

		/* KillEdge( eDel ) destroys an edge (the half-edges eDel and eDel->Sym),
		* and removes from the global edge list.
		*/
		//static void KillEdge( TESSmesh *mesh, TESShalfEdge *eDel )
		killEdge_: function(eDel) {
			/* Half-edges are allocated in pairs, see EdgePair above */
			if( eDel.Sym.side < eDel.side ) { eDel = eDel.Sym; }

			/* delete from circular doubly-linked list */
			var eNext = eDel.next;
			var ePrev = eDel.Sym.next;
			eNext.Sym.next = ePrev;
			ePrev.Sym.next = eNext;
		},


		/* KillVertex( vDel ) destroys a vertex and removes it from the global
		* vertex list.  It updates the vertex loop to point to a given new vertex.
		*/
		//static void KillVertex( TESSmesh *mesh, TESSvertex *vDel, TESSvertex *newOrg )
		killVertex_: function(vDel, newOrg) {
			var eStart = vDel.anEdge;
			/* change the origin of all affected edges */
			var e = eStart;
			do {
				e.Org = newOrg;
				e = e.Onext;
			} while(e !== eStart);

			/* delete from circular doubly-linked list */
			var vPrev = vDel.prev;
			var vNext = vDel.next;
			vNext.prev = vPrev;
			vPrev.next = vNext;
		},

		/* KillFace( fDel ) destroys a face and removes it from the global face
		* list.  It updates the face loop to point to a given new face.
		*/
		//static void KillFace( TESSmesh *mesh, TESSface *fDel, TESSface *newLface )
		killFace_: function(fDel, newLface) {
			var eStart = fDel.anEdge;

			/* change the left face of all affected edges */
			var e = eStart;
			do {
				e.Lface = newLface;
				e = e.Lnext;
			} while(e !== eStart);

			/* delete from circular doubly-linked list */
			var fPrev = fDel.prev;
			var fNext = fDel.next;
			fNext.prev = fPrev;
			fPrev.next = fNext;
		},

		/****************** Basic Edge Operations **********************/

		/* tessMeshMakeEdge creates one edge, two vertices, and a loop (face).
		* The loop consists of the two new half-edges.
		*/
		//TESShalfEdge *tessMeshMakeEdge( TESSmesh *mesh )
		makeEdge: function() {
			var newVertex1 = new TESSvertex();
			var newVertex2 = new TESSvertex();
			var newFace = new TESSface();
			var e = this.makeEdge_( this.eHead);
			this.makeVertex_( newVertex1, e, this.vHead );
			this.makeVertex_( newVertex2, e.Sym, this.vHead );
			this.makeFace_( newFace, e, this.fHead );
			return e;
		},

		/* tessMeshSplice( eOrg, eDst ) is the basic operation for changing the
		* mesh connectivity and topology.  It changes the mesh so that
		*	eOrg->Onext <- OLD( eDst->Onext )
		*	eDst->Onext <- OLD( eOrg->Onext )
		* where OLD(...) means the value before the meshSplice operation.
		*
		* This can have two effects on the vertex structure:
		*  - if eOrg->Org != eDst->Org, the two vertices are merged together
		*  - if eOrg->Org == eDst->Org, the origin is split into two vertices
		* In both cases, eDst->Org is changed and eOrg->Org is untouched.
		*
		* Similarly (and independently) for the face structure,
		*  - if eOrg->Lface == eDst->Lface, one loop is split into two
		*  - if eOrg->Lface != eDst->Lface, two distinct loops are joined into one
		* In both cases, eDst->Lface is changed and eOrg->Lface is unaffected.
		*
		* Some special cases:
		* If eDst == eOrg, the operation has no effect.
		* If eDst == eOrg->Lnext, the new face will have a single edge.
		* If eDst == eOrg->Lprev, the old face will have a single edge.
		* If eDst == eOrg->Onext, the new vertex will have a single edge.
		* If eDst == eOrg->Oprev, the old vertex will have a single edge.
		*/
		//int tessMeshSplice( TESSmesh* mesh, TESShalfEdge *eOrg, TESShalfEdge *eDst )
		splice: function(eOrg, eDst) {
			var joiningLoops = false;
			var joiningVertices = false;

			if( eOrg === eDst ) return;

			if( eDst.Org !== eOrg.Org ) {
				/* We are merging two disjoint vertices -- destroy eDst->Org */
				joiningVertices = true;
				this.killVertex_( eDst.Org, eOrg.Org );
			}
			if( eDst.Lface !== eOrg.Lface ) {
				/* We are connecting two disjoint loops -- destroy eDst->Lface */
				joiningLoops = true;
				this.killFace_( eDst.Lface, eOrg.Lface );
			}

			/* Change the edge structure */
			this.splice_( eDst, eOrg );

			if( ! joiningVertices ) {
				var newVertex = new TESSvertex();

				/* We split one vertex into two -- the new vertex is eDst->Org.
				* Make sure the old vertex points to a valid half-edge.
				*/
				this.makeVertex_( newVertex, eDst, eOrg.Org );
				eOrg.Org.anEdge = eOrg;
			}
			if( ! joiningLoops ) {
				var newFace = new TESSface();  

				/* We split one loop into two -- the new loop is eDst->Lface.
				* Make sure the old face points to a valid half-edge.
				*/
				this.makeFace_( newFace, eDst, eOrg.Lface );
				eOrg.Lface.anEdge = eOrg;
			}
		},

		/* tessMeshDelete( eDel ) removes the edge eDel.  There are several cases:
		* if (eDel->Lface != eDel->Rface), we join two loops into one; the loop
		* eDel->Lface is deleted.  Otherwise, we are splitting one loop into two;
		* the newly created loop will contain eDel->Dst.  If the deletion of eDel
		* would create isolated vertices, those are deleted as well.
		*
		* This function could be implemented as two calls to tessMeshSplice
		* plus a few calls to memFree, but this would allocate and delete
		* unnecessary vertices and faces.
		*/
		//int tessMeshDelete( TESSmesh *mesh, TESShalfEdge *eDel )
		delete: function(eDel) {
			var eDelSym = eDel.Sym;
			var joiningLoops = false;

			/* First step: disconnect the origin vertex eDel->Org.  We make all
			* changes to get a consistent mesh in this "intermediate" state.
			*/
			if( eDel.Lface !== eDel.Rface ) {
				/* We are joining two loops into one -- remove the left face */
				joiningLoops = true;
				this.killFace_( eDel.Lface, eDel.Rface );
			}

			if( eDel.Onext === eDel ) {
				this.killVertex_( eDel.Org, null );
			} else {
				/* Make sure that eDel->Org and eDel->Rface point to valid half-edges */
				eDel.Rface.anEdge = eDel.Oprev;
				eDel.Org.anEdge = eDel.Onext;

				this.splice_( eDel, eDel.Oprev );
				if( ! joiningLoops ) {
					var newFace = new TESSface();

					/* We are splitting one loop into two -- create a new loop for eDel. */
					this.makeFace_( newFace, eDel, eDel.Lface );
				}
			}

			/* Claim: the mesh is now in a consistent state, except that eDel->Org
			* may have been deleted.  Now we disconnect eDel->Dst.
			*/
			if( eDelSym.Onext === eDelSym ) {
				this.killVertex_( eDelSym.Org, null );
				this.killFace_( eDelSym.Lface, null );
			} else {
				/* Make sure that eDel->Dst and eDel->Lface point to valid half-edges */
				eDel.Lface.anEdge = eDelSym.Oprev;
				eDelSym.Org.anEdge = eDelSym.Onext;
				this.splice_( eDelSym, eDelSym.Oprev );
			}

			/* Any isolated vertices or faces have already been freed. */
			this.killEdge_( eDel );
		},

		/******************** Other Edge Operations **********************/

		/* All these routines can be implemented with the basic edge
		* operations above.  They are provided for convenience and efficiency.
		*/


		/* tessMeshAddEdgeVertex( eOrg ) creates a new edge eNew such that
		* eNew == eOrg->Lnext, and eNew->Dst is a newly created vertex.
		* eOrg and eNew will have the same left face.
		*/
		// TESShalfEdge *tessMeshAddEdgeVertex( TESSmesh *mesh, TESShalfEdge *eOrg );
		addEdgeVertex: function(eOrg) {
			var eNew = this.makeEdge_( eOrg );
			var eNewSym = eNew.Sym;

			/* Connect the new edge appropriately */
			this.splice_( eNew, eOrg.Lnext );

			/* Set the vertex and face information */
			eNew.Org = eOrg.Dst;

			var newVertex = new TESSvertex();
			this.makeVertex_( newVertex, eNewSym, eNew.Org );

			eNew.Lface = eNewSym.Lface = eOrg.Lface;

			return eNew;
		},


		/* tessMeshSplitEdge( eOrg ) splits eOrg into two edges eOrg and eNew,
		* such that eNew == eOrg->Lnext.  The new vertex is eOrg->Dst == eNew->Org.
		* eOrg and eNew will have the same left face.
		*/
		// TESShalfEdge *tessMeshSplitEdge( TESSmesh *mesh, TESShalfEdge *eOrg );
		splitEdge: function(eOrg, eDst) {
			var tempHalfEdge = this.addEdgeVertex( eOrg );
			var eNew = tempHalfEdge.Sym;

			/* Disconnect eOrg from eOrg->Dst and connect it to eNew->Org */
			this.splice_( eOrg.Sym, eOrg.Sym.Oprev );
			this.splice_( eOrg.Sym, eNew );

			/* Set the vertex and face information */
			eOrg.Dst = eNew.Org;
			eNew.Dst.anEdge = eNew.Sym;	/* may have pointed to eOrg->Sym */
			eNew.Rface = eOrg.Rface;
			eNew.winding = eOrg.winding;	/* copy old winding information */
			eNew.Sym.winding = eOrg.Sym.winding;

			return eNew;
		},


		/* tessMeshConnect( eOrg, eDst ) creates a new edge from eOrg->Dst
		* to eDst->Org, and returns the corresponding half-edge eNew.
		* If eOrg->Lface == eDst->Lface, this splits one loop into two,
		* and the newly created loop is eNew->Lface.  Otherwise, two disjoint
		* loops are merged into one, and the loop eDst->Lface is destroyed.
		*
		* If (eOrg == eDst), the new face will have only two edges.
		* If (eOrg->Lnext == eDst), the old face is reduced to a single edge.
		* If (eOrg->Lnext->Lnext == eDst), the old face is reduced to two edges.
		*/

		// TESShalfEdge *tessMeshConnect( TESSmesh *mesh, TESShalfEdge *eOrg, TESShalfEdge *eDst );
		connect: function(eOrg, eDst) {
			var joiningLoops = false;  
			var eNew = this.makeEdge_( eOrg );
			var eNewSym = eNew.Sym;

			if( eDst.Lface !== eOrg.Lface ) {
				/* We are connecting two disjoint loops -- destroy eDst->Lface */
				joiningLoops = true;
				this.killFace_( eDst.Lface, eOrg.Lface );
			}

			/* Connect the new edge appropriately */
			this.splice_( eNew, eOrg.Lnext );
			this.splice_( eNewSym, eDst );

			/* Set the vertex and face information */
			eNew.Org = eOrg.Dst;
			eNewSym.Org = eDst.Org;
			eNew.Lface = eNewSym.Lface = eOrg.Lface;

			/* Make sure the old face points to a valid half-edge */
			eOrg.Lface.anEdge = eNewSym;

			if( ! joiningLoops ) {
				var newFace = new TESSface();
				/* We split one loop into two -- the new loop is eNew->Lface */
				this.makeFace_( newFace, eNew, eOrg.Lface );
			}
			return eNew;
		},

		/* tessMeshZapFace( fZap ) destroys a face and removes it from the
		* global face list.  All edges of fZap will have a NULL pointer as their
		* left face.  Any edges which also have a NULL pointer as their right face
		* are deleted entirely (along with any isolated vertices this produces).
		* An entire mesh can be deleted by zapping its faces, one at a time,
		* in any order.  Zapped faces cannot be used in further mesh operations!
		*/
		zapFace: function( fZap )
		{
			var eStart = fZap.anEdge;
			var e, eNext, eSym;
			var fPrev, fNext;

			/* walk around face, deleting edges whose right face is also NULL */
			eNext = eStart.Lnext;
			do {
				e = eNext;
				eNext = e.Lnext;

				e.Lface = null;
				if( e.Rface === null ) {
					/* delete the edge -- see TESSmeshDelete above */

					if( e.Onext === e ) {
						this.killVertex_( e.Org, null );
					} else {
						/* Make sure that e->Org points to a valid half-edge */
						e.Org.anEdge = e.Onext;
						this.splice_( e, e.Oprev );
					}
					eSym = e.Sym;
					if( eSym.Onext === eSym ) {
						this.killVertex_( eSym.Org, null );
					} else {
						/* Make sure that eSym->Org points to a valid half-edge */
						eSym.Org.anEdge = eSym.Onext;
						this.splice_( eSym, eSym.Oprev );
					}
					this.killEdge_( e );
				}
			} while( e != eStart );

			/* delete from circular doubly-linked list */
			fPrev = fZap.prev;
			fNext = fZap.next;
			fNext.prev = fPrev;
			fPrev.next = fNext;
		},

		countFaceVerts_: function(f) {
			var eCur = f.anEdge;
			var n = 0;
			do
			{
				n++;
				eCur = eCur.Lnext;
			}
			while (eCur !== f.anEdge);
			return n;
		},

		//int tessMeshMergeConvexFaces( TESSmesh *mesh, int maxVertsPerFace )
		mergeConvexFaces: function(maxVertsPerFace) {
			var f;
			var eCur, eNext, eSym;
			var vStart;
			var curNv, symNv;

			for( f = this.fHead.next; f !== this.fHead; f = f.next )
			{
				// Skip faces which are outside the result.
				if( !f.inside )
					continue;

				eCur = f.anEdge;
				vStart = eCur.Org;
					
				while (true)
				{
					eNext = eCur.Lnext;
					eSym = eCur.Sym;

					// Try to merge if the neighbour face is valid.
					if( eSym && eSym.Lface && eSym.Lface.inside )
					{
						// Try to merge the neighbour faces if the resulting polygons
						// does not exceed maximum number of vertices.
						curNv = this.countFaceVerts_( f );
						symNv = this.countFaceVerts_( eSym.Lface );
						if( (curNv+symNv-2) <= maxVertsPerFace )
						{
							// Merge if the resulting poly is convex.
							if( Geom.vertCCW( eCur.Lprev.Org, eCur.Org, eSym.Lnext.Lnext.Org ) &&
								Geom.vertCCW( eSym.Lprev.Org, eSym.Org, eCur.Lnext.Lnext.Org ) )
							{
								eNext = eSym.Lnext;
								this.delete( eSym );
								eCur = null;
								eSym = null;
							}
						}
					}
					
					if( eCur && eCur.Lnext.Org === vStart )
						break;
						
					// Continue to next edge.
					eCur = eNext;
				}
			}
			
			return true;
		},

		/* tessMeshCheckMesh( mesh ) checks a mesh for self-consistency.
		*/
		check: function() {
			var fHead = this.fHead;
			var vHead = this.vHead;
			var eHead = this.eHead;
			var f, fPrev, v, vPrev, e, ePrev;

			fPrev = fHead;
			for( fPrev = fHead ; (f = fPrev.next) !== fHead; fPrev = f) {
				assert( f.prev === fPrev );
				e = f.anEdge;
				do {
					assert( e.Sym !== e );
					assert( e.Sym.Sym === e );
					assert( e.Lnext.Onext.Sym === e );
					assert( e.Onext.Sym.Lnext === e );
					assert( e.Lface === f );
					e = e.Lnext;
				} while( e !== f.anEdge );
			}
			assert( f.prev === fPrev && f.anEdge === null );

			vPrev = vHead;
			for( vPrev = vHead ; (v = vPrev.next) !== vHead; vPrev = v) {
				assert( v.prev === vPrev );
				e = v.anEdge;
				do {
					assert( e.Sym !== e );
					assert( e.Sym.Sym === e );
					assert( e.Lnext.Onext.Sym === e );
					assert( e.Onext.Sym.Lnext === e );
					assert( e.Org === v );
					e = e.Onext;
				} while( e !== v.anEdge );
			}
			assert( v.prev === vPrev && v.anEdge === null );

			ePrev = eHead;
			for( ePrev = eHead ; (e = ePrev.next) !== eHead; ePrev = e) {
				assert( e.Sym.next === ePrev.Sym );
				assert( e.Sym !== e );
				assert( e.Sym.Sym === e );
				assert( e.Org !== null );
				assert( e.Dst !== null );
				assert( e.Lnext.Onext.Sym === e );
				assert( e.Onext.Sym.Lnext === e );
			}
			assert( e.Sym.next === ePrev.Sym
				&& e.Sym === this.eHeadSym
				&& e.Sym.Sym === e
				&& e.Org === null && e.Dst === null
				&& e.Lface === null && e.Rface === null );
		}

	};

	var Geom = {};

	Geom.vertEq = function(u,v) {
		return (u.s === v.s && u.t === v.t);
	};

	/* Returns TRUE if u is lexicographically <= v. */
	Geom.vertLeq = function(u,v) {
		return ((u.s < v.s) || (u.s === v.s && u.t <= v.t));
	};

	/* Versions of VertLeq, EdgeSign, EdgeEval with s and t transposed. */
	Geom.transLeq = function(u,v) {
		return ((u.t < v.t) || (u.t === v.t && u.s <= v.s));
	};

	Geom.edgeGoesLeft = function(e) {
		return Geom.vertLeq( e.Dst, e.Org );
	};

	Geom.edgeGoesRight = function(e) {
		return Geom.vertLeq( e.Org, e.Dst );
	};

	Geom.vertL1dist = function(u,v) {
		return (Math.abs(u.s - v.s) + Math.abs(u.t - v.t));
	};

	//TESSreal tesedgeEval( TESSvertex *u, TESSvertex *v, TESSvertex *w )
	Geom.edgeEval = function( u, v, w ) {
		/* Given three vertices u,v,w such that VertLeq(u,v) && VertLeq(v,w),
		* evaluates the t-coord of the edge uw at the s-coord of the vertex v.
		* Returns v->t - (uw)(v->s), ie. the signed distance from uw to v.
		* If uw is vertical (and thus passes thru v), the result is zero.
		*
		* The calculation is extremely accurate and stable, even when v
		* is very close to u or w.  In particular if we set v->t = 0 and
		* let r be the negated result (this evaluates (uw)(v->s)), then
		* r is guaranteed to satisfy MIN(u->t,w->t) <= r <= MAX(u->t,w->t).
		*/
		assert( Geom.vertLeq( u, v ) && Geom.vertLeq( v, w ));

		var gapL = v.s - u.s;
		var gapR = w.s - v.s;

		if( gapL + gapR > 0.0 ) {
			if( gapL < gapR ) {
				return (v.t - u.t) + (u.t - w.t) * (gapL / (gapL + gapR));
			} else {
				return (v.t - w.t) + (w.t - u.t) * (gapR / (gapL + gapR));
			}
		}
		/* vertical line */
		return 0.0;
	};

	//TESSreal tesedgeSign( TESSvertex *u, TESSvertex *v, TESSvertex *w )
	Geom.edgeSign = function( u, v, w ) {
		/* Returns a number whose sign matches EdgeEval(u,v,w) but which
		* is cheaper to evaluate.  Returns > 0, == 0 , or < 0
		* as v is above, on, or below the edge uw.
		*/
		assert( Geom.vertLeq( u, v ) && Geom.vertLeq( v, w ));

		var gapL = v.s - u.s;
		var gapR = w.s - v.s;

		if( gapL + gapR > 0.0 ) {
			return (v.t - w.t) * gapL + (v.t - u.t) * gapR;
		}
		/* vertical line */
		return 0.0;
	};


	/***********************************************************************
	* Define versions of EdgeSign, EdgeEval with s and t transposed.
	*/

	//TESSreal testransEval( TESSvertex *u, TESSvertex *v, TESSvertex *w )
	Geom.transEval = function( u, v, w ) {
		/* Given three vertices u,v,w such that TransLeq(u,v) && TransLeq(v,w),
		* evaluates the t-coord of the edge uw at the s-coord of the vertex v.
		* Returns v->s - (uw)(v->t), ie. the signed distance from uw to v.
		* If uw is vertical (and thus passes thru v), the result is zero.
		*
		* The calculation is extremely accurate and stable, even when v
		* is very close to u or w.  In particular if we set v->s = 0 and
		* let r be the negated result (this evaluates (uw)(v->t)), then
		* r is guaranteed to satisfy MIN(u->s,w->s) <= r <= MAX(u->s,w->s).
		*/
		assert( Geom.transLeq( u, v ) && Geom.transLeq( v, w ));

		var gapL = v.t - u.t;
		var gapR = w.t - v.t;

		if( gapL + gapR > 0.0 ) {
			if( gapL < gapR ) {
				return (v.s - u.s) + (u.s - w.s) * (gapL / (gapL + gapR));
			} else {
				return (v.s - w.s) + (w.s - u.s) * (gapR / (gapL + gapR));
			}
		}
		/* vertical line */
		return 0.0;
	};

	//TESSreal testransSign( TESSvertex *u, TESSvertex *v, TESSvertex *w )
	Geom.transSign = function( u, v, w ) {
		/* Returns a number whose sign matches TransEval(u,v,w) but which
		* is cheaper to evaluate.  Returns > 0, == 0 , or < 0
		* as v is above, on, or below the edge uw.
		*/
		assert( Geom.transLeq( u, v ) && Geom.transLeq( v, w ));

		var gapL = v.t - u.t;
		var gapR = w.t - v.t;

		if( gapL + gapR > 0.0 ) {
			return (v.s - w.s) * gapL + (v.s - u.s) * gapR;
		}
		/* vertical line */
		return 0.0;
	};


	//int tesvertCCW( TESSvertex *u, TESSvertex *v, TESSvertex *w )
	Geom.vertCCW = function( u, v, w ) {
		/* For almost-degenerate situations, the results are not reliable.
		* Unless the floating-point arithmetic can be performed without
		* rounding errors, *any* implementation will give incorrect results
		* on some degenerate inputs, so the client must have some way to
		* handle this situation.
		*/
		return (u.s*(v.t - w.t) + v.s*(w.t - u.t) + w.s*(u.t - v.t)) >= 0.0;
	};

	/* Given parameters a,x,b,y returns the value (b*x+a*y)/(a+b),
	* or (x+y)/2 if a==b==0.  It requires that a,b >= 0, and enforces
	* this in the rare case that one argument is slightly negative.
	* The implementation is extremely stable numerically.
	* In particular it guarantees that the result r satisfies
	* MIN(x,y) <= r <= MAX(x,y), and the results are very accurate
	* even when a and b differ greatly in magnitude.
	*/
	Geom.interpolate = function(a,x,b,y) {
		return (a = (a < 0) ? 0 : a, b = (b < 0) ? 0 : b, ((a <= b) ? ((b == 0) ? ((x+y) / 2) : (x + (y-x) * (a/(a+b)))) : (y + (x-y) * (b/(a+b)))));
	};

	/*
	#ifndef FOR_TRITE_TEST_PROGRAM
	#define Interpolate(a,x,b,y)	RealInterpolate(a,x,b,y)
	#else

	// Claim: the ONLY property the sweep algorithm relies on is that
	// MIN(x,y) <= r <= MAX(x,y).  This is a nasty way to test that.
	#include <stdlib.h>
	extern int RandomInterpolate;

	double Interpolate( double a, double x, double b, double y)
	{
		printf("*********************%d\n",RandomInterpolate);
		if( RandomInterpolate ) {
			a = 1.2 * drand48() - 0.1;
			a = (a < 0) ? 0 : ((a > 1) ? 1 : a);
			b = 1.0 - a;
		}
		return RealInterpolate(a,x,b,y);
	}
	#endif*/

	Geom.intersect = function( o1, d1, o2, d2, v ) {
		/* Given edges (o1,d1) and (o2,d2), compute their point of intersection.
		* The computed point is guaranteed to lie in the intersection of the
		* bounding rectangles defined by each edge.
		*/
		var z1, z2;
		var t;

		/* This is certainly not the most efficient way to find the intersection
		* of two line segments, but it is very numerically stable.
		*
		* Strategy: find the two middle vertices in the VertLeq ordering,
		* and interpolate the intersection s-value from these.  Then repeat
		* using the TransLeq ordering to find the intersection t-value.
		*/

		if( ! Geom.vertLeq( o1, d1 )) { t = o1; o1 = d1; d1 = t; } //swap( o1, d1 ); }
		if( ! Geom.vertLeq( o2, d2 )) { t = o2; o2 = d2; d2 = t; } //swap( o2, d2 ); }
		if( ! Geom.vertLeq( o1, o2 )) { t = o1; o1 = o2; o2 = t; t = d1; d1 = d2; d2 = t; }//swap( o1, o2 ); swap( d1, d2 ); }

		if( ! Geom.vertLeq( o2, d1 )) {
			/* Technically, no intersection -- do our best */
			v.s = (o2.s + d1.s) / 2;
		} else if( Geom.vertLeq( d1, d2 )) {
			/* Interpolate between o2 and d1 */
			z1 = Geom.edgeEval( o1, o2, d1 );
			z2 = Geom.edgeEval( o2, d1, d2 );
			if( z1+z2 < 0 ) { z1 = -z1; z2 = -z2; }
			v.s = Geom.interpolate( z1, o2.s, z2, d1.s );
		} else {
			/* Interpolate between o2 and d2 */
			z1 = Geom.edgeSign( o1, o2, d1 );
			z2 = -Geom.edgeSign( o1, d2, d1 );
			if( z1+z2 < 0 ) { z1 = -z1; z2 = -z2; }
			v.s = Geom.interpolate( z1, o2.s, z2, d2.s );
		}

		/* Now repeat the process for t */

		if( ! Geom.transLeq( o1, d1 )) { t = o1; o1 = d1; d1 = t; } //swap( o1, d1 ); }
		if( ! Geom.transLeq( o2, d2 )) { t = o2; o2 = d2; d2 = t; } //swap( o2, d2 ); }
		if( ! Geom.transLeq( o1, o2 )) { t = o1; o1 = o2; o2 = t; t = d1; d1 = d2; d2 = t; } //swap( o1, o2 ); swap( d1, d2 ); }

		if( ! Geom.transLeq( o2, d1 )) {
			/* Technically, no intersection -- do our best */
			v.t = (o2.t + d1.t) / 2;
		} else if( Geom.transLeq( d1, d2 )) {
			/* Interpolate between o2 and d1 */
			z1 = Geom.transEval( o1, o2, d1 );
			z2 = Geom.transEval( o2, d1, d2 );
			if( z1+z2 < 0 ) { z1 = -z1; z2 = -z2; }
			v.t = Geom.interpolate( z1, o2.t, z2, d1.t );
		} else {
			/* Interpolate between o2 and d2 */
			z1 = Geom.transSign( o1, o2, d1 );
			z2 = -Geom.transSign( o1, d2, d1 );
			if( z1+z2 < 0 ) { z1 = -z1; z2 = -z2; }
			v.t = Geom.interpolate( z1, o2.t, z2, d2.t );
		}
	};



	function DictNode() {
		this.key = null;
		this.next = null;
		this.prev = null;
	};

	function Dict(frame, leq) {
		this.head = new DictNode();
		this.head.next = this.head;
		this.head.prev = this.head;
		this.frame = frame;
		this.leq = leq;
	};

	Dict.prototype = {
		min: function() {
			return this.head.next;
		},

		max: function() {
			return this.head.prev;
		},

		insert: function(k) {
			return this.insertBefore(this.head, k);
		},

		search: function(key) {
			/* Search returns the node with the smallest key greater than or equal
			* to the given key.  If there is no such key, returns a node whose
			* key is NULL.  Similarly, Succ(Max(d)) has a NULL key, etc.
			*/
			var node = this.head;
			do {
				node = node.next;
			} while( node.key !== null && ! this.leq(this.frame, key, node.key));

			return node;
		},

		insertBefore: function(node, key) {
			do {
				node = node.prev;
			} while( node.key !== null && ! this.leq(this.frame, node.key, key));

			var newNode = new DictNode();
			newNode.key = key;
			newNode.next = node.next;
			node.next.prev = newNode;
			newNode.prev = node;
			node.next = newNode;

			return newNode;
		},

		delete: function(node) {
			node.next.prev = node.prev;
			node.prev.next = node.next;
		}
	};


	function PQnode() {
		this.handle = null;
	}

	function PQhandleElem() {
		this.key = null;
		this.node = null;
	}

	function PriorityQ(size, leq) {
		this.size = 0;
		this.max = size;

		this.nodes = [];
		this.nodes.length = size+1;
		for (var i = 0; i < this.nodes.length; i++)
			this.nodes[i] = new PQnode();

		this.handles = [];
		this.handles.length = size+1;
		for (var i = 0; i < this.handles.length; i++)
			this.handles[i] = new PQhandleElem();

		this.initialized = false;
		this.freeList = 0;
		this.leq = leq;

		this.nodes[1].handle = 1;	/* so that Minimum() returns NULL */
		this.handles[1].key = null;
	};

	PriorityQ.prototype = {

		floatDown_: function( curr )
		{
			var n = this.nodes;
			var h = this.handles;
			var hCurr, hChild;
			var child;

			hCurr = n[curr].handle;
			for( ;; ) {
				child = curr << 1;
				if( child < this.size && this.leq( h[n[child+1].handle].key, h[n[child].handle].key )) {
					++child;
				}

				assert(child <= this.max);

				hChild = n[child].handle;
				if( child > this.size || this.leq( h[hCurr].key, h[hChild].key )) {
					n[curr].handle = hCurr;
					h[hCurr].node = curr;
					break;
				}
				n[curr].handle = hChild;
				h[hChild].node = curr;
				curr = child;
			}
		},

		floatUp_: function( curr )
		{
			var n = this.nodes;
			var h = this.handles;
			var hCurr, hParent;
			var parent;

			hCurr = n[curr].handle;
			for( ;; ) {
				parent = curr >> 1;
				hParent = n[parent].handle;
				if( parent == 0 || this.leq( h[hParent].key, h[hCurr].key )) {
					n[curr].handle = hCurr;
					h[hCurr].node = curr;
					break;
				}
				n[curr].handle = hParent;
				h[hParent].node = curr;
				curr = parent;
			}
		},

		init: function() {
			/* This method of building a heap is O(n), rather than O(n lg n). */
			for( var i = this.size; i >= 1; --i ) {
				this.floatDown_( i );
			}
			this.initialized = true;
		},

		min: function() {
			return this.handles[this.nodes[1].handle].key;
		},

		isEmpty: function() {
			this.size === 0;
		},

		/* really pqHeapInsert */
		/* returns INV_HANDLE iff out of memory */
		//PQhandle pqHeapInsert( TESSalloc* alloc, PriorityQHeap *pq, PQkey keyNew )
		insert: function(keyNew)
		{
			var curr;
			var free;

			curr = ++this.size;
			if( (curr*2) > this.max ) {
				this.max *= 2;
				var s;
				s = this.nodes.length;
				this.nodes.length = this.max+1;
				for (var i = s; i < this.nodes.length; i++)
					this.nodes[i] = new PQnode();

				s = this.handles.length;
				this.handles.length = this.max+1;
				for (var i = s; i < this.handles.length; i++)
					this.handles[i] = new PQhandleElem();
			}

			if( this.freeList === 0 ) {
				free = curr;
			} else {
				free = this.freeList;
				this.freeList = this.handles[free].node;
			}

			this.nodes[curr].handle = free;
			this.handles[free].node = curr;
			this.handles[free].key = keyNew;

			if( this.initialized ) {
				this.floatUp_( curr );
			}
			return free;
		},

		//PQkey pqHeapExtractMin( PriorityQHeap *pq )
		extractMin: function() {
			var n = this.nodes;
			var h = this.handles;
			var hMin = n[1].handle;
			var min = h[hMin].key;

			if( this.size > 0 ) {
				n[1].handle = n[this.size].handle;
				h[n[1].handle].node = 1;

				h[hMin].key = null;
				h[hMin].node = this.freeList;
				this.freeList = hMin;

				--this.size;
				if( this.size > 0 ) {
					this.floatDown_( 1 );
				}
			}
			return min;
		},

		delete: function( hCurr ) {
			var n = this.nodes;
			var h = this.handles;
			var curr;

			assert( hCurr >= 1 && hCurr <= this.max && h[hCurr].key !== null );

			curr = h[hCurr].node;
			n[curr].handle = n[this.size].handle;
			h[n[curr].handle].node = curr;

			--this.size;
			if( curr <= this.size ) {
				if( curr <= 1 || this.leq( h[n[curr>>1].handle].key, h[n[curr].handle].key )) {
					this.floatDown_( curr );
				} else {
					this.floatUp_( curr );
				}
			}
			h[hCurr].key = null;
			h[hCurr].node = this.freeList;
			this.freeList = hCurr;
		}
	};


	/* For each pair of adjacent edges crossing the sweep line, there is
	* an ActiveRegion to represent the region between them.  The active
	* regions are kept in sorted order in a dynamic dictionary.  As the
	* sweep line crosses each vertex, we update the affected regions.
	*/

	function ActiveRegion() {
		this.eUp = null;		/* upper edge, directed right to left */
		this.nodeUp = null;	/* dictionary node corresponding to eUp */
		this.windingNumber = 0;	/* used to determine which regions are
								* inside the polygon */
		this.inside = false;		/* is this region inside the polygon? */
		this.sentinel = false;	/* marks fake edges at t = +/-infinity */
		this.dirty = false;		/* marks regions where the upper or lower
						* edge has changed, but we haven't checked
						* whether they intersect yet */
		this.fixUpperEdge = false;	/* marks temporary edges introduced when
							* we process a "right vertex" (one without
							* any edges leaving to the right) */
	};

	var Sweep = {};

	Sweep.regionBelow = function(r) {
		return r.nodeUp.prev.key;
	}

	Sweep.regionAbove = function(r) {
		return r.nodeUp.next.key;
	}

	Sweep.debugEvent = function( tess ) {
		// empty
	}


	/*
	* Invariants for the Edge Dictionary.
	* - each pair of adjacent edges e2=Succ(e1) satisfies EdgeLeq(e1,e2)
	*   at any valid location of the sweep event
	* - if EdgeLeq(e2,e1) as well (at any valid sweep event), then e1 and e2
	*   share a common endpoint
	* - for each e, e->Dst has been processed, but not e->Org
	* - each edge e satisfies VertLeq(e->Dst,event) && VertLeq(event,e->Org)
	*   where "event" is the current sweep line event.
	* - no edge e has zero length
	*
	* Invariants for the Mesh (the processed portion).
	* - the portion of the mesh left of the sweep line is a planar graph,
	*   ie. there is *some* way to embed it in the plane
	* - no processed edge has zero length
	* - no two processed vertices have identical coordinates
	* - each "inside" region is monotone, ie. can be broken into two chains
	*   of monotonically increasing vertices according to VertLeq(v1,v2)
	*   - a non-invariant: these chains may intersect (very slightly)
	*
	* Invariants for the Sweep.
	* - if none of the edges incident to the event vertex have an activeRegion
	*   (ie. none of these edges are in the edge dictionary), then the vertex
	*   has only right-going edges.
	* - if an edge is marked "fixUpperEdge" (it is a temporary edge introduced
	*   by ConnectRightVertex), then it is the only right-going edge from
	*   its associated vertex.  (This says that these edges exist only
	*   when it is necessary.)
	*/

	/* When we merge two edges into one, we need to compute the combined
	* winding of the new edge.
	*/
	Sweep.addWinding = function(eDst,eSrc) {
		eDst.winding += eSrc.winding;
		eDst.Sym.winding += eSrc.Sym.winding;
	}


	//static int EdgeLeq( TESStesselator *tess, ActiveRegion *reg1, ActiveRegion *reg2 )
	Sweep.edgeLeq = function( tess, reg1, reg2 ) {
		/*
		* Both edges must be directed from right to left (this is the canonical
		* direction for the upper edge of each region).
		*
		* The strategy is to evaluate a "t" value for each edge at the
		* current sweep line position, given by tess->event.  The calculations
		* are designed to be very stable, but of course they are not perfect.
		*
		* Special case: if both edge destinations are at the sweep event,
		* we sort the edges by slope (they would otherwise compare equally).
		*/
		var ev = tess.event;
		var t1, t2;

		var e1 = reg1.eUp;
		var e2 = reg2.eUp;

		if( e1.Dst === ev ) {
			if( e2.Dst === ev ) {
				/* Two edges right of the sweep line which meet at the sweep event.
				* Sort them by slope.
				*/
				if( Geom.vertLeq( e1.Org, e2.Org )) {
					return Geom.edgeSign( e2.Dst, e1.Org, e2.Org ) <= 0;
				}
				return Geom.edgeSign( e1.Dst, e2.Org, e1.Org ) >= 0;
			}
			return Geom.edgeSign( e2.Dst, ev, e2.Org ) <= 0;
		}
		if( e2.Dst === ev ) {
			return Geom.edgeSign( e1.Dst, ev, e1.Org ) >= 0;
		}

		/* General case - compute signed distance *from* e1, e2 to event */
		var t1 = Geom.edgeEval( e1.Dst, ev, e1.Org );
		var t2 = Geom.edgeEval( e2.Dst, ev, e2.Org );
		return (t1 >= t2);
	}


	//static void DeleteRegion( TESStesselator *tess, ActiveRegion *reg )
	Sweep.deleteRegion = function( tess, reg ) {
		if( reg.fixUpperEdge ) {
			/* It was created with zero winding number, so it better be
			* deleted with zero winding number (ie. it better not get merged
			* with a real edge).
			*/
			assert( reg.eUp.winding === 0 );
		}
		reg.eUp.activeRegion = null;
		tess.dict.delete( reg.nodeUp );
	}

	//static int FixUpperEdge( TESStesselator *tess, ActiveRegion *reg, TESShalfEdge *newEdge )
	Sweep.fixUpperEdge = function( tess, reg, newEdge ) {
		/*
		* Replace an upper edge which needs fixing (see ConnectRightVertex).
		*/
		assert( reg.fixUpperEdge );
		tess.mesh.delete( reg.eUp );
		reg.fixUpperEdge = false;
		reg.eUp = newEdge;
		newEdge.activeRegion = reg;
	}

	//static ActiveRegion *TopLeftRegion( TESStesselator *tess, ActiveRegion *reg )
	Sweep.topLeftRegion = function( tess, reg ) {
		var org = reg.eUp.Org;
		var e;

		/* Find the region above the uppermost edge with the same origin */
		do {
			reg = Sweep.regionAbove( reg );
		} while( reg.eUp.Org === org );

		/* If the edge above was a temporary edge introduced by ConnectRightVertex,
		* now is the time to fix it.
		*/
		if( reg.fixUpperEdge ) {
			e = tess.mesh.connect( Sweep.regionBelow(reg).eUp.Sym, reg.eUp.Lnext );
			if (e === null) return null;
			Sweep.fixUpperEdge( tess, reg, e );
			reg = Sweep.regionAbove( reg );
		}
		return reg;
	}

	//static ActiveRegion *TopRightRegion( ActiveRegion *reg )
	Sweep.topRightRegion = function( reg )
	{
		var dst = reg.eUp.Dst;
		var reg = null;
		/* Find the region above the uppermost edge with the same destination */
		do {
			reg = Sweep.regionAbove( reg );
		} while( reg.eUp.Dst === dst );
		return reg;
	}

	//static ActiveRegion *AddRegionBelow( TESStesselator *tess, ActiveRegion *regAbove, TESShalfEdge *eNewUp )
	Sweep.addRegionBelow = function( tess, regAbove, eNewUp ) {
		/*
		* Add a new active region to the sweep line, *somewhere* below "regAbove"
		* (according to where the new edge belongs in the sweep-line dictionary).
		* The upper edge of the new region will be "eNewUp".
		* Winding number and "inside" flag are not updated.
		*/
		var regNew = new ActiveRegion();
		regNew.eUp = eNewUp;
		regNew.nodeUp = tess.dict.insertBefore( regAbove.nodeUp, regNew );
	//	if (regNew->nodeUp == NULL) longjmp(tess->env,1);
		regNew.fixUpperEdge = false;
		regNew.sentinel = false;
		regNew.dirty = false;

		eNewUp.activeRegion = regNew;
		return regNew;
	}

	//static int IsWindingInside( TESStesselator *tess, int n )
	Sweep.isWindingInside = function( tess, n ) {
		switch( tess.windingRule ) {
			case Tess2.WINDING_ODD:
				return (n & 1) != 0;
			case Tess2.WINDING_NONZERO:
				return (n != 0);
			case Tess2.WINDING_POSITIVE:
				return (n > 0);
			case Tess2.WINDING_NEGATIVE:
				return (n < 0);
			case Tess2.WINDING_ABS_GEQ_TWO:
				return (n >= 2) || (n <= -2);
		}
		assert( false );
		return false;
	}

	//static void ComputeWinding( TESStesselator *tess, ActiveRegion *reg )
	Sweep.computeWinding = function( tess, reg ) {
		reg.windingNumber = Sweep.regionAbove(reg).windingNumber + reg.eUp.winding;
		reg.inside = Sweep.isWindingInside( tess, reg.windingNumber );
	}


	//static void FinishRegion( TESStesselator *tess, ActiveRegion *reg )
	Sweep.finishRegion = function( tess, reg ) {
		/*
		* Delete a region from the sweep line.  This happens when the upper
		* and lower chains of a region meet (at a vertex on the sweep line).
		* The "inside" flag is copied to the appropriate mesh face (we could
		* not do this before -- since the structure of the mesh is always
		* changing, this face may not have even existed until now).
		*/
		var e = reg.eUp;
		var f = e.Lface;

		f.inside = reg.inside;
		f.anEdge = e;   /* optimization for tessMeshTessellateMonoRegion() */
		Sweep.deleteRegion( tess, reg );
	}


	//static TESShalfEdge *FinishLeftRegions( TESStesselator *tess, ActiveRegion *regFirst, ActiveRegion *regLast )
	Sweep.finishLeftRegions = function( tess, regFirst, regLast ) {
		/*
		* We are given a vertex with one or more left-going edges.  All affected
		* edges should be in the edge dictionary.  Starting at regFirst->eUp,
		* we walk down deleting all regions where both edges have the same
		* origin vOrg.  At the same time we copy the "inside" flag from the
		* active region to the face, since at this point each face will belong
		* to at most one region (this was not necessarily true until this point
		* in the sweep).  The walk stops at the region above regLast; if regLast
		* is NULL we walk as far as possible.  At the same time we relink the
		* mesh if necessary, so that the ordering of edges around vOrg is the
		* same as in the dictionary.
		*/
		var e, ePrev;
		var reg = null;
		var regPrev = regFirst;
		var ePrev = regFirst.eUp;
		while( regPrev !== regLast ) {
			regPrev.fixUpperEdge = false;	/* placement was OK */
			reg = Sweep.regionBelow( regPrev );
			e = reg.eUp;
			if( e.Org != ePrev.Org ) {
				if( ! reg.fixUpperEdge ) {
					/* Remove the last left-going edge.  Even though there are no further
					* edges in the dictionary with this origin, there may be further
					* such edges in the mesh (if we are adding left edges to a vertex
					* that has already been processed).  Thus it is important to call
					* FinishRegion rather than just DeleteRegion.
					*/
					Sweep.finishRegion( tess, regPrev );
					break;
				}
				/* If the edge below was a temporary edge introduced by
				* ConnectRightVertex, now is the time to fix it.
				*/
				e = tess.mesh.connect( ePrev.Lprev, e.Sym );
	//			if (e == NULL) longjmp(tess->env,1);
				Sweep.fixUpperEdge( tess, reg, e );
			}

			/* Relink edges so that ePrev->Onext == e */
			if( ePrev.Onext !== e ) {
				tess.mesh.splice( e.Oprev, e );
				tess.mesh.splice( ePrev, e );
			}
			Sweep.finishRegion( tess, regPrev );	/* may change reg->eUp */
			ePrev = reg.eUp;
			regPrev = reg;
		}
		return ePrev;
	}


	//static void AddRightEdges( TESStesselator *tess, ActiveRegion *regUp, TESShalfEdge *eFirst, TESShalfEdge *eLast, TESShalfEdge *eTopLeft, int cleanUp )
	Sweep.addRightEdges = function( tess, regUp, eFirst, eLast, eTopLeft, cleanUp ) {
		/*
		* Purpose: insert right-going edges into the edge dictionary, and update
		* winding numbers and mesh connectivity appropriately.  All right-going
		* edges share a common origin vOrg.  Edges are inserted CCW starting at
		* eFirst; the last edge inserted is eLast->Oprev.  If vOrg has any
		* left-going edges already processed, then eTopLeft must be the edge
		* such that an imaginary upward vertical segment from vOrg would be
		* contained between eTopLeft->Oprev and eTopLeft; otherwise eTopLeft
		* should be NULL.
		*/
		var reg, regPrev;
		var e, ePrev;
		var firstTime = true;

		/* Insert the new right-going edges in the dictionary */
		e = eFirst;
		do {
			assert( Geom.vertLeq( e.Org, e.Dst ));
			Sweep.addRegionBelow( tess, regUp, e.Sym );
			e = e.Onext;
		} while ( e !== eLast );

		/* Walk *all* right-going edges from e->Org, in the dictionary order,
		* updating the winding numbers of each region, and re-linking the mesh
		* edges to match the dictionary ordering (if necessary).
		*/
		if( eTopLeft === null ) {
			eTopLeft = Sweep.regionBelow( regUp ).eUp.Rprev;
		}
		regPrev = regUp;
		ePrev = eTopLeft;
		for( ;; ) {
			reg = Sweep.regionBelow( regPrev );
			e = reg.eUp.Sym;
			if( e.Org !== ePrev.Org ) break;

			if( e.Onext !== ePrev ) {
				/* Unlink e from its current position, and relink below ePrev */
				tess.mesh.splice( e.Oprev, e );
				tess.mesh.splice( ePrev.Oprev, e );
			}
			/* Compute the winding number and "inside" flag for the new regions */
			reg.windingNumber = regPrev.windingNumber - e.winding;
			reg.inside = Sweep.isWindingInside( tess, reg.windingNumber );

			/* Check for two outgoing edges with same slope -- process these
			* before any intersection tests (see example in tessComputeInterior).
			*/
			regPrev.dirty = true;
			if( ! firstTime && Sweep.checkForRightSplice( tess, regPrev )) {
				Sweep.addWinding( e, ePrev );
				Sweep.deleteRegion( tess, regPrev );
				tess.mesh.delete( ePrev );
			}
			firstTime = false;
			regPrev = reg;
			ePrev = e;
		}
		regPrev.dirty = true;
		assert( regPrev.windingNumber - e.winding === reg.windingNumber );

		if( cleanUp ) {
			/* Check for intersections between newly adjacent edges. */
			Sweep.walkDirtyRegions( tess, regPrev );
		}
	}


	//static void SpliceMergeVertices( TESStesselator *tess, TESShalfEdge *e1, TESShalfEdge *e2 )
	Sweep.spliceMergeVertices = function( tess, e1, e2 ) {
		/*
		* Two vertices with idential coordinates are combined into one.
		* e1->Org is kept, while e2->Org is discarded.
		*/
		tess.mesh.splice( e1, e2 ); 
	}

	//static void VertexWeights( TESSvertex *isect, TESSvertex *org, TESSvertex *dst, TESSreal *weights )
	Sweep.vertexWeights = function( isect, org, dst ) {
		/*
		* Find some weights which describe how the intersection vertex is
		* a linear combination of "org" and "dest".  Each of the two edges
		* which generated "isect" is allocated 50% of the weight; each edge
		* splits the weight between its org and dst according to the
		* relative distance to "isect".
		*/
		var t1 = Geom.vertL1dist( org, isect );
		var t2 = Geom.vertL1dist( dst, isect );
		var w0 = 0.5 * t2 / (t1 + t2);
		var w1 = 0.5 * t1 / (t1 + t2);
		isect.coords[0] += w0*org.coords[0] + w1*dst.coords[0];
		isect.coords[1] += w0*org.coords[1] + w1*dst.coords[1];
		isect.coords[2] += w0*org.coords[2] + w1*dst.coords[2];
	}


	//static void GetIntersectData( TESStesselator *tess, TESSvertex *isect, TESSvertex *orgUp, TESSvertex *dstUp, TESSvertex *orgLo, TESSvertex *dstLo )
	Sweep.getIntersectData = function( tess, isect, orgUp, dstUp, orgLo, dstLo ) {
		 /*
		 * We've computed a new intersection point, now we need a "data" pointer
		 * from the user so that we can refer to this new vertex in the
		 * rendering callbacks.
		 */
		isect.coords[0] = isect.coords[1] = isect.coords[2] = 0;
		isect.idx = -1;
		Sweep.vertexWeights( isect, orgUp, dstUp );
		Sweep.vertexWeights( isect, orgLo, dstLo );
	}

	//static int CheckForRightSplice( TESStesselator *tess, ActiveRegion *regUp )
	Sweep.checkForRightSplice = function( tess, regUp ) {
		/*
		* Check the upper and lower edge of "regUp", to make sure that the
		* eUp->Org is above eLo, or eLo->Org is below eUp (depending on which
		* origin is leftmost).
		*
		* The main purpose is to splice right-going edges with the same
		* dest vertex and nearly identical slopes (ie. we can't distinguish
		* the slopes numerically).  However the splicing can also help us
		* to recover from numerical errors.  For example, suppose at one
		* point we checked eUp and eLo, and decided that eUp->Org is barely
		* above eLo.  Then later, we split eLo into two edges (eg. from
		* a splice operation like this one).  This can change the result of
		* our test so that now eUp->Org is incident to eLo, or barely below it.
		* We must correct this condition to maintain the dictionary invariants.
		*
		* One possibility is to check these edges for intersection again
		* (ie. CheckForIntersect).  This is what we do if possible.  However
		* CheckForIntersect requires that tess->event lies between eUp and eLo,
		* so that it has something to fall back on when the intersection
		* calculation gives us an unusable answer.  So, for those cases where
		* we can't check for intersection, this routine fixes the problem
		* by just splicing the offending vertex into the other edge.
		* This is a guaranteed solution, no matter how degenerate things get.
		* Basically this is a combinatorial solution to a numerical problem.
		*/
		var regLo = Sweep.regionBelow(regUp);
		var eUp = regUp.eUp;
		var eLo = regLo.eUp;

		if( Geom.vertLeq( eUp.Org, eLo.Org )) {
			if( Geom.edgeSign( eLo.Dst, eUp.Org, eLo.Org ) > 0 ) return false;

			/* eUp->Org appears to be below eLo */
			if( ! Geom.vertEq( eUp.Org, eLo.Org )) {
				/* Splice eUp->Org into eLo */
				tess.mesh.splitEdge( eLo.Sym );
				tess.mesh.splice( eUp, eLo.Oprev );
				regUp.dirty = regLo.dirty = true;

			} else if( eUp.Org !== eLo.Org ) {
				/* merge the two vertices, discarding eUp->Org */
				tess.pq.delete( eUp.Org.pqHandle );
				Sweep.spliceMergeVertices( tess, eLo.Oprev, eUp );
			}
		} else {
			if( Geom.edgeSign( eUp.Dst, eLo.Org, eUp.Org ) < 0 ) return false;

			/* eLo->Org appears to be above eUp, so splice eLo->Org into eUp */
			Sweep.regionAbove(regUp).dirty = regUp.dirty = true;
			tess.mesh.splitEdge( eUp.Sym );
			tess.mesh.splice( eLo.Oprev, eUp );
		}
		return true;
	}

	//static int CheckForLeftSplice( TESStesselator *tess, ActiveRegion *regUp )
	Sweep.checkForLeftSplice = function( tess, regUp ) {
		/*
		* Check the upper and lower edge of "regUp", to make sure that the
		* eUp->Dst is above eLo, or eLo->Dst is below eUp (depending on which
		* destination is rightmost).
		*
		* Theoretically, this should always be true.  However, splitting an edge
		* into two pieces can change the results of previous tests.  For example,
		* suppose at one point we checked eUp and eLo, and decided that eUp->Dst
		* is barely above eLo.  Then later, we split eLo into two edges (eg. from
		* a splice operation like this one).  This can change the result of
		* the test so that now eUp->Dst is incident to eLo, or barely below it.
		* We must correct this condition to maintain the dictionary invariants
		* (otherwise new edges might get inserted in the wrong place in the
		* dictionary, and bad stuff will happen).
		*
		* We fix the problem by just splicing the offending vertex into the
		* other edge.
		*/
		var regLo = Sweep.regionBelow(regUp);
		var eUp = regUp.eUp;
		var eLo = regLo.eUp;
		var e;

		assert( ! Geom.vertEq( eUp.Dst, eLo.Dst ));

		if( Geom.vertLeq( eUp.Dst, eLo.Dst )) {
			if( Geom.edgeSign( eUp.Dst, eLo.Dst, eUp.Org ) < 0 ) return false;

			/* eLo->Dst is above eUp, so splice eLo->Dst into eUp */
			Sweep.regionAbove(regUp).dirty = regUp.dirty = true;
			e = tess.mesh.splitEdge( eUp );
			tess.mesh.splice( eLo.Sym, e );
			e.Lface.inside = regUp.inside;
		} else {
			if( Geom.edgeSign( eLo.Dst, eUp.Dst, eLo.Org ) > 0 ) return false;

			/* eUp->Dst is below eLo, so splice eUp->Dst into eLo */
			regUp.dirty = regLo.dirty = true;
			e = tess.mesh.splitEdge( eLo );
			tess.mesh.splice( eUp.Lnext, eLo.Sym );
			e.Rface.inside = regUp.inside;
		}
		return true;
	}


	//static int CheckForIntersect( TESStesselator *tess, ActiveRegion *regUp )
	Sweep.checkForIntersect = function( tess, regUp ) {
		/*
		* Check the upper and lower edges of the given region to see if
		* they intersect.  If so, create the intersection and add it
		* to the data structures.
		*
		* Returns TRUE if adding the new intersection resulted in a recursive
		* call to AddRightEdges(); in this case all "dirty" regions have been
		* checked for intersections, and possibly regUp has been deleted.
		*/
		var regLo = Sweep.regionBelow(regUp);
		var eUp = regUp.eUp;
		var eLo = regLo.eUp;
		var orgUp = eUp.Org;
		var orgLo = eLo.Org;
		var dstUp = eUp.Dst;
		var dstLo = eLo.Dst;
		var tMinUp, tMaxLo;
		var isect = new TESSvertex, orgMin;
		var e;

		assert( ! Geom.vertEq( dstLo, dstUp ));
		assert( Geom.edgeSign( dstUp, tess.event, orgUp ) <= 0 );
		assert( Geom.edgeSign( dstLo, tess.event, orgLo ) >= 0 );
		assert( orgUp !== tess.event && orgLo !== tess.event );
		assert( ! regUp.fixUpperEdge && ! regLo.fixUpperEdge );

		if( orgUp === orgLo ) return false;	/* right endpoints are the same */

		tMinUp = Math.min( orgUp.t, dstUp.t );
		tMaxLo = Math.max( orgLo.t, dstLo.t );
		if( tMinUp > tMaxLo ) return false;	/* t ranges do not overlap */

		if( Geom.vertLeq( orgUp, orgLo )) {
			if( Geom.edgeSign( dstLo, orgUp, orgLo ) > 0 ) return false;
		} else {
			if( Geom.edgeSign( dstUp, orgLo, orgUp ) < 0 ) return false;
		}

		/* At this point the edges intersect, at least marginally */
		Sweep.debugEvent( tess );

		Geom.intersect( dstUp, orgUp, dstLo, orgLo, isect );
		/* The following properties are guaranteed: */
		assert( Math.min( orgUp.t, dstUp.t ) <= isect.t );
		assert( isect.t <= Math.max( orgLo.t, dstLo.t ));
		assert( Math.min( dstLo.s, dstUp.s ) <= isect.s );
		assert( isect.s <= Math.max( orgLo.s, orgUp.s ));

		if( Geom.vertLeq( isect, tess.event )) {
			/* The intersection point lies slightly to the left of the sweep line,
			* so move it until it''s slightly to the right of the sweep line.
			* (If we had perfect numerical precision, this would never happen
			* in the first place).  The easiest and safest thing to do is
			* replace the intersection by tess->event.
			*/
			isect.s = tess.event.s;
			isect.t = tess.event.t;
		}
		/* Similarly, if the computed intersection lies to the right of the
		* rightmost origin (which should rarely happen), it can cause
		* unbelievable inefficiency on sufficiently degenerate inputs.
		* (If you have the test program, try running test54.d with the
		* "X zoom" option turned on).
		*/
		orgMin = Geom.vertLeq( orgUp, orgLo ) ? orgUp : orgLo;
		if( Geom.vertLeq( orgMin, isect )) {
			isect.s = orgMin.s;
			isect.t = orgMin.t;
		}

		if( Geom.vertEq( isect, orgUp ) || Geom.vertEq( isect, orgLo )) {
			/* Easy case -- intersection at one of the right endpoints */
			Sweep.checkForRightSplice( tess, regUp );
			return false;
		}

		if(    (! Geom.vertEq( dstUp, tess.event )
			&& Geom.edgeSign( dstUp, tess.event, isect ) >= 0)
			|| (! Geom.vertEq( dstLo, tess.event )
			&& Geom.edgeSign( dstLo, tess.event, isect ) <= 0 ))
		{
			/* Very unusual -- the new upper or lower edge would pass on the
			* wrong side of the sweep event, or through it.  This can happen
			* due to very small numerical errors in the intersection calculation.
			*/
			if( dstLo === tess.event ) {
				/* Splice dstLo into eUp, and process the new region(s) */
				tess.mesh.splitEdge( eUp.Sym );
				tess.mesh.splice( eLo.Sym, eUp );
				regUp = Sweep.topLeftRegion( tess, regUp );
	//			if (regUp == NULL) longjmp(tess->env,1);
				eUp = Sweep.regionBelow(regUp).eUp;
				Sweep.finishLeftRegions( tess, Sweep.regionBelow(regUp), regLo );
				Sweep.addRightEdges( tess, regUp, eUp.Oprev, eUp, eUp, true );
				return TRUE;
			}
			if( dstUp === tess.event ) {
				/* Splice dstUp into eLo, and process the new region(s) */
				tess.mesh.splitEdge( eLo.Sym );
				tess.mesh.splice( eUp.Lnext, eLo.Oprev ); 
				regLo = regUp;
				regUp = Sweep.topRightRegion( regUp );
				e = Sweep.regionBelow(regUp).eUp.Rprev;
				regLo.eUp = eLo.Oprev;
				eLo = Sweep.finishLeftRegions( tess, regLo, null );
				Sweep.addRightEdges( tess, regUp, eLo.Onext, eUp.Rprev, e, true );
				return true;
			}
			/* Special case: called from ConnectRightVertex.  If either
			* edge passes on the wrong side of tess->event, split it
			* (and wait for ConnectRightVertex to splice it appropriately).
			*/
			if( Geom.edgeSign( dstUp, tess.event, isect ) >= 0 ) {
				Sweep.regionAbove(regUp).dirty = regUp.dirty = true;
				tess.mesh.splitEdge( eUp.Sym );
				eUp.Org.s = tess.event.s;
				eUp.Org.t = tess.event.t;
			}
			if( Geom.edgeSign( dstLo, tess.event, isect ) <= 0 ) {
				regUp.dirty = regLo.dirty = true;
				tess.mesh.splitEdge( eLo.Sym );
				eLo.Org.s = tess.event.s;
				eLo.Org.t = tess.event.t;
			}
			/* leave the rest for ConnectRightVertex */
			return false;
		}

		/* General case -- split both edges, splice into new vertex.
		* When we do the splice operation, the order of the arguments is
		* arbitrary as far as correctness goes.  However, when the operation
		* creates a new face, the work done is proportional to the size of
		* the new face.  We expect the faces in the processed part of
		* the mesh (ie. eUp->Lface) to be smaller than the faces in the
		* unprocessed original contours (which will be eLo->Oprev->Lface).
		*/
		tess.mesh.splitEdge( eUp.Sym );
		tess.mesh.splitEdge( eLo.Sym );
		tess.mesh.splice( eLo.Oprev, eUp );
		eUp.Org.s = isect.s;
		eUp.Org.t = isect.t;
		eUp.Org.pqHandle = tess.pq.insert( eUp.Org );
		Sweep.getIntersectData( tess, eUp.Org, orgUp, dstUp, orgLo, dstLo );
		Sweep.regionAbove(regUp).dirty = regUp.dirty = regLo.dirty = true;
		return false;
	}

	//static void WalkDirtyRegions( TESStesselator *tess, ActiveRegion *regUp )
	Sweep.walkDirtyRegions = function( tess, regUp ) {
		/*
		* When the upper or lower edge of any region changes, the region is
		* marked "dirty".  This routine walks through all the dirty regions
		* and makes sure that the dictionary invariants are satisfied
		* (see the comments at the beginning of this file).  Of course
		* new dirty regions can be created as we make changes to restore
		* the invariants.
		*/
		var regLo = Sweep.regionBelow(regUp);
		var eUp, eLo;

		for( ;; ) {
			/* Find the lowest dirty region (we walk from the bottom up). */
			while( regLo.dirty ) {
				regUp = regLo;
				regLo = Sweep.regionBelow(regLo);
			}
			if( ! regUp.dirty ) {
				regLo = regUp;
				regUp = Sweep.regionAbove( regUp );
				if( regUp == null || ! regUp.dirty ) {
					/* We've walked all the dirty regions */
					return;
				}
			}
			regUp.dirty = false;
			eUp = regUp.eUp;
			eLo = regLo.eUp;

			if( eUp.Dst !== eLo.Dst ) {
				/* Check that the edge ordering is obeyed at the Dst vertices. */
				if( Sweep.checkForLeftSplice( tess, regUp )) {

					/* If the upper or lower edge was marked fixUpperEdge, then
					* we no longer need it (since these edges are needed only for
					* vertices which otherwise have no right-going edges).
					*/
					if( regLo.fixUpperEdge ) {
						Sweep.deleteRegion( tess, regLo );
						tess.mesh.delete( eLo );
						regLo = Sweep.regionBelow( regUp );
						eLo = regLo.eUp;
					} else if( regUp.fixUpperEdge ) {
						Sweep.deleteRegion( tess, regUp );
						tess.mesh.delete( eUp );
						regUp = Sweep.regionAbove( regLo );
						eUp = regUp.eUp;
					}
				}
			}
			if( eUp.Org !== eLo.Org ) {
				if(    eUp.Dst !== eLo.Dst
					&& ! regUp.fixUpperEdge && ! regLo.fixUpperEdge
					&& (eUp.Dst === tess.event || eLo.Dst === tess.event) )
				{
					/* When all else fails in CheckForIntersect(), it uses tess->event
					* as the intersection location.  To make this possible, it requires
					* that tess->event lie between the upper and lower edges, and also
					* that neither of these is marked fixUpperEdge (since in the worst
					* case it might splice one of these edges into tess->event, and
					* violate the invariant that fixable edges are the only right-going
					* edge from their associated vertex).
					*/
					if( Sweep.checkForIntersect( tess, regUp )) {
						/* WalkDirtyRegions() was called recursively; we're done */
						return;
					}
				} else {
					/* Even though we can't use CheckForIntersect(), the Org vertices
					* may violate the dictionary edge ordering.  Check and correct this.
					*/
					Sweep.checkForRightSplice( tess, regUp );
				}
			}
			if( eUp.Org === eLo.Org && eUp.Dst === eLo.Dst ) {
				/* A degenerate loop consisting of only two edges -- delete it. */
				Sweep.addWinding( eLo, eUp );
				Sweep.deleteRegion( tess, regUp );
				tess.mesh.delete( eUp );
				regUp = Sweep.regionAbove( regLo );
			}
		}
	}


	//static void ConnectRightVertex( TESStesselator *tess, ActiveRegion *regUp, TESShalfEdge *eBottomLeft )
	Sweep.connectRightVertex = function( tess, regUp, eBottomLeft ) {
		/*
		* Purpose: connect a "right" vertex vEvent (one where all edges go left)
		* to the unprocessed portion of the mesh.  Since there are no right-going
		* edges, two regions (one above vEvent and one below) are being merged
		* into one.  "regUp" is the upper of these two regions.
		*
		* There are two reasons for doing this (adding a right-going edge):
		*  - if the two regions being merged are "inside", we must add an edge
		*    to keep them separated (the combined region would not be monotone).
		*  - in any case, we must leave some record of vEvent in the dictionary,
		*    so that we can merge vEvent with features that we have not seen yet.
		*    For example, maybe there is a vertical edge which passes just to
		*    the right of vEvent; we would like to splice vEvent into this edge.
		*
		* However, we don't want to connect vEvent to just any vertex.  We don''t
		* want the new edge to cross any other edges; otherwise we will create
		* intersection vertices even when the input data had no self-intersections.
		* (This is a bad thing; if the user's input data has no intersections,
		* we don't want to generate any false intersections ourselves.)
		*
		* Our eventual goal is to connect vEvent to the leftmost unprocessed
		* vertex of the combined region (the union of regUp and regLo).
		* But because of unseen vertices with all right-going edges, and also
		* new vertices which may be created by edge intersections, we don''t
		* know where that leftmost unprocessed vertex is.  In the meantime, we
		* connect vEvent to the closest vertex of either chain, and mark the region
		* as "fixUpperEdge".  This flag says to delete and reconnect this edge
		* to the next processed vertex on the boundary of the combined region.
		* Quite possibly the vertex we connected to will turn out to be the
		* closest one, in which case we won''t need to make any changes.
		*/
		var eNew;
		var eTopLeft = eBottomLeft.Onext;
		var regLo = Sweep.regionBelow(regUp);
		var eUp = regUp.eUp;
		var eLo = regLo.eUp;
		var degenerate = false;

		if( eUp.Dst !== eLo.Dst ) {
			Sweep.checkForIntersect( tess, regUp );
		}

		/* Possible new degeneracies: upper or lower edge of regUp may pass
		* through vEvent, or may coincide with new intersection vertex
		*/
		if( Geom.vertEq( eUp.Org, tess.event )) {
			tess.mesh.splice( eTopLeft.Oprev, eUp );
			regUp = Sweep.topLeftRegion( tess, regUp );
			eTopLeft = Sweep.regionBelow( regUp ).eUp;
			Sweep.finishLeftRegions( tess, Sweep.regionBelow(regUp), regLo );
			degenerate = true;
		}
		if( Geom.vertEq( eLo.Org, tess.event )) {
			tess.mesh.splice( eBottomLeft, eLo.Oprev );
			eBottomLeft = Sweep.finishLeftRegions( tess, regLo, null );
			degenerate = true;
		}
		if( degenerate ) {
			Sweep.addRightEdges( tess, regUp, eBottomLeft.Onext, eTopLeft, eTopLeft, true );
			return;
		}

		/* Non-degenerate situation -- need to add a temporary, fixable edge.
		* Connect to the closer of eLo->Org, eUp->Org.
		*/
		if( Geom.vertLeq( eLo.Org, eUp.Org )) {
			eNew = eLo.Oprev;
		} else {
			eNew = eUp;
		}
		eNew = tess.mesh.connect( eBottomLeft.Lprev, eNew );

		/* Prevent cleanup, otherwise eNew might disappear before we've even
		* had a chance to mark it as a temporary edge.
		*/
		Sweep.addRightEdges( tess, regUp, eNew, eNew.Onext, eNew.Onext, false );
		eNew.Sym.activeRegion.fixUpperEdge = true;
		Sweep.walkDirtyRegions( tess, regUp );
	}

	/* Because vertices at exactly the same location are merged together
	* before we process the sweep event, some degenerate cases can't occur.
	* However if someone eventually makes the modifications required to
	* merge features which are close together, the cases below marked
	* TOLERANCE_NONZERO will be useful.  They were debugged before the
	* code to merge identical vertices in the main loop was added.
	*/
	//#define TOLERANCE_NONZERO	FALSE

	//static void ConnectLeftDegenerate( TESStesselator *tess, ActiveRegion *regUp, TESSvertex *vEvent )
	Sweep.connectLeftDegenerate = function( tess, regUp, vEvent ) {
		/*
		* The event vertex lies exacty on an already-processed edge or vertex.
		* Adding the new vertex involves splicing it into the already-processed
		* part of the mesh.
		*/
		var e, eTopLeft, eTopRight, eLast;
		var reg;

		e = regUp.eUp;
		if( Geom.vertEq( e.Org, vEvent )) {
			/* e->Org is an unprocessed vertex - just combine them, and wait
			* for e->Org to be pulled from the queue
			*/
			assert( false /*TOLERANCE_NONZERO*/ );
			Sweep.spliceMergeVertices( tess, e, vEvent.anEdge );
			return;
		}

		if( ! Geom.vertEq( e.Dst, vEvent )) {
			/* General case -- splice vEvent into edge e which passes through it */
			tess.mesh.splitEdge( e.Sym );
			if( regUp.fixUpperEdge ) {
				/* This edge was fixable -- delete unused portion of original edge */
				tess.mesh.delete( e.Onext );
				regUp.fixUpperEdge = false;
			}
			tess.mesh.splice( vEvent.anEdge, e );
			Sweep.sweepEvent( tess, vEvent );	/* recurse */
			return;
		}

		/* vEvent coincides with e->Dst, which has already been processed.
		* Splice in the additional right-going edges.
		*/
		assert( false /*TOLERANCE_NONZERO*/ );
		regUp = Sweep.topRightRegion( regUp );
		reg = Sweep.regionBelow( regUp );
		eTopRight = reg.eUp.Sym;
		eTopLeft = eLast = eTopRight.Onext;
		if( reg.fixUpperEdge ) {
			/* Here e->Dst has only a single fixable edge going right.
			* We can delete it since now we have some real right-going edges.
			*/
			assert( eTopLeft !== eTopRight );   /* there are some left edges too */
			Sweep.deleteRegion( tess, reg );
			tess.mesh.delete( eTopRight );
			eTopRight = eTopLeft.Oprev;
		}
		tess.mesh.splice( vEvent.anEdge, eTopRight );
		if( ! Geom.edgeGoesLeft( eTopLeft )) {
			/* e->Dst had no left-going edges -- indicate this to AddRightEdges() */
			eTopLeft = null;
		}
		Sweep.addRightEdges( tess, regUp, eTopRight.Onext, eLast, eTopLeft, true );
	}


	//static void ConnectLeftVertex( TESStesselator *tess, TESSvertex *vEvent )
	Sweep.connectLeftVertex = function( tess, vEvent ) {
		/*
		* Purpose: connect a "left" vertex (one where both edges go right)
		* to the processed portion of the mesh.  Let R be the active region
		* containing vEvent, and let U and L be the upper and lower edge
		* chains of R.  There are two possibilities:
		*
		* - the normal case: split R into two regions, by connecting vEvent to
		*   the rightmost vertex of U or L lying to the left of the sweep line
		*
		* - the degenerate case: if vEvent is close enough to U or L, we
		*   merge vEvent into that edge chain.  The subcases are:
		*	- merging with the rightmost vertex of U or L
		*	- merging with the active edge of U or L
		*	- merging with an already-processed portion of U or L
		*/
		var regUp, regLo, reg;
		var eUp, eLo, eNew;
		var tmp = new ActiveRegion();

		/* assert( vEvent->anEdge->Onext->Onext == vEvent->anEdge ); */

		/* Get a pointer to the active region containing vEvent */
		tmp.eUp = vEvent.anEdge.Sym;
		/* __GL_DICTLISTKEY */ /* tessDictListSearch */
		regUp = tess.dict.search( tmp ).key;
		regLo = Sweep.regionBelow( regUp );
		if( !regLo ) {
			// This may happen if the input polygon is coplanar.
			return;
		}
		eUp = regUp.eUp;
		eLo = regLo.eUp;

		/* Try merging with U or L first */
		if( Geom.edgeSign( eUp.Dst, vEvent, eUp.Org ) === 0.0 ) {
			Sweep.connectLeftDegenerate( tess, regUp, vEvent );
			return;
		}

		/* Connect vEvent to rightmost processed vertex of either chain.
		* e->Dst is the vertex that we will connect to vEvent.
		*/
		reg = Geom.vertLeq( eLo.Dst, eUp.Dst ) ? regUp : regLo;

		if( regUp.inside || reg.fixUpperEdge) {
			if( reg === regUp ) {
				eNew = tess.mesh.connect( vEvent.anEdge.Sym, eUp.Lnext );
			} else {
				var tempHalfEdge = tess.mesh.connect( eLo.Dnext, vEvent.anEdge);
				eNew = tempHalfEdge.Sym;
			}
			if( reg.fixUpperEdge ) {
				Sweep.fixUpperEdge( tess, reg, eNew );
			} else {
				Sweep.computeWinding( tess, Sweep.addRegionBelow( tess, regUp, eNew ));
			}
			Sweep.sweepEvent( tess, vEvent );
		} else {
			/* The new vertex is in a region which does not belong to the polygon.
			* We don''t need to connect this vertex to the rest of the mesh.
			*/
			Sweep.addRightEdges( tess, regUp, vEvent.anEdge, vEvent.anEdge, null, true );
		}
	};


	//static void SweepEvent( TESStesselator *tess, TESSvertex *vEvent )
	Sweep.sweepEvent = function( tess, vEvent ) {
		/*
		* Does everything necessary when the sweep line crosses a vertex.
		* Updates the mesh and the edge dictionary.
		*/

		tess.event = vEvent;		/* for access in EdgeLeq() */
		Sweep.debugEvent( tess );

		/* Check if this vertex is the right endpoint of an edge that is
		* already in the dictionary.  In this case we don't need to waste
		* time searching for the location to insert new edges.
		*/
		var e = vEvent.anEdge;
		while( e.activeRegion === null ) {
			e = e.Onext;
			if( e == vEvent.anEdge ) {
				/* All edges go right -- not incident to any processed edges */
				Sweep.connectLeftVertex( tess, vEvent );
				return;
			}
		}

		/* Processing consists of two phases: first we "finish" all the
		* active regions where both the upper and lower edges terminate
		* at vEvent (ie. vEvent is closing off these regions).
		* We mark these faces "inside" or "outside" the polygon according
		* to their winding number, and delete the edges from the dictionary.
		* This takes care of all the left-going edges from vEvent.
		*/
		var regUp = Sweep.topLeftRegion( tess, e.activeRegion );
		assert( regUp !== null );
	//	if (regUp == NULL) longjmp(tess->env,1);
		var reg = Sweep.regionBelow( regUp );
		var eTopLeft = reg.eUp;
		var eBottomLeft = Sweep.finishLeftRegions( tess, reg, null );

		/* Next we process all the right-going edges from vEvent.  This
		* involves adding the edges to the dictionary, and creating the
		* associated "active regions" which record information about the
		* regions between adjacent dictionary edges.
		*/
		if( eBottomLeft.Onext === eTopLeft ) {
			/* No right-going edges -- add a temporary "fixable" edge */
			Sweep.connectRightVertex( tess, regUp, eBottomLeft );
		} else {
			Sweep.addRightEdges( tess, regUp, eBottomLeft.Onext, eTopLeft, eTopLeft, true );
		}
	};


	/* Make the sentinel coordinates big enough that they will never be
	* merged with real input features.
	*/

	//static void AddSentinel( TESStesselator *tess, TESSreal smin, TESSreal smax, TESSreal t )
	Sweep.addSentinel = function( tess, smin, smax, t ) {
		/*
		* We add two sentinel edges above and below all other edges,
		* to avoid special cases at the top and bottom.
		*/
		var reg = new ActiveRegion();
		var e = tess.mesh.makeEdge();
	//	if (e == NULL) longjmp(tess->env,1);

		e.Org.s = smax;
		e.Org.t = t;
		e.Dst.s = smin;
		e.Dst.t = t;
		tess.event = e.Dst;		/* initialize it */

		reg.eUp = e;
		reg.windingNumber = 0;
		reg.inside = false;
		reg.fixUpperEdge = false;
		reg.sentinel = true;
		reg.dirty = false;
		reg.nodeUp = tess.dict.insert( reg );
	//	if (reg->nodeUp == NULL) longjmp(tess->env,1);
	}


	//static void InitEdgeDict( TESStesselator *tess )
	Sweep.initEdgeDict = function( tess ) {
		/*
		* We maintain an ordering of edge intersections with the sweep line.
		* This order is maintained in a dynamic dictionary.
		*/
		tess.dict = new Dict( tess, Sweep.edgeLeq );
	//	if (tess->dict == NULL) longjmp(tess->env,1);

		var w = (tess.bmax[0] - tess.bmin[0]);
		var h = (tess.bmax[1] - tess.bmin[1]);

		var smin = tess.bmin[0] - w;
		var smax = tess.bmax[0] + w;
		var tmin = tess.bmin[1] - h;
		var tmax = tess.bmax[1] + h;

		Sweep.addSentinel( tess, smin, smax, tmin );
		Sweep.addSentinel( tess, smin, smax, tmax );
	}


	Sweep.doneEdgeDict = function( tess )
	{
		var reg;
		var fixedEdges = 0;

		while( (reg = tess.dict.min().key) !== null ) {
			/*
			* At the end of all processing, the dictionary should contain
			* only the two sentinel edges, plus at most one "fixable" edge
			* created by ConnectRightVertex().
			*/
			if( ! reg.sentinel ) {
				assert( reg.fixUpperEdge );
				assert( ++fixedEdges == 1 );
			}
			assert( reg.windingNumber == 0 );
			Sweep.deleteRegion( tess, reg );
			/*    tessMeshDelete( reg->eUp );*/
		}
	//	dictDeleteDict( &tess->alloc, tess->dict );
	}


	Sweep.removeDegenerateEdges = function( tess ) {
		/*
		* Remove zero-length edges, and contours with fewer than 3 vertices.
		*/
		var e, eNext, eLnext;
		var eHead = tess.mesh.eHead;

		/*LINTED*/
		for( e = eHead.next; e !== eHead; e = eNext ) {
			eNext = e.next;
			eLnext = e.Lnext;

			if( Geom.vertEq( e.Org, e.Dst ) && e.Lnext.Lnext !== e ) {
				/* Zero-length edge, contour has at least 3 edges */
				Sweep.spliceMergeVertices( tess, eLnext, e );	/* deletes e->Org */
				tess.mesh.delete( e ); /* e is a self-loop */
				e = eLnext;
				eLnext = e.Lnext;
			}
			if( eLnext.Lnext === e ) {
				/* Degenerate contour (one or two edges) */
				if( eLnext !== e ) {
					if( eLnext === eNext || eLnext === eNext.Sym ) { eNext = eNext.next; }
					tess.mesh.delete( eLnext );
				}
				if( e === eNext || e === eNext.Sym ) { eNext = eNext.next; }
				tess.mesh.delete( e );
			}
		}
	}

	Sweep.initPriorityQ = function( tess ) {
		/*
		* Insert all vertices into the priority queue which determines the
		* order in which vertices cross the sweep line.
		*/
		var pq;
		var v, vHead;
		var vertexCount = 0;
		
		vHead = tess.mesh.vHead;
		for( v = vHead.next; v !== vHead; v = v.next ) {
			vertexCount++;
		}
		/* Make sure there is enough space for sentinels. */
		vertexCount += 8; //MAX( 8, tess->alloc.extraVertices );
		
		pq = tess.pq = new PriorityQ( vertexCount, Geom.vertLeq );
	//	if (pq == NULL) return 0;

		vHead = tess.mesh.vHead;
		for( v = vHead.next; v !== vHead; v = v.next ) {
			v.pqHandle = pq.insert( v );
	//		if (v.pqHandle == INV_HANDLE)
	//			break;
		}

		if (v !== vHead) {
			return false;
		}

		pq.init();

		return true;
	}


	Sweep.donePriorityQ = function( tess ) {
		tess.pq = null;
	}


	Sweep.removeDegenerateFaces = function( tess, mesh ) {
		/*
		* Delete any degenerate faces with only two edges.  WalkDirtyRegions()
		* will catch almost all of these, but it won't catch degenerate faces
		* produced by splice operations on already-processed edges.
		* The two places this can happen are in FinishLeftRegions(), when
		* we splice in a "temporary" edge produced by ConnectRightVertex(),
		* and in CheckForLeftSplice(), where we splice already-processed
		* edges to ensure that our dictionary invariants are not violated
		* by numerical errors.
		*
		* In both these cases it is *very* dangerous to delete the offending
		* edge at the time, since one of the routines further up the stack
		* will sometimes be keeping a pointer to that edge.
		*/
		var f, fNext;
		var e;

		/*LINTED*/
		for( f = mesh.fHead.next; f !== mesh.fHead; f = fNext ) {
			fNext = f.next;
			e = f.anEdge;
			assert( e.Lnext !== e );

			if( e.Lnext.Lnext === e ) {
				/* A face with only two edges */
				Sweep.addWinding( e.Onext, e );
				tess.mesh.delete( e );
			}
		}
		return true;
	}

	Sweep.computeInterior = function( tess ) {
		/*
		* tessComputeInterior( tess ) computes the planar arrangement specified
		* by the given contours, and further subdivides this arrangement
		* into regions.  Each region is marked "inside" if it belongs
		* to the polygon, according to the rule given by tess->windingRule.
		* Each interior region is guaranteed be monotone.
		*/
		var v, vNext;

		/* Each vertex defines an event for our sweep line.  Start by inserting
		* all the vertices in a priority queue.  Events are processed in
		* lexicographic order, ie.
		*
		*	e1 < e2  iff  e1.x < e2.x || (e1.x == e2.x && e1.y < e2.y)
		*/
		Sweep.removeDegenerateEdges( tess );
		if ( !Sweep.initPriorityQ( tess ) ) return false; /* if error */
		Sweep.initEdgeDict( tess );

		while( (v = tess.pq.extractMin()) !== null ) {
			for( ;; ) {
				vNext = tess.pq.min();
				if( vNext === null || ! Geom.vertEq( vNext, v )) break;

				/* Merge together all vertices at exactly the same location.
				* This is more efficient than processing them one at a time,
				* simplifies the code (see ConnectLeftDegenerate), and is also
				* important for correct handling of certain degenerate cases.
				* For example, suppose there are two identical edges A and B
				* that belong to different contours (so without this code they would
				* be processed by separate sweep events).  Suppose another edge C
				* crosses A and B from above.  When A is processed, we split it
				* at its intersection point with C.  However this also splits C,
				* so when we insert B we may compute a slightly different
				* intersection point.  This might leave two edges with a small
				* gap between them.  This kind of error is especially obvious
				* when using boundary extraction (TESS_BOUNDARY_ONLY).
				*/
				vNext = tess.pq.extractMin();
				Sweep.spliceMergeVertices( tess, v.anEdge, vNext.anEdge );
			}
			Sweep.sweepEvent( tess, v );
		}

		/* Set tess->event for debugging purposes */
		tess.event = tess.dict.min().key.eUp.Org;
		Sweep.debugEvent( tess );
		Sweep.doneEdgeDict( tess );
		Sweep.donePriorityQ( tess );

		if ( !Sweep.removeDegenerateFaces( tess, tess.mesh ) ) return false;
		tess.mesh.check();

		return true;
	}


	function Tesselator() {

		/*** state needed for collecting the input data ***/
		this.mesh = null;		/* stores the input contours, and eventually
							the tessellation itself */

		/*** state needed for projecting onto the sweep plane ***/

		this.normal = [0.0, 0.0, 0.0];	/* user-specified normal (if provided) */
		this.sUnit = [0.0, 0.0, 0.0];	/* unit vector in s-direction (debugging) */
		this.tUnit = [0.0, 0.0, 0.0];	/* unit vector in t-direction (debugging) */

		this.bmin = [0.0, 0.0];
		this.bmax = [0.0, 0.0];

		/*** state needed for the line sweep ***/
		this.windingRule = Tess2.WINDING_ODD;	/* rule for determining polygon interior */

		this.dict = null;		/* edge dictionary for sweep line */
		this.pq = null;		/* priority queue of vertex events */
		this.event = null;		/* current sweep event being processed */

		this.vertexIndexCounter = 0;
		
		this.vertices = [];
		this.vertexIndices = [];
		this.vertexCount = 0;
		this.elements = [];
		this.elementCount = 0;
	};

	Tesselator.prototype = {

		dot_: function(u, v) {
			return (u[0]*v[0] + u[1]*v[1] + u[2]*v[2]);
		},

		normalize_: function( v ) {
			var len = v[0]*v[0] + v[1]*v[1] + v[2]*v[2];
			assert( len > 0.0 );
			len = Math.sqrt( len );
			v[0] /= len;
			v[1] /= len;
			v[2] /= len;
		},

		longAxis_: function( v ) {
			var i = 0;
			if( Math.abs(v[1]) > Math.abs(v[0]) ) { i = 1; }
			if( Math.abs(v[2]) > Math.abs(v[i]) ) { i = 2; }
			return i;
		},

		computeNormal_: function( norm )
		{
			var v, v1, v2;
			var c, tLen2, maxLen2;
			var maxVal = [0,0,0], minVal = [0,0,0], d1 = [0,0,0], d2 = [0,0,0], tNorm = [0,0,0];
			var maxVert = [null,null,null], minVert = [null,null,null];
			var vHead = this.mesh.vHead;
			var i;

			v = vHead.next;
			for( i = 0; i < 3; ++i ) {
				c = v.coords[i];
				minVal[i] = c;
				minVert[i] = v;
				maxVal[i] = c;
				maxVert[i] = v;
			}

			for( v = vHead.next; v !== vHead; v = v.next ) {
				for( i = 0; i < 3; ++i ) {
					c = v.coords[i];
					if( c < minVal[i] ) { minVal[i] = c; minVert[i] = v; }
					if( c > maxVal[i] ) { maxVal[i] = c; maxVert[i] = v; }
				}
			}

			/* Find two vertices separated by at least 1/sqrt(3) of the maximum
			* distance between any two vertices
			*/
			i = 0;
			if( maxVal[1] - minVal[1] > maxVal[0] - minVal[0] ) { i = 1; }
			if( maxVal[2] - minVal[2] > maxVal[i] - minVal[i] ) { i = 2; }
			if( minVal[i] >= maxVal[i] ) {
				/* All vertices are the same -- normal doesn't matter */
				norm[0] = 0; norm[1] = 0; norm[2] = 1;
				return;
			}

			/* Look for a third vertex which forms the triangle with maximum area
			* (Length of normal == twice the triangle area)
			*/
			maxLen2 = 0;
			v1 = minVert[i];
			v2 = maxVert[i];
			d1[0] = v1.coords[0] - v2.coords[0];
			d1[1] = v1.coords[1] - v2.coords[1];
			d1[2] = v1.coords[2] - v2.coords[2];
			for( v = vHead.next; v !== vHead; v = v.next ) {
				d2[0] = v.coords[0] - v2.coords[0];
				d2[1] = v.coords[1] - v2.coords[1];
				d2[2] = v.coords[2] - v2.coords[2];
				tNorm[0] = d1[1]*d2[2] - d1[2]*d2[1];
				tNorm[1] = d1[2]*d2[0] - d1[0]*d2[2];
				tNorm[2] = d1[0]*d2[1] - d1[1]*d2[0];
				tLen2 = tNorm[0]*tNorm[0] + tNorm[1]*tNorm[1] + tNorm[2]*tNorm[2];
				if( tLen2 > maxLen2 ) {
					maxLen2 = tLen2;
					norm[0] = tNorm[0];
					norm[1] = tNorm[1];
					norm[2] = tNorm[2];
				}
			}

			if( maxLen2 <= 0 ) {
				/* All points lie on a single line -- any decent normal will do */
				norm[0] = norm[1] = norm[2] = 0;
				norm[this.longAxis_(d1)] = 1;
			}
		},

		checkOrientation_: function() {
			var area;
			var f, fHead = this.mesh.fHead;
			var v, vHead = this.mesh.vHead;
			var e;

			/* When we compute the normal automatically, we choose the orientation
			* so that the the sum of the signed areas of all contours is non-negative.
			*/
			area = 0;
			for( f = fHead.next; f !== fHead; f = f.next ) {
				e = f.anEdge;
				if( e.winding <= 0 ) continue;
				do {
					area += (e.Org.s - e.Dst.s) * (e.Org.t + e.Dst.t);
					e = e.Lnext;
				} while( e !== f.anEdge );
			}
			if( area < 0 ) {
				/* Reverse the orientation by flipping all the t-coordinates */
				for( v = vHead.next; v !== vHead; v = v.next ) {
					v.t = - v.t;
				}
				this.tUnit[0] = - this.tUnit[0];
				this.tUnit[1] = - this.tUnit[1];
				this.tUnit[2] = - this.tUnit[2];
			}
		},

	/*	#ifdef FOR_TRITE_TEST_PROGRAM
		#include <stdlib.h>
		extern int RandomSweep;
		#define S_UNIT_X	(RandomSweep ? (2*drand48()-1) : 1.0)
		#define S_UNIT_Y	(RandomSweep ? (2*drand48()-1) : 0.0)
		#else
		#if defined(SLANTED_SWEEP) */
		/* The "feature merging" is not intended to be complete.  There are
		* special cases where edges are nearly parallel to the sweep line
		* which are not implemented.  The algorithm should still behave
		* robustly (ie. produce a reasonable tesselation) in the presence
		* of such edges, however it may miss features which could have been
		* merged.  We could minimize this effect by choosing the sweep line
		* direction to be something unusual (ie. not parallel to one of the
		* coordinate axes).
		*/
	/*	#define S_UNIT_X	(TESSreal)0.50941539564955385	// Pre-normalized
		#define S_UNIT_Y	(TESSreal)0.86052074622010633
		#else
		#define S_UNIT_X	(TESSreal)1.0
		#define S_UNIT_Y	(TESSreal)0.0
		#endif
		#endif*/

		/* Determine the polygon normal and project vertices onto the plane
		* of the polygon.
		*/
		projectPolygon_: function() {
			var v, vHead = this.mesh.vHead;
			var norm = [0,0,0];
			var sUnit, tUnit;
			var i, first, computedNormal = false;

			norm[0] = this.normal[0];
			norm[1] = this.normal[1];
			norm[2] = this.normal[2];
			if( norm[0] === 0.0 && norm[1] === 0.0 && norm[2] === 0.0 ) {
				this.computeNormal_( norm );
				computedNormal = true;
			}
			sUnit = this.sUnit;
			tUnit = this.tUnit;
			i = this.longAxis_( norm );

	/*	#if defined(FOR_TRITE_TEST_PROGRAM) || defined(TRUE_PROJECT)
			// Choose the initial sUnit vector to be approximately perpendicular
			// to the normal.
			
			Normalize( norm );

			sUnit[i] = 0;
			sUnit[(i+1)%3] = S_UNIT_X;
			sUnit[(i+2)%3] = S_UNIT_Y;

			// Now make it exactly perpendicular 
			w = Dot( sUnit, norm );
			sUnit[0] -= w * norm[0];
			sUnit[1] -= w * norm[1];
			sUnit[2] -= w * norm[2];
			Normalize( sUnit );

			// Choose tUnit so that (sUnit,tUnit,norm) form a right-handed frame 
			tUnit[0] = norm[1]*sUnit[2] - norm[2]*sUnit[1];
			tUnit[1] = norm[2]*sUnit[0] - norm[0]*sUnit[2];
			tUnit[2] = norm[0]*sUnit[1] - norm[1]*sUnit[0];
			Normalize( tUnit );
		#else*/
			/* Project perpendicular to a coordinate axis -- better numerically */
			sUnit[i] = 0;
			sUnit[(i+1)%3] = 1.0;
			sUnit[(i+2)%3] = 0.0;

			tUnit[i] = 0;
			tUnit[(i+1)%3] = 0.0;
			tUnit[(i+2)%3] = (norm[i] > 0) ? 1.0 : -1.0;
	//	#endif

			/* Project the vertices onto the sweep plane */
			for( v = vHead.next; v !== vHead; v = v.next ) {
				v.s = this.dot_( v.coords, sUnit );
				v.t = this.dot_( v.coords, tUnit );
			}
			if( computedNormal ) {
				this.checkOrientation_();
			}

			/* Compute ST bounds. */
			first = true;
			for( v = vHead.next; v !== vHead; v = v.next ) {
				if (first) {
					this.bmin[0] = this.bmax[0] = v.s;
					this.bmin[1] = this.bmax[1] = v.t;
					first = false;
				} else {
					if (v.s < this.bmin[0]) this.bmin[0] = v.s;
					if (v.s > this.bmax[0]) this.bmax[0] = v.s;
					if (v.t < this.bmin[1]) this.bmin[1] = v.t;
					if (v.t > this.bmax[1]) this.bmax[1] = v.t;
				}
			}
		},

		addWinding_: function(eDst,eSrc) {
			eDst.winding += eSrc.winding;
			eDst.Sym.winding += eSrc.Sym.winding;
		},
		
		/* tessMeshTessellateMonoRegion( face ) tessellates a monotone region
		* (what else would it do??)  The region must consist of a single
		* loop of half-edges (see mesh.h) oriented CCW.  "Monotone" in this
		* case means that any vertical line intersects the interior of the
		* region in a single interval.  
		*
		* Tessellation consists of adding interior edges (actually pairs of
		* half-edges), to split the region into non-overlapping triangles.
		*
		* The basic idea is explained in Preparata and Shamos (which I don''t
		* have handy right now), although their implementation is more
		* complicated than this one.  The are two edge chains, an upper chain
		* and a lower chain.  We process all vertices from both chains in order,
		* from right to left.
		*
		* The algorithm ensures that the following invariant holds after each
		* vertex is processed: the untessellated region consists of two
		* chains, where one chain (say the upper) is a single edge, and
		* the other chain is concave.  The left vertex of the single edge
		* is always to the left of all vertices in the concave chain.
		*
		* Each step consists of adding the rightmost unprocessed vertex to one
		* of the two chains, and forming a fan of triangles from the rightmost
		* of two chain endpoints.  Determining whether we can add each triangle
		* to the fan is a simple orientation test.  By making the fan as large
		* as possible, we restore the invariant (check it yourself).
		*/
	//	int tessMeshTessellateMonoRegion( TESSmesh *mesh, TESSface *face )
		tessellateMonoRegion_: function( mesh, face ) {
			var up, lo;

			/* All edges are oriented CCW around the boundary of the region.
			* First, find the half-edge whose origin vertex is rightmost.
			* Since the sweep goes from left to right, face->anEdge should
			* be close to the edge we want.
			*/
			up = face.anEdge;
			assert( up.Lnext !== up && up.Lnext.Lnext !== up );

			for( ; Geom.vertLeq( up.Dst, up.Org ); up = up.Lprev )
				;
			for( ; Geom.vertLeq( up.Org, up.Dst ); up = up.Lnext )
				;
			lo = up.Lprev;

			while( up.Lnext !== lo ) {
				if( Geom.vertLeq( up.Dst, lo.Org )) {
					/* up->Dst is on the left.  It is safe to form triangles from lo->Org.
					* The EdgeGoesLeft test guarantees progress even when some triangles
					* are CW, given that the upper and lower chains are truly monotone.
					*/
					while( lo.Lnext !== up && (Geom.edgeGoesLeft( lo.Lnext )
						|| Geom.edgeSign( lo.Org, lo.Dst, lo.Lnext.Dst ) <= 0.0 )) {
							var tempHalfEdge = mesh.connect( lo.Lnext, lo );
							//if (tempHalfEdge == NULL) return 0;
							lo = tempHalfEdge.Sym;
					}
					lo = lo.Lprev;
				} else {
					/* lo->Org is on the left.  We can make CCW triangles from up->Dst. */
					while( lo.Lnext != up && (Geom.edgeGoesRight( up.Lprev )
						|| Geom.edgeSign( up.Dst, up.Org, up.Lprev.Org ) >= 0.0 )) {
							var tempHalfEdge = mesh.connect( up, up.Lprev );
							//if (tempHalfEdge == NULL) return 0;
							up = tempHalfEdge.Sym;
					}
					up = up.Lnext;
				}
			}

			/* Now lo->Org == up->Dst == the leftmost vertex.  The remaining region
			* can be tessellated in a fan from this leftmost vertex.
			*/
			assert( lo.Lnext !== up );
			while( lo.Lnext.Lnext !== up ) {
				var tempHalfEdge = mesh.connect( lo.Lnext, lo );
				//if (tempHalfEdge == NULL) return 0;
				lo = tempHalfEdge.Sym;
			}

			return true;
		},


		/* tessMeshTessellateInterior( mesh ) tessellates each region of
		* the mesh which is marked "inside" the polygon.  Each such region
		* must be monotone.
		*/
		//int tessMeshTessellateInterior( TESSmesh *mesh )
		tessellateInterior_: function( mesh ) {
			var f, next;

			/*LINTED*/
			for( f = mesh.fHead.next; f !== mesh.fHead; f = next ) {
				/* Make sure we don''t try to tessellate the new triangles. */
				next = f.next;
				if( f.inside ) {
					if ( !this.tessellateMonoRegion_( mesh, f ) ) return false;
				}
			}

			return true;
		},


		/* tessMeshDiscardExterior( mesh ) zaps (ie. sets to NULL) all faces
		* which are not marked "inside" the polygon.  Since further mesh operations
		* on NULL faces are not allowed, the main purpose is to clean up the
		* mesh so that exterior loops are not represented in the data structure.
		*/
		//void tessMeshDiscardExterior( TESSmesh *mesh )
		discardExterior_: function( mesh ) {
			var f, next;

			/*LINTED*/
			for( f = mesh.fHead.next; f !== mesh.fHead; f = next ) {
				/* Since f will be destroyed, save its next pointer. */
				next = f.next;
				if( ! f.inside ) {
					mesh.zapFace( f );
				}
			}
		},

		/* tessMeshSetWindingNumber( mesh, value, keepOnlyBoundary ) resets the
		* winding numbers on all edges so that regions marked "inside" the
		* polygon have a winding number of "value", and regions outside
		* have a winding number of 0.
		*
		* If keepOnlyBoundary is TRUE, it also deletes all edges which do not
		* separate an interior region from an exterior one.
		*/
	//	int tessMeshSetWindingNumber( TESSmesh *mesh, int value, int keepOnlyBoundary )
		setWindingNumber_: function( mesh, value, keepOnlyBoundary ) {
			var e, eNext;

			for( e = mesh.eHead.next; e !== mesh.eHead; e = eNext ) {
				eNext = e.next;
				if( e.Rface.inside !== e.Lface.inside ) {

					/* This is a boundary edge (one side is interior, one is exterior). */
					e.winding = (e.Lface.inside) ? value : -value;
				} else {

					/* Both regions are interior, or both are exterior. */
					if( ! keepOnlyBoundary ) {
						e.winding = 0;
					} else {
						mesh.delete( e );
					}
				}
			}
		},

		getNeighbourFace_: function(edge)
		{
			if (!edge.Rface)
				return -1;
			if (!edge.Rface.inside)
				return -1;
			return edge.Rface.n;
		},

		outputPolymesh_: function( mesh, elementType, polySize, vertexSize ) {
			var v;
			var f;
			var edge;
			var maxFaceCount = 0;
			var maxVertexCount = 0;
			var faceVerts, i;
			var elements = 0;
			var vert;

			// Assume that the input data is triangles now.
			// Try to merge as many polygons as possible
			if (polySize > 3)
			{
				mesh.mergeConvexFaces( polySize );
			}

			// Mark unused
			for ( v = mesh.vHead.next; v !== mesh.vHead; v = v.next )
				v.n = -1;

			// Create unique IDs for all vertices and faces.
			for ( f = mesh.fHead.next; f != mesh.fHead; f = f.next )
			{
				f.n = -1;
				if( !f.inside ) continue;

				edge = f.anEdge;
				faceVerts = 0;
				do
				{
					v = edge.Org;
					if ( v.n === -1 )
					{
						v.n = maxVertexCount;
						maxVertexCount++;
					}
					faceVerts++;
					edge = edge.Lnext;
				}
				while (edge !== f.anEdge);
				
				assert( faceVerts <= polySize );

				f.n = maxFaceCount;
				++maxFaceCount;
			}

			this.elementCount = maxFaceCount;
			if (elementType == Tess2.CONNECTED_POLYGONS)
				maxFaceCount *= 2;
	/*		tess.elements = (TESSindex*)tess->alloc.memalloc( tess->alloc.userData,
															  sizeof(TESSindex) * maxFaceCount * polySize );
			if (!tess->elements)
			{
				tess->outOfMemory = 1;
				return;
			}*/
			this.elements = [];
			this.elements.length = maxFaceCount * polySize;
			
			this.vertexCount = maxVertexCount;
	/*		tess->vertices = (TESSreal*)tess->alloc.memalloc( tess->alloc.userData,
															 sizeof(TESSreal) * tess->vertexCount * vertexSize );
			if (!tess->vertices)
			{
				tess->outOfMemory = 1;
				return;
			}*/
			this.vertices = [];
			this.vertices.length = maxVertexCount * vertexSize;

	/*		tess->vertexIndices = (TESSindex*)tess->alloc.memalloc( tess->alloc.userData,
																    sizeof(TESSindex) * tess->vertexCount );
			if (!tess->vertexIndices)
			{
				tess->outOfMemory = 1;
				return;
			}*/
			this.vertexIndices = [];
			this.vertexIndices.length = maxVertexCount;

			
			// Output vertices.
			for ( v = mesh.vHead.next; v !== mesh.vHead; v = v.next )
			{
				if ( v.n != -1 )
				{
					// Store coordinate
					var idx = v.n * vertexSize;
					this.vertices[idx+0] = v.coords[0];
					this.vertices[idx+1] = v.coords[1];
					if ( vertexSize > 2 )
						this.vertices[idx+2] = v.coords[2];
					// Store vertex index.
					this.vertexIndices[v.n] = v.idx;
				}
			}

			// Output indices.
			var nel = 0;
			for ( f = mesh.fHead.next; f !== mesh.fHead; f = f.next )
			{
				if ( !f.inside ) continue;
				
				// Store polygon
				edge = f.anEdge;
				faceVerts = 0;
				do
				{
					v = edge.Org;
					this.elements[nel++] = v.n;
					faceVerts++;
					edge = edge.Lnext;
				}
				while (edge !== f.anEdge);
				// Fill unused.
				for (i = faceVerts; i < polySize; ++i)
					this.elements[nel++] = -1;

				// Store polygon connectivity
				if ( elementType == Tess2.CONNECTED_POLYGONS )
				{
					edge = f.anEdge;
					do
					{
						this.elements[nel++] = this.getNeighbourFace_( edge );
						edge = edge.Lnext;
					}
					while (edge !== f.anEdge);
					// Fill unused.
					for (i = faceVerts; i < polySize; ++i)
						this.elements[nel++] = -1;
				}
			}
		},

	//	void OutputContours( TESStesselator *tess, TESSmesh *mesh, int vertexSize )
		outputContours_: function( mesh, vertexSize ) {
			var f;
			var edge;
			var start;
			var verts;
			var elements;
			var vertInds;
			var startVert = 0;
			var vertCount = 0;

			this.vertexCount = 0;
			this.elementCount = 0;

			for ( f = mesh.fHead.next; f !== mesh.fHead; f = f.next )
			{
				if ( !f.inside ) continue;

				start = edge = f.anEdge;
				do
				{
					this.vertexCount++;
					edge = edge.Lnext;
				}
				while ( edge !== start );

				this.elementCount++;
			}

	/*		tess->elements = (TESSindex*)tess->alloc.memalloc( tess->alloc.userData,
															  sizeof(TESSindex) * tess->elementCount * 2 );
			if (!tess->elements)
			{
				tess->outOfMemory = 1;
				return;
			}*/
			this.elements = [];
			this.elements.length = this.elementCount * 2;
			
	/*		tess->vertices = (TESSreal*)tess->alloc.memalloc( tess->alloc.userData,
															  sizeof(TESSreal) * tess->vertexCount * vertexSize );
			if (!tess->vertices)
			{
				tess->outOfMemory = 1;
				return;
			}*/
			this.vertices = [];
			this.vertices.length = this.vertexCount * vertexSize;

	/*		tess->vertexIndices = (TESSindex*)tess->alloc.memalloc( tess->alloc.userData,
																    sizeof(TESSindex) * tess->vertexCount );
			if (!tess->vertexIndices)
			{
				tess->outOfMemory = 1;
				return;
			}*/
			this.vertexIndices = [];
			this.vertexIndices.length = this.vertexCount;

			var nv = 0;
			var nvi = 0;
			var nel = 0;
			startVert = 0;

			for ( f = mesh.fHead.next; f !== mesh.fHead; f = f.next )
			{
				if ( !f.inside ) continue;

				vertCount = 0;
				start = edge = f.anEdge;
				do
				{
					this.vertices[nv++] = edge.Org.coords[0];
					this.vertices[nv++] = edge.Org.coords[1];
					if ( vertexSize > 2 )
						this.vertices[nv++] = edge.Org.coords[2];
					this.vertexIndices[nvi++] = edge.Org.idx;
					vertCount++;
					edge = edge.Lnext;
				}
				while ( edge !== start );

				this.elements[nel++] = startVert;
				this.elements[nel++] = vertCount;

				startVert += vertCount;
			}
		},

		addContour: function( size, vertices )
		{
			var e;
			var i;

			if ( this.mesh === null )
			  	this.mesh = new TESSmesh();
	/*	 	if ( tess->mesh == NULL ) {
				tess->outOfMemory = 1;
				return;
			}*/

			if ( size < 2 )
				size = 2;
			if ( size > 3 )
				size = 3;

			e = null;

			for( i = 0; i < vertices.length; i += size )
			{
				if( e == null ) {
					/* Make a self-loop (one vertex, one edge). */
					e = this.mesh.makeEdge();
	/*				if ( e == NULL ) {
						tess->outOfMemory = 1;
						return;
					}*/
					this.mesh.splice( e, e.Sym );
				} else {
					/* Create a new vertex and edge which immediately follow e
					* in the ordering around the left face.
					*/
					this.mesh.splitEdge( e );
					e = e.Lnext;
				}

				/* The new vertex is now e->Org. */
				e.Org.coords[0] = vertices[i+0];
				e.Org.coords[1] = vertices[i+1];
				if ( size > 2 )
					e.Org.coords[2] = vertices[i+2];
				else
					e.Org.coords[2] = 0.0;
				/* Store the insertion number so that the vertex can be later recognized. */
				e.Org.idx = this.vertexIndexCounter++;

				/* The winding of an edge says how the winding number changes as we
				* cross from the edge''s right face to its left face.  We add the
				* vertices in such an order that a CCW contour will add +1 to
				* the winding number of the region inside the contour.
				*/
				e.winding = 1;
				e.Sym.winding = -1;
			}
		},

	//	int tessTesselate( TESStesselator *tess, int windingRule, int elementType, int polySize, int vertexSize, const TESSreal* normal )
		tesselate: function( windingRule, elementType, polySize, vertexSize, normal ) {
			this.vertices = [];
			this.elements = [];
			this.vertexIndices = [];

			this.vertexIndexCounter = 0;
			
			if (normal)
			{
				this.normal[0] = normal[0];
				this.normal[1] = normal[1];
				this.normal[2] = normal[2];
			}

			this.windingRule = windingRule;

			if (vertexSize < 2)
				vertexSize = 2;
			if (vertexSize > 3)
				vertexSize = 3;

	/*		if (setjmp(tess->env) != 0) { 
				// come back here if out of memory
				return 0;
			}*/

			if (!this.mesh)
			{
				return false;
			}

			/* Determine the polygon normal and project vertices onto the plane
			* of the polygon.
			*/
			this.projectPolygon_();

			/* tessComputeInterior( tess ) computes the planar arrangement specified
			* by the given contours, and further subdivides this arrangement
			* into regions.  Each region is marked "inside" if it belongs
			* to the polygon, according to the rule given by tess->windingRule.
			* Each interior region is guaranteed be monotone.
			*/
			Sweep.computeInterior( this );

			var mesh = this.mesh;

			/* If the user wants only the boundary contours, we throw away all edges
			* except those which separate the interior from the exterior.
			* Otherwise we tessellate all the regions marked "inside".
			*/
			if (elementType == Tess2.BOUNDARY_CONTOURS) {
				this.setWindingNumber_( mesh, 1, true );
			} else {
				this.tessellateInterior_( mesh ); 
			}
	//		if (rc == 0) longjmp(tess->env,1);  /* could've used a label */

			mesh.check();

			if (elementType == Tess2.BOUNDARY_CONTOURS) {
				this.outputContours_( mesh, vertexSize );     /* output contours */
			}
			else
			{
				this.outputPolymesh_( mesh, elementType, polySize, vertexSize );     /* output polygons */
			}

//			tess.mesh = null;

			return true;
		}
	};
},{}],"/projects/blackice/node_modules/unlerp/index.js":[function(require,module,exports){
module.exports = function range(min, max, value) {
  return (value - min) / (max - min)
}
},{}],"/projects/blackice/node_modules/xtend/immutable.js":[function(require,module,exports){
module.exports=require("/projects/blackice/node_modules/three-sdf-text/node_modules/xtend/immutable.js")
},{"/projects/blackice/node_modules/three-sdf-text/node_modules/xtend/immutable.js":"/projects/blackice/node_modules/three-sdf-text/node_modules/xtend/immutable.js"}]},{},["./test.js"])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJ0ZXN0LmpzIiwiZm9udHMvRXhvMlNlbWlCb2xkLmpzb24iLCJpbmRleC5qcyIsImxpYi9SaWdTY2VuZS5qcyIsImxpYi9UZXh0UGFzcy5qcyIsImxpYi9hbmltYXRlLWxhYmVscy5qcyIsImxpYi9jcmVhdGUtZm9udC5qcyIsImxpYi9jcmVhdGUtdGV4dC1wYXNzLmpzIiwibGliL2dldC1wb2x5Z29uLmpzIiwibGliL2dldC1zdmcuanMiLCJsaWIvcmVuZGVyZXIuanMiLCJsaWIvc2V0dXAtZWZmZWN0cy5qcyIsImxpYi9zZXR1cC13YXRlci5qcyIsImxpYi9zaGFkZXJzL2JsdXIuanMiLCJsaWIvc2hhZGVycy9jcmVhdGUuanMiLCJsaWIvc2hhZGVycy9sZW5zLmpzIiwibGliL3NoYWRlcnMvcGFzcy5qcyIsImxpYi90ZXh0LWRhdGEuanMiLCJsaWIvdGhyZWUtb3JiaXQtY2FtZXJhL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2FzLW51bWJlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnVmZmVyL25vZGVfbW9kdWxlcy9iYXNlNjQtanMvbGliL2I2NC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9idWZmZXIvbm9kZV9tb2R1bGVzL2llZWU3NTQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnVmZmVyL25vZGVfbW9kdWxlcy9pcy1hcnJheS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jYW52YXMtYXBwL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NhbnZhcy1hcHAvbm9kZV9tb2R1bGVzL2FkZC1ldmVudC1saXN0ZW5lci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jYW52YXMtYXBwL25vZGVfbW9kdWxlcy9kZWJvdW5jZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jYW52YXMtYXBwL25vZGVfbW9kdWxlcy9kZWJvdW5jZS9ub2RlX21vZHVsZXMvZGF0ZS1ub3cvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY2FudmFzLWFwcC9ub2RlX21vZHVsZXMvaXMtd2ViZ2wtY29udGV4dC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jYW52YXMtYXBwL25vZGVfbW9kdWxlcy93ZWJnbC1jb250ZXh0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NsYW1wL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2RvbXJlYWR5L3JlYWR5LmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdDQvaWRlbnRpdHkuanMiLCJub2RlX21vZHVsZXMvZ2wtbWF0NC9tdWx0aXBseS5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXQ0L3NjYWxlLmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdDQvdHJhbnNsYXRlLmpzIiwibm9kZV9tb2R1bGVzL2dsLXRleHR1cmUyZC9ub2RlX21vZHVsZXMvbmRhcnJheS1vcHMvbmRhcnJheS1vcHMuanMiLCJub2RlX21vZHVsZXMvZ2wtdGV4dHVyZTJkL25vZGVfbW9kdWxlcy9uZGFycmF5LW9wcy9ub2RlX21vZHVsZXMvY3dpc2UtY29tcGlsZXIvY29tcGlsZXIuanMiLCJub2RlX21vZHVsZXMvZ2wtdGV4dHVyZTJkL25vZGVfbW9kdWxlcy9uZGFycmF5LW9wcy9ub2RlX21vZHVsZXMvY3dpc2UtY29tcGlsZXIvbGliL2NvbXBpbGUuanMiLCJub2RlX21vZHVsZXMvZ2wtdGV4dHVyZTJkL25vZGVfbW9kdWxlcy9uZGFycmF5LW9wcy9ub2RlX21vZHVsZXMvY3dpc2UtY29tcGlsZXIvbGliL3RodW5rLmpzIiwibm9kZV9tb2R1bGVzL2dsLXRleHR1cmUyZC9ub2RlX21vZHVsZXMvbmRhcnJheS1vcHMvbm9kZV9tb2R1bGVzL2N3aXNlLWNvbXBpbGVyL25vZGVfbW9kdWxlcy91bmlxL3VuaXEuanMiLCJub2RlX21vZHVsZXMvZ2wtdGV4dHVyZTJkL25vZGVfbW9kdWxlcy9uZGFycmF5L25kYXJyYXkuanMiLCJub2RlX21vZHVsZXMvZ2wtdGV4dHVyZTJkL25vZGVfbW9kdWxlcy9uZGFycmF5L25vZGVfbW9kdWxlcy9pb3RhLWFycmF5L2lvdGEuanMiLCJub2RlX21vZHVsZXMvZ2wtdGV4dHVyZTJkL25vZGVfbW9kdWxlcy90eXBlZGFycmF5LXBvb2wvbm9kZV9tb2R1bGVzL2JpdC10d2lkZGxlL3R3aWRkbGUuanMiLCJub2RlX21vZHVsZXMvZ2wtdGV4dHVyZTJkL25vZGVfbW9kdWxlcy90eXBlZGFycmF5LXBvb2wvbm9kZV9tb2R1bGVzL2R1cC9kdXAuanMiLCJub2RlX21vZHVsZXMvZ2wtdGV4dHVyZTJkL25vZGVfbW9kdWxlcy90eXBlZGFycmF5LXBvb2wvcG9vbC5qcyIsIm5vZGVfbW9kdWxlcy9nbC10ZXh0dXJlMmQvbm9kZV9tb2R1bGVzL3dlYmdsZXcvbm9kZV9tb2R1bGVzL3dlYWttYXAvd2Vha21hcC5qcyIsIm5vZGVfbW9kdWxlcy9nbC10ZXh0dXJlMmQvbm9kZV9tb2R1bGVzL3dlYmdsZXcvd2ViZ2xldy5qcyIsIm5vZGVfbW9kdWxlcy9nbC10ZXh0dXJlMmQvdGV4dHVyZS5qcyIsIm5vZGVfbW9kdWxlcy9nbC12ZWMzL3NldC5qcyIsIm5vZGVfbW9kdWxlcy9nbHNsaWZ5L2FkYXB0ZXIuanMiLCJub2RlX21vZHVsZXMvZ2xzbGlmeS9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2dsc2xpZnkvbm9kZV9tb2R1bGVzL2dsLXNoYWRlci1jb3JlL2xpYi9jcmVhdGUtYXR0cmlidXRlcy5qcyIsIm5vZGVfbW9kdWxlcy9nbHNsaWZ5L25vZGVfbW9kdWxlcy9nbC1zaGFkZXItY29yZS9saWIvY3JlYXRlLXVuaWZvcm1zLmpzIiwibm9kZV9tb2R1bGVzL2dsc2xpZnkvbm9kZV9tb2R1bGVzL2dsLXNoYWRlci1jb3JlL2xpYi9yZWZsZWN0LmpzIiwibm9kZV9tb2R1bGVzL2dsc2xpZnkvbm9kZV9tb2R1bGVzL2dsLXNoYWRlci1jb3JlL25vZGVfbW9kdWxlcy9kdXAvZHVwLmpzIiwibm9kZV9tb2R1bGVzL2dsc2xpZnkvbm9kZV9tb2R1bGVzL2dsLXNoYWRlci1jb3JlL3NoYWRlci1jb3JlLmpzIiwibm9kZV9tb2R1bGVzL2dsc2xpZnkvc2ltcGxlLWFkYXB0ZXIuanMiLCJub2RlX21vZHVsZXMvaW1nL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2luaGVyaXRzL2luaGVyaXRzX2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvbGVycC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9taXhlcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9ub3JtYWxpemUtcGF0aC1zY2FsZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9ub3JtYWxpemUtcGF0aC1zY2FsZS9ub2RlX21vZHVsZXMvZ2V0Ym91bmRpbmdib3gvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcGFyc2Utc3ZnLXBhdGgvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcGx1Y2tlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9yYWYuanMvcmFmLmpzIiwibm9kZV9tb2R1bGVzL3NpbXBsaWZ5LXBhdGgvZG91Z2xhcy1wZXVja2VyLmpzIiwibm9kZV9tb2R1bGVzL3NpbXBsaWZ5LXBhdGgvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc2ltcGxpZnktcGF0aC9yYWRpYWwtZGlzdGFuY2UuanMiLCJub2RlX21vZHVsZXMvc21vb3Roc3RlcC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zdmctcGF0aC1jb250b3Vycy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zdmctcGF0aC1jb250b3Vycy9ub2RlX21vZHVsZXMvYWJzLXN2Zy1wYXRoL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3N2Zy1wYXRoLWNvbnRvdXJzL25vZGVfbW9kdWxlcy9hZGFwdGl2ZS1iZXppZXItY3VydmUvZnVuY3Rpb24uanMiLCJub2RlX21vZHVsZXMvc3ZnLXBhdGgtY29udG91cnMvbm9kZV9tb2R1bGVzL2FkYXB0aXZlLWJlemllci1jdXJ2ZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zdmctcGF0aC1jb250b3Vycy9ub2RlX21vZHVsZXMvbm9ybWFsaXplLXN2Zy1wYXRoL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3N2Zy1wYXRoLWNvbnRvdXJzL25vZGVfbW9kdWxlcy92ZWMyLWNvcHkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdGhyZWUtZWZmZWN0Y29tcG9zZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdGhyZWUtZWZmZWN0Y29tcG9zZXIvbGliL2NsZWFybWFza3Bhc3MuanMiLCJub2RlX21vZHVsZXMvdGhyZWUtZWZmZWN0Y29tcG9zZXIvbGliL21hc2twYXNzLmpzIiwibm9kZV9tb2R1bGVzL3RocmVlLWVmZmVjdGNvbXBvc2VyL2xpYi9yZW5kZXJwYXNzLmpzIiwibm9kZV9tb2R1bGVzL3RocmVlLWVmZmVjdGNvbXBvc2VyL2xpYi9zaGFkZXJwYXNzLmpzIiwibm9kZV9tb2R1bGVzL3RocmVlLWVmZmVjdGNvbXBvc2VyL25vZGVfbW9kdWxlcy90aHJlZS1jb3B5c2hhZGVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3RocmVlLWdsc2xpZnkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdGhyZWUtZ2xzbGlmeS90eXBlcy5qcyIsIm5vZGVfbW9kdWxlcy90aHJlZS1zZGYtdGV4dC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy90aHJlZS1zZGYtdGV4dC9saWIvcmVuZGVyZXIuanMiLCJub2RlX21vZHVsZXMvdGhyZWUtc2RmLXRleHQvbGliL3RleHR1cmUtd3JhcC5qcyIsIm5vZGVfbW9kdWxlcy90aHJlZS1zZGYtdGV4dC9ub2RlX21vZHVsZXMvYXMtbnVtYmVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3RocmVlLXNkZi10ZXh0L25vZGVfbW9kdWxlcy9nbC1tYXQ0L2NyZWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy90aHJlZS1zZGYtdGV4dC9ub2RlX21vZHVsZXMvZ2wtbWF0NC9tdWx0aXBseS5qcyIsIm5vZGVfbW9kdWxlcy90aHJlZS1zZGYtdGV4dC9ub2RlX21vZHVsZXMvZ2wtbWF0NC9zY2FsZS5qcyIsIm5vZGVfbW9kdWxlcy90aHJlZS1zZGYtdGV4dC9ub2RlX21vZHVsZXMvZ2wtc2hhZGVyLWNvcmUvc2hhZGVyLWNvcmUuanMiLCJub2RlX21vZHVsZXMvdGhyZWUtc2RmLXRleHQvbm9kZV9tb2R1bGVzL2dsLXNwcml0ZS10ZXh0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3RocmVlLXNkZi10ZXh0L25vZGVfbW9kdWxlcy9nbC1zcHJpdGUtdGV4dC9ub2RlX21vZHVsZXMvZm9udHBhdGgtYm1mb250L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3RocmVlLXNkZi10ZXh0L25vZGVfbW9kdWxlcy9nbC1zcHJpdGUtdGV4dC9ub2RlX21vZHVsZXMvZm9udHBhdGgtc2ltcGxlLXJlbmRlcmVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3RocmVlLXNkZi10ZXh0L25vZGVfbW9kdWxlcy9nbC1zcHJpdGUtdGV4dC9ub2RlX21vZHVsZXMvZm9udHBhdGgtc2ltcGxlLXJlbmRlcmVyL25vZGVfbW9kdWxlcy9mb250cGF0aC1yZW5kZXJlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy90aHJlZS1zZGYtdGV4dC9ub2RlX21vZHVsZXMvZ2wtc3ByaXRlLXRleHQvbm9kZV9tb2R1bGVzL2ZvbnRwYXRoLXNpbXBsZS1yZW5kZXJlci9ub2RlX21vZHVsZXMvZm9udHBhdGgtcmVuZGVyZXIvbm9kZV9tb2R1bGVzL2ZvbnRwYXRoLWdseXBoLWl0ZXJhdG9yL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3RocmVlLXNkZi10ZXh0L25vZGVfbW9kdWxlcy9nbC1zcHJpdGUtdGV4dC9ub2RlX21vZHVsZXMvZm9udHBhdGgtc2ltcGxlLXJlbmRlcmVyL25vZGVfbW9kdWxlcy9mb250cGF0aC1yZW5kZXJlci9ub2RlX21vZHVsZXMvZm9udHBhdGgtdXRpbC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy90aHJlZS1zZGYtdGV4dC9ub2RlX21vZHVsZXMvZ2wtc3ByaXRlLXRleHQvbm9kZV9tb2R1bGVzL2ZvbnRwYXRoLXNpbXBsZS1yZW5kZXJlci9ub2RlX21vZHVsZXMvZm9udHBhdGgtcmVuZGVyZXIvbm9kZV9tb2R1bGVzL2ZvbnRwYXRoLXdvcmR3cmFwL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3RocmVlLXNkZi10ZXh0L25vZGVfbW9kdWxlcy9nbC1zcHJpdGUtdGV4dC9ub2RlX21vZHVsZXMvZ2wtc3ByaXRlLWJhdGNoL2NvbW1vbi5qcyIsIm5vZGVfbW9kdWxlcy90aHJlZS1zZGYtdGV4dC9ub2RlX21vZHVsZXMvZ2wtc3ByaXRlLXRleHQvbm9kZV9tb2R1bGVzL2dsLXNwcml0ZS1iYXRjaC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy90aHJlZS1zZGYtdGV4dC9ub2RlX21vZHVsZXMvZ2wtc3ByaXRlLXRleHQvbm9kZV9tb2R1bGVzL2dsLXNwcml0ZS1iYXRjaC9ub2RlX21vZHVsZXMvZ2wtYWxpYXNlZC12YW8vaW5kZXguanMiLCJub2RlX21vZHVsZXMvdGhyZWUtc2RmLXRleHQvbm9kZV9tb2R1bGVzL2dsLXNwcml0ZS10ZXh0L25vZGVfbW9kdWxlcy9nbC1zcHJpdGUtYmF0Y2gvbm9kZV9tb2R1bGVzL2dsLWFsaWFzZWQtdmFvL2xpYi9kby1iaW5kLmpzIiwibm9kZV9tb2R1bGVzL3RocmVlLXNkZi10ZXh0L25vZGVfbW9kdWxlcy9nbC1zcHJpdGUtdGV4dC9ub2RlX21vZHVsZXMvZ2wtc3ByaXRlLWJhdGNoL25vZGVfbW9kdWxlcy9nbC1hbGlhc2VkLXZhby9saWIvdmFvLWVtdWxhdGVkLmpzIiwibm9kZV9tb2R1bGVzL3RocmVlLXNkZi10ZXh0L25vZGVfbW9kdWxlcy9nbC1zcHJpdGUtdGV4dC9ub2RlX21vZHVsZXMvZ2wtc3ByaXRlLWJhdGNoL25vZGVfbW9kdWxlcy9nbC1idWZmZXIvYnVmZmVyLmpzIiwibm9kZV9tb2R1bGVzL3RocmVlLXNkZi10ZXh0L25vZGVfbW9kdWxlcy9nbC1zcHJpdGUtdGV4dC9ub2RlX21vZHVsZXMvZ2wtc3ByaXRlLWJhdGNoL25vZGVfbW9kdWxlcy9nbC1idWZmZXIvbm9kZV9tb2R1bGVzL25kYXJyYXktb3BzL25kYXJyYXktb3BzLmpzIiwibm9kZV9tb2R1bGVzL3RocmVlLXNkZi10ZXh0L25vZGVfbW9kdWxlcy9nbC1zcHJpdGUtdGV4dC9ub2RlX21vZHVsZXMvZ2wtc3ByaXRlLWJhdGNoL25vZGVfbW9kdWxlcy9nbC1idWZmZXIvbm9kZV9tb2R1bGVzL25kYXJyYXkvbmRhcnJheS5qcyIsIm5vZGVfbW9kdWxlcy90aHJlZS1zZGYtdGV4dC9ub2RlX21vZHVsZXMvZ2wtc3ByaXRlLXRleHQvbm9kZV9tb2R1bGVzL2dsLXNwcml0ZS1iYXRjaC9ub2RlX21vZHVsZXMvZ2wtYnVmZmVyL25vZGVfbW9kdWxlcy9uZGFycmF5L25vZGVfbW9kdWxlcy9pb3RhLWFycmF5L2lvdGEuanMiLCJub2RlX21vZHVsZXMvdGhyZWUtc2RmLXRleHQvbm9kZV9tb2R1bGVzL2dsLXNwcml0ZS10ZXh0L25vZGVfbW9kdWxlcy9nbC1zcHJpdGUtYmF0Y2gvbm9kZV9tb2R1bGVzL2dsLWJ1ZmZlci9ub2RlX21vZHVsZXMvdHlwZWRhcnJheS1wb29sL3Bvb2wuanMiLCJub2RlX21vZHVsZXMvdGhyZWUtc2RmLXRleHQvbm9kZV9tb2R1bGVzL2dsLXNwcml0ZS10ZXh0L25vZGVfbW9kdWxlcy9nbC1zcHJpdGUtYmF0Y2gvbm9kZV9tb2R1bGVzL2dsLWJ1ZmZlci9ub2RlX21vZHVsZXMvd2ViZ2xldy9ub2RlX21vZHVsZXMvd2Vhay1tYXAvd2Vhay1tYXAuanMiLCJub2RlX21vZHVsZXMvdGhyZWUtc2RmLXRleHQvbm9kZV9tb2R1bGVzL2dsLXNwcml0ZS10ZXh0L25vZGVfbW9kdWxlcy9nbC1zcHJpdGUtYmF0Y2gvbm9kZV9tb2R1bGVzL2dsLWJ1ZmZlci9ub2RlX21vZHVsZXMvd2ViZ2xldy93ZWJnbGV3LmpzIiwibm9kZV9tb2R1bGVzL3RocmVlLXNkZi10ZXh0L25vZGVfbW9kdWxlcy9nbC1zcHJpdGUtdGV4dC9ub2RlX21vZHVsZXMvZ2wtc3ByaXRlLWJhdGNoL25vZGVfbW9kdWxlcy9nbC13aGl0ZS10ZXh0dXJlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3RocmVlLXNkZi10ZXh0L25vZGVfbW9kdWxlcy9nbC1zcHJpdGUtdGV4dC9ub2RlX21vZHVsZXMvZ2wtc3ByaXRlLWJhdGNoL25vZGVfbW9kdWxlcy9nbC13aGl0ZS10ZXh0dXJlL25vZGVfbW9kdWxlcy9uZGFycmF5L25kYXJyYXkuanMiLCJub2RlX21vZHVsZXMvdGhyZWUtc2RmLXRleHQvbm9kZV9tb2R1bGVzL2dsLXNwcml0ZS10ZXh0L25vZGVfbW9kdWxlcy9nbC1zcHJpdGUtYmF0Y2gvbm9kZV9tb2R1bGVzL21peGVzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3RocmVlLXNkZi10ZXh0L25vZGVfbW9kdWxlcy9nbC1zcHJpdGUtdGV4dC9ub2RlX21vZHVsZXMvZ2wtc3ByaXRlLWJhdGNoL25vZGVfbW9kdWxlcy9udW1iZXItdXRpbC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy90aHJlZS1zZGYtdGV4dC9ub2RlX21vZHVsZXMvZ2wtc3ByaXRlLXRleHQvbm9kZV9tb2R1bGVzL2dsLXNwcml0ZS1iYXRjaC9ub2RlX21vZHVsZXMvcHJlbXVsdGlwbGllZC1yZ2JhL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3RocmVlLXNkZi10ZXh0L25vZGVfbW9kdWxlcy9nbC1zcHJpdGUtdGV4dC9ub2RlX21vZHVsZXMvZ2wtc3ByaXRlLWJhdGNoL3BhY2stcmdiYS1mbG9hdC5qcyIsIm5vZGVfbW9kdWxlcy90aHJlZS1zZGYtdGV4dC9ub2RlX21vZHVsZXMvZ2wtc3ByaXRlLXRleHQvbm9kZV9tb2R1bGVzL2luaGVyaXRzL2luaGVyaXRzX2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvdGhyZWUtc2RmLXRleHQvbm9kZV9tb2R1bGVzL2dsLXNwcml0ZS10ZXh0L25vZGVfbW9kdWxlcy90ZXhjb29yZC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy90aHJlZS1zZGYtdGV4dC9ub2RlX21vZHVsZXMvZ2wtdGV4dHVyZTJkL3RleHR1cmUuanMiLCJub2RlX21vZHVsZXMvdGhyZWUtc2RmLXRleHQvbm9kZV9tb2R1bGVzL3h0ZW5kL2ltbXV0YWJsZS5qcyIsIm5vZGVfbW9kdWxlcy90aHJlZS1zaGFkZXItZnhhYS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy90aHJlZS1zaW1wbGljaWFsLWNvbXBsZXgvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdHJpYW5ndWxhdGUtY29udG91cnMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdHJpYW5ndWxhdGUtY29udG91cnMvbm9kZV9tb2R1bGVzL3Rlc3MyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3RyaWFuZ3VsYXRlLWNvbnRvdXJzL25vZGVfbW9kdWxlcy90ZXNzMi9zcmMvdGVzczIuanMiLCJub2RlX21vZHVsZXMvdW5sZXJwL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3h0ZW5kL2ltbXV0YWJsZS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0hBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3cEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN2NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOVJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5WUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaFBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlpQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeERBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JNQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeE1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEhBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTs7QUNBQTs7QUNBQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6UkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFKQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFWQTs7QUNBQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTs7QUNBQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0REE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoMkdBO0FBQ0E7QUFDQTs7QUNGQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCJ2YXIgc2NlbmUzZCA9IHJlcXVpcmUoJy4vJylcblxucmVxdWlyZSgnZG9tcmVhZHknKShmdW5jdGlvbigpIHtcbiAgICBkb2N1bWVudC5ib2R5LnN0eWxlLm1hcmdpbiA9ICcwJ1xuICAgIGRvY3VtZW50LmJvZHkuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJ1xuXG4gICAgLy95b3VyIGNhbnZhcy4uLlxuICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKVxuICAgIGNhbnZhcy5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJ1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoY2FudmFzKVxuXG4gICAgdmFyIGFwcCA9IHNjZW5lM2QoeyBcbiAgICAgICAgY2FudmFzOiBjYW52YXNcbiAgICB9KVxuXG4gICAgYXBwLmxvYWQoZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgIGlmIChlcnIpXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycilcbiAgICAgICAgYXBwLnN0YXJ0KClcbiAgICB9KVxufSkiLCJtb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz17XCJwYWdlc1wiOltcIkV4bzJTZW1pQm9sZC5wbmdcIl0sXCJjaGFyc1wiOlt7XCJpZFwiOjMyLFwieFwiOjAsXCJ5XCI6MCxcIndpZHRoXCI6MCxcImhlaWdodFwiOjAsXCJ4b2Zmc2V0XCI6MCxcInlvZmZzZXRcIjozMyxcInhhZHZhbmNlXCI6NyxcInBhZ2VcIjowLFwiY2hubFwiOjB9LHtcImlkXCI6NDEsXCJ4XCI6MCxcInlcIjowLFwid2lkdGhcIjoyMCxcImhlaWdodFwiOjQxLFwieG9mZnNldFwiOi00LFwieW9mZnNldFwiOjMsXCJ4YWR2YW5jZVwiOjEyLFwicGFnZVwiOjAsXCJjaG5sXCI6MH0se1wiaWRcIjo0MCxcInhcIjoyMCxcInlcIjowLFwid2lkdGhcIjoxOSxcImhlaWdodFwiOjQxLFwieG9mZnNldFwiOi0zLFwieW9mZnNldFwiOjMsXCJ4YWR2YW5jZVwiOjEyLFwicGFnZVwiOjAsXCJjaG5sXCI6MH0se1wiaWRcIjoxMjQsXCJ4XCI6MzksXCJ5XCI6MCxcIndpZHRoXCI6MTMsXCJoZWlnaHRcIjo0MCxcInhvZmZzZXRcIjotMixcInlvZmZzZXRcIjozLFwieGFkdmFuY2VcIjo4LFwicGFnZVwiOjAsXCJjaG5sXCI6MH0se1wiaWRcIjoxMjUsXCJ4XCI6NTIsXCJ5XCI6MCxcIndpZHRoXCI6MTgsXCJoZWlnaHRcIjo0MCxcInhvZmZzZXRcIjotMyxcInlvZmZzZXRcIjo0LFwieGFkdmFuY2VcIjoxMSxcInBhZ2VcIjowLFwiY2hubFwiOjB9LHtcImlkXCI6MTIzLFwieFwiOjcwLFwieVwiOjAsXCJ3aWR0aFwiOjE4LFwiaGVpZ2h0XCI6NDAsXCJ4b2Zmc2V0XCI6LTMsXCJ5b2Zmc2V0XCI6NCxcInhhZHZhbmNlXCI6MTEsXCJwYWdlXCI6MCxcImNobmxcIjowfSx7XCJpZFwiOjM2LFwieFwiOjg4LFwieVwiOjAsXCJ3aWR0aFwiOjI1LFwiaGVpZ2h0XCI6MzksXCJ4b2Zmc2V0XCI6LTMsXCJ5b2Zmc2V0XCI6MyxcInhhZHZhbmNlXCI6MTgsXCJwYWdlXCI6MCxcImNobmxcIjowfSx7XCJpZFwiOjkzLFwieFwiOjExMyxcInlcIjowLFwid2lkdGhcIjoxNyxcImhlaWdodFwiOjM5LFwieG9mZnNldFwiOi0zLFwieW9mZnNldFwiOjQsXCJ4YWR2YW5jZVwiOjExLFwicGFnZVwiOjAsXCJjaG5sXCI6MH0se1wiaWRcIjo5MSxcInhcIjoxMzAsXCJ5XCI6MCxcIndpZHRoXCI6MTcsXCJoZWlnaHRcIjozOSxcInhvZmZzZXRcIjotMixcInlvZmZzZXRcIjo0LFwieGFkdmFuY2VcIjoxMSxcInBhZ2VcIjowLFwiY2hubFwiOjB9LHtcImlkXCI6ODEsXCJ4XCI6MTQ3LFwieVwiOjAsXCJ3aWR0aFwiOjI4LFwiaGVpZ2h0XCI6MzksXCJ4b2Zmc2V0XCI6LTMsXCJ5b2Zmc2V0XCI6NixcInhhZHZhbmNlXCI6MjIsXCJwYWdlXCI6MCxcImNobmxcIjowfSx7XCJpZFwiOjEwNixcInhcIjoxNzUsXCJ5XCI6MCxcIndpZHRoXCI6MTYsXCJoZWlnaHRcIjozOCxcInhvZmZzZXRcIjotNCxcInlvZmZzZXRcIjo2LFwieGFkdmFuY2VcIjo5LFwicGFnZVwiOjAsXCJjaG5sXCI6MH0se1wiaWRcIjo5MixcInhcIjoxOTEsXCJ5XCI6MCxcIndpZHRoXCI6MjYsXCJoZWlnaHRcIjozNCxcInhvZmZzZXRcIjotNCxcInlvZmZzZXRcIjo2LFwieGFkdmFuY2VcIjoxNyxcInBhZ2VcIjowLFwiY2hubFwiOjB9LHtcImlkXCI6NDcsXCJ4XCI6MjE3LFwieVwiOjAsXCJ3aWR0aFwiOjI2LFwiaGVpZ2h0XCI6MzQsXCJ4b2Zmc2V0XCI6LTQsXCJ5b2Zmc2V0XCI6NixcInhhZHZhbmNlXCI6MTcsXCJwYWdlXCI6MCxcImNobmxcIjowfSx7XCJpZFwiOjEwMixcInhcIjoyNDMsXCJ5XCI6MCxcIndpZHRoXCI6MjMsXCJoZWlnaHRcIjozMyxcInhvZmZzZXRcIjotNCxcInlvZmZzZXRcIjo1LFwieGFkdmFuY2VcIjoxMyxcInBhZ2VcIjowLFwiY2hubFwiOjB9LHtcImlkXCI6MzgsXCJ4XCI6MjY2LFwieVwiOjAsXCJ3aWR0aFwiOjMyLFwiaGVpZ2h0XCI6MzIsXCJ4b2Zmc2V0XCI6LTMsXCJ5b2Zmc2V0XCI6NixcInhhZHZhbmNlXCI6MjUsXCJwYWdlXCI6MCxcImNobmxcIjowfSx7XCJpZFwiOjM1LFwieFwiOjI5OCxcInlcIjowLFwid2lkdGhcIjozMCxcImhlaWdodFwiOjMyLFwieG9mZnNldFwiOi0zLFwieW9mZnNldFwiOjYsXCJ4YWR2YW5jZVwiOjIyLFwicGFnZVwiOjAsXCJjaG5sXCI6MH0se1wiaWRcIjozNyxcInhcIjozMjgsXCJ5XCI6MCxcIndpZHRoXCI6MzYsXCJoZWlnaHRcIjozMixcInhvZmZzZXRcIjotMyxcInlvZmZzZXRcIjo2LFwieGFkdmFuY2VcIjoyOSxcInBhZ2VcIjowLFwiY2hubFwiOjB9LHtcImlkXCI6NjMsXCJ4XCI6MzY0LFwieVwiOjAsXCJ3aWR0aFwiOjI0LFwiaGVpZ2h0XCI6MzIsXCJ4b2Zmc2V0XCI6LTMsXCJ5b2Zmc2V0XCI6NixcInhhZHZhbmNlXCI6MTYsXCJwYWdlXCI6MCxcImNobmxcIjowfSx7XCJpZFwiOjMzLFwieFwiOjM4OCxcInlcIjowLFwid2lkdGhcIjoxNCxcImhlaWdodFwiOjMyLFwieG9mZnNldFwiOi0yLFwieW9mZnNldFwiOjYsXCJ4YWR2YW5jZVwiOjksXCJwYWdlXCI6MCxcImNobmxcIjowfSx7XCJpZFwiOjQ4LFwieFwiOjQwMixcInlcIjowLFwid2lkdGhcIjoyNixcImhlaWdodFwiOjMyLFwieG9mZnNldFwiOi0zLFwieW9mZnNldFwiOjYsXCJ4YWR2YW5jZVwiOjIwLFwicGFnZVwiOjAsXCJjaG5sXCI6MH0se1wiaWRcIjo1NyxcInhcIjo0MjgsXCJ5XCI6MCxcIndpZHRoXCI6MjUsXCJoZWlnaHRcIjozMixcInhvZmZzZXRcIjotMyxcInlvZmZzZXRcIjo2LFwieGFkdmFuY2VcIjoxOSxcInBhZ2VcIjowLFwiY2hubFwiOjB9LHtcImlkXCI6NTYsXCJ4XCI6NDUzLFwieVwiOjAsXCJ3aWR0aFwiOjI2LFwiaGVpZ2h0XCI6MzIsXCJ4b2Zmc2V0XCI6LTMsXCJ5b2Zmc2V0XCI6NixcInhhZHZhbmNlXCI6MjAsXCJwYWdlXCI6MCxcImNobmxcIjowfSx7XCJpZFwiOjU1LFwieFwiOjQ3OSxcInlcIjowLFwid2lkdGhcIjoyNCxcImhlaWdodFwiOjMyLFwieG9mZnNldFwiOi0zLFwieW9mZnNldFwiOjYsXCJ4YWR2YW5jZVwiOjE3LFwicGFnZVwiOjAsXCJjaG5sXCI6MH0se1wiaWRcIjo1NCxcInhcIjowLFwieVwiOjQxLFwid2lkdGhcIjoyNixcImhlaWdodFwiOjMyLFwieG9mZnNldFwiOi0zLFwieW9mZnNldFwiOjYsXCJ4YWR2YW5jZVwiOjE5LFwicGFnZVwiOjAsXCJjaG5sXCI6MH0se1wiaWRcIjo1MyxcInhcIjoyNixcInlcIjo0MSxcIndpZHRoXCI6MjQsXCJoZWlnaHRcIjozMixcInhvZmZzZXRcIjotMyxcInlvZmZzZXRcIjo2LFwieGFkdmFuY2VcIjoxNyxcInBhZ2VcIjowLFwiY2hubFwiOjB9LHtcImlkXCI6NTIsXCJ4XCI6NTAsXCJ5XCI6NDEsXCJ3aWR0aFwiOjI3LFwiaGVpZ2h0XCI6MzIsXCJ4b2Zmc2V0XCI6LTMsXCJ5b2Zmc2V0XCI6NixcInhhZHZhbmNlXCI6MjAsXCJwYWdlXCI6MCxcImNobmxcIjowfSx7XCJpZFwiOjUxLFwieFwiOjc3LFwieVwiOjQxLFwid2lkdGhcIjoyNSxcImhlaWdodFwiOjMyLFwieG9mZnNldFwiOi0zLFwieW9mZnNldFwiOjYsXCJ4YWR2YW5jZVwiOjE4LFwicGFnZVwiOjAsXCJjaG5sXCI6MH0se1wiaWRcIjo1MCxcInhcIjoxMDIsXCJ5XCI6NDEsXCJ3aWR0aFwiOjI1LFwiaGVpZ2h0XCI6MzIsXCJ4b2Zmc2V0XCI6LTMsXCJ5b2Zmc2V0XCI6NixcInhhZHZhbmNlXCI6MTgsXCJwYWdlXCI6MCxcImNobmxcIjowfSx7XCJpZFwiOjQ5LFwieFwiOjEyNyxcInlcIjo0MSxcIndpZHRoXCI6MTksXCJoZWlnaHRcIjozMixcInhvZmZzZXRcIjotNCxcInlvZmZzZXRcIjo2LFwieGFkdmFuY2VcIjoxMyxcInBhZ2VcIjowLFwiY2hubFwiOjB9LHtcImlkXCI6MTIxLFwieFwiOjE0NixcInlcIjo0MSxcIndpZHRoXCI6MjcsXCJoZWlnaHRcIjozMixcInhvZmZzZXRcIjotNCxcInlvZmZzZXRcIjoxMixcInhhZHZhbmNlXCI6MTcsXCJwYWdlXCI6MCxcImNobmxcIjowfSx7XCJpZFwiOjExMyxcInhcIjoxNzMsXCJ5XCI6NDEsXCJ3aWR0aFwiOjI1LFwiaGVpZ2h0XCI6MzIsXCJ4b2Zmc2V0XCI6LTMsXCJ5b2Zmc2V0XCI6MTIsXCJ4YWR2YW5jZVwiOjE5LFwicGFnZVwiOjAsXCJjaG5sXCI6MH0se1wiaWRcIjoxMTIsXCJ4XCI6MTk4LFwieVwiOjQxLFwid2lkdGhcIjoyNSxcImhlaWdodFwiOjMyLFwieG9mZnNldFwiOi0yLFwieW9mZnNldFwiOjEyLFwieGFkdmFuY2VcIjoxOSxcInBhZ2VcIjowLFwiY2hubFwiOjB9LHtcImlkXCI6MTA4LFwieFwiOjIyMyxcInlcIjo0MSxcIndpZHRoXCI6MTcsXCJoZWlnaHRcIjozMixcInhvZmZzZXRcIjotMixcInlvZmZzZXRcIjo2LFwieGFkdmFuY2VcIjoxMCxcInBhZ2VcIjowLFwiY2hubFwiOjB9LHtcImlkXCI6MTA3LFwieFwiOjI0MCxcInlcIjo0MSxcIndpZHRoXCI6MjQsXCJoZWlnaHRcIjozMixcInhvZmZzZXRcIjotMixcInlvZmZzZXRcIjo2LFwieGFkdmFuY2VcIjoxNyxcInBhZ2VcIjowLFwiY2hubFwiOjB9LHtcImlkXCI6MTA1LFwieFwiOjI2NCxcInlcIjo0MSxcIndpZHRoXCI6MTQsXCJoZWlnaHRcIjozMixcInhvZmZzZXRcIjotMixcInlvZmZzZXRcIjo2LFwieGFkdmFuY2VcIjo4LFwicGFnZVwiOjAsXCJjaG5sXCI6MH0se1wiaWRcIjoxMDQsXCJ4XCI6Mjc4LFwieVwiOjQxLFwid2lkdGhcIjoyNCxcImhlaWdodFwiOjMyLFwieG9mZnNldFwiOi0yLFwieW9mZnNldFwiOjYsXCJ4YWR2YW5jZVwiOjE5LFwicGFnZVwiOjAsXCJjaG5sXCI6MH0se1wiaWRcIjoxMDMsXCJ4XCI6MzAyLFwieVwiOjQxLFwid2lkdGhcIjoyNyxcImhlaWdodFwiOjMyLFwieG9mZnNldFwiOi00LFwieW9mZnNldFwiOjEyLFwieGFkdmFuY2VcIjoxOCxcInBhZ2VcIjowLFwiY2hubFwiOjB9LHtcImlkXCI6MTAwLFwieFwiOjMyOSxcInlcIjo0MSxcIndpZHRoXCI6MjUsXCJoZWlnaHRcIjozMixcInhvZmZzZXRcIjotMyxcInlvZmZzZXRcIjo2LFwieGFkdmFuY2VcIjoxOSxcInBhZ2VcIjowLFwiY2hubFwiOjB9LHtcImlkXCI6OTgsXCJ4XCI6MzU0LFwieVwiOjQxLFwid2lkdGhcIjoyNSxcImhlaWdodFwiOjMyLFwieG9mZnNldFwiOi0yLFwieW9mZnNldFwiOjYsXCJ4YWR2YW5jZVwiOjE5LFwicGFnZVwiOjAsXCJjaG5sXCI6MH0se1wiaWRcIjo5MCxcInhcIjozNzksXCJ5XCI6NDEsXCJ3aWR0aFwiOjI1LFwiaGVpZ2h0XCI6MzIsXCJ4b2Zmc2V0XCI6LTMsXCJ5b2Zmc2V0XCI6NixcInhhZHZhbmNlXCI6MTgsXCJwYWdlXCI6MCxcImNobmxcIjowfSx7XCJpZFwiOjg5LFwieFwiOjQwNCxcInlcIjo0MSxcIndpZHRoXCI6MjgsXCJoZWlnaHRcIjozMixcInhvZmZzZXRcIjotNCxcInlvZmZzZXRcIjo2LFwieGFkdmFuY2VcIjoxOSxcInBhZ2VcIjowLFwiY2hubFwiOjB9LHtcImlkXCI6ODgsXCJ4XCI6NDMyLFwieVwiOjQxLFwid2lkdGhcIjoyOSxcImhlaWdodFwiOjMyLFwieG9mZnNldFwiOi00LFwieW9mZnNldFwiOjYsXCJ4YWR2YW5jZVwiOjIwLFwicGFnZVwiOjAsXCJjaG5sXCI6MH0se1wiaWRcIjo4NyxcInhcIjo0NjEsXCJ5XCI6NDEsXCJ3aWR0aFwiOjM5LFwiaGVpZ2h0XCI6MzIsXCJ4b2Zmc2V0XCI6LTQsXCJ5b2Zmc2V0XCI6NixcInhhZHZhbmNlXCI6MzEsXCJwYWdlXCI6MCxcImNobmxcIjowfSx7XCJpZFwiOjg2LFwieFwiOjAsXCJ5XCI6NzMsXCJ3aWR0aFwiOjI5LFwiaGVpZ2h0XCI6MzIsXCJ4b2Zmc2V0XCI6LTQsXCJ5b2Zmc2V0XCI6NixcInhhZHZhbmNlXCI6MjAsXCJwYWdlXCI6MCxcImNobmxcIjowfSx7XCJpZFwiOjg1LFwieFwiOjI5LFwieVwiOjczLFwid2lkdGhcIjoyNyxcImhlaWdodFwiOjMyLFwieG9mZnNldFwiOi0yLFwieW9mZnNldFwiOjYsXCJ4YWR2YW5jZVwiOjIxLFwicGFnZVwiOjAsXCJjaG5sXCI6MH0se1wiaWRcIjo4NCxcInhcIjo1NixcInlcIjo3MyxcIndpZHRoXCI6MjgsXCJoZWlnaHRcIjozMixcInhvZmZzZXRcIjotNCxcInlvZmZzZXRcIjo2LFwieGFkdmFuY2VcIjoxOSxcInBhZ2VcIjowLFwiY2hubFwiOjB9LHtcImlkXCI6ODMsXCJ4XCI6ODQsXCJ5XCI6NzMsXCJ3aWR0aFwiOjI1LFwiaGVpZ2h0XCI6MzIsXCJ4b2Zmc2V0XCI6LTMsXCJ5b2Zmc2V0XCI6NixcInhhZHZhbmNlXCI6MTgsXCJwYWdlXCI6MCxcImNobmxcIjowfSx7XCJpZFwiOjgyLFwieFwiOjEwOSxcInlcIjo3MyxcIndpZHRoXCI6MjYsXCJoZWlnaHRcIjozMixcInhvZmZzZXRcIjotMixcInlvZmZzZXRcIjo2LFwieGFkdmFuY2VcIjoyMCxcInBhZ2VcIjowLFwiY2hubFwiOjB9LHtcImlkXCI6ODAsXCJ4XCI6MTM1LFwieVwiOjczLFwid2lkdGhcIjoyNixcImhlaWdodFwiOjMyLFwieG9mZnNldFwiOi0yLFwieW9mZnNldFwiOjYsXCJ4YWR2YW5jZVwiOjE5LFwicGFnZVwiOjAsXCJjaG5sXCI6MH0se1wiaWRcIjo3OSxcInhcIjoxNjEsXCJ5XCI6NzMsXCJ3aWR0aFwiOjI4LFwiaGVpZ2h0XCI6MzIsXCJ4b2Zmc2V0XCI6LTMsXCJ5b2Zmc2V0XCI6NixcInhhZHZhbmNlXCI6MjIsXCJwYWdlXCI6MCxcImNobmxcIjowfSx7XCJpZFwiOjc4LFwieFwiOjE4OSxcInlcIjo3MyxcIndpZHRoXCI6MjgsXCJoZWlnaHRcIjozMixcInhvZmZzZXRcIjotMixcInlvZmZzZXRcIjo2LFwieGFkdmFuY2VcIjoyMyxcInBhZ2VcIjowLFwiY2hubFwiOjB9LHtcImlkXCI6NzcsXCJ4XCI6MjE3LFwieVwiOjczLFwid2lkdGhcIjozNCxcImhlaWdodFwiOjMyLFwieG9mZnNldFwiOi0yLFwieW9mZnNldFwiOjYsXCJ4YWR2YW5jZVwiOjI5LFwicGFnZVwiOjAsXCJjaG5sXCI6MH0se1wiaWRcIjo3NixcInhcIjoyNTEsXCJ5XCI6NzMsXCJ3aWR0aFwiOjI0LFwiaGVpZ2h0XCI6MzIsXCJ4b2Zmc2V0XCI6LTIsXCJ5b2Zmc2V0XCI6NixcInhhZHZhbmNlXCI6MTcsXCJwYWdlXCI6MCxcImNobmxcIjowfSx7XCJpZFwiOjc1LFwieFwiOjI3NSxcInlcIjo3MyxcIndpZHRoXCI6MjcsXCJoZWlnaHRcIjozMixcInhvZmZzZXRcIjotMixcInlvZmZzZXRcIjo2LFwieGFkdmFuY2VcIjoyMCxcInBhZ2VcIjowLFwiY2hubFwiOjB9LHtcImlkXCI6NzQsXCJ4XCI6MzAyLFwieVwiOjczLFwid2lkdGhcIjoxOCxcImhlaWdodFwiOjMyLFwieG9mZnNldFwiOi00LFwieW9mZnNldFwiOjYsXCJ4YWR2YW5jZVwiOjExLFwicGFnZVwiOjAsXCJjaG5sXCI6MH0se1wiaWRcIjo3MyxcInhcIjozMjAsXCJ5XCI6NzMsXCJ3aWR0aFwiOjE0LFwiaGVpZ2h0XCI6MzIsXCJ4b2Zmc2V0XCI6LTIsXCJ5b2Zmc2V0XCI6NixcInhhZHZhbmNlXCI6OSxcInBhZ2VcIjowLFwiY2hubFwiOjB9LHtcImlkXCI6NzIsXCJ4XCI6MzM0LFwieVwiOjczLFwid2lkdGhcIjoyNyxcImhlaWdodFwiOjMyLFwieG9mZnNldFwiOi0yLFwieW9mZnNldFwiOjYsXCJ4YWR2YW5jZVwiOjIyLFwicGFnZVwiOjAsXCJjaG5sXCI6MH0se1wiaWRcIjo3MSxcInhcIjozNjEsXCJ5XCI6NzMsXCJ3aWR0aFwiOjI3LFwiaGVpZ2h0XCI6MzIsXCJ4b2Zmc2V0XCI6LTMsXCJ5b2Zmc2V0XCI6NixcInhhZHZhbmNlXCI6MjAsXCJwYWdlXCI6MCxcImNobmxcIjowfSx7XCJpZFwiOjcwLFwieFwiOjM4OCxcInlcIjo3MyxcIndpZHRoXCI6MjQsXCJoZWlnaHRcIjozMixcInhvZmZzZXRcIjotMixcInlvZmZzZXRcIjo2LFwieGFkdmFuY2VcIjoxNyxcInBhZ2VcIjowLFwiY2hubFwiOjB9LHtcImlkXCI6NjksXCJ4XCI6NDEyLFwieVwiOjczLFwid2lkdGhcIjoyNCxcImhlaWdodFwiOjMyLFwieG9mZnNldFwiOi0yLFwieW9mZnNldFwiOjYsXCJ4YWR2YW5jZVwiOjE4LFwicGFnZVwiOjAsXCJjaG5sXCI6MH0se1wiaWRcIjo2OCxcInhcIjo0MzYsXCJ5XCI6NzMsXCJ3aWR0aFwiOjI3LFwiaGVpZ2h0XCI6MzIsXCJ4b2Zmc2V0XCI6LTIsXCJ5b2Zmc2V0XCI6NixcInhhZHZhbmNlXCI6MjEsXCJwYWdlXCI6MCxcImNobmxcIjowfSx7XCJpZFwiOjY3LFwieFwiOjQ2MyxcInlcIjo3MyxcIndpZHRoXCI6MjYsXCJoZWlnaHRcIjozMixcInhvZmZzZXRcIjotMyxcInlvZmZzZXRcIjo2LFwieGFkdmFuY2VcIjoxOSxcInBhZ2VcIjowLFwiY2hubFwiOjB9LHtcImlkXCI6NjYsXCJ4XCI6MCxcInlcIjoxMDUsXCJ3aWR0aFwiOjI2LFwiaGVpZ2h0XCI6MzIsXCJ4b2Zmc2V0XCI6LTIsXCJ5b2Zmc2V0XCI6NixcInhhZHZhbmNlXCI6MjAsXCJwYWdlXCI6MCxcImNobmxcIjowfSx7XCJpZFwiOjY1LFwieFwiOjI2LFwieVwiOjEwNSxcIndpZHRoXCI6MzAsXCJoZWlnaHRcIjozMixcInhvZmZzZXRcIjotNCxcInlvZmZzZXRcIjo2LFwieGFkdmFuY2VcIjoyMCxcInBhZ2VcIjowLFwiY2hubFwiOjB9LHtcImlkXCI6NjQsXCJ4XCI6NTYsXCJ5XCI6MTA1LFwid2lkdGhcIjoyOSxcImhlaWdodFwiOjMxLFwieG9mZnNldFwiOi0yLFwieW9mZnNldFwiOjksXCJ4YWR2YW5jZVwiOjI0LFwicGFnZVwiOjAsXCJjaG5sXCI6MH0se1wiaWRcIjoxMTYsXCJ4XCI6ODUsXCJ5XCI6MTA1LFwid2lkdGhcIjoyMixcImhlaWdodFwiOjMwLFwieG9mZnNldFwiOi00LFwieW9mZnNldFwiOjgsXCJ4YWR2YW5jZVwiOjEzLFwicGFnZVwiOjAsXCJjaG5sXCI6MH0se1wiaWRcIjo1OSxcInhcIjoxMDcsXCJ5XCI6MTA1LFwid2lkdGhcIjoxNCxcImhlaWdodFwiOjI5LFwieG9mZnNldFwiOi0yLFwieW9mZnNldFwiOjE0LFwieGFkdmFuY2VcIjo4LFwicGFnZVwiOjAsXCJjaG5sXCI6MH0se1wiaWRcIjoxMjIsXCJ4XCI6MTIxLFwieVwiOjEwNSxcIndpZHRoXCI6MjQsXCJoZWlnaHRcIjoyNixcInhvZmZzZXRcIjotMyxcInlvZmZzZXRcIjoxMixcInhhZHZhbmNlXCI6MTcsXCJwYWdlXCI6MCxcImNobmxcIjowfSx7XCJpZFwiOjEyMCxcInhcIjoxNDUsXCJ5XCI6MTA1LFwid2lkdGhcIjoyNixcImhlaWdodFwiOjI2LFwieG9mZnNldFwiOi00LFwieW9mZnNldFwiOjEyLFwieGFkdmFuY2VcIjoxNyxcInBhZ2VcIjowLFwiY2hubFwiOjB9LHtcImlkXCI6MTE5LFwieFwiOjE3MSxcInlcIjoxMDUsXCJ3aWR0aFwiOjM2LFwiaGVpZ2h0XCI6MjYsXCJ4b2Zmc2V0XCI6LTQsXCJ5b2Zmc2V0XCI6MTIsXCJ4YWR2YW5jZVwiOjI3LFwicGFnZVwiOjAsXCJjaG5sXCI6MH0se1wiaWRcIjoxMTgsXCJ4XCI6MjA3LFwieVwiOjEwNSxcIndpZHRoXCI6MjcsXCJoZWlnaHRcIjoyNixcInhvZmZzZXRcIjotNCxcInlvZmZzZXRcIjoxMixcInhhZHZhbmNlXCI6MTcsXCJwYWdlXCI6MCxcImNobmxcIjowfSx7XCJpZFwiOjExNyxcInhcIjoyMzQsXCJ5XCI6MTA1LFwid2lkdGhcIjoyNCxcImhlaWdodFwiOjI2LFwieG9mZnNldFwiOi0yLFwieW9mZnNldFwiOjEyLFwieGFkdmFuY2VcIjoxOSxcInBhZ2VcIjowLFwiY2hubFwiOjB9LHtcImlkXCI6MTE1LFwieFwiOjI1OCxcInlcIjoxMDUsXCJ3aWR0aFwiOjI0LFwiaGVpZ2h0XCI6MjYsXCJ4b2Zmc2V0XCI6LTMsXCJ5b2Zmc2V0XCI6MTIsXCJ4YWR2YW5jZVwiOjE3LFwicGFnZVwiOjAsXCJjaG5sXCI6MH0se1wiaWRcIjoxMTQsXCJ4XCI6MjgyLFwieVwiOjEwNSxcIndpZHRoXCI6MjAsXCJoZWlnaHRcIjoyNixcInhvZmZzZXRcIjotMixcInlvZmZzZXRcIjoxMixcInhhZHZhbmNlXCI6MTMsXCJwYWdlXCI6MCxcImNobmxcIjowfSx7XCJpZFwiOjExMSxcInhcIjozMDIsXCJ5XCI6MTA1LFwid2lkdGhcIjoyNSxcImhlaWdodFwiOjI2LFwieG9mZnNldFwiOi0zLFwieW9mZnNldFwiOjEyLFwieGFkdmFuY2VcIjoxOCxcInBhZ2VcIjowLFwiY2hubFwiOjB9LHtcImlkXCI6MTEwLFwieFwiOjMyNyxcInlcIjoxMDUsXCJ3aWR0aFwiOjI0LFwiaGVpZ2h0XCI6MjYsXCJ4b2Zmc2V0XCI6LTIsXCJ5b2Zmc2V0XCI6MTIsXCJ4YWR2YW5jZVwiOjE5LFwicGFnZVwiOjAsXCJjaG5sXCI6MH0se1wiaWRcIjoxMDksXCJ4XCI6MzUxLFwieVwiOjEwNSxcIndpZHRoXCI6MzMsXCJoZWlnaHRcIjoyNixcInhvZmZzZXRcIjotMixcInlvZmZzZXRcIjoxMixcInhhZHZhbmNlXCI6MjgsXCJwYWdlXCI6MCxcImNobmxcIjowfSx7XCJpZFwiOjEwMSxcInhcIjozODQsXCJ5XCI6MTA1LFwid2lkdGhcIjoyNSxcImhlaWdodFwiOjI2LFwieG9mZnNldFwiOi0zLFwieW9mZnNldFwiOjEyLFwieGFkdmFuY2VcIjoxOCxcInBhZ2VcIjowLFwiY2hubFwiOjB9LHtcImlkXCI6OTksXCJ4XCI6NDA5LFwieVwiOjEwNSxcIndpZHRoXCI6MjMsXCJoZWlnaHRcIjoyNixcInhvZmZzZXRcIjotMyxcInlvZmZzZXRcIjoxMixcInhhZHZhbmNlXCI6MTYsXCJwYWdlXCI6MCxcImNobmxcIjowfSx7XCJpZFwiOjk3LFwieFwiOjQzMixcInlcIjoxMDUsXCJ3aWR0aFwiOjI0LFwiaGVpZ2h0XCI6MjYsXCJ4b2Zmc2V0XCI6LTMsXCJ5b2Zmc2V0XCI6MTIsXCJ4YWR2YW5jZVwiOjE4LFwicGFnZVwiOjAsXCJjaG5sXCI6MH0se1wiaWRcIjo0MyxcInhcIjo0NTYsXCJ5XCI6MTA1LFwid2lkdGhcIjoyNCxcImhlaWdodFwiOjI0LFwieG9mZnNldFwiOi0zLFwieW9mZnNldFwiOjExLFwieGFkdmFuY2VcIjoxNyxcInBhZ2VcIjowLFwiY2hubFwiOjB9LHtcImlkXCI6NjIsXCJ4XCI6NDgwLFwieVwiOjEwNSxcIndpZHRoXCI6MjMsXCJoZWlnaHRcIjoyNCxcInhvZmZzZXRcIjotMixcInlvZmZzZXRcIjoxMixcInhhZHZhbmNlXCI6MTcsXCJwYWdlXCI6MCxcImNobmxcIjowfSx7XCJpZFwiOjYwLFwieFwiOjAsXCJ5XCI6MTM3LFwid2lkdGhcIjoyMyxcImhlaWdodFwiOjI0LFwieG9mZnNldFwiOi0zLFwieW9mZnNldFwiOjEyLFwieGFkdmFuY2VcIjoxNyxcInBhZ2VcIjowLFwiY2hubFwiOjB9LHtcImlkXCI6NTgsXCJ4XCI6MjMsXCJ5XCI6MTM3LFwid2lkdGhcIjoxNCxcImhlaWdodFwiOjI0LFwieG9mZnNldFwiOi0zLFwieW9mZnNldFwiOjE0LFwieGFkdmFuY2VcIjo4LFwicGFnZVwiOjAsXCJjaG5sXCI6MH0se1wiaWRcIjo0MixcInhcIjozNyxcInlcIjoxMzcsXCJ3aWR0aFwiOjIxLFwiaGVpZ2h0XCI6MjEsXCJ4b2Zmc2V0XCI6LTMsXCJ5b2Zmc2V0XCI6NixcInhhZHZhbmNlXCI6MTQsXCJwYWdlXCI6MCxcImNobmxcIjowfSx7XCJpZFwiOjYxLFwieFwiOjU4LFwieVwiOjEzNyxcIndpZHRoXCI6MjQsXCJoZWlnaHRcIjoyMCxcInhvZmZzZXRcIjotMixcInlvZmZzZXRcIjoxMyxcInhhZHZhbmNlXCI6MTksXCJwYWdlXCI6MCxcImNobmxcIjowfSx7XCJpZFwiOjk0LFwieFwiOjgyLFwieVwiOjEzNyxcIndpZHRoXCI6MjMsXCJoZWlnaHRcIjoxOSxcInhvZmZzZXRcIjotNCxcInlvZmZzZXRcIjo4LFwieGFkdmFuY2VcIjoxNCxcInBhZ2VcIjowLFwiY2hubFwiOjB9LHtcImlkXCI6NDQsXCJ4XCI6MTA1LFwieVwiOjEzNyxcIndpZHRoXCI6MTQsXCJoZWlnaHRcIjoxOSxcInhvZmZzZXRcIjotMyxcInlvZmZzZXRcIjoyNCxcInhhZHZhbmNlXCI6OCxcInBhZ2VcIjowLFwiY2hubFwiOjB9LHtcImlkXCI6MzksXCJ4XCI6MTE5LFwieVwiOjEzNyxcIndpZHRoXCI6MTMsXCJoZWlnaHRcIjoxNyxcInhvZmZzZXRcIjotMyxcInlvZmZzZXRcIjo2LFwieGFkdmFuY2VcIjo3LFwicGFnZVwiOjAsXCJjaG5sXCI6MH0se1wiaWRcIjo5NixcInhcIjoxMzIsXCJ5XCI6MTM3LFwid2lkdGhcIjoxOCxcImhlaWdodFwiOjE3LFwieG9mZnNldFwiOi00LFwieW9mZnNldFwiOjUsXCJ4YWR2YW5jZVwiOjExLFwicGFnZVwiOjAsXCJjaG5sXCI6MH0se1wiaWRcIjozNCxcInhcIjoxNTAsXCJ5XCI6MTM3LFwid2lkdGhcIjoxOCxcImhlaWdodFwiOjE3LFwieG9mZnNldFwiOi0zLFwieW9mZnNldFwiOjYsXCJ4YWR2YW5jZVwiOjEyLFwicGFnZVwiOjAsXCJjaG5sXCI6MH0se1wiaWRcIjoxMjYsXCJ4XCI6MTY4LFwieVwiOjEzNyxcIndpZHRoXCI6MjIsXCJoZWlnaHRcIjoxNCxcInhvZmZzZXRcIjotMixcInlvZmZzZXRcIjoxNyxcInhhZHZhbmNlXCI6MTcsXCJwYWdlXCI6MCxcImNobmxcIjowfSx7XCJpZFwiOjQ2LFwieFwiOjE5MCxcInlcIjoxMzcsXCJ3aWR0aFwiOjE0LFwiaGVpZ2h0XCI6MTQsXCJ4b2Zmc2V0XCI6LTMsXCJ5b2Zmc2V0XCI6MjQsXCJ4YWR2YW5jZVwiOjgsXCJwYWdlXCI6MCxcImNobmxcIjowfSx7XCJpZFwiOjk1LFwieFwiOjIwNCxcInlcIjoxMzcsXCJ3aWR0aFwiOjI0LFwiaGVpZ2h0XCI6MTMsXCJ4b2Zmc2V0XCI6LTIsXCJ5b2Zmc2V0XCI6MjgsXCJ4YWR2YW5jZVwiOjE4LFwicGFnZVwiOjAsXCJjaG5sXCI6MH0se1wiaWRcIjo0NSxcInhcIjoyMjgsXCJ5XCI6MTM3LFwid2lkdGhcIjoxOSxcImhlaWdodFwiOjEzLFwieG9mZnNldFwiOi0yLFwieW9mZnNldFwiOjE4LFwieGFkdmFuY2VcIjoxNCxcInBhZ2VcIjowLFwiY2hubFwiOjB9XSxcImtlcm5pbmdzXCI6W10sXCJpbmZvXCI6e1wiZmFjZVwiOlwiRXhvIDIgU2VtaSBCb2xkXCIsXCJzaXplXCI6MzIsXCJib2xkXCI6MCxcIml0YWxpY1wiOjAsXCJjaGFyc2V0XCI6XCJcIixcInVuaWNvZGVcIjowLFwic3RyZXRjaEhcIjoxMDAsXCJzbW9vdGhcIjoxLFwiYWFcIjoxLFwicGFkZGluZ1wiOls0LDQsNCw0XSxcInNwYWNpbmdcIjpbLTgsLThdfSxcImNvbW1vblwiOntcImxpbmVIZWlnaHRcIjo0MCxcImJhc2VcIjozMyxcInNjYWxlV1wiOjUxMixcInNjYWxlSFwiOjUxMixcInBhZ2VzXCI6MSxcInBhY2tlZFwiOjB9fSIsIihmdW5jdGlvbiAoZ2xvYmFsKXtcbnJlcXVpcmUoJ3JhZi5qcycpXG5cbnZhciBUSFJFRSA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93LlRIUkVFIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbC5USFJFRSA6IG51bGwpXG52YXIgUmVuZGVyZXIgPSByZXF1aXJlKCcuL2xpYi9yZW5kZXJlcicpXG52YXIgY3JlYXRlRm9udCA9IHJlcXVpcmUoJy4vbGliL2NyZWF0ZS1mb250JylcbnZhciB4dGVuZCA9IHJlcXVpcmUoJ3h0ZW5kJylcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvcHQpIHtcbiAgICBvcHQgPSBvcHR8fHt9XG4gICAgdmFyIGFwcCA9IHJlcXVpcmUoJ2NhbnZhcy1hcHAnKShyZW5kZXIsIHh0ZW5kKHtcbiAgICAgICAgY29udGV4dDogJ3dlYmdsJyxcbiAgICAgICAgY29udGV4dEF0dHJpYnV0ZXM6IHsgYW50aWFsaWFzOiBmYWxzZSwgYWxwaGE6IGZhbHNlIH0sXG4gICAgICAgIHJldGluYTogdHJ1ZSxcbiAgICAgICAgb25SZXNpemU6IGhhbmRsZVJlc2l6ZVxuICAgIH0sIG9wdCkpXG5cbiAgICBcbiAgICB2YXIgcmVuZGVyZXJcblxuICAgIGFwcC5sb2FkID0gZnVuY3Rpb24oY2IpIHtcbiAgICAgICAgY2IgPSBjYiB8fCBmdW5jdGlvbigpIHt9XG4gICAgICAgIHZhciBnbCA9IGFwcC5jb250ZXh0XG4gICAgICAgIGNyZWF0ZUZvbnQoZ2wsIGZ1bmN0aW9uKGVyciwgZm9udCkge1xuICAgICAgICAgICAgcmVuZGVyZXIgPSBSZW5kZXJlcih7XG4gICAgICAgICAgICAgICAgZ2w6IGdsLCBcbiAgICAgICAgICAgICAgICB3aWR0aDogYXBwLndpZHRoLCBcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGFwcC5oZWlnaHQsXG4gICAgICAgICAgICAgICAgZm9udDogZm9udFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIGNiKGVycilcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICByZXR1cm4gYXBwXG5cbiAgICBmdW5jdGlvbiByZW5kZXIoZ2wsIHdpZHRoLCBoZWlnaHQsIGR0KSB7XG4gICAgICAgIGlmIChyZW5kZXJlcilcbiAgICAgICAgICAgIHJlbmRlcmVyLmRyYXcoZHQpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFuZGxlUmVzaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgaWYgKHJlbmRlcmVyKVxuICAgICAgICAgICAgcmVuZGVyZXIucmVzaXplKHdpZHRoLCBoZWlnaHQpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0dXBTbW9vdGhUZXgoZ2wsIHQpIHtcbiAgICAgICAgdC5taW5GaWx0ZXIgPSBnbC5MSU5FQVJfTUlQTUFQX0xJTkVBUlxuICAgICAgICB0Lm1hZ0ZpbHRlciA9IGdsLkxJTkVBUlxuXG4gICAgICAgIHZhciBleHQgPSAoZ2wuZ2V0RXh0ZW5zaW9uKCdFWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWMnKSBcbiAgICAgICAgICAgICAgICAgICAgICAgIHx8IGdsLmdldEV4dGVuc2lvbihcIk1PWl9FWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWNcIikpO1xuICAgICAgICBpZiAoZXh0KSB7XG4gICAgICAgICAgICB2YXIgbWF4QW5pc3Ryb3BoeSA9IGdsLmdldFBhcmFtZXRlcihleHQuTUFYX1RFWFRVUkVfTUFYX0FOSVNPVFJPUFlfRVhUKTtcbiAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmYoZ2wuVEVYVFVSRV8yRCwgZXh0LlRFWFRVUkVfTUFYX0FOSVNPVFJPUFlfRVhULCBNYXRoLm1pbigxNiwgbWF4QW5pc3Ryb3BoeSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdC5nZW5lcmF0ZU1pcG1hcCgpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0dXBOZWFyZXN0VGV4KGdsLCB0KSB7XG4gICAgICAgIHQubWluRmlsdGVyID0gdC5tYWdGaWx0ZXIgPSBnbC5ORUFSRVNUXG4gICAgfVxufVxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pIiwiKGZ1bmN0aW9uIChnbG9iYWwpe1xudmFyIFRIUkVFID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cuVEhSRUUgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsLlRIUkVFIDogbnVsbClcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBtaXhlcyA9IHJlcXVpcmUoJ21peGVzJylcbnZhciBCYXNlID0gVEhSRUUuU2NlbmVcblxudmFyIFlPRkYgPSAyLjVcblxuZnVuY3Rpb24gUmlnU2NlbmUob3B0KSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJpZ1NjZW5lKSlcbiAgICAgICAgcmV0dXJuIG5ldyBSaWdTY2VuZShvcHQpXG4gICAgQmFzZS5jYWxsKHRoaXMpXG4gICAgdGhpcy5mb2cgPSBuZXcgVEhSRUUuRm9nRXhwMiggMHgwYjA1MTYsIDAuMDAwMTUgKTtcblxuXG4gICAgLy8gdmFyIGJveCA9IG5ldyBUSFJFRS5NZXNoKFxuICAgIC8vICAgICBuZXcgVEhSRUUuQm94R2VvbWV0cnkoMjAsIDIwLCAxMCksXG4gICAgLy8gICAgIG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCh7IGNvbG9yOiAweGFhYWFhYSwgd2lyZWZyYW1lOiBmYWxzZSB9KVxuICAgIC8vIClcblxuICAgIC8vIHRoaXMuYWRkKGJveClcblxuXG4gICAgdGhpcy50aW1lID0gMFxuICAgIHRoaXMuY3ViZU1hcCA9IG51bGxcbiAgICB0aGlzLnVwZGF0ZU1hdGVyaWFsKClcblxuICAgIHZhciBsb2FkZXIgPSBuZXcgVEhSRUUuT0JKTVRMTG9hZGVyKClcbiAgICBsb2FkZXIubG9hZCgnbW9kZWwvUHJpcmF6bG9tbmF5YXdpdGhwaXBlczMub2JqJywgJ21vZGVsL1ByaXJhemxvbW5heWF3aXRocGlwZXMzLm10bCcsIGZ1bmN0aW9uKG9iamVjdCwgbWF0ZXJpYWxzKSB7XG4gICAgICAgIHZhciBzID0gMC4zXG4gICAgICAgIGNvbnNvbGUubG9nKG9iamVjdCwgbWF0ZXJpYWxzKVxuICAgICAgICBvYmplY3Quc2NhbGUuc2V0KHMscyxzKVxuICAgICAgICBvYmplY3QucG9zaXRpb24ueSAtPSBZT0ZGXG4gICAgICAgIHRoaXMubWVzaCA9IG9iamVjdFxuXG4gICAgICAgIHRoaXMubWVzaC50cmF2ZXJzZShmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgIGlmIChvYmogaW5zdGFuY2VvZiBUSFJFRS5NZXNoKSB7XG4gICAgICAgICAgICAgICAgb2JqLmNhc3RTaGFkb3cgPSB0cnVlXG4gICAgICAgICAgICAgICAgb2JqLnJlY2VpdmVTaGFkb3cgPSB0cnVlXG4gICAgICAgICAgICAgICAgb2JqLm1hdGVyaWFsLnNoaW5pbmVzcyA9IDFcbiAgICAgICAgICAgICAgICBpZiAob2JqLm1hdGVyaWFsLm1hcCkge1xuICAgICAgICAgICAgICAgICAgICBvYmoubWF0ZXJpYWwudHJhbnNwYXJlbnQgPSB0cnVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKG9iai5tYXRlcmlhbC51bmlmb3JtcylcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcblxuICAgICAgICB0aGlzLmFkZChvYmplY3QpXG4gICAgfS5iaW5kKHRoaXMpKVxuICAgIFxuXG4gICAgLy8gdmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLlRvcnVzS25vdEdlb21ldHJ5KCAxMCwgMywgMTAwLCAxNiApO1xuICAgIC8vIHZhciBtYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogMHhmZmZmMDAgfSApO1xuICAgIC8vIHZhciB0b3J1c0tub3QgPSBuZXcgVEhSRUUuTWVzaCggZ2VvbWV0cnksIG1hdGVyaWFsICk7XG4gICAgLy8gdGhpcy5hZGQoIHRvcnVzS25vdCApO1xuICAgIC8vIHRvcnVzS25vdC5jYXN0U2hhZG93ID0gdHJ1ZVxuICAgIC8vIHRvcnVzS25vdC5yZWNlaXZlU2hhZG93ID0gdHJ1ZVxuXG4gICAgdGhpcy5saWdodHMgPSBbXG4gICAgICAgIFsgbmV3IFRIUkVFLlZlY3RvcjMoLTEwLCAyMCwgLTIwKSwgMSBdLFxuICAgICAgICBbIG5ldyBUSFJFRS5WZWN0b3IzKDE1LCAxMCwgMTUpLCAwLjUgXVxuICAgIF0ubWFwKGZ1bmN0aW9uKGFyZ3MsIGkpIHtcbiAgICAgICAgdmFyIGxpZ2h0ID0gbmV3IFRIUkVFLkRpcmVjdGlvbmFsTGlnaHQoIDB4ZGRmNGZkLCBhcmdzWzFdIClcbiAgICAgICAgbGlnaHQucG9zaXRpb24uY29weShhcmdzWzBdKVxuICAgICAgICBsaWdodC5jYXN0U2hhZG93ID0gdHJ1ZVxuICAgICAgICBsaWdodC5zaGFkb3dNYXBXaWR0aCA9IDEwMjRcbiAgICAgICAgbGlnaHQuc2hhZG93TWFwSGVpZ2h0ID0gMTAyNFxuICAgICAgICBsaWdodC5zaGFkb3dDYW1lcmFOZWFyID0gMVxuICAgICAgICBsaWdodC5zaGFkb3dDYW1lcmFGYXIgPSAxMDBcblxuICAgICAgICAvLyBsaWdodC5oZWxwZXIgPSBuZXcgVEhSRUUuRGlyZWN0aW9uYWxMaWdodEhlbHBlcihsaWdodCwgNClcbiAgICAgICAgLy8gdGhpcy5hZGQobGlnaHQuaGVscGVyKVxuICAgICAgICB0aGlzLmFkZChsaWdodClcbiAgICAgICAgcmV0dXJuIGxpZ2h0XG4gICAgfSx0aGlzKVxufVxuXG5pbmhlcml0cyhSaWdTY2VuZSwgQmFzZSlcblxubWl4ZXMoUmlnU2NlbmUsIHtcblxuICAgIHVwZGF0ZU1hdGVyaWFsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5tYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoTGFtYmVydE1hdGVyaWFsKHtcbiAgICAgICAgICAgIGNvbG9yOiAweGFhYWFhYSxcbiAgICAgICAgICAgIHJlZmxlY3Rpdml0eTogMC40LFxuICAgICAgICAgICAgZW52TWFwOiB0aGlzLmN1YmVNYXBcbiAgICAgICAgfSlcblxuICAgIH0sXG5cbiAgICB1cGRhdGU6IGZ1bmN0aW9uKGR0KSB7XG4gICAgICAgIHRoaXMudGltZSArPSBNYXRoLm1pbihkdCwgMzApLzEwMDBcbiAgICAgICAgdmFyIG0gPSB0aGlzLm1lc2hcbiAgICAgICAgaWYgKCFtKVxuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIHZhciBhbmltID0gTWF0aC5zaW4odGhpcy50aW1lKVxuXG4gICAgICAgIC8vIHRoaXMubGlnaHRzLmZvckVhY2goZnVuY3Rpb24obGlnaHQpIHsgbGlnaHQuaGVscGVyLnVwZGF0ZSgpIH0pXG4gICAgICAgIC8vIG0ucG9zaXRpb24ueSA9IFlPRkYgKyBhbmltKjAuMlxuICAgICAgICAvLyBtLnBvc2l0aW9uLnggPSBNYXRoLnNpbih0aGlzLnRpbWUqMC4xKSowLjA1XG4gICAgICAgIC8vIG0ucG9zaXRpb24ueiA9IE1hdGguc2luKHRoaXMudGltZSowLjIpKjAuMVxuICAgICAgICAvLyBtLnJvdGF0aW9uLnggPSBhbmltKjAuMDNcbiAgICAgICAgLy8gbS5yb3RhdGlvbi55ID0gTWF0aC5zaW4odGhpcy50aW1lKk1hdGguY29zKHRoaXMudGltZSowLjEpKSowLjAwNVxuICAgIH1cbn0pXG5cbm1vZHVsZS5leHBvcnRzID0gUmlnU2NlbmVcbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KSIsIihmdW5jdGlvbiAoZ2xvYmFsKXtcbnZhciBUSFJFRSA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93LlRIUkVFIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbC5USFJFRSA6IG51bGwpO1xudmFyIEVmZmVjdENvbXBvc2VyID0gcmVxdWlyZShcInRocmVlLWVmZmVjdGNvbXBvc2VyXCIpKFRIUkVFKTtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoXCJpbmhlcml0c1wiKTtcbnZhciBCYXNlID0gRWZmZWN0Q29tcG9zZXIuUmVuZGVyUGFzcztcbnZhciBwbHVja2VyID0gcmVxdWlyZShcInBsdWNrZXJcIik7XG52YXIgbnVtYmVyID0gcmVxdWlyZShcImFzLW51bWJlclwiKTtcbnZhciBUZXh0RWxlbWVudCA9IHJlcXVpcmUoXCJ0aHJlZS1zZGYtdGV4dFwiKShUSFJFRSk7XG52YXIgeHRlbmQgPSByZXF1aXJlKFwieHRlbmRcIik7XG52YXIgVU5JVF9TQ0FMRSA9IDAuMTtcbnZhciBTQ0FMRSA9IFtVTklUX1NDQUxFLCBVTklUX1NDQUxFLCBVTklUX1NDQUxFXTtcblxudmFyIG1hdDQgPSB7XG4gICAgc2NhbGU6IHJlcXVpcmUoXCJnbC1tYXQ0L3NjYWxlXCIpLFxuICAgIGlkZW50aXR5OiByZXF1aXJlKFwiZ2wtbWF0NC9pZGVudGl0eVwiKSxcbiAgICBtdWx0aXBseTogcmVxdWlyZShcImdsLW1hdDQvbXVsdGlwbHlcIiksXG4gICAgdHJhbnNsYXRlOiByZXF1aXJlKFwiZ2wtbWF0NC90cmFuc2xhdGVcIilcbn07XG5cbnZhciBzZXRWZWMzID0gcmVxdWlyZShcImdsLXZlYzMvc2V0XCIpO1xudmFyIHRtcFZlYzMgPSBbMCwgMCwgMF07XG52YXIgcGx1Y2tQYW5lbHMgPSBwbHVja2VyKFwicGFuZWxzXCIpO1xudmFyIGdsc2xpZnkgPSByZXF1aXJlKFwiZ2xzbGlmeVwiKTtcbnZhciBjcmVhdGVTREZTaGFkZXIgPSByZXF1aXJlKFwiZ2xzbGlmeS9hZGFwdGVyLmpzXCIpKFwiXFxuI2RlZmluZSBHTFNMSUZZIDFcXG5cXG5hdHRyaWJ1dGUgdmVjNCBwb3NpdGlvbjtcXG5hdHRyaWJ1dGUgdmVjNCBjb2xvcjtcXG5hdHRyaWJ1dGUgdmVjMiB0ZXhjb29yZDA7XFxudW5pZm9ybSBtYXQ0IHByb2plY3Rpb247XFxudW5pZm9ybSBtYXQ0IHZpZXc7XFxudW5pZm9ybSBtYXQ0IG1vZGVsO1xcbnZhcnlpbmcgdmVjNCB2X2NvbDtcXG52YXJ5aW5nIHZlYzIgdl90ZXgwO1xcbnZhcnlpbmcgZmxvYXQgYW5pbU9mZnNldDtcXG52b2lkIG1haW4oKSB7XFxuICBnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb24gKiB2aWV3ICogbW9kZWwgKiBwb3NpdGlvbjtcXG4gIHZfY29sID0gY29sb3I7XFxuICB2X3RleDAgPSB0ZXhjb29yZDA7XFxuICBnbF9Qb2ludFNpemUgPSAxLjA7XFxuICBhbmltT2Zmc2V0ID0gcG9zaXRpb24ueCAvIDEwMC4wO1xcbn1cIiwgXCJcXG4jZGVmaW5lIEdMU0xJRlkgMVxcblxcbiNpZmRlZiBHTF9FU1xcblxcbnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbiNlbmRpZlxcblxcbnZhcnlpbmcgdmVjNCB2X2NvbDtcXG52YXJ5aW5nIHZlYzIgdl90ZXgwO1xcbnZhcnlpbmcgZmxvYXQgYW5pbU9mZnNldDtcXG51bmlmb3JtIHNhbXBsZXIyRCB0ZXh0dXJlMDtcXG51bmlmb3JtIHNhbXBsZXIyRCB0ZXh0dXJlMTtcXG51bmlmb3JtIGZsb2F0IHNtb290aGluZztcXG51bmlmb3JtIGZsb2F0IGZhZGU7XFxuY29uc3QgdmVjMiBzaGFkb3dPZmZzZXQgPSB2ZWMyKC0xLjAgLyA1MTIuMCk7XFxuY29uc3QgdmVjNCBnbG93Q29sb3IgPSB2ZWM0KHZlYzMoMC4xKSwgMS4wKTtcXG5jb25zdCBmbG9hdCBnbG93TWluID0gMC40O1xcbmNvbnN0IGZsb2F0IGdsb3dNYXggPSAwLjg7XFxudm9pZCBtYWluKCkge1xcbiAgZmxvYXQgYW5pbSA9IGZhZGUgKiBhbmltT2Zmc2V0O1xcbiAgYW5pbSA9IGNsYW1wKG1peChhbmltLCAxLjAsIGZhZGUgKiBmYWRlKSwgMC4wLCAxLjApO1xcbiAgdmVjNCBzbW9vdGhDb2xvciA9IHZlYzQoMC4wKTtcXG4gIHZlYzQgdGV4Q29sb3IgPSB0ZXh0dXJlMkQodGV4dHVyZTAsIHZfdGV4MCk7XFxuICBmbG9hdCBkc3QgPSB0ZXhDb2xvci5hO1xcbiAgZmxvYXQgc21vb3RoQW10ID0gbWl4KDEuNSwgc21vb3RoaW5nLCBhbmltKTtcXG4gIGZsb2F0IGFscGhhID0gc21vb3Roc3RlcCgwLjUgLSBzbW9vdGhBbXQsIDAuNSArIHNtb290aEFtdCwgZHN0KTtcXG4gIHZlYzQgYmFzZSA9IHZfY29sICogdmVjNChhbHBoYSk7XFxuICBmbG9hdCBnbG93RHN0ID0gdGV4dHVyZTJEKHRleHR1cmUwLCB2X3RleDAgKyBzaGFkb3dPZmZzZXQpLmE7XFxuICB2ZWM0IGdsb3cgPSBnbG93Q29sb3IgKiBzbW9vdGhzdGVwKGdsb3dNaW4sIGdsb3dNYXgsIGdsb3dEc3QpO1xcbiAgZmxvYXQgbWFzayA9IDEuMCAtIGFscGhhO1xcbiAgZ2xfRnJhZ0NvbG9yID0gbWl4KHZlYzQoMC4wKSwgYmFzZSwgYW5pbSk7XFxuICBpZihnbF9GcmFnQ29sb3IuYSA8IDAuMSlcXG4gICAgZGlzY2FyZDtcXG4gIFxcbn1cIiwgW3tcIm5hbWVcIjpcInByb2plY3Rpb25cIixcInR5cGVcIjpcIm1hdDRcIn0se1wibmFtZVwiOlwidmlld1wiLFwidHlwZVwiOlwibWF0NFwifSx7XCJuYW1lXCI6XCJtb2RlbFwiLFwidHlwZVwiOlwibWF0NFwifSx7XCJuYW1lXCI6XCJ0ZXh0dXJlMFwiLFwidHlwZVwiOlwic2FtcGxlcjJEXCJ9LHtcIm5hbWVcIjpcInRleHR1cmUxXCIsXCJ0eXBlXCI6XCJzYW1wbGVyMkRcIn0se1wibmFtZVwiOlwic21vb3RoaW5nXCIsXCJ0eXBlXCI6XCJmbG9hdFwifSx7XCJuYW1lXCI6XCJmYWRlXCIsXCJ0eXBlXCI6XCJmbG9hdFwifV0sIFt7XCJuYW1lXCI6XCJwb3NpdGlvblwiLFwidHlwZVwiOlwidmVjNFwifSx7XCJuYW1lXCI6XCJjb2xvclwiLFwidHlwZVwiOlwidmVjNFwifSx7XCJuYW1lXCI6XCJ0ZXhjb29yZDBcIixcInR5cGVcIjpcInZlYzJcIn1dKTtcbnZhciBzZGZTaGFkZXI7XG5cbmZ1bmN0aW9uIFRleHRQYXNzKG9wdCkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBUZXh0UGFzcykpXG4gICAgICAgIHJldHVybiBuZXcgVGV4dFBhc3Mob3B0KTtcblxuICAgIG9wdCA9IG9wdCB8fCB7fTtcbiAgICB2YXIgcmVuZGVyZXIgPSBvcHQucmVuZGVyZXI7XG4gICAgdmFyIGNhbWVyYSA9IG9wdC5jYW1lcmE7XG4gICAgdmFyIHNjZW5lID0gb3B0LnNjZW5lO1xuICAgIEJhc2UuY2FsbCh0aGlzLCBzY2VuZSwgY2FtZXJhKTtcbiAgICB2YXIgZm9udCA9IG9wdC5mb250O1xuXG4gICAgaWYgKCFzZGZTaGFkZXIpXG4gICAgICAgIHNkZlNoYWRlciA9IGNyZWF0ZVNERlNoYWRlcihyZW5kZXJlci5nZXRDb250ZXh0KCkpO1xuXG4gICAgdGhpcy5ncm91cHMgPSAob3B0Lmdyb3VwcyB8fCBbXSkubWFwKGNyZWF0ZUdyb3VwcyhyZW5kZXJlciwgZm9udCkpO1xuICAgIHdpbmRvdy5ncm91cHMgPSB0aGlzLmdyb3Vwcztcbn1cblxuZnVuY3Rpb24gY3JlYXRlR3JvdXBzKHJlbmRlcmVyLCBmb250KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGdyb3VwLCBncm91cEluZGV4KSB7XG4gICAgICAgIGdyb3VwLmVsZW1lbnRzID0gZ3JvdXAucGFuZWxzLm1hcChmdW5jdGlvbihwYW5lbCwgaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBzaWRlID0gKGluZGV4ID09PSAwID8gMSA6IC0xKTtcblxuICAgICAgICAgICAgcmV0dXJuIHBhbmVsLmxhYmVscy5tYXAoZnVuY3Rpb24obGFiZWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlRWxlbWVudChsYWJlbCwgc2lkZSwgcmVuZGVyZXIsIGZvbnQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pLnJlZHVjZShmdW5jdGlvbihwcmV2LCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJldi5jb25jYXQoYik7XG4gICAgICAgIH0sIFtdKTtcblxuICAgICAgICBncm91cC5fb3BhY2l0eSA9IDE7XG4gICAgICAgIGdyb3VwLmZhZGUgPSAxO1xuICAgICAgICBncm91cC5zaG93aW5nID0gdHJ1ZTtcbiAgICAgICAgZ3JvdXAuYW5pbWF0aW5nT3V0ID0gZmFsc2U7XG5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGdyb3VwLCBcIm9wYWNpdHlcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ3JvdXAuX29wYWNpdHk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICAgICAgICAgIGdyb3VwLl9vcGFjaXR5ID0gdmFsO1xuXG4gICAgICAgICAgICAgICAgZ3JvdXAuZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgIGUudGV4dC5vcGFjaXR5ID0gdmFsO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgZ3JvdXAucGFuZWxzLmZvckVhY2goZnVuY3Rpb24ocCkge1xuICAgICAgICAgICAgICAgICAgICBwLmNvbnRhaW5lci52aXNpYmxlID0gdmFsID4gMC4wMTtcblxuICAgICAgICAgICAgICAgICAgICBwLnNoYXBlcy5mb3JFYWNoKGZ1bmN0aW9uKHNoYXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaGFwZS5tYXRlcmlhbC5vcGFjaXR5ID0gdmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2hhcGUudmlzaWJsZSA9IHZhbCA+IDAuMDE7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gZ3JvdXA7XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudChsYWJlbCwgc2lkZSwgcmVuZGVyZXIsIGZvbnQpIHtcbiAgICB2YXIgdGV4dE9wdCA9IHh0ZW5kKGxhYmVsLCB7XG4gICAgICAgIGZvbnQ6IGZvbnQsXG4gICAgICAgIHRleHR1cmVzOiBmb250LnRleHR1cmVzLFxuICAgICAgICBzaGFkZXI6IHNkZlNoYWRlclxuICAgIH0pO1xuXG4gICAgdmFyIHRleHRFbCA9IFRleHRFbGVtZW50KHJlbmRlcmVyLCB0ZXh0T3B0KTtcblxuICAgIHJldHVybiB4dGVuZChsYWJlbCwge1xuICAgICAgICB0ZXh0OiB0ZXh0RWwsXG4gICAgICAgIHNpZGU6IHNpZGVcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyRWxlbWVudChjYW1lcmEsIGUsIGZhZGUpIHtcbiAgICBlLm9iamVjdDNkLnVwZGF0ZU1hdHJpeFdvcmxkKHRydWUpO1xuICAgIHZhciB0cmFuc2Zvcm0gPSBlLnRleHQudHJhbnNmb3JtO1xuICAgIG1hdDQuaWRlbnRpdHkodHJhbnNmb3JtKTtcbiAgICBtYXQ0LnNjYWxlKHRyYW5zZm9ybSwgdHJhbnNmb3JtLCBTQ0FMRSk7XG4gICAgc2V0VmVjMyh0bXBWZWMzLCBlLnRyYW5zbGF0aW9uWzBdLCBlLnRyYW5zbGF0aW9uWzFdLCBlLnRyYW5zbGF0aW9uWzJdKTtcbiAgICBtYXQ0LnRyYW5zbGF0ZSh0cmFuc2Zvcm0sIHRyYW5zZm9ybSwgdG1wVmVjMyk7XG4gICAgc2V0VmVjMyh0bXBWZWMzLCBlLnNpemUsIGUuc2l6ZSwgZS5zaXplKTtcbiAgICBtYXQ0LnNjYWxlKHRyYW5zZm9ybSwgdHJhbnNmb3JtLCB0bXBWZWMzKTtcbiAgICBlLnRleHQuc2hhZGVyLmJpbmQoKTtcbiAgICBlLnRleHQuc2hhZGVyLnVuaWZvcm1zLmZhZGUgPSBmYWRlO1xuICAgIGUudGV4dC5kcmF3KGNhbWVyYSwgZS5vYmplY3QzZCk7XG59XG5cbmluaGVyaXRzKFRleHRQYXNzLCBCYXNlKTtcblxuVGV4dFBhc3MucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKHJlbmRlcmVyLCB3cml0ZUJ1ZmZlciwgcmVhZEJ1ZmZlciwgZGVsdGEpIHtcbiAgICBCYXNlLnByb3RvdHlwZS5yZW5kZXIuY2FsbCh0aGlzLCByZW5kZXJlciwgd3JpdGVCdWZmZXIsIHJlYWRCdWZmZXIsIGRlbHRhKTtcbiAgICB2YXIgY2FtZXJhID0gdGhpcy5jYW1lcmE7XG5cbiAgICB0aGlzLmdyb3Vwcy5mb3JFYWNoKGZ1bmN0aW9uKGcpIHtcbiAgICAgICAgZy5lbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGlmICghZy5zaG93aW5nKVxuICAgICAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgICAgcmVuZGVyRWxlbWVudChjYW1lcmEsIGUsIGcuZmFkZSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgcmVuZGVyZXIucmVzZXRHTFN0YXRlKCk7XG4gICAgcmVuZGVyZXIucmVzZXRBdHRyaWJ1dGVzKCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRleHRQYXNzO1xufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pIiwiKGZ1bmN0aW9uIChnbG9iYWwpe1xudmFyIFR3ZWVuTWF4ID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cuVHdlZW5NYXggOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsLlR3ZWVuTWF4IDogbnVsbClcbnZhciBjbGFtcCA9IHJlcXVpcmUoJ2NsYW1wJylcbnZhciBzbW9vdGhzdGVwID0gcmVxdWlyZSgnc21vb3Roc3RlcCcpXG5cbnZhciBsYXN0SW5kZXggPSAtMVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGNvbnRyb2xsZXIsIGxhYmVscykge1xuICAgIHZhciBjbG9zZUluZGV4ID0gY2xvc2VzdChjb250cm9sbGVyLCBsYWJlbHMpXG5cbiAgICAvLyBjb25zb2xlLmxvZyhjb250cm9sbGVyLnRoZXRhKVxuICAgIGxhYmVscy5mb3JFYWNoKGZ1bmN0aW9uKGxhYmVsLCBpKSB7XG4gICAgICAgIC8vIHNldFNob3dpbmcobGFiZWwsIHRydWUpXG4gICAgICAgIHZhciB2aXNpYmxlID0gaT09PWNsb3NlSW5kZXhcbiAgICAgICAgaWYgKHZpc2libGUgJiYgIWxhYmVsLnNob3dpbmcpIHtcbiAgICAgICAgICAgIGFuaW1hdGVJbkZlYXR1cmUobGFiZWwpXG4gICAgICAgIH0gZWxzZSBpZiAoIXZpc2libGUgJiYgbGFiZWwuc2hvd2luZykge1xuICAgICAgICAgICAgYW5pbWF0ZU91dEZlYXR1cmUobGFiZWwpXG4gICAgICAgIH1cbiAgICB9KVxufVxuXG5tb2R1bGUuZXhwb3J0cy5oaWRlQWxsID0gZnVuY3Rpb24oZmVhdHVyZXMpIHtcbiAgICBmZWF0dXJlcy5mb3JFYWNoKGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgc2V0U2hvd2luZyhmLCBmYWxzZSlcbiAgICB9KVxufVxuXG5mdW5jdGlvbiBkaXN0YW5jZShjb250cm9sbGVyLCBsYWJlbCkge1xuICAgIC8vc2lnbmVkIGRpc3RhbmNlXG4gICAgdmFyIHggPSAtbGFiZWwudGhldGEsIFxuICAgICAgICB5ID0gY29udHJvbGxlci50aGV0YVxuXG4gICAgdmFyIGFiZGlzdCA9IE1hdGguYWJzKHggLSB5KVxuICAgIHJldHVybiBNYXRoLm1pbigoMiAqIE1hdGguUEkpIC0gYWJkaXN0LCBhYmRpc3QpXG5cbn1cblxuZnVuY3Rpb24gY2xvc2VzdChjb250cm9sbGVyLCBsYWJlbHMpIHtcbiAgICB2YXIgbWluRGlzdCA9IE51bWJlci5NQVhfVkFMVUVcbiAgICB2YXIgcmV0ID0gLTFcbiAgICBsYWJlbHMuZm9yRWFjaChmdW5jdGlvbihsYWJlbCwgaW5kZXgpIHtcbiAgICAgICAgdmFyIGRpc3QgPSBkaXN0YW5jZShjb250cm9sbGVyLCBsYWJlbClcbiAgICAgICAgXG4gICAgICAgIGlmIChkaXN0IDwgbWluRGlzdCkge1xuICAgICAgICAgICAgbWluRGlzdCA9IGRpc3RcbiAgICAgICAgICAgIHJldCA9IGluZGV4XG4gICAgICAgIH1cbiAgICB9KVxuICAgIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gc2V0U2hvd2luZyhmZWF0dXJlLCBzaG93aW5nKSB7XG4gICAgZmVhdHVyZS5zaG93aW5nID0gc2hvd2luZ1xufVxuXG5mdW5jdGlvbiBhbmltYXRlSW5GZWF0dXJlKGZlYXR1cmUpIHtcbiAgICBmZWF0dXJlLnNob3dpbmcgPSB0cnVlXG4gICAgZmVhdHVyZS5mYWRlID0gMFxuICAgIFR3ZWVuTWF4LmtpbGxUd2VlbnNPZihmZWF0dXJlKVxuICAgIFR3ZWVuTWF4LnRvKGZlYXR1cmUsIDAuNSwge1xuICAgICAgICBmYWRlOiAxLjAsXG4gICAgICAgIGVhc2U6IFwiZWFzZU91dFF1YWRcIlxuICAgIH0pXG59XG5cbmZ1bmN0aW9uIGFuaW1hdGVPdXRGZWF0dXJlKGZlYXR1cmUpIHtcbiAgICBpZiAoZmVhdHVyZS5hbmltYXRpbmdPdXQpXG4gICAgICAgIHJldHVyblxuXG4gICAgZmVhdHVyZS5hbmltYXRpbmdPdXQgPSB0cnVlXG4gICAgVHdlZW5NYXgudG8oZmVhdHVyZSwgMC41LCB7XG4gICAgICAgIGZhZGU6IDAsXG4gICAgICAgIGVhc2U6ICdlYXNlT3V0UXVhZCcsXG4gICAgICAgIG9uQ29tcGxldGU6IGhpZGVGZWF0dXJlLmJpbmQobnVsbCwgZmVhdHVyZSlcbiAgICB9KVxufVxuXG5mdW5jdGlvbiBoaWRlRmVhdHVyZShmZWF0dXJlKSB7XG4gICAgZmVhdHVyZS5hbmltYXRpbmdPdXQgPSBmYWxzZVxuICAgIGZlYXR1cmUuc2hvd2luZyA9IGZhbHNlXG59XG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSkiLCJ2YXIgRm9udCA9IHJlcXVpcmUoJy4uL2ZvbnRzL0V4bzJTZW1pQm9sZC5qc29uJylcbnZhciBmb250SW1hZ2UgPSAnZm9udHMvRXhvMlNlbWlCb2xkLnBuZydcbnZhciBpbWcgPSByZXF1aXJlKCdpbWcnKVxudmFyIGNyZWF0ZVRleHR1cmUgPSByZXF1aXJlKCdnbC10ZXh0dXJlMmQnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGdsLCBjYikge1xuICAgIGltZyhmb250SW1hZ2UsIGZ1bmN0aW9uKGVyciwgcmVzKSB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIGNiKGVycilcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgRm9udC50ZXh0dXJlcyA9IFtyZXNdLm1hcChmdW5jdGlvbihpKSB7XG4gICAgICAgICAgICB2YXIgdCA9IGNyZWF0ZVRleHR1cmUoZ2wsIGkpXG5cbiAgICAgICAgICAgIHQubWluRmlsdGVyID0gZ2wuTElORUFSX01JUE1BUF9MSU5FQVJcbiAgICAgICAgICAgIHQubWFnRmlsdGVyID0gZ2wuTElORUFSXG5cbiAgICAgICAgICAgIHZhciBleHQgPSAoZ2wuZ2V0RXh0ZW5zaW9uKCdFWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWMnKSBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB8fCBnbC5nZXRFeHRlbnNpb24oXCJNT1pfRVhUX3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljXCIpKTtcbiAgICAgICAgICAgIGlmIChleHQpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWF4QW5pc3Ryb3BoeSA9IGdsLmdldFBhcmFtZXRlcihleHQuTUFYX1RFWFRVUkVfTUFYX0FOSVNPVFJPUFlfRVhUKTtcbiAgICAgICAgICAgICAgICBnbC50ZXhQYXJhbWV0ZXJmKGdsLlRFWFRVUkVfMkQsIGV4dC5URVhUVVJFX01BWF9BTklTT1RST1BZX0VYVCwgTWF0aC5taW4oMTYsIG1heEFuaXN0cm9waHkpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdC5nZW5lcmF0ZU1pcG1hcCgpXG4gICAgICAgICAgICByZXR1cm4gdFxuICAgICAgICB9KVxuICAgICAgICBcbiAgICAgICAgY2IobnVsbCwgRm9udClcbiAgICB9KVxufSIsIihmdW5jdGlvbiAoZ2xvYmFsKXtcbnZhciBUZXh0UGFzcyA9IHJlcXVpcmUoJy4vVGV4dFBhc3MnKVxudmFyIFRIUkVFID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cuVEhSRUUgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsLlRIUkVFIDogbnVsbClcbnZhciB4dGVuZCA9IHJlcXVpcmUoJ3h0ZW5kJylcbnZhciBnZXRTVkcgPSByZXF1aXJlKCcuL2dldC1zdmcnKVxudmFyIGdldFBvbHkgPSByZXF1aXJlKCcuL2dldC1wb2x5Z29uJylcbnZhciBDb21wbGV4ID0gcmVxdWlyZSgndGhyZWUtc2ltcGxpY2lhbC1jb21wbGV4JykoVEhSRUUpXG5cbnZhciBVTklUX1NDQUxFID0gMC4xXG5cbnZhciBkYXRhID0gcmVxdWlyZSgnLi90ZXh0LWRhdGEnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9wdCkge1xuICAgIHZhciBncm91cHMgPSBjcmVhdGVHcm91cHMoKVxuICAgIFxuICAgIGdyb3Vwcy5mb3JFYWNoKGZ1bmN0aW9uKGdyb3VwKSB7XG4gICAgICAgIC8vIHZhciBsZW4gPSAxMDBcbiAgICAgICAgLy8gdmFyIGRpciA9IG5ldyBUSFJFRS5WZWN0b3IzKE1hdGguY29zKGdyb3VwLnRoZXRhKSwgMCwgTWF0aC5zaW4oZ3JvdXAudGhldGEpKVxuICAgICAgICAvLyB2YXIgYXJyb3cgPSBuZXcgVEhSRUUuQXJyb3dIZWxwZXIoZGlyLCBuZXcgVEhSRUUuVmVjdG9yMygpLCBsZW4pXG4gICAgICAgIC8vIG9wdC5zY2VuZS5hZGQoYXJyb3cpXG5cbiAgICAgICAgZ3JvdXAucGFuZWxzLmZvckVhY2goZnVuY3Rpb24ocGFuZWwpIHtcbiAgICAgICAgICAgIG9wdC5zY2VuZS5hZGQocGFuZWwuY29udGFpbmVyKVxuICAgICAgICB9KVxuICAgIH0pXG5cbiAgICByZXR1cm4gVGV4dFBhc3MoeHRlbmQob3B0LCB7XG4gICAgICAgIGdyb3VwczogZ3JvdXBzXG4gICAgfSkpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUdyb3VwcygpIHtcbiAgICByZXR1cm4gZGF0YS5tYXAoZnVuY3Rpb24oZ3JvdXAsIGksIGxpc3QpIHtcbiAgICAgICAgdmFyIHRoZXRhID0gaS8obGlzdC5sZW5ndGgrMSkgKiBNYXRoLlBJICogMlxuICAgICAgICBncm91cCA9IHh0ZW5kKGdyb3VwLCB7XG4gICAgICAgICAgICBwYW5lbHM6IGdyb3VwLnBhbmVscy5tYXAoZnVuY3Rpb24ocGFuZWwsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVBhbmVsKHBhbmVsLCBpbmRleCwgdGhldGEpXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHRoZXRhOiB0aGV0YVxuICAgICAgICB9KVxuICAgICAgICByZXR1cm4gZ3JvdXBcbiAgICB9KVxufVxuXG5mdW5jdGlvbiBjcmVhdGVQYW5lbChkYXRhLCBpbmRleCwgcm90YXRpb24pIHtcbiAgICB2YXIgY29udGFpbmVyID0gbmV3IFRIUkVFLk9iamVjdDNEKClcbiAgICB2YXIgbWlycm9yID0gaW5kZXggPT09IDFcblxuICAgIHZhciByYWRpdXMgPSAyMFxuICAgIGlmIChtaXJyb3IpIHtcbiAgICAgICAgcm90YXRpb24gKz0gTWF0aC5QSSoyXG4gICAgICAgIHJhZGl1cyAqPSAtMVxuICAgIH1cblxuICAgIC8vbWFrZSB0ZXh0IHBlcnBlbmRpY3VsYXIgdG8gdGhldGEgcm90YXRpb25cbiAgICAvLyByb3RhdGlvbiAtPSBNYXRoLlBJLzIgXG5cbiAgICBjb250YWluZXIucG9zaXRpb24uc2V0KFxuICAgICAgICBNYXRoLmNvcyhyb3RhdGlvbikgKiByYWRpdXMsXG4gICAgICAgIDE1LFxuICAgICAgICBNYXRoLnNpbihyb3RhdGlvbikgKiByYWRpdXNcbiAgICApXG4gICAgXG5cbiAgICAvLyBjb250YWluZXIucG9zaXRpb24uY29weShkYXRhLm9yaWdpbilcblxuICAgIHZhciBwb3MgPSBjb250YWluZXIucG9zaXRpb25cbiAgICB2YXIgZGlyID0gcG9zLmNsb25lKCkuc3ViKG5ldyBUSFJFRS5WZWN0b3IzKDAscG9zLnksMCkpLm5vcm1hbGl6ZSgpXG5cbiAgICB2YXIgcm90T2ZmID0gMC8vTWF0aC5QSS8xMCAqIChtaXJyb3IgPyAtMSA6IDEpXG5cbiAgICB2YXIgZHggPSBwb3MueCxcbiAgICAgICAgZHogPSBwb3MueixcbiAgICAgICAgdGhldGEgPSAtTWF0aC5hdGFuMihkeiwgZHgpIC0gcm90T2ZmXG4gICAgLy8gY29udGFpbmVyLnJvdGF0aW9uLnkgPSB0aGV0YVxuICAgIGNvbnRhaW5lci5yb3RhdGlvbi55ID0gdGhldGFcbiAgICBjb250YWluZXIucm90YXRpb24ueCA9IDBcbiAgICBcbiAgICBpZiAobWlycm9yKSB7XG4gICAgICAgIGNvbnRhaW5lci5zY2FsZS54ICo9IC0xXG4gICAgfVxuXG4gICAgdmFyIGxhYmVscyA9IGRhdGEubGFiZWxzLm1hcChmdW5jdGlvbihsYWJlbCkge1xuICAgICAgICB2YXIgb2JqID0gbmV3IFRIUkVFLk9iamVjdDNEKClcbiAgICAgICAgY29udGFpbmVyLmFkZChvYmopXG4gICAgICAgIGlmIChtaXJyb3IpXG4gICAgICAgICAgICBvYmoucG9zaXRpb24ueCA9IC1kYXRhLndpZHRofHwwXG4gICAgICAgIHJldHVybiB4dGVuZCh7IHNpemU6IDEsIHRyYW5zbGF0aW9uOiBbMCwgMCwgMF0gfSwgbGFiZWwsIHsgXG4gICAgICAgICAgICBvYmplY3QzZDogb2JqLCBcbiAgICAgICAgICAgIC8vIHRoZXRhOiB0aGV0YVxuICAgICAgICB9KVxuICAgIH0pXG5cbiAgICB2YXIgc2hhcGVzID0gKGRhdGEuc2hhcGVzfHxbXSkubWFwKGZ1bmN0aW9uKHNoYXBlKSB7XG4gICAgICAgIHZhciBjb21wbGV4ID0gc2hhcGUucGF0aCA/IGdldFNWRyhzaGFwZS5wYXRoKSA6IGdldFBvbHkoc2hhcGUucG9pbnRzKVxuICAgICAgICB2YXIgZ2VvID0gQ29tcGxleChjb21wbGV4KVxuICAgICAgICB2YXIgbWVzaCA9IG5ldyBUSFJFRS5NZXNoKGdlbywgbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKHsgXG4gICAgICAgICAgICBjb2xvcjogMHhmZmZmZmYsXG4gICAgICAgICAgICBzaWRlOiBUSFJFRS5Eb3VibGVTaWRlLFxuICAgICAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgICAgIHRyYW5zcGFyZW50OiB0cnVlXG4gICAgICAgIH0pKVxuICAgICAgICBcbiAgICAgICAgaWYgKHNoYXBlLnBvc2l0aW9uKSBtZXNoLnBvc2l0aW9uLmZyb21BcnJheShzaGFwZS5wb3NpdGlvbilcbiAgICAgICAgaWYgKHNoYXBlLnNjYWxlKSBtZXNoLnNjYWxlLmZyb21BcnJheShzaGFwZS5zY2FsZSlcblxuICAgICAgICBjb250YWluZXIuYWRkKG1lc2gpXG4gICAgICAgIHJldHVybiBtZXNoXG4gICAgfSlcblxuICAgIHJldHVybiB7XG4gICAgICAgIGxhYmVsczogbGFiZWxzLFxuICAgICAgICBzaGFwZXM6IHNoYXBlcyxcbiAgICAgICAgY29udGFpbmVyOiBjb250YWluZXJcbiAgICB9XG59XG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSkiLCJ2YXIgdHJpYW5ndWxhdGUgPSByZXF1aXJlKCd0cmlhbmd1bGF0ZS1jb250b3VycycpXG52YXIgbm9ybWFsaXplID0gcmVxdWlyZSgnbm9ybWFsaXplLXBhdGgtc2NhbGUnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHBvaW50cykge1xuICAgIHBvaW50cyA9IHBvaW50cy5zcGxpdCgnICcpLm1hcChmdW5jdGlvbihwKSB7XG4gICAgICAgIHJldHVybiBwLnNwbGl0KCcsJykubWFwKGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUZsb2F0KG4sIDEwKVxuICAgICAgICB9KVxuICAgIH0pXG5cbiAgICBwb2ludHMgPSBub3JtYWxpemUocG9pbnRzKVxuXG4gICAgdmFyIHRyaWFuZ3VsYXRlZCA9IHRyaWFuZ3VsYXRlKFsgcG9pbnRzIF0pXG4gICAgdHJpYW5ndWxhdGVkLnBvc2l0aW9ucyA9IHRyaWFuZ3VsYXRlZC5wb3NpdGlvbnMubWFwKGZ1bmN0aW9uKHApIHtcbiAgICAgICAgcmV0dXJuIFtwWzBdLCBwWzFdLCAwXVxuICAgIH0pXG4gICAgcmV0dXJuIHRyaWFuZ3VsYXRlZFxufSIsInZhciBwYXJzZSA9IHJlcXVpcmUoJ3BhcnNlLXN2Zy1wYXRoJylcbnZhciBjb250b3VycyA9IHJlcXVpcmUoJ3N2Zy1wYXRoLWNvbnRvdXJzJylcbnZhciBzaW1wbGlmeSA9IHJlcXVpcmUoJ3NpbXBsaWZ5LXBhdGgnKVxudmFyIHRyaWFuZ3VsYXRlID0gcmVxdWlyZSgndHJpYW5ndWxhdGUtY29udG91cnMnKVxudmFyIG5vcm1hbGl6ZSA9IHJlcXVpcmUoJ25vcm1hbGl6ZS1wYXRoLXNjYWxlJylcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihjb250ZW50cykge1xuICAgIHZhciBwYXJzZWQgPSBwYXJzZShjb250ZW50cylcbiAgICBjb25zb2xlLmxvZyhwYXJzZWQsIGNvbnRlbnRzKVxuICAgIC8vZ2V0IGEgbGlzdCBvZiBwb2x5bGluZXMvY29udG91cnMgZnJvbSBzdmcgY29udGVudHNcbiAgICB2YXIgbGluZXMgPSBjb250b3VycyhwYXJzZWQpXG5cbiAgICAvL3NpbXBsaWZ5IHRoZSBjb250b3VycyBiZWZvcmUgdHJpYW5ndWxhdGlvblxuICAgIC8vIGxpbmVzID0gbGluZXMubWFwKGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAvLyAgICAgcmV0dXJuIHNpbXBsaWZ5KHBhdGgsIHRocmVzaG9sZClcbiAgICAvLyB9KVxuICAgIFxuICAgIC8vdHVybnMgaW50byB0cmlhbmdsZXMsIHJldHVybnMgeyBwb3NpdGlvbnMsIGNlbGxzIH1cbiAgICB2YXIgc2hhcGUgPSB0cmlhbmd1bGF0ZShsaW5lcylcblxuICAgIC8vbm9ybWFsaXplKHNoYXBlLnBvc2l0aW9ucylcblxuICAgIHNoYXBlLnBvc2l0aW9ucyA9IHNoYXBlLnBvc2l0aW9ucy5tYXAoZnVuY3Rpb24ocCkge1xuICAgICAgICByZXR1cm4gW3BbMF0sIHBbMV0sIDBdXG4gICAgfSlcbiAgICByZXR1cm4gc2hhcGVcbn0iLCIoZnVuY3Rpb24gKGdsb2JhbCl7XG52YXIgVEhSRUUgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdy5USFJFRSA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwuVEhSRUUgOiBudWxsKVxuXG52YXIgUmlnU2NlbmUgPSByZXF1aXJlKCcuL1JpZ1NjZW5lJylcbnZhciBPcmJpdENvbnRyb2xsZXIgPSByZXF1aXJlKCcuL3RocmVlLW9yYml0LWNhbWVyYScpKFRIUkVFKVxudmFyIEVmZmVjdHMgPSByZXF1aXJlKCcuL3NldHVwLWVmZmVjdHMnKVxuXG52YXIgVHdlZW5NYXggPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdy5Ud2Vlbk1heCA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwuVHdlZW5NYXggOiBudWxsKVxudmFyIGFuaW1hdGVMYWJlbHMgPSByZXF1aXJlKCcuL2FuaW1hdGUtbGFiZWxzJylcbnZhciBoaWRlTGFiZWxzID0gYW5pbWF0ZUxhYmVscy5oaWRlQWxsXG5cbnZhciBjbGFtcCA9IHJlcXVpcmUoJ2NsYW1wJylcbnZhciBwbHVjayA9IHJlcXVpcmUoJ3BsdWNrZXInKVxudmFyIG51bWJlciA9IHJlcXVpcmUoJ2FzLW51bWJlcicpXG52YXIgc21vb3Roc3RlcCA9IHJlcXVpcmUoJ3Ntb290aHN0ZXAnKVxudmFyIGxlcnAgPSByZXF1aXJlKCdsZXJwJylcbnZhciB1bmxlcnAgPSByZXF1aXJlKCd1bmxlcnAnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9wdCkge1xuICAgIG9wdCA9IG9wdHx8e31cblxuICAgIHZhciBGb250ID0gb3B0LmZvbnRcblxuICAgIGlmICghRm9udCB8fCAhRm9udC50ZXh0dXJlcylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtdXN0IHNwZWNpZnkgZm9udCB3aXRoIHRleHR1cmVzJylcblxuICAgIHZhciByZW5kZXJlcixcbiAgICAgICAgc2NlbmUsXG4gICAgICAgIGNhbWVyYSxcbiAgICAgICAgY29udHJvbGxlcixcbiAgICAgICAgZmVhdHVyZXMsXG4gICAgICAgIHdhdGVyLFxuICAgICAgICBlZmZlY3RzLFxuICAgICAgICBsYWJlbHMgPSBbXSxcbiAgICAgICAgdGltZSA9IDBcblxuICAgIGlmICghb3B0LmdsKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ211c3Qgc3BlY2lmeSBHTCBjb250ZXh0JylcblxuICAgIHNldHVwKG9wdC5nbCwgb3B0LndpZHRofHwwLCBvcHQuaGVpZ2h0fHwwKVxuXG4gICAgZnVuY3Rpb24gZHJhdyhkdCkge1xuICAgICAgICB0aW1lICs9ICBNYXRoLm1pbihkdCwgMzApIC8gMTAwMFxuICAgICAgICByZW5kZXJlci5yZXNldEF0dHJpYnV0ZXMoKVxuICAgICAgICByZW5kZXJlci5yZXNldEdMU3RhdGUoKVxuXG4gICAgICAgIHdhdGVyLm1hdGVyaWFsLnVuaWZvcm1zLnRpbWUudmFsdWUgPSB0aW1lICogMC4xXG4gICAgICAgIHdhdGVyLnJlbmRlcigpXG5cbiAgICAgICAgY29udHJvbGxlci51cGRhdGUoKVxuICAgICAgICBcbiAgICAgICAgc2NlbmUudXBkYXRlKGR0KVxuICAgICAgICBlZmZlY3RzLnJlbmRlcihkdClcblxuICAgICAgICBhbmltYXRlTGFiZWxzKGNvbnRyb2xsZXIsIGxhYmVscylcblxuICAgICAgICB2YXIgdCA9IHVubGVycCgwLjYsIDEuNCwgY29udHJvbGxlci5waGkpXG4gICAgICAgIHQgPSBzbW9vdGhzdGVwKDEuNCwgMC40NSwgdClcbiAgICAgICAgdmFyIHJhbmdlID0gY2xhbXAodCwgMCwgMSlcbiAgICAgICAgd2F0ZXIuYWxwaGEgPSByYW5nZXx8MFxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldHVwKGdsLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHJlbmRlcmVyID0gbmV3IFRIUkVFLldlYkdMUmVuZGVyZXIoeyBcbiAgICAgICAgICAgIGNhbnZhczogZ2wuY2FudmFzLFxuICAgICAgICAgICAgYW50aWFsaWFzOiBmYWxzZSxcbiAgICAgICAgICAgIGFscGhhOiBmYWxzZVxuICAgICAgICB9KVxuICAgICAgICByZW5kZXJlci5zZXRDbGVhckNvbG9yKDB4ZmZmZmZmLCAwKVxuICAgICAgICByZW5kZXJlci5zaGFkb3dNYXBUeXBlID0gVEhSRUUuQmFzaWNTaGFkb3dNYXBcbiAgICAgICAgLy8gcmVuZGVyZXIuc2hhZG93TWFwRW5hYmxlZCA9IHRydWVcblxuICAgICAgICBvcHQuZm92ID0gbnVtYmVyKG9wdC5mb3YsIDUwKVxuICAgICAgICBjYW1lcmEgPSBuZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEob3B0LmZvdiwgd2lkdGgvaGVpZ2h0LCAwLjUsIDIwMDAwKVxuICAgICAgICBjYW1lcmEucG9zaXRpb24ueCA9IC02MFxuICAgICAgICBjYW1lcmEucG9zaXRpb24ueiA9IC00MFxuICAgICAgICBjYW1lcmEucG9zaXRpb24ueSA9IDM4XG4gICAgICAgIGNhbWVyYS5sb29rQXQobmV3IFRIUkVFLlZlY3RvcjMoKSlcblxuICAgICAgICBjb250cm9sbGVyID0gbmV3IE9yYml0Q29udHJvbGxlcihjYW1lcmEpXG4gICAgICAgIGNvbnRyb2xsZXIudXNlclBhbiA9IGZhbHNlXG4gICAgICAgIGNvbnRyb2xsZXIudXNlclBhblNwZWVkID0gMC4wXG4gICAgICAgIGNvbnRyb2xsZXIuem9vbVNwZWVkID0gMC4xXG4gICAgICAgIGNvbnRyb2xsZXIucm90YXRlU3BlZWQgPSAwLjJcbiAgICAgICAgY29udHJvbGxlci5taW5EaXN0YW5jZSA9IDMwXG4gICAgICAgIGNvbnRyb2xsZXIubWF4RGlzdGFuY2UgPSAyMDAuMFxuICAgICAgICBjb250cm9sbGVyLm1heFBvbGFyQW5nbGUgPSA5MCAqIE1hdGguUEkvMTgwXG4gICAgICAgIGNvbnRyb2xsZXIubWluUG9sYXJBbmdsZSA9IDQwICogTWF0aC5QSS8xODBcbiAgICAgICAgY29udHJvbGxlci5jZW50ZXIuc2V0KCAwLCA1LCAwIClcbiAgICAgICAgc2NlbmUgPSBSaWdTY2VuZSgpXG5cbiAgICAgICAgd2F0ZXIgPSByZXF1aXJlKCcuL3NldHVwLXdhdGVyJykocmVuZGVyZXIsIGNhbWVyYSwgc2NlbmUpXG4gICAgICAgIFxuICAgICAgICBzY2VuZS5jdWJlTWFwID0gd2F0ZXIuY3ViZU1hcFxuICAgICAgICBzY2VuZS51cGRhdGVNYXRlcmlhbCgpXG5cbiAgICAgICAgdmFyIHBhc3MgPSByZXF1aXJlKCcuL2NyZWF0ZS10ZXh0LXBhc3MnKSh7XG4gICAgICAgICAgICByZW5kZXJlcjogcmVuZGVyZXIsXG4gICAgICAgICAgICBzY2VuZTogc2NlbmUsXG4gICAgICAgICAgICBjYW1lcmE6IGNhbWVyYSxcbiAgICAgICAgICAgIGZvbnQ6IEZvbnRcbiAgICAgICAgfSlcblxuICAgICAgICBsYWJlbHMgPSBwYXNzLmdyb3Vwc1xuXG4gICAgICAgIGVmZmVjdHMgPSBFZmZlY3RzKHtcbiAgICAgICAgICAgIHJlbmRlcmVyOiByZW5kZXJlcixcbiAgICAgICAgICAgIHNjZW5lOiBzY2VuZSxcbiAgICAgICAgICAgIGNhbWVyYTogY2FtZXJhLFxuICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgYmx1cjogZmFsc2UsXG4gICAgICAgICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgICAgIHJlbmRlclBhc3M6IHBhc3NcbiAgICAgICAgfSlcblxuICAgICAgICBoaWRlTGFiZWxzKGxhYmVscylcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVSZXNpemUod2lkdGgsIGhlaWdodCkge1xuICAgICAgICByZW5kZXJlci5zZXRTaXplKHdpZHRoLCBoZWlnaHQpXG4gICAgICAgIGNhbWVyYS5hc3BlY3QgPSB3aWR0aC9oZWlnaHRcbiAgICAgICAgY2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKVxuXG4gICAgICAgIGVmZmVjdHMucmVzaXplKHdpZHRoLCBoZWlnaHQpXG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgZHJhdzogZHJhdyxcbiAgICAgICAgcmVzaXplOiBoYW5kbGVSZXNpemVcbiAgICB9XG59XG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSkiLCIoZnVuY3Rpb24gKGdsb2JhbCl7XG52YXIgVEhSRUUgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdy5USFJFRSA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwuVEhSRUUgOiBudWxsKVxudmFyIEVmZmVjdENvbXBvc2VyID0gcmVxdWlyZSgndGhyZWUtZWZmZWN0Y29tcG9zZXInKShUSFJFRSlcbnZhciBjcmVhdGVGWEFBID0gcmVxdWlyZSgndGhyZWUtc2hhZGVyLWZ4YWEnKShUSFJFRSlcbnZhciBjcmVhdGVCbHVyID0gcmVxdWlyZSgnLi9zaGFkZXJzL2JsdXInKVxudmFyIGNyZWF0ZUxlbnMgPSByZXF1aXJlKCcuL3NoYWRlcnMvbGVucycpXG52YXIgY3JlYXRlRW1wdHkgPSByZXF1aXJlKCcuL3NoYWRlcnMvcGFzcycpXG4vLyB2YXIgVGV4dFBhc3MgPSByZXF1aXJlKCcuL1RleHRQYXNzJylcblxubW9kdWxlLmV4cG9ydHMgPSBFZmZlY3RzXG5cbmZ1bmN0aW9uIEVmZmVjdHMob3B0KSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEVmZmVjdHMpKSBcbiAgICAgICAgcmV0dXJuIG5ldyBFZmZlY3RzKG9wdClcbiAgICBvcHQgPSBvcHR8fHt9XG5cblxuICAgIHZhciBwYXJhbWV0ZXJzID0geyBcbiAgICAgICAgbWluRmlsdGVyOiBUSFJFRS5MaW5lYXJGaWx0ZXIsIFxuICAgICAgICBtYWdGaWx0ZXI6IFRIUkVFLkxpbmVhckZpbHRlciwgXG4gICAgICAgIGZvcm1hdDogVEhSRUUuUkdCRm9ybWF0LCBcbiAgICAgICAgc3RlbmNpbEJ1ZmZlcjogZmFsc2UgXG4gICAgfVxuICAgIHZhciB3aWR0aCA9IG9wdC53aWR0aFxuICAgIHZhciBoZWlnaHQgPSBvcHQuaGVpZ2h0XG4gICAgdmFyIHJlbmRlclRhcmdldCA9IG5ldyBUSFJFRS5XZWJHTFJlbmRlclRhcmdldCh3aWR0aCwgaGVpZ2h0LCBwYXJhbWV0ZXJzKTtcblxuICAgIHRoaXMuY29tcG9zZXIgPSBuZXcgRWZmZWN0Q29tcG9zZXIob3B0LnJlbmRlcmVyLCByZW5kZXJUYXJnZXQpXG4gICAgdGhpcy5jb21wb3Nlci5hZGRQYXNzKG9wdC5yZW5kZXJQYXNzKVxuICAgIFxuICAgIHRoaXMuc2hhZGVycyA9IFtdXG4gICAgdGhpcy5ub2lzZURlbGF5ID0gMzNcbiAgICB0aGlzLm5vaXNlVGltZSA9IDBcblxuICAgIC8vIHRoaXMuc2hhZGVycy5wdXNoKG5ldyBFZmZlY3RDb21wb3Nlci5TaGFkZXJQYXNzKGNyZWF0ZUVtcHR5KCkpKVxuXG5cbiAgICB2YXIgZnhhYVNoYWRlciA9IG5ldyBFZmZlY3RDb21wb3Nlci5TaGFkZXJQYXNzKGNyZWF0ZUZYQUEoKSlcbiAgICB0aGlzLnNoYWRlcnMucHVzaChmeGFhU2hhZGVyKVxuXG4gICAgaWYgKG9wdC5ibHVyICE9PSBmYWxzZSkge1xuICAgICAgICB2YXIgYmx1ciA9IGNyZWF0ZUJsdXIoKVxuICAgICAgICB2YXIgaXRlcmF0aW9ucyA9IDE7XG4gICAgICAgIGZvciAodmFyIGk9MDsgaTxpdGVyYXRpb25zOyBpKyspIHtcbiAgICAgICAgICAgIHZhciByID0gKGkrMSkqMjtcblxuICAgICAgICAgICAgdmFyIGhvcml6ID0gbmV3IEVmZmVjdENvbXBvc2VyLlNoYWRlclBhc3MoIGJsdXIgKTtcbiAgICAgICAgICAgIGhvcml6LnVuaWZvcm1zLnJhZGl1cy52YWx1ZSA9IHJcbiAgICAgICAgICAgIGhvcml6LnVuaWZvcm1zLnN0cmVuZ3RoLnZhbHVlID0gMVxuICAgICAgICAgICAgaG9yaXoudW5pZm9ybXMuZGlyLnZhbHVlLnNldCgxLDApXG5cbiAgICAgICAgICAgIHZhciB2ZXJ0ID0gbmV3IEVmZmVjdENvbXBvc2VyLlNoYWRlclBhc3MoIGJsdXIgKTtcbiAgICAgICAgICAgIHZlcnQudW5pZm9ybXMucmFkaXVzLnZhbHVlID0gclxuICAgICAgICAgICAgdmVydC51bmlmb3Jtcy5zdHJlbmd0aC52YWx1ZSA9IDFcbiAgICAgICAgICAgIHZlcnQudW5pZm9ybXMuZGlyLnZhbHVlLnNldCgwLDEpXG5cbiAgICAgICAgICAgIHRoaXMuc2hhZGVycy5wdXNoKGhvcml6LCB2ZXJ0KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGxlbnNQYXNzID0gbmV3IEVmZmVjdENvbXBvc2VyLlNoYWRlclBhc3MoY3JlYXRlTGVucygpKVxuICAgIHRoaXMuc2hhZGVycy5wdXNoKGxlbnNQYXNzKVxuXG4gICAgLy9kZWZhdWx0IHZhbHVlcyB0byBhdm9pZCBkaXYgYnkgemVyb1xuICAgIGxlbnNQYXNzLnVuaWZvcm1zLm92ZXJsYXlSZXNvbHV0aW9uLnZhbHVlLnNldCgxLCAxKVxuICAgIGxlbnNQYXNzLnVuaWZvcm1zLnRMb29rdXAudmFsdWUgPSBsb2FkVGV4dHVyZSgnaW1nL2xvb2t1cC5wbmcnLCB7IFxuICAgICAgICBnZW5lcmF0ZU1pcG1hcHM6IGZhbHNlLFxuICAgICAgICBmaWx0ZXI6IFRIUkVFLkxpbmVhckZpbHRlciBcbiAgICB9KVxuICAgIGxlbnNQYXNzLnVuaWZvcm1zLnRPdmVybGF5LnZhbHVlID0gbG9hZFRleHR1cmUoJ2ltZy9kdXN0LmpwZycsIHtcbiAgICAgICAgZ2VuZXJhdGVNaXBtYXBzOiBmYWxzZSxcbiAgICAgICAgZmlsdGVyOiBUSFJFRS5MaW5lYXJGaWx0ZXJcbiAgICB9LCBmdW5jdGlvbihlcnIsIHRleCkge1xuICAgICAgICBsZW5zUGFzcy51bmlmb3Jtcy5vdmVybGF5UmVzb2x1dGlvbi52YWx1ZS5zZXQodGV4LmltYWdlLndpZHRoLCB0ZXguaW1hZ2UuaGVpZ2h0KVxuICAgIH0pXG5cbiAgICB0aGlzLnNoYWRlcnMuZm9yRWFjaChmdW5jdGlvbihwYXNzLCBpLCBzZWxmKSB7XG4gICAgICAgIHRoaXMuY29tcG9zZXIuYWRkUGFzcyhwYXNzKVxuICAgICAgICBpZiAoaSA9PT0gc2VsZi5sZW5ndGgtMSlcbiAgICAgICAgICAgIHBhc3MucmVuZGVyVG9TY3JlZW4gPSB0cnVlXG4gICAgfSwgdGhpcykgIFxuICAgIGlmIChvcHQud2lkdGggJiYgb3B0LmhlaWdodCkgXG4gICAgICAgIHRoaXMucmVzaXplKG9wdC53aWR0aCwgb3B0LmhlaWdodClcbn1cblxuXG5mdW5jdGlvbiBsb2FkVGV4dHVyZShwYXRoLCBvcHQsIGNiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY2IgPSBvcHRcbiAgICAgICAgb3B0ID0ge31cbiAgICB9XG5cbiAgICByZXR1cm4gVEhSRUUuSW1hZ2VVdGlscy5sb2FkVGV4dHVyZShwYXRoLCB1bmRlZmluZWQsIGZ1bmN0aW9uKHRleCkge1xuICAgICAgICBpZiAob3B0LmZpbHRlcikgdGV4Lm1pbkZpbHRlciA9IHRleC5tYWdGaWx0ZXIgPSBvcHQuZmlsdGVyXG4gICAgICAgIGlmIChvcHQud3JhcCkgdGV4LndyYXBTID0gdGV4LndyYXBUID0gb3B0LndyYXBcbiAgICAgICAgdGV4LmdlbmVyYXRlTWlwbWFwcyA9IG9wdC5nZW5lcmF0ZU1pcG1hcHNcbiAgICAgICAgaWYgKHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJykgXG4gICAgICAgICAgICBjYihudWxsLCB0ZXgpXG4gICAgfSlcbn1cblxucmVxdWlyZSgnbWl4ZXMnKShFZmZlY3RzLCB7XG5cbiAgICByZW5kZXI6IGZ1bmN0aW9uKGR0KSB7XG4gICAgICAgIHRoaXMubm9pc2VUaW1lICs9IGR0XG4gICAgICAgIGlmICh0aGlzLm5vaXNlVGltZSA+IHRoaXMubm9pc2VEZWxheSkge1xuICAgICAgICAgICAgdGhpcy5ub2lzZVRpbWUgPSAwXG4gICAgICAgICAgICB0aGlzLnNoYWRlcnMuZm9yRWFjaChmdW5jdGlvbihwYXNzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhc3MudW5pZm9ybXMudGljaylcbiAgICAgICAgICAgICAgICAgICAgcGFzcy51bmlmb3Jtcy50aWNrLnZhbHVlICs9IDAuMDA1XG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jb21wb3Nlci5yZW5kZXIoKVxuICAgIH0sXG5cbiAgICByZXNpemU6IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgd2lkdGggKj0gMlxuICAgICAgICBoZWlnaHQgKj0gMlxuICAgICAgICB0aGlzLmNvbXBvc2VyLnNldFNpemUod2lkdGgsIGhlaWdodClcbiAgICAgICAgdGhpcy5zaGFkZXJzLmZvckVhY2goZnVuY3Rpb24ocGFzcykge1xuICAgICAgICAgICAgdmFyIGRwciA9IDFcbiAgICAgICAgICAgIC8vIHZhciBkcHIgPSAod2luZG93LmRldmljZVBpeGVsUmF0aW98fDEpXG4gICAgICAgICAgICBpZiAocGFzcy51bmlmb3Jtcy5yZXNvbHV0aW9uKVxuICAgICAgICAgICAgICAgIHBhc3MudW5pZm9ybXMucmVzb2x1dGlvbi52YWx1ZS5zZXQod2lkdGgqZHByLCBoZWlnaHQqZHByKVxuICAgICAgICAgICAgXG4gICAgICAgIH0pXG4gICAgfVxufSlcbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KSIsInZhciBjdWJlU2hhZGVyID0ge1xuXG4gICAgdW5pZm9ybXM6IFRIUkVFLlVuaWZvcm1zVXRpbHMubWVyZ2UoIFtcbiAgICAgICAgeyBcInRDdWJlXCI6IHsgdHlwZTogXCJ0XCIsIHZhbHVlOiBudWxsIH0sXG4gICAgICAgIFwidEZsaXBcIjogeyB0eXBlOiBcImZcIiwgdmFsdWU6IC0gMSB9IH0sXG4gICAgICAgIFRIUkVFLlVuaWZvcm1zTGliWyBcImZvZ1wiIF1cbiAgICBdICksXG5cbiAgICB2ZXJ0ZXhTaGFkZXI6IFtcblxuICAgICAgICBcInZhcnlpbmcgdmVjMyB2V29ybGRQb3NpdGlvbjtcIixcblxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleFwiIF0sXG5cbiAgICAgICAgXCJ2b2lkIG1haW4oKSB7XCIsXG5cbiAgICAgICAgXCIgICB2ZWM0IHdvcmxkUG9zaXRpb24gPSBtb2RlbE1hdHJpeCAqIHZlYzQoIHBvc2l0aW9uLCAxLjAgKTtcIixcbiAgICAgICAgXCIgICB2V29ybGRQb3NpdGlvbiA9IHdvcmxkUG9zaXRpb24ueHl6O1wiLFxuXG4gICAgICAgIFwiICAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApO1wiLFxuXG4gICAgICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl92ZXJ0ZXhcIiBdLFxuXG4gICAgICAgIFwifVwiXG5cbiAgICBdLmpvaW4oXCJcXG5cIiksXG5cbiAgICBmcmFnbWVudFNoYWRlcjogW1xuXG4gICAgICAgIFwidW5pZm9ybSBzYW1wbGVyQ3ViZSB0Q3ViZTtcIixcbiAgICAgICAgXCJ1bmlmb3JtIGZsb2F0IHRGbGlwO1wiLFxuXG4gICAgICAgIFwidmFyeWluZyB2ZWMzIHZXb3JsZFBvc2l0aW9uO1wiLFxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50XCIgXSxcbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiZm9nX3BhcnNfZnJhZ21lbnRcIiBdLFxuICAgICAgICBcInZvaWQgbWFpbigpIHtcIixcbiAgICAgICAgXCIgICBnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlQ3ViZSggdEN1YmUsIHZlYzMoIHRGbGlwICogdldvcmxkUG9zaXRpb24ueCwgdldvcmxkUG9zaXRpb24ueXogKSApO1wiLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfZnJhZ21lbnRcIiBdLFxuICAgICAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiZm9nX2ZyYWdtZW50XCIgXSxcbiAgICAgICAgXCJ9XCJcblxuICAgIF0uam9pbihcIlxcblwiKVxuXG59XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHJlbmRlcmVyLCBjYW1lcmEsIHNjZW5lKSB7XG4gICAgdmFyIGxpZ2h0ID0gbmV3IFRIUkVFLkhlbWlzcGhlcmVMaWdodCgweGJiZTlmZiwgMHgwODA4MjAsIDEpXG4gICAgbGlnaHQucG9zaXRpb24uc2V0KC0xLCAxLCAtMSlcbiAgICBzY2VuZS5hZGQobGlnaHQpXG5cbiAgICB2YXIgd2F0ZXJOb3JtYWxzID0gbmV3IFRIUkVFLkltYWdlVXRpbHMubG9hZFRleHR1cmUoJ2ltZy93YXRlcm5vcm1hbHM1LmpwZycpXG4gICAgd2F0ZXJOb3JtYWxzLndyYXBTID0gd2F0ZXJOb3JtYWxzLndyYXBUID0gVEhSRUUuUmVwZWF0V3JhcHBpbmdcblxuICAgIHZhciB3YXRlciA9IG5ldyBUSFJFRS5XYXRlcihyZW5kZXJlciwgY2FtZXJhLCBzY2VuZSwge1xuICAgICAgICB0ZXh0dXJlV2lkdGg6IDUxMixcbiAgICAgICAgdGV4dHVyZUhlaWdodDogNTEyLFxuICAgICAgICB3YXRlck5vcm1hbHM6IHdhdGVyTm9ybWFscyxcbiAgICAgICAgYWxwaGE6IDAuOSxcbiAgICAgICAgc3VuRGlyZWN0aW9uOiBsaWdodC5wb3NpdGlvbi5jbG9uZSgpLm5vcm1hbGl6ZSgpLFxuICAgICAgICBzdW5Db2xvcjogMHhmZmZmZmYsXG4gICAgICAgIHdhdGVyQ29sb3I6IDB4MDIwZDE1LFxuICAgICAgICBkaXN0b3J0aW9uU2NhbGU6IDgwLjAsXG4gICAgfSlcblxuICAgIHZhciBtaXJyb3JNZXNoID0gbmV3IFRIUkVFLk1lc2goXG4gICAgICAgIG5ldyBUSFJFRS5QbGFuZUJ1ZmZlckdlb21ldHJ5KDUwMDAsIDUwMDApLFxuICAgICAgICB3YXRlci5tYXRlcmlhbFxuICAgIClcblxuICAgIG1pcnJvck1lc2guYWRkKHdhdGVyKVxuICAgIG1pcnJvck1lc2gucm90YXRpb24ueCA9IC1NYXRoLlBJICogMC41XG4gICAgc2NlbmUuYWRkKG1pcnJvck1lc2gpXG5cblxuICAgIC8vIGxvYWQgc2t5Ym94XG5cbiAgICB2YXIgY3ViZU1hcCA9IG5ldyBUSFJFRS5DdWJlVGV4dHVyZShbXSlcbiAgICBjdWJlTWFwLmZvcm1hdCA9IFRIUkVFLlJHQkZvcm1hdFxuICAgIGN1YmVNYXAuZmxpcFkgPSBmYWxzZVxuXG4gICAgdmFyIGxvYWRlciA9IG5ldyBUSFJFRS5JbWFnZUxvYWRlcigpXG4gICAgbG9hZGVyLmxvYWQoJ2ltZy9jbG91ZHlfbmlnaHQyLmpwZycsIGZ1bmN0aW9uKGltYWdlKSB7XG5cbiAgICAgICAgdmFyIGdldFNpZGUgPSBmdW5jdGlvbih4LCB5KSB7XG5cbiAgICAgICAgICAgIHZhciBzaXplID0gMTAyNFxuXG4gICAgICAgICAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJylcbiAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IHNpemVcbiAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSBzaXplXG5cbiAgICAgICAgICAgIHZhciBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJylcbiAgICAgICAgICAgIGNvbnRleHQuZHJhd0ltYWdlKGltYWdlLCAteCAqIHNpemUsIC15ICogc2l6ZSlcblxuICAgICAgICAgICAgcmV0dXJuIGNhbnZhc1xuXG4gICAgICAgIH1cblxuICAgICAgICBjdWJlTWFwLmltYWdlc1swXSA9IGdldFNpZGUoMiwgMSkgLy8gcHhcbiAgICAgICAgY3ViZU1hcC5pbWFnZXNbMV0gPSBnZXRTaWRlKDAsIDEpIC8vIG54XG4gICAgICAgIGN1YmVNYXAuaW1hZ2VzWzJdID0gZ2V0U2lkZSgxLCAwKSAvLyBweVxuICAgICAgICBjdWJlTWFwLmltYWdlc1szXSA9IGdldFNpZGUoMSwgMikgLy8gbnlcbiAgICAgICAgY3ViZU1hcC5pbWFnZXNbNF0gPSBnZXRTaWRlKDEsIDEpIC8vIHB6XG4gICAgICAgIGN1YmVNYXAuaW1hZ2VzWzVdID0gZ2V0U2lkZSgzLCAxKSAvLyBuelxuICAgICAgICBjdWJlTWFwLm5lZWRzVXBkYXRlID0gdHJ1ZVxuXG4gICAgfSlcblxuICAgIGN1YmVTaGFkZXIudW5pZm9ybXMudEN1YmUudmFsdWUgPSBjdWJlTWFwXG5cbiAgICB2YXIgc2t5Qm94TWF0ZXJpYWwgPSBuZXcgVEhSRUUuU2hhZGVyTWF0ZXJpYWwoe1xuICAgICAgICBmcmFnbWVudFNoYWRlcjogY3ViZVNoYWRlci5mcmFnbWVudFNoYWRlcixcbiAgICAgICAgdmVydGV4U2hhZGVyOiBjdWJlU2hhZGVyLnZlcnRleFNoYWRlcixcbiAgICAgICAgdW5pZm9ybXM6IGN1YmVTaGFkZXIudW5pZm9ybXMsXG4gICAgICAgIC8vIGRlcHRoV3JpdGU6IGZhbHNlLFxuICAgICAgICBzaWRlOiBUSFJFRS5CYWNrU2lkZSxcbiAgICAgICAgZm9nOiB0cnVlLFxuICAgIH0pXG5cbiAgICB2YXIgc2t5Qm94ID0gbmV3IFRIUkVFLk1lc2goXG4gICAgICAgIG5ldyBUSFJFRS5Cb3hHZW9tZXRyeSg1MDAwLCA1MDAwLCA1MDAwKSxcbiAgICAgICAgc2t5Qm94TWF0ZXJpYWxcbiAgICApXG4gICAgXG4gICAgd2F0ZXIuY3ViZU1hcCA9IGN1YmVNYXBcblxuICAgIHNjZW5lLmFkZChza3lCb3gpXG4gICAgcmV0dXJuIHdhdGVyXG59IiwidmFyIGdsc2xpZnkgPSByZXF1aXJlKFwiZ2xzbGlmeVwiKTtcbnZhciBzb3VyY2UgPSByZXF1aXJlKFwiZ2xzbGlmeS9zaW1wbGUtYWRhcHRlci5qc1wiKShcIlxcbiNkZWZpbmUgR0xTTElGWSAxXFxuXFxudmFyeWluZyB2ZWMyIHZVdjtcXG52b2lkIG1haW4oKSB7XFxuICB2VXYgPSB1djtcXG4gIGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG1vZGVsVmlld01hdHJpeCAqIHZlYzQocG9zaXRpb24sIDEuMCk7XFxufVwiLCBcIlxcbiNkZWZpbmUgR0xTTElGWSAxXFxuXFxudW5pZm9ybSB2ZWMyIHJlc29sdXRpb247XFxudW5pZm9ybSBmbG9hdCByYWRpdXM7XFxudW5pZm9ybSB2ZWMyIGRpcjtcXG51bmlmb3JtIGZsb2F0IHN0cmVuZ3RoO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHREaWZmdXNlO1xcbnZhcnlpbmcgdmVjMiB2VXY7XFxudmVjNCBhX3hfYmx1cihzYW1wbGVyMkQgdGV4LCB2ZWMyIHV2LCB2ZWMyIGJsdXIsIHZlYzIgZGlyZWN0aW9uKSB7XFxuICB2ZWM0IHN1bSA9IHZlYzQoMC4wKTtcXG4gIHN1bSArPSB0ZXh0dXJlMkQodGV4LCB2ZWMyKHV2LnggLSA0LjAgKiBibHVyLnggKiBkaXJlY3Rpb24ueCwgdXYueSAtIDQuMCAqIGJsdXIueSAqIGRpcmVjdGlvbi55KSkgKiAwLjAxNjIxNjIxNjI7XFxuICBzdW0gKz0gdGV4dHVyZTJEKHRleCwgdmVjMih1di54IC0gMy4wICogYmx1ci54ICogZGlyZWN0aW9uLngsIHV2LnkgLSAzLjAgKiBibHVyLnkgKiBkaXJlY3Rpb24ueSkpICogMC4wNTQwNTQwNTQxO1xcbiAgc3VtICs9IHRleHR1cmUyRCh0ZXgsIHZlYzIodXYueCAtIDIuMCAqIGJsdXIueCAqIGRpcmVjdGlvbi54LCB1di55IC0gMi4wICogYmx1ci55ICogZGlyZWN0aW9uLnkpKSAqIDAuMTIxNjIxNjIxNjtcXG4gIHN1bSArPSB0ZXh0dXJlMkQodGV4LCB2ZWMyKHV2LnggLSAxLjAgKiBibHVyLnggKiBkaXJlY3Rpb24ueCwgdXYueSAtIDEuMCAqIGJsdXIueSAqIGRpcmVjdGlvbi55KSkgKiAwLjE5NDU5NDU5NDY7XFxuICBzdW0gKz0gdGV4dHVyZTJEKHRleCwgdmVjMih1di54LCB1di55KSkgKiAwLjIyNzAyNzAyNzA7XFxuICBzdW0gKz0gdGV4dHVyZTJEKHRleCwgdmVjMih1di54ICsgMS4wICogYmx1ci54ICogZGlyZWN0aW9uLngsIHV2LnkgKyAxLjAgKiBibHVyLnkgKiBkaXJlY3Rpb24ueSkpICogMC4xOTQ1OTQ1OTQ2O1xcbiAgc3VtICs9IHRleHR1cmUyRCh0ZXgsIHZlYzIodXYueCArIDIuMCAqIGJsdXIueCAqIGRpcmVjdGlvbi54LCB1di55ICsgMi4wICogYmx1ci55ICogZGlyZWN0aW9uLnkpKSAqIDAuMTIxNjIxNjIxNjtcXG4gIHN1bSArPSB0ZXh0dXJlMkQodGV4LCB2ZWMyKHV2LnggKyAzLjAgKiBibHVyLnggKiBkaXJlY3Rpb24ueCwgdXYueSArIDMuMCAqIGJsdXIueSAqIGRpcmVjdGlvbi55KSkgKiAwLjA1NDA1NDA1NDE7XFxuICBzdW0gKz0gdGV4dHVyZTJEKHRleCwgdmVjMih1di54ICsgNC4wICogYmx1ci54ICogZGlyZWN0aW9uLngsIHV2LnkgKyA0LjAgKiBibHVyLnkgKiBkaXJlY3Rpb24ueSkpICogMC4wMTYyMTYyMTYyO1xcbiAgcmV0dXJuIHN1bTtcXG59XFxudm9pZCBtYWluKCkge1xcbiAgdmVjMiBibHVyQW10ID0gdmVjMihyYWRpdXMpIC8gcmVzb2x1dGlvbjtcXG4gIHZlYzQgc3VtID0gYV94X2JsdXIodERpZmZ1c2UsIHZVdiwgYmx1ckFtdCwgZGlyKTtcXG4gIHZlYzIgcCA9IChnbF9GcmFnQ29vcmQueHkgLyByZXNvbHV0aW9uLnh5IC0gMC41KTtcXG4gIHAueCAqPSByZXNvbHV0aW9uLnggLyByZXNvbHV0aW9uLnk7XFxuICBmbG9hdCBsZW4gPSBzbW9vdGhzdGVwKDAuNSwgMS4yLCBsZW5ndGgocCkpO1xcbiAgdmVjMyBvcmlnID0gdGV4dHVyZTJEKHREaWZmdXNlLCB2VXYpLnJnYjtcXG4gIGdsX0ZyYWdDb2xvci5yZ2IgPSBtaXgob3JpZywgc3VtLnJnYiwgbGVuICsgMC4xKTtcXG4gIGdsX0ZyYWdDb2xvci5hID0gMS4wO1xcbn1cIiwgW3tcIm5hbWVcIjpcInJlc29sdXRpb25cIixcInR5cGVcIjpcInZlYzJcIn0se1wibmFtZVwiOlwicmFkaXVzXCIsXCJ0eXBlXCI6XCJmbG9hdFwifSx7XCJuYW1lXCI6XCJkaXJcIixcInR5cGVcIjpcInZlYzJcIn0se1wibmFtZVwiOlwic3RyZW5ndGhcIixcInR5cGVcIjpcImZsb2F0XCJ9LHtcIm5hbWVcIjpcInREaWZmdXNlXCIsXCJ0eXBlXCI6XCJzYW1wbGVyMkRcIn1dLCBbXSk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL2NyZWF0ZVwiKShzb3VyY2UpOyIsIihmdW5jdGlvbiAoZ2xvYmFsKXtcbnZhciBUSFJFRSA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93LlRIUkVFIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbC5USFJFRSA6IG51bGwpXG52YXIgdGhyZWVpZnkgPSByZXF1aXJlKCd0aHJlZS1nbHNsaWZ5JykoVEhSRUUpXG52YXIgeHRlbmQgPSByZXF1aXJlKCd4dGVuZCcpIFxuIFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihzb3VyY2UpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24ob3B0KSB7XG4gICAgICAgIHJldHVybiB4dGVuZCh0aHJlZWlmeShzb3VyY2UpLCBvcHQpXG4gICAgfVxufVxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pIiwidmFyIGdsc2xpZnkgPSByZXF1aXJlKFwiZ2xzbGlmeVwiKTtcbnZhciBzb3VyY2UgPSByZXF1aXJlKFwiZ2xzbGlmeS9zaW1wbGUtYWRhcHRlci5qc1wiKShcIlxcbiNkZWZpbmUgR0xTTElGWSAxXFxuXFxudW5pZm9ybSB2ZWMyIG92ZXJsYXlSZXNvbHV0aW9uO1xcbnVuaWZvcm0gdmVjMiByZXNvbHV0aW9uO1xcbnZhcnlpbmcgdmVjMiB2VXY7XFxudmFyeWluZyB2ZWMyIG92ZXJsYXlVVjtcXG52b2lkIG1haW4oKSB7XFxuICB2VXYgPSB1djtcXG4gIGZsb2F0IGFzcGVjdCA9IG92ZXJsYXlSZXNvbHV0aW9uLnggLyBvdmVybGF5UmVzb2x1dGlvbi55O1xcbiAgZmxvYXQgcmF0aW8gPSByZXNvbHV0aW9uLnggLyByZXNvbHV0aW9uLnk7XFxuICBvdmVybGF5VVYgPSB1djtcXG4gIGZsb2F0IHRBc3BlY3QgPSBvdmVybGF5UmVzb2x1dGlvbi54IC8gb3ZlcmxheVJlc29sdXRpb24ueTtcXG4gIGZsb2F0IHBBc3BlY3QgPSByZXNvbHV0aW9uLnggLyByZXNvbHV0aW9uLnk7XFxuICBvdmVybGF5VVYgPSB1djtcXG4gIGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG1vZGVsVmlld01hdHJpeCAqIHZlYzQocG9zaXRpb24sIDEuMCk7XFxufVwiLCBcIlxcbiNkZWZpbmUgR0xTTElGWSAxXFxuXFxudW5pZm9ybSBmbG9hdCB0aWNrO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHREaWZmdXNlO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHRMb29rdXA7XFxudW5pZm9ybSBzYW1wbGVyMkQgdE92ZXJsYXk7XFxudmFyeWluZyB2ZWMyIHZVdjtcXG52YXJ5aW5nIHZlYzIgb3ZlcmxheVVWO1xcbmhpZ2hwIGZsb2F0IGFfeF9yYW5kb20odmVjMiBjbykge1xcbiAgaGlnaHAgZmxvYXQgYSA9IDEyLjk4OTg7XFxuICBoaWdocCBmbG9hdCBiID0gNzguMjMzO1xcbiAgaGlnaHAgZmxvYXQgYyA9IDQzNzU4LjU0NTM7XFxuICBoaWdocCBmbG9hdCBkdCA9IGRvdChjby54eSwgdmVjMihhLCBiKSk7XFxuICBoaWdocCBmbG9hdCBzbiA9IG1vZChkdCwgMy4xNCk7XFxuICByZXR1cm4gZnJhY3Qoc2luKHNuKSAqIGMpO1xcbn1cXG52ZWMzIGJfeF9ibGVuZE92ZXJsYXkodmVjMyBiYXNlLCB2ZWMzIGJsZW5kKSB7XFxuICByZXR1cm4gdmVjMyhiYXNlLnIgPCAwLjUgPyAoMi4wICogYmFzZS5yICogYmxlbmQucikgOiAoMS4wIC0gMi4wICogKDEuMCAtIGJhc2UucikgKiAoMS4wIC0gYmxlbmQucikpLCBiYXNlLmcgPCAwLjUgPyAoMi4wICogYmFzZS5nICogYmxlbmQuZykgOiAoMS4wIC0gMi4wICogKDEuMCAtIGJhc2UuZykgKiAoMS4wIC0gYmxlbmQuZykpLCBiYXNlLmIgPCAwLjUgPyAoMi4wICogYmFzZS5iICogYmxlbmQuYikgOiAoMS4wIC0gMi4wICogKDEuMCAtIGJhc2UuYikgKiAoMS4wIC0gYmxlbmQuYikpKTtcXG59XFxuZmxvYXQgY194X2x1bWEodmVjMyBjb2xvcikge1xcbiAgcmV0dXJuIGRvdChjb2xvciwgdmVjMygwLjI5OSwgMC41ODcsIDAuMTE0KSk7XFxufVxcbmZsb2F0IGNfeF9sdW1hKHZlYzQgY29sb3IpIHtcXG4gIHJldHVybiBkb3QoY29sb3IucmdiLCB2ZWMzKDAuMjk5LCAwLjU4NywgMC4xMTQpKTtcXG59XFxuI2RlZmluZSBMVVRfRkxJUF9ZXFxuXFxudmVjNCBlX3hfbG9va3VwKGluIHZlYzQgdGV4dHVyZUNvbG9yLCBpbiBzYW1wbGVyMkQgbG9va3VwVGFibGUpIHtcXG4gIFxcbiAgI2lmbmRlZiBMVVRfTk9fQ0xBTVBcXG4gIHRleHR1cmVDb2xvciA9IGNsYW1wKHRleHR1cmVDb2xvciwgMC4wLCAxLjApO1xcbiAgI2VuZGlmXFxuICBtZWRpdW1wIGZsb2F0IGJsdWVDb2xvciA9IHRleHR1cmVDb2xvci5iICogNjMuMDtcXG4gIG1lZGl1bXAgdmVjMiBxdWFkMTtcXG4gIHF1YWQxLnkgPSBmbG9vcihmbG9vcihibHVlQ29sb3IpIC8gOC4wKTtcXG4gIHF1YWQxLnggPSBmbG9vcihibHVlQ29sb3IpIC0gKHF1YWQxLnkgKiA4LjApO1xcbiAgbWVkaXVtcCB2ZWMyIHF1YWQyO1xcbiAgcXVhZDIueSA9IGZsb29yKGNlaWwoYmx1ZUNvbG9yKSAvIDguMCk7XFxuICBxdWFkMi54ID0gY2VpbChibHVlQ29sb3IpIC0gKHF1YWQyLnkgKiA4LjApO1xcbiAgaGlnaHAgdmVjMiB0ZXhQb3MxO1xcbiAgdGV4UG9zMS54ID0gKHF1YWQxLnggKiAwLjEyNSkgKyAwLjUgLyA1MTIuMCArICgoMC4xMjUgLSAxLjAgLyA1MTIuMCkgKiB0ZXh0dXJlQ29sb3Iucik7XFxuICB0ZXhQb3MxLnkgPSAocXVhZDEueSAqIDAuMTI1KSArIDAuNSAvIDUxMi4wICsgKCgwLjEyNSAtIDEuMCAvIDUxMi4wKSAqIHRleHR1cmVDb2xvci5nKTtcXG4gICNpZmRlZiBMVVRfRkxJUF9ZXFxuICB0ZXhQb3MxLnkgPSAxLjAgLSB0ZXhQb3MxLnk7XFxuICAjZW5kaWZcXG4gIGhpZ2hwIHZlYzIgdGV4UG9zMjtcXG4gIHRleFBvczIueCA9IChxdWFkMi54ICogMC4xMjUpICsgMC41IC8gNTEyLjAgKyAoKDAuMTI1IC0gMS4wIC8gNTEyLjApICogdGV4dHVyZUNvbG9yLnIpO1xcbiAgdGV4UG9zMi55ID0gKHF1YWQyLnkgKiAwLjEyNSkgKyAwLjUgLyA1MTIuMCArICgoMC4xMjUgLSAxLjAgLyA1MTIuMCkgKiB0ZXh0dXJlQ29sb3IuZyk7XFxuICAjaWZkZWYgTFVUX0ZMSVBfWVxcbiAgdGV4UG9zMi55ID0gMS4wIC0gdGV4UG9zMi55O1xcbiAgI2VuZGlmXFxuICBsb3dwIHZlYzQgbmV3Q29sb3IxID0gdGV4dHVyZTJEKGxvb2t1cFRhYmxlLCB0ZXhQb3MxKTtcXG4gIGxvd3AgdmVjNCBuZXdDb2xvcjIgPSB0ZXh0dXJlMkQobG9va3VwVGFibGUsIHRleFBvczIpO1xcbiAgbG93cCB2ZWM0IG5ld0NvbG9yID0gbWl4KG5ld0NvbG9yMSwgbmV3Q29sb3IyLCBmcmFjdChibHVlQ29sb3IpKTtcXG4gIHJldHVybiBuZXdDb2xvcjtcXG59XFxudm9pZCBtYWluKCkge1xcbiAgdmVjMyB0ZXhDb2xvciA9IHRleHR1cmUyRCh0RGlmZnVzZSwgdlV2KS5yZ2I7XFxuICBmbG9hdCBsdW1pbmFuY2UgPSBjX3hfbHVtYSh0ZXhDb2xvcik7XFxuICBmbG9hdCBub2lzZU1hcCA9IHNtb290aHN0ZXAobHVtaW5hbmNlLCAwLjUsIDAuMCk7XFxuICB2ZWMyIHRVdiA9IHZVdiArIHRpY2s7XFxuICB2ZWMzIG5vaXNlID0gdmVjMyhhX3hfcmFuZG9tKHRVdiksIGFfeF9yYW5kb20odFV2ICogMS41KSwgYV94X3JhbmRvbSh0VXYgKiAwLjUpKTtcXG4gIHZlYzMgbm9pc2VDb2xvciA9IG1peChub2lzZSwgdmVjMygwLjUpLCBub2lzZU1hcCk7XFxuICB2ZWMzIGNvbG9yID0gbWl4KHRleENvbG9yLCBiX3hfYmxlbmRPdmVybGF5KHRleENvbG9yLCBub2lzZSksIDAuMTUpO1xcbiAgdmVjMyBjb3JyZWN0ZWQgPSBlX3hfbG9va3VwKHZlYzQoY29sb3IsIDEuMCksIHRMb29rdXApLnJnYjtcXG4gIGNvbG9yID0gbWl4KGNvbG9yLCBjb3JyZWN0ZWQsIDAuOSk7XFxuICBnbF9GcmFnQ29sb3IgPSB2ZWM0KGNvbG9yLCAxLjApO1xcbiAgdmVjNCBzY3JhdGNoZXMgPSB0ZXh0dXJlMkQodE92ZXJsYXksIG92ZXJsYXlVVik7XFxuICB2ZWMzIHNjcmF0Y2hCbGVuZCA9IGdsX0ZyYWdDb2xvci5yZ2IgKyBzY3JhdGNoZXMucmdiO1xcbiAgZmxvYXQgY2VudGVyID0gc21vb3Roc3RlcCgwLjAsIDAuNiwgbGVuZ3RoKHZVdiAtIDAuNSkpO1xcbiAgZmxvYXQgZGlydE1hcCA9IHNtb290aHN0ZXAoMC4xLCAwLjQsIGx1bWluYW5jZSAqIGNlbnRlcik7XFxuICBnbF9GcmFnQ29sb3IucmdiID0gbWl4KGdsX0ZyYWdDb2xvci5yZ2IsIHNjcmF0Y2hCbGVuZCwgZGlydE1hcCk7XFxufVwiLCBbe1wibmFtZVwiOlwib3ZlcmxheVJlc29sdXRpb25cIixcInR5cGVcIjpcInZlYzJcIn0se1wibmFtZVwiOlwicmVzb2x1dGlvblwiLFwidHlwZVwiOlwidmVjMlwifSx7XCJuYW1lXCI6XCJ0aWNrXCIsXCJ0eXBlXCI6XCJmbG9hdFwifSx7XCJuYW1lXCI6XCJ0RGlmZnVzZVwiLFwidHlwZVwiOlwic2FtcGxlcjJEXCJ9LHtcIm5hbWVcIjpcInRMb29rdXBcIixcInR5cGVcIjpcInNhbXBsZXIyRFwifSx7XCJuYW1lXCI6XCJ0T3ZlcmxheVwiLFwidHlwZVwiOlwic2FtcGxlcjJEXCJ9XSwgW10pO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9jcmVhdGVcIikoc291cmNlKTsiLCJ2YXIgZ2xzbGlmeSA9IHJlcXVpcmUoXCJnbHNsaWZ5XCIpO1xudmFyIHNvdXJjZSA9IHJlcXVpcmUoXCJnbHNsaWZ5L3NpbXBsZS1hZGFwdGVyLmpzXCIpKFwiXFxuI2RlZmluZSBHTFNMSUZZIDFcXG5cXG52YXJ5aW5nIHZlYzIgdlV2O1xcbnZvaWQgbWFpbigpIHtcXG4gIHZVdiA9IHV2O1xcbiAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNChwb3NpdGlvbiwgMS4wKTtcXG59XCIsIFwiXFxuI2RlZmluZSBHTFNMSUZZIDFcXG5cXG51bmlmb3JtIHNhbXBsZXIyRCB0RGlmZnVzZTtcXG52YXJ5aW5nIHZlYzIgdlV2O1xcbnZvaWQgbWFpbigpIHtcXG4gIGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCh0RGlmZnVzZSwgdlV2KTtcXG59XCIsIFt7XCJuYW1lXCI6XCJ0RGlmZnVzZVwiLFwidHlwZVwiOlwic2FtcGxlcjJEXCJ9XSwgW10pO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9jcmVhdGVcIikoc291cmNlKTsiLCIoZnVuY3Rpb24gKGdsb2JhbCl7XG52YXIgVEhSRUUgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdy5USFJFRSA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwuVEhSRUUgOiBudWxsKVxudmFyIGxpbmVIZWlnaHQgPSAyMlxudmFyIGJpZyA9IDAuN1xudmFyIHNtYWxsID0gMC41XG5cbnZhciBwYW5lbFdpZHRoID0gMjBcbm1vZHVsZS5leHBvcnRzID0gW1xuICAgIFxuICAgIHtcbiAgICAgICAgbmFtZTogJ3Rvbm5lcycsXG4gICAgICAgIHBhbmVsczogWyB7XG4gICAgICAgICAgICAvLyBvcmlnaW46IG5ldyBUSFJFRS5WZWN0b3IzKDE4LCAxMCwgMiksXG4gICAgICAgICAgICBsYWJlbHM6IFtcbiAgICAgICAgICAgICAgICB7IHRleHQ6ICc1IG1pbGxpb24gdG9ubmVzJywgc2l6ZTogYmlnIH0sXG4gICAgICAgICAgICAgICAgeyB0ZXh0OiAnZXN0aW1hdGVkIG9pbCBzcGlsdCBpbiBSdXNzaWEgZWFjaCB5ZWFyJywgc2l6ZTogc21hbGwsIHRyYW5zbGF0aW9uOiBbLTIsIC1saW5lSGVpZ2h0LCAwXSB9LFxuICAgICAgICAgICAgXVxuICAgICAgICB9LCBcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gb3JpZ2luOiBuZXcgVEhSRUUuVmVjdG9yMygtMjAsIDEwLCAyKSxcbiAgICAgICAgICAgIHdpZHRoOiBwYW5lbFdpZHRoLFxuICAgICAgICAgICAgbGFiZWxzOiBbXG4gICAgICAgICAgICAgICAgeyB0ZXh0OiAnNiBtaWxsaW9uIHRvbm5lcycsIHNpemU6IGJpZyB9LFxuICAgICAgICAgICAgICAgIHsgdGV4dDogJ2V4cGVjdGVkIHllYXJseSBvdXRwdXQgb2YgdGhpcyBwbGF0Zm9ybScsIHNpemU6IHNtYWxsLCB0cmFuc2xhdGlvbjogWzAsIC1saW5lSGVpZ2h0LCAwXSB9LFxuICAgICAgICAgICAgXVxuICAgICAgICB9IFxuICAgICAgICBdXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6ICd0b3AnLFxuICAgICAgICBwYW5lbHM6IFsge1xuICAgICAgICAgICAgbGFiZWxzOiBbXG4gICAgICAgICAgICAgICAgeyB0ZXh0OiAnVGVjaG5vbG9naWNhbGx5IG91dGRhdGVkJywgc2l6ZTogYmlnIH0sXG4gICAgICAgICAgICAgICAgeyB0ZXh0OiAndXNpbmcgc2Vjb25kaGFuZCBjb21wb25lbnRzJywgc2l6ZTogc21hbGwsIHRyYW5zbGF0aW9uOiBbMCwgLWxpbmVIZWlnaHQsIDBdIH0sXG4gICAgICAgICAgICBdXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIHdpZHRoOiBwYW5lbFdpZHRoLFxuICAgICAgICAgICAgbGFiZWxzOiBbXG4gICAgICAgICAgICAgICAgeyB0ZXh0OiAnJDMuMiBiaWxsaW9uIG92ZXIgYnVkZ2V0Jywgc2l6ZTogYmlnIH0sXG4gICAgICAgICAgICAgICAgeyB0ZXh0OiAnMTggeWVhcnMgdG8gY29uc3RydWN0Jywgc2l6ZTogc21hbGwsIHRyYW5zbGF0aW9uOiBbMCwgLWxpbmVIZWlnaHQsIDBdIH0sXG4gICAgICAgICAgICBdXG4gICAgICAgIH0gXVxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiAnbmF0dXJlJyxcbiAgICAgICAgcGFuZWxzOiBbIHtcbiAgICAgICAgICAgIGxhYmVsczogW1xuICAgICAgICAgICAgICAgIHsgdGV4dDogJzUwIGttIGZyb20gTmF0dXJlIHJlc2VydmUnLCBzaXplOiBiaWcgfSxcbiAgICAgICAgICAgICAgICB7IHRleHQ6ICdMZXNzIHRoYW4gMjBocnMgZm9yIG9pbCB0byByZWFjaCcsIHNpemU6IHNtYWxsLCB0cmFuc2xhdGlvbjogWzAsIC1saW5lSGVpZ2h0LCAwXSB9LFxuICAgICAgICAgICAgXVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICB3aWR0aDogcGFuZWxXaWR0aCxcbiAgICAgICAgICAgIGxhYmVsczogW1xuICAgICAgICAgICAgICAgIHsgdGV4dDogJ0NydWNpYWwgYnJlZWRpbmcgZ3JvdW5kcycsIHNpemU6IGJpZyB9LFxuICAgICAgICAgICAgICAgIHsgdGV4dDogJ2ZvciB3YWxydXMsIHdoYWxlcyAmIHBvbGFyIGJlYXJzJywgc2l6ZTogc21hbGwsIHRyYW5zbGF0aW9uOiBbMCwgLWxpbmVIZWlnaHQsIDBdIH0sXG4gICAgICAgICAgICBdXG4gICAgICAgIH0gXVxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiAncmVzcG9uc2UnLFxuICAgICAgICBwYW5lbHM6IFsge1xuICAgICAgICAgICAgbGFiZWxzOiBbXG4gICAgICAgICAgICAgICAgeyB0ZXh0OiAnTGFyZ2Ugc2NhbGUgc3BpbGwgZXF1aXBtZW50ICcsIHNpemU6IGJpZyB9LFxuICAgICAgICAgICAgICAgIHsgdGV4dDogJzEwMDBrbSAoMyBkYXlzIHNhaWxpbmcpIGF3YXknLCBzaXplOiBzbWFsbCwgdHJhbnNsYXRpb246IFswLCAtbGluZUhlaWdodCwgMF0gfSxcbiAgICAgICAgICAgIF1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgd2lkdGg6IHBhbmVsV2lkdGgqMS41LFxuICAgICAgICAgICAgbGFiZWxzOiBbXG4gICAgICAgICAgICAgICAgeyB0ZXh0OiAnMTUgYnVja2V0cyBhbmQgMyBheGVzJywgc2l6ZTogYmlnIH0sXG4gICAgICAgICAgICAgICAgeyB0ZXh0OiAnaW5jbHVkZWQgaW4gcHJldmlvdXMgcmVzcG9uc2UgcGxhbicsIHNpemU6IHNtYWxsLCB0cmFuc2xhdGlvbjogWzAsIC1saW5lSGVpZ2h0LCAwXSB9LFxuICAgICAgICAgICAgXVxuICAgICAgICB9IF1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogJ3NwaWxsJyxcbiAgICAgICAgcGFuZWxzOiBbIHtcbiAgICAgICAgICAgIGxhYmVsczogW1xuICAgICAgICAgICAgICAgIHsgdGV4dDogJ0FyY3RpYyBPaWwgc3BpbGxzJywgc2l6ZTogYmlnIH0sXG4gICAgICAgICAgICAgICAgeyB0ZXh0OiAnYXJlIGNsb3NlIHRvIGltcG9zc2libGUgdG8gY2xlYW4gdXAnLCBzaXplOiBzbWFsbCwgdHJhbnNsYXRpb246IFswLCAtbGluZUhlaWdodCwgMF0gfSxcbiAgICAgICAgICAgIF1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgd2lkdGg6IHBhbmVsV2lkdGgsXG4gICAgICAgICAgICBsYWJlbHM6IFtcbiAgICAgICAgICAgICAgICB7IHRleHQ6ICdPZmZzaG9yZSBkcmlsbGluZyBmb3IgYXJjdGljIG9pbCcsIHNpemU6IGJpZyB9LFxuICAgICAgICAgICAgICAgIHsgdGV4dDogJ3NwaWxscyBhcmUgdmlydHVhbGx5IGluZXZpdGFibGUnLCBzaXplOiBzbWFsbCwgdHJhbnNsYXRpb246IFswLCAtbGluZUhlaWdodCwgMF0gfSxcbiAgICAgICAgICAgIF1cbiAgICAgICAgfSBdXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6ICd3ZWF0aGVyJyxcbiAgICAgICAgcGFuZWxzOiBbIHtcbiAgICAgICAgICAgIGxhYmVsczogW1xuICAgICAgICAgICAgICAgIHsgdGV4dDogJ0FzIGNvbGQgYXMgLTUwy5pjIC8xMjLLmmYnLCBzaXplOiBiaWcgfSxcbiAgICAgICAgICAgICAgICB7IHRleHQ6ICd0d28gdGhpcmRzIG9mIHRoZSB5ZWFyIHN1cnJvdW5kZWQgYnkgaWNlJywgc2l6ZTogc21hbGwsIHRyYW5zbGF0aW9uOiBbMCwgLWxpbmVIZWlnaHQsIDBdIH0sXG4gICAgICAgICAgICBdXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIHdpZHRoOiBwYW5lbFdpZHRoLFxuICAgICAgICAgICAgbGFiZWxzOiBbXG4gICAgICAgICAgICAgICAgeyB0ZXh0OiAnUGxhZ3VlZCBieSBiYWQgd2VhdGhlcicsIHNpemU6IGJpZyB9LFxuICAgICAgICAgICAgICAgIHsgdGV4dDogJ3dhdmVzIGFzIGhpZ2ggYXMgMTJtJywgc2l6ZTogc21hbGwsIHRyYW5zbGF0aW9uOiBbMCwgLWxpbmVIZWlnaHQsIDBdIH0sXG4gICAgICAgICAgICBdXG4gICAgICAgIH0gXVxuICAgIH0sXG5dXG5cbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KSIsIihmdW5jdGlvbiAoZ2xvYmFsKXtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBUd2Vlbk1heCA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93LlR3ZWVuTWF4IDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbC5Ud2Vlbk1heCA6IG51bGwpXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oVEhSRUUpIHtcbiAgICBpZiAoIVRIUkVFLk1PVVNFKVxuICAgICAgICBUSFJFRS5NT1VTRSA9IHsgTEVGVDogMCwgTUlERExFOiAxLCBSSUdIVDogMiB9O1xuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBxaWFvIC8gaHR0cHM6Ly9naXRodWIuY29tL3FpYW9cbiAgICAgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tXG4gICAgICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAgICAgKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcbiAgICAgKiBAYXV0aG9yIGVyaWNoNjY2IC8gaHR0cDovL2VyaWNoYWluZXMuY29tXG4gICAgICovXG4gICAgLypnbG9iYWwgVEhSRUUsIGNvbnNvbGUgKi9cblxuICAgIC8vIFRoaXMgc2V0IG9mIGNvbnRyb2xzIHBlcmZvcm1zIG9yYml0aW5nLCBkb2xseWluZyAoem9vbWluZyksIGFuZCBwYW5uaW5nLiBJdCBtYWludGFpbnNcbiAgICAvLyB0aGUgXCJ1cFwiIGRpcmVjdGlvbiBhcyArWSwgdW5saWtlIHRoZSBUcmFja2JhbGxDb250cm9scy4gVG91Y2ggb24gdGFibGV0IGFuZCBwaG9uZXMgaXNcbiAgICAvLyBzdXBwb3J0ZWQuXG4gICAgLy9cbiAgICAvLyAgICBPcmJpdCAtIGxlZnQgbW91c2UgLyB0b3VjaDogb25lIGZpbmdlciBtb3ZlXG4gICAgLy8gICAgWm9vbSAtIG1pZGRsZSBtb3VzZSwgb3IgbW91c2V3aGVlbCAvIHRvdWNoOiB0d28gZmluZ2VyIHNwcmVhZCBvciBzcXVpc2hcbiAgICAvLyAgICBQYW4gLSByaWdodCBtb3VzZSwgb3IgYXJyb3cga2V5cyAvIHRvdWNoOiB0aHJlZSBmaW50ZXIgc3dpcGVcbiAgICAvL1xuICAgIC8vIFRoaXMgaXMgYSBkcm9wLWluIHJlcGxhY2VtZW50IGZvciAobW9zdCkgVHJhY2tiYWxsQ29udHJvbHMgdXNlZCBpbiBleGFtcGxlcy5cbiAgICAvLyBUaGF0IGlzLCBpbmNsdWRlIHRoaXMganMgZmlsZSBhbmQgd2hlcmV2ZXIgeW91IHNlZTpcbiAgICAvLyAgICAgIGNvbnRyb2xzID0gbmV3IFRIUkVFLlRyYWNrYmFsbENvbnRyb2xzKCBjYW1lcmEgKTtcbiAgICAvLyAgICAgIGNvbnRyb2xzLnRhcmdldC56ID0gMTUwO1xuICAgIC8vIFNpbXBsZSBzdWJzdGl0dXRlIFwiT3JiaXRDb250cm9sc1wiIGFuZCB0aGUgY29udHJvbCBzaG91bGQgd29yayBhcy1pcy5cblxuICAgIGZ1bmN0aW9uIE9yYml0Q29udHJvbHMoIG9iamVjdCwgZG9tRWxlbWVudCApIHtcblxuICAgICAgICB0aGlzLm9iamVjdCA9IG9iamVjdDtcbiAgICAgICAgdGhpcy5kb21FbGVtZW50ID0gKCBkb21FbGVtZW50ICE9PSB1bmRlZmluZWQgKSA/IGRvbUVsZW1lbnQgOiBkb2N1bWVudDtcblxuICAgICAgICAvLyBBUElcblxuICAgICAgICAvLyBTZXQgdG8gZmFsc2UgdG8gZGlzYWJsZSB0aGlzIGNvbnRyb2xcbiAgICAgICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcblxuICAgICAgICAvLyBcInRhcmdldFwiIHNldHMgdGhlIGxvY2F0aW9uIG9mIGZvY3VzLCB3aGVyZSB0aGUgY29udHJvbCBvcmJpdHMgYXJvdW5kXG4gICAgICAgIC8vIGFuZCB3aGVyZSBpdCBwYW5zIHdpdGggcmVzcGVjdCB0by5cbiAgICAgICAgdGhpcy50YXJnZXQgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgICAgIC8vIGNlbnRlciBpcyBvbGQsIGRlcHJlY2F0ZWQ7IHVzZSBcInRhcmdldFwiIGluc3RlYWRcbiAgICAgICAgdGhpcy5jZW50ZXIgPSB0aGlzLnRhcmdldDtcblxuICAgICAgICAvLyBUaGlzIG9wdGlvbiBhY3R1YWxseSBlbmFibGVzIGRvbGx5aW5nIGluIGFuZCBvdXQ7IGxlZnQgYXMgXCJ6b29tXCIgZm9yXG4gICAgICAgIC8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gICAgICAgIHRoaXMubm9ab29tID0gZmFsc2U7XG4gICAgICAgIHRoaXMuem9vbVNwZWVkID0gMS4wO1xuXG4gICAgICAgIC8vIExpbWl0cyB0byBob3cgZmFyIHlvdSBjYW4gZG9sbHkgaW4gYW5kIG91dFxuICAgICAgICB0aGlzLm1pbkRpc3RhbmNlID0gMDtcbiAgICAgICAgdGhpcy5tYXhEaXN0YW5jZSA9IEluZmluaXR5O1xuXG4gICAgICAgIC8vIFNldCB0byB0cnVlIHRvIGRpc2FibGUgdGhpcyBjb250cm9sXG4gICAgICAgIHRoaXMubm9Sb3RhdGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5yb3RhdGVTcGVlZCA9IDEuMDtcblxuICAgICAgICAvLyBTZXQgdG8gdHJ1ZSB0byBkaXNhYmxlIHRoaXMgY29udHJvbFxuICAgICAgICB0aGlzLm5vUGFuID0gZmFsc2U7XG4gICAgICAgIHRoaXMua2V5UGFuU3BlZWQgPSA3LjA7IC8vIHBpeGVscyBtb3ZlZCBwZXIgYXJyb3cga2V5IHB1c2hcblxuICAgICAgICAvLyBTZXQgdG8gdHJ1ZSB0byBhdXRvbWF0aWNhbGx5IHJvdGF0ZSBhcm91bmQgdGhlIHRhcmdldFxuICAgICAgICB0aGlzLmF1dG9Sb3RhdGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5hdXRvUm90YXRlU3BlZWQgPSAyLjA7IC8vIDMwIHNlY29uZHMgcGVyIHJvdW5kIHdoZW4gZnBzIGlzIDYwXG5cbiAgICAgICAgLy8gSG93IGZhciB5b3UgY2FuIG9yYml0IHZlcnRpY2FsbHksIHVwcGVyIGFuZCBsb3dlciBsaW1pdHMuXG4gICAgICAgIC8vIFJhbmdlIGlzIDAgdG8gTWF0aC5QSSByYWRpYW5zLlxuICAgICAgICB0aGlzLm1pblBvbGFyQW5nbGUgPSAwOyAvLyByYWRpYW5zXG4gICAgICAgIHRoaXMubWF4UG9sYXJBbmdsZSA9IE1hdGguUEk7IC8vIHJhZGlhbnNcblxuICAgICAgICAvLyBTZXQgdG8gdHJ1ZSB0byBkaXNhYmxlIHVzZSBvZiB0aGUga2V5c1xuICAgICAgICB0aGlzLm5vS2V5cyA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMucGhpID0gMFxuICAgICAgICB0aGlzLnRoZXRhID0gMCBcblxuICAgICAgICAvLyBUaGUgZm91ciBhcnJvdyBrZXlzXG4gICAgICAgIHRoaXMua2V5cyA9IHsgTEVGVDogMzcsIFVQOiAzOCwgUklHSFQ6IDM5LCBCT1RUT006IDQwIH07XG5cbiAgICAgICAgdGhpcy5jb25zdHJhaW5EZWx0YSA9IHsgeDogMCwgeTogMCB9O1xuXG4gICAgICAgIC8vLy8vLy8vLy8vL1xuICAgICAgICAvLyBpbnRlcm5hbHNcblxuICAgICAgICB2YXIgc2NvcGUgPSB0aGlzO1xuXG4gICAgICAgIHZhciBFUFMgPSAwLjAwMDAwMTtcblxuICAgICAgICB2YXIgcm90YXRlU3RhcnQgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xuICAgICAgICB2YXIgcm90YXRlRW5kID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcbiAgICAgICAgdmFyIHJvdGF0ZURlbHRhID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcblxuICAgICAgICB2YXIgcGFuU3RhcnQgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xuICAgICAgICB2YXIgcGFuRW5kID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcbiAgICAgICAgdmFyIHBhbkRlbHRhID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcbiAgICAgICAgdmFyIHBhbk9mZnNldCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICAgICAgdmFyIG9mZnNldCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICAgICAgdmFyIGRvbGx5U3RhcnQgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xuICAgICAgICB2YXIgZG9sbHlFbmQgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xuICAgICAgICB2YXIgZG9sbHlEZWx0YSA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG5cbiAgICAgICAgdmFyIHBoaURlbHRhID0gMDtcbiAgICAgICAgdmFyIHRoZXRhRGVsdGEgPSAwO1xuICAgICAgICB2YXIgc2NhbGUgPSAxO1xuICAgICAgICB2YXIgcGFuID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgICAgICB2YXIgbGFzdFBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgICAgICB2YXIgU1RBVEUgPSB7IE5PTkUgOiAtMSwgUk9UQVRFIDogMCwgRE9MTFkgOiAxLCBQQU4gOiAyLCBUT1VDSF9ST1RBVEUgOiAzLCBUT1VDSF9ET0xMWSA6IDQsIFRPVUNIX1BBTiA6IDUgfTtcblxuICAgICAgICB2YXIgc3RhdGUgPSBTVEFURS5OT05FO1xuXG4gICAgICAgIC8vIGZvciByZXNldFxuXG4gICAgICAgIHRoaXMudGFyZ2V0MCA9IHRoaXMudGFyZ2V0LmNsb25lKCk7XG4gICAgICAgIHRoaXMucG9zaXRpb24wID0gdGhpcy5vYmplY3QucG9zaXRpb24uY2xvbmUoKTtcblxuICAgICAgICAvLyBzbyBjYW1lcmEudXAgaXMgdGhlIG9yYml0IGF4aXNcblxuICAgICAgICB2YXIgcXVhdCA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCkuc2V0RnJvbVVuaXRWZWN0b3JzKCBvYmplY3QudXAsIG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAxLCAwICkgKTtcbiAgICAgICAgdmFyIHF1YXRJbnZlcnNlID0gcXVhdC5jbG9uZSgpLmludmVyc2UoKTtcblxuICAgICAgICAvLyBldmVudHNcblxuICAgICAgICB2YXIgY2hhbmdlRXZlbnQgPSB7IHR5cGU6ICdjaGFuZ2UnIH07XG4gICAgICAgIHZhciBzdGFydEV2ZW50ID0geyB0eXBlOiAnc3RhcnQnfTtcbiAgICAgICAgdmFyIGVuZEV2ZW50ID0geyB0eXBlOiAnZW5kJ307XG5cbiAgICAgICAgdGhpcy5yb3RhdGVMZWZ0ID0gZnVuY3Rpb24gKCBhbmdsZSApIHtcblxuICAgICAgICAgICAgaWYgKCBhbmdsZSA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgYW5nbGUgPSBnZXRBdXRvUm90YXRpb25BbmdsZSgpO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoZXRhRGVsdGEgLT0gYW5nbGU7XG5cbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLnJvdGF0ZVVwID0gZnVuY3Rpb24gKCBhbmdsZSApIHtcblxuICAgICAgICAgICAgaWYgKCBhbmdsZSA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICAgICAgYW5nbGUgPSBnZXRBdXRvUm90YXRpb25BbmdsZSgpO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHBoaURlbHRhIC09IGFuZ2xlO1xuXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gcGFzcyBpbiBkaXN0YW5jZSBpbiB3b3JsZCBzcGFjZSB0byBtb3ZlIGxlZnRcbiAgICAgICAgdGhpcy5wYW5MZWZ0ID0gZnVuY3Rpb24gKCBkaXN0YW5jZSApIHtcblxuICAgICAgICAgICAgdmFyIHRlID0gdGhpcy5vYmplY3QubWF0cml4LmVsZW1lbnRzO1xuXG4gICAgICAgICAgICAvLyBnZXQgWCBjb2x1bW4gb2YgbWF0cml4XG4gICAgICAgICAgICBwYW5PZmZzZXQuc2V0KCB0ZVsgMCBdLCB0ZVsgMSBdLCB0ZVsgMiBdICk7XG4gICAgICAgICAgICBwYW5PZmZzZXQubXVsdGlwbHlTY2FsYXIoIC0gZGlzdGFuY2UgKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgcGFuLmFkZCggcGFuT2Zmc2V0ICk7XG5cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBwYXNzIGluIGRpc3RhbmNlIGluIHdvcmxkIHNwYWNlIHRvIG1vdmUgdXBcbiAgICAgICAgdGhpcy5wYW5VcCA9IGZ1bmN0aW9uICggZGlzdGFuY2UgKSB7XG5cbiAgICAgICAgICAgIHZhciB0ZSA9IHRoaXMub2JqZWN0Lm1hdHJpeC5lbGVtZW50cztcblxuICAgICAgICAgICAgLy8gZ2V0IFkgY29sdW1uIG9mIG1hdHJpeFxuICAgICAgICAgICAgcGFuT2Zmc2V0LnNldCggdGVbIDQgXSwgdGVbIDUgXSwgdGVbIDYgXSApO1xuICAgICAgICAgICAgcGFuT2Zmc2V0Lm11bHRpcGx5U2NhbGFyKCBkaXN0YW5jZSApO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBwYW4uYWRkKCBwYW5PZmZzZXQgKTtcblxuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgLy8gcGFzcyBpbiB4LHkgb2YgY2hhbmdlIGRlc2lyZWQgaW4gcGl4ZWwgc3BhY2UsXG4gICAgICAgIC8vIHJpZ2h0IGFuZCBkb3duIGFyZSBwb3NpdGl2ZVxuICAgICAgICB0aGlzLnBhbiA9IGZ1bmN0aW9uICggZGVsdGFYLCBkZWx0YVkgKSB7XG5cbiAgICAgICAgICAgIHZhciBlbGVtZW50ID0gc2NvcGUuZG9tRWxlbWVudCA9PT0gZG9jdW1lbnQgPyBzY29wZS5kb21FbGVtZW50LmJvZHkgOiBzY29wZS5kb21FbGVtZW50O1xuXG4gICAgICAgICAgICBpZiAoIHNjb3BlLm9iamVjdC5mb3YgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgIC8vIHBlcnNwZWN0aXZlXG4gICAgICAgICAgICAgICAgdmFyIHBvc2l0aW9uID0gc2NvcGUub2JqZWN0LnBvc2l0aW9uO1xuICAgICAgICAgICAgICAgIHZhciBvZmZzZXQgPSBwb3NpdGlvbi5jbG9uZSgpLnN1Yiggc2NvcGUudGFyZ2V0ICk7XG4gICAgICAgICAgICAgICAgdmFyIHRhcmdldERpc3RhbmNlID0gb2Zmc2V0Lmxlbmd0aCgpO1xuXG4gICAgICAgICAgICAgICAgLy8gaGFsZiBvZiB0aGUgZm92IGlzIGNlbnRlciB0byB0b3Agb2Ygc2NyZWVuXG4gICAgICAgICAgICAgICAgdGFyZ2V0RGlzdGFuY2UgKj0gTWF0aC50YW4oICggc2NvcGUub2JqZWN0LmZvdiAvIDIgKSAqIE1hdGguUEkgLyAxODAuMCApO1xuXG4gICAgICAgICAgICAgICAgLy8gd2UgYWN0dWFsbHkgZG9uJ3QgdXNlIHNjcmVlbldpZHRoLCBzaW5jZSBwZXJzcGVjdGl2ZSBjYW1lcmEgaXMgZml4ZWQgdG8gc2NyZWVuIGhlaWdodFxuICAgICAgICAgICAgICAgIHNjb3BlLnBhbkxlZnQoIDIgKiBkZWx0YVggKiB0YXJnZXREaXN0YW5jZSAvIGVsZW1lbnQuY2xpZW50SGVpZ2h0ICk7XG4gICAgICAgICAgICAgICAgc2NvcGUucGFuVXAoIDIgKiBkZWx0YVkgKiB0YXJnZXREaXN0YW5jZSAvIGVsZW1lbnQuY2xpZW50SGVpZ2h0ICk7XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIHNjb3BlLm9iamVjdC50b3AgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgIC8vIG9ydGhvZ3JhcGhpY1xuICAgICAgICAgICAgICAgIHNjb3BlLnBhbkxlZnQoIGRlbHRhWCAqIChzY29wZS5vYmplY3QucmlnaHQgLSBzY29wZS5vYmplY3QubGVmdCkgLyBlbGVtZW50LmNsaWVudFdpZHRoICk7XG4gICAgICAgICAgICAgICAgc2NvcGUucGFuVXAoIGRlbHRhWSAqIChzY29wZS5vYmplY3QudG9wIC0gc2NvcGUub2JqZWN0LmJvdHRvbSkgLyBlbGVtZW50LmNsaWVudEhlaWdodCApO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgLy8gY2FtZXJhIG5laXRoZXIgb3J0aG9ncmFwaGljIG9yIHBlcnNwZWN0aXZlXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCAnV0FSTklORzogT3JiaXRDb250cm9scy5qcyBlbmNvdW50ZXJlZCBhbiB1bmtub3duIGNhbWVyYSB0eXBlIC0gcGFuIGRpc2FibGVkLicgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5kb2xseUluID0gZnVuY3Rpb24gKCBkb2xseVNjYWxlICkge1xuXG4gICAgICAgICAgICBpZiAoIGRvbGx5U2NhbGUgPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgIGRvbGx5U2NhbGUgPSBnZXRab29tU2NhbGUoKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzY2FsZSAvPSBkb2xseVNjYWxlO1xuXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5kb2xseU91dCA9IGZ1bmN0aW9uICggZG9sbHlTY2FsZSApIHtcblxuICAgICAgICAgICAgaWYgKCBkb2xseVNjYWxlID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgICAgICBkb2xseVNjYWxlID0gZ2V0Wm9vbVNjYWxlKCk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2NhbGUgKj0gZG9sbHlTY2FsZTtcblxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMudXBkYXRlID0gZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICB2YXIgcG9zaXRpb24gPSB0aGlzLm9iamVjdC5wb3NpdGlvbjtcblxuICAgICAgICAgICAgLy8gLy8gcm90YXRpbmcgYWNyb3NzIHdob2xlIHNjcmVlbiBnb2VzIDM2MCBkZWdyZWVzIGFyb3VuZFxuICAgICAgICAgICAgc2NvcGUucm90YXRlTGVmdCggMiAqIE1hdGguUEkgKiBzY29wZS5jb25zdHJhaW5EZWx0YS54IC8gd2luZG93LmlubmVyV2lkdGggKiBzY29wZS5yb3RhdGVTcGVlZCApO1xuXG4gICAgICAgICAgICAvLyAvLyByb3RhdGluZyB1cCBhbmQgZG93biBhbG9uZyB3aG9sZSBzY3JlZW4gYXR0ZW1wdHMgdG8gZ28gMzYwLCBidXQgbGltaXRlZCB0byAxODBcbiAgICAgICAgICAgIHNjb3BlLnJvdGF0ZVVwKCAyICogTWF0aC5QSSAqIHNjb3BlLmNvbnN0cmFpbkRlbHRhLnkgLyB3aW5kb3cuaW5uZXJIZWlnaHQgKiBzY29wZS5yb3RhdGVTcGVlZCApO1xuXG4gICAgICAgICAgICBvZmZzZXQuY29weSggcG9zaXRpb24gKS5zdWIoIHRoaXMudGFyZ2V0ICk7XG5cbiAgICAgICAgICAgIC8vIHJvdGF0ZSBvZmZzZXQgdG8gXCJ5LWF4aXMtaXMtdXBcIiBzcGFjZVxuICAgICAgICAgICAgb2Zmc2V0LmFwcGx5UXVhdGVybmlvbiggcXVhdCApO1xuXG4gICAgICAgICAgICAvLyBhbmdsZSBmcm9tIHotYXhpcyBhcm91bmQgeS1heGlzXG5cbiAgICAgICAgICAgIHZhciB0aGV0YSA9IE1hdGguYXRhbjIoIG9mZnNldC54LCBvZmZzZXQueiApO1xuXG4gICAgICAgICAgICAvLyBhbmdsZSBmcm9tIHktYXhpc1xuXG4gICAgICAgICAgICB2YXIgcGhpID0gTWF0aC5hdGFuMiggTWF0aC5zcXJ0KCBvZmZzZXQueCAqIG9mZnNldC54ICsgb2Zmc2V0LnogKiBvZmZzZXQueiApLCBvZmZzZXQueSApO1xuXG4gICAgICAgICAgICBpZiAoIHRoaXMuYXV0b1JvdGF0ZSApIHtcblxuICAgICAgICAgICAgICAgIHRoaXMucm90YXRlTGVmdCggZ2V0QXV0b1JvdGF0aW9uQW5nbGUoKSApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoZXRhICs9IHRoZXRhRGVsdGE7XG4gICAgICAgICAgICBwaGkgKz0gcGhpRGVsdGE7XG5cbiAgICAgICAgICAgIC8vIHJlc3RyaWN0IHBoaSB0byBiZSBiZXR3ZWVuIGRlc2lyZWQgbGltaXRzXG4gICAgICAgICAgICBwaGkgPSBNYXRoLm1heCggdGhpcy5taW5Qb2xhckFuZ2xlLCBNYXRoLm1pbiggdGhpcy5tYXhQb2xhckFuZ2xlLCBwaGkgKSApO1xuXG4gICAgICAgICAgICAvLyByZXN0cmljdCBwaGkgdG8gYmUgYmV0d2VlIEVQUyBhbmQgUEktRVBTXG4gICAgICAgICAgICBwaGkgPSBNYXRoLm1heCggRVBTLCBNYXRoLm1pbiggTWF0aC5QSSAtIEVQUywgcGhpICkgKTtcblxuICAgICAgICAgICAgdmFyIHJhZGl1cyA9IG9mZnNldC5sZW5ndGgoKSAqIHNjYWxlO1xuXG4gICAgICAgICAgICAvLyByZXN0cmljdCByYWRpdXMgdG8gYmUgYmV0d2VlbiBkZXNpcmVkIGxpbWl0c1xuICAgICAgICAgICAgcmFkaXVzID0gTWF0aC5tYXgoIHRoaXMubWluRGlzdGFuY2UsIE1hdGgubWluKCB0aGlzLm1heERpc3RhbmNlLCByYWRpdXMgKSApO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBtb3ZlIHRhcmdldCB0byBwYW5uZWQgbG9jYXRpb25cbiAgICAgICAgICAgIHRoaXMudGFyZ2V0LmFkZCggcGFuICk7XG5cbiAgICAgICAgICAgIHNjb3BlLnBoaSA9IHBoaVxuICAgICAgICAgICAgc2NvcGUudGhldGEgPSB0aGV0YVxuXG4gICAgICAgICAgICBvZmZzZXQueCA9IHJhZGl1cyAqIE1hdGguc2luKCBwaGkgKSAqIE1hdGguc2luKCB0aGV0YSApO1xuICAgICAgICAgICAgb2Zmc2V0LnkgPSByYWRpdXMgKiBNYXRoLmNvcyggcGhpICk7XG4gICAgICAgICAgICBvZmZzZXQueiA9IHJhZGl1cyAqIE1hdGguc2luKCBwaGkgKSAqIE1hdGguY29zKCB0aGV0YSApO1xuXG4gICAgICAgICAgICAvLyByb3RhdGUgb2Zmc2V0IGJhY2sgdG8gXCJjYW1lcmEtdXAtdmVjdG9yLWlzLXVwXCIgc3BhY2VcbiAgICAgICAgICAgIG9mZnNldC5hcHBseVF1YXRlcm5pb24oIHF1YXRJbnZlcnNlICk7XG5cbiAgICAgICAgICAgIHBvc2l0aW9uLmNvcHkoIHRoaXMudGFyZ2V0ICkuYWRkKCBvZmZzZXQgKTtcblxuICAgICAgICAgICAgdGhpcy5vYmplY3QubG9va0F0KCB0aGlzLnRhcmdldCApO1xuXG4gICAgICAgICAgICB0aGV0YURlbHRhID0gMDtcbiAgICAgICAgICAgIHBoaURlbHRhID0gMDtcbiAgICAgICAgICAgIHNjYWxlID0gMTtcbiAgICAgICAgICAgIHBhbi5zZXQoIDAsIDAsIDAgKTtcblxuICAgICAgICAgICAgaWYgKCBsYXN0UG9zaXRpb24uZGlzdGFuY2VUb1NxdWFyZWQoIHRoaXMub2JqZWN0LnBvc2l0aW9uICkgPiBFUFMgKSB7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoIGNoYW5nZUV2ZW50ICk7XG5cbiAgICAgICAgICAgICAgICBsYXN0UG9zaXRpb24uY29weSggdGhpcy5vYmplY3QucG9zaXRpb24gKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH07XG5cblxuICAgICAgICB0aGlzLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICBzdGF0ZSA9IFNUQVRFLk5PTkU7XG5cbiAgICAgICAgICAgIHRoaXMudGFyZ2V0LmNvcHkoIHRoaXMudGFyZ2V0MCApO1xuICAgICAgICAgICAgdGhpcy5vYmplY3QucG9zaXRpb24uY29weSggdGhpcy5wb3NpdGlvbjAgKTtcblxuICAgICAgICAgICAgdGhpcy51cGRhdGUoKTtcblxuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIGdldEF1dG9Sb3RhdGlvbkFuZ2xlKCkge1xuXG4gICAgICAgICAgICByZXR1cm4gMiAqIE1hdGguUEkgLyA2MCAvIDYwICogc2NvcGUuYXV0b1JvdGF0ZVNwZWVkO1xuXG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBnZXRab29tU2NhbGUoKSB7XG5cbiAgICAgICAgICAgIHJldHVybiBNYXRoLnBvdyggMC45NSwgc2NvcGUuem9vbVNwZWVkICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIG9uTW91c2VEb3duKCBldmVudCApIHtcblxuICAgICAgICAgICAgaWYgKCBzY29wZS5lbmFibGVkID09PSBmYWxzZSApIHJldHVybjtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICAgIGlmICggZXZlbnQuYnV0dG9uID09PSAwICkge1xuICAgICAgICAgICAgICAgIGlmICggc2NvcGUubm9Sb3RhdGUgPT09IHRydWUgKSByZXR1cm47XG5cbiAgICAgICAgICAgICAgICBzdGF0ZSA9IFNUQVRFLlJPVEFURTtcblxuICAgICAgICAgICAgICAgIHJvdGF0ZVN0YXJ0LnNldCggZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSApO1xuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCBldmVudC5idXR0b24gPT09IDEgKSB7XG4gICAgICAgICAgICAgICAgaWYgKCBzY29wZS5ub1pvb20gPT09IHRydWUgKSByZXR1cm47XG5cbiAgICAgICAgICAgICAgICBzdGF0ZSA9IFNUQVRFLkRPTExZO1xuXG4gICAgICAgICAgICAgICAgZG9sbHlTdGFydC5zZXQoIGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkgKTtcblxuICAgICAgICAgICAgfSBlbHNlIGlmICggZXZlbnQuYnV0dG9uID09PSAyICkge1xuICAgICAgICAgICAgICAgIGlmICggc2NvcGUubm9QYW4gPT09IHRydWUgKSByZXR1cm47XG5cbiAgICAgICAgICAgICAgICBzdGF0ZSA9IFNUQVRFLlBBTjtcblxuICAgICAgICAgICAgICAgIHBhblN0YXJ0LnNldCggZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNjb3BlLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggJ21vdXNlbW92ZScsIG9uTW91c2VNb3ZlLCBmYWxzZSApO1xuICAgICAgICAgICAgc2NvcGUuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCAnbW91c2V1cCcsIG9uTW91c2VVcCwgZmFsc2UgKTtcbiAgICAgICAgICAgIHNjb3BlLmRpc3BhdGNoRXZlbnQoIHN0YXJ0RXZlbnQgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gb25Nb3VzZU1vdmUoIGV2ZW50ICkge1xuXG4gICAgICAgICAgICBpZiAoIHNjb3BlLmVuYWJsZWQgPT09IGZhbHNlICkgcmV0dXJuO1xuXG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgICB2YXIgZWxlbWVudCA9IHNjb3BlLmRvbUVsZW1lbnQgPT09IGRvY3VtZW50ID8gc2NvcGUuZG9tRWxlbWVudC5ib2R5IDogc2NvcGUuZG9tRWxlbWVudDtcblxuICAgICAgICAgICAgaWYgKCBzdGF0ZSA9PT0gU1RBVEUuUk9UQVRFICkge1xuXG4gICAgICAgICAgICAgICAgaWYgKCBzY29wZS5ub1JvdGF0ZSA9PT0gdHJ1ZSApIHJldHVybjtcblxuICAgICAgICAgICAgICAgIHJvdGF0ZUVuZC5zZXQoIGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkgKTtcbiAgICAgICAgICAgICAgICByb3RhdGVEZWx0YS5zdWJWZWN0b3JzKCByb3RhdGVFbmQsIHJvdGF0ZVN0YXJ0ICk7XG5cbiAgICAgICAgICAgICAgICBzY29wZS5jb25zdHJhaW5EZWx0YS54ID0gcm90YXRlRGVsdGEueDtcbiAgICAgICAgICAgICAgICBzY29wZS5jb25zdHJhaW5EZWx0YS55ID0gcm90YXRlRGVsdGEueTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBUd2Vlbk1heC5raWxsVHdlZW5zT2Yoc2NvcGUuY29uc3RyYWluRGVsdGEpO1xuICAgICAgICAgICAgICAgIFR3ZWVuTWF4LnRvKHNjb3BlLmNvbnN0cmFpbkRlbHRhLCAwLjUwLCB7XG4gICAgICAgICAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgICAgICAgICAgIGVhc2U6ICdlYXNlT3V0UXVhZCcsXG4gICAgICAgICAgICAgICAgICAgIGRlbGF5OiAwLjBcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHJvdGF0ZVN0YXJ0LmNvcHkoIHJvdGF0ZUVuZCApO1xuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCBzdGF0ZSA9PT0gU1RBVEUuRE9MTFkgKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoIHNjb3BlLm5vWm9vbSA9PT0gdHJ1ZSApIHJldHVybjtcblxuICAgICAgICAgICAgICAgIGRvbGx5RW5kLnNldCggZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSApO1xuICAgICAgICAgICAgICAgIGRvbGx5RGVsdGEuc3ViVmVjdG9ycyggZG9sbHlFbmQsIGRvbGx5U3RhcnQgKTtcblxuICAgICAgICAgICAgICAgIGlmICggZG9sbHlEZWx0YS55ID4gMCApIHtcblxuICAgICAgICAgICAgICAgICAgICBzY29wZS5kb2xseUluKCk7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgIHNjb3BlLmRvbGx5T3V0KCk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBkb2xseVN0YXJ0LmNvcHkoIGRvbGx5RW5kICk7XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIHN0YXRlID09PSBTVEFURS5QQU4gKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoIHNjb3BlLm5vUGFuID09PSB0cnVlICkgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgcGFuRW5kLnNldCggZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSApO1xuICAgICAgICAgICAgICAgIHBhbkRlbHRhLnN1YlZlY3RvcnMoIHBhbkVuZCwgcGFuU3RhcnQgKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBzY29wZS5wYW4oIHBhbkRlbHRhLngsIHBhbkRlbHRhLnkgKTtcblxuICAgICAgICAgICAgICAgIHBhblN0YXJ0LmNvcHkoIHBhbkVuZCApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNjb3BlLnVwZGF0ZSgpO1xuXG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBvbk1vdXNlVXAoIC8qIGV2ZW50ICovICkge1xuXG4gICAgICAgICAgICBpZiAoIHNjb3BlLmVuYWJsZWQgPT09IGZhbHNlICkgcmV0dXJuO1xuXG4gICAgICAgICAgICBzY29wZS5kb21FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoICdtb3VzZW1vdmUnLCBvbk1vdXNlTW92ZSwgZmFsc2UgKTtcbiAgICAgICAgICAgIHNjb3BlLmRvbUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ21vdXNldXAnLCBvbk1vdXNlVXAsIGZhbHNlICk7XG4gICAgICAgICAgICBzY29wZS5kaXNwYXRjaEV2ZW50KCBlbmRFdmVudCApO1xuICAgICAgICAgICAgc3RhdGUgPSBTVEFURS5OT05FO1xuXG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBvbk1vdXNlV2hlZWwoIGV2ZW50ICkge1xuXG4gICAgICAgICAgICBpZiAoIHNjb3BlLmVuYWJsZWQgPT09IGZhbHNlIHx8IHNjb3BlLm5vWm9vbSA9PT0gdHJ1ZSApIHJldHVybjtcblxuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICAgICAgICB2YXIgZGVsdGEgPSAwO1xuXG4gICAgICAgICAgICBpZiAoIGV2ZW50LndoZWVsRGVsdGEgIT09IHVuZGVmaW5lZCApIHsgLy8gV2ViS2l0IC8gT3BlcmEgLyBFeHBsb3JlciA5XG5cbiAgICAgICAgICAgICAgICBkZWx0YSA9IGV2ZW50LndoZWVsRGVsdGE7XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIGV2ZW50LmRldGFpbCAhPT0gdW5kZWZpbmVkICkgeyAvLyBGaXJlZm94XG5cbiAgICAgICAgICAgICAgICBkZWx0YSA9IC0gZXZlbnQuZGV0YWlsO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggZGVsdGEgPiAwICkge1xuXG4gICAgICAgICAgICAgICAgc2NvcGUuZG9sbHlPdXQoKTtcblxuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgIHNjb3BlLmRvbGx5SW4oKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzY29wZS51cGRhdGUoKTtcbiAgICAgICAgICAgIHNjb3BlLmRpc3BhdGNoRXZlbnQoIHN0YXJ0RXZlbnQgKTtcbiAgICAgICAgICAgIHNjb3BlLmRpc3BhdGNoRXZlbnQoIGVuZEV2ZW50ICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIG9uS2V5RG93biggZXZlbnQgKSB7XG5cbiAgICAgICAgICAgIGlmICggc2NvcGUuZW5hYmxlZCA9PT0gZmFsc2UgfHwgc2NvcGUubm9LZXlzID09PSB0cnVlIHx8IHNjb3BlLm5vUGFuID09PSB0cnVlICkgcmV0dXJuO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBzd2l0Y2ggKCBldmVudC5rZXlDb2RlICkge1xuXG4gICAgICAgICAgICAgICAgY2FzZSBzY29wZS5rZXlzLlVQOlxuICAgICAgICAgICAgICAgICAgICBzY29wZS5wYW4oIDAsIHNjb3BlLmtleVBhblNwZWVkICk7XG4gICAgICAgICAgICAgICAgICAgIHNjb3BlLnVwZGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2Ugc2NvcGUua2V5cy5CT1RUT006XG4gICAgICAgICAgICAgICAgICAgIHNjb3BlLnBhbiggMCwgLSBzY29wZS5rZXlQYW5TcGVlZCApO1xuICAgICAgICAgICAgICAgICAgICBzY29wZS51cGRhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlIHNjb3BlLmtleXMuTEVGVDpcbiAgICAgICAgICAgICAgICAgICAgc2NvcGUucGFuKCBzY29wZS5rZXlQYW5TcGVlZCwgMCApO1xuICAgICAgICAgICAgICAgICAgICBzY29wZS51cGRhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlIHNjb3BlLmtleXMuUklHSFQ6XG4gICAgICAgICAgICAgICAgICAgIHNjb3BlLnBhbiggLSBzY29wZS5rZXlQYW5TcGVlZCwgMCApO1xuICAgICAgICAgICAgICAgICAgICBzY29wZS51cGRhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gdG91Y2hzdGFydCggZXZlbnQgKSB7XG5cbiAgICAgICAgICAgIGlmICggc2NvcGUuZW5hYmxlZCA9PT0gZmFsc2UgKSByZXR1cm47XG5cbiAgICAgICAgICAgIHN3aXRjaCAoIGV2ZW50LnRvdWNoZXMubGVuZ3RoICkge1xuXG4gICAgICAgICAgICAgICAgY2FzZSAxOiAvLyBvbmUtZmluZ2VyZWQgdG91Y2g6IHJvdGF0ZVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICggc2NvcGUubm9Sb3RhdGUgPT09IHRydWUgKSByZXR1cm47XG5cbiAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSBTVEFURS5UT1VDSF9ST1RBVEU7XG5cbiAgICAgICAgICAgICAgICAgICAgcm90YXRlU3RhcnQuc2V0KCBldmVudC50b3VjaGVzWyAwIF0ucGFnZVgsIGV2ZW50LnRvdWNoZXNbIDAgXS5wYWdlWSApO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgMjogLy8gdHdvLWZpbmdlcmVkIHRvdWNoOiBkb2xseVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICggc2NvcGUubm9ab29tID09PSB0cnVlICkgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlID0gU1RBVEUuVE9VQ0hfRE9MTFk7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGR4ID0gZXZlbnQudG91Y2hlc1sgMCBdLnBhZ2VYIC0gZXZlbnQudG91Y2hlc1sgMSBdLnBhZ2VYO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZHkgPSBldmVudC50b3VjaGVzWyAwIF0ucGFnZVkgLSBldmVudC50b3VjaGVzWyAxIF0ucGFnZVk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkaXN0YW5jZSA9IE1hdGguc3FydCggZHggKiBkeCArIGR5ICogZHkgKTtcbiAgICAgICAgICAgICAgICAgICAgZG9sbHlTdGFydC5zZXQoIDAsIGRpc3RhbmNlICk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAzOiAvLyB0aHJlZS1maW5nZXJlZCB0b3VjaDogcGFuXG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBzY29wZS5ub1BhbiA9PT0gdHJ1ZSApIHJldHVybjtcblxuICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IFNUQVRFLlRPVUNIX1BBTjtcblxuICAgICAgICAgICAgICAgICAgICBwYW5TdGFydC5zZXQoIGV2ZW50LnRvdWNoZXNbIDAgXS5wYWdlWCwgZXZlbnQudG91Y2hlc1sgMCBdLnBhZ2VZICk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcblxuICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IFNUQVRFLk5PTkU7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2NvcGUuZGlzcGF0Y2hFdmVudCggc3RhcnRFdmVudCApO1xuXG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiB0b3VjaG1vdmUoIGV2ZW50ICkge1xuXG4gICAgICAgICAgICBpZiAoIHNjb3BlLmVuYWJsZWQgPT09IGZhbHNlICkgcmV0dXJuO1xuXG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICAgICAgICAgIHZhciBlbGVtZW50ID0gc2NvcGUuZG9tRWxlbWVudCA9PT0gZG9jdW1lbnQgPyBzY29wZS5kb21FbGVtZW50LmJvZHkgOiBzY29wZS5kb21FbGVtZW50O1xuXG4gICAgICAgICAgICBzd2l0Y2ggKCBldmVudC50b3VjaGVzLmxlbmd0aCApIHtcblxuICAgICAgICAgICAgICAgIGNhc2UgMTogLy8gb25lLWZpbmdlcmVkIHRvdWNoOiByb3RhdGVcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIHNjb3BlLm5vUm90YXRlID09PSB0cnVlICkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIHN0YXRlICE9PSBTVEFURS5UT1VDSF9ST1RBVEUgKSByZXR1cm47XG5cbiAgICAgICAgICAgICAgICAgICAgcm90YXRlRW5kLnNldCggZXZlbnQudG91Y2hlc1sgMCBdLnBhZ2VYLCBldmVudC50b3VjaGVzWyAwIF0ucGFnZVkgKTtcbiAgICAgICAgICAgICAgICAgICAgcm90YXRlRGVsdGEuc3ViVmVjdG9ycyggcm90YXRlRW5kLCByb3RhdGVTdGFydCApO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIHJvdGF0aW5nIGFjcm9zcyB3aG9sZSBzY3JlZW4gZ29lcyAzNjAgZGVncmVlcyBhcm91bmRcbiAgICAgICAgICAgICAgICAgICAgc2NvcGUucm90YXRlTGVmdCggMiAqIE1hdGguUEkgKiByb3RhdGVEZWx0YS54IC8gZWxlbWVudC5jbGllbnRXaWR0aCAqIHNjb3BlLnJvdGF0ZVNwZWVkICk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJvdGF0aW5nIHVwIGFuZCBkb3duIGFsb25nIHdob2xlIHNjcmVlbiBhdHRlbXB0cyB0byBnbyAzNjAsIGJ1dCBsaW1pdGVkIHRvIDE4MFxuICAgICAgICAgICAgICAgICAgICBzY29wZS5yb3RhdGVVcCggMiAqIE1hdGguUEkgKiByb3RhdGVEZWx0YS55IC8gZWxlbWVudC5jbGllbnRIZWlnaHQgKiBzY29wZS5yb3RhdGVTcGVlZCApO1xuXG4gICAgICAgICAgICAgICAgICAgIHJvdGF0ZVN0YXJ0LmNvcHkoIHJvdGF0ZUVuZCApO1xuXG4gICAgICAgICAgICAgICAgICAgIHNjb3BlLnVwZGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgMjogLy8gdHdvLWZpbmdlcmVkIHRvdWNoOiBkb2xseVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICggc2NvcGUubm9ab29tID09PSB0cnVlICkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIHN0YXRlICE9PSBTVEFURS5UT1VDSF9ET0xMWSApIHJldHVybjtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgZHggPSBldmVudC50b3VjaGVzWyAwIF0ucGFnZVggLSBldmVudC50b3VjaGVzWyAxIF0ucGFnZVg7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkeSA9IGV2ZW50LnRvdWNoZXNbIDAgXS5wYWdlWSAtIGV2ZW50LnRvdWNoZXNbIDEgXS5wYWdlWTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRpc3RhbmNlID0gTWF0aC5zcXJ0KCBkeCAqIGR4ICsgZHkgKiBkeSApO1xuXG4gICAgICAgICAgICAgICAgICAgIGRvbGx5RW5kLnNldCggMCwgZGlzdGFuY2UgKTtcbiAgICAgICAgICAgICAgICAgICAgZG9sbHlEZWx0YS5zdWJWZWN0b3JzKCBkb2xseUVuZCwgZG9sbHlTdGFydCApO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggZG9sbHlEZWx0YS55ID4gMCApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUuZG9sbHlPdXQoKTtcblxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBzY29wZS5kb2xseUluKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGRvbGx5U3RhcnQuY29weSggZG9sbHlFbmQgKTtcblxuICAgICAgICAgICAgICAgICAgICBzY29wZS51cGRhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlIDM6IC8vIHRocmVlLWZpbmdlcmVkIHRvdWNoOiBwYW5cblxuICAgICAgICAgICAgICAgICAgICBpZiAoIHNjb3BlLm5vUGFuID09PSB0cnVlICkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIHN0YXRlICE9PSBTVEFURS5UT1VDSF9QQU4gKSByZXR1cm47XG5cbiAgICAgICAgICAgICAgICAgICAgcGFuRW5kLnNldCggZXZlbnQudG91Y2hlc1sgMCBdLnBhZ2VYLCBldmVudC50b3VjaGVzWyAwIF0ucGFnZVkgKTtcbiAgICAgICAgICAgICAgICAgICAgcGFuRGVsdGEuc3ViVmVjdG9ycyggcGFuRW5kLCBwYW5TdGFydCApO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgc2NvcGUucGFuKCBwYW5EZWx0YS54LCBwYW5EZWx0YS55ICk7XG5cbiAgICAgICAgICAgICAgICAgICAgcGFuU3RhcnQuY29weSggcGFuRW5kICk7XG5cbiAgICAgICAgICAgICAgICAgICAgc2NvcGUudXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcblxuICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IFNUQVRFLk5PTkU7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gdG91Y2hlbmQoIC8qIGV2ZW50ICovICkge1xuXG4gICAgICAgICAgICBpZiAoIHNjb3BlLmVuYWJsZWQgPT09IGZhbHNlICkgcmV0dXJuO1xuXG4gICAgICAgICAgICBzY29wZS5kaXNwYXRjaEV2ZW50KCBlbmRFdmVudCApO1xuICAgICAgICAgICAgc3RhdGUgPSBTVEFURS5OT05FO1xuXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggJ2NvbnRleHRtZW51JywgZnVuY3Rpb24gKCBldmVudCApIHsgZXZlbnQucHJldmVudERlZmF1bHQoKTsgfSwgZmFsc2UgKTtcbiAgICAgICAgdGhpcy5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoICdtb3VzZWRvd24nLCBvbk1vdXNlRG93biwgZmFsc2UgKTtcbiAgICAgICAgdGhpcy5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoICdtb3VzZXdoZWVsJywgb25Nb3VzZVdoZWVsLCBmYWxzZSApO1xuICAgICAgICB0aGlzLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggJ0RPTU1vdXNlU2Nyb2xsJywgb25Nb3VzZVdoZWVsLCBmYWxzZSApOyAvLyBmaXJlZm94XG5cbiAgICAgICAgdGhpcy5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoICd0b3VjaHN0YXJ0JywgdG91Y2hzdGFydCwgZmFsc2UgKTtcbiAgICAgICAgdGhpcy5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoICd0b3VjaGVuZCcsIHRvdWNoZW5kLCBmYWxzZSApO1xuICAgICAgICB0aGlzLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggJ3RvdWNobW92ZScsIHRvdWNobW92ZSwgZmFsc2UgKTtcblxuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggJ2tleWRvd24nLCBvbktleURvd24sIGZhbHNlICk7XG5cbiAgICAgICAgLy8gZm9yY2UgYW4gdXBkYXRlIGF0IHN0YXJ0XG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG5cbiAgICB9O1xuXG4gICAgaW5oZXJpdHMoT3JiaXRDb250cm9scywgVEhSRUUuRXZlbnREaXNwYXRjaGVyKVxuICAgIHJldHVybiBPcmJpdENvbnRyb2xzXG59XG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSkiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG51bXR5cGUobnVtLCBkZWYpIHtcblx0cmV0dXJuIHR5cGVvZiBudW0gPT09ICdudW1iZXInXG5cdFx0PyBudW0gXG5cdFx0OiAodHlwZW9mIGRlZiA9PT0gJ251bWJlcicgPyBkZWYgOiAwKVxufSIsIi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGZlcm9zc0BmZXJvc3Mub3JnPiA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cblxudmFyIGJhc2U2NCA9IHJlcXVpcmUoJ2Jhc2U2NC1qcycpXG52YXIgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKVxudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpcy1hcnJheScpXG5cbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MFxuQnVmZmVyLnBvb2xTaXplID0gODE5MiAvLyBub3QgdXNlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uXG5cbnZhciBrTWF4TGVuZ3RoID0gMHgzZmZmZmZmZlxuXG4vKipcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBVc2UgT2JqZWN0IGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBOb3RlOlxuICpcbiAqIC0gSW1wbGVtZW50YXRpb24gbXVzdCBzdXBwb3J0IGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWAgaW5zdGFuY2VzLlxuICogICBGaXJlZm94IDQtMjkgbGFja2VkIHN1cHBvcnQsIGZpeGVkIGluIEZpcmVmb3ggMzArLlxuICogICBTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOC5cbiAqXG4gKiAgLSBDaHJvbWUgOS0xMCBpcyBtaXNzaW5nIHRoZSBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uLlxuICpcbiAqICAtIElFMTAgaGFzIGEgYnJva2VuIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhcnJheXMgb2ZcbiAqICAgIGluY29ycmVjdCBsZW5ndGggaW4gc29tZSBzaXR1YXRpb25zLlxuICpcbiAqIFdlIGRldGVjdCB0aGVzZSBidWdneSBicm93c2VycyBhbmQgc2V0IGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGAgdG8gYGZhbHNlYCBzbyB0aGV5IHdpbGxcbiAqIGdldCB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uLCB3aGljaCBpcyBzbG93ZXIgYnV0IHdpbGwgd29yayBjb3JyZWN0bHkuXG4gKi9cbkJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID0gKGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICB2YXIgYnVmID0gbmV3IEFycmF5QnVmZmVyKDApXG4gICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KGJ1ZilcbiAgICBhcnIuZm9vID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gNDIgfVxuICAgIHJldHVybiA0MiA9PT0gYXJyLmZvbygpICYmIC8vIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkXG4gICAgICAgIHR5cGVvZiBhcnIuc3ViYXJyYXkgPT09ICdmdW5jdGlvbicgJiYgLy8gY2hyb21lIDktMTAgbGFjayBgc3ViYXJyYXlgXG4gICAgICAgIG5ldyBVaW50OEFycmF5KDEpLnN1YmFycmF5KDEsIDEpLmJ5dGVMZW5ndGggPT09IDAgLy8gaWUxMCBoYXMgYnJva2VuIGBzdWJhcnJheWBcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59KSgpXG5cbi8qKlxuICogQ2xhc3M6IEJ1ZmZlclxuICogPT09PT09PT09PT09PVxuICpcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgYXJlIGF1Z21lbnRlZFxuICogd2l0aCBmdW5jdGlvbiBwcm9wZXJ0aWVzIGZvciBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgQVBJIGZ1bmN0aW9ucy4gV2UgdXNlXG4gKiBgVWludDhBcnJheWAgc28gdGhhdCBzcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdCByZXR1cm5zXG4gKiBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBCeSBhdWdtZW50aW5nIHRoZSBpbnN0YW5jZXMsIHdlIGNhbiBhdm9pZCBtb2RpZnlpbmcgdGhlIGBVaW50OEFycmF5YFxuICogcHJvdG90eXBlLlxuICovXG5mdW5jdGlvbiBCdWZmZXIgKHN1YmplY3QsIGVuY29kaW5nLCBub1plcm8pIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEJ1ZmZlcikpXG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoc3ViamVjdCwgZW5jb2RpbmcsIG5vWmVybylcblxuICB2YXIgdHlwZSA9IHR5cGVvZiBzdWJqZWN0XG5cbiAgLy8gRmluZCB0aGUgbGVuZ3RoXG4gIHZhciBsZW5ndGhcbiAgaWYgKHR5cGUgPT09ICdudW1iZXInKVxuICAgIGxlbmd0aCA9IHN1YmplY3QgPiAwID8gc3ViamVjdCA+Pj4gMCA6IDBcbiAgZWxzZSBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAoZW5jb2RpbmcgPT09ICdiYXNlNjQnKVxuICAgICAgc3ViamVjdCA9IGJhc2U2NGNsZWFuKHN1YmplY3QpXG4gICAgbGVuZ3RoID0gQnVmZmVyLmJ5dGVMZW5ndGgoc3ViamVjdCwgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ29iamVjdCcgJiYgc3ViamVjdCAhPT0gbnVsbCkgeyAvLyBhc3N1bWUgb2JqZWN0IGlzIGFycmF5LWxpa2VcbiAgICBpZiAoc3ViamVjdC50eXBlID09PSAnQnVmZmVyJyAmJiBpc0FycmF5KHN1YmplY3QuZGF0YSkpXG4gICAgICBzdWJqZWN0ID0gc3ViamVjdC5kYXRhXG4gICAgbGVuZ3RoID0gK3N1YmplY3QubGVuZ3RoID4gMCA/IE1hdGguZmxvb3IoK3N1YmplY3QubGVuZ3RoKSA6IDBcbiAgfSBlbHNlXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbXVzdCBzdGFydCB3aXRoIG51bWJlciwgYnVmZmVyLCBhcnJheSBvciBzdHJpbmcnKVxuXG4gIGlmICh0aGlzLmxlbmd0aCA+IGtNYXhMZW5ndGgpXG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArXG4gICAgICAnc2l6ZTogMHgnICsga01heExlbmd0aC50b1N0cmluZygxNikgKyAnIGJ5dGVzJylcblxuICB2YXIgYnVmXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFByZWZlcnJlZDogUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICBidWYgPSBCdWZmZXIuX2F1Z21lbnQobmV3IFVpbnQ4QXJyYXkobGVuZ3RoKSlcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIFRISVMgaW5zdGFuY2Ugb2YgQnVmZmVyIChjcmVhdGVkIGJ5IGBuZXdgKVxuICAgIGJ1ZiA9IHRoaXNcbiAgICBidWYubGVuZ3RoID0gbGVuZ3RoXG4gICAgYnVmLl9pc0J1ZmZlciA9IHRydWVcbiAgfVxuXG4gIHZhciBpXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiB0eXBlb2Ygc3ViamVjdC5ieXRlTGVuZ3RoID09PSAnbnVtYmVyJykge1xuICAgIC8vIFNwZWVkIG9wdGltaXphdGlvbiAtLSB1c2Ugc2V0IGlmIHdlJ3JlIGNvcHlpbmcgZnJvbSBhIHR5cGVkIGFycmF5XG4gICAgYnVmLl9zZXQoc3ViamVjdClcbiAgfSBlbHNlIGlmIChpc0FycmF5aXNoKHN1YmplY3QpKSB7XG4gICAgLy8gVHJlYXQgYXJyYXktaXNoIG9iamVjdHMgYXMgYSBieXRlIGFycmF5XG4gICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdWJqZWN0KSkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKVxuICAgICAgICBidWZbaV0gPSBzdWJqZWN0LnJlYWRVSW50OChpKVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspXG4gICAgICAgIGJ1ZltpXSA9ICgoc3ViamVjdFtpXSAlIDI1NikgKyAyNTYpICUgMjU2XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgYnVmLndyaXRlKHN1YmplY3QsIDAsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInICYmICFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiAhbm9aZXJvKSB7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBidWZbaV0gPSAwXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ1ZlxufVxuXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiAoYikge1xuICByZXR1cm4gISEoYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyKVxufVxuXG5CdWZmZXIuY29tcGFyZSA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGEpIHx8ICFCdWZmZXIuaXNCdWZmZXIoYikpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIG11c3QgYmUgQnVmZmVycycpXG5cbiAgdmFyIHggPSBhLmxlbmd0aFxuICB2YXIgeSA9IGIubGVuZ3RoXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbiAmJiBhW2ldID09PSBiW2ldOyBpKyspIHt9XG4gIGlmIChpICE9PSBsZW4pIHtcbiAgICB4ID0gYVtpXVxuICAgIHkgPSBiW2ldXG4gIH1cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG5CdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAncmF3JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIChsaXN0LCB0b3RhbExlbmd0aCkge1xuICBpZiAoIWlzQXJyYXkobGlzdCkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1VzYWdlOiBCdWZmZXIuY29uY2F0KGxpc3RbLCBsZW5ndGhdKScpXG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoMClcbiAgfSBlbHNlIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBsaXN0WzBdXG4gIH1cblxuICB2YXIgaVxuICBpZiAodG90YWxMZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIHRvdGFsTGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB0b3RhbExlbmd0aCArPSBsaXN0W2ldLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIHZhciBidWYgPSBuZXcgQnVmZmVyKHRvdGFsTGVuZ3RoKVxuICB2YXIgcG9zID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpdGVtID0gbGlzdFtpXVxuICAgIGl0ZW0uY29weShidWYsIHBvcylcbiAgICBwb3MgKz0gaXRlbS5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gZnVuY3Rpb24gKHN0ciwgZW5jb2RpbmcpIHtcbiAgdmFyIHJldFxuICBzdHIgPSBzdHIgKyAnJ1xuICBzd2l0Y2ggKGVuY29kaW5nIHx8ICd1dGY4Jykge1xuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ3Jhdyc6XG4gICAgICByZXQgPSBzdHIubGVuZ3RoXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXQgPSBzdHIubGVuZ3RoICogMlxuICAgICAgYnJlYWtcbiAgICBjYXNlICdoZXgnOlxuICAgICAgcmV0ID0gc3RyLmxlbmd0aCA+Pj4gMVxuICAgICAgYnJlYWtcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgICByZXQgPSB1dGY4VG9CeXRlcyhzdHIpLmxlbmd0aFxuICAgICAgYnJlYWtcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgcmV0ID0gYmFzZTY0VG9CeXRlcyhzdHIpLmxlbmd0aFxuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0ID0gc3RyLmxlbmd0aFxuICB9XG4gIHJldHVybiByZXRcbn1cblxuLy8gcHJlLXNldCBmb3IgdmFsdWVzIHRoYXQgbWF5IGV4aXN0IGluIHRoZSBmdXR1cmVcbkJ1ZmZlci5wcm90b3R5cGUubGVuZ3RoID0gdW5kZWZpbmVkXG5CdWZmZXIucHJvdG90eXBlLnBhcmVudCA9IHVuZGVmaW5lZFxuXG4vLyB0b1N0cmluZyhlbmNvZGluZywgc3RhcnQ9MCwgZW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG5cbiAgc3RhcnQgPSBzdGFydCA+Pj4gMFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPT09IEluZmluaXR5ID8gdGhpcy5sZW5ndGggOiBlbmQgPj4+IDBcblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAoZW5kIDw9IHN0YXJ0KSByZXR1cm4gJydcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBiaW5hcnlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIChiKSB7XG4gIGlmKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYikgPT09IDBcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RyID0gJydcbiAgdmFyIG1heCA9IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVNcbiAgaWYgKHRoaXMubGVuZ3RoID4gMCkge1xuICAgIHN0ciA9IHRoaXMudG9TdHJpbmcoJ2hleCcsIDAsIG1heCkubWF0Y2goLy57Mn0vZykuam9pbignICcpXG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KVxuICAgICAgc3RyICs9ICcgLi4uICdcbiAgfVxuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufVxuXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiAoYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKVxufVxuXG4vLyBgZ2V0YCB3aWxsIGJlIHJlbW92ZWQgaW4gTm9kZSAwLjEzK1xuQnVmZmVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gIGNvbnNvbGUubG9nKCcuZ2V0KCkgaXMgZGVwcmVjYXRlZC4gQWNjZXNzIHVzaW5nIGFycmF5IGluZGV4ZXMgaW5zdGVhZC4nKVxuICByZXR1cm4gdGhpcy5yZWFkVUludDgob2Zmc2V0KVxufVxuXG4vLyBgc2V0YCB3aWxsIGJlIHJlbW92ZWQgaW4gTm9kZSAwLjEzK1xuQnVmZmVyLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAodiwgb2Zmc2V0KSB7XG4gIGNvbnNvbGUubG9nKCcuc2V0KCkgaXMgZGVwcmVjYXRlZC4gQWNjZXNzIHVzaW5nIGFycmF5IGluZGV4ZXMgaW5zdGVhZC4nKVxuICByZXR1cm4gdGhpcy53cml0ZVVJbnQ4KHYsIG9mZnNldClcbn1cblxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICAvLyBtdXN0IGJlIGFuIGV2ZW4gbnVtYmVyIG9mIGRpZ2l0c1xuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAoc3RyTGVuICUgMiAhPT0gMCkgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGhleCBzdHJpbmcnKVxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMlxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYnl0ZSA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcbiAgICBpZiAoaXNOYU4oYnl0ZSkpIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBoZXggc3RyaW5nJylcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBieXRlXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIGNoYXJzV3JpdHRlbiA9IGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbiAgcmV0dXJuIGNoYXJzV3JpdHRlblxufVxuXG5mdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIGNoYXJzV3JpdHRlbiA9IGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG4gIHJldHVybiBjaGFyc1dyaXR0ZW5cbn1cblxuZnVuY3Rpb24gYmluYXJ5V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYXNjaWlXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIGNoYXJzV3JpdHRlbiA9IGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxuICByZXR1cm4gY2hhcnNXcml0dGVuXG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHZhciBjaGFyc1dyaXR0ZW4gPSBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG4gIHJldHVybiBjaGFyc1dyaXR0ZW5cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBTdXBwb3J0IGJvdGggKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKVxuICAvLyBhbmQgdGhlIGxlZ2FjeSAoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0LCBsZW5ndGgpXG4gIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgaWYgKCFpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aFxuICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkXG4gICAgfVxuICB9IGVsc2UgeyAgLy8gbGVnYWN5XG4gICAgdmFyIHN3YXAgPSBlbmNvZGluZ1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgb2Zmc2V0ID0gbGVuZ3RoXG4gICAgbGVuZ3RoID0gc3dhcFxuICB9XG5cbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZyB8fCAndXRmOCcpLnRvTG93ZXJDYXNlKClcblxuICB2YXIgcmV0XG4gIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgICAgcmV0ID0gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgICAgcmV0ID0gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIHJldCA9IGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgIHJldCA9IGJpbmFyeVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICByZXQgPSBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0ID0gdXRmMTZsZVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG4gICAgICBicmVha1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJlcyA9ICcnXG4gIHZhciB0bXAgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICBpZiAoYnVmW2ldIDw9IDB4N0YpIHtcbiAgICAgIHJlcyArPSBkZWNvZGVVdGY4Q2hhcih0bXApICsgU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gICAgICB0bXAgPSAnJ1xuICAgIH0gZWxzZSB7XG4gICAgICB0bXAgKz0gJyUnICsgYnVmW2ldLnRvU3RyaW5nKDE2KVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXMgKyBkZWNvZGVVdGY4Q2hhcih0bXApXG59XG5cbmZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gYmluYXJ5U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICByZXR1cm4gYXNjaWlTbGljZShidWYsIHN0YXJ0LCBlbmQpXG59XG5cbmZ1bmN0aW9uIGhleFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW5cblxuICB2YXIgb3V0ID0gJydcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICBvdXQgKz0gdG9IZXgoYnVmW2ldKVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIHZhciByZXMgPSAnJ1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyBieXRlc1tpICsgMV0gKiAyNTYpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIHN0YXJ0ID0gfn5zdGFydFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kXG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IGxlbjtcbiAgICBpZiAoc3RhcnQgPCAwKVxuICAgICAgc3RhcnQgPSAwXG4gIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcbiAgICBzdGFydCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgKz0gbGVuXG4gICAgaWYgKGVuZCA8IDApXG4gICAgICBlbmQgPSAwXG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XG4gICAgZW5kID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpXG4gICAgZW5kID0gc3RhcnRcblxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICByZXR1cm4gQnVmZmVyLl9hdWdtZW50KHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZCkpXG4gIH0gZWxzZSB7XG4gICAgdmFyIHNsaWNlTGVuID0gZW5kIC0gc3RhcnRcbiAgICB2YXIgbmV3QnVmID0gbmV3IEJ1ZmZlcihzbGljZUxlbiwgdW5kZWZpbmVkLCB0cnVlKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2xpY2VMZW47IGkrKykge1xuICAgICAgbmV3QnVmW2ldID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICAgIHJldHVybiBuZXdCdWZcbiAgfVxufVxuXG4vKlxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMClcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0IGlzIG5vdCB1aW50JylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGxlbmd0aClcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgK1xuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXG4gICAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAgIHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIGlmICghKHRoaXNbb2Zmc2V0XSAmIDB4ODApKVxuICAgIHJldHVybiAodGhpc1tvZmZzZXRdKVxuICByZXR1cm4gKCgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDNdIDw8IDI0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDI0KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpXG59XG5cbmZ1bmN0aW9uIGNoZWNrSW50IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignYnVmZmVyIG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbHVlIGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFR5cGVFcnJvcignaW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWVcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MTYgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgMik7IGkgPCBqOyBpKyspIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgJiAoMHhmZiA8PCAoOCAqIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpKSkpID4+PlxuICAgICAgKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkgKiA4XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gdmFsdWVcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Ugb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSB2YWx1ZVxuICB9IGVsc2Ugb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDMyIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCA0KTsgaSA8IGo7IGkrKykge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSA+Pj4gKGxpdHRsZUVuZGlhbiA/IGkgOiAzIC0gaSkgKiA4KSAmIDB4ZmZcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldF0gPSB2YWx1ZVxuICB9IGVsc2Ugb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gdmFsdWVcbiAgfSBlbHNlIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWVcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSB2YWx1ZVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gdmFsdWVcbiAgfSBlbHNlIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gdmFsdWVcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICB9IGVsc2Ugb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9IHZhbHVlXG4gIH0gZWxzZSBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuZnVuY3Rpb24gY2hlY2tJRUVFNzU0IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWx1ZSBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KVxuICByZXR1cm4gb2Zmc2V0ICsgOFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKHRhcmdldCwgdGFyZ2V0X3N0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIHZhciBzb3VyY2UgPSB0aGlzXG5cbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKCF0YXJnZXRfc3RhcnQpIHRhcmdldF9zdGFydCA9IDBcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVyblxuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCBzb3VyY2UubGVuZ3RoID09PSAwKSByZXR1cm5cblxuICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXG4gIGlmIChlbmQgPCBzdGFydCkgdGhyb3cgbmV3IFR5cGVFcnJvcignc291cmNlRW5kIDwgc291cmNlU3RhcnQnKVxuICBpZiAodGFyZ2V0X3N0YXJ0IDwgMCB8fCB0YXJnZXRfc3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aClcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSBzb3VyY2UubGVuZ3RoKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdzb3VyY2VTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgaWYgKGVuZCA8IDAgfHwgZW5kID4gc291cmNlLmxlbmd0aCkgdGhyb3cgbmV3IFR5cGVFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aClcbiAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldF9zdGFydCA8IGVuZCAtIHN0YXJ0KVxuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRfc3RhcnQgKyBzdGFydFxuXG4gIHZhciBsZW4gPSBlbmQgLSBzdGFydFxuXG4gIGlmIChsZW4gPCAxMDAwIHx8ICFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0X3N0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0YXJnZXQuX3NldCh0aGlzLnN1YmFycmF5KHN0YXJ0LCBzdGFydCArIGxlbiksIHRhcmdldF9zdGFydClcbiAgfVxufVxuXG4vLyBmaWxsKHZhbHVlLCBzdGFydD0wLCBlbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uICh2YWx1ZSwgc3RhcnQsIGVuZCkge1xuICBpZiAoIXZhbHVlKSB2YWx1ZSA9IDBcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kKSBlbmQgPSB0aGlzLmxlbmd0aFxuXG4gIGlmIChlbmQgPCBzdGFydCkgdGhyb3cgbmV3IFR5cGVFcnJvcignZW5kIDwgc3RhcnQnKVxuXG4gIC8vIEZpbGwgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuXG4gIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuXG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFR5cGVFcnJvcignc3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChlbmQgPCAwIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICB0aGlzW2ldID0gdmFsdWVcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGJ5dGVzID0gdXRmOFRvQnl0ZXModmFsdWUudG9TdHJpbmcoKSlcbiAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoXG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgdGhpc1tpXSA9IGJ5dGVzW2kgJSBsZW5dXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGBBcnJheUJ1ZmZlcmAgd2l0aCB0aGUgKmNvcGllZCogbWVtb3J5IG9mIHRoZSBidWZmZXIgaW5zdGFuY2UuXG4gKiBBZGRlZCBpbiBOb2RlIDAuMTIuIE9ubHkgYXZhaWxhYmxlIGluIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBBcnJheUJ1ZmZlci5cbiAqL1xuQnVmZmVyLnByb3RvdHlwZS50b0FycmF5QnVmZmVyID0gZnVuY3Rpb24gKCkge1xuICBpZiAodHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgICByZXR1cm4gKG5ldyBCdWZmZXIodGhpcykpLmJ1ZmZlclxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYnVmID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5sZW5ndGgpXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYnVmLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIGJ1ZltpXSA9IHRoaXNbaV1cbiAgICAgIH1cbiAgICAgIHJldHVybiBidWYuYnVmZmVyXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0J1ZmZlci50b0FycmF5QnVmZmVyIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyJylcbiAgfVxufVxuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbnZhciBCUCA9IEJ1ZmZlci5wcm90b3R5cGVcblxuLyoqXG4gKiBBdWdtZW50IGEgVWludDhBcnJheSAqaW5zdGFuY2UqIChub3QgdGhlIFVpbnQ4QXJyYXkgY2xhc3MhKSB3aXRoIEJ1ZmZlciBtZXRob2RzXG4gKi9cbkJ1ZmZlci5fYXVnbWVudCA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgYXJyLmNvbnN0cnVjdG9yID0gQnVmZmVyXG4gIGFyci5faXNCdWZmZXIgPSB0cnVlXG5cbiAgLy8gc2F2ZSByZWZlcmVuY2UgdG8gb3JpZ2luYWwgVWludDhBcnJheSBnZXQvc2V0IG1ldGhvZHMgYmVmb3JlIG92ZXJ3cml0aW5nXG4gIGFyci5fZ2V0ID0gYXJyLmdldFxuICBhcnIuX3NldCA9IGFyci5zZXRcblxuICAvLyBkZXByZWNhdGVkLCB3aWxsIGJlIHJlbW92ZWQgaW4gbm9kZSAwLjEzK1xuICBhcnIuZ2V0ID0gQlAuZ2V0XG4gIGFyci5zZXQgPSBCUC5zZXRcblxuICBhcnIud3JpdGUgPSBCUC53cml0ZVxuICBhcnIudG9TdHJpbmcgPSBCUC50b1N0cmluZ1xuICBhcnIudG9Mb2NhbGVTdHJpbmcgPSBCUC50b1N0cmluZ1xuICBhcnIudG9KU09OID0gQlAudG9KU09OXG4gIGFyci5lcXVhbHMgPSBCUC5lcXVhbHNcbiAgYXJyLmNvbXBhcmUgPSBCUC5jb21wYXJlXG4gIGFyci5jb3B5ID0gQlAuY29weVxuICBhcnIuc2xpY2UgPSBCUC5zbGljZVxuICBhcnIucmVhZFVJbnQ4ID0gQlAucmVhZFVJbnQ4XG4gIGFyci5yZWFkVUludDE2TEUgPSBCUC5yZWFkVUludDE2TEVcbiAgYXJyLnJlYWRVSW50MTZCRSA9IEJQLnJlYWRVSW50MTZCRVxuICBhcnIucmVhZFVJbnQzMkxFID0gQlAucmVhZFVJbnQzMkxFXG4gIGFyci5yZWFkVUludDMyQkUgPSBCUC5yZWFkVUludDMyQkVcbiAgYXJyLnJlYWRJbnQ4ID0gQlAucmVhZEludDhcbiAgYXJyLnJlYWRJbnQxNkxFID0gQlAucmVhZEludDE2TEVcbiAgYXJyLnJlYWRJbnQxNkJFID0gQlAucmVhZEludDE2QkVcbiAgYXJyLnJlYWRJbnQzMkxFID0gQlAucmVhZEludDMyTEVcbiAgYXJyLnJlYWRJbnQzMkJFID0gQlAucmVhZEludDMyQkVcbiAgYXJyLnJlYWRGbG9hdExFID0gQlAucmVhZEZsb2F0TEVcbiAgYXJyLnJlYWRGbG9hdEJFID0gQlAucmVhZEZsb2F0QkVcbiAgYXJyLnJlYWREb3VibGVMRSA9IEJQLnJlYWREb3VibGVMRVxuICBhcnIucmVhZERvdWJsZUJFID0gQlAucmVhZERvdWJsZUJFXG4gIGFyci53cml0ZVVJbnQ4ID0gQlAud3JpdGVVSW50OFxuICBhcnIud3JpdGVVSW50MTZMRSA9IEJQLndyaXRlVUludDE2TEVcbiAgYXJyLndyaXRlVUludDE2QkUgPSBCUC53cml0ZVVJbnQxNkJFXG4gIGFyci53cml0ZVVJbnQzMkxFID0gQlAud3JpdGVVSW50MzJMRVxuICBhcnIud3JpdGVVSW50MzJCRSA9IEJQLndyaXRlVUludDMyQkVcbiAgYXJyLndyaXRlSW50OCA9IEJQLndyaXRlSW50OFxuICBhcnIud3JpdGVJbnQxNkxFID0gQlAud3JpdGVJbnQxNkxFXG4gIGFyci53cml0ZUludDE2QkUgPSBCUC53cml0ZUludDE2QkVcbiAgYXJyLndyaXRlSW50MzJMRSA9IEJQLndyaXRlSW50MzJMRVxuICBhcnIud3JpdGVJbnQzMkJFID0gQlAud3JpdGVJbnQzMkJFXG4gIGFyci53cml0ZUZsb2F0TEUgPSBCUC53cml0ZUZsb2F0TEVcbiAgYXJyLndyaXRlRmxvYXRCRSA9IEJQLndyaXRlRmxvYXRCRVxuICBhcnIud3JpdGVEb3VibGVMRSA9IEJQLndyaXRlRG91YmxlTEVcbiAgYXJyLndyaXRlRG91YmxlQkUgPSBCUC53cml0ZURvdWJsZUJFXG4gIGFyci5maWxsID0gQlAuZmlsbFxuICBhcnIuaW5zcGVjdCA9IEJQLmluc3BlY3RcbiAgYXJyLnRvQXJyYXlCdWZmZXIgPSBCUC50b0FycmF5QnVmZmVyXG5cbiAgcmV0dXJuIGFyclxufVxuXG52YXIgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rXFwvMC05QS16XS9nXG5cbmZ1bmN0aW9uIGJhc2U2NGNsZWFuIChzdHIpIHtcbiAgLy8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxcbiBhbmQgXFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHN0ciA9IHN0cmluZ3RyaW0oc3RyKS5yZXBsYWNlKElOVkFMSURfQkFTRTY0X1JFLCAnJylcbiAgLy8gTm9kZSBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgYmFzZTY0IHN0cmluZ3MgKG1pc3NpbmcgdHJhaWxpbmcgPT09KSwgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgIHN0ciA9IHN0ciArICc9J1xuICB9XG4gIHJldHVybiBzdHJcbn1cblxuZnVuY3Rpb24gc3RyaW5ndHJpbSAoc3RyKSB7XG4gIGlmIChzdHIudHJpbSkgcmV0dXJuIHN0ci50cmltKClcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJylcbn1cblxuZnVuY3Rpb24gaXNBcnJheWlzaCAoc3ViamVjdCkge1xuICByZXR1cm4gaXNBcnJheShzdWJqZWN0KSB8fCBCdWZmZXIuaXNCdWZmZXIoc3ViamVjdCkgfHxcbiAgICAgIHN1YmplY3QgJiYgdHlwZW9mIHN1YmplY3QgPT09ICdvYmplY3QnICYmXG4gICAgICB0eXBlb2Ygc3ViamVjdC5sZW5ndGggPT09ICdudW1iZXInXG59XG5cbmZ1bmN0aW9uIHRvSGV4IChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KVxuICByZXR1cm4gbi50b1N0cmluZygxNilcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYiA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaWYgKGIgPD0gMHg3Rikge1xuICAgICAgYnl0ZUFycmF5LnB1c2goYilcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHN0YXJ0ID0gaVxuICAgICAgaWYgKGIgPj0gMHhEODAwICYmIGIgPD0gMHhERkZGKSBpKytcbiAgICAgIHZhciBoID0gZW5jb2RlVVJJQ29tcG9uZW50KHN0ci5zbGljZShzdGFydCwgaSsxKSkuc3Vic3RyKDEpLnNwbGl0KCclJylcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaC5sZW5ndGg7IGorKykge1xuICAgICAgICBieXRlQXJyYXkucHVzaChwYXJzZUludChoW2pdLCAxNikpXG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKVxuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYywgaGksIGxvXG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGhpID0gYyA+PiA4XG4gICAgbG8gPSBjICUgMjU2XG4gICAgYnl0ZUFycmF5LnB1c2gobG8pXG4gICAgYnl0ZUFycmF5LnB1c2goaGkpXG4gIH1cblxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMgKHN0cikge1xuICByZXR1cm4gYmFzZTY0LnRvQnl0ZUFycmF5KHN0cilcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpXG4gICAgICBicmVha1xuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXVxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIGRlY29kZVV0ZjhDaGFyIChzdHIpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHN0cilcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoMHhGRkZEKSAvLyBVVEYgOCBpbnZhbGlkIGNoYXJcbiAgfVxufVxuIiwidmFyIGxvb2t1cCA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJztcblxuOyhmdW5jdGlvbiAoZXhwb3J0cykge1xuXHQndXNlIHN0cmljdCc7XG5cbiAgdmFyIEFyciA9ICh0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgPyBVaW50OEFycmF5XG4gICAgOiBBcnJheVxuXG5cdHZhciBQTFVTICAgPSAnKycuY2hhckNvZGVBdCgwKVxuXHR2YXIgU0xBU0ggID0gJy8nLmNoYXJDb2RlQXQoMClcblx0dmFyIE5VTUJFUiA9ICcwJy5jaGFyQ29kZUF0KDApXG5cdHZhciBMT1dFUiAgPSAnYScuY2hhckNvZGVBdCgwKVxuXHR2YXIgVVBQRVIgID0gJ0EnLmNoYXJDb2RlQXQoMClcblxuXHRmdW5jdGlvbiBkZWNvZGUgKGVsdCkge1xuXHRcdHZhciBjb2RlID0gZWx0LmNoYXJDb2RlQXQoMClcblx0XHRpZiAoY29kZSA9PT0gUExVUylcblx0XHRcdHJldHVybiA2MiAvLyAnKydcblx0XHRpZiAoY29kZSA9PT0gU0xBU0gpXG5cdFx0XHRyZXR1cm4gNjMgLy8gJy8nXG5cdFx0aWYgKGNvZGUgPCBOVU1CRVIpXG5cdFx0XHRyZXR1cm4gLTEgLy9ubyBtYXRjaFxuXHRcdGlmIChjb2RlIDwgTlVNQkVSICsgMTApXG5cdFx0XHRyZXR1cm4gY29kZSAtIE5VTUJFUiArIDI2ICsgMjZcblx0XHRpZiAoY29kZSA8IFVQUEVSICsgMjYpXG5cdFx0XHRyZXR1cm4gY29kZSAtIFVQUEVSXG5cdFx0aWYgKGNvZGUgPCBMT1dFUiArIDI2KVxuXHRcdFx0cmV0dXJuIGNvZGUgLSBMT1dFUiArIDI2XG5cdH1cblxuXHRmdW5jdGlvbiBiNjRUb0J5dGVBcnJheSAoYjY0KSB7XG5cdFx0dmFyIGksIGosIGwsIHRtcCwgcGxhY2VIb2xkZXJzLCBhcnJcblxuXHRcdGlmIChiNjQubGVuZ3RoICUgNCA+IDApIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpXG5cdFx0fVxuXG5cdFx0Ly8gdGhlIG51bWJlciBvZiBlcXVhbCBzaWducyAocGxhY2UgaG9sZGVycylcblx0XHQvLyBpZiB0aGVyZSBhcmUgdHdvIHBsYWNlaG9sZGVycywgdGhhbiB0aGUgdHdvIGNoYXJhY3RlcnMgYmVmb3JlIGl0XG5cdFx0Ly8gcmVwcmVzZW50IG9uZSBieXRlXG5cdFx0Ly8gaWYgdGhlcmUgaXMgb25seSBvbmUsIHRoZW4gdGhlIHRocmVlIGNoYXJhY3RlcnMgYmVmb3JlIGl0IHJlcHJlc2VudCAyIGJ5dGVzXG5cdFx0Ly8gdGhpcyBpcyBqdXN0IGEgY2hlYXAgaGFjayB0byBub3QgZG8gaW5kZXhPZiB0d2ljZVxuXHRcdHZhciBsZW4gPSBiNjQubGVuZ3RoXG5cdFx0cGxhY2VIb2xkZXJzID0gJz0nID09PSBiNjQuY2hhckF0KGxlbiAtIDIpID8gMiA6ICc9JyA9PT0gYjY0LmNoYXJBdChsZW4gLSAxKSA/IDEgOiAwXG5cblx0XHQvLyBiYXNlNjQgaXMgNC8zICsgdXAgdG8gdHdvIGNoYXJhY3RlcnMgb2YgdGhlIG9yaWdpbmFsIGRhdGFcblx0XHRhcnIgPSBuZXcgQXJyKGI2NC5sZW5ndGggKiAzIC8gNCAtIHBsYWNlSG9sZGVycylcblxuXHRcdC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcblx0XHRsID0gcGxhY2VIb2xkZXJzID4gMCA/IGI2NC5sZW5ndGggLSA0IDogYjY0Lmxlbmd0aFxuXG5cdFx0dmFyIEwgPSAwXG5cblx0XHRmdW5jdGlvbiBwdXNoICh2KSB7XG5cdFx0XHRhcnJbTCsrXSA9IHZcblx0XHR9XG5cblx0XHRmb3IgKGkgPSAwLCBqID0gMDsgaSA8IGw7IGkgKz0gNCwgaiArPSAzKSB7XG5cdFx0XHR0bXAgPSAoZGVjb2RlKGI2NC5jaGFyQXQoaSkpIDw8IDE4KSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMSkpIDw8IDEyKSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMikpIDw8IDYpIHwgZGVjb2RlKGI2NC5jaGFyQXQoaSArIDMpKVxuXHRcdFx0cHVzaCgodG1wICYgMHhGRjAwMDApID4+IDE2KVxuXHRcdFx0cHVzaCgodG1wICYgMHhGRjAwKSA+PiA4KVxuXHRcdFx0cHVzaCh0bXAgJiAweEZGKVxuXHRcdH1cblxuXHRcdGlmIChwbGFjZUhvbGRlcnMgPT09IDIpIHtcblx0XHRcdHRtcCA9IChkZWNvZGUoYjY0LmNoYXJBdChpKSkgPDwgMikgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDEpKSA+PiA0KVxuXHRcdFx0cHVzaCh0bXAgJiAweEZGKVxuXHRcdH0gZWxzZSBpZiAocGxhY2VIb2xkZXJzID09PSAxKSB7XG5cdFx0XHR0bXAgPSAoZGVjb2RlKGI2NC5jaGFyQXQoaSkpIDw8IDEwKSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMSkpIDw8IDQpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAyKSkgPj4gMilcblx0XHRcdHB1c2goKHRtcCA+PiA4KSAmIDB4RkYpXG5cdFx0XHRwdXNoKHRtcCAmIDB4RkYpXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGFyclxuXHR9XG5cblx0ZnVuY3Rpb24gdWludDhUb0Jhc2U2NCAodWludDgpIHtcblx0XHR2YXIgaSxcblx0XHRcdGV4dHJhQnl0ZXMgPSB1aW50OC5sZW5ndGggJSAzLCAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuXHRcdFx0b3V0cHV0ID0gXCJcIixcblx0XHRcdHRlbXAsIGxlbmd0aFxuXG5cdFx0ZnVuY3Rpb24gZW5jb2RlIChudW0pIHtcblx0XHRcdHJldHVybiBsb29rdXAuY2hhckF0KG51bSlcblx0XHR9XG5cblx0XHRmdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuXHRcdFx0cmV0dXJuIGVuY29kZShudW0gPj4gMTggJiAweDNGKSArIGVuY29kZShudW0gPj4gMTIgJiAweDNGKSArIGVuY29kZShudW0gPj4gNiAmIDB4M0YpICsgZW5jb2RlKG51bSAmIDB4M0YpXG5cdFx0fVxuXG5cdFx0Ly8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuXHRcdGZvciAoaSA9IDAsIGxlbmd0aCA9IHVpbnQ4Lmxlbmd0aCAtIGV4dHJhQnl0ZXM7IGkgPCBsZW5ndGg7IGkgKz0gMykge1xuXHRcdFx0dGVtcCA9ICh1aW50OFtpXSA8PCAxNikgKyAodWludDhbaSArIDFdIDw8IDgpICsgKHVpbnQ4W2kgKyAyXSlcblx0XHRcdG91dHB1dCArPSB0cmlwbGV0VG9CYXNlNjQodGVtcClcblx0XHR9XG5cblx0XHQvLyBwYWQgdGhlIGVuZCB3aXRoIHplcm9zLCBidXQgbWFrZSBzdXJlIHRvIG5vdCBmb3JnZXQgdGhlIGV4dHJhIGJ5dGVzXG5cdFx0c3dpdGNoIChleHRyYUJ5dGVzKSB7XG5cdFx0XHRjYXNlIDE6XG5cdFx0XHRcdHRlbXAgPSB1aW50OFt1aW50OC5sZW5ndGggLSAxXVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKHRlbXAgPj4gMilcblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSgodGVtcCA8PCA0KSAmIDB4M0YpXG5cdFx0XHRcdG91dHB1dCArPSAnPT0nXG5cdFx0XHRcdGJyZWFrXG5cdFx0XHRjYXNlIDI6XG5cdFx0XHRcdHRlbXAgPSAodWludDhbdWludDgubGVuZ3RoIC0gMl0gPDwgOCkgKyAodWludDhbdWludDgubGVuZ3RoIC0gMV0pXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUodGVtcCA+PiAxMClcblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSgodGVtcCA+PiA0KSAmIDB4M0YpXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUoKHRlbXAgPDwgMikgJiAweDNGKVxuXHRcdFx0XHRvdXRwdXQgKz0gJz0nXG5cdFx0XHRcdGJyZWFrXG5cdFx0fVxuXG5cdFx0cmV0dXJuIG91dHB1dFxuXHR9XG5cblx0ZXhwb3J0cy50b0J5dGVBcnJheSA9IGI2NFRvQnl0ZUFycmF5XG5cdGV4cG9ydHMuZnJvbUJ5dGVBcnJheSA9IHVpbnQ4VG9CYXNlNjRcbn0odHlwZW9mIGV4cG9ydHMgPT09ICd1bmRlZmluZWQnID8gKHRoaXMuYmFzZTY0anMgPSB7fSkgOiBleHBvcnRzKSlcbiIsImV4cG9ydHMucmVhZCA9IGZ1bmN0aW9uKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sXG4gICAgICBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxLFxuICAgICAgZU1heCA9ICgxIDw8IGVMZW4pIC0gMSxcbiAgICAgIGVCaWFzID0gZU1heCA+PiAxLFxuICAgICAgbkJpdHMgPSAtNyxcbiAgICAgIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMCxcbiAgICAgIGQgPSBpc0xFID8gLTEgOiAxLFxuICAgICAgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXTtcblxuICBpICs9IGQ7XG5cbiAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSk7XG4gIHMgPj49ICgtbkJpdHMpO1xuICBuQml0cyArPSBlTGVuO1xuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gZSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KTtcblxuICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKTtcbiAgZSA+Pj0gKC1uQml0cyk7XG4gIG5CaXRzICs9IG1MZW47XG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSBtICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpO1xuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhcztcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpO1xuICB9IGVsc2Uge1xuICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbik7XG4gICAgZSA9IGUgLSBlQmlhcztcbiAgfVxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKTtcbn07XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbihidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSwgYyxcbiAgICAgIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDEsXG4gICAgICBlTWF4ID0gKDEgPDwgZUxlbikgLSAxLFxuICAgICAgZUJpYXMgPSBlTWF4ID4+IDEsXG4gICAgICBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMCksXG4gICAgICBpID0gaXNMRSA/IDAgOiAobkJ5dGVzIC0gMSksXG4gICAgICBkID0gaXNMRSA/IDEgOiAtMSxcbiAgICAgIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDA7XG5cbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSk7XG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDA7XG4gICAgZSA9IGVNYXg7XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpO1xuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLTtcbiAgICAgIGMgKj0gMjtcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKys7XG4gICAgICBjIC89IDI7XG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMDtcbiAgICAgIGUgPSBlTWF4O1xuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAodmFsdWUgKiBjIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKTtcbiAgICAgIGUgPSBlICsgZUJpYXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKTtcbiAgICAgIGUgPSAwO1xuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpO1xuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG07XG4gIGVMZW4gKz0gbUxlbjtcbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KTtcblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjg7XG59O1xuIiwiXG4vKipcbiAqIGlzQXJyYXlcbiAqL1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbi8qKlxuICogdG9TdHJpbmdcbiAqL1xuXG52YXIgc3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuLyoqXG4gKiBXaGV0aGVyIG9yIG5vdCB0aGUgZ2l2ZW4gYHZhbGBcbiAqIGlzIGFuIGFycmF5LlxuICpcbiAqIGV4YW1wbGU6XG4gKlxuICogICAgICAgIGlzQXJyYXkoW10pO1xuICogICAgICAgIC8vID4gdHJ1ZVxuICogICAgICAgIGlzQXJyYXkoYXJndW1lbnRzKTtcbiAqICAgICAgICAvLyA+IGZhbHNlXG4gKiAgICAgICAgaXNBcnJheSgnJyk7XG4gKiAgICAgICAgLy8gPiBmYWxzZVxuICpcbiAqIEBwYXJhbSB7bWl4ZWR9IHZhbFxuICogQHJldHVybiB7Ym9vbH1cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJyYXkgfHwgZnVuY3Rpb24gKHZhbCkge1xuICByZXR1cm4gISEgdmFsICYmICdbb2JqZWN0IEFycmF5XScgPT0gc3RyLmNhbGwodmFsKTtcbn07XG4iLCJ2YXIgaXNHTCA9IHJlcXVpcmUoJ2lzLXdlYmdsLWNvbnRleHQnKTtcbnZhciBnZXRHTCA9IHJlcXVpcmUoJ3dlYmdsLWNvbnRleHQnKTtcbnZhciBkZWJvdW5jZSA9IHJlcXVpcmUoJ2RlYm91bmNlJyk7XG52YXIgYWRkRXZlbnQgPSByZXF1aXJlKCdhZGQtZXZlbnQtbGlzdGVuZXInKTtcblxuZnVuY3Rpb24gaXNDYW52YXNDb250ZXh0KG9iaikge1xuICAgIHZhciBjdHgyZCA9IHR5cGVvZiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQgIT09ICd1bmRlZmluZWQnICYmIG9iaiBpbnN0YW5jZW9mIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRDtcbiAgICByZXR1cm4gb2JqICYmIChjdHgyZCB8fCBpc0dMKG9iaikpO1xufVxuXG5mdW5jdGlvbiBDYW52YXNBcHAocmVuZGVyLCBvcHRpb25zKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIENhbnZhc0FwcCkpXG4gICAgICAgIHJldHVybiBuZXcgQ2FudmFzQXBwKHJlbmRlciwgb3B0aW9ucyk7XG5cbiAgICAvL2FsbG93IG9wdGlvbnMgdG8gYmUgcGFzc2VkIGFzIGZpcnN0IGFyZ3VtZW50XG4gICAgaWYgKHR5cGVvZiByZW5kZXIgPT09ICdvYmplY3QnICYmIHJlbmRlcikge1xuICAgICAgICBvcHRpb25zID0gcmVuZGVyO1xuICAgICAgICByZW5kZXIgPSBudWxsO1xuICAgIH1cblxuICAgIHJlbmRlciA9IHR5cGVvZiByZW5kZXIgPT09ICdmdW5jdGlvbicgPyByZW5kZXIgOiBvcHRpb25zLm9uUmVuZGVyO1xuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnN8fHt9O1xuICAgIG9wdGlvbnMucmV0aW5hID0gdHlwZW9mIG9wdGlvbnMucmV0aW5hID09PSBcImJvb2xlYW5cIiA/IG9wdGlvbnMucmV0aW5hIDogdHJ1ZTtcbiAgICBcbiAgICB2YXIgaGFzV2lkdGggPSB0eXBlb2Ygb3B0aW9ucy53aWR0aCA9PT0gXCJudW1iZXJcIiwgXG4gICAgICAgIGhhc0hlaWdodCA9IHR5cGVvZiBvcHRpb25zLmhlaWdodCA9PT0gXCJudW1iZXJcIjtcblxuICAgIC8vaWYgZWl0aGVyIHdpZHRoIG9yIGhlaWdodCBpcyBzcGVjaWZpZWQsIGRvbid0IGF1dG8tcmVzaXplIHRvIHRoZSB3aW5kb3cuLi5cbiAgICBpZiAoaGFzV2lkdGggfHwgaGFzSGVpZ2h0KSBcbiAgICAgICAgb3B0aW9ucy5pZ25vcmVSZXNpemUgPSB0cnVlO1xuXG4gICAgb3B0aW9ucy53aWR0aCA9IGhhc1dpZHRoID8gb3B0aW9ucy53aWR0aCA6IHdpbmRvdy5pbm5lcldpZHRoO1xuICAgIG9wdGlvbnMuaGVpZ2h0ID0gaGFzSGVpZ2h0ID8gb3B0aW9ucy5oZWlnaHQgOiB3aW5kb3cuaW5uZXJIZWlnaHQ7XG5cbiAgICB2YXIgRFBSID0gb3B0aW9ucy5yZXRpbmEgPyAod2luZG93LmRldmljZVBpeGVsUmF0aW98fDEpIDogMTsgXG5cbiAgICAvL3NldHVwIHRoZSBjYW52YXNcbiAgICB2YXIgY2FudmFzLFxuICAgICAgICBjb250ZXh0LFxuICAgICAgICBhdHRyaWJzID0gb3B0aW9ucy5jb250ZXh0QXR0cmlidXRlc3x8e307XG5cbiAgICB0aGlzLmlzV2ViR0wgPSBmYWxzZTtcblxuICAgIC8vaWYgdXNlciBwcm92aWRlZCBhIGNvbnRleHQgb2JqZWN0XG4gICAgaWYgKGlzQ2FudmFzQ29udGV4dChvcHRpb25zLmNvbnRleHQpKSB7XG4gICAgICAgIGNvbnRleHQgPSBvcHRpb25zLmNvbnRleHQ7XG4gICAgICAgIGNhbnZhcyA9IGNvbnRleHQuY2FudmFzO1xuICAgIH1cblxuICAgIC8vb3RoZXJ3aXNlIGFsbG93IGZvciBhIHN0cmluZyB0byBzZXQgb25lIHVwXG4gICAgaWYgKCFjYW52YXMpXG4gICAgICAgIGNhbnZhcyA9IG9wdGlvbnMuY2FudmFzIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG5cbiAgICBjYW52YXMud2lkdGggPSBvcHRpb25zLndpZHRoICogRFBSO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBvcHRpb25zLmhlaWdodCAqIERQUjtcblxuICAgIGlmICghY29udGV4dCkge1xuICAgICAgICBpZiAob3B0aW9ucy5jb250ZXh0ID09PSBcIndlYmdsXCIgfHwgb3B0aW9ucy5jb250ZXh0ID09PSBcImV4cGVyaW1lbnRhbC13ZWJnbFwiKSB7XG4gICAgICAgICAgICBjb250ZXh0ID0gZ2V0R0woeyBjYW52YXM6IGNhbnZhcywgYXR0cmlidXRlczogYXR0cmlicyB9KTtcbiAgICAgICAgICAgIGlmICghY29udGV4dCkge1xuICAgICAgICAgICAgICAgIHRocm93IFwiV2ViR0wgQ29udGV4dCBOb3QgU3VwcG9ydGVkIC0tIHRyeSBlbmFibGluZyBpdCBvciB1c2luZyBhIGRpZmZlcmVudCBicm93c2VyXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQob3B0aW9ucy5jb250ZXh0fHxcIjJkXCIsIGF0dHJpYnMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5pc1dlYkdMID0gaXNHTChjb250ZXh0KTtcblxuICAgIGlmIChvcHRpb25zLnJldGluYSkge1xuICAgICAgICBjYW52YXMuc3R5bGUud2lkdGggPSBvcHRpb25zLndpZHRoICsgJ3B4JztcbiAgICAgICAgY2FudmFzLnN0eWxlLmhlaWdodCA9IG9wdGlvbnMuaGVpZ2h0ICsgJ3B4JztcbiAgICB9XG5cbiAgICB0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcbiAgICB0aGlzLndpZHRoID0gb3B0aW9ucy53aWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IG9wdGlvbnMuaGVpZ2h0O1xuICAgIHRoaXMuY2FudmFzID0gY2FudmFzO1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgdGhpcy5vblJlc2l6ZSA9IG9wdGlvbnMub25SZXNpemU7XG4gICAgdGhpcy5fRFBSID0gRFBSO1xuICAgIHRoaXMuX3JldGluYSA9IG9wdGlvbnMucmV0aW5hO1xuICAgIHRoaXMuX29uY2UgPSBvcHRpb25zLm9uY2U7XG4gICAgdGhpcy5faWdub3JlUmVzaXplID0gb3B0aW9ucy5pZ25vcmVSZXNpemU7XG4gICAgdGhpcy5fbGFzdEZyYW1lID0gbnVsbDtcbiAgICB0aGlzLl90aGVuID0gRGF0ZS5ub3coKTtcblxuICAgIC8vRlBTIGNvdW50ZXJcbiAgICB0aGlzLmZwcyA9IDYwO1xuICAgIHRoaXMuX2ZyYW1lcyA9IDA7XG4gICAgdGhpcy5fcHJldlRpbWUgPSB0aGlzLl90aGVuO1xuXG4gICAgaWYgKCF0aGlzLl9pZ25vcmVSZXNpemUpIHtcbiAgICAgICAgb3B0aW9ucy5yZXNpemVEZWJvdW5jZSA9IHR5cGVvZiBvcHRpb25zLnJlc2l6ZURlYm91bmNlID09PSAnbnVtYmVyJ1xuICAgICAgICAgICAgICAgICAgICA/IG9wdGlvbnMucmVzaXplRGVib3VuY2UgOiA1MDtcbiAgICAgICAgYWRkRXZlbnQod2luZG93LCBcInJlc2l6ZVwiLCBkZWJvdW5jZShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMucmVzaXplKHdpbmRvdy5pbm5lcldpZHRoLCB3aW5kb3cuaW5uZXJIZWlnaHQpO1xuICAgICAgICB9LmJpbmQodGhpcyksIG9wdGlvbnMucmVzaXplRGVib3VuY2UsIGZhbHNlKSk7XG5cbiAgICAgICAgYWRkRXZlbnQod2luZG93LCBcIm9yaWVudGF0aW9uY2hhbmdlXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5yZXNpemUod2luZG93LmlubmVyV2lkdGgsIHdpbmRvdy5pbm5lckhlaWdodCk7XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiByZW5kZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aGlzLm9uUmVuZGVyID0gcmVuZGVyLmJpbmQodGhpcyk7ICAgXG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy9kdW1teSByZW5kZXIgZnVuY3Rpb25cbiAgICAgICAgdGhpcy5vblJlbmRlciA9IGZ1bmN0aW9uIChjb250ZXh0LCB3aWR0aCwgaGVpZ2h0LCBkdCkgeyB9O1xuICAgIH1cblxuICAgIHRoaXMucmVuZGVyT25jZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdmFyIGR0ID0gKG5vdy10aGlzLl90aGVuKTtcblxuICAgICAgICB0aGlzLl9mcmFtZXMrKztcbiAgICAgICAgaWYgKG5vdyA+IHRoaXMuX3ByZXZUaW1lICsgMTAwMCkge1xuICAgICAgICAgICAgdGhpcy5mcHMgPSBNYXRoLnJvdW5kKCh0aGlzLl9mcmFtZXMgKiAxMDAwKSAvIChub3cgLSB0aGlzLl9wcmV2VGltZSkpO1xuXG4gICAgICAgICAgICB0aGlzLl9wcmV2VGltZSA9IG5vdztcbiAgICAgICAgICAgIHRoaXMuX2ZyYW1lcyA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuaXNXZWJHTCkge1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0LnNhdmUoKTtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5zY2FsZSh0aGlzLl9EUFIsIHRoaXMuX0RQUik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHQudmlld3BvcnQoMCwgMCwgdGhpcy53aWR0aCAqIHRoaXMuX0RQUiwgdGhpcy5oZWlnaHQgKiB0aGlzLl9EUFIpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICB0aGlzLm9uUmVuZGVyKHRoaXMuY29udGV4dCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIGR0KTtcblxuICAgICAgICBpZiAoIXRoaXMuaXNXZWJHTClcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5yZXN0b3JlKCk7XG5cbiAgICAgICAgdGhpcy5fdGhlbiA9IG5vdztcbiAgICB9O1xuXG4gICAgdGhpcy5fcmVuZGVySGFuZGxlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMucnVubmluZykgXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIFxuICAgICAgICBpZiAoIXRoaXMuX29uY2UpIHtcbiAgICAgICAgICAgIHRoaXMuX2xhc3RGcmFtZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLl9yZW5kZXJIYW5kbGVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucmVuZGVyT25jZSgpO1xuICAgIH0uYmluZCh0aGlzKTtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5vblJlYWR5ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgb3B0aW9ucy5vblJlYWR5LmNhbGwodGhpcywgY29udGV4dCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KENhbnZhc0FwcC5wcm90b3R5cGUsICdyZXRpbmFFbmFibGVkJywge1xuXG4gICAgc2V0OiBmdW5jdGlvbih2KSB7XG4gICAgICAgIHRoaXMuX3JldGluYSA9IHY7XG4gICAgICAgIHRoaXMuX0RQUiA9IHRoaXMuX3JldGluYSA/ICh3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpb3x8MSkgOiAxO1xuICAgICAgICB0aGlzLnJlc2l6ZSh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgfSxcblxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZXRpbmE7XG4gICAgfVxufSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShDYW52YXNBcHAucHJvdG90eXBlLCAnZGV2aWNlV2lkdGgnLCB7XG5cbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy53aWR0aCAqIHRoaXMuX0RQUjtcbiAgICB9XG59KTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KENhbnZhc0FwcC5wcm90b3R5cGUsICdkZXZpY2VIZWlnaHQnLCB7XG5cbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oZWlnaHQgKiB0aGlzLl9EUFI7XG4gICAgfVxufSk7XG5cbkNhbnZhc0FwcC5wcm90b3R5cGUucmVzZXRGUFMgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9mcmFtZXMgPSAwO1xuICAgIHRoaXMuX3ByZXZUaW1lID0gRGF0ZS5ub3coKTtcbiAgICB0aGlzLl90aGVuID0gdGhpcy5fcHJldlRpbWU7XG4gICAgdGhpcy5mcHMgPSA2MDtcbn07XG5cbkNhbnZhc0FwcC5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5ydW5uaW5nKVxuICAgICAgICByZXR1cm47XG4gICAgXG4gICAgaWYgKHRoaXMuX2xhc3RGcmFtZSkgXG4gICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuX2xhc3RGcmFtZSk7XG5cbiAgICAvL3Jlc2V0IEZQUyBjb3VudGVyXG4gICAgdGhpcy5yZXNldEZQUygpO1xuXG4gICAgdGhpcy5ydW5uaW5nID0gdHJ1ZTtcbiAgICB0aGlzLl9sYXN0RnJhbWUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5fcmVuZGVySGFuZGxlcik7XG59O1xuXG5DYW52YXNBcHAucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5fbGFzdEZyYW1lKSB7XG4gICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuX2xhc3RGcmFtZSk7XG4gICAgICAgIHRoaXMuX2xhc3RGcmFtZSA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMucnVubmluZyA9IGZhbHNlO1xufTtcblxuQ2FudmFzQXBwLnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdmFyIGNhbnZhcyA9IHRoaXMuY2FudmFzO1xuXG4gICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIGNhbnZhcy53aWR0aCA9IHRoaXMud2lkdGggKiB0aGlzLl9EUFI7XG4gICAgY2FudmFzLmhlaWdodCA9IHRoaXMuaGVpZ2h0ICogdGhpcy5fRFBSO1xuXG4gICAgaWYgKHRoaXMuX3JldGluYSkge1xuICAgICAgICBjYW52YXMuc3R5bGUud2lkdGggPSB0aGlzLndpZHRoICsgJ3B4JztcbiAgICAgICAgY2FudmFzLnN0eWxlLmhlaWdodCA9IHRoaXMuaGVpZ2h0ICsgJ3B4JztcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fb25jZSlcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuX3JlbmRlckhhbmRsZXIpO1xuICAgIGlmICh0eXBlb2YgdGhpcy5vblJlc2l6ZSA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgICB0aGlzLm9uUmVzaXplKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ2FudmFzQXBwOyIsImFkZEV2ZW50TGlzdGVuZXIucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IHJlbW92ZUV2ZW50TGlzdGVuZXJcbmFkZEV2ZW50TGlzdGVuZXIuYWRkRXZlbnRMaXN0ZW5lciA9IGFkZEV2ZW50TGlzdGVuZXJcblxubW9kdWxlLmV4cG9ydHMgPSBhZGRFdmVudExpc3RlbmVyXG5cbnZhciBFdmVudHMgPSBudWxsXG5cbmZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXIoZWwsIGV2ZW50TmFtZSwgbGlzdGVuZXIsIHVzZUNhcHR1cmUpIHtcbiAgRXZlbnRzID0gRXZlbnRzIHx8IChcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyID9cbiAgICB7YWRkOiBzdGRBdHRhY2gsIHJtOiBzdGREZXRhY2h9IDpcbiAgICB7YWRkOiBvbGRJRUF0dGFjaCwgcm06IG9sZElFRGV0YWNofVxuICApXG4gIFxuICByZXR1cm4gRXZlbnRzLmFkZChlbCwgZXZlbnROYW1lLCBsaXN0ZW5lciwgdXNlQ2FwdHVyZSlcbn1cblxuZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcihlbCwgZXZlbnROYW1lLCBsaXN0ZW5lciwgdXNlQ2FwdHVyZSkge1xuICBFdmVudHMgPSBFdmVudHMgfHwgKFxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIgP1xuICAgIHthZGQ6IHN0ZEF0dGFjaCwgcm06IHN0ZERldGFjaH0gOlxuICAgIHthZGQ6IG9sZElFQXR0YWNoLCBybTogb2xkSUVEZXRhY2h9XG4gIClcbiAgXG4gIHJldHVybiBFdmVudHMucm0oZWwsIGV2ZW50TmFtZSwgbGlzdGVuZXIsIHVzZUNhcHR1cmUpXG59XG5cbmZ1bmN0aW9uIHN0ZEF0dGFjaChlbCwgZXZlbnROYW1lLCBsaXN0ZW5lciwgdXNlQ2FwdHVyZSkge1xuICBlbC5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIsIHVzZUNhcHR1cmUpXG59XG5cbmZ1bmN0aW9uIHN0ZERldGFjaChlbCwgZXZlbnROYW1lLCBsaXN0ZW5lciwgdXNlQ2FwdHVyZSkge1xuICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIsIHVzZUNhcHR1cmUpXG59XG5cbmZ1bmN0aW9uIG9sZElFQXR0YWNoKGVsLCBldmVudE5hbWUsIGxpc3RlbmVyLCB1c2VDYXB0dXJlKSB7XG4gIGlmKHVzZUNhcHR1cmUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCB1c2VDYXB0dXJlIGluIG9sZElFJylcbiAgfVxuXG4gIGVsLmF0dGFjaEV2ZW50KCdvbicgKyBldmVudE5hbWUsIGxpc3RlbmVyKVxufVxuXG5mdW5jdGlvbiBvbGRJRURldGFjaChlbCwgZXZlbnROYW1lLCBsaXN0ZW5lciwgdXNlQ2FwdHVyZSkge1xuICBlbC5kZXRhY2hFdmVudCgnb24nICsgZXZlbnROYW1lLCBsaXN0ZW5lcilcbn1cbiIsIlxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBub3cgPSByZXF1aXJlKCdkYXRlLW5vdycpO1xuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiwgdGhhdCwgYXMgbG9uZyBhcyBpdCBjb250aW51ZXMgdG8gYmUgaW52b2tlZCwgd2lsbCBub3RcbiAqIGJlIHRyaWdnZXJlZC4gVGhlIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIGFmdGVyIGl0IHN0b3BzIGJlaW5nIGNhbGxlZCBmb3JcbiAqIE4gbWlsbGlzZWNvbmRzLiBJZiBgaW1tZWRpYXRlYCBpcyBwYXNzZWQsIHRyaWdnZXIgdGhlIGZ1bmN0aW9uIG9uIHRoZVxuICogbGVhZGluZyBlZGdlLCBpbnN0ZWFkIG9mIHRoZSB0cmFpbGluZy5cbiAqXG4gKiBAc291cmNlIHVuZGVyc2NvcmUuanNcbiAqIEBzZWUgaHR0cDovL3Vuc2NyaXB0YWJsZS5jb20vMjAwOS8wMy8yMC9kZWJvdW5jaW5nLWphdmFzY3JpcHQtbWV0aG9kcy9cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmN0aW9uIHRvIHdyYXBcbiAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lb3V0IGluIG1zIChgMTAwYClcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gd2hldGhlciB0byBleGVjdXRlIGF0IHRoZSBiZWdpbm5pbmcgKGBmYWxzZWApXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZGVib3VuY2UoZnVuYywgd2FpdCwgaW1tZWRpYXRlKXtcbiAgdmFyIHRpbWVvdXQsIGFyZ3MsIGNvbnRleHQsIHRpbWVzdGFtcCwgcmVzdWx0O1xuICBpZiAobnVsbCA9PSB3YWl0KSB3YWl0ID0gMTAwO1xuXG4gIGZ1bmN0aW9uIGxhdGVyKCkge1xuICAgIHZhciBsYXN0ID0gbm93KCkgLSB0aW1lc3RhbXA7XG5cbiAgICBpZiAobGFzdCA8IHdhaXQgJiYgbGFzdCA+IDApIHtcbiAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCB3YWl0IC0gbGFzdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgaWYgKCFpbW1lZGlhdGUpIHtcbiAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgaWYgKCF0aW1lb3V0KSBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBmdW5jdGlvbiBkZWJvdW5jZWQoKSB7XG4gICAgY29udGV4dCA9IHRoaXM7XG4gICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICB0aW1lc3RhbXAgPSBub3coKTtcbiAgICB2YXIgY2FsbE5vdyA9IGltbWVkaWF0ZSAmJiAhdGltZW91dDtcbiAgICBpZiAoIXRpbWVvdXQpIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCB3YWl0KTtcbiAgICBpZiAoY2FsbE5vdykge1xuICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgIGNvbnRleHQgPSBhcmdzID0gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gRGF0ZS5ub3cgfHwgbm93XG5cbmZ1bmN0aW9uIG5vdygpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKClcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oY3R4KSB7XG5cdGlmICghY3R4KSByZXR1cm4gZmFsc2Vcblx0dmFyIGdsID0gY3R4XG5cdC8vY29tcGF0aWJpbGl0eSB3aXRoIENocm9tZSBXZWJHTCBJbnNwZWN0b3IgQWRkb25cblx0aWYgKHR5cGVvZiBjdHgucmF3Z2wgIT09ICd1bmRlZmluZWQnKVxuXHRcdGdsID0gY3R4LnJhd2dsXG5cdGlmICh0eXBlb2YgV2ViR0xSZW5kZXJpbmdDb250ZXh0ICE9PSAndW5kZWZpbmVkJyAmJiBnbCBpbnN0YW5jZW9mIFdlYkdMUmVuZGVyaW5nQ29udGV4dClcblx0XHRyZXR1cm4gdHJ1ZVxuXHRyZXR1cm4gZmFsc2Vcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9wdHMpIHtcbiAgICBvcHRzID0gb3B0c3x8e307XG4gICAgdmFyIGNhbnZhcyA9IG9wdHMuY2FudmFzIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgaWYgKHR5cGVvZiBvcHRzLndpZHRoID09PSBcIm51bWJlclwiKVxuICAgICAgICBjYW52YXMud2lkdGggPSBvcHRzLndpZHRoO1xuICAgIGlmICh0eXBlb2Ygb3B0cy5oZWlnaHQgPT09IFwibnVtYmVyXCIpXG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSBvcHRzLmhlaWdodDtcbiAgICBcbiAgICB2YXIgYXR0cmlicyA9IChvcHRzLmF0dHJpYnV0ZXMgfHwgb3B0cy5hdHRyaWJzIHx8IHt9KTtcbiAgICB0cnkge1xuICAgICAgICBnbCA9IChjYW52YXMuZ2V0Q29udGV4dCgnd2ViZ2wnLCBhdHRyaWJzKSB8fCBjYW52YXMuZ2V0Q29udGV4dCgnZXhwZXJpbWVudGFsLXdlYmdsJywgYXR0cmlicykpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgZ2wgPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gZ2w7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gY2xhbXBcblxuZnVuY3Rpb24gY2xhbXAodmFsdWUsIG1pbiwgbWF4KSB7XG4gIHJldHVybiBtaW4gPCBtYXhcbiAgICA/ICh2YWx1ZSA8IG1pbiA/IG1pbiA6IHZhbHVlID4gbWF4ID8gbWF4IDogdmFsdWUpXG4gICAgOiAodmFsdWUgPCBtYXggPyBtYXggOiB2YWx1ZSA+IG1pbiA/IG1pbiA6IHZhbHVlKVxufVxuIiwiLyohXG4gICogZG9tcmVhZHkgKGMpIER1c3RpbiBEaWF6IDIwMTQgLSBMaWNlbnNlIE1JVFxuICAqL1xuIWZ1bmN0aW9uIChuYW1lLCBkZWZpbml0aW9uKSB7XG5cbiAgaWYgKHR5cGVvZiBtb2R1bGUgIT0gJ3VuZGVmaW5lZCcpIG1vZHVsZS5leHBvcnRzID0gZGVmaW5pdGlvbigpXG4gIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZGVmaW5lLmFtZCA9PSAnb2JqZWN0JykgZGVmaW5lKGRlZmluaXRpb24pXG4gIGVsc2UgdGhpc1tuYW1lXSA9IGRlZmluaXRpb24oKVxuXG59KCdkb21yZWFkeScsIGZ1bmN0aW9uICgpIHtcblxuICB2YXIgZm5zID0gW10sIGxpc3RlbmVyXG4gICAgLCBkb2MgPSBkb2N1bWVudFxuICAgICwgaGFjayA9IGRvYy5kb2N1bWVudEVsZW1lbnQuZG9TY3JvbGxcbiAgICAsIGRvbUNvbnRlbnRMb2FkZWQgPSAnRE9NQ29udGVudExvYWRlZCdcbiAgICAsIGxvYWRlZCA9IChoYWNrID8gL15sb2FkZWR8XmMvIDogL15sb2FkZWR8Xml8XmMvKS50ZXN0KGRvYy5yZWFkeVN0YXRlKVxuXG5cbiAgaWYgKCFsb2FkZWQpXG4gIGRvYy5hZGRFdmVudExpc3RlbmVyKGRvbUNvbnRlbnRMb2FkZWQsIGxpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xuICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKGRvbUNvbnRlbnRMb2FkZWQsIGxpc3RlbmVyKVxuICAgIGxvYWRlZCA9IDFcbiAgICB3aGlsZSAobGlzdGVuZXIgPSBmbnMuc2hpZnQoKSkgbGlzdGVuZXIoKVxuICB9KVxuXG4gIHJldHVybiBmdW5jdGlvbiAoZm4pIHtcbiAgICBsb2FkZWQgPyBmbigpIDogZm5zLnB1c2goZm4pXG4gIH1cblxufSk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGlkZW50aXR5O1xuXG4vKipcbiAqIFNldCBhIG1hdDQgdG8gdGhlIGlkZW50aXR5IG1hdHJpeFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmZ1bmN0aW9uIGlkZW50aXR5KG91dCkge1xuICAgIG91dFswXSA9IDE7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzRdID0gMDtcbiAgICBvdXRbNV0gPSAxO1xuICAgIG91dFs2XSA9IDA7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSAwO1xuICAgIG91dFs5XSA9IDA7XG4gICAgb3V0WzEwXSA9IDE7XG4gICAgb3V0WzExXSA9IDA7XG4gICAgb3V0WzEyXSA9IDA7XG4gICAgb3V0WzEzXSA9IDA7XG4gICAgb3V0WzE0XSA9IDA7XG4gICAgb3V0WzE1XSA9IDE7XG4gICAgcmV0dXJuIG91dDtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBtdWx0aXBseTtcblxuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byBtYXQ0J3NcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge21hdDR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmZ1bmN0aW9uIG11bHRpcGx5KG91dCwgYSwgYikge1xuICAgIHZhciBhMDAgPSBhWzBdLCBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdLCBhMDMgPSBhWzNdLFxuICAgICAgICBhMTAgPSBhWzRdLCBhMTEgPSBhWzVdLCBhMTIgPSBhWzZdLCBhMTMgPSBhWzddLFxuICAgICAgICBhMjAgPSBhWzhdLCBhMjEgPSBhWzldLCBhMjIgPSBhWzEwXSwgYTIzID0gYVsxMV0sXG4gICAgICAgIGEzMCA9IGFbMTJdLCBhMzEgPSBhWzEzXSwgYTMyID0gYVsxNF0sIGEzMyA9IGFbMTVdO1xuXG4gICAgLy8gQ2FjaGUgb25seSB0aGUgY3VycmVudCBsaW5lIG9mIHRoZSBzZWNvbmQgbWF0cml4XG4gICAgdmFyIGIwICA9IGJbMF0sIGIxID0gYlsxXSwgYjIgPSBiWzJdLCBiMyA9IGJbM107ICBcbiAgICBvdXRbMF0gPSBiMCphMDAgKyBiMSphMTAgKyBiMiphMjAgKyBiMyphMzA7XG4gICAgb3V0WzFdID0gYjAqYTAxICsgYjEqYTExICsgYjIqYTIxICsgYjMqYTMxO1xuICAgIG91dFsyXSA9IGIwKmEwMiArIGIxKmExMiArIGIyKmEyMiArIGIzKmEzMjtcbiAgICBvdXRbM10gPSBiMCphMDMgKyBiMSphMTMgKyBiMiphMjMgKyBiMyphMzM7XG5cbiAgICBiMCA9IGJbNF07IGIxID0gYls1XTsgYjIgPSBiWzZdOyBiMyA9IGJbN107XG4gICAgb3V0WzRdID0gYjAqYTAwICsgYjEqYTEwICsgYjIqYTIwICsgYjMqYTMwO1xuICAgIG91dFs1XSA9IGIwKmEwMSArIGIxKmExMSArIGIyKmEyMSArIGIzKmEzMTtcbiAgICBvdXRbNl0gPSBiMCphMDIgKyBiMSphMTIgKyBiMiphMjIgKyBiMyphMzI7XG4gICAgb3V0WzddID0gYjAqYTAzICsgYjEqYTEzICsgYjIqYTIzICsgYjMqYTMzO1xuXG4gICAgYjAgPSBiWzhdOyBiMSA9IGJbOV07IGIyID0gYlsxMF07IGIzID0gYlsxMV07XG4gICAgb3V0WzhdID0gYjAqYTAwICsgYjEqYTEwICsgYjIqYTIwICsgYjMqYTMwO1xuICAgIG91dFs5XSA9IGIwKmEwMSArIGIxKmExMSArIGIyKmEyMSArIGIzKmEzMTtcbiAgICBvdXRbMTBdID0gYjAqYTAyICsgYjEqYTEyICsgYjIqYTIyICsgYjMqYTMyO1xuICAgIG91dFsxMV0gPSBiMCphMDMgKyBiMSphMTMgKyBiMiphMjMgKyBiMyphMzM7XG5cbiAgICBiMCA9IGJbMTJdOyBiMSA9IGJbMTNdOyBiMiA9IGJbMTRdOyBiMyA9IGJbMTVdO1xuICAgIG91dFsxMl0gPSBiMCphMDAgKyBiMSphMTAgKyBiMiphMjAgKyBiMyphMzA7XG4gICAgb3V0WzEzXSA9IGIwKmEwMSArIGIxKmExMSArIGIyKmEyMSArIGIzKmEzMTtcbiAgICBvdXRbMTRdID0gYjAqYTAyICsgYjEqYTEyICsgYjIqYTIyICsgYjMqYTMyO1xuICAgIG91dFsxNV0gPSBiMCphMDMgKyBiMSphMTMgKyBiMiphMjMgKyBiMyphMzM7XG4gICAgcmV0dXJuIG91dDtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBzY2FsZTtcblxuLyoqXG4gKiBTY2FsZXMgdGhlIG1hdDQgYnkgdGhlIGRpbWVuc2lvbnMgaW4gdGhlIGdpdmVuIHZlYzNcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBtYXRyaXggdG8gc2NhbGVcbiAqIEBwYXJhbSB7dmVjM30gdiB0aGUgdmVjMyB0byBzY2FsZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKiovXG5mdW5jdGlvbiBzY2FsZShvdXQsIGEsIHYpIHtcbiAgICB2YXIgeCA9IHZbMF0sIHkgPSB2WzFdLCB6ID0gdlsyXTtcblxuICAgIG91dFswXSA9IGFbMF0gKiB4O1xuICAgIG91dFsxXSA9IGFbMV0gKiB4O1xuICAgIG91dFsyXSA9IGFbMl0gKiB4O1xuICAgIG91dFszXSA9IGFbM10gKiB4O1xuICAgIG91dFs0XSA9IGFbNF0gKiB5O1xuICAgIG91dFs1XSA9IGFbNV0gKiB5O1xuICAgIG91dFs2XSA9IGFbNl0gKiB5O1xuICAgIG91dFs3XSA9IGFbN10gKiB5O1xuICAgIG91dFs4XSA9IGFbOF0gKiB6O1xuICAgIG91dFs5XSA9IGFbOV0gKiB6O1xuICAgIG91dFsxMF0gPSBhWzEwXSAqIHo7XG4gICAgb3V0WzExXSA9IGFbMTFdICogejtcbiAgICBvdXRbMTJdID0gYVsxMl07XG4gICAgb3V0WzEzXSA9IGFbMTNdO1xuICAgIG91dFsxNF0gPSBhWzE0XTtcbiAgICBvdXRbMTVdID0gYVsxNV07XG4gICAgcmV0dXJuIG91dDtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSB0cmFuc2xhdGU7XG5cbi8qKlxuICogVHJhbnNsYXRlIGEgbWF0NCBieSB0aGUgZ2l2ZW4gdmVjdG9yXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgbWF0cml4IHRvIHRyYW5zbGF0ZVxuICogQHBhcmFtIHt2ZWMzfSB2IHZlY3RvciB0byB0cmFuc2xhdGUgYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZnVuY3Rpb24gdHJhbnNsYXRlKG91dCwgYSwgdikge1xuICAgIHZhciB4ID0gdlswXSwgeSA9IHZbMV0sIHogPSB2WzJdLFxuICAgICAgICBhMDAsIGEwMSwgYTAyLCBhMDMsXG4gICAgICAgIGExMCwgYTExLCBhMTIsIGExMyxcbiAgICAgICAgYTIwLCBhMjEsIGEyMiwgYTIzO1xuXG4gICAgaWYgKGEgPT09IG91dCkge1xuICAgICAgICBvdXRbMTJdID0gYVswXSAqIHggKyBhWzRdICogeSArIGFbOF0gKiB6ICsgYVsxMl07XG4gICAgICAgIG91dFsxM10gPSBhWzFdICogeCArIGFbNV0gKiB5ICsgYVs5XSAqIHogKyBhWzEzXTtcbiAgICAgICAgb3V0WzE0XSA9IGFbMl0gKiB4ICsgYVs2XSAqIHkgKyBhWzEwXSAqIHogKyBhWzE0XTtcbiAgICAgICAgb3V0WzE1XSA9IGFbM10gKiB4ICsgYVs3XSAqIHkgKyBhWzExXSAqIHogKyBhWzE1XTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBhMDAgPSBhWzBdOyBhMDEgPSBhWzFdOyBhMDIgPSBhWzJdOyBhMDMgPSBhWzNdO1xuICAgICAgICBhMTAgPSBhWzRdOyBhMTEgPSBhWzVdOyBhMTIgPSBhWzZdOyBhMTMgPSBhWzddO1xuICAgICAgICBhMjAgPSBhWzhdOyBhMjEgPSBhWzldOyBhMjIgPSBhWzEwXTsgYTIzID0gYVsxMV07XG5cbiAgICAgICAgb3V0WzBdID0gYTAwOyBvdXRbMV0gPSBhMDE7IG91dFsyXSA9IGEwMjsgb3V0WzNdID0gYTAzO1xuICAgICAgICBvdXRbNF0gPSBhMTA7IG91dFs1XSA9IGExMTsgb3V0WzZdID0gYTEyOyBvdXRbN10gPSBhMTM7XG4gICAgICAgIG91dFs4XSA9IGEyMDsgb3V0WzldID0gYTIxOyBvdXRbMTBdID0gYTIyOyBvdXRbMTFdID0gYTIzO1xuXG4gICAgICAgIG91dFsxMl0gPSBhMDAgKiB4ICsgYTEwICogeSArIGEyMCAqIHogKyBhWzEyXTtcbiAgICAgICAgb3V0WzEzXSA9IGEwMSAqIHggKyBhMTEgKiB5ICsgYTIxICogeiArIGFbMTNdO1xuICAgICAgICBvdXRbMTRdID0gYTAyICogeCArIGExMiAqIHkgKyBhMjIgKiB6ICsgYVsxNF07XG4gICAgICAgIG91dFsxNV0gPSBhMDMgKiB4ICsgYTEzICogeSArIGEyMyAqIHogKyBhWzE1XTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0O1xufTsiLCJcInVzZSBzdHJpY3RcIlxuXG52YXIgY29tcGlsZSA9IHJlcXVpcmUoXCJjd2lzZS1jb21waWxlclwiKVxuXG52YXIgRW1wdHlQcm9jID0ge1xuICBib2R5OiBcIlwiLFxuICBhcmdzOiBbXSxcbiAgdGhpc1ZhcnM6IFtdLFxuICBsb2NhbFZhcnM6IFtdXG59XG5cbmZ1bmN0aW9uIGZpeHVwKHgpIHtcbiAgaWYoIXgpIHtcbiAgICByZXR1cm4gRW1wdHlQcm9jXG4gIH1cbiAgZm9yKHZhciBpPTA7IGk8eC5hcmdzLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGEgPSB4LmFyZ3NbaV1cbiAgICBpZihpID09PSAwKSB7XG4gICAgICB4LmFyZ3NbaV0gPSB7bmFtZTogYSwgbHZhbHVlOnRydWUsIHJ2YWx1ZTogISF4LnJ2YWx1ZSwgY291bnQ6eC5jb3VudHx8MSB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHguYXJnc1tpXSA9IHtuYW1lOiBhLCBsdmFsdWU6ZmFsc2UsIHJ2YWx1ZTp0cnVlLCBjb3VudDogMX1cbiAgICB9XG4gIH1cbiAgaWYoIXgudGhpc1ZhcnMpIHtcbiAgICB4LnRoaXNWYXJzID0gW11cbiAgfVxuICBpZigheC5sb2NhbFZhcnMpIHtcbiAgICB4LmxvY2FsVmFycyA9IFtdXG4gIH1cbiAgcmV0dXJuIHhcbn1cblxuZnVuY3Rpb24gcGNvbXBpbGUodXNlcl9hcmdzKSB7XG4gIHJldHVybiBjb21waWxlKHtcbiAgICBhcmdzOiAgICAgdXNlcl9hcmdzLmFyZ3MsXG4gICAgcHJlOiAgICAgIGZpeHVwKHVzZXJfYXJncy5wcmUpLFxuICAgIGJvZHk6ICAgICBmaXh1cCh1c2VyX2FyZ3MuYm9keSksXG4gICAgcG9zdDogICAgIGZpeHVwKHVzZXJfYXJncy5wcm9jKSxcbiAgICBmdW5jTmFtZTogdXNlcl9hcmdzLmZ1bmNOYW1lXG4gIH0pXG59XG5cbmZ1bmN0aW9uIG1ha2VPcCh1c2VyX2FyZ3MpIHtcbiAgdmFyIGFyZ3MgPSBbXVxuICBmb3IodmFyIGk9MDsgaTx1c2VyX2FyZ3MuYXJncy5sZW5ndGg7ICsraSkge1xuICAgIGFyZ3MucHVzaChcImFcIitpKVxuICB9XG4gIHZhciB3cmFwcGVyID0gbmV3IEZ1bmN0aW9uKFwiUFwiLCBbXG4gICAgXCJyZXR1cm4gZnVuY3Rpb24gXCIsIHVzZXJfYXJncy5mdW5jTmFtZSwgXCJfbmRhcnJheW9wcyhcIiwgYXJncy5qb2luKFwiLFwiKSwgXCIpIHtQKFwiLCBhcmdzLmpvaW4oXCIsXCIpLCBcIik7cmV0dXJuIGEwfVwiXG4gIF0uam9pbihcIlwiKSlcbiAgcmV0dXJuIHdyYXBwZXIocGNvbXBpbGUodXNlcl9hcmdzKSlcbn1cblxudmFyIGFzc2lnbl9vcHMgPSB7XG4gIGFkZDogIFwiK1wiLFxuICBzdWI6ICBcIi1cIixcbiAgbXVsOiAgXCIqXCIsXG4gIGRpdjogIFwiL1wiLFxuICBtb2Q6ICBcIiVcIixcbiAgYmFuZDogXCImXCIsXG4gIGJvcjogIFwifFwiLFxuICBieG9yOiBcIl5cIixcbiAgbHNoaWZ0OiBcIjw8XCIsXG4gIHJzaGlmdDogXCI+PlwiLFxuICBycnNoaWZ0OiBcIj4+PlwiXG59XG47KGZ1bmN0aW9uKCl7XG4gIGZvcih2YXIgaWQgaW4gYXNzaWduX29wcykge1xuICAgIHZhciBvcCA9IGFzc2lnbl9vcHNbaWRdXG4gICAgZXhwb3J0c1tpZF0gPSBtYWtlT3Aoe1xuICAgICAgYXJnczogW1wiYXJyYXlcIixcImFycmF5XCIsXCJhcnJheVwiXSxcbiAgICAgIGJvZHk6IHthcmdzOltcImFcIixcImJcIixcImNcIl0sXG4gICAgICAgICAgICAgYm9keTogXCJhPWJcIitvcCtcImNcIn0sXG4gICAgICBmdW5jTmFtZTogaWRcbiAgICB9KVxuICAgIGV4cG9ydHNbaWQrXCJlcVwiXSA9IG1ha2VPcCh7XG4gICAgICBhcmdzOiBbXCJhcnJheVwiLFwiYXJyYXlcIl0sXG4gICAgICBib2R5OiB7YXJnczpbXCJhXCIsXCJiXCJdLFxuICAgICAgICAgICAgIGJvZHk6XCJhXCIrb3ArXCI9YlwifSxcbiAgICAgIHJ2YWx1ZTogdHJ1ZSxcbiAgICAgIGZ1bmNOYW1lOiBpZCtcImVxXCJcbiAgICB9KVxuICAgIGV4cG9ydHNbaWQrXCJzXCJdID0gbWFrZU9wKHtcbiAgICAgIGFyZ3M6IFtcImFycmF5XCIsIFwiYXJyYXlcIiwgXCJzY2FsYXJcIl0sXG4gICAgICBib2R5OiB7YXJnczpbXCJhXCIsXCJiXCIsXCJzXCJdLFxuICAgICAgICAgICAgIGJvZHk6XCJhPWJcIitvcCtcInNcIn0sXG4gICAgICBmdW5jTmFtZTogaWQrXCJzXCJcbiAgICB9KVxuICAgIGV4cG9ydHNbaWQrXCJzZXFcIl0gPSBtYWtlT3Aoe1xuICAgICAgYXJnczogW1wiYXJyYXlcIixcInNjYWxhclwiXSxcbiAgICAgIGJvZHk6IHthcmdzOltcImFcIixcInNcIl0sXG4gICAgICAgICAgICAgYm9keTpcImFcIitvcCtcIj1zXCJ9LFxuICAgICAgcnZhbHVlOiB0cnVlLFxuICAgICAgZnVuY05hbWU6IGlkK1wic2VxXCJcbiAgICB9KVxuICB9XG59KSgpO1xuXG52YXIgdW5hcnlfb3BzID0ge1xuICBub3Q6IFwiIVwiLFxuICBibm90OiBcIn5cIixcbiAgbmVnOiBcIi1cIixcbiAgcmVjaXA6IFwiMS4wL1wiXG59XG47KGZ1bmN0aW9uKCl7XG4gIGZvcih2YXIgaWQgaW4gdW5hcnlfb3BzKSB7XG4gICAgdmFyIG9wID0gdW5hcnlfb3BzW2lkXVxuICAgIGV4cG9ydHNbaWRdID0gbWFrZU9wKHtcbiAgICAgIGFyZ3M6IFtcImFycmF5XCIsIFwiYXJyYXlcIl0sXG4gICAgICBib2R5OiB7YXJnczpbXCJhXCIsXCJiXCJdLFxuICAgICAgICAgICAgIGJvZHk6XCJhPVwiK29wK1wiYlwifSxcbiAgICAgIGZ1bmNOYW1lOiBpZFxuICAgIH0pXG4gICAgZXhwb3J0c1tpZCtcImVxXCJdID0gbWFrZU9wKHtcbiAgICAgIGFyZ3M6IFtcImFycmF5XCJdLFxuICAgICAgYm9keToge2FyZ3M6W1wiYVwiXSxcbiAgICAgICAgICAgICBib2R5OlwiYT1cIitvcCtcImFcIn0sXG4gICAgICBydmFsdWU6IHRydWUsXG4gICAgICBjb3VudDogMixcbiAgICAgIGZ1bmNOYW1lOiBpZCtcImVxXCJcbiAgICB9KVxuICB9XG59KSgpO1xuXG52YXIgYmluYXJ5X29wcyA9IHtcbiAgYW5kOiBcIiYmXCIsXG4gIG9yOiBcInx8XCIsXG4gIGVxOiBcIj09PVwiLFxuICBuZXE6IFwiIT09XCIsXG4gIGx0OiBcIjxcIixcbiAgZ3Q6IFwiPlwiLFxuICBsZXE6IFwiPD1cIixcbiAgZ2VxOiBcIj49XCJcbn1cbjsoZnVuY3Rpb24oKSB7XG4gIGZvcih2YXIgaWQgaW4gYmluYXJ5X29wcykge1xuICAgIHZhciBvcCA9IGJpbmFyeV9vcHNbaWRdXG4gICAgZXhwb3J0c1tpZF0gPSBtYWtlT3Aoe1xuICAgICAgYXJnczogW1wiYXJyYXlcIixcImFycmF5XCIsXCJhcnJheVwiXSxcbiAgICAgIGJvZHk6IHthcmdzOltcImFcIiwgXCJiXCIsIFwiY1wiXSxcbiAgICAgICAgICAgICBib2R5OlwiYT1iXCIrb3ArXCJjXCJ9LFxuICAgICAgZnVuY05hbWU6IGlkXG4gICAgfSlcbiAgICBleHBvcnRzW2lkK1wic1wiXSA9IG1ha2VPcCh7XG4gICAgICBhcmdzOiBbXCJhcnJheVwiLFwiYXJyYXlcIixcInNjYWxhclwiXSxcbiAgICAgIGJvZHk6IHthcmdzOltcImFcIiwgXCJiXCIsIFwic1wiXSxcbiAgICAgICAgICAgICBib2R5OlwiYT1iXCIrb3ArXCJzXCJ9LFxuICAgICAgZnVuY05hbWU6IGlkK1wic1wiXG4gICAgfSlcbiAgICBleHBvcnRzW2lkK1wiZXFcIl0gPSBtYWtlT3Aoe1xuICAgICAgYXJnczogW1wiYXJyYXlcIiwgXCJhcnJheVwiXSxcbiAgICAgIGJvZHk6IHthcmdzOltcImFcIiwgXCJiXCJdLFxuICAgICAgICAgICAgIGJvZHk6XCJhPWFcIitvcCtcImJcIn0sXG4gICAgICBydmFsdWU6dHJ1ZSxcbiAgICAgIGNvdW50OjIsXG4gICAgICBmdW5jTmFtZTogaWQrXCJlcVwiXG4gICAgfSlcbiAgICBleHBvcnRzW2lkK1wic2VxXCJdID0gbWFrZU9wKHtcbiAgICAgIGFyZ3M6IFtcImFycmF5XCIsIFwic2NhbGFyXCJdLFxuICAgICAgYm9keToge2FyZ3M6W1wiYVwiLFwic1wiXSxcbiAgICAgICAgICAgICBib2R5OlwiYT1hXCIrb3ArXCJzXCJ9LFxuICAgICAgcnZhbHVlOnRydWUsXG4gICAgICBjb3VudDoyLFxuICAgICAgZnVuY05hbWU6IGlkK1wic2VxXCJcbiAgICB9KVxuICB9XG59KSgpO1xuXG52YXIgbWF0aF91bmFyeSA9IFtcbiAgXCJhYnNcIixcbiAgXCJhY29zXCIsXG4gIFwiYXNpblwiLFxuICBcImF0YW5cIixcbiAgXCJjZWlsXCIsXG4gIFwiY29zXCIsXG4gIFwiZXhwXCIsXG4gIFwiZmxvb3JcIixcbiAgXCJsb2dcIixcbiAgXCJyb3VuZFwiLFxuICBcInNpblwiLFxuICBcInNxcnRcIixcbiAgXCJ0YW5cIlxuXVxuOyhmdW5jdGlvbigpIHtcbiAgZm9yKHZhciBpPTA7IGk8bWF0aF91bmFyeS5sZW5ndGg7ICsraSkge1xuICAgIHZhciBmID0gbWF0aF91bmFyeVtpXVxuICAgIGV4cG9ydHNbZl0gPSBtYWtlT3Aoe1xuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbXCJhcnJheVwiLCBcImFycmF5XCJdLFxuICAgICAgICAgICAgICAgICAgICBwcmU6IHthcmdzOltdLCBib2R5OlwidGhpc19mPU1hdGguXCIrZiwgdGhpc1ZhcnM6W1widGhpc19mXCJdfSxcbiAgICAgICAgICAgICAgICAgICAgYm9keToge2FyZ3M6W1wiYVwiLFwiYlwiXSwgYm9keTpcImE9dGhpc19mKGIpXCIsIHRoaXNWYXJzOltcInRoaXNfZlwiXX0sXG4gICAgICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiBmXG4gICAgICAgICAgICAgICAgICB9KVxuICAgIGV4cG9ydHNbZitcImVxXCJdID0gbWFrZU9wKHtcbiAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBbXCJhcnJheVwiXSxcbiAgICAgICAgICAgICAgICAgICAgICBwcmU6IHthcmdzOltdLCBib2R5OlwidGhpc19mPU1hdGguXCIrZiwgdGhpc1ZhcnM6W1widGhpc19mXCJdfSxcbiAgICAgICAgICAgICAgICAgICAgICBib2R5OiB7YXJnczogW1wiYVwiXSwgYm9keTpcImE9dGhpc19mKGEpXCIsIHRoaXNWYXJzOltcInRoaXNfZlwiXX0sXG4gICAgICAgICAgICAgICAgICAgICAgcnZhbHVlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgIGNvdW50OiAyLFxuICAgICAgICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiBmK1wiZXFcIlxuICAgICAgICAgICAgICAgICAgICB9KVxuICB9XG59KSgpO1xuXG52YXIgbWF0aF9jb21tID0gW1xuICBcIm1heFwiLFxuICBcIm1pblwiLFxuICBcImF0YW4yXCIsXG4gIFwicG93XCJcbl1cbjsoZnVuY3Rpb24oKXtcbiAgZm9yKHZhciBpPTA7IGk8bWF0aF9jb21tLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGY9IG1hdGhfY29tbVtpXVxuICAgIGV4cG9ydHNbZl0gPSBtYWtlT3Aoe1xuICAgICAgICAgICAgICAgICAgYXJnczpbXCJhcnJheVwiLCBcImFycmF5XCIsIFwiYXJyYXlcIl0sXG4gICAgICAgICAgICAgICAgICBwcmU6IHthcmdzOltdLCBib2R5OlwidGhpc19mPU1hdGguXCIrZiwgdGhpc1ZhcnM6W1widGhpc19mXCJdfSxcbiAgICAgICAgICAgICAgICAgIGJvZHk6IHthcmdzOltcImFcIixcImJcIixcImNcIl0sIGJvZHk6XCJhPXRoaXNfZihiLGMpXCIsIHRoaXNWYXJzOltcInRoaXNfZlwiXX0sXG4gICAgICAgICAgICAgICAgICBmdW5jTmFtZTogZlxuICAgICAgICAgICAgICAgIH0pXG4gICAgZXhwb3J0c1tmK1wic1wiXSA9IG1ha2VPcCh7XG4gICAgICAgICAgICAgICAgICBhcmdzOltcImFycmF5XCIsIFwiYXJyYXlcIiwgXCJzY2FsYXJcIl0sXG4gICAgICAgICAgICAgICAgICBwcmU6IHthcmdzOltdLCBib2R5OlwidGhpc19mPU1hdGguXCIrZiwgdGhpc1ZhcnM6W1widGhpc19mXCJdfSxcbiAgICAgICAgICAgICAgICAgIGJvZHk6IHthcmdzOltcImFcIixcImJcIixcImNcIl0sIGJvZHk6XCJhPXRoaXNfZihiLGMpXCIsIHRoaXNWYXJzOltcInRoaXNfZlwiXX0sXG4gICAgICAgICAgICAgICAgICBmdW5jTmFtZTogZitcInNcIlxuICAgICAgICAgICAgICAgICAgfSlcbiAgICBleHBvcnRzW2YrXCJlcVwiXSA9IG1ha2VPcCh7IGFyZ3M6W1wiYXJyYXlcIiwgXCJhcnJheVwiXSxcbiAgICAgICAgICAgICAgICAgIHByZToge2FyZ3M6W10sIGJvZHk6XCJ0aGlzX2Y9TWF0aC5cIitmLCB0aGlzVmFyczpbXCJ0aGlzX2ZcIl19LFxuICAgICAgICAgICAgICAgICAgYm9keToge2FyZ3M6W1wiYVwiLFwiYlwiXSwgYm9keTpcImE9dGhpc19mKGEsYilcIiwgdGhpc1ZhcnM6W1widGhpc19mXCJdfSxcbiAgICAgICAgICAgICAgICAgIHJ2YWx1ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgIGNvdW50OiAyLFxuICAgICAgICAgICAgICAgICAgZnVuY05hbWU6IGYrXCJlcVwiXG4gICAgICAgICAgICAgICAgICB9KVxuICAgIGV4cG9ydHNbZitcInNlcVwiXSA9IG1ha2VPcCh7IGFyZ3M6W1wiYXJyYXlcIiwgXCJzY2FsYXJcIl0sXG4gICAgICAgICAgICAgICAgICBwcmU6IHthcmdzOltdLCBib2R5OlwidGhpc19mPU1hdGguXCIrZiwgdGhpc1ZhcnM6W1widGhpc19mXCJdfSxcbiAgICAgICAgICAgICAgICAgIGJvZHk6IHthcmdzOltcImFcIixcImJcIl0sIGJvZHk6XCJhPXRoaXNfZihhLGIpXCIsIHRoaXNWYXJzOltcInRoaXNfZlwiXX0sXG4gICAgICAgICAgICAgICAgICBydmFsdWU6dHJ1ZSxcbiAgICAgICAgICAgICAgICAgIGNvdW50OjIsXG4gICAgICAgICAgICAgICAgICBmdW5jTmFtZTogZitcInNlcVwiXG4gICAgICAgICAgICAgICAgICB9KVxuICB9XG59KSgpO1xuXG52YXIgbWF0aF9ub25jb21tID0gW1xuICBcImF0YW4yXCIsXG4gIFwicG93XCJcbl1cbjsoZnVuY3Rpb24oKXtcbiAgZm9yKHZhciBpPTA7IGk8bWF0aF9ub25jb21tLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGY9IG1hdGhfbm9uY29tbVtpXVxuICAgIGV4cG9ydHNbZitcIm9wXCJdID0gbWFrZU9wKHtcbiAgICAgICAgICAgICAgICAgIGFyZ3M6W1wiYXJyYXlcIiwgXCJhcnJheVwiLCBcImFycmF5XCJdLFxuICAgICAgICAgICAgICAgICAgcHJlOiB7YXJnczpbXSwgYm9keTpcInRoaXNfZj1NYXRoLlwiK2YsIHRoaXNWYXJzOltcInRoaXNfZlwiXX0sXG4gICAgICAgICAgICAgICAgICBib2R5OiB7YXJnczpbXCJhXCIsXCJiXCIsXCJjXCJdLCBib2R5OlwiYT10aGlzX2YoYyxiKVwiLCB0aGlzVmFyczpbXCJ0aGlzX2ZcIl19LFxuICAgICAgICAgICAgICAgICAgZnVuY05hbWU6IGYrXCJvcFwiXG4gICAgICAgICAgICAgICAgfSlcbiAgICBleHBvcnRzW2YrXCJvcHNcIl0gPSBtYWtlT3Aoe1xuICAgICAgICAgICAgICAgICAgYXJnczpbXCJhcnJheVwiLCBcImFycmF5XCIsIFwic2NhbGFyXCJdLFxuICAgICAgICAgICAgICAgICAgcHJlOiB7YXJnczpbXSwgYm9keTpcInRoaXNfZj1NYXRoLlwiK2YsIHRoaXNWYXJzOltcInRoaXNfZlwiXX0sXG4gICAgICAgICAgICAgICAgICBib2R5OiB7YXJnczpbXCJhXCIsXCJiXCIsXCJjXCJdLCBib2R5OlwiYT10aGlzX2YoYyxiKVwiLCB0aGlzVmFyczpbXCJ0aGlzX2ZcIl19LFxuICAgICAgICAgICAgICAgICAgZnVuY05hbWU6IGYrXCJvcHNcIlxuICAgICAgICAgICAgICAgICAgfSlcbiAgICBleHBvcnRzW2YrXCJvcGVxXCJdID0gbWFrZU9wKHsgYXJnczpbXCJhcnJheVwiLCBcImFycmF5XCJdLFxuICAgICAgICAgICAgICAgICAgcHJlOiB7YXJnczpbXSwgYm9keTpcInRoaXNfZj1NYXRoLlwiK2YsIHRoaXNWYXJzOltcInRoaXNfZlwiXX0sXG4gICAgICAgICAgICAgICAgICBib2R5OiB7YXJnczpbXCJhXCIsXCJiXCJdLCBib2R5OlwiYT10aGlzX2YoYixhKVwiLCB0aGlzVmFyczpbXCJ0aGlzX2ZcIl19LFxuICAgICAgICAgICAgICAgICAgcnZhbHVlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgY291bnQ6IDIsXG4gICAgICAgICAgICAgICAgICBmdW5jTmFtZTogZitcIm9wZXFcIlxuICAgICAgICAgICAgICAgICAgfSlcbiAgICBleHBvcnRzW2YrXCJvcHNlcVwiXSA9IG1ha2VPcCh7IGFyZ3M6W1wiYXJyYXlcIiwgXCJzY2FsYXJcIl0sXG4gICAgICAgICAgICAgICAgICBwcmU6IHthcmdzOltdLCBib2R5OlwidGhpc19mPU1hdGguXCIrZiwgdGhpc1ZhcnM6W1widGhpc19mXCJdfSxcbiAgICAgICAgICAgICAgICAgIGJvZHk6IHthcmdzOltcImFcIixcImJcIl0sIGJvZHk6XCJhPXRoaXNfZihiLGEpXCIsIHRoaXNWYXJzOltcInRoaXNfZlwiXX0sXG4gICAgICAgICAgICAgICAgICBydmFsdWU6dHJ1ZSxcbiAgICAgICAgICAgICAgICAgIGNvdW50OjIsXG4gICAgICAgICAgICAgICAgICBmdW5jTmFtZTogZitcIm9wc2VxXCJcbiAgICAgICAgICAgICAgICAgIH0pXG4gIH1cbn0pKCk7XG5cbmV4cG9ydHMuYW55ID0gY29tcGlsZSh7XG4gIGFyZ3M6W1wiYXJyYXlcIl0sXG4gIHByZTogRW1wdHlQcm9jLFxuICBib2R5OiB7YXJnczpbe25hbWU6XCJhXCIsIGx2YWx1ZTpmYWxzZSwgcnZhbHVlOnRydWUsIGNvdW50OjF9XSwgYm9keTogXCJpZihhKXtyZXR1cm4gdHJ1ZX1cIiwgbG9jYWxWYXJzOiBbXSwgdGhpc1ZhcnM6IFtdfSxcbiAgcG9zdDoge2FyZ3M6W10sIGxvY2FsVmFyczpbXSwgdGhpc1ZhcnM6W10sIGJvZHk6XCJyZXR1cm4gZmFsc2VcIn0sXG4gIGZ1bmNOYW1lOiBcImFueVwiXG59KVxuXG5leHBvcnRzLmFsbCA9IGNvbXBpbGUoe1xuICBhcmdzOltcImFycmF5XCJdLFxuICBwcmU6IEVtcHR5UHJvYyxcbiAgYm9keToge2FyZ3M6W3tuYW1lOlwieFwiLCBsdmFsdWU6ZmFsc2UsIHJ2YWx1ZTp0cnVlLCBjb3VudDoxfV0sIGJvZHk6IFwiaWYoIXgpe3JldHVybiBmYWxzZX1cIiwgbG9jYWxWYXJzOiBbXSwgdGhpc1ZhcnM6IFtdfSxcbiAgcG9zdDoge2FyZ3M6W10sIGxvY2FsVmFyczpbXSwgdGhpc1ZhcnM6W10sIGJvZHk6XCJyZXR1cm4gdHJ1ZVwifSxcbiAgZnVuY05hbWU6IFwiYWxsXCJcbn0pXG5cbmV4cG9ydHMuc3VtID0gY29tcGlsZSh7XG4gIGFyZ3M6W1wiYXJyYXlcIl0sXG4gIHByZToge2FyZ3M6W10sIGxvY2FsVmFyczpbXSwgdGhpc1ZhcnM6W1widGhpc19zXCJdLCBib2R5OlwidGhpc19zPTBcIn0sXG4gIGJvZHk6IHthcmdzOlt7bmFtZTpcImFcIiwgbHZhbHVlOmZhbHNlLCBydmFsdWU6dHJ1ZSwgY291bnQ6MX1dLCBib2R5OiBcInRoaXNfcys9YVwiLCBsb2NhbFZhcnM6IFtdLCB0aGlzVmFyczogW1widGhpc19zXCJdfSxcbiAgcG9zdDoge2FyZ3M6W10sIGxvY2FsVmFyczpbXSwgdGhpc1ZhcnM6W1widGhpc19zXCJdLCBib2R5OlwicmV0dXJuIHRoaXNfc1wifSxcbiAgZnVuY05hbWU6IFwic3VtXCJcbn0pXG5cbmV4cG9ydHMucHJvZCA9IGNvbXBpbGUoe1xuICBhcmdzOltcImFycmF5XCJdLFxuICBwcmU6IHthcmdzOltdLCBsb2NhbFZhcnM6W10sIHRoaXNWYXJzOltcInRoaXNfc1wiXSwgYm9keTpcInRoaXNfcz0xXCJ9LFxuICBib2R5OiB7YXJnczpbe25hbWU6XCJhXCIsIGx2YWx1ZTpmYWxzZSwgcnZhbHVlOnRydWUsIGNvdW50OjF9XSwgYm9keTogXCJ0aGlzX3MqPWFcIiwgbG9jYWxWYXJzOiBbXSwgdGhpc1ZhcnM6IFtcInRoaXNfc1wiXX0sXG4gIHBvc3Q6IHthcmdzOltdLCBsb2NhbFZhcnM6W10sIHRoaXNWYXJzOltcInRoaXNfc1wiXSwgYm9keTpcInJldHVybiB0aGlzX3NcIn0sXG4gIGZ1bmNOYW1lOiBcInByb2RcIlxufSlcblxuZXhwb3J0cy5ub3JtMnNxdWFyZWQgPSBjb21waWxlKHtcbiAgYXJnczpbXCJhcnJheVwiXSxcbiAgcHJlOiB7YXJnczpbXSwgbG9jYWxWYXJzOltdLCB0aGlzVmFyczpbXCJ0aGlzX3NcIl0sIGJvZHk6XCJ0aGlzX3M9MFwifSxcbiAgYm9keToge2FyZ3M6W3tuYW1lOlwiYVwiLCBsdmFsdWU6ZmFsc2UsIHJ2YWx1ZTp0cnVlLCBjb3VudDoyfV0sIGJvZHk6IFwidGhpc19zKz1hKmFcIiwgbG9jYWxWYXJzOiBbXSwgdGhpc1ZhcnM6IFtcInRoaXNfc1wiXX0sXG4gIHBvc3Q6IHthcmdzOltdLCBsb2NhbFZhcnM6W10sIHRoaXNWYXJzOltcInRoaXNfc1wiXSwgYm9keTpcInJldHVybiB0aGlzX3NcIn0sXG4gIGZ1bmNOYW1lOiBcIm5vcm0yc3F1YXJlZFwiXG59KVxuICBcbmV4cG9ydHMubm9ybTIgPSBjb21waWxlKHtcbiAgYXJnczpbXCJhcnJheVwiXSxcbiAgcHJlOiB7YXJnczpbXSwgbG9jYWxWYXJzOltdLCB0aGlzVmFyczpbXCJ0aGlzX3NcIl0sIGJvZHk6XCJ0aGlzX3M9MFwifSxcbiAgYm9keToge2FyZ3M6W3tuYW1lOlwiYVwiLCBsdmFsdWU6ZmFsc2UsIHJ2YWx1ZTp0cnVlLCBjb3VudDoyfV0sIGJvZHk6IFwidGhpc19zKz1hKmFcIiwgbG9jYWxWYXJzOiBbXSwgdGhpc1ZhcnM6IFtcInRoaXNfc1wiXX0sXG4gIHBvc3Q6IHthcmdzOltdLCBsb2NhbFZhcnM6W10sIHRoaXNWYXJzOltcInRoaXNfc1wiXSwgYm9keTpcInJldHVybiBNYXRoLnNxcnQodGhpc19zKVwifSxcbiAgZnVuY05hbWU6IFwibm9ybTJcIlxufSlcbiAgXG5cbmV4cG9ydHMubm9ybWluZiA9IGNvbXBpbGUoe1xuICBhcmdzOltcImFycmF5XCJdLFxuICBwcmU6IHthcmdzOltdLCBsb2NhbFZhcnM6W10sIHRoaXNWYXJzOltcInRoaXNfc1wiXSwgYm9keTpcInRoaXNfcz0wXCJ9LFxuICBib2R5OiB7YXJnczpbe25hbWU6XCJhXCIsIGx2YWx1ZTpmYWxzZSwgcnZhbHVlOnRydWUsIGNvdW50OjR9XSwgYm9keTpcImlmKC1hPnRoaXNfcyl7dGhpc19zPS1hfWVsc2UgaWYoYT50aGlzX3Mpe3RoaXNfcz1hfVwiLCBsb2NhbFZhcnM6IFtdLCB0aGlzVmFyczogW1widGhpc19zXCJdfSxcbiAgcG9zdDoge2FyZ3M6W10sIGxvY2FsVmFyczpbXSwgdGhpc1ZhcnM6W1widGhpc19zXCJdLCBib2R5OlwicmV0dXJuIHRoaXNfc1wifSxcbiAgZnVuY05hbWU6IFwibm9ybWluZlwiXG59KVxuXG5leHBvcnRzLm5vcm0xID0gY29tcGlsZSh7XG4gIGFyZ3M6W1wiYXJyYXlcIl0sXG4gIHByZToge2FyZ3M6W10sIGxvY2FsVmFyczpbXSwgdGhpc1ZhcnM6W1widGhpc19zXCJdLCBib2R5OlwidGhpc19zPTBcIn0sXG4gIGJvZHk6IHthcmdzOlt7bmFtZTpcImFcIiwgbHZhbHVlOmZhbHNlLCBydmFsdWU6dHJ1ZSwgY291bnQ6M31dLCBib2R5OiBcInRoaXNfcys9YTwwPy1hOmFcIiwgbG9jYWxWYXJzOiBbXSwgdGhpc1ZhcnM6IFtcInRoaXNfc1wiXX0sXG4gIHBvc3Q6IHthcmdzOltdLCBsb2NhbFZhcnM6W10sIHRoaXNWYXJzOltcInRoaXNfc1wiXSwgYm9keTpcInJldHVybiB0aGlzX3NcIn0sXG4gIGZ1bmNOYW1lOiBcIm5vcm0xXCJcbn0pXG5cbmV4cG9ydHMuc3VwID0gY29tcGlsZSh7XG4gIGFyZ3M6IFsgXCJhcnJheVwiIF0sXG4gIHByZTpcbiAgIHsgYm9keTogXCJ0aGlzX2g9LUluZmluaXR5XCIsXG4gICAgIGFyZ3M6IFtdLFxuICAgICB0aGlzVmFyczogWyBcInRoaXNfaFwiIF0sXG4gICAgIGxvY2FsVmFyczogW10gfSxcbiAgYm9keTpcbiAgIHsgYm9keTogXCJpZihfaW5saW5lXzFfYXJnMF8+dGhpc19oKXRoaXNfaD1faW5saW5lXzFfYXJnMF9cIixcbiAgICAgYXJnczogW3tcIm5hbWVcIjpcIl9pbmxpbmVfMV9hcmcwX1wiLFwibHZhbHVlXCI6ZmFsc2UsXCJydmFsdWVcIjp0cnVlLFwiY291bnRcIjoyfSBdLFxuICAgICB0aGlzVmFyczogWyBcInRoaXNfaFwiIF0sXG4gICAgIGxvY2FsVmFyczogW10gfSxcbiAgcG9zdDpcbiAgIHsgYm9keTogXCJyZXR1cm4gdGhpc19oXCIsXG4gICAgIGFyZ3M6IFtdLFxuICAgICB0aGlzVmFyczogWyBcInRoaXNfaFwiIF0sXG4gICAgIGxvY2FsVmFyczogW10gfVxuIH0pXG5cbmV4cG9ydHMuaW5mID0gY29tcGlsZSh7XG4gIGFyZ3M6IFsgXCJhcnJheVwiIF0sXG4gIHByZTpcbiAgIHsgYm9keTogXCJ0aGlzX2g9SW5maW5pdHlcIixcbiAgICAgYXJnczogW10sXG4gICAgIHRoaXNWYXJzOiBbIFwidGhpc19oXCIgXSxcbiAgICAgbG9jYWxWYXJzOiBbXSB9LFxuICBib2R5OlxuICAgeyBib2R5OiBcImlmKF9pbmxpbmVfMV9hcmcwXzx0aGlzX2gpdGhpc19oPV9pbmxpbmVfMV9hcmcwX1wiLFxuICAgICBhcmdzOiBbe1wibmFtZVwiOlwiX2lubGluZV8xX2FyZzBfXCIsXCJsdmFsdWVcIjpmYWxzZSxcInJ2YWx1ZVwiOnRydWUsXCJjb3VudFwiOjJ9IF0sXG4gICAgIHRoaXNWYXJzOiBbIFwidGhpc19oXCIgXSxcbiAgICAgbG9jYWxWYXJzOiBbXSB9LFxuICBwb3N0OlxuICAgeyBib2R5OiBcInJldHVybiB0aGlzX2hcIixcbiAgICAgYXJnczogW10sXG4gICAgIHRoaXNWYXJzOiBbIFwidGhpc19oXCIgXSxcbiAgICAgbG9jYWxWYXJzOiBbXSB9XG4gfSlcblxuZXhwb3J0cy5hcmdtaW4gPSBjb21waWxlKHtcbiAgYXJnczpbXCJpbmRleFwiLFwiYXJyYXlcIixcInNoYXBlXCJdLFxuICBwcmU6e1xuICAgIGJvZHk6XCJ7dGhpc192PUluZmluaXR5O3RoaXNfaT1faW5saW5lXzBfYXJnMl8uc2xpY2UoMCl9XCIsXG4gICAgYXJnczpbXG4gICAgICB7bmFtZTpcIl9pbmxpbmVfMF9hcmcwX1wiLGx2YWx1ZTpmYWxzZSxydmFsdWU6ZmFsc2UsY291bnQ6MH0sXG4gICAgICB7bmFtZTpcIl9pbmxpbmVfMF9hcmcxX1wiLGx2YWx1ZTpmYWxzZSxydmFsdWU6ZmFsc2UsY291bnQ6MH0sXG4gICAgICB7bmFtZTpcIl9pbmxpbmVfMF9hcmcyX1wiLGx2YWx1ZTpmYWxzZSxydmFsdWU6dHJ1ZSxjb3VudDoxfVxuICAgICAgXSxcbiAgICB0aGlzVmFyczpbXCJ0aGlzX2lcIixcInRoaXNfdlwiXSxcbiAgICBsb2NhbFZhcnM6W119LFxuICBib2R5OntcbiAgICBib2R5Olwie2lmKF9pbmxpbmVfMV9hcmcxXzx0aGlzX3Ype3RoaXNfdj1faW5saW5lXzFfYXJnMV87Zm9yKHZhciBfaW5saW5lXzFfaz0wO19pbmxpbmVfMV9rPF9pbmxpbmVfMV9hcmcwXy5sZW5ndGg7KytfaW5saW5lXzFfayl7dGhpc19pW19pbmxpbmVfMV9rXT1faW5saW5lXzFfYXJnMF9bX2lubGluZV8xX2tdfX19XCIsXG4gICAgYXJnczpbXG4gICAgICB7bmFtZTpcIl9pbmxpbmVfMV9hcmcwX1wiLGx2YWx1ZTpmYWxzZSxydmFsdWU6dHJ1ZSxjb3VudDoyfSxcbiAgICAgIHtuYW1lOlwiX2lubGluZV8xX2FyZzFfXCIsbHZhbHVlOmZhbHNlLHJ2YWx1ZTp0cnVlLGNvdW50OjJ9XSxcbiAgICB0aGlzVmFyczpbXCJ0aGlzX2lcIixcInRoaXNfdlwiXSxcbiAgICBsb2NhbFZhcnM6W1wiX2lubGluZV8xX2tcIl19LFxuICBwb3N0OntcbiAgICBib2R5Olwie3JldHVybiB0aGlzX2l9XCIsXG4gICAgYXJnczpbXSxcbiAgICB0aGlzVmFyczpbXCJ0aGlzX2lcIl0sXG4gICAgbG9jYWxWYXJzOltdfVxufSlcblxuZXhwb3J0cy5hcmdtYXggPSBjb21waWxlKHtcbiAgYXJnczpbXCJpbmRleFwiLFwiYXJyYXlcIixcInNoYXBlXCJdLFxuICBwcmU6e1xuICAgIGJvZHk6XCJ7dGhpc192PS1JbmZpbml0eTt0aGlzX2k9X2lubGluZV8wX2FyZzJfLnNsaWNlKDApfVwiLFxuICAgIGFyZ3M6W1xuICAgICAge25hbWU6XCJfaW5saW5lXzBfYXJnMF9cIixsdmFsdWU6ZmFsc2UscnZhbHVlOmZhbHNlLGNvdW50OjB9LFxuICAgICAge25hbWU6XCJfaW5saW5lXzBfYXJnMV9cIixsdmFsdWU6ZmFsc2UscnZhbHVlOmZhbHNlLGNvdW50OjB9LFxuICAgICAge25hbWU6XCJfaW5saW5lXzBfYXJnMl9cIixsdmFsdWU6ZmFsc2UscnZhbHVlOnRydWUsY291bnQ6MX1cbiAgICAgIF0sXG4gICAgdGhpc1ZhcnM6W1widGhpc19pXCIsXCJ0aGlzX3ZcIl0sXG4gICAgbG9jYWxWYXJzOltdfSxcbiAgYm9keTp7XG4gICAgYm9keTpcIntpZihfaW5saW5lXzFfYXJnMV8+dGhpc192KXt0aGlzX3Y9X2lubGluZV8xX2FyZzFfO2Zvcih2YXIgX2lubGluZV8xX2s9MDtfaW5saW5lXzFfazxfaW5saW5lXzFfYXJnMF8ubGVuZ3RoOysrX2lubGluZV8xX2spe3RoaXNfaVtfaW5saW5lXzFfa109X2lubGluZV8xX2FyZzBfW19pbmxpbmVfMV9rXX19fVwiLFxuICAgIGFyZ3M6W1xuICAgICAge25hbWU6XCJfaW5saW5lXzFfYXJnMF9cIixsdmFsdWU6ZmFsc2UscnZhbHVlOnRydWUsY291bnQ6Mn0sXG4gICAgICB7bmFtZTpcIl9pbmxpbmVfMV9hcmcxX1wiLGx2YWx1ZTpmYWxzZSxydmFsdWU6dHJ1ZSxjb3VudDoyfV0sXG4gICAgdGhpc1ZhcnM6W1widGhpc19pXCIsXCJ0aGlzX3ZcIl0sXG4gICAgbG9jYWxWYXJzOltcIl9pbmxpbmVfMV9rXCJdfSxcbiAgcG9zdDp7XG4gICAgYm9keTpcIntyZXR1cm4gdGhpc19pfVwiLFxuICAgIGFyZ3M6W10sXG4gICAgdGhpc1ZhcnM6W1widGhpc19pXCJdLFxuICAgIGxvY2FsVmFyczpbXX1cbn0pICBcblxuZXhwb3J0cy5yYW5kb20gPSBtYWtlT3Aoe1xuICBhcmdzOiBbXCJhcnJheVwiXSxcbiAgcHJlOiB7YXJnczpbXSwgYm9keTpcInRoaXNfZj1NYXRoLnJhbmRvbVwiLCB0aGlzVmFyczpbXCJ0aGlzX2ZcIl19LFxuICBib2R5OiB7YXJnczogW1wiYVwiXSwgYm9keTpcImE9dGhpc19mKClcIiwgdGhpc1ZhcnM6W1widGhpc19mXCJdfSxcbiAgZnVuY05hbWU6IFwicmFuZG9tXCJcbn0pXG5cbmV4cG9ydHMuYXNzaWduID0gbWFrZU9wKHtcbiAgYXJnczpbXCJhcnJheVwiLCBcImFycmF5XCJdLFxuICBib2R5OiB7YXJnczpbXCJhXCIsIFwiYlwiXSwgYm9keTpcImE9YlwifSxcbiAgZnVuY05hbWU6IFwiYXNzaWduXCIgfSlcblxuZXhwb3J0cy5hc3NpZ25zID0gbWFrZU9wKHtcbiAgYXJnczpbXCJhcnJheVwiLCBcInNjYWxhclwiXSxcbiAgYm9keToge2FyZ3M6W1wiYVwiLCBcImJcIl0sIGJvZHk6XCJhPWJcIn0sXG4gIGZ1bmNOYW1lOiBcImFzc2lnbnNcIiB9KVxuXG5cbmV4cG9ydHMuZXF1YWxzID0gY29tcGlsZSh7XG4gIGFyZ3M6W1wiYXJyYXlcIiwgXCJhcnJheVwiXSxcbiAgcHJlOiBFbXB0eVByb2MsXG4gIGJvZHk6IHthcmdzOlt7bmFtZTpcInhcIiwgbHZhbHVlOmZhbHNlLCBydmFsdWU6dHJ1ZSwgY291bnQ6MX0sXG4gICAgICAgICAgICAgICB7bmFtZTpcInlcIiwgbHZhbHVlOmZhbHNlLCBydmFsdWU6dHJ1ZSwgY291bnQ6MX1dLCBcbiAgICAgICAgYm9keTogXCJpZih4IT09eSl7cmV0dXJuIGZhbHNlfVwiLCBcbiAgICAgICAgbG9jYWxWYXJzOiBbXSwgXG4gICAgICAgIHRoaXNWYXJzOiBbXX0sXG4gIHBvc3Q6IHthcmdzOltdLCBsb2NhbFZhcnM6W10sIHRoaXNWYXJzOltdLCBib2R5OlwicmV0dXJuIHRydWVcIn0sXG4gIGZ1bmNOYW1lOiBcImVxdWFsc1wiXG59KVxuXG5cbiIsIlwidXNlIHN0cmljdFwiXG5cbnZhciBjcmVhdGVUaHVuayA9IHJlcXVpcmUoXCIuL2xpYi90aHVuay5qc1wiKVxuXG5mdW5jdGlvbiBQcm9jZWR1cmUoKSB7XG4gIHRoaXMuYXJnVHlwZXMgPSBbXVxuICB0aGlzLnNoaW1BcmdzID0gW11cbiAgdGhpcy5hcnJheUFyZ3MgPSBbXVxuICB0aGlzLnNjYWxhckFyZ3MgPSBbXVxuICB0aGlzLm9mZnNldEFyZ3MgPSBbXVxuICB0aGlzLm9mZnNldEFyZ0luZGV4ID0gW11cbiAgdGhpcy5pbmRleEFyZ3MgPSBbXVxuICB0aGlzLnNoYXBlQXJncyA9IFtdXG4gIHRoaXMuZnVuY05hbWUgPSBcIlwiXG4gIHRoaXMucHJlID0gbnVsbFxuICB0aGlzLmJvZHkgPSBudWxsXG4gIHRoaXMucG9zdCA9IG51bGxcbiAgdGhpcy5kZWJ1ZyA9IGZhbHNlXG59XG5cbmZ1bmN0aW9uIGNvbXBpbGVDd2lzZSh1c2VyX2FyZ3MpIHtcbiAgLy9DcmVhdGUgcHJvY2VkdXJlXG4gIHZhciBwcm9jID0gbmV3IFByb2NlZHVyZSgpXG4gIFxuICAvL1BhcnNlIGJsb2Nrc1xuICBwcm9jLnByZSAgICA9IHVzZXJfYXJncy5wcmVcbiAgcHJvYy5ib2R5ICAgPSB1c2VyX2FyZ3MuYm9keVxuICBwcm9jLnBvc3QgICA9IHVzZXJfYXJncy5wb3N0XG5cbiAgLy9QYXJzZSBhcmd1bWVudHNcbiAgdmFyIHByb2NfYXJncyA9IHVzZXJfYXJncy5hcmdzLnNsaWNlKDApXG4gIHByb2MuYXJnVHlwZXMgPSBwcm9jX2FyZ3NcbiAgZm9yKHZhciBpPTA7IGk8cHJvY19hcmdzLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGFyZ190eXBlID0gcHJvY19hcmdzW2ldXG4gICAgaWYoYXJnX3R5cGUgPT09IFwiYXJyYXlcIikge1xuICAgICAgcHJvYy5hcnJheUFyZ3MucHVzaChpKVxuICAgICAgcHJvYy5zaGltQXJncy5wdXNoKFwiYXJyYXlcIiArIGkpXG4gICAgICBpZihpIDwgcHJvYy5wcmUuYXJncy5sZW5ndGggJiYgcHJvYy5wcmUuYXJnc1tpXS5jb3VudD4wKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImN3aXNlOiBwcmUoKSBibG9jayBtYXkgbm90IHJlZmVyZW5jZSBhcnJheSBhcmdzXCIpXG4gICAgICB9XG4gICAgICBpZihpIDwgcHJvYy5wb3N0LmFyZ3MubGVuZ3RoICYmIHByb2MucG9zdC5hcmdzW2ldLmNvdW50PjApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY3dpc2U6IHBvc3QoKSBibG9jayBtYXkgbm90IHJlZmVyZW5jZSBhcnJheSBhcmdzXCIpXG4gICAgICB9XG4gICAgfSBlbHNlIGlmKGFyZ190eXBlID09PSBcInNjYWxhclwiKSB7XG4gICAgICBwcm9jLnNjYWxhckFyZ3MucHVzaChpKVxuICAgICAgcHJvYy5zaGltQXJncy5wdXNoKFwic2NhbGFyXCIgKyBpKVxuICAgIH0gZWxzZSBpZihhcmdfdHlwZSA9PT0gXCJpbmRleFwiKSB7XG4gICAgICBwcm9jLmluZGV4QXJncy5wdXNoKGkpXG4gICAgICBpZihpIDwgcHJvYy5wcmUuYXJncy5sZW5ndGggJiYgcHJvYy5wcmUuYXJnc1tpXS5jb3VudCA+IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY3dpc2U6IHByZSgpIGJsb2NrIG1heSBub3QgcmVmZXJlbmNlIGFycmF5IGluZGV4XCIpXG4gICAgICB9XG4gICAgICBpZihpIDwgcHJvYy5ib2R5LmFyZ3MubGVuZ3RoICYmIHByb2MuYm9keS5hcmdzW2ldLmx2YWx1ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjd2lzZTogYm9keSgpIGJsb2NrIG1heSBub3Qgd3JpdGUgdG8gYXJyYXkgaW5kZXhcIilcbiAgICAgIH1cbiAgICAgIGlmKGkgPCBwcm9jLnBvc3QuYXJncy5sZW5ndGggJiYgcHJvYy5wb3N0LmFyZ3NbaV0uY291bnQgPiAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImN3aXNlOiBwb3N0KCkgYmxvY2sgbWF5IG5vdCByZWZlcmVuY2UgYXJyYXkgaW5kZXhcIilcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYoYXJnX3R5cGUgPT09IFwic2hhcGVcIikge1xuICAgICAgcHJvYy5zaGFwZUFyZ3MucHVzaChpKVxuICAgICAgaWYoaSA8IHByb2MucHJlLmFyZ3MubGVuZ3RoICYmIHByb2MucHJlLmFyZ3NbaV0ubHZhbHVlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImN3aXNlOiBwcmUoKSBibG9jayBtYXkgbm90IHdyaXRlIHRvIGFycmF5IHNoYXBlXCIpXG4gICAgICB9XG4gICAgICBpZihpIDwgcHJvYy5ib2R5LmFyZ3MubGVuZ3RoICYmIHByb2MuYm9keS5hcmdzW2ldLmx2YWx1ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjd2lzZTogYm9keSgpIGJsb2NrIG1heSBub3Qgd3JpdGUgdG8gYXJyYXkgc2hhcGVcIilcbiAgICAgIH1cbiAgICAgIGlmKGkgPCBwcm9jLnBvc3QuYXJncy5sZW5ndGggJiYgcHJvYy5wb3N0LmFyZ3NbaV0ubHZhbHVlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImN3aXNlOiBwb3N0KCkgYmxvY2sgbWF5IG5vdCB3cml0ZSB0byBhcnJheSBzaGFwZVwiKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZih0eXBlb2YgYXJnX3R5cGUgPT09IFwib2JqZWN0XCIgJiYgYXJnX3R5cGUub2Zmc2V0KSB7XG4gICAgICBwcm9jLmFyZ1R5cGVzW2ldID0gXCJvZmZzZXRcIlxuICAgICAgcHJvYy5vZmZzZXRBcmdzLnB1c2goeyBhcnJheTogYXJnX3R5cGUuYXJyYXksIG9mZnNldDphcmdfdHlwZS5vZmZzZXQgfSlcbiAgICAgIHByb2Mub2Zmc2V0QXJnSW5kZXgucHVzaChpKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjd2lzZTogVW5rbm93biBhcmd1bWVudCB0eXBlIFwiICsgcHJvY19hcmdzW2ldKVxuICAgIH1cbiAgfVxuICBcbiAgLy9NYWtlIHN1cmUgYXQgbGVhc3Qgb25lIGFycmF5IGFyZ3VtZW50IHdhcyBzcGVjaWZpZWRcbiAgaWYocHJvYy5hcnJheUFyZ3MubGVuZ3RoIDw9IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJjd2lzZTogTm8gYXJyYXkgYXJndW1lbnRzIHNwZWNpZmllZFwiKVxuICB9XG4gIFxuICAvL01ha2Ugc3VyZSBhcmd1bWVudHMgYXJlIGNvcnJlY3RcbiAgaWYocHJvYy5wcmUuYXJncy5sZW5ndGggPiBwcm9jX2FyZ3MubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiY3dpc2U6IFRvbyBtYW55IGFyZ3VtZW50cyBpbiBwcmUoKSBibG9ja1wiKVxuICB9XG4gIGlmKHByb2MuYm9keS5hcmdzLmxlbmd0aCA+IHByb2NfYXJncy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJjd2lzZTogVG9vIG1hbnkgYXJndW1lbnRzIGluIGJvZHkoKSBibG9ja1wiKVxuICB9XG4gIGlmKHByb2MucG9zdC5hcmdzLmxlbmd0aCA+IHByb2NfYXJncy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJjd2lzZTogVG9vIG1hbnkgYXJndW1lbnRzIGluIHBvc3QoKSBibG9ja1wiKVxuICB9XG5cbiAgLy9DaGVjayBkZWJ1ZyBmbGFnXG4gIHByb2MuZGVidWcgPSAhIXVzZXJfYXJncy5wcmludENvZGUgfHwgISF1c2VyX2FyZ3MuZGVidWdcbiAgXG4gIC8vUmV0cmlldmUgbmFtZVxuICBwcm9jLmZ1bmNOYW1lID0gdXNlcl9hcmdzLmZ1bmNOYW1lIHx8IFwiY3dpc2VcIlxuICBcbiAgLy9SZWFkIGluIGJsb2NrIHNpemVcbiAgcHJvYy5ibG9ja1NpemUgPSB1c2VyX2FyZ3MuYmxvY2tTaXplIHx8IDY0XG5cbiAgcmV0dXJuIGNyZWF0ZVRodW5rKHByb2MpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29tcGlsZUN3aXNlXG4iLCJcInVzZSBzdHJpY3RcIlxuXG52YXIgdW5pcSA9IHJlcXVpcmUoXCJ1bmlxXCIpXG5cbmZ1bmN0aW9uIGlubmVyRmlsbChvcmRlciwgcHJvYywgYm9keSkge1xuICB2YXIgZGltZW5zaW9uID0gb3JkZXIubGVuZ3RoXG4gICAgLCBuYXJncyA9IHByb2MuYXJyYXlBcmdzLmxlbmd0aFxuICAgICwgaGFzX2luZGV4ID0gcHJvYy5pbmRleEFyZ3MubGVuZ3RoPjBcbiAgICAsIGNvZGUgPSBbXVxuICAgICwgdmFycyA9IFtdXG4gICAgLCBpZHg9MCwgcGlkeD0wLCBpLCBqXG4gIGZvcihpPTA7IGk8ZGltZW5zaW9uOyArK2kpIHtcbiAgICB2YXJzLnB1c2goW1wiaVwiLGksXCI9MFwiXS5qb2luKFwiXCIpKVxuICB9XG4gIC8vQ29tcHV0ZSBzY2FuIGRlbHRhc1xuICBmb3Ioaj0wOyBqPG5hcmdzOyArK2opIHtcbiAgICBmb3IoaT0wOyBpPGRpbWVuc2lvbjsgKytpKSB7XG4gICAgICBwaWR4ID0gaWR4XG4gICAgICBpZHggPSBvcmRlcltpXVxuICAgICAgaWYoaSA9PT0gMCkge1xuICAgICAgICB2YXJzLnB1c2goW1wiZFwiLGosXCJzXCIsaSxcIj10XCIsaixcInBcIixpZHhdLmpvaW4oXCJcIikpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXJzLnB1c2goW1wiZFwiLGosXCJzXCIsaSxcIj0odFwiLGosXCJwXCIsaWR4LFwiLXNcIixwaWR4LFwiKnRcIixqLFwicFwiLHBpZHgsXCIpXCJdLmpvaW4oXCJcIikpXG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNvZGUucHVzaChcInZhciBcIiArIHZhcnMuam9pbihcIixcIikpXG4gIC8vU2NhbiBsb29wXG4gIGZvcihpPWRpbWVuc2lvbi0xOyBpPj0wOyAtLWkpIHtcbiAgICBpZHggPSBvcmRlcltpXVxuICAgIGNvZGUucHVzaChbXCJmb3IoaVwiLGksXCI9MDtpXCIsaSxcIjxzXCIsaWR4LFwiOysraVwiLGksXCIpe1wiXS5qb2luKFwiXCIpKVxuICB9XG4gIC8vUHVzaCBib2R5IG9mIGlubmVyIGxvb3BcbiAgY29kZS5wdXNoKGJvZHkpXG4gIC8vQWR2YW5jZSBzY2FuIHBvaW50ZXJzXG4gIGZvcihpPTA7IGk8ZGltZW5zaW9uOyArK2kpIHtcbiAgICBwaWR4ID0gaWR4XG4gICAgaWR4ID0gb3JkZXJbaV1cbiAgICBmb3Ioaj0wOyBqPG5hcmdzOyArK2opIHtcbiAgICAgIGNvZGUucHVzaChbXCJwXCIsaixcIis9ZFwiLGosXCJzXCIsaV0uam9pbihcIlwiKSlcbiAgICB9XG4gICAgaWYoaGFzX2luZGV4KSB7XG4gICAgICBpZihpID4gMCkge1xuICAgICAgICBjb2RlLnB1c2goW1wiaW5kZXhbXCIscGlkeCxcIl0tPXNcIixwaWR4XS5qb2luKFwiXCIpKVxuICAgICAgfVxuICAgICAgY29kZS5wdXNoKFtcIisraW5kZXhbXCIsaWR4LFwiXVwiXS5qb2luKFwiXCIpKVxuICAgIH1cbiAgICBjb2RlLnB1c2goXCJ9XCIpXG4gIH1cbiAgcmV0dXJuIGNvZGUuam9pbihcIlxcblwiKVxufVxuXG5mdW5jdGlvbiBvdXRlckZpbGwobWF0Y2hlZCwgb3JkZXIsIHByb2MsIGJvZHkpIHtcbiAgdmFyIGRpbWVuc2lvbiA9IG9yZGVyLmxlbmd0aFxuICAgICwgbmFyZ3MgPSBwcm9jLmFycmF5QXJncy5sZW5ndGhcbiAgICAsIGJsb2NrU2l6ZSA9IHByb2MuYmxvY2tTaXplXG4gICAgLCBoYXNfaW5kZXggPSBwcm9jLmluZGV4QXJncy5sZW5ndGggPiAwXG4gICAgLCBjb2RlID0gW11cbiAgZm9yKHZhciBpPTA7IGk8bmFyZ3M7ICsraSkge1xuICAgIGNvZGUucHVzaChbXCJ2YXIgb2Zmc2V0XCIsaSxcIj1wXCIsaV0uam9pbihcIlwiKSlcbiAgfVxuICAvL0dlbmVyYXRlIG1hdGNoZWQgbG9vcHNcbiAgZm9yKHZhciBpPW1hdGNoZWQ7IGk8ZGltZW5zaW9uOyArK2kpIHtcbiAgICBjb2RlLnB1c2goW1wiZm9yKHZhciBqXCIraStcIj1TU1tcIiwgb3JkZXJbaV0sIFwiXXwwO2pcIiwgaSwgXCI+MDspe1wiXS5qb2luKFwiXCIpKVxuICAgIGNvZGUucHVzaChbXCJpZihqXCIsaSxcIjxcIixibG9ja1NpemUsXCIpe1wiXS5qb2luKFwiXCIpKVxuICAgIGNvZGUucHVzaChbXCJzXCIsb3JkZXJbaV0sXCI9alwiLGldLmpvaW4oXCJcIikpXG4gICAgY29kZS5wdXNoKFtcImpcIixpLFwiPTBcIl0uam9pbihcIlwiKSlcbiAgICBjb2RlLnB1c2goW1wifWVsc2V7c1wiLG9yZGVyW2ldLFwiPVwiLGJsb2NrU2l6ZV0uam9pbihcIlwiKSlcbiAgICBjb2RlLnB1c2goW1wialwiLGksXCItPVwiLGJsb2NrU2l6ZSxcIn1cIl0uam9pbihcIlwiKSlcbiAgICBpZihoYXNfaW5kZXgpIHtcbiAgICAgIGNvZGUucHVzaChbXCJpbmRleFtcIixvcmRlcltpXSxcIl09alwiLGldLmpvaW4oXCJcIikpXG4gICAgfVxuICB9XG4gIGZvcih2YXIgaT0wOyBpPG5hcmdzOyArK2kpIHtcbiAgICB2YXIgaW5kZXhTdHIgPSBbXCJvZmZzZXRcIitpXVxuICAgIGZvcih2YXIgaj1tYXRjaGVkOyBqPGRpbWVuc2lvbjsgKytqKSB7XG4gICAgICBpbmRleFN0ci5wdXNoKFtcImpcIixqLFwiKnRcIixpLFwicFwiLG9yZGVyW2pdXS5qb2luKFwiXCIpKVxuICAgIH1cbiAgICBjb2RlLnB1c2goW1wicFwiLGksXCI9KFwiLGluZGV4U3RyLmpvaW4oXCIrXCIpLFwiKVwiXS5qb2luKFwiXCIpKVxuICB9XG4gIGNvZGUucHVzaChpbm5lckZpbGwob3JkZXIsIHByb2MsIGJvZHkpKVxuICBmb3IodmFyIGk9bWF0Y2hlZDsgaTxkaW1lbnNpb247ICsraSkge1xuICAgIGNvZGUucHVzaChcIn1cIilcbiAgfVxuICByZXR1cm4gY29kZS5qb2luKFwiXFxuXCIpXG59XG5cbi8vQ291bnQgdGhlIG51bWJlciBvZiBjb21wYXRpYmxlIGlubmVyIG9yZGVyc1xuZnVuY3Rpb24gY291bnRNYXRjaGVzKG9yZGVycykge1xuICB2YXIgbWF0Y2hlZCA9IDAsIGRpbWVuc2lvbiA9IG9yZGVyc1swXS5sZW5ndGhcbiAgd2hpbGUobWF0Y2hlZCA8IGRpbWVuc2lvbikge1xuICAgIGZvcih2YXIgaj0xOyBqPG9yZGVycy5sZW5ndGg7ICsraikge1xuICAgICAgaWYob3JkZXJzW2pdW21hdGNoZWRdICE9PSBvcmRlcnNbMF1bbWF0Y2hlZF0pIHtcbiAgICAgICAgcmV0dXJuIG1hdGNoZWRcbiAgICAgIH1cbiAgICB9XG4gICAgKyttYXRjaGVkXG4gIH1cbiAgcmV0dXJuIG1hdGNoZWRcbn1cblxuLy9Qcm9jZXNzZXMgYSBibG9jayBhY2NvcmRpbmcgdG8gdGhlIGdpdmVuIGRhdGEgdHlwZXNcbmZ1bmN0aW9uIHByb2Nlc3NCbG9jayhibG9jaywgcHJvYywgZHR5cGVzKSB7XG4gIHZhciBjb2RlID0gYmxvY2suYm9keVxuICB2YXIgcHJlID0gW11cbiAgdmFyIHBvc3QgPSBbXVxuICBmb3IodmFyIGk9MDsgaTxibG9jay5hcmdzLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGNhcmcgPSBibG9jay5hcmdzW2ldXG4gICAgaWYoY2FyZy5jb3VudCA8PSAwKSB7XG4gICAgICBjb250aW51ZVxuICAgIH1cbiAgICB2YXIgcmUgPSBuZXcgUmVnRXhwKGNhcmcubmFtZSwgXCJnXCIpXG4gICAgdmFyIHB0clN0ciA9IFwiXCJcbiAgICB2YXIgYXJyTnVtID0gcHJvYy5hcnJheUFyZ3MuaW5kZXhPZihpKVxuICAgIHN3aXRjaChwcm9jLmFyZ1R5cGVzW2ldKSB7XG4gICAgICBjYXNlIFwib2Zmc2V0XCI6XG4gICAgICAgIHZhciBvZmZBcmdJbmRleCA9IHByb2Mub2Zmc2V0QXJnSW5kZXguaW5kZXhPZihpKVxuICAgICAgICB2YXIgb2ZmQXJnID0gcHJvYy5vZmZzZXRBcmdzW29mZkFyZ0luZGV4XVxuICAgICAgICBhcnJOdW0gPSBvZmZBcmcuYXJyYXlcbiAgICAgICAgcHRyU3RyID0gXCIrcVwiICsgb2ZmQXJnSW5kZXhcbiAgICAgIGNhc2UgXCJhcnJheVwiOlxuICAgICAgICBwdHJTdHIgPSBcInBcIiArIGFyck51bSArIHB0clN0clxuICAgICAgICB2YXIgbG9jYWxTdHIgPSBcImxcIiArIGlcbiAgICAgICAgdmFyIGFyclN0ciA9IFwiYVwiICsgYXJyTnVtXG4gICAgICAgIGlmKGNhcmcuY291bnQgPT09IDEpIHtcbiAgICAgICAgICBpZihkdHlwZXNbYXJyTnVtXSA9PT0gXCJnZW5lcmljXCIpIHtcbiAgICAgICAgICAgIGlmKGNhcmcubHZhbHVlKSB7XG4gICAgICAgICAgICAgIHByZS5wdXNoKFtcInZhciBcIiwgbG9jYWxTdHIsIFwiPVwiLCBhcnJTdHIsIFwiLmdldChcIiwgcHRyU3RyLCBcIilcIl0uam9pbihcIlwiKSlcbiAgICAgICAgICAgICAgY29kZSA9IGNvZGUucmVwbGFjZShyZSwgbG9jYWxTdHIpXG4gICAgICAgICAgICAgIHBvc3QucHVzaChbYXJyU3RyLCBcIi5zZXQoXCIsIHB0clN0ciwgXCIsXCIsIGxvY2FsU3RyLFwiKVwiXS5qb2luKFwiXCIpKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29kZSA9IGNvZGUucmVwbGFjZShyZSwgW2FyclN0ciwgXCIuZ2V0KFwiLCBwdHJTdHIsIFwiKVwiXS5qb2luKFwiXCIpKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb2RlID0gY29kZS5yZXBsYWNlKHJlLCBbYXJyU3RyLCBcIltcIiwgcHRyU3RyLCBcIl1cIl0uam9pbihcIlwiKSlcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZihkdHlwZXNbYXJyTnVtXSA9PT0gXCJnZW5lcmljXCIpIHtcbiAgICAgICAgICBwcmUucHVzaChbXCJ2YXIgXCIsIGxvY2FsU3RyLCBcIj1cIiwgYXJyU3RyLCBcIi5nZXQoXCIsIHB0clN0ciwgXCIpXCJdLmpvaW4oXCJcIikpXG4gICAgICAgICAgY29kZSA9IGNvZGUucmVwbGFjZShyZSwgbG9jYWxTdHIpXG4gICAgICAgICAgaWYoY2FyZy5sdmFsdWUpIHtcbiAgICAgICAgICAgIHBvc3QucHVzaChbYXJyU3RyLCBcIi5zZXQoXCIsIHB0clN0ciwgXCIsXCIsIGxvY2FsU3RyLFwiKVwiXS5qb2luKFwiXCIpKVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmUucHVzaChbXCJ2YXIgXCIsIGxvY2FsU3RyLCBcIj1cIiwgYXJyU3RyLCBcIltcIiwgcHRyU3RyLCBcIl1cIl0uam9pbihcIlwiKSlcbiAgICAgICAgICBjb2RlID0gY29kZS5yZXBsYWNlKHJlLCBsb2NhbFN0cilcbiAgICAgICAgICBpZihjYXJnLmx2YWx1ZSkge1xuICAgICAgICAgICAgcG9zdC5wdXNoKFthcnJTdHIsIFwiW1wiLCBwdHJTdHIsIFwiXT1cIiwgbG9jYWxTdHJdLmpvaW4oXCJcIikpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICBicmVha1xuICAgICAgY2FzZSBcInNjYWxhclwiOlxuICAgICAgICBjb2RlID0gY29kZS5yZXBsYWNlKHJlLCBcIllcIiArIHByb2Muc2NhbGFyQXJncy5pbmRleE9mKGkpKVxuICAgICAgYnJlYWtcbiAgICAgIGNhc2UgXCJpbmRleFwiOlxuICAgICAgICBjb2RlID0gY29kZS5yZXBsYWNlKHJlLCBcImluZGV4XCIpXG4gICAgICBicmVha1xuICAgICAgY2FzZSBcInNoYXBlXCI6XG4gICAgICAgIGNvZGUgPSBjb2RlLnJlcGxhY2UocmUsIFwic2hhcGVcIilcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG4gIHJldHVybiBbcHJlLmpvaW4oXCJcXG5cIiksIGNvZGUsIHBvc3Quam9pbihcIlxcblwiKV0uam9pbihcIlxcblwiKS50cmltKClcbn1cblxuZnVuY3Rpb24gdHlwZVN1bW1hcnkoZHR5cGVzKSB7XG4gIHZhciBzdW1tYXJ5ID0gbmV3IEFycmF5KGR0eXBlcy5sZW5ndGgpXG4gIHZhciBhbGxFcXVhbCA9IHRydWVcbiAgZm9yKHZhciBpPTA7IGk8ZHR5cGVzLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHQgPSBkdHlwZXNbaV1cbiAgICB2YXIgZGlnaXRzID0gdC5tYXRjaCgvXFxkKy8pXG4gICAgaWYoIWRpZ2l0cykge1xuICAgICAgZGlnaXRzID0gXCJcIlxuICAgIH0gZWxzZSB7XG4gICAgICBkaWdpdHMgPSBkaWdpdHNbMF1cbiAgICB9XG4gICAgaWYodC5jaGFyQXQoMCkgPT09IDApIHtcbiAgICAgIHN1bW1hcnlbaV0gPSBcInVcIiArIHQuY2hhckF0KDEpICsgZGlnaXRzXG4gICAgfSBlbHNlIHtcbiAgICAgIHN1bW1hcnlbaV0gPSB0LmNoYXJBdCgwKSArIGRpZ2l0c1xuICAgIH1cbiAgICBpZihpID4gMCkge1xuICAgICAgYWxsRXF1YWwgPSBhbGxFcXVhbCAmJiBzdW1tYXJ5W2ldID09PSBzdW1tYXJ5W2ktMV1cbiAgICB9XG4gIH1cbiAgaWYoYWxsRXF1YWwpIHtcbiAgICByZXR1cm4gc3VtbWFyeVswXVxuICB9XG4gIHJldHVybiBzdW1tYXJ5LmpvaW4oXCJcIilcbn1cblxuLy9HZW5lcmF0ZXMgYSBjd2lzZSBvcGVyYXRvclxuZnVuY3Rpb24gZ2VuZXJhdGVDV2lzZU9wKHByb2MsIHR5cGVzaWcpIHtcblxuICAvL0NvbXB1dGUgZGltZW5zaW9uXG4gIHZhciBkaW1lbnNpb24gPSB0eXBlc2lnWzFdLmxlbmd0aHwwXG4gIHZhciBvcmRlcnMgPSBuZXcgQXJyYXkocHJvYy5hcnJheUFyZ3MubGVuZ3RoKVxuICB2YXIgZHR5cGVzID0gbmV3IEFycmF5KHByb2MuYXJyYXlBcmdzLmxlbmd0aClcblxuICAvL0ZpcnN0IGNyZWF0ZSBhcmd1bWVudHMgZm9yIHByb2NlZHVyZVxuICB2YXIgYXJnbGlzdCA9IFtcIlNTXCJdXG4gIHZhciBjb2RlID0gW1wiJ3VzZSBzdHJpY3QnXCJdXG4gIHZhciB2YXJzID0gW11cbiAgXG4gIGZvcih2YXIgaj0wOyBqPGRpbWVuc2lvbjsgKytqKSB7XG4gICAgdmFycy5wdXNoKFtcInNcIiwgaiwgXCI9U1NbXCIsIGosIFwiXVwiXS5qb2luKFwiXCIpKVxuICB9XG4gIGZvcih2YXIgaT0wOyBpPHByb2MuYXJyYXlBcmdzLmxlbmd0aDsgKytpKSB7XG4gICAgYXJnbGlzdC5wdXNoKFwiYVwiK2kpXG4gICAgYXJnbGlzdC5wdXNoKFwidFwiK2kpXG4gICAgYXJnbGlzdC5wdXNoKFwicFwiK2kpXG4gICAgZHR5cGVzW2ldID0gdHlwZXNpZ1syKmldXG4gICAgb3JkZXJzW2ldID0gdHlwZXNpZ1syKmkrMV1cbiAgICBcbiAgICBmb3IodmFyIGo9MDsgajxkaW1lbnNpb247ICsraikge1xuICAgICAgdmFycy5wdXNoKFtcInRcIixpLFwicFwiLGosXCI9dFwiLGksXCJbXCIsaixcIl1cIl0uam9pbihcIlwiKSlcbiAgICB9XG4gIH1cbiAgZm9yKHZhciBpPTA7IGk8cHJvYy5zY2FsYXJBcmdzLmxlbmd0aDsgKytpKSB7XG4gICAgYXJnbGlzdC5wdXNoKFwiWVwiICsgaSlcbiAgfVxuICBpZihwcm9jLnNoYXBlQXJncy5sZW5ndGggPiAwKSB7XG4gICAgdmFycy5wdXNoKFwic2hhcGU9U1Muc2xpY2UoMClcIilcbiAgfVxuICBpZihwcm9jLmluZGV4QXJncy5sZW5ndGggPiAwKSB7XG4gICAgdmFyIHplcm9zID0gbmV3IEFycmF5KGRpbWVuc2lvbilcbiAgICBmb3IodmFyIGk9MDsgaTxkaW1lbnNpb247ICsraSkge1xuICAgICAgemVyb3NbaV0gPSBcIjBcIlxuICAgIH1cbiAgICB2YXJzLnB1c2goW1wiaW5kZXg9W1wiLCB6ZXJvcy5qb2luKFwiLFwiKSwgXCJdXCJdLmpvaW4oXCJcIikpXG4gIH1cbiAgZm9yKHZhciBpPTA7IGk8cHJvYy5vZmZzZXRBcmdzLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIG9mZl9hcmcgPSBwcm9jLm9mZnNldEFyZ3NbaV1cbiAgICB2YXIgaW5pdF9zdHJpbmcgPSBbXVxuICAgIGZvcih2YXIgaj0wOyBqPG9mZl9hcmcub2Zmc2V0Lmxlbmd0aDsgKytqKSB7XG4gICAgICBpZihvZmZfYXJnLm9mZnNldFtqXSA9PT0gMCkge1xuICAgICAgICBjb250aW51ZVxuICAgICAgfSBlbHNlIGlmKG9mZl9hcmcub2Zmc2V0W2pdID09PSAxKSB7XG4gICAgICAgIGluaXRfc3RyaW5nLnB1c2goW1widFwiLCBvZmZfYXJnLmFycmF5LCBcInBcIiwgal0uam9pbihcIlwiKSkgICAgICBcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluaXRfc3RyaW5nLnB1c2goW29mZl9hcmcub2Zmc2V0W2pdLCBcIip0XCIsIG9mZl9hcmcuYXJyYXksIFwicFwiLCBqXS5qb2luKFwiXCIpKVxuICAgICAgfVxuICAgIH1cbiAgICBpZihpbml0X3N0cmluZy5sZW5ndGggPT09IDApIHtcbiAgICAgIHZhcnMucHVzaChcInFcIiArIGkgKyBcIj0wXCIpXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhcnMucHVzaChbXCJxXCIsIGksIFwiPVwiLCBpbml0X3N0cmluZy5qb2luKFwiK1wiKV0uam9pbihcIlwiKSlcbiAgICB9XG4gIH1cblxuICAvL1ByZXBhcmUgdGhpcyB2YXJpYWJsZXNcbiAgdmFyIHRoaXNWYXJzID0gdW5pcShbXS5jb25jYXQocHJvYy5wcmUudGhpc1ZhcnMpXG4gICAgICAgICAgICAgICAgICAgICAgLmNvbmNhdChwcm9jLmJvZHkudGhpc1ZhcnMpXG4gICAgICAgICAgICAgICAgICAgICAgLmNvbmNhdChwcm9jLnBvc3QudGhpc1ZhcnMpKVxuICB2YXJzID0gdmFycy5jb25jYXQodGhpc1ZhcnMpXG4gIGNvZGUucHVzaChcInZhciBcIiArIHZhcnMuam9pbihcIixcIikpXG4gIGZvcih2YXIgaT0wOyBpPHByb2MuYXJyYXlBcmdzLmxlbmd0aDsgKytpKSB7XG4gICAgY29kZS5wdXNoKFwicFwiK2krXCJ8PTBcIilcbiAgfVxuICBcbiAgLy9JbmxpbmUgcHJlbHVkZVxuICBpZihwcm9jLnByZS5ib2R5Lmxlbmd0aCA+IDMpIHtcbiAgICBjb2RlLnB1c2gocHJvY2Vzc0Jsb2NrKHByb2MucHJlLCBwcm9jLCBkdHlwZXMpKVxuICB9XG5cbiAgLy9Qcm9jZXNzIGJvZHlcbiAgdmFyIGJvZHkgPSBwcm9jZXNzQmxvY2socHJvYy5ib2R5LCBwcm9jLCBkdHlwZXMpXG4gIHZhciBtYXRjaGVkID0gY291bnRNYXRjaGVzKG9yZGVycylcbiAgaWYobWF0Y2hlZCA8IGRpbWVuc2lvbikge1xuICAgIGNvZGUucHVzaChvdXRlckZpbGwobWF0Y2hlZCwgb3JkZXJzWzBdLCBwcm9jLCBib2R5KSlcbiAgfSBlbHNlIHtcbiAgICBjb2RlLnB1c2goaW5uZXJGaWxsKG9yZGVyc1swXSwgcHJvYywgYm9keSkpXG4gIH1cblxuICAvL0lubGluZSBlcGlsb2dcbiAgaWYocHJvYy5wb3N0LmJvZHkubGVuZ3RoID4gMykge1xuICAgIGNvZGUucHVzaChwcm9jZXNzQmxvY2socHJvYy5wb3N0LCBwcm9jLCBkdHlwZXMpKVxuICB9XG4gIFxuICBpZihwcm9jLmRlYnVnKSB7XG4gICAgY29uc29sZS5sb2coXCJHZW5lcmF0ZWQgY3dpc2Ugcm91dGluZSBmb3IgXCIsIHR5cGVzaWcsIFwiOlxcblxcblwiLCBjb2RlLmpvaW4oXCJcXG5cIikpXG4gIH1cbiAgXG4gIHZhciBsb29wTmFtZSA9IFsocHJvYy5mdW5jTmFtZXx8XCJ1bm5hbWVkXCIpLCBcIl9jd2lzZV9sb29wX1wiLCBvcmRlcnNbMF0uam9pbihcInNcIiksXCJtXCIsbWF0Y2hlZCx0eXBlU3VtbWFyeShkdHlwZXMpXS5qb2luKFwiXCIpXG4gIHZhciBmID0gbmV3IEZ1bmN0aW9uKFtcImZ1bmN0aW9uIFwiLGxvb3BOYW1lLFwiKFwiLCBhcmdsaXN0LmpvaW4oXCIsXCIpLFwiKXtcIiwgY29kZS5qb2luKFwiXFxuXCIpLFwifSByZXR1cm4gXCIsIGxvb3BOYW1lXS5qb2luKFwiXCIpKVxuICByZXR1cm4gZigpXG59XG5tb2R1bGUuZXhwb3J0cyA9IGdlbmVyYXRlQ1dpc2VPcCIsIlwidXNlIHN0cmljdFwiXG5cbnZhciBjb21waWxlID0gcmVxdWlyZShcIi4vY29tcGlsZS5qc1wiKVxuXG5mdW5jdGlvbiBjcmVhdGVUaHVuayhwcm9jKSB7XG4gIHZhciBjb2RlID0gW1wiJ3VzZSBzdHJpY3QnXCIsIFwidmFyIENBQ0hFRD17fVwiXVxuICB2YXIgdmFycyA9IFtdXG4gIHZhciB0aHVua05hbWUgPSBwcm9jLmZ1bmNOYW1lICsgXCJfY3dpc2VfdGh1bmtcIlxuICBcbiAgLy9CdWlsZCB0aHVua1xuICBjb2RlLnB1c2goW1wicmV0dXJuIGZ1bmN0aW9uIFwiLCB0aHVua05hbWUsIFwiKFwiLCBwcm9jLnNoaW1BcmdzLmpvaW4oXCIsXCIpLCBcIil7XCJdLmpvaW4oXCJcIikpXG4gIHZhciB0eXBlc2lnID0gW11cbiAgdmFyIHN0cmluZ190eXBlc2lnID0gW11cbiAgdmFyIHByb2NfYXJncyA9IFtbXCJhcnJheVwiLHByb2MuYXJyYXlBcmdzWzBdLFwiLnNoYXBlXCJdLmpvaW4oXCJcIildXG4gIGZvcih2YXIgaT0wOyBpPHByb2MuYXJyYXlBcmdzLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGogPSBwcm9jLmFycmF5QXJnc1tpXVxuICAgIHZhcnMucHVzaChbXCJ0XCIsIGosIFwiPWFycmF5XCIsIGosIFwiLmR0eXBlLFwiLFxuICAgICAgICAgICAgICAgXCJyXCIsIGosIFwiPWFycmF5XCIsIGosIFwiLm9yZGVyXCJdLmpvaW4oXCJcIikpXG4gICAgdHlwZXNpZy5wdXNoKFwidFwiICsgailcbiAgICB0eXBlc2lnLnB1c2goXCJyXCIgKyBqKVxuICAgIHN0cmluZ190eXBlc2lnLnB1c2goXCJ0XCIrailcbiAgICBzdHJpbmdfdHlwZXNpZy5wdXNoKFwiclwiK2orXCIuam9pbigpXCIpXG4gICAgcHJvY19hcmdzLnB1c2goXCJhcnJheVwiICsgaiArIFwiLmRhdGFcIilcbiAgICBwcm9jX2FyZ3MucHVzaChcImFycmF5XCIgKyBqICsgXCIuc3RyaWRlXCIpXG4gICAgcHJvY19hcmdzLnB1c2goXCJhcnJheVwiICsgaiArIFwiLm9mZnNldHwwXCIpXG4gIH1cbiAgZm9yKHZhciBpPTA7IGk8cHJvYy5zY2FsYXJBcmdzLmxlbmd0aDsgKytpKSB7XG4gICAgcHJvY19hcmdzLnB1c2goXCJzY2FsYXJcIiArIHByb2Muc2NhbGFyQXJnc1tpXSlcbiAgfVxuICB2YXJzLnB1c2goW1widHlwZT1bXCIsIHN0cmluZ190eXBlc2lnLmpvaW4oXCIsXCIpLCBcIl0uam9pbigpXCJdLmpvaW4oXCJcIikpXG4gIHZhcnMucHVzaChcInByb2M9Q0FDSEVEW3R5cGVdXCIpXG4gIGNvZGUucHVzaChcInZhciBcIiArIHZhcnMuam9pbihcIixcIikpXG4gIFxuICBjb2RlLnB1c2goW1wiaWYoIXByb2Mpe1wiLFxuICAgICAgICAgICAgIFwiQ0FDSEVEW3R5cGVdPXByb2M9Y29tcGlsZShbXCIsIHR5cGVzaWcuam9pbihcIixcIiksIFwiXSl9XCIsXG4gICAgICAgICAgICAgXCJyZXR1cm4gcHJvYyhcIiwgcHJvY19hcmdzLmpvaW4oXCIsXCIpLCBcIil9XCJdLmpvaW4oXCJcIikpXG5cbiAgaWYocHJvYy5kZWJ1Zykge1xuICAgIGNvbnNvbGUubG9nKFwiR2VuZXJhdGVkIHRodW5rOlwiLCBjb2RlLmpvaW4oXCJcXG5cIikpXG4gIH1cbiAgXG4gIC8vQ29tcGlsZSB0aHVua1xuICB2YXIgdGh1bmsgPSBuZXcgRnVuY3Rpb24oXCJjb21waWxlXCIsIGNvZGUuam9pbihcIlxcblwiKSlcbiAgcmV0dXJuIHRodW5rKGNvbXBpbGUuYmluZCh1bmRlZmluZWQsIHByb2MpKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZVRodW5rXG4iLCJcInVzZSBzdHJpY3RcIlxuXG5mdW5jdGlvbiB1bmlxdWVfcHJlZChsaXN0LCBjb21wYXJlKSB7XG4gIHZhciBwdHIgPSAxXG4gICAgLCBsZW4gPSBsaXN0Lmxlbmd0aFxuICAgICwgYT1saXN0WzBdLCBiPWxpc3RbMF1cbiAgZm9yKHZhciBpPTE7IGk8bGVuOyArK2kpIHtcbiAgICBiID0gYVxuICAgIGEgPSBsaXN0W2ldXG4gICAgaWYoY29tcGFyZShhLCBiKSkge1xuICAgICAgaWYoaSA9PT0gcHRyKSB7XG4gICAgICAgIHB0cisrXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG4gICAgICBsaXN0W3B0cisrXSA9IGFcbiAgICB9XG4gIH1cbiAgbGlzdC5sZW5ndGggPSBwdHJcbiAgcmV0dXJuIGxpc3Rcbn1cblxuZnVuY3Rpb24gdW5pcXVlX2VxKGxpc3QpIHtcbiAgdmFyIHB0ciA9IDFcbiAgICAsIGxlbiA9IGxpc3QubGVuZ3RoXG4gICAgLCBhPWxpc3RbMF0sIGIgPSBsaXN0WzBdXG4gIGZvcih2YXIgaT0xOyBpPGxlbjsgKytpLCBiPWEpIHtcbiAgICBiID0gYVxuICAgIGEgPSBsaXN0W2ldXG4gICAgaWYoYSAhPT0gYikge1xuICAgICAgaWYoaSA9PT0gcHRyKSB7XG4gICAgICAgIHB0cisrXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG4gICAgICBsaXN0W3B0cisrXSA9IGFcbiAgICB9XG4gIH1cbiAgbGlzdC5sZW5ndGggPSBwdHJcbiAgcmV0dXJuIGxpc3Rcbn1cblxuZnVuY3Rpb24gdW5pcXVlKGxpc3QsIGNvbXBhcmUsIHNvcnRlZCkge1xuICBpZihsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBsaXN0XG4gIH1cbiAgaWYoY29tcGFyZSkge1xuICAgIGlmKCFzb3J0ZWQpIHtcbiAgICAgIGxpc3Quc29ydChjb21wYXJlKVxuICAgIH1cbiAgICByZXR1cm4gdW5pcXVlX3ByZWQobGlzdCwgY29tcGFyZSlcbiAgfVxuICBpZighc29ydGVkKSB7XG4gICAgbGlzdC5zb3J0KClcbiAgfVxuICByZXR1cm4gdW5pcXVlX2VxKGxpc3QpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gdW5pcXVlXG4iLCIoZnVuY3Rpb24gKEJ1ZmZlcil7XG52YXIgaW90YSA9IHJlcXVpcmUoXCJpb3RhLWFycmF5XCIpXG5cbnZhciBhcnJheU1ldGhvZHMgPSBbXG4gIFwiY29uY2F0XCIsXG4gIFwiam9pblwiLFxuICBcInNsaWNlXCIsXG4gIFwidG9TdHJpbmdcIixcbiAgXCJpbmRleE9mXCIsXG4gIFwibGFzdEluZGV4T2ZcIixcbiAgXCJmb3JFYWNoXCIsXG4gIFwiZXZlcnlcIixcbiAgXCJzb21lXCIsXG4gIFwiZmlsdGVyXCIsXG4gIFwibWFwXCIsXG4gIFwicmVkdWNlXCIsXG4gIFwicmVkdWNlUmlnaHRcIlxuXVxuXG52YXIgaGFzVHlwZWRBcnJheXMgID0gKCh0eXBlb2YgRmxvYXQ2NEFycmF5KSAhPT0gXCJ1bmRlZmluZWRcIilcbnZhciBoYXNCdWZmZXIgICAgICAgPSAoKHR5cGVvZiBCdWZmZXIpICE9PSBcInVuZGVmaW5lZFwiKVxuXG5mdW5jdGlvbiBjb21wYXJlMXN0KGEsIGIpIHtcbiAgcmV0dXJuIGFbMF0gLSBiWzBdXG59XG5cbmZ1bmN0aW9uIG9yZGVyKCkge1xuICB2YXIgc3RyaWRlID0gdGhpcy5zdHJpZGVcbiAgdmFyIHRlcm1zID0gbmV3IEFycmF5KHN0cmlkZS5sZW5ndGgpXG4gIHZhciBpXG4gIGZvcihpPTA7IGk8dGVybXMubGVuZ3RoOyArK2kpIHtcbiAgICB0ZXJtc1tpXSA9IFtNYXRoLmFicyhzdHJpZGVbaV0pLCBpXVxuICB9XG4gIHRlcm1zLnNvcnQoY29tcGFyZTFzdClcbiAgdmFyIHJlc3VsdCA9IG5ldyBBcnJheSh0ZXJtcy5sZW5ndGgpXG4gIGZvcihpPTA7IGk8cmVzdWx0Lmxlbmd0aDsgKytpKSB7XG4gICAgcmVzdWx0W2ldID0gdGVybXNbaV1bMV1cbiAgfVxuICByZXR1cm4gcmVzdWx0XG59XG5cbmZ1bmN0aW9uIGNvbXBpbGVDb25zdHJ1Y3RvcihkdHlwZSwgZGltZW5zaW9uKSB7XG4gIHZhciBjbGFzc05hbWUgPSBbXCJWaWV3XCIsIGRpbWVuc2lvbiwgXCJkXCIsIGR0eXBlXS5qb2luKFwiXCIpXG4gIGlmKGRpbWVuc2lvbiA8IDApIHtcbiAgICBjbGFzc05hbWUgPSBcIlZpZXdfTmlsXCIgKyBkdHlwZVxuICB9XG4gIHZhciB1c2VHZXR0ZXJzID0gKGR0eXBlID09PSBcImdlbmVyaWNcIilcbiAgXG4gIGlmKGRpbWVuc2lvbiA9PT0gLTEpIHtcbiAgICAvL1NwZWNpYWwgY2FzZSBmb3IgdHJpdmlhbCBhcnJheXNcbiAgICB2YXIgY29kZSA9IFxuICAgICAgXCJmdW5jdGlvbiBcIitjbGFzc05hbWUrXCIoYSl7dGhpcy5kYXRhPWE7fTtcXFxudmFyIHByb3RvPVwiK2NsYXNzTmFtZStcIi5wcm90b3R5cGU7XFxcbnByb3RvLmR0eXBlPSdcIitkdHlwZStcIic7XFxcbnByb3RvLmluZGV4PWZ1bmN0aW9uKCl7cmV0dXJuIC0xfTtcXFxucHJvdG8uc2l6ZT0wO1xcXG5wcm90by5kaW1lbnNpb249LTE7XFxcbnByb3RvLnNoYXBlPXByb3RvLnN0cmlkZT1wcm90by5vcmRlcj1bXTtcXFxucHJvdG8ubG89cHJvdG8uaGk9cHJvdG8udHJhbnNwb3NlPXByb3RvLnN0ZXA9XFxcbmZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBcIitjbGFzc05hbWUrXCIodGhpcy5kYXRhKTt9O1xcXG5wcm90by5nZXQ9cHJvdG8uc2V0PWZ1bmN0aW9uKCl7fTtcXFxucHJvdG8ucGljaz1mdW5jdGlvbigpe3JldHVybiBudWxsfTtcXFxucmV0dXJuIGZ1bmN0aW9uIGNvbnN0cnVjdF9cIitjbGFzc05hbWUrXCIoYSl7cmV0dXJuIG5ldyBcIitjbGFzc05hbWUrXCIoYSk7fVwiXG4gICAgdmFyIHByb2NlZHVyZSA9IG5ldyBGdW5jdGlvbihjb2RlKVxuICAgIHJldHVybiBwcm9jZWR1cmUoKVxuICB9IGVsc2UgaWYoZGltZW5zaW9uID09PSAwKSB7XG4gICAgLy9TcGVjaWFsIGNhc2UgZm9yIDBkIGFycmF5c1xuICAgIHZhciBjb2RlID1cbiAgICAgIFwiZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiKGEsZCkge1xcXG50aGlzLmRhdGEgPSBhO1xcXG50aGlzLm9mZnNldCA9IGRcXFxufTtcXFxudmFyIHByb3RvPVwiK2NsYXNzTmFtZStcIi5wcm90b3R5cGU7XFxcbnByb3RvLmR0eXBlPSdcIitkdHlwZStcIic7XFxcbnByb3RvLmluZGV4PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMub2Zmc2V0fTtcXFxucHJvdG8uZGltZW5zaW9uPTA7XFxcbnByb3RvLnNpemU9MTtcXFxucHJvdG8uc2hhcGU9XFxcbnByb3RvLnN0cmlkZT1cXFxucHJvdG8ub3JkZXI9W107XFxcbnByb3RvLmxvPVxcXG5wcm90by5oaT1cXFxucHJvdG8udHJhbnNwb3NlPVxcXG5wcm90by5zdGVwPWZ1bmN0aW9uIFwiK2NsYXNzTmFtZStcIl9jb3B5KCkge1xcXG5yZXR1cm4gbmV3IFwiK2NsYXNzTmFtZStcIih0aGlzLmRhdGEsdGhpcy5vZmZzZXQpXFxcbn07XFxcbnByb3RvLnBpY2s9ZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiX3BpY2soKXtcXFxucmV0dXJuIFRyaXZpYWxBcnJheSh0aGlzLmRhdGEpO1xcXG59O1xcXG5wcm90by52YWx1ZU9mPXByb3RvLmdldD1mdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfZ2V0KCl7XFxcbnJldHVybiBcIisodXNlR2V0dGVycyA/IFwidGhpcy5kYXRhLmdldCh0aGlzLm9mZnNldClcIiA6IFwidGhpcy5kYXRhW3RoaXMub2Zmc2V0XVwiKStcblwifTtcXFxucHJvdG8uc2V0PWZ1bmN0aW9uIFwiK2NsYXNzTmFtZStcIl9zZXQodil7XFxcbnJldHVybiBcIisodXNlR2V0dGVycyA/IFwidGhpcy5kYXRhLnNldCh0aGlzLm9mZnNldCx2KVwiIDogXCJ0aGlzLmRhdGFbdGhpcy5vZmZzZXRdPXZcIikrXCJcXFxufTtcXFxucmV0dXJuIGZ1bmN0aW9uIGNvbnN0cnVjdF9cIitjbGFzc05hbWUrXCIoYSxiLGMsZCl7cmV0dXJuIG5ldyBcIitjbGFzc05hbWUrXCIoYSxkKX1cIlxuICAgIHZhciBwcm9jZWR1cmUgPSBuZXcgRnVuY3Rpb24oXCJUcml2aWFsQXJyYXlcIiwgY29kZSlcbiAgICByZXR1cm4gcHJvY2VkdXJlKENBQ0hFRF9DT05TVFJVQ1RPUlNbZHR5cGVdWzBdKVxuICB9XG5cbiAgdmFyIGNvZGUgPSBbXCIndXNlIHN0cmljdCdcIl1cbiAgICBcbiAgLy9DcmVhdGUgY29uc3RydWN0b3IgZm9yIHZpZXdcbiAgdmFyIGluZGljZXMgPSBpb3RhKGRpbWVuc2lvbilcbiAgdmFyIGFyZ3MgPSBpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7IHJldHVybiBcImlcIitpIH0pXG4gIHZhciBpbmRleF9zdHIgPSBcInRoaXMub2Zmc2V0K1wiICsgaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkge1xuICAgICAgICByZXR1cm4gXCJ0aGlzLl9zdHJpZGVcIiArIGkgKyBcIippXCIgKyBpXG4gICAgICB9KS5qb2luKFwiK1wiKVxuICBjb2RlLnB1c2goXCJmdW5jdGlvbiBcIitjbGFzc05hbWUrXCIoYSxcIitcbiAgICBpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gXCJiXCIraVxuICAgIH0pLmpvaW4oXCIsXCIpICsgXCIsXCIgK1xuICAgIGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBcImNcIitpXG4gICAgfSkuam9pbihcIixcIikgKyBcIixkKXt0aGlzLmRhdGE9YVwiKVxuICBmb3IodmFyIGk9MDsgaTxkaW1lbnNpb247ICsraSkge1xuICAgIGNvZGUucHVzaChcInRoaXMuX3NoYXBlXCIraStcIj1iXCIraStcInwwXCIpXG4gIH1cbiAgZm9yKHZhciBpPTA7IGk8ZGltZW5zaW9uOyArK2kpIHtcbiAgICBjb2RlLnB1c2goXCJ0aGlzLl9zdHJpZGVcIitpK1wiPWNcIitpK1wifDBcIilcbiAgfVxuICBjb2RlLnB1c2goXCJ0aGlzLm9mZnNldD1kfDB9XCIsXG4gICAgXCJ2YXIgcHJvdG89XCIrY2xhc3NOYW1lK1wiLnByb3RvdHlwZVwiLFxuICAgIFwicHJvdG8uZHR5cGU9J1wiK2R0eXBlK1wiJ1wiLFxuICAgIFwicHJvdG8uZGltZW5zaW9uPVwiK2RpbWVuc2lvbilcbiAgXG4gIC8vdmlldy5zdHJpZGUgYW5kIHZpZXcuc2hhcGVcbiAgdmFyIHN0cmlkZUNsYXNzTmFtZSA9IFwiVlN0cmlkZVwiICsgZGltZW5zaW9uICsgXCJkXCIgKyBkdHlwZVxuICB2YXIgc2hhcGVDbGFzc05hbWUgPSBcIlZTaGFwZVwiICsgZGltZW5zaW9uICsgXCJkXCIgKyBkdHlwZVxuICB2YXIgcHJvcHMgPSB7XCJzdHJpZGVcIjpzdHJpZGVDbGFzc05hbWUsIFwic2hhcGVcIjpzaGFwZUNsYXNzTmFtZX1cbiAgZm9yKHZhciBwcm9wIGluIHByb3BzKSB7XG4gICAgdmFyIGFycmF5TmFtZSA9IHByb3BzW3Byb3BdXG4gICAgY29kZS5wdXNoKFxuICAgICAgXCJmdW5jdGlvbiBcIiArIGFycmF5TmFtZSArIFwiKHYpIHt0aGlzLl92PXZ9IHZhciBhcHJvdG89XCIgKyBhcnJheU5hbWUgKyBcIi5wcm90b3R5cGVcIixcbiAgICAgIFwiYXByb3RvLmxlbmd0aD1cIitkaW1lbnNpb24pXG4gICAgXG4gICAgdmFyIGFycmF5X2VsZW1lbnRzID0gW11cbiAgICBmb3IodmFyIGk9MDsgaTxkaW1lbnNpb247ICsraSkge1xuICAgICAgYXJyYXlfZWxlbWVudHMucHVzaChbXCJ0aGlzLl92Ll9cIiwgcHJvcCwgaV0uam9pbihcIlwiKSlcbiAgICB9XG4gICAgY29kZS5wdXNoKFxuICAgICAgXCJhcHJvdG8udG9KU09OPWZ1bmN0aW9uIFwiICsgYXJyYXlOYW1lICsgXCJfdG9KU09OKCl7cmV0dXJuIFtcIiArIGFycmF5X2VsZW1lbnRzLmpvaW4oXCIsXCIpICsgXCJdfVwiLFxuICAgICAgXCJhcHJvdG8udmFsdWVPZj1hcHJvdG8udG9TdHJpbmc9ZnVuY3Rpb24gXCIgKyBhcnJheU5hbWUgKyBcIl90b1N0cmluZygpe3JldHVybiBbXCIgKyBhcnJheV9lbGVtZW50cy5qb2luKFwiLFwiKSArIFwiXS5qb2luKCl9XCIpXG4gICAgXG4gICAgZm9yKHZhciBpPTA7IGk8ZGltZW5zaW9uOyArK2kpIHtcbiAgICAgIGNvZGUucHVzaChcIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShhcHJvdG8sXCIraStcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3YuX1wiK3Byb3AraStcIn0sc2V0OmZ1bmN0aW9uKHYpe3JldHVybiB0aGlzLl92Ll9cIitwcm9wK2krXCI9dnwwfSxlbnVtZXJhYmxlOnRydWV9KVwiKVxuICAgIH1cbiAgICBmb3IodmFyIGk9MDsgaTxhcnJheU1ldGhvZHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGlmKGFycmF5TWV0aG9kc1tpXSBpbiBBcnJheS5wcm90b3R5cGUpIHtcbiAgICAgICAgY29kZS5wdXNoKFwiYXByb3RvLlwiK2FycmF5TWV0aG9kc1tpXStcIj1BcnJheS5wcm90b3R5cGUuXCIrYXJyYXlNZXRob2RzW2ldKVxuICAgICAgfVxuICAgIH1cbiAgICBjb2RlLnB1c2goW1wiT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvLCdcIixwcm9wLFwiJyx7Z2V0OmZ1bmN0aW9uIFwiLCBhcnJheU5hbWUsIFwiX2dldCgpe3JldHVybiBuZXcgXCIsIGFycmF5TmFtZSwgXCIodGhpcyl9LHNldDogZnVuY3Rpb24gXCIsIGFycmF5TmFtZSwgXCJfc2V0KHYpe1wiXS5qb2luKFwiXCIpKVxuICAgIGZvcih2YXIgaT0wOyBpPGRpbWVuc2lvbjsgKytpKSB7XG4gICAgICBjb2RlLnB1c2goXCJ0aGlzLl9cIitwcm9wK2krXCI9dltcIitpK1wiXXwwXCIpXG4gICAgfVxuICAgIGNvZGUucHVzaChcInJldHVybiB2fX0pXCIpXG4gIH1cbiAgXG4gIC8vdmlldy5zaXplOlxuICBjb2RlLnB1c2goXCJPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG8sJ3NpemUnLHtnZXQ6ZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiX3NpemUoKXtcXFxucmV0dXJuIFwiK2luZGljZXMubWFwKGZ1bmN0aW9uKGkpIHsgcmV0dXJuIFwidGhpcy5fc2hhcGVcIitpIH0pLmpvaW4oXCIqXCIpLFxuXCJ9fSlcIilcblxuICAvL3ZpZXcub3JkZXI6XG4gIGlmKGRpbWVuc2lvbiA9PT0gMSkge1xuICAgIGNvZGUucHVzaChcInByb3RvLm9yZGVyPVswXVwiKVxuICB9IGVsc2Uge1xuICAgIGNvZGUucHVzaChcIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90bywnb3JkZXInLHtnZXQ6XCIpXG4gICAgaWYoZGltZW5zaW9uIDwgNCkge1xuICAgICAgY29kZS5wdXNoKFwiZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiX29yZGVyKCl7XCIpXG4gICAgICBpZihkaW1lbnNpb24gPT09IDIpIHtcbiAgICAgICAgY29kZS5wdXNoKFwicmV0dXJuIChNYXRoLmFicyh0aGlzLl9zdHJpZGUwKT5NYXRoLmFicyh0aGlzLl9zdHJpZGUxKSk/WzEsMF06WzAsMV19fSlcIilcbiAgICAgIH0gZWxzZSBpZihkaW1lbnNpb24gPT09IDMpIHtcbiAgICAgICAgY29kZS5wdXNoKFxuXCJ2YXIgczA9TWF0aC5hYnModGhpcy5fc3RyaWRlMCksczE9TWF0aC5hYnModGhpcy5fc3RyaWRlMSksczI9TWF0aC5hYnModGhpcy5fc3RyaWRlMik7XFxcbmlmKHMwPnMxKXtcXFxuaWYoczE+czIpe1xcXG5yZXR1cm4gWzIsMSwwXTtcXFxufWVsc2UgaWYoczA+czIpe1xcXG5yZXR1cm4gWzEsMiwwXTtcXFxufWVsc2V7XFxcbnJldHVybiBbMSwwLDJdO1xcXG59XFxcbn1lbHNlIGlmKHMwPnMyKXtcXFxucmV0dXJuIFsyLDAsMV07XFxcbn1lbHNlIGlmKHMyPnMxKXtcXFxucmV0dXJuIFswLDEsMl07XFxcbn1lbHNle1xcXG5yZXR1cm4gWzAsMiwxXTtcXFxufX19KVwiKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb2RlLnB1c2goXCJPUkRFUn0pXCIpXG4gICAgfVxuICB9XG4gIFxuICAvL3ZpZXcuc2V0KGkwLCAuLi4sIHYpOlxuICBjb2RlLnB1c2goXG5cInByb3RvLnNldD1mdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfc2V0KFwiK2FyZ3Muam9pbihcIixcIikrXCIsdil7XCIpXG4gIGlmKHVzZUdldHRlcnMpIHtcbiAgICBjb2RlLnB1c2goXCJyZXR1cm4gdGhpcy5kYXRhLnNldChcIitpbmRleF9zdHIrXCIsdil9XCIpXG4gIH0gZWxzZSB7XG4gICAgY29kZS5wdXNoKFwicmV0dXJuIHRoaXMuZGF0YVtcIitpbmRleF9zdHIrXCJdPXZ9XCIpXG4gIH1cbiAgXG4gIC8vdmlldy5nZXQoaTAsIC4uLik6XG4gIGNvZGUucHVzaChcInByb3RvLmdldD1mdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfZ2V0KFwiK2FyZ3Muam9pbihcIixcIikrXCIpe1wiKVxuICBpZih1c2VHZXR0ZXJzKSB7XG4gICAgY29kZS5wdXNoKFwicmV0dXJuIHRoaXMuZGF0YS5nZXQoXCIraW5kZXhfc3RyK1wiKX1cIilcbiAgfSBlbHNlIHtcbiAgICBjb2RlLnB1c2goXCJyZXR1cm4gdGhpcy5kYXRhW1wiK2luZGV4X3N0citcIl19XCIpXG4gIH1cbiAgXG4gIC8vdmlldy5pbmRleDpcbiAgY29kZS5wdXNoKFxuICAgIFwicHJvdG8uaW5kZXg9ZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiX2luZGV4KFwiLCBhcmdzLmpvaW4oKSwgXCIpe3JldHVybiBcIitpbmRleF9zdHIrXCJ9XCIpXG5cbiAgLy92aWV3LmhpKCk6XG4gIGNvZGUucHVzaChcInByb3RvLmhpPWZ1bmN0aW9uIFwiK2NsYXNzTmFtZStcIl9oaShcIithcmdzLmpvaW4oXCIsXCIpK1wiKXtyZXR1cm4gbmV3IFwiK2NsYXNzTmFtZStcIih0aGlzLmRhdGEsXCIrXG4gICAgaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIFtcIih0eXBlb2YgaVwiLGksXCIhPT0nbnVtYmVyJ3x8aVwiLGksXCI8MCk/dGhpcy5fc2hhcGVcIiwgaSwgXCI6aVwiLCBpLFwifDBcIl0uam9pbihcIlwiKVxuICAgIH0pLmpvaW4oXCIsXCIpK1wiLFwiK1xuICAgIGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBcInRoaXMuX3N0cmlkZVwiK2lcbiAgICB9KS5qb2luKFwiLFwiKStcIix0aGlzLm9mZnNldCl9XCIpXG4gIFxuICAvL3ZpZXcubG8oKTpcbiAgdmFyIGFfdmFycyA9IGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHsgcmV0dXJuIFwiYVwiK2krXCI9dGhpcy5fc2hhcGVcIitpIH0pXG4gIHZhciBjX3ZhcnMgPSBpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7IHJldHVybiBcImNcIitpK1wiPXRoaXMuX3N0cmlkZVwiK2kgfSlcbiAgY29kZS5wdXNoKFwicHJvdG8ubG89ZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiX2xvKFwiK2FyZ3Muam9pbihcIixcIikrXCIpe3ZhciBiPXRoaXMub2Zmc2V0LGQ9MCxcIithX3ZhcnMuam9pbihcIixcIikrXCIsXCIrY192YXJzLmpvaW4oXCIsXCIpKVxuICBmb3IodmFyIGk9MDsgaTxkaW1lbnNpb247ICsraSkge1xuICAgIGNvZGUucHVzaChcblwiaWYodHlwZW9mIGlcIitpK1wiPT09J251bWJlcicmJmlcIitpK1wiPj0wKXtcXFxuZD1pXCIraStcInwwO1xcXG5iKz1jXCIraStcIipkO1xcXG5hXCIraStcIi09ZH1cIilcbiAgfVxuICBjb2RlLnB1c2goXCJyZXR1cm4gbmV3IFwiK2NsYXNzTmFtZStcIih0aGlzLmRhdGEsXCIrXG4gICAgaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIFwiYVwiK2lcbiAgICB9KS5qb2luKFwiLFwiKStcIixcIitcbiAgICBpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gXCJjXCIraVxuICAgIH0pLmpvaW4oXCIsXCIpK1wiLGIpfVwiKVxuICBcbiAgLy92aWV3LnN0ZXAoKTpcbiAgY29kZS5wdXNoKFwicHJvdG8uc3RlcD1mdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfc3RlcChcIithcmdzLmpvaW4oXCIsXCIpK1wiKXt2YXIgXCIrXG4gICAgaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIFwiYVwiK2krXCI9dGhpcy5fc2hhcGVcIitpXG4gICAgfSkuam9pbihcIixcIikrXCIsXCIrXG4gICAgaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIFwiYlwiK2krXCI9dGhpcy5fc3RyaWRlXCIraVxuICAgIH0pLmpvaW4oXCIsXCIpK1wiLGM9dGhpcy5vZmZzZXQsZD0wLGNlaWw9TWF0aC5jZWlsXCIpXG4gIGZvcih2YXIgaT0wOyBpPGRpbWVuc2lvbjsgKytpKSB7XG4gICAgY29kZS5wdXNoKFxuXCJpZih0eXBlb2YgaVwiK2krXCI9PT0nbnVtYmVyJyl7XFxcbmQ9aVwiK2krXCJ8MDtcXFxuaWYoZDwwKXtcXFxuYys9YlwiK2krXCIqKGFcIitpK1wiLTEpO1xcXG5hXCIraStcIj1jZWlsKC1hXCIraStcIi9kKVxcXG59ZWxzZXtcXFxuYVwiK2krXCI9Y2VpbChhXCIraStcIi9kKVxcXG59XFxcbmJcIitpK1wiKj1kXFxcbn1cIilcbiAgfVxuICBjb2RlLnB1c2goXCJyZXR1cm4gbmV3IFwiK2NsYXNzTmFtZStcIih0aGlzLmRhdGEsXCIrXG4gICAgaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIFwiYVwiICsgaVxuICAgIH0pLmpvaW4oXCIsXCIpK1wiLFwiK1xuICAgIGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBcImJcIiArIGlcbiAgICB9KS5qb2luKFwiLFwiKStcIixjKX1cIilcbiAgXG4gIC8vdmlldy50cmFuc3Bvc2UoKTpcbiAgdmFyIHRTaGFwZSA9IG5ldyBBcnJheShkaW1lbnNpb24pXG4gIHZhciB0U3RyaWRlID0gbmV3IEFycmF5KGRpbWVuc2lvbilcbiAgZm9yKHZhciBpPTA7IGk8ZGltZW5zaW9uOyArK2kpIHtcbiAgICB0U2hhcGVbaV0gPSBcImFbaVwiK2krXCJdXCJcbiAgICB0U3RyaWRlW2ldID0gXCJiW2lcIitpK1wiXVwiXG4gIH1cbiAgY29kZS5wdXNoKFwicHJvdG8udHJhbnNwb3NlPWZ1bmN0aW9uIFwiK2NsYXNzTmFtZStcIl90cmFuc3Bvc2UoXCIrYXJncytcIil7XCIrXG4gICAgYXJncy5tYXAoZnVuY3Rpb24obixpZHgpIHsgcmV0dXJuIG4gKyBcIj0oXCIgKyBuICsgXCI9PT11bmRlZmluZWQ/XCIgKyBpZHggKyBcIjpcIiArIG4gKyBcInwwKVwifSkuam9pbihcIjtcIiksXG4gICAgXCJ2YXIgYT10aGlzLnNoYXBlLGI9dGhpcy5zdHJpZGU7cmV0dXJuIG5ldyBcIitjbGFzc05hbWUrXCIodGhpcy5kYXRhLFwiK3RTaGFwZS5qb2luKFwiLFwiKStcIixcIit0U3RyaWRlLmpvaW4oXCIsXCIpK1wiLHRoaXMub2Zmc2V0KX1cIilcbiAgXG4gIC8vdmlldy5waWNrKCk6XG4gIGNvZGUucHVzaChcInByb3RvLnBpY2s9ZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiX3BpY2soXCIrYXJncytcIil7dmFyIGE9W10sYj1bXSxjPXRoaXMub2Zmc2V0XCIpXG4gIGZvcih2YXIgaT0wOyBpPGRpbWVuc2lvbjsgKytpKSB7XG4gICAgY29kZS5wdXNoKFwiaWYodHlwZW9mIGlcIitpK1wiPT09J251bWJlcicmJmlcIitpK1wiPj0wKXtjPShjK3RoaXMuX3N0cmlkZVwiK2krXCIqaVwiK2krXCIpfDB9ZWxzZXthLnB1c2godGhpcy5fc2hhcGVcIitpK1wiKTtiLnB1c2godGhpcy5fc3RyaWRlXCIraStcIil9XCIpXG4gIH1cbiAgY29kZS5wdXNoKFwidmFyIGN0b3I9Q1RPUl9MSVNUW2EubGVuZ3RoKzFdO3JldHVybiBjdG9yKHRoaXMuZGF0YSxhLGIsYyl9XCIpXG4gICAgXG4gIC8vQWRkIHJldHVybiBzdGF0ZW1lbnRcbiAgY29kZS5wdXNoKFwicmV0dXJuIGZ1bmN0aW9uIGNvbnN0cnVjdF9cIitjbGFzc05hbWUrXCIoZGF0YSxzaGFwZSxzdHJpZGUsb2Zmc2V0KXtyZXR1cm4gbmV3IFwiK2NsYXNzTmFtZStcIihkYXRhLFwiK1xuICAgIGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBcInNoYXBlW1wiK2krXCJdXCJcbiAgICB9KS5qb2luKFwiLFwiKStcIixcIitcbiAgICBpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gXCJzdHJpZGVbXCIraStcIl1cIlxuICAgIH0pLmpvaW4oXCIsXCIpK1wiLG9mZnNldCl9XCIpXG5cbiAgLy9Db21waWxlIHByb2NlZHVyZVxuICB2YXIgcHJvY2VkdXJlID0gbmV3IEZ1bmN0aW9uKFwiQ1RPUl9MSVNUXCIsIFwiT1JERVJcIiwgY29kZS5qb2luKFwiXFxuXCIpKVxuICByZXR1cm4gcHJvY2VkdXJlKENBQ0hFRF9DT05TVFJVQ1RPUlNbZHR5cGVdLCBvcmRlcilcbn1cblxuZnVuY3Rpb24gYXJyYXlEVHlwZShkYXRhKSB7XG4gIGlmKGhhc0J1ZmZlcikge1xuICAgIGlmKEJ1ZmZlci5pc0J1ZmZlcihkYXRhKSkge1xuICAgICAgcmV0dXJuIFwiYnVmZmVyXCJcbiAgICB9XG4gIH1cbiAgaWYoaGFzVHlwZWRBcnJheXMpIHtcbiAgICBzd2l0Y2goT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGRhdGEpKSB7XG4gICAgICBjYXNlIFwiW29iamVjdCBGbG9hdDY0QXJyYXldXCI6XG4gICAgICAgIHJldHVybiBcImZsb2F0NjRcIlxuICAgICAgY2FzZSBcIltvYmplY3QgRmxvYXQzMkFycmF5XVwiOlxuICAgICAgICByZXR1cm4gXCJmbG9hdDMyXCJcbiAgICAgIGNhc2UgXCJbb2JqZWN0IEludDhBcnJheV1cIjpcbiAgICAgICAgcmV0dXJuIFwiaW50OFwiXG4gICAgICBjYXNlIFwiW29iamVjdCBJbnQxNkFycmF5XVwiOlxuICAgICAgICByZXR1cm4gXCJpbnQxNlwiXG4gICAgICBjYXNlIFwiW29iamVjdCBJbnQzMkFycmF5XVwiOlxuICAgICAgICByZXR1cm4gXCJpbnQzMlwiXG4gICAgICBjYXNlIFwiW29iamVjdCBVaW50OEFycmF5XVwiOlxuICAgICAgICByZXR1cm4gXCJ1aW50OFwiXG4gICAgICBjYXNlIFwiW29iamVjdCBVaW50MTZBcnJheV1cIjpcbiAgICAgICAgcmV0dXJuIFwidWludDE2XCJcbiAgICAgIGNhc2UgXCJbb2JqZWN0IFVpbnQzMkFycmF5XVwiOlxuICAgICAgICByZXR1cm4gXCJ1aW50MzJcIlxuICAgICAgY2FzZSBcIltvYmplY3QgVWludDhDbGFtcGVkQXJyYXldXCI6XG4gICAgICAgIHJldHVybiBcInVpbnQ4X2NsYW1wZWRcIlxuICAgIH1cbiAgfVxuICBpZihBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgcmV0dXJuIFwiYXJyYXlcIlxuICB9XG4gIHJldHVybiBcImdlbmVyaWNcIlxufVxuXG52YXIgQ0FDSEVEX0NPTlNUUlVDVE9SUyA9IHtcbiAgXCJmbG9hdDMyXCI6W10sXG4gIFwiZmxvYXQ2NFwiOltdLFxuICBcImludDhcIjpbXSxcbiAgXCJpbnQxNlwiOltdLFxuICBcImludDMyXCI6W10sXG4gIFwidWludDhcIjpbXSxcbiAgXCJ1aW50MTZcIjpbXSxcbiAgXCJ1aW50MzJcIjpbXSxcbiAgXCJhcnJheVwiOltdLFxuICBcInVpbnQ4X2NsYW1wZWRcIjpbXSxcbiAgXCJidWZmZXJcIjpbXSxcbiAgXCJnZW5lcmljXCI6W11cbn1cblxuOyhmdW5jdGlvbigpIHtcbiAgZm9yKHZhciBpZCBpbiBDQUNIRURfQ09OU1RSVUNUT1JTKSB7XG4gICAgQ0FDSEVEX0NPTlNUUlVDVE9SU1tpZF0ucHVzaChjb21waWxlQ29uc3RydWN0b3IoaWQsIC0xKSlcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIHdyYXBwZWROREFycmF5Q3RvcihkYXRhLCBzaGFwZSwgc3RyaWRlLCBvZmZzZXQpIHtcbiAgaWYoZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIGN0b3IgPSBDQUNIRURfQ09OU1RSVUNUT1JTLmFycmF5WzBdXG4gICAgcmV0dXJuIGN0b3IoW10pXG4gIH0gZWxzZSBpZih0eXBlb2YgZGF0YSA9PT0gXCJudW1iZXJcIikge1xuICAgIGRhdGEgPSBbZGF0YV1cbiAgfVxuICBpZihzaGFwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc2hhcGUgPSBbIGRhdGEubGVuZ3RoIF1cbiAgfVxuICB2YXIgZCA9IHNoYXBlLmxlbmd0aFxuICBpZihzdHJpZGUgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0cmlkZSA9IG5ldyBBcnJheShkKVxuICAgIGZvcih2YXIgaT1kLTEsIHN6PTE7IGk+PTA7IC0taSkge1xuICAgICAgc3RyaWRlW2ldID0gc3pcbiAgICAgIHN6ICo9IHNoYXBlW2ldXG4gICAgfVxuICB9XG4gIGlmKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgb2Zmc2V0ID0gMFxuICAgIGZvcih2YXIgaT0wOyBpPGQ7ICsraSkge1xuICAgICAgaWYoc3RyaWRlW2ldIDwgMCkge1xuICAgICAgICBvZmZzZXQgLT0gKHNoYXBlW2ldLTEpKnN0cmlkZVtpXVxuICAgICAgfVxuICAgIH1cbiAgfVxuICB2YXIgZHR5cGUgPSBhcnJheURUeXBlKGRhdGEpXG4gIHZhciBjdG9yX2xpc3QgPSBDQUNIRURfQ09OU1RSVUNUT1JTW2R0eXBlXVxuICB3aGlsZShjdG9yX2xpc3QubGVuZ3RoIDw9IGQrMSkge1xuICAgIGN0b3JfbGlzdC5wdXNoKGNvbXBpbGVDb25zdHJ1Y3RvcihkdHlwZSwgY3Rvcl9saXN0Lmxlbmd0aC0xKSlcbiAgfVxuICB2YXIgY3RvciA9IGN0b3JfbGlzdFtkKzFdXG4gIHJldHVybiBjdG9yKGRhdGEsIHNoYXBlLCBzdHJpZGUsIG9mZnNldClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB3cmFwcGVkTkRBcnJheUN0b3Jcbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcikiLCJcInVzZSBzdHJpY3RcIlxuXG5mdW5jdGlvbiBpb3RhKG4pIHtcbiAgdmFyIHJlc3VsdCA9IG5ldyBBcnJheShuKVxuICBmb3IodmFyIGk9MDsgaTxuOyArK2kpIHtcbiAgICByZXN1bHRbaV0gPSBpXG4gIH1cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlvdGEiLCIvKipcbiAqIEJpdCB0d2lkZGxpbmcgaGFja3MgZm9yIEphdmFTY3JpcHQuXG4gKlxuICogQXV0aG9yOiBNaWtvbGEgTHlzZW5rb1xuICpcbiAqIFBvcnRlZCBmcm9tIFN0YW5mb3JkIGJpdCB0d2lkZGxpbmcgaGFjayBsaWJyYXJ5OlxuICogICAgaHR0cDovL2dyYXBoaWNzLnN0YW5mb3JkLmVkdS9+c2VhbmRlci9iaXRoYWNrcy5odG1sXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7IFwidXNlIHJlc3RyaWN0XCI7XG5cbi8vTnVtYmVyIG9mIGJpdHMgaW4gYW4gaW50ZWdlclxudmFyIElOVF9CSVRTID0gMzI7XG5cbi8vQ29uc3RhbnRzXG5leHBvcnRzLklOVF9CSVRTICA9IElOVF9CSVRTO1xuZXhwb3J0cy5JTlRfTUFYICAgPSAgMHg3ZmZmZmZmZjtcbmV4cG9ydHMuSU5UX01JTiAgID0gLTE8PChJTlRfQklUUy0xKTtcblxuLy9SZXR1cm5zIC0xLCAwLCArMSBkZXBlbmRpbmcgb24gc2lnbiBvZiB4XG5leHBvcnRzLnNpZ24gPSBmdW5jdGlvbih2KSB7XG4gIHJldHVybiAodiA+IDApIC0gKHYgPCAwKTtcbn1cblxuLy9Db21wdXRlcyBhYnNvbHV0ZSB2YWx1ZSBvZiBpbnRlZ2VyXG5leHBvcnRzLmFicyA9IGZ1bmN0aW9uKHYpIHtcbiAgdmFyIG1hc2sgPSB2ID4+IChJTlRfQklUUy0xKTtcbiAgcmV0dXJuICh2IF4gbWFzaykgLSBtYXNrO1xufVxuXG4vL0NvbXB1dGVzIG1pbmltdW0gb2YgaW50ZWdlcnMgeCBhbmQgeVxuZXhwb3J0cy5taW4gPSBmdW5jdGlvbih4LCB5KSB7XG4gIHJldHVybiB5IF4gKCh4IF4geSkgJiAtKHggPCB5KSk7XG59XG5cbi8vQ29tcHV0ZXMgbWF4aW11bSBvZiBpbnRlZ2VycyB4IGFuZCB5XG5leHBvcnRzLm1heCA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgcmV0dXJuIHggXiAoKHggXiB5KSAmIC0oeCA8IHkpKTtcbn1cblxuLy9DaGVja3MgaWYgYSBudW1iZXIgaXMgYSBwb3dlciBvZiB0d29cbmV4cG9ydHMuaXNQb3cyID0gZnVuY3Rpb24odikge1xuICByZXR1cm4gISh2ICYgKHYtMSkpICYmICghIXYpO1xufVxuXG4vL0NvbXB1dGVzIGxvZyBiYXNlIDIgb2YgdlxuZXhwb3J0cy5sb2cyID0gZnVuY3Rpb24odikge1xuICB2YXIgciwgc2hpZnQ7XG4gIHIgPSAgICAgKHYgPiAweEZGRkYpIDw8IDQ7IHYgPj4+PSByO1xuICBzaGlmdCA9ICh2ID4gMHhGRiAgKSA8PCAzOyB2ID4+Pj0gc2hpZnQ7IHIgfD0gc2hpZnQ7XG4gIHNoaWZ0ID0gKHYgPiAweEYgICApIDw8IDI7IHYgPj4+PSBzaGlmdDsgciB8PSBzaGlmdDtcbiAgc2hpZnQgPSAodiA+IDB4MyAgICkgPDwgMTsgdiA+Pj49IHNoaWZ0OyByIHw9IHNoaWZ0O1xuICByZXR1cm4gciB8ICh2ID4+IDEpO1xufVxuXG4vL0NvbXB1dGVzIGxvZyBiYXNlIDEwIG9mIHZcbmV4cG9ydHMubG9nMTAgPSBmdW5jdGlvbih2KSB7XG4gIHJldHVybiAgKHYgPj0gMTAwMDAwMDAwMCkgPyA5IDogKHYgPj0gMTAwMDAwMDAwKSA/IDggOiAodiA+PSAxMDAwMDAwMCkgPyA3IDpcbiAgICAgICAgICAodiA+PSAxMDAwMDAwKSA/IDYgOiAodiA+PSAxMDAwMDApID8gNSA6ICh2ID49IDEwMDAwKSA/IDQgOlxuICAgICAgICAgICh2ID49IDEwMDApID8gMyA6ICh2ID49IDEwMCkgPyAyIDogKHYgPj0gMTApID8gMSA6IDA7XG59XG5cbi8vQ291bnRzIG51bWJlciBvZiBiaXRzXG5leHBvcnRzLnBvcENvdW50ID0gZnVuY3Rpb24odikge1xuICB2ID0gdiAtICgodiA+Pj4gMSkgJiAweDU1NTU1NTU1KTtcbiAgdiA9ICh2ICYgMHgzMzMzMzMzMykgKyAoKHYgPj4+IDIpICYgMHgzMzMzMzMzMyk7XG4gIHJldHVybiAoKHYgKyAodiA+Pj4gNCkgJiAweEYwRjBGMEYpICogMHgxMDEwMTAxKSA+Pj4gMjQ7XG59XG5cbi8vQ291bnRzIG51bWJlciBvZiB0cmFpbGluZyB6ZXJvc1xuZnVuY3Rpb24gY291bnRUcmFpbGluZ1plcm9zKHYpIHtcbiAgdmFyIGMgPSAzMjtcbiAgdiAmPSAtdjtcbiAgaWYgKHYpIGMtLTtcbiAgaWYgKHYgJiAweDAwMDBGRkZGKSBjIC09IDE2O1xuICBpZiAodiAmIDB4MDBGRjAwRkYpIGMgLT0gODtcbiAgaWYgKHYgJiAweDBGMEYwRjBGKSBjIC09IDQ7XG4gIGlmICh2ICYgMHgzMzMzMzMzMykgYyAtPSAyO1xuICBpZiAodiAmIDB4NTU1NTU1NTUpIGMgLT0gMTtcbiAgcmV0dXJuIGM7XG59XG5leHBvcnRzLmNvdW50VHJhaWxpbmdaZXJvcyA9IGNvdW50VHJhaWxpbmdaZXJvcztcblxuLy9Sb3VuZHMgdG8gbmV4dCBwb3dlciBvZiAyXG5leHBvcnRzLm5leHRQb3cyID0gZnVuY3Rpb24odikge1xuICB2ICs9IHYgPT09IDA7XG4gIC0tdjtcbiAgdiB8PSB2ID4+PiAxO1xuICB2IHw9IHYgPj4+IDI7XG4gIHYgfD0gdiA+Pj4gNDtcbiAgdiB8PSB2ID4+PiA4O1xuICB2IHw9IHYgPj4+IDE2O1xuICByZXR1cm4gdiArIDE7XG59XG5cbi8vUm91bmRzIGRvd24gdG8gcHJldmlvdXMgcG93ZXIgb2YgMlxuZXhwb3J0cy5wcmV2UG93MiA9IGZ1bmN0aW9uKHYpIHtcbiAgdiB8PSB2ID4+PiAxO1xuICB2IHw9IHYgPj4+IDI7XG4gIHYgfD0gdiA+Pj4gNDtcbiAgdiB8PSB2ID4+PiA4O1xuICB2IHw9IHYgPj4+IDE2O1xuICByZXR1cm4gdiAtICh2Pj4+MSk7XG59XG5cbi8vQ29tcHV0ZXMgcGFyaXR5IG9mIHdvcmRcbmV4cG9ydHMucGFyaXR5ID0gZnVuY3Rpb24odikge1xuICB2IF49IHYgPj4+IDE2O1xuICB2IF49IHYgPj4+IDg7XG4gIHYgXj0gdiA+Pj4gNDtcbiAgdiAmPSAweGY7XG4gIHJldHVybiAoMHg2OTk2ID4+PiB2KSAmIDE7XG59XG5cbnZhciBSRVZFUlNFX1RBQkxFID0gbmV3IEFycmF5KDI1Nik7XG5cbihmdW5jdGlvbih0YWIpIHtcbiAgZm9yKHZhciBpPTA7IGk8MjU2OyArK2kpIHtcbiAgICB2YXIgdiA9IGksIHIgPSBpLCBzID0gNztcbiAgICBmb3IgKHYgPj4+PSAxOyB2OyB2ID4+Pj0gMSkge1xuICAgICAgciA8PD0gMTtcbiAgICAgIHIgfD0gdiAmIDE7XG4gICAgICAtLXM7XG4gICAgfVxuICAgIHRhYltpXSA9IChyIDw8IHMpICYgMHhmZjtcbiAgfVxufSkoUkVWRVJTRV9UQUJMRSk7XG5cbi8vUmV2ZXJzZSBiaXRzIGluIGEgMzIgYml0IHdvcmRcbmV4cG9ydHMucmV2ZXJzZSA9IGZ1bmN0aW9uKHYpIHtcbiAgcmV0dXJuICAoUkVWRVJTRV9UQUJMRVsgdiAgICAgICAgICYgMHhmZl0gPDwgMjQpIHxcbiAgICAgICAgICAoUkVWRVJTRV9UQUJMRVsodiA+Pj4gOCkgICYgMHhmZl0gPDwgMTYpIHxcbiAgICAgICAgICAoUkVWRVJTRV9UQUJMRVsodiA+Pj4gMTYpICYgMHhmZl0gPDwgOCkgIHxcbiAgICAgICAgICAgUkVWRVJTRV9UQUJMRVsodiA+Pj4gMjQpICYgMHhmZl07XG59XG5cbi8vSW50ZXJsZWF2ZSBiaXRzIG9mIDIgY29vcmRpbmF0ZXMgd2l0aCAxNiBiaXRzLiAgVXNlZnVsIGZvciBmYXN0IHF1YWR0cmVlIGNvZGVzXG5leHBvcnRzLmludGVybGVhdmUyID0gZnVuY3Rpb24oeCwgeSkge1xuICB4ICY9IDB4RkZGRjtcbiAgeCA9ICh4IHwgKHggPDwgOCkpICYgMHgwMEZGMDBGRjtcbiAgeCA9ICh4IHwgKHggPDwgNCkpICYgMHgwRjBGMEYwRjtcbiAgeCA9ICh4IHwgKHggPDwgMikpICYgMHgzMzMzMzMzMztcbiAgeCA9ICh4IHwgKHggPDwgMSkpICYgMHg1NTU1NTU1NTtcblxuICB5ICY9IDB4RkZGRjtcbiAgeSA9ICh5IHwgKHkgPDwgOCkpICYgMHgwMEZGMDBGRjtcbiAgeSA9ICh5IHwgKHkgPDwgNCkpICYgMHgwRjBGMEYwRjtcbiAgeSA9ICh5IHwgKHkgPDwgMikpICYgMHgzMzMzMzMzMztcbiAgeSA9ICh5IHwgKHkgPDwgMSkpICYgMHg1NTU1NTU1NTtcblxuICByZXR1cm4geCB8ICh5IDw8IDEpO1xufVxuXG4vL0V4dHJhY3RzIHRoZSBudGggaW50ZXJsZWF2ZWQgY29tcG9uZW50XG5leHBvcnRzLmRlaW50ZXJsZWF2ZTIgPSBmdW5jdGlvbih2LCBuKSB7XG4gIHYgPSAodiA+Pj4gbikgJiAweDU1NTU1NTU1O1xuICB2ID0gKHYgfCAodiA+Pj4gMSkpICAmIDB4MzMzMzMzMzM7XG4gIHYgPSAodiB8ICh2ID4+PiAyKSkgICYgMHgwRjBGMEYwRjtcbiAgdiA9ICh2IHwgKHYgPj4+IDQpKSAgJiAweDAwRkYwMEZGO1xuICB2ID0gKHYgfCAodiA+Pj4gMTYpKSAmIDB4MDAwRkZGRjtcbiAgcmV0dXJuICh2IDw8IDE2KSA+PiAxNjtcbn1cblxuXG4vL0ludGVybGVhdmUgYml0cyBvZiAzIGNvb3JkaW5hdGVzLCBlYWNoIHdpdGggMTAgYml0cy4gIFVzZWZ1bCBmb3IgZmFzdCBvY3RyZWUgY29kZXNcbmV4cG9ydHMuaW50ZXJsZWF2ZTMgPSBmdW5jdGlvbih4LCB5LCB6KSB7XG4gIHggJj0gMHgzRkY7XG4gIHggID0gKHggfCAoeDw8MTYpKSAmIDQyNzgxOTAzMzU7XG4gIHggID0gKHggfCAoeDw8OCkpICAmIDI1MTcxOTY5NTtcbiAgeCAgPSAoeCB8ICh4PDw0KSkgICYgMzI3MjM1NjAzNTtcbiAgeCAgPSAoeCB8ICh4PDwyKSkgICYgMTIyNzEzMzUxMztcblxuICB5ICY9IDB4M0ZGO1xuICB5ICA9ICh5IHwgKHk8PDE2KSkgJiA0Mjc4MTkwMzM1O1xuICB5ICA9ICh5IHwgKHk8PDgpKSAgJiAyNTE3MTk2OTU7XG4gIHkgID0gKHkgfCAoeTw8NCkpICAmIDMyNzIzNTYwMzU7XG4gIHkgID0gKHkgfCAoeTw8MikpICAmIDEyMjcxMzM1MTM7XG4gIHggfD0gKHkgPDwgMSk7XG4gIFxuICB6ICY9IDB4M0ZGO1xuICB6ICA9ICh6IHwgKHo8PDE2KSkgJiA0Mjc4MTkwMzM1O1xuICB6ICA9ICh6IHwgKHo8PDgpKSAgJiAyNTE3MTk2OTU7XG4gIHogID0gKHogfCAoejw8NCkpICAmIDMyNzIzNTYwMzU7XG4gIHogID0gKHogfCAoejw8MikpICAmIDEyMjcxMzM1MTM7XG4gIFxuICByZXR1cm4geCB8ICh6IDw8IDIpO1xufVxuXG4vL0V4dHJhY3RzIG50aCBpbnRlcmxlYXZlZCBjb21wb25lbnQgb2YgYSAzLXR1cGxlXG5leHBvcnRzLmRlaW50ZXJsZWF2ZTMgPSBmdW5jdGlvbih2LCBuKSB7XG4gIHYgPSAodiA+Pj4gbikgICAgICAgJiAxMjI3MTMzNTEzO1xuICB2ID0gKHYgfCAodj4+PjIpKSAgICYgMzI3MjM1NjAzNTtcbiAgdiA9ICh2IHwgKHY+Pj40KSkgICAmIDI1MTcxOTY5NTtcbiAgdiA9ICh2IHwgKHY+Pj44KSkgICAmIDQyNzgxOTAzMzU7XG4gIHYgPSAodiB8ICh2Pj4+MTYpKSAgJiAweDNGRjtcbiAgcmV0dXJuICh2PDwyMik+PjIyO1xufVxuXG4vL0NvbXB1dGVzIG5leHQgY29tYmluYXRpb24gaW4gY29sZXhpY29ncmFwaGljIG9yZGVyICh0aGlzIGlzIG1pc3Rha2VubHkgY2FsbGVkIG5leHRQZXJtdXRhdGlvbiBvbiB0aGUgYml0IHR3aWRkbGluZyBoYWNrcyBwYWdlKVxuZXhwb3J0cy5uZXh0Q29tYmluYXRpb24gPSBmdW5jdGlvbih2KSB7XG4gIHZhciB0ID0gdiB8ICh2IC0gMSk7XG4gIHJldHVybiAodCArIDEpIHwgKCgofnQgJiAtfnQpIC0gMSkgPj4+IChjb3VudFRyYWlsaW5nWmVyb3ModikgKyAxKSk7XG59XG5cbiIsIlwidXNlIHN0cmljdFwiXG5cbmZ1bmN0aW9uIGR1cGVfYXJyYXkoY291bnQsIHZhbHVlLCBpKSB7XG4gIHZhciBjID0gY291bnRbaV18MFxuICBpZihjIDw9IDApIHtcbiAgICByZXR1cm4gW11cbiAgfVxuICB2YXIgcmVzdWx0ID0gbmV3IEFycmF5KGMpLCBqXG4gIGlmKGkgPT09IGNvdW50Lmxlbmd0aC0xKSB7XG4gICAgZm9yKGo9MDsgajxjOyArK2opIHtcbiAgICAgIHJlc3VsdFtqXSA9IHZhbHVlXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvcihqPTA7IGo8YzsgKytqKSB7XG4gICAgICByZXN1bHRbal0gPSBkdXBlX2FycmF5KGNvdW50LCB2YWx1ZSwgaSsxKVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0XG59XG5cbmZ1bmN0aW9uIGR1cGVfbnVtYmVyKGNvdW50LCB2YWx1ZSkge1xuICB2YXIgcmVzdWx0LCBpXG4gIHJlc3VsdCA9IG5ldyBBcnJheShjb3VudClcbiAgZm9yKGk9MDsgaTxjb3VudDsgKytpKSB7XG4gICAgcmVzdWx0W2ldID0gdmFsdWVcbiAgfVxuICByZXR1cm4gcmVzdWx0XG59XG5cbmZ1bmN0aW9uIGR1cGUoY291bnQsIHZhbHVlKSB7XG4gIGlmKHR5cGVvZiB2YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHZhbHVlID0gMFxuICB9XG4gIHN3aXRjaCh0eXBlb2YgY291bnQpIHtcbiAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICBpZihjb3VudCA+IDApIHtcbiAgICAgICAgcmV0dXJuIGR1cGVfbnVtYmVyKGNvdW50fDAsIHZhbHVlKVxuICAgICAgfVxuICAgIGJyZWFrXG4gICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgaWYodHlwZW9mIChjb3VudC5sZW5ndGgpID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHJldHVybiBkdXBlX2FycmF5KGNvdW50LCB2YWx1ZSwgMClcbiAgICAgIH1cbiAgICBicmVha1xuICB9XG4gIHJldHVybiBbXVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGR1cGUiLCIoZnVuY3Rpb24gKGdsb2JhbCxCdWZmZXIpe1xuJ3VzZSBzdHJpY3QnXG5cbnZhciBiaXRzID0gcmVxdWlyZSgnYml0LXR3aWRkbGUnKVxudmFyIGR1cCA9IHJlcXVpcmUoJ2R1cCcpXG5cbi8vTGVnYWN5IHBvb2wgc3VwcG9ydFxuaWYoIWdsb2JhbC5fX1RZUEVEQVJSQVlfUE9PTCkge1xuICBnbG9iYWwuX19UWVBFREFSUkFZX1BPT0wgPSB7XG4gICAgICBVSU5UOCAgIDogZHVwKFszMiwgMF0pXG4gICAgLCBVSU5UMTYgIDogZHVwKFszMiwgMF0pXG4gICAgLCBVSU5UMzIgIDogZHVwKFszMiwgMF0pXG4gICAgLCBJTlQ4ICAgIDogZHVwKFszMiwgMF0pXG4gICAgLCBJTlQxNiAgIDogZHVwKFszMiwgMF0pXG4gICAgLCBJTlQzMiAgIDogZHVwKFszMiwgMF0pXG4gICAgLCBGTE9BVCAgIDogZHVwKFszMiwgMF0pXG4gICAgLCBET1VCTEUgIDogZHVwKFszMiwgMF0pXG4gICAgLCBEQVRBICAgIDogZHVwKFszMiwgMF0pXG4gICAgLCBVSU5UOEMgIDogZHVwKFszMiwgMF0pXG4gICAgLCBCVUZGRVIgIDogZHVwKFszMiwgMF0pXG4gIH1cbn1cblxudmFyIGhhc1VpbnQ4QyA9ICh0eXBlb2YgVWludDhDbGFtcGVkQXJyYXkpICE9PSAndW5kZWZpbmVkJ1xudmFyIFBPT0wgPSBnbG9iYWwuX19UWVBFREFSUkFZX1BPT0xcblxuLy9VcGdyYWRlIHBvb2xcbmlmKCFQT09MLlVJTlQ4Qykge1xuICBQT09MLlVJTlQ4QyA9IGR1cChbMzIsIDBdKVxufVxuaWYoIVBPT0wuQlVGRkVSKSB7XG4gIFBPT0wuQlVGRkVSID0gZHVwKFszMiwgMF0pXG59XG5cbi8vTmV3IHRlY2huaXF1ZTogT25seSBhbGxvY2F0ZSBmcm9tIEFycmF5QnVmZmVyVmlldyBhbmQgQnVmZmVyXG52YXIgREFUQSAgICA9IFBPT0wuREFUQVxuICAsIEJVRkZFUiAgPSBQT09MLkJVRkZFUlxuXG5leHBvcnRzLmZyZWUgPSBmdW5jdGlvbiBmcmVlKGFycmF5KSB7XG4gIGlmKEJ1ZmZlci5pc0J1ZmZlcihhcnJheSkpIHtcbiAgICBCVUZGRVJbYml0cy5sb2cyKGFycmF5Lmxlbmd0aCldLnB1c2goYXJyYXkpXG4gIH0gZWxzZSB7XG4gICAgaWYoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFycmF5KSAhPT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJykge1xuICAgICAgYXJyYXkgPSBhcnJheS5idWZmZXJcbiAgICB9XG4gICAgaWYoIWFycmF5KSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgdmFyIG4gPSBhcnJheS5sZW5ndGggfHwgYXJyYXkuYnl0ZUxlbmd0aFxuICAgIHZhciBsb2dfbiA9IGJpdHMubG9nMihuKXwwXG4gICAgREFUQVtsb2dfbl0ucHVzaChhcnJheSlcbiAgfVxufVxuXG5mdW5jdGlvbiBmcmVlQXJyYXlCdWZmZXIoYnVmZmVyKSB7XG4gIGlmKCFidWZmZXIpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgbiA9IGJ1ZmZlci5sZW5ndGggfHwgYnVmZmVyLmJ5dGVMZW5ndGhcbiAgdmFyIGxvZ19uID0gYml0cy5sb2cyKG4pXG4gIERBVEFbbG9nX25dLnB1c2goYnVmZmVyKVxufVxuXG5mdW5jdGlvbiBmcmVlVHlwZWRBcnJheShhcnJheSkge1xuICBmcmVlQXJyYXlCdWZmZXIoYXJyYXkuYnVmZmVyKVxufVxuXG5leHBvcnRzLmZyZWVVaW50OCA9XG5leHBvcnRzLmZyZWVVaW50MTYgPVxuZXhwb3J0cy5mcmVlVWludDMyID1cbmV4cG9ydHMuZnJlZUludDggPVxuZXhwb3J0cy5mcmVlSW50MTYgPVxuZXhwb3J0cy5mcmVlSW50MzIgPVxuZXhwb3J0cy5mcmVlRmxvYXQzMiA9IFxuZXhwb3J0cy5mcmVlRmxvYXQgPVxuZXhwb3J0cy5mcmVlRmxvYXQ2NCA9IFxuZXhwb3J0cy5mcmVlRG91YmxlID0gXG5leHBvcnRzLmZyZWVVaW50OENsYW1wZWQgPSBcbmV4cG9ydHMuZnJlZURhdGFWaWV3ID0gZnJlZVR5cGVkQXJyYXlcblxuZXhwb3J0cy5mcmVlQXJyYXlCdWZmZXIgPSBmcmVlQXJyYXlCdWZmZXJcblxuZXhwb3J0cy5mcmVlQnVmZmVyID0gZnVuY3Rpb24gZnJlZUJ1ZmZlcihhcnJheSkge1xuICBCVUZGRVJbYml0cy5sb2cyKGFycmF5Lmxlbmd0aCldLnB1c2goYXJyYXkpXG59XG5cbmV4cG9ydHMubWFsbG9jID0gZnVuY3Rpb24gbWFsbG9jKG4sIGR0eXBlKSB7XG4gIGlmKGR0eXBlID09PSB1bmRlZmluZWQgfHwgZHR5cGUgPT09ICdhcnJheWJ1ZmZlcicpIHtcbiAgICByZXR1cm4gbWFsbG9jQXJyYXlCdWZmZXIobilcbiAgfSBlbHNlIHtcbiAgICBzd2l0Y2goZHR5cGUpIHtcbiAgICAgIGNhc2UgJ3VpbnQ4JzpcbiAgICAgICAgcmV0dXJuIG1hbGxvY1VpbnQ4KG4pXG4gICAgICBjYXNlICd1aW50MTYnOlxuICAgICAgICByZXR1cm4gbWFsbG9jVWludDE2KG4pXG4gICAgICBjYXNlICd1aW50MzInOlxuICAgICAgICByZXR1cm4gbWFsbG9jVWludDMyKG4pXG4gICAgICBjYXNlICdpbnQ4JzpcbiAgICAgICAgcmV0dXJuIG1hbGxvY0ludDgobilcbiAgICAgIGNhc2UgJ2ludDE2JzpcbiAgICAgICAgcmV0dXJuIG1hbGxvY0ludDE2KG4pXG4gICAgICBjYXNlICdpbnQzMic6XG4gICAgICAgIHJldHVybiBtYWxsb2NJbnQzMihuKVxuICAgICAgY2FzZSAnZmxvYXQnOlxuICAgICAgY2FzZSAnZmxvYXQzMic6XG4gICAgICAgIHJldHVybiBtYWxsb2NGbG9hdChuKVxuICAgICAgY2FzZSAnZG91YmxlJzpcbiAgICAgIGNhc2UgJ2Zsb2F0NjQnOlxuICAgICAgICByZXR1cm4gbWFsbG9jRG91YmxlKG4pXG4gICAgICBjYXNlICd1aW50OF9jbGFtcGVkJzpcbiAgICAgICAgcmV0dXJuIG1hbGxvY1VpbnQ4Q2xhbXBlZChuKVxuICAgICAgY2FzZSAnYnVmZmVyJzpcbiAgICAgICAgcmV0dXJuIG1hbGxvY0J1ZmZlcihuKVxuICAgICAgY2FzZSAnZGF0YSc6XG4gICAgICBjYXNlICdkYXRhdmlldyc6XG4gICAgICAgIHJldHVybiBtYWxsb2NEYXRhVmlldyhuKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbFxufVxuXG5mdW5jdGlvbiBtYWxsb2NBcnJheUJ1ZmZlcihuKSB7XG4gIHZhciBuID0gYml0cy5uZXh0UG93MihuKVxuICB2YXIgbG9nX24gPSBiaXRzLmxvZzIobilcbiAgdmFyIGQgPSBEQVRBW2xvZ19uXVxuICBpZihkLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gZC5wb3AoKVxuICB9XG4gIHJldHVybiBuZXcgQXJyYXlCdWZmZXIobilcbn1cbmV4cG9ydHMubWFsbG9jQXJyYXlCdWZmZXIgPSBtYWxsb2NBcnJheUJ1ZmZlclxuXG5mdW5jdGlvbiBtYWxsb2NVaW50OChuKSB7XG4gIHJldHVybiBuZXcgVWludDhBcnJheShtYWxsb2NBcnJheUJ1ZmZlcihuKSwgMCwgbilcbn1cbmV4cG9ydHMubWFsbG9jVWludDggPSBtYWxsb2NVaW50OFxuXG5mdW5jdGlvbiBtYWxsb2NVaW50MTYobikge1xuICByZXR1cm4gbmV3IFVpbnQxNkFycmF5KG1hbGxvY0FycmF5QnVmZmVyKDIqbiksIDAsIG4pXG59XG5leHBvcnRzLm1hbGxvY1VpbnQxNiA9IG1hbGxvY1VpbnQxNlxuXG5mdW5jdGlvbiBtYWxsb2NVaW50MzIobikge1xuICByZXR1cm4gbmV3IFVpbnQzMkFycmF5KG1hbGxvY0FycmF5QnVmZmVyKDQqbiksIDAsIG4pXG59XG5leHBvcnRzLm1hbGxvY1VpbnQzMiA9IG1hbGxvY1VpbnQzMlxuXG5mdW5jdGlvbiBtYWxsb2NJbnQ4KG4pIHtcbiAgcmV0dXJuIG5ldyBJbnQ4QXJyYXkobWFsbG9jQXJyYXlCdWZmZXIobiksIDAsIG4pXG59XG5leHBvcnRzLm1hbGxvY0ludDggPSBtYWxsb2NJbnQ4XG5cbmZ1bmN0aW9uIG1hbGxvY0ludDE2KG4pIHtcbiAgcmV0dXJuIG5ldyBJbnQxNkFycmF5KG1hbGxvY0FycmF5QnVmZmVyKDIqbiksIDAsIG4pXG59XG5leHBvcnRzLm1hbGxvY0ludDE2ID0gbWFsbG9jSW50MTZcblxuZnVuY3Rpb24gbWFsbG9jSW50MzIobikge1xuICByZXR1cm4gbmV3IEludDMyQXJyYXkobWFsbG9jQXJyYXlCdWZmZXIoNCpuKSwgMCwgbilcbn1cbmV4cG9ydHMubWFsbG9jSW50MzIgPSBtYWxsb2NJbnQzMlxuXG5mdW5jdGlvbiBtYWxsb2NGbG9hdChuKSB7XG4gIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KG1hbGxvY0FycmF5QnVmZmVyKDQqbiksIDAsIG4pXG59XG5leHBvcnRzLm1hbGxvY0Zsb2F0MzIgPSBleHBvcnRzLm1hbGxvY0Zsb2F0ID0gbWFsbG9jRmxvYXRcblxuZnVuY3Rpb24gbWFsbG9jRG91YmxlKG4pIHtcbiAgcmV0dXJuIG5ldyBGbG9hdDY0QXJyYXkobWFsbG9jQXJyYXlCdWZmZXIoOCpuKSwgMCwgbilcbn1cbmV4cG9ydHMubWFsbG9jRmxvYXQ2NCA9IGV4cG9ydHMubWFsbG9jRG91YmxlID0gbWFsbG9jRG91YmxlXG5cbmZ1bmN0aW9uIG1hbGxvY1VpbnQ4Q2xhbXBlZChuKSB7XG4gIGlmKGhhc1VpbnQ4Qykge1xuICAgIHJldHVybiBuZXcgVWludDhDbGFtcGVkQXJyYXkobWFsbG9jQXJyYXlCdWZmZXIobiksIDAsIG4pXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG1hbGxvY1VpbnQ4KG4pXG4gIH1cbn1cbmV4cG9ydHMubWFsbG9jVWludDhDbGFtcGVkID0gbWFsbG9jVWludDhDbGFtcGVkXG5cbmZ1bmN0aW9uIG1hbGxvY0RhdGFWaWV3KG4pIHtcbiAgcmV0dXJuIG5ldyBEYXRhVmlldyhtYWxsb2NBcnJheUJ1ZmZlcihuKSwgMCwgbilcbn1cbmV4cG9ydHMubWFsbG9jRGF0YVZpZXcgPSBtYWxsb2NEYXRhVmlld1xuXG5mdW5jdGlvbiBtYWxsb2NCdWZmZXIobikge1xuICBuID0gYml0cy5uZXh0UG93MihuKVxuICB2YXIgbG9nX24gPSBiaXRzLmxvZzIobilcbiAgdmFyIGNhY2hlID0gQlVGRkVSW2xvZ19uXVxuICBpZihjYWNoZS5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIGNhY2hlLnBvcCgpXG4gIH1cbiAgcmV0dXJuIG5ldyBCdWZmZXIobilcbn1cbmV4cG9ydHMubWFsbG9jQnVmZmVyID0gbWFsbG9jQnVmZmVyXG5cbmV4cG9ydHMuY2xlYXJDYWNoZSA9IGZ1bmN0aW9uIGNsZWFyQ2FjaGUoKSB7XG4gIGZvcih2YXIgaT0wOyBpPDMyOyArK2kpIHtcbiAgICBQT09MLlVJTlQ4W2ldLmxlbmd0aCA9IDBcbiAgICBQT09MLlVJTlQxNltpXS5sZW5ndGggPSAwXG4gICAgUE9PTC5VSU5UMzJbaV0ubGVuZ3RoID0gMFxuICAgIFBPT0wuSU5UOFtpXS5sZW5ndGggPSAwXG4gICAgUE9PTC5JTlQxNltpXS5sZW5ndGggPSAwXG4gICAgUE9PTC5JTlQzMltpXS5sZW5ndGggPSAwXG4gICAgUE9PTC5GTE9BVFtpXS5sZW5ndGggPSAwXG4gICAgUE9PTC5ET1VCTEVbaV0ubGVuZ3RoID0gMFxuICAgIFBPT0wuVUlOVDhDW2ldLmxlbmd0aCA9IDBcbiAgICBEQVRBW2ldLmxlbmd0aCA9IDBcbiAgICBCVUZGRVJbaV0ubGVuZ3RoID0gMFxuICB9XG59XG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcikiLCIvKiAoVGhlIE1JVCBMaWNlbnNlKVxyXG4gKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTIgQnJhbmRvbiBCZW52aWUgPGh0dHA6Ly9iYmVudmllLmNvbT5cclxuICpcclxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZFxyXG4gKiBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSAnU29mdHdhcmUnKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcclxuICogaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSxcclxuICogc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXHJcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XHJcbiAqXHJcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIHdpdGggYWxsIGNvcGllcyBvclxyXG4gKiBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXHJcbiAqXHJcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCAnQVMgSVMnLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElOR1xyXG4gKiBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcclxuICogTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSAgQ0xBSU0sXHJcbiAqIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcclxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXHJcbiAqL1xyXG5cclxuLy8gT3JpZ2luYWwgV2Vha01hcCBpbXBsZW1lbnRhdGlvbiBieSBHb3phbGEgQCBodHRwczovL2dpc3QuZ2l0aHViLmNvbS8xMjY5OTkxXHJcbi8vIFVwZGF0ZWQgYW5kIGJ1Z2ZpeGVkIGJ5IFJheW5vcyBAIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tLzE2MzgwNTlcclxuLy8gRXhwYW5kZWQgYnkgQmVudmllIEAgaHR0cHM6Ly9naXRodWIuY29tL0JlbnZpZS9oYXJtb255LWNvbGxlY3Rpb25zXHJcblxyXG52b2lkIGZ1bmN0aW9uKGdsb2JhbCwgdW5kZWZpbmVkXywgdW5kZWZpbmVkKXtcclxuICB2YXIgZ2V0UHJvcHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyxcclxuICAgICAgZGVmUHJvcCAgPSBPYmplY3QuZGVmaW5lUHJvcGVydHksXHJcbiAgICAgIHRvU291cmNlID0gRnVuY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nLFxyXG4gICAgICBjcmVhdGUgICA9IE9iamVjdC5jcmVhdGUsXHJcbiAgICAgIGhhc093biAgID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSxcclxuICAgICAgZnVuY05hbWUgPSAvXlxcbj9mdW5jdGlvblxccz8oXFx3Kik/Xz9cXCgvO1xyXG5cclxuXHJcbiAgZnVuY3Rpb24gZGVmaW5lKG9iamVjdCwga2V5LCB2YWx1ZSl7XHJcbiAgICBpZiAodHlwZW9mIGtleSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICB2YWx1ZSA9IGtleTtcclxuICAgICAga2V5ID0gbmFtZU9mKHZhbHVlKS5yZXBsYWNlKC9fJC8sICcnKTtcclxuICAgIH1cclxuICAgIHJldHVybiBkZWZQcm9wKG9iamVjdCwga2V5LCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIG5hbWVPZihmdW5jKXtcclxuICAgIHJldHVybiB0eXBlb2YgZnVuYyAhPT0gJ2Z1bmN0aW9uJ1xyXG4gICAgICAgICAgPyAnJyA6ICduYW1lJyBpbiBmdW5jXHJcbiAgICAgICAgICA/IGZ1bmMubmFtZSA6IHRvU291cmNlLmNhbGwoZnVuYykubWF0Y2goZnVuY05hbWUpWzFdO1xyXG4gIH1cclxuXHJcbiAgLy8gIyMjIyMjIyMjIyMjXHJcbiAgLy8gIyMjIERhdGEgIyMjXHJcbiAgLy8gIyMjIyMjIyMjIyMjXHJcblxyXG4gIHZhciBEYXRhID0gKGZ1bmN0aW9uKCl7XHJcbiAgICB2YXIgZGF0YURlc2MgPSB7IHZhbHVlOiB7IHdyaXRhYmxlOiB0cnVlLCB2YWx1ZTogdW5kZWZpbmVkIH0gfSxcclxuICAgICAgICBkYXRhbG9jayA9ICdyZXR1cm4gZnVuY3Rpb24oayl7aWYoaz09PXMpcmV0dXJuIGx9JyxcclxuICAgICAgICB1aWRzICAgICA9IGNyZWF0ZShudWxsKSxcclxuXHJcbiAgICAgICAgY3JlYXRlVUlEID0gZnVuY3Rpb24oKXtcclxuICAgICAgICAgIHZhciBrZXkgPSBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyKTtcclxuICAgICAgICAgIHJldHVybiBrZXkgaW4gdWlkcyA/IGNyZWF0ZVVJRCgpIDogdWlkc1trZXldID0ga2V5O1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGdsb2JhbElEID0gY3JlYXRlVUlEKCksXHJcblxyXG4gICAgICAgIHN0b3JhZ2UgPSBmdW5jdGlvbihvYmope1xyXG4gICAgICAgICAgaWYgKGhhc093bi5jYWxsKG9iaiwgZ2xvYmFsSUQpKVxyXG4gICAgICAgICAgICByZXR1cm4gb2JqW2dsb2JhbElEXTtcclxuXHJcbiAgICAgICAgICBpZiAoIU9iamVjdC5pc0V4dGVuc2libGUob2JqKSlcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk9iamVjdCBtdXN0IGJlIGV4dGVuc2libGVcIik7XHJcblxyXG4gICAgICAgICAgdmFyIHN0b3JlID0gY3JlYXRlKG51bGwpO1xyXG4gICAgICAgICAgZGVmUHJvcChvYmosIGdsb2JhbElELCB7IHZhbHVlOiBzdG9yZSB9KTtcclxuICAgICAgICAgIHJldHVybiBzdG9yZTtcclxuICAgICAgICB9O1xyXG5cclxuICAgIC8vIGNvbW1vbiBwZXItb2JqZWN0IHN0b3JhZ2UgYXJlYSBtYWRlIHZpc2libGUgYnkgcGF0Y2hpbmcgZ2V0T3duUHJvcGVydHlOYW1lcydcclxuICAgIGRlZmluZShPYmplY3QsIGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMob2JqKXtcclxuICAgICAgdmFyIHByb3BzID0gZ2V0UHJvcHMob2JqKTtcclxuICAgICAgaWYgKGhhc093bi5jYWxsKG9iaiwgZ2xvYmFsSUQpKVxyXG4gICAgICAgIHByb3BzLnNwbGljZShwcm9wcy5pbmRleE9mKGdsb2JhbElEKSwgMSk7XHJcbiAgICAgIHJldHVybiBwcm9wcztcclxuICAgIH0pO1xyXG5cclxuICAgIGZ1bmN0aW9uIERhdGEoKXtcclxuICAgICAgdmFyIHB1aWQgPSBjcmVhdGVVSUQoKSxcclxuICAgICAgICAgIHNlY3JldCA9IHt9O1xyXG5cclxuICAgICAgdGhpcy51bmxvY2sgPSBmdW5jdGlvbihvYmope1xyXG4gICAgICAgIHZhciBzdG9yZSA9IHN0b3JhZ2Uob2JqKTtcclxuICAgICAgICBpZiAoaGFzT3duLmNhbGwoc3RvcmUsIHB1aWQpKVxyXG4gICAgICAgICAgcmV0dXJuIHN0b3JlW3B1aWRdKHNlY3JldCk7XHJcblxyXG4gICAgICAgIHZhciBkYXRhID0gY3JlYXRlKG51bGwsIGRhdGFEZXNjKTtcclxuICAgICAgICBkZWZQcm9wKHN0b3JlLCBwdWlkLCB7XHJcbiAgICAgICAgICB2YWx1ZTogbmV3IEZ1bmN0aW9uKCdzJywgJ2wnLCBkYXRhbG9jaykoc2VjcmV0LCBkYXRhKVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZGVmaW5lKERhdGEucHJvdG90eXBlLCBmdW5jdGlvbiBnZXQobyl7IHJldHVybiB0aGlzLnVubG9jayhvKS52YWx1ZSB9KTtcclxuICAgIGRlZmluZShEYXRhLnByb3RvdHlwZSwgZnVuY3Rpb24gc2V0KG8sIHYpeyB0aGlzLnVubG9jayhvKS52YWx1ZSA9IHYgfSk7XHJcblxyXG4gICAgcmV0dXJuIERhdGE7XHJcbiAgfSgpKTtcclxuXHJcblxyXG4gIHZhciBXTSA9IChmdW5jdGlvbihkYXRhKXtcclxuICAgIHZhciB2YWxpZGF0ZSA9IGZ1bmN0aW9uKGtleSl7XHJcbiAgICAgIGlmIChrZXkgPT0gbnVsbCB8fCB0eXBlb2Yga2V5ICE9PSAnb2JqZWN0JyAmJiB0eXBlb2Yga2V5ICE9PSAnZnVuY3Rpb24nKVxyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIFdlYWtNYXAga2V5XCIpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciB3cmFwID0gZnVuY3Rpb24oY29sbGVjdGlvbiwgdmFsdWUpe1xyXG4gICAgICB2YXIgc3RvcmUgPSBkYXRhLnVubG9jayhjb2xsZWN0aW9uKTtcclxuICAgICAgaWYgKHN0b3JlLnZhbHVlKVxyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJPYmplY3QgaXMgYWxyZWFkeSBhIFdlYWtNYXBcIik7XHJcbiAgICAgIHN0b3JlLnZhbHVlID0gdmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHVud3JhcCA9IGZ1bmN0aW9uKGNvbGxlY3Rpb24pe1xyXG4gICAgICB2YXIgc3RvcmFnZSA9IGRhdGEudW5sb2NrKGNvbGxlY3Rpb24pLnZhbHVlO1xyXG4gICAgICBpZiAoIXN0b3JhZ2UpXHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIldlYWtNYXAgaXMgbm90IGdlbmVyaWNcIik7XHJcbiAgICAgIHJldHVybiBzdG9yYWdlO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBpbml0aWFsaXplID0gZnVuY3Rpb24od2Vha21hcCwgaXRlcmFibGUpe1xyXG4gICAgICBpZiAoaXRlcmFibGUgIT09IG51bGwgJiYgdHlwZW9mIGl0ZXJhYmxlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgaXRlcmFibGUuZm9yRWFjaCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIGl0ZXJhYmxlLmZvckVhY2goZnVuY3Rpb24oaXRlbSwgaSl7XHJcbiAgICAgICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIEFycmF5ICYmIGl0ZW0ubGVuZ3RoID09PSAyKVxyXG4gICAgICAgICAgICBzZXQuY2FsbCh3ZWFrbWFwLCBpdGVyYWJsZVtpXVswXSwgaXRlcmFibGVbaV1bMV0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGZ1bmN0aW9uIFdlYWtNYXAoaXRlcmFibGUpe1xyXG4gICAgICBpZiAodGhpcyA9PT0gZ2xvYmFsIHx8IHRoaXMgPT0gbnVsbCB8fCB0aGlzID09PSBXZWFrTWFwLnByb3RvdHlwZSlcclxuICAgICAgICByZXR1cm4gbmV3IFdlYWtNYXAoaXRlcmFibGUpO1xyXG5cclxuICAgICAgd3JhcCh0aGlzLCBuZXcgRGF0YSk7XHJcbiAgICAgIGluaXRpYWxpemUodGhpcywgaXRlcmFibGUpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGdldChrZXkpe1xyXG4gICAgICB2YWxpZGF0ZShrZXkpO1xyXG4gICAgICB2YXIgdmFsdWUgPSB1bndyYXAodGhpcykuZ2V0KGtleSk7XHJcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkXyA/IHVuZGVmaW5lZCA6IHZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHNldChrZXksIHZhbHVlKXtcclxuICAgICAgdmFsaWRhdGUoa2V5KTtcclxuICAgICAgLy8gc3RvcmUgYSB0b2tlbiBmb3IgZXhwbGljaXQgdW5kZWZpbmVkIHNvIHRoYXQgXCJoYXNcIiB3b3JrcyBjb3JyZWN0bHlcclxuICAgICAgdW53cmFwKHRoaXMpLnNldChrZXksIHZhbHVlID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWRfIDogdmFsdWUpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGhhcyhrZXkpe1xyXG4gICAgICB2YWxpZGF0ZShrZXkpO1xyXG4gICAgICByZXR1cm4gdW53cmFwKHRoaXMpLmdldChrZXkpICE9PSB1bmRlZmluZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZGVsZXRlXyhrZXkpe1xyXG4gICAgICB2YWxpZGF0ZShrZXkpO1xyXG4gICAgICB2YXIgZGF0YSA9IHVud3JhcCh0aGlzKSxcclxuICAgICAgICAgIGhhZCA9IGRhdGEuZ2V0KGtleSkgIT09IHVuZGVmaW5lZDtcclxuICAgICAgZGF0YS5zZXQoa2V5LCB1bmRlZmluZWQpO1xyXG4gICAgICByZXR1cm4gaGFkO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHRvU3RyaW5nKCl7XHJcbiAgICAgIHVud3JhcCh0aGlzKTtcclxuICAgICAgcmV0dXJuICdbb2JqZWN0IFdlYWtNYXBdJztcclxuICAgIH1cclxuXHJcbiAgICB0cnkge1xyXG4gICAgICB2YXIgc3JjID0gKCdyZXR1cm4gJytkZWxldGVfKS5yZXBsYWNlKCdlXycsICdcXFxcdTAwNjUnKSxcclxuICAgICAgICAgIGRlbCA9IG5ldyBGdW5jdGlvbigndW53cmFwJywgJ3ZhbGlkYXRlJywgc3JjKSh1bndyYXAsIHZhbGlkYXRlKTtcclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgdmFyIGRlbCA9IGRlbGV0ZV87XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHNyYyA9ICgnJytPYmplY3QpLnNwbGl0KCdPYmplY3QnKTtcclxuICAgIHZhciBzdHJpbmdpZmllciA9IGZ1bmN0aW9uIHRvU3RyaW5nKCl7XHJcbiAgICAgIHJldHVybiBzcmNbMF0gKyBuYW1lT2YodGhpcykgKyBzcmNbMV07XHJcbiAgICB9O1xyXG5cclxuICAgIGRlZmluZShzdHJpbmdpZmllciwgc3RyaW5naWZpZXIpO1xyXG5cclxuICAgIHZhciBwcmVwID0geyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheVxyXG4gICAgICA/IGZ1bmN0aW9uKGYpeyBmLl9fcHJvdG9fXyA9IHN0cmluZ2lmaWVyIH1cclxuICAgICAgOiBmdW5jdGlvbihmKXsgZGVmaW5lKGYsIHN0cmluZ2lmaWVyKSB9O1xyXG5cclxuICAgIHByZXAoV2Vha01hcCk7XHJcblxyXG4gICAgW3RvU3RyaW5nLCBnZXQsIHNldCwgaGFzLCBkZWxdLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKXtcclxuICAgICAgZGVmaW5lKFdlYWtNYXAucHJvdG90eXBlLCBtZXRob2QpO1xyXG4gICAgICBwcmVwKG1ldGhvZCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gV2Vha01hcDtcclxuICB9KG5ldyBEYXRhKSk7XHJcblxyXG4gIHZhciBkZWZhdWx0Q3JlYXRvciA9IE9iamVjdC5jcmVhdGVcclxuICAgID8gZnVuY3Rpb24oKXsgcmV0dXJuIE9iamVjdC5jcmVhdGUobnVsbCkgfVxyXG4gICAgOiBmdW5jdGlvbigpeyByZXR1cm4ge30gfTtcclxuXHJcbiAgZnVuY3Rpb24gY3JlYXRlU3RvcmFnZShjcmVhdG9yKXtcclxuICAgIHZhciB3ZWFrbWFwID0gbmV3IFdNO1xyXG4gICAgY3JlYXRvciB8fCAoY3JlYXRvciA9IGRlZmF1bHRDcmVhdG9yKTtcclxuXHJcbiAgICBmdW5jdGlvbiBzdG9yYWdlKG9iamVjdCwgdmFsdWUpe1xyXG4gICAgICBpZiAodmFsdWUgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xyXG4gICAgICAgIHdlYWttYXAuc2V0KG9iamVjdCwgdmFsdWUpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHZhbHVlID0gd2Vha21hcC5nZXQob2JqZWN0KTtcclxuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgdmFsdWUgPSBjcmVhdG9yKG9iamVjdCk7XHJcbiAgICAgICAgICB3ZWFrbWFwLnNldChvYmplY3QsIHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBzdG9yYWdlO1xyXG4gIH1cclxuXHJcblxyXG4gIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBXTTtcclxuICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgZXhwb3J0cy5XZWFrTWFwID0gV007XHJcbiAgfSBlbHNlIGlmICghKCdXZWFrTWFwJyBpbiBnbG9iYWwpKSB7XHJcbiAgICBnbG9iYWwuV2Vha01hcCA9IFdNO1xyXG4gIH1cclxuXHJcbiAgV00uY3JlYXRlU3RvcmFnZSA9IGNyZWF0ZVN0b3JhZ2U7XHJcbiAgaWYgKGdsb2JhbC5XZWFrTWFwKVxyXG4gICAgZ2xvYmFsLldlYWtNYXAuY3JlYXRlU3RvcmFnZSA9IGNyZWF0ZVN0b3JhZ2U7XHJcbn0oKDAsIGV2YWwpKCd0aGlzJykpO1xyXG4iLCIndXNlIHN0cmljdCdcblxudmFyIHdlYWtNYXAgPSB0eXBlb2YgV2Vha01hcCA9PT0gJ3VuZGVmaW5lZCcgPyByZXF1aXJlKCd3ZWFrbWFwJykgOiBXZWFrTWFwXG5cbnZhciBXZWJHTEVXU3RydWN0ID0gbmV3IHdlYWtNYXAoKVxuXG5mdW5jdGlvbiBiYXNlTmFtZShleHRfbmFtZSkge1xuICByZXR1cm4gZXh0X25hbWUucmVwbGFjZSgvXltBLVpdK18vLCAnJylcbn1cblxuZnVuY3Rpb24gaW5pdFdlYkdMRVcoZ2wpIHtcbiAgdmFyIHN0cnVjdCA9IFdlYkdMRVdTdHJ1Y3QuZ2V0KGdsKVxuICBpZihzdHJ1Y3QpIHtcbiAgICByZXR1cm4gc3RydWN0XG4gIH1cbiAgdmFyIGV4dGVuc2lvbnMgPSB7fVxuICB2YXIgc3VwcG9ydGVkID0gZ2wuZ2V0U3VwcG9ydGVkRXh0ZW5zaW9ucygpXG4gIGZvcih2YXIgaT0wOyBpPHN1cHBvcnRlZC5sZW5ndGg7ICsraSkge1xuICAgIHZhciBleHROYW1lID0gc3VwcG9ydGVkW2ldXG5cbiAgICAvL1NraXAgTU9aXyBleHRlbnNpb25zXG4gICAgaWYoZXh0TmFtZS5pbmRleE9mKCdNT1pfJykgPT09IDApIHtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIHZhciBleHQgPSBnbC5nZXRFeHRlbnNpb24oc3VwcG9ydGVkW2ldKVxuICAgIGlmKCFleHQpIHtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIHdoaWxlKHRydWUpIHtcbiAgICAgIGV4dGVuc2lvbnNbZXh0TmFtZV0gPSBleHRcbiAgICAgIHZhciBiYXNlID0gYmFzZU5hbWUoZXh0TmFtZSlcbiAgICAgIGlmKGJhc2UgPT09IGV4dE5hbWUpIHtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGV4dE5hbWUgPSBiYXNlXG4gICAgfVxuICB9XG4gIFdlYkdMRVdTdHJ1Y3Quc2V0KGdsLCBleHRlbnNpb25zKVxuICByZXR1cm4gZXh0ZW5zaW9uc1xufVxubW9kdWxlLmV4cG9ydHMgPSBpbml0V2ViR0xFVyIsIid1c2Ugc3RyaWN0J1xuXG52YXIgbmRhcnJheSA9IHJlcXVpcmUoJ25kYXJyYXknKVxudmFyIG9wcyAgICAgPSByZXF1aXJlKCduZGFycmF5LW9wcycpXG52YXIgcG9vbCAgICA9IHJlcXVpcmUoJ3R5cGVkYXJyYXktcG9vbCcpXG52YXIgd2ViZ2xldyA9IHJlcXVpcmUoJ3dlYmdsZXcnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZVRleHR1cmUyRFxuXG52YXIgbGluZWFyVHlwZXMgPSBudWxsXG52YXIgZmlsdGVyVHlwZXMgPSBudWxsXG52YXIgd3JhcFR5cGVzICAgPSBudWxsXG5cbmZ1bmN0aW9uIGxhenlJbml0TGluZWFyVHlwZXMoZ2wpIHtcbiAgbGluZWFyVHlwZXMgPSBbXG4gICAgZ2wuTElORUFSLFxuICAgIGdsLk5FQVJFU1RfTUlQTUFQX0xJTkVBUixcbiAgICBnbC5MSU5FQVJfTUlQTUFQX05FQVJFU1QsXG4gICAgZ2wuTElORUFSX01JUE1BUF9ORUFSRVNUXG4gIF1cbiAgZmlsdGVyVHlwZXMgPSBbXG4gICAgZ2wuTkVBUkVTVCxcbiAgICBnbC5MSU5FQVIsXG4gICAgZ2wuTkVBUkVTVF9NSVBNQVBfTkVBUkVTVCxcbiAgICBnbC5ORUFSRVNUX01JUE1BUF9MSU5FQVIsXG4gICAgZ2wuTElORUFSX01JUE1BUF9ORUFSRVNULFxuICAgIGdsLkxJTkVBUl9NSVBNQVBfTElORUFSXG4gIF1cbiAgd3JhcFR5cGVzID0gW1xuICAgIGdsLlJFUEVBVCxcbiAgICBnbC5DTEFNUF9UT19FREdFLFxuICAgIGdsLk1JUlJPUkVEX1JFUEVBVFxuICBdXG59XG5cbnZhciBjb252ZXJ0RmxvYXRUb1VpbnQ4ID0gZnVuY3Rpb24ob3V0LCBpbnApIHtcbiAgb3BzLm11bHMob3V0LCBpbnAsIDI1NS4wKVxufVxuXG5mdW5jdGlvbiByZXNoYXBlVGV4dHVyZSh0ZXgsIHcsIGgpIHtcbiAgdmFyIGdsID0gdGV4LmdsXG4gIHZhciBtYXhTaXplID0gZ2wuZ2V0UGFyYW1ldGVyKGdsLk1BWF9URVhUVVJFX1NJWkUpXG4gIGlmKHcgPCAwIHx8IHcgPiBtYXhTaXplIHx8IGggPCAwIHx8IGggPiBtYXhTaXplKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdnbC10ZXh0dXJlMmQ6IEludmFsaWQgdGV4dHVyZSBzaXplJylcbiAgfVxuICB0ZXguX3NoYXBlID0gW3csIGhdXG4gIHRleC5iaW5kKClcbiAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCB0ZXguZm9ybWF0LCB3LCBoLCAwLCB0ZXguZm9ybWF0LCB0ZXgudHlwZSwgbnVsbClcbiAgdGV4Ll9taXBMZXZlbHMgPSBbMF1cbiAgcmV0dXJuIHRleFxufVxuXG5mdW5jdGlvbiBUZXh0dXJlMkQoZ2wsIGhhbmRsZSwgd2lkdGgsIGhlaWdodCwgZm9ybWF0LCB0eXBlKSB7XG4gIHRoaXMuZ2wgPSBnbFxuICB0aGlzLmhhbmRsZSA9IGhhbmRsZVxuICB0aGlzLmZvcm1hdCA9IGZvcm1hdFxuICB0aGlzLnR5cGUgPSB0eXBlXG4gIHRoaXMuX3NoYXBlID0gW3dpZHRoLCBoZWlnaHRdXG4gIHRoaXMuX21pcExldmVscyA9IFswXVxuICB0aGlzLl9tYWdGaWx0ZXIgPSBnbC5ORUFSRVNUXG4gIHRoaXMuX21pbkZpbHRlciA9IGdsLk5FQVJFU1RcbiAgdGhpcy5fd3JhcFMgPSBnbC5DTEFNUF9UT19FREdFXG4gIHRoaXMuX3dyYXBUID0gZ2wuQ0xBTVBfVE9fRURHRVxuICB0aGlzLl9hbmlzb1NhbXBsZXMgPSAxXG5cbiAgdmFyIHBhcmVudCA9IHRoaXNcbiAgdmFyIHdyYXBWZWN0b3IgPSBbdGhpcy5fd3JhcFMsIHRoaXMuX3dyYXBUXVxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh3cmFwVmVjdG9yLCBbXG4gICAge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHBhcmVudC5fd3JhcFNcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgcmV0dXJuIHBhcmVudC53cmFwUyA9IHZcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBwYXJlbnQuX3dyYXBUXG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbih2KSB7XG4gICAgICAgIHJldHVybiBwYXJlbnQud3JhcFQgPSB2XG4gICAgICB9XG4gICAgfVxuICBdKVxuICB0aGlzLl93cmFwVmVjdG9yID0gd3JhcFZlY3RvclxuXG4gIHZhciBzaGFwZVZlY3RvciA9IFt0aGlzLl9zaGFwZVswXSwgdGhpcy5fc2hhcGVbMV1dXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHNoYXBlVmVjdG9yLCBbXG4gICAge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHBhcmVudC5fc2hhcGVbMF1cbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgcmV0dXJuIHBhcmVudC53aWR0aCA9IHZcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBwYXJlbnQuX3NoYXBlWzFdXG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbih2KSB7XG4gICAgICAgIHJldHVybiBwYXJlbnQuaGVpZ2h0ID0gdlxuICAgICAgfVxuICAgIH1cbiAgXSlcbiAgdGhpcy5fc2hhcGVWZWN0b3IgPSBzaGFwZVZlY3RvclxufVxuXG52YXIgcHJvdG8gPSBUZXh0dXJlMkQucHJvdG90eXBlXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHByb3RvLCB7XG4gIG1pbkZpbHRlcjoge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbWluRmlsdGVyXG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcbiAgICAgIHRoaXMuYmluZCgpXG4gICAgICB2YXIgZ2wgPSB0aGlzLmdsXG4gICAgICBpZih0aGlzLnR5cGUgPT09IGdsLkZMT0FUICYmIGxpbmVhclR5cGVzLmluZGV4T2YodikgPj0gMCkge1xuICAgICAgICBpZighd2ViZ2xldyhnbCkudGV4dHVyZV9mbG9hdF9saW5lYXIpIHtcbiAgICAgICAgICB2ID0gZ2wuTkVBUkVTVFxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZihmaWx0ZXJUeXBlcy5pbmRleE9mKHYpIDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dsLXRleHR1cmUyZDogVW5rbm93biBmaWx0ZXIgbW9kZSAnICsgdilcbiAgICAgIH1cbiAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCB2KVxuICAgICAgcmV0dXJuIHRoaXMuX21pbkZpbHRlciA9IHZcbiAgICB9XG4gIH0sXG4gIG1hZ0ZpbHRlcjoge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbWFnRmlsdGVyXG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcbiAgICAgIHRoaXMuYmluZCgpXG4gICAgICB2YXIgZ2wgPSB0aGlzLmdsXG4gICAgICBpZih0aGlzLnR5cGUgPT09IGdsLkZMT0FUICYmIGxpbmVhclR5cGVzLmluZGV4T2YodikgPj0gMCkge1xuICAgICAgICBpZighd2ViZ2xldyhnbCkudGV4dHVyZV9mbG9hdF9saW5lYXIpIHtcbiAgICAgICAgICB2ID0gZ2wuTkVBUkVTVFxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZihmaWx0ZXJUeXBlcy5pbmRleE9mKHYpIDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dsLXRleHR1cmUyZDogVW5rbm93biBmaWx0ZXIgbW9kZSAnICsgdilcbiAgICAgIH1cbiAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCB2KVxuICAgICAgcmV0dXJuIHRoaXMuX21hZ0ZpbHRlciA9IHZcbiAgICB9XG4gIH0sXG4gIG1pcFNhbXBsZXM6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2FuaXNvU2FtcGxlc1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbihpKSB7XG4gICAgICB2YXIgcHNhbXBsZXMgPSB0aGlzLl9hbmlzb1NhbXBsZXNcbiAgICAgIHRoaXMuX2FuaXNvU2FtcGxlcyA9IE1hdGgubWF4KGksIDEpfDBcbiAgICAgIGlmKHBzYW1wbGVzICE9PSB0aGlzLl9hbmlzb1NhbXBsZXMpIHtcbiAgICAgICAgdmFyIGV4dCA9IHdlYmdsZXcodGhpcy5nbCkuRVhUX3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljXG4gICAgICAgIGlmKGV4dCkge1xuICAgICAgICAgIHRoaXMuZ2wudGV4UGFyYW1ldGVyZih0aGlzLmdsLlRFWFRVUkVfMkQsIGV4dC5URVhUVVJFX01BWF9BTklTT1RST1BZX0VYVCwgdGhpcy5fYW5pc29TYW1wbGVzKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fYW5pc29TYW1wbGVzXG4gICAgfVxuICB9LFxuICB3cmFwUzoge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fd3JhcFNcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24odikge1xuICAgICAgdGhpcy5iaW5kKClcbiAgICAgIGlmKHdyYXBUeXBlcy5pbmRleE9mKHYpIDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dsLXRleHR1cmUyZDogVW5rbm93biB3cmFwIG1vZGUgJyArIHYpXG4gICAgICB9XG4gICAgICB0aGlzLmdsLnRleFBhcmFtZXRlcmkodGhpcy5nbC5URVhUVVJFXzJELCB0aGlzLmdsLlRFWFRVUkVfV1JBUF9TLCB2KVxuICAgICAgcmV0dXJuIHRoaXMuX3dyYXBTID0gdlxuICAgIH1cbiAgfSxcbiAgd3JhcFQ6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3dyYXBUXG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcbiAgICAgIHRoaXMuYmluZCgpXG4gICAgICBpZih3cmFwVHlwZXMuaW5kZXhPZih2KSA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdnbC10ZXh0dXJlMmQ6IFVua25vd24gd3JhcCBtb2RlICcgKyB2KVxuICAgICAgfVxuICAgICAgdGhpcy5nbC50ZXhQYXJhbWV0ZXJpKHRoaXMuZ2wuVEVYVFVSRV8yRCwgdGhpcy5nbC5URVhUVVJFX1dSQVBfVCwgdilcbiAgICAgIHJldHVybiB0aGlzLl93cmFwVCA9IHZcbiAgICB9XG4gIH0sXG4gIHdyYXA6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3dyYXBWZWN0b3JcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24odikge1xuICAgICAgaWYoIUFycmF5LmlzQXJyYXkodikpIHtcbiAgICAgICAgdiA9IFt2LHZdXG4gICAgICB9XG4gICAgICBpZih2Lmxlbmd0aCAhPT0gMikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dsLXRleHR1cmUyZDogTXVzdCBzcGVjaWZ5IHdyYXAgbW9kZSBmb3Igcm93cyBhbmQgY29sdW1ucycpXG4gICAgICB9XG4gICAgICBmb3IodmFyIGk9MDsgaTwyOyArK2kpIHtcbiAgICAgICAgaWYod3JhcFR5cGVzLmluZGV4T2YodltpXSkgPCAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdnbC10ZXh0dXJlMmQ6IFVua25vd24gd3JhcCBtb2RlICcgKyB2KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLl93cmFwUyA9IHZbMF1cbiAgICAgIHRoaXMuX3dyYXBUID0gdlsxXVxuXG4gICAgICB2YXIgZ2wgPSB0aGlzLmdsXG4gICAgICB0aGlzLmJpbmQoKVxuICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgdGhpcy5fd3JhcFMpXG4gICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCB0aGlzLl93cmFwVClcblxuICAgICAgcmV0dXJuIHZcbiAgICB9XG4gIH0sXG4gIHNoYXBlOiB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zaGFwZVZlY3RvclxuICAgIH0sIFxuICAgIHNldDogZnVuY3Rpb24oeCkge1xuICAgICAgaWYoIUFycmF5LmlzQXJyYXkoeCkpIHtcbiAgICAgICAgeCA9IFt4fDAseHwwXVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYoeC5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dsLXRleHR1cmUyZDogSW52YWxpZCB0ZXh0dXJlIHNoYXBlJylcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmVzaGFwZVRleHR1cmUodGhpcywgeFswXXwwLCB4WzFdfDApXG4gICAgICByZXR1cm4gW3hbMF18MCwgeFsxXXwwXVxuICAgIH1cbiAgfSxcbiAgd2lkdGg6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3NoYXBlWzBdXG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKHcpIHtcbiAgICAgIHcgPSB3fDBcbiAgICAgIHJlc2hhcGVUZXh0dXJlKHRoaXMsIHcsIHRoaXMuX3NoYXBlWzFdKVxuICAgICAgcmV0dXJuIHdcbiAgICB9XG4gIH0sXG4gIGhlaWdodDoge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc2hhcGVbMV1cbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24oaCkge1xuICAgICAgaCA9IGh8MFxuICAgICAgcmVzaGFwZVRleHR1cmUodGhpcywgdGhpcy5fc2hhcGVbMF0sIGgpXG4gICAgICByZXR1cm4gaFxuICAgIH1cbiAgfVxufSlcblxucHJvdG8uYmluZCA9IGZ1bmN0aW9uKHVuaXQpIHtcbiAgdmFyIGdsID0gdGhpcy5nbFxuICBpZih1bml0ICE9PSB1bmRlZmluZWQpIHtcbiAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwICsgKHVuaXR8MCkpXG4gIH1cbiAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy5oYW5kbGUpXG4gIGlmKHVuaXQgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiAodW5pdHwwKVxuICB9XG4gIHJldHVybiBnbC5nZXRQYXJhbWV0ZXIoZ2wuQUNUSVZFX1RFWFRVUkUpIC0gZ2wuVEVYVFVSRTBcbn1cblxucHJvdG8uZGlzcG9zZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmdsLmRlbGV0ZVRleHR1cmUodGhpcy5oYW5kbGUpXG59XG5cbnByb3RvLmdlbmVyYXRlTWlwbWFwID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuYmluZCgpXG4gIHRoaXMuZ2wuZ2VuZXJhdGVNaXBtYXAodGhpcy5nbC5URVhUVVJFXzJEKVxuICBcbiAgLy9VcGRhdGUgbWlwIGxldmVsc1xuICB2YXIgbCA9IE1hdGgubWluKHRoaXMuX3NoYXBlWzBdLCB0aGlzLl9zaGFwZVsxXSlcbiAgZm9yKHZhciBpPTA7IGw+MDsgKytpLCBsPj4+PTEpIHtcbiAgICBpZih0aGlzLl9taXBMZXZlbHMuaW5kZXhPZihpKSA8IDApIHtcbiAgICAgIHRoaXMuX21pcExldmVscy5wdXNoKGkpXG4gICAgfVxuICB9XG59XG5cbnByb3RvLnNldFBpeGVscyA9IGZ1bmN0aW9uKGRhdGEsIHhfb2ZmLCB5X29mZiwgbWlwX2xldmVsKSB7XG4gIHZhciBnbCA9IHRoaXMuZ2xcbiAgdGhpcy5iaW5kKClcbiAgaWYoQXJyYXkuaXNBcnJheSh4X29mZikpIHtcbiAgICBtaXBfbGV2ZWwgPSB5X29mZlxuICAgIHlfb2ZmID0geF9vZmZbMV18MFxuICAgIHhfb2ZmID0geF9vZmZbMF18MFxuICB9IGVsc2Uge1xuICAgIHhfb2ZmID0geF9vZmYgfHwgMFxuICAgIHlfb2ZmID0geV9vZmYgfHwgMFxuICB9XG4gIG1pcF9sZXZlbCA9IG1pcF9sZXZlbCB8fCAwXG4gIGlmKGRhdGEgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudCB8fFxuICAgICBkYXRhIGluc3RhbmNlb2YgSW1hZ2VEYXRhIHx8XG4gICAgIGRhdGEgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50IHx8XG4gICAgIGRhdGEgaW5zdGFuY2VvZiBIVE1MVmlkZW9FbGVtZW50KSB7XG4gICAgdmFyIG5lZWRzTWlwID0gdGhpcy5fbWlwTGV2ZWxzLmluZGV4T2YobWlwX2xldmVsKSA8IDBcbiAgICBpZihuZWVkc01pcCkge1xuICAgICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCB0aGlzLmZvcm1hdCwgdGhpcy5mb3JtYXQsIHRoaXMudHlwZSwgZGF0YSlcbiAgICAgIHRoaXMuX21pcExldmVscy5wdXNoKG1pcF9sZXZlbClcbiAgICB9IGVsc2Uge1xuICAgICAgZ2wudGV4U3ViSW1hZ2UyRChnbC5URVhUVVJFXzJELCBtaXBfbGV2ZWwsIHhfb2ZmLCB5X29mZiwgdGhpcy5mb3JtYXQsIHRoaXMudHlwZSwgZGF0YSlcbiAgICB9XG4gIH0gZWxzZSBpZihkYXRhLnNoYXBlICYmIGRhdGEuc3RyaWRlICYmIGRhdGEuZGF0YSkge1xuICAgIGlmKGRhdGEuc2hhcGUubGVuZ3RoIDwgMiB8fFxuICAgICAgIHhfb2ZmICsgZGF0YS5zaGFwZVsxXSA+IHRoaXMuX3NoYXBlWzFdPj4+bWlwX2xldmVsIHx8XG4gICAgICAgeV9vZmYgKyBkYXRhLnNoYXBlWzBdID4gdGhpcy5fc2hhcGVbMF0+Pj5taXBfbGV2ZWwgfHxcbiAgICAgICB4X29mZiA8IDAgfHxcbiAgICAgICB5X29mZiA8IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZ2wtdGV4dHVyZTJkOiBUZXh0dXJlIGRpbWVuc2lvbnMgYXJlIG91dCBvZiBib3VuZHMnKVxuICAgIH1cbiAgICB0ZXhTdWJJbWFnZUFycmF5KGdsLCB4X29mZiwgeV9vZmYsIG1pcF9sZXZlbCwgdGhpcy5mb3JtYXQsIHRoaXMudHlwZSwgdGhpcy5fbWlwTGV2ZWxzLCBkYXRhKVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignZ2wtdGV4dHVyZTJkOiBVbnN1cHBvcnRlZCBkYXRhIHR5cGUnKVxuICB9XG59XG5cblxuZnVuY3Rpb24gaXNQYWNrZWQoc2hhcGUsIHN0cmlkZSkge1xuICBpZihzaGFwZS5sZW5ndGggPT09IDMpIHtcbiAgICByZXR1cm4gIChzdHJpZGVbMl0gPT09IDEpICYmIFxuICAgICAgICAgICAgKHN0cmlkZVsxXSA9PT0gc2hhcGVbMF0qc2hhcGVbMl0pICYmXG4gICAgICAgICAgICAoc3RyaWRlWzBdID09PSBzaGFwZVsyXSlcbiAgfVxuICByZXR1cm4gIChzdHJpZGVbMF0gPT09IDEpICYmIFxuICAgICAgICAgIChzdHJpZGVbMV0gPT09IHNoYXBlWzBdKVxufVxuXG5mdW5jdGlvbiB0ZXhTdWJJbWFnZUFycmF5KGdsLCB4X29mZiwgeV9vZmYsIG1pcF9sZXZlbCwgY2Zvcm1hdCwgY3R5cGUsIG1pcExldmVscywgYXJyYXkpIHtcbiAgdmFyIGR0eXBlID0gYXJyYXkuZHR5cGVcbiAgdmFyIHNoYXBlID0gYXJyYXkuc2hhcGUuc2xpY2UoKVxuICBpZihzaGFwZS5sZW5ndGggPCAyIHx8IHNoYXBlLmxlbmd0aCA+IDMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2dsLXRleHR1cmUyZDogSW52YWxpZCBuZGFycmF5LCBtdXN0IGJlIDJkIG9yIDNkJylcbiAgfVxuICB2YXIgdHlwZSA9IDAsIGZvcm1hdCA9IDBcbiAgdmFyIHBhY2tlZCA9IGlzUGFja2VkKHNoYXBlLCBhcnJheS5zdHJpZGUuc2xpY2UoKSlcbiAgaWYoZHR5cGUgPT09ICdmbG9hdDMyJykge1xuICAgIHR5cGUgPSBnbC5GTE9BVFxuICB9IGVsc2UgaWYoZHR5cGUgPT09ICdmbG9hdDY0Jykge1xuICAgIHR5cGUgPSBnbC5GTE9BVFxuICAgIHBhY2tlZCA9IGZhbHNlXG4gICAgZHR5cGUgPSAnZmxvYXQzMidcbiAgfSBlbHNlIGlmKGR0eXBlID09PSAndWludDgnKSB7XG4gICAgdHlwZSA9IGdsLlVOU0lHTkVEX0JZVEVcbiAgfSBlbHNlIHtcbiAgICB0eXBlID0gZ2wuVU5TSUdORURfQllURVxuICAgIHBhY2tlZCA9IGZhbHNlXG4gICAgZHR5cGUgPSAndWludDgnXG4gIH1cbiAgdmFyIGNoYW5uZWxzID0gMVxuICBpZihzaGFwZS5sZW5ndGggPT09IDIpIHtcbiAgICBmb3JtYXQgPSBnbC5MVU1JTkFOQ0VcbiAgICBzaGFwZSA9IFtzaGFwZVswXSwgc2hhcGVbMV0sIDFdXG4gICAgYXJyYXkgPSBuZGFycmF5KGFycmF5LmRhdGEsIHNoYXBlLCBbYXJyYXkuc3RyaWRlWzBdLCBhcnJheS5zdHJpZGVbMV0sIDFdLCBhcnJheS5vZmZzZXQpXG4gIH0gZWxzZSBpZihzaGFwZS5sZW5ndGggPT09IDMpIHtcbiAgICBpZihzaGFwZVsyXSA9PT0gMSkge1xuICAgICAgZm9ybWF0ID0gZ2wuQUxQSEFcbiAgICB9IGVsc2UgaWYoc2hhcGVbMl0gPT09IDIpIHtcbiAgICAgIGZvcm1hdCA9IGdsLkxVTUlOQU5DRV9BTFBIQVxuICAgIH0gZWxzZSBpZihzaGFwZVsyXSA9PT0gMykge1xuICAgICAgZm9ybWF0ID0gZ2wuUkdCXG4gICAgfSBlbHNlIGlmKHNoYXBlWzJdID09PSA0KSB7XG4gICAgICBmb3JtYXQgPSBnbC5SR0JBXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZ2wtdGV4dHVyZTJkOiBJbnZhbGlkIHNoYXBlIGZvciBwaXhlbCBjb29yZHMnKVxuICAgIH1cbiAgICBjaGFubmVscyA9IHNoYXBlWzJdXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdnbC10ZXh0dXJlMmQ6IEludmFsaWQgc2hhcGUgZm9yIHRleHR1cmUnKVxuICB9XG4gIC8vRm9yIDEtY2hhbm5lbCB0ZXh0dXJlcyBhbGxvdyBjb252ZXJzaW9uIGJldHdlZW4gZm9ybWF0c1xuICBpZigoZm9ybWF0ICA9PT0gZ2wuTFVNSU5BTkNFIHx8IGZvcm1hdCAgPT09IGdsLkFMUEhBKSAmJlxuICAgICAoY2Zvcm1hdCA9PT0gZ2wuTFVNSU5BTkNFIHx8IGNmb3JtYXQgPT09IGdsLkFMUEhBKSkge1xuICAgIGZvcm1hdCA9IGNmb3JtYXRcbiAgfVxuICBpZihmb3JtYXQgIT09IGNmb3JtYXQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2dsLXRleHR1cmUyZDogSW5jb21wYXRpYmxlIHRleHR1cmUgZm9ybWF0IGZvciBzZXRQaXhlbHMnKVxuICB9XG4gIHZhciBzaXplID0gYXJyYXkuc2l6ZVxuICB2YXIgbmVlZHNNaXAgPSBtaXBMZXZlbHMuaW5kZXhPZihtaXBfbGV2ZWwpIDwgMFxuICBpZihuZWVkc01pcCkge1xuICAgIG1pcExldmVscy5wdXNoKG1pcF9sZXZlbClcbiAgfVxuICBpZih0eXBlID09PSBjdHlwZSAmJiBwYWNrZWQpIHtcbiAgICAvL0FycmF5IGRhdGEgdHlwZXMgYXJlIGNvbXBhdGlibGUsIGNhbiBkaXJlY3RseSBjb3B5IGludG8gdGV4dHVyZVxuICAgIGlmKGFycmF5Lm9mZnNldCA9PT0gMCAmJiBhcnJheS5kYXRhLmxlbmd0aCA9PT0gc2l6ZSkge1xuICAgICAgaWYobmVlZHNNaXApIHtcbiAgICAgICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCBtaXBfbGV2ZWwsIGNmb3JtYXQsIHNoYXBlWzBdLCBzaGFwZVsxXSwgMCwgY2Zvcm1hdCwgY3R5cGUsIGFycmF5LmRhdGEpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBnbC50ZXhTdWJJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIG1pcF9sZXZlbCwgeF9vZmYsIHlfb2ZmLCBzaGFwZVswXSwgc2hhcGVbMV0sIGNmb3JtYXQsIGN0eXBlLCBhcnJheS5kYXRhKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZihuZWVkc01pcCkge1xuICAgICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIG1pcF9sZXZlbCwgY2Zvcm1hdCwgc2hhcGVbMF0sIHNoYXBlWzFdLCAwLCBjZm9ybWF0LCBjdHlwZSwgYXJyYXkuZGF0YS5zdWJhcnJheShhcnJheS5vZmZzZXQsIGFycmF5Lm9mZnNldCtzaXplKSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdsLnRleFN1YkltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgbWlwX2xldmVsLCB4X29mZiwgeV9vZmYsIHNoYXBlWzBdLCBzaGFwZVsxXSwgY2Zvcm1hdCwgY3R5cGUsIGFycmF5LmRhdGEuc3ViYXJyYXkoYXJyYXkub2Zmc2V0LCBhcnJheS5vZmZzZXQrc2l6ZSkpXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vTmVlZCB0byBkbyB0eXBlIGNvbnZlcnNpb24gdG8gcGFjayBkYXRhIGludG8gYnVmZmVyXG4gICAgdmFyIHBhY2tfYnVmZmVyXG4gICAgaWYoY3R5cGUgPT09IGdsLkZMT0FUKSB7XG4gICAgICBwYWNrX2J1ZmZlciA9IHBvb2wubWFsbG9jRmxvYXQzMihzaXplKVxuICAgIH0gZWxzZSB7XG4gICAgICBwYWNrX2J1ZmZlciA9IHBvb2wubWFsbG9jVWludDgoc2l6ZSlcbiAgICB9XG4gICAgdmFyIHBhY2tfdmlldyA9IG5kYXJyYXkocGFja19idWZmZXIsIHNoYXBlLCBbc2hhcGVbMl0sIHNoYXBlWzJdKnNoYXBlWzBdLCAxXSlcbiAgICBpZih0eXBlID09PSBnbC5GTE9BVCAmJiBjdHlwZSA9PT0gZ2wuVU5TSUdORURfQllURSkge1xuICAgICAgY29udmVydEZsb2F0VG9VaW50OChwYWNrX3ZpZXcsIGFycmF5KVxuICAgIH0gZWxzZSB7XG4gICAgICBvcHMuYXNzaWduKHBhY2tfdmlldywgYXJyYXkpXG4gICAgfVxuICAgIGlmKG5lZWRzTWlwKSB7XG4gICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIG1pcF9sZXZlbCwgY2Zvcm1hdCwgc2hhcGVbMF0sIHNoYXBlWzFdLCAwLCBjZm9ybWF0LCBjdHlwZSwgcGFja19idWZmZXIuc3ViYXJyYXkoMCwgc2l6ZSkpXG4gICAgfSBlbHNlIHtcbiAgICAgIGdsLnRleFN1YkltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgbWlwX2xldmVsLCB4X29mZiwgeV9vZmYsIHNoYXBlWzBdLCBzaGFwZVsxXSwgY2Zvcm1hdCwgY3R5cGUsIHBhY2tfYnVmZmVyLnN1YmFycmF5KDAsIHNpemUpKVxuICAgIH1cbiAgICBpZihjdHlwZSA9PT0gZ2wuRkxPQVQpIHtcbiAgICAgIHBvb2wuZnJlZUZsb2F0MzIocGFja19idWZmZXIpXG4gICAgfSBlbHNlIHtcbiAgICAgIHBvb2wuZnJlZVVpbnQ4KHBhY2tfYnVmZmVyKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0VGV4dHVyZShnbCkge1xuICB2YXIgdGV4ID0gZ2wuY3JlYXRlVGV4dHVyZSgpXG4gIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleClcbiAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLk5FQVJFU1QpXG4gIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5ORUFSRVNUKVxuICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKVxuICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFKVxuICByZXR1cm4gdGV4XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVRleHR1cmVTaGFwZShnbCwgd2lkdGgsIGhlaWdodCwgZm9ybWF0LCB0eXBlKSB7XG4gIHZhciBtYXhUZXh0dXJlU2l6ZSA9IGdsLmdldFBhcmFtZXRlcihnbC5NQVhfVEVYVFVSRV9TSVpFKVxuICBpZih3aWR0aCA8IDAgfHwgd2lkdGggPiBtYXhUZXh0dXJlU2l6ZSB8fCBoZWlnaHQgPCAwIHx8IGhlaWdodCAgPiBtYXhUZXh0dXJlU2l6ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignZ2wtdGV4dHVyZTJkOiBJbnZhbGlkIHRleHR1cmUgc2hhcGUnKVxuICB9XG4gIGlmKHR5cGUgPT09IGdsLkZMT0FUICYmICF3ZWJnbGV3KGdsKS50ZXh0dXJlX2Zsb2F0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdnbC10ZXh0dXJlMmQ6IEZsb2F0aW5nIHBvaW50IHRleHR1cmVzIG5vdCBzdXBwb3J0ZWQgb24gdGhpcyBwbGF0Zm9ybScpXG4gIH1cbiAgdmFyIHRleCA9IGluaXRUZXh0dXJlKGdsKVxuICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGZvcm1hdCwgd2lkdGgsIGhlaWdodCwgMCwgZm9ybWF0LCB0eXBlLCBudWxsKVxuICByZXR1cm4gbmV3IFRleHR1cmUyRChnbCwgdGV4LCB3aWR0aCwgaGVpZ2h0LCBmb3JtYXQsIHR5cGUpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVRleHR1cmVET00oZ2wsIGVsZW1lbnQsIGZvcm1hdCwgdHlwZSkge1xuICB2YXIgdGV4ID0gaW5pdFRleHR1cmUoZ2wpXG4gIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZm9ybWF0LCBmb3JtYXQsIHR5cGUsIGVsZW1lbnQpXG4gIHJldHVybiBuZXcgVGV4dHVyZTJEKGdsLCB0ZXgsIGVsZW1lbnQud2lkdGh8MCwgZWxlbWVudC5oZWlnaHR8MCwgZm9ybWF0LCB0eXBlKVxufVxuXG4vL0NyZWF0ZXMgYSB0ZXh0dXJlIGZyb20gYW4gbmRhcnJheVxuZnVuY3Rpb24gY3JlYXRlVGV4dHVyZUFycmF5KGdsLCBhcnJheSkge1xuICB2YXIgZHR5cGUgPSBhcnJheS5kdHlwZVxuICB2YXIgc2hhcGUgPSBhcnJheS5zaGFwZS5zbGljZSgpXG4gIHZhciBtYXhTaXplID0gZ2wuZ2V0UGFyYW1ldGVyKGdsLk1BWF9URVhUVVJFX1NJWkUpXG4gIGlmKHNoYXBlWzBdIDwgMCB8fCBzaGFwZVswXSA+IG1heFNpemUgfHwgc2hhcGVbMV0gPCAwIHx8IHNoYXBlWzFdID4gbWF4U2l6ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignZ2wtdGV4dHVyZTJkOiBJbnZhbGlkIHRleHR1cmUgc2l6ZScpXG4gIH1cbiAgdmFyIHBhY2tlZCA9IGlzUGFja2VkKHNoYXBlLCBhcnJheS5zdHJpZGUuc2xpY2UoKSlcbiAgdmFyIHR5cGUgPSAwXG4gIGlmKGR0eXBlID09PSAnZmxvYXQzMicpIHtcbiAgICB0eXBlID0gZ2wuRkxPQVRcbiAgfSBlbHNlIGlmKGR0eXBlID09PSAnZmxvYXQ2NCcpIHtcbiAgICB0eXBlID0gZ2wuRkxPQVRcbiAgICBwYWNrZWQgPSBmYWxzZVxuICAgIGR0eXBlID0gJ2Zsb2F0MzInXG4gIH0gZWxzZSBpZihkdHlwZSA9PT0gJ3VpbnQ4Jykge1xuICAgIHR5cGUgPSBnbC5VTlNJR05FRF9CWVRFXG4gIH0gZWxzZSB7XG4gICAgdHlwZSA9IGdsLlVOU0lHTkVEX0JZVEVcbiAgICBwYWNrZWQgPSBmYWxzZVxuICAgIGR0eXBlID0gJ3VpbnQ4J1xuICB9XG4gIHZhciBmb3JtYXQgPSAwXG4gIGlmKHNoYXBlLmxlbmd0aCA9PT0gMikge1xuICAgIGZvcm1hdCA9IGdsLkxVTUlOQU5DRVxuICAgIHNoYXBlID0gW3NoYXBlWzBdLCBzaGFwZVsxXSwgMV1cbiAgICBhcnJheSA9IG5kYXJyYXkoYXJyYXkuZGF0YSwgc2hhcGUsIFthcnJheS5zdHJpZGVbMF0sIGFycmF5LnN0cmlkZVsxXSwgMV0sIGFycmF5Lm9mZnNldClcbiAgfSBlbHNlIGlmKHNoYXBlLmxlbmd0aCA9PT0gMykge1xuICAgIGlmKHNoYXBlWzJdID09PSAxKSB7XG4gICAgICBmb3JtYXQgPSBnbC5BTFBIQVxuICAgIH0gZWxzZSBpZihzaGFwZVsyXSA9PT0gMikge1xuICAgICAgZm9ybWF0ID0gZ2wuTFVNSU5BTkNFX0FMUEhBXG4gICAgfSBlbHNlIGlmKHNoYXBlWzJdID09PSAzKSB7XG4gICAgICBmb3JtYXQgPSBnbC5SR0JcbiAgICB9IGVsc2UgaWYoc2hhcGVbMl0gPT09IDQpIHtcbiAgICAgIGZvcm1hdCA9IGdsLlJHQkFcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdnbC10ZXh0dXJlMmQ6IEludmFsaWQgc2hhcGUgZm9yIHBpeGVsIGNvb3JkcycpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignZ2wtdGV4dHVyZTJkOiBJbnZhbGlkIHNoYXBlIGZvciB0ZXh0dXJlJylcbiAgfVxuICBpZih0eXBlID09PSBnbC5GTE9BVCAmJiAhd2ViZ2xldyhnbCkudGV4dHVyZV9mbG9hdCkge1xuICAgIHR5cGUgPSBnbC5VTlNJR05FRF9CWVRFXG4gICAgcGFja2VkID0gZmFsc2VcbiAgfVxuICB2YXIgYnVmZmVyLCBidWZfc3RvcmVcbiAgdmFyIHNpemUgPSBhcnJheS5zaXplXG4gIGlmKCFwYWNrZWQpIHtcbiAgICB2YXIgc3RyaWRlID0gW3NoYXBlWzJdLCBzaGFwZVsyXSpzaGFwZVswXSwgMV1cbiAgICBidWZfc3RvcmUgPSBwb29sLm1hbGxvYyhzaXplLCBkdHlwZSlcbiAgICB2YXIgYnVmX2FycmF5ID0gbmRhcnJheShidWZfc3RvcmUsIHNoYXBlLCBzdHJpZGUsIDApXG4gICAgaWYoKGR0eXBlID09PSAnZmxvYXQzMicgfHwgZHR5cGUgPT09ICdmbG9hdDY0JykgJiYgdHlwZSA9PT0gZ2wuVU5TSUdORURfQllURSkge1xuICAgICAgY29udmVydEZsb2F0VG9VaW50OChidWZfYXJyYXksIGFycmF5KVxuICAgIH0gZWxzZSB7XG4gICAgICBvcHMuYXNzaWduKGJ1Zl9hcnJheSwgYXJyYXkpXG4gICAgfVxuICAgIGJ1ZmZlciA9IGJ1Zl9zdG9yZS5zdWJhcnJheSgwLCBzaXplKVxuICB9IGVsc2UgaWYgKGFycmF5Lm9mZnNldCA9PT0gMCAmJiBhcnJheS5kYXRhLmxlbmd0aCA9PT0gc2l6ZSkge1xuICAgIGJ1ZmZlciA9IGFycmF5LmRhdGFcbiAgfSBlbHNlIHtcbiAgICBidWZmZXIgPSBhcnJheS5kYXRhLnN1YmFycmF5KGFycmF5Lm9mZnNldCwgYXJyYXkub2Zmc2V0ICsgc2l6ZSlcbiAgfVxuICB2YXIgdGV4ID0gaW5pdFRleHR1cmUoZ2wpXG4gIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZm9ybWF0LCBzaGFwZVswXSwgc2hhcGVbMV0sIDAsIGZvcm1hdCwgdHlwZSwgYnVmZmVyKVxuICBpZighcGFja2VkKSB7XG4gICAgcG9vbC5mcmVlKGJ1Zl9zdG9yZSlcbiAgfVxuICByZXR1cm4gbmV3IFRleHR1cmUyRChnbCwgdGV4LCBzaGFwZVswXSwgc2hhcGVbMV0sIGZvcm1hdCwgdHlwZSlcbn1cblxuZnVuY3Rpb24gY3JlYXRlVGV4dHVyZTJEKGdsKSB7XG4gIGlmKGFyZ3VtZW50cy5sZW5ndGggPD0gMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignZ2wtdGV4dHVyZTJkOiBNaXNzaW5nIGFyZ3VtZW50cyBmb3IgdGV4dHVyZTJkIGNvbnN0cnVjdG9yJylcbiAgfVxuICBpZighbGluZWFyVHlwZXMpIHtcbiAgICBsYXp5SW5pdExpbmVhclR5cGVzKGdsKVxuICB9XG4gIGlmKHR5cGVvZiBhcmd1bWVudHNbMV0gPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIGNyZWF0ZVRleHR1cmVTaGFwZShnbCwgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0sIGFyZ3VtZW50c1szXXx8Z2wuUkdCQSwgYXJndW1lbnRzWzRdfHxnbC5VTlNJR05FRF9CWVRFKVxuICB9XG4gIGlmKEFycmF5LmlzQXJyYXkoYXJndW1lbnRzWzFdKSkge1xuICAgIHJldHVybiBjcmVhdGVUZXh0dXJlU2hhcGUoZ2wsIGFyZ3VtZW50c1sxXVswXXwwLCBhcmd1bWVudHNbMV1bMV18MCwgYXJndW1lbnRzWzJdfHxnbC5SR0JBLCBhcmd1bWVudHNbM118fGdsLlVOU0lHTkVEX0JZVEUpXG4gIH1cbiAgaWYodHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gJ29iamVjdCcpIHtcbiAgICB2YXIgb2JqID0gYXJndW1lbnRzWzFdXG4gICAgaWYob2JqIGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnQgfHxcbiAgICAgICBvYmogaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50IHx8XG4gICAgICAgb2JqIGluc3RhbmNlb2YgSFRNTFZpZGVvRWxlbWVudCB8fFxuICAgICAgIG9iaiBpbnN0YW5jZW9mIEltYWdlRGF0YSkge1xuICAgICAgcmV0dXJuIGNyZWF0ZVRleHR1cmVET00oZ2wsIG9iaiwgYXJndW1lbnRzWzJdfHxnbC5SR0JBLCBhcmd1bWVudHNbM118fGdsLlVOU0lHTkVEX0JZVEUpXG4gICAgfSBlbHNlIGlmKG9iai5zaGFwZSAmJiBvYmouZGF0YSAmJiBvYmouc3RyaWRlKSB7XG4gICAgICByZXR1cm4gY3JlYXRlVGV4dHVyZUFycmF5KGdsLCBvYmopXG4gICAgfVxuICB9XG4gIHRocm93IG5ldyBFcnJvcignZ2wtdGV4dHVyZTJkOiBJbnZhbGlkIGFyZ3VtZW50cyBmb3IgdGV4dHVyZTJkIGNvbnN0cnVjdG9yJylcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gc2V0O1xuXG4vKipcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzMgdG8gdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB6IFogY29tcG9uZW50XG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIHNldChvdXQsIHgsIHksIHopIHtcbiAgICBvdXRbMF0gPSB4XG4gICAgb3V0WzFdID0geVxuICAgIG91dFsyXSA9IHpcbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBwcm9ncmFtaWZ5XG5cbnZhciBzaGFkZXIgPSByZXF1aXJlKCdnbC1zaGFkZXItY29yZScpXG5cbmZ1bmN0aW9uIHByb2dyYW1pZnkodmVydGV4LCBmcmFnbWVudCwgdW5pZm9ybXMsIGF0dHJpYnV0ZXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGdsKSB7XG4gICAgcmV0dXJuIHNoYWRlcihnbCwgdmVydGV4LCBmcmFnbWVudCwgdW5pZm9ybXMsIGF0dHJpYnV0ZXMpXG4gIH1cbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gbm9vcFxuXG5mdW5jdGlvbiBub29wKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnWW91IHNob3VsZCBidW5kbGUgeW91ciBjb2RlICcgK1xuICAgICAgJ3VzaW5nIGBnbHNsaWZ5YCBhcyBhIHRyYW5zZm9ybS4nXG4gIClcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUF0dHJpYnV0ZVdyYXBwZXJcblxuLy9TaGFkZXIgYXR0cmlidXRlIGNsYXNzXG5mdW5jdGlvbiBTaGFkZXJBdHRyaWJ1dGUoZ2wsIHByb2dyYW0sIGxvY2F0aW9uLCBkaW1lbnNpb24sIG5hbWUsIGNvbnN0RnVuYywgcmVsaW5rKSB7XG4gIHRoaXMuX2dsID0gZ2xcbiAgdGhpcy5fcHJvZ3JhbSA9IHByb2dyYW1cbiAgdGhpcy5fbG9jYXRpb24gPSBsb2NhdGlvblxuICB0aGlzLl9kaW1lbnNpb24gPSBkaW1lbnNpb25cbiAgdGhpcy5fbmFtZSA9IG5hbWVcbiAgdGhpcy5fY29uc3RGdW5jID0gY29uc3RGdW5jXG4gIHRoaXMuX3JlbGluayA9IHJlbGlua1xufVxuXG52YXIgcHJvdG8gPSBTaGFkZXJBdHRyaWJ1dGUucHJvdG90eXBlXG5cbnByb3RvLnBvaW50ZXIgPSBmdW5jdGlvbiBzZXRBdHRyaWJQb2ludGVyKHR5cGUsIG5vcm1hbGl6ZWQsIHN0cmlkZSwgb2Zmc2V0KSB7XG4gIHZhciBnbCA9IHRoaXMuX2dsXG4gIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIodGhpcy5fbG9jYXRpb24sIHRoaXMuX2RpbWVuc2lvbiwgdHlwZXx8Z2wuRkxPQVQsICEhbm9ybWFsaXplZCwgc3RyaWRlfHwwLCBvZmZzZXR8fDApXG4gIHRoaXMuX2dsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHRoaXMuX2xvY2F0aW9uKVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG8sICdsb2NhdGlvbicsIHtcbiAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fbG9jYXRpb25cbiAgfVxuICAsIHNldDogZnVuY3Rpb24odikge1xuICAgIGlmKHYgIT09IHRoaXMuX2xvY2F0aW9uKSB7XG4gICAgICB0aGlzLl9sb2NhdGlvbiA9IHZcbiAgICAgIHRoaXMuX2dsLmJpbmRBdHRyaWJMb2NhdGlvbih0aGlzLl9wcm9ncmFtLCB2LCB0aGlzLl9uYW1lKVxuICAgICAgdGhpcy5fZ2wubGlua1Byb2dyYW0odGhpcy5fcHJvZ3JhbSlcbiAgICAgIHRoaXMuX3JlbGluaygpXG4gICAgfVxuICB9XG59KVxuXG5cbi8vQWRkcyBhIHZlY3RvciBhdHRyaWJ1dGUgdG8gb2JqXG5mdW5jdGlvbiBhZGRWZWN0b3JBdHRyaWJ1dGUoZ2wsIHByb2dyYW0sIGxvY2F0aW9uLCBkaW1lbnNpb24sIG9iaiwgbmFtZSwgZG9MaW5rKSB7XG4gIHZhciBjb25zdEZ1bmNBcmdzID0gWyAnZ2wnLCAndicgXVxuICB2YXIgdmFyTmFtZXMgPSBbXVxuICBmb3IodmFyIGk9MDsgaTxkaW1lbnNpb247ICsraSkge1xuICAgIGNvbnN0RnVuY0FyZ3MucHVzaCgneCcraSlcbiAgICB2YXJOYW1lcy5wdXNoKCd4JytpKVxuICB9XG4gIGNvbnN0RnVuY0FyZ3MucHVzaChbXG4gICAgJ2lmKHgwLmxlbmd0aD09PXZvaWQgMCl7cmV0dXJuIGdsLnZlcnRleEF0dHJpYicsIGRpbWVuc2lvbiwgJ2YodiwnLCB2YXJOYW1lcy5qb2luKCksICcpfWVsc2V7cmV0dXJuIGdsLnZlcnRleEF0dHJpYicsIGRpbWVuc2lvbiwgJ2Z2KHYseDApfSdcbiAgXS5qb2luKCcnKSlcbiAgdmFyIGNvbnN0RnVuYyA9IEZ1bmN0aW9uLmFwcGx5KHVuZGVmaW5lZCwgY29uc3RGdW5jQXJncylcbiAgdmFyIGF0dHIgPSBuZXcgU2hhZGVyQXR0cmlidXRlKGdsLCBwcm9ncmFtLCBsb2NhdGlvbiwgZGltZW5zaW9uLCBuYW1lLCBjb25zdEZ1bmMsIGRvTGluaylcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgbmFtZSwge1xuICAgIHNldDogZnVuY3Rpb24oeCkge1xuICAgICAgZ2wuZGlzYWJsZVZlcnRleEF0dHJpYkFycmF5KGF0dHIuX2xvY2F0aW9uKVxuICAgICAgY29uc3RGdW5jKGdsLCBhdHRyLl9sb2NhdGlvbiwgeClcbiAgICAgIHJldHVybiB4XG4gICAgfVxuICAgICwgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBhdHRyXG4gICAgfVxuICAgICwgZW51bWVyYWJsZTogdHJ1ZVxuICB9KVxufVxuXG4vL0NyZWF0ZSBzaGltcyBmb3IgYXR0cmlidXRlc1xuZnVuY3Rpb24gY3JlYXRlQXR0cmlidXRlV3JhcHBlcihnbCwgcHJvZ3JhbSwgYXR0cmlidXRlcywgZG9MaW5rKSB7XG4gIHZhciBvYmogPSB7fVxuICBmb3IodmFyIGk9MCwgbj1hdHRyaWJ1dGVzLmxlbmd0aDsgaTxuOyArK2kpIHtcbiAgICB2YXIgYSA9IGF0dHJpYnV0ZXNbaV1cbiAgICB2YXIgbmFtZSA9IGEubmFtZVxuICAgIHZhciB0eXBlID0gYS50eXBlXG4gICAgdmFyIGxvY2F0aW9uID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgbmFtZSlcbiAgICBcbiAgICBzd2l0Y2godHlwZSkge1xuICAgICAgY2FzZSAnYm9vbCc6XG4gICAgICBjYXNlICdpbnQnOlxuICAgICAgY2FzZSAnZmxvYXQnOlxuICAgICAgICBhZGRWZWN0b3JBdHRyaWJ1dGUoZ2wsIHByb2dyYW0sIGxvY2F0aW9uLCAxLCBvYmosIG5hbWUsIGRvTGluaylcbiAgICAgIGJyZWFrXG4gICAgICBcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmKHR5cGUuaW5kZXhPZigndmVjJykgPj0gMCkge1xuICAgICAgICAgIHZhciBkID0gdHlwZS5jaGFyQ29kZUF0KHR5cGUubGVuZ3RoLTEpIC0gNDhcbiAgICAgICAgICBpZihkIDwgMiB8fCBkID4gNCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdnbC1zaGFkZXI6IEludmFsaWQgZGF0YSB0eXBlIGZvciBhdHRyaWJ1dGUgJyArIG5hbWUgKyAnOiAnICsgdHlwZSlcbiAgICAgICAgICB9XG4gICAgICAgICAgYWRkVmVjdG9yQXR0cmlidXRlKGdsLCBwcm9ncmFtLCBsb2NhdGlvbiwgZCwgb2JqLCBuYW1lLCBkb0xpbmspXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdnbC1zaGFkZXI6IFVua25vd24gZGF0YSB0eXBlIGZvciBhdHRyaWJ1dGUgJyArIG5hbWUgKyAnOiAnICsgdHlwZSlcbiAgICAgICAgfVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9ialxufSIsIid1c2Ugc3RyaWN0J1xuXG52YXIgZHVwID0gcmVxdWlyZSgnZHVwJylcbnZhciBjb2FsbGVzY2VVbmlmb3JtcyA9IHJlcXVpcmUoJy4vcmVmbGVjdCcpXG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlVW5pZm9ybVdyYXBwZXJcblxuLy9CaW5kcyBhIGZ1bmN0aW9uIGFuZCByZXR1cm5zIGEgdmFsdWVcbmZ1bmN0aW9uIGlkZW50aXR5KHgpIHtcbiAgdmFyIGMgPSBuZXcgRnVuY3Rpb24oJ3knLCAncmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIHl9JylcbiAgcmV0dXJuIGMoeClcbn1cblxuLy9DcmVhdGUgc2hpbXMgZm9yIHVuaWZvcm1zXG5mdW5jdGlvbiBjcmVhdGVVbmlmb3JtV3JhcHBlcihnbCwgcHJvZ3JhbSwgdW5pZm9ybXMsIGxvY2F0aW9ucykge1xuXG4gIGZ1bmN0aW9uIG1ha2VHZXR0ZXIoaW5kZXgpIHtcbiAgICB2YXIgcHJvYyA9IG5ldyBGdW5jdGlvbignZ2wnLCAncHJvZycsICdsb2NhdGlvbnMnLCBcbiAgICAgICdyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gZ2wuZ2V0VW5pZm9ybShwcm9nLGxvY2F0aW9uc1snICsgaW5kZXggKyAnXSl9JykgXG4gICAgcmV0dXJuIHByb2MoZ2wsIHByb2dyYW0sIGxvY2F0aW9ucylcbiAgfVxuXG4gIGZ1bmN0aW9uIG1ha2VQcm9wU2V0dGVyKHBhdGgsIGluZGV4LCB0eXBlKSB7XG4gICAgc3dpdGNoKHR5cGUpIHtcbiAgICAgIGNhc2UgJ2Jvb2wnOlxuICAgICAgY2FzZSAnaW50JzpcbiAgICAgIGNhc2UgJ3NhbXBsZXIyRCc6XG4gICAgICBjYXNlICdzYW1wbGVyQ3ViZSc6XG4gICAgICAgIHJldHVybiAnZ2wudW5pZm9ybTFpKGxvY2F0aW9uc1snICsgaW5kZXggKyAnXSxvYmonICsgcGF0aCArICcpJ1xuICAgICAgY2FzZSAnZmxvYXQnOlxuICAgICAgICByZXR1cm4gJ2dsLnVuaWZvcm0xZihsb2NhdGlvbnNbJyArIGluZGV4ICsgJ10sb2JqJyArIHBhdGggKyAnKSdcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHZhciB2aWR4ID0gdHlwZS5pbmRleE9mKCd2ZWMnKVxuICAgICAgICBpZigwIDw9IHZpZHggJiYgdmlkeCA8PSAxICYmIHR5cGUubGVuZ3RoID09PSA0ICsgdmlkeCkge1xuICAgICAgICAgIHZhciBkID0gdHlwZS5jaGFyQ29kZUF0KHR5cGUubGVuZ3RoLTEpIC0gNDhcbiAgICAgICAgICBpZihkIDwgMiB8fCBkID4gNCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdnbC1zaGFkZXI6IEludmFsaWQgZGF0YSB0eXBlJylcbiAgICAgICAgICB9XG4gICAgICAgICAgc3dpdGNoKHR5cGUuY2hhckF0KDApKSB7XG4gICAgICAgICAgICBjYXNlICdiJzpcbiAgICAgICAgICAgIGNhc2UgJ2knOlxuICAgICAgICAgICAgICByZXR1cm4gJ2dsLnVuaWZvcm0nICsgZCArICdpdihsb2NhdGlvbnNbJyArIGluZGV4ICsgJ10sb2JqJyArIHBhdGggKyAnKSdcbiAgICAgICAgICAgIGNhc2UgJ3YnOlxuICAgICAgICAgICAgICByZXR1cm4gJ2dsLnVuaWZvcm0nICsgZCArICdmdihsb2NhdGlvbnNbJyArIGluZGV4ICsgJ10sb2JqJyArIHBhdGggKyAnKSdcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZ2wtc2hhZGVyOiBVbnJlY29nbml6ZWQgZGF0YSB0eXBlIGZvciB2ZWN0b3IgJyArIG5hbWUgKyAnOiAnICsgdHlwZSlcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZih0eXBlLmluZGV4T2YoJ21hdCcpID09PSAwICYmIHR5cGUubGVuZ3RoID09PSA0KSB7XG4gICAgICAgICAgdmFyIGQgPSB0eXBlLmNoYXJDb2RlQXQodHlwZS5sZW5ndGgtMSkgLSA0OFxuICAgICAgICAgIGlmKGQgPCAyIHx8IGQgPiA0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dsLXNoYWRlcjogSW52YWxpZCB1bmlmb3JtIGRpbWVuc2lvbiB0eXBlIGZvciBtYXRyaXggJyArIG5hbWUgKyAnOiAnICsgdHlwZSlcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuICdnbC51bmlmb3JtTWF0cml4JyArIGQgKyAnZnYobG9jYXRpb25zWycgKyBpbmRleCArICddLGZhbHNlLG9iaicgKyBwYXRoICsgJyknXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdnbC1zaGFkZXI6IFVua25vd24gdW5pZm9ybSBkYXRhIHR5cGUgZm9yICcgKyBuYW1lICsgJzogJyArIHR5cGUpXG4gICAgICAgIH1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZW51bWVyYXRlSW5kaWNlcyhwcmVmaXgsIHR5cGUpIHtcbiAgICBpZih0eXBlb2YgdHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiBbIFtwcmVmaXgsIHR5cGVdIF1cbiAgICB9XG4gICAgdmFyIGluZGljZXMgPSBbXVxuICAgIGZvcih2YXIgaWQgaW4gdHlwZSkge1xuICAgICAgdmFyIHByb3AgPSB0eXBlW2lkXVxuICAgICAgdmFyIHRwcmVmaXggPSBwcmVmaXhcbiAgICAgIGlmKHBhcnNlSW50KGlkKSArICcnID09PSBpZCkge1xuICAgICAgICB0cHJlZml4ICs9ICdbJyArIGlkICsgJ10nXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cHJlZml4ICs9ICcuJyArIGlkXG4gICAgICB9XG4gICAgICBpZih0eXBlb2YgcHJvcCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgaW5kaWNlcy5wdXNoLmFwcGx5KGluZGljZXMsIGVudW1lcmF0ZUluZGljZXModHByZWZpeCwgcHJvcCkpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbmRpY2VzLnB1c2goW3RwcmVmaXgsIHByb3BdKVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaW5kaWNlc1xuICB9XG5cbiAgZnVuY3Rpb24gbWFrZVNldHRlcih0eXBlKSB7XG4gICAgdmFyIGNvZGUgPSBbICdyZXR1cm4gZnVuY3Rpb24gdXBkYXRlUHJvcGVydHkob2JqKXsnIF1cbiAgICB2YXIgaW5kaWNlcyA9IGVudW1lcmF0ZUluZGljZXMoJycsIHR5cGUpXG4gICAgZm9yKHZhciBpPTA7IGk8aW5kaWNlcy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIGl0ZW0gPSBpbmRpY2VzW2ldXG4gICAgICB2YXIgcGF0aCA9IGl0ZW1bMF1cbiAgICAgIHZhciBpZHggID0gaXRlbVsxXVxuICAgICAgaWYobG9jYXRpb25zW2lkeF0pIHtcbiAgICAgICAgY29kZS5wdXNoKG1ha2VQcm9wU2V0dGVyKHBhdGgsIGlkeCwgdW5pZm9ybXNbaWR4XS50eXBlKSlcbiAgICAgIH1cbiAgICB9XG4gICAgY29kZS5wdXNoKCdyZXR1cm4gb2JqfScpXG4gICAgdmFyIHByb2MgPSBuZXcgRnVuY3Rpb24oJ2dsJywgJ3Byb2cnLCAnbG9jYXRpb25zJywgY29kZS5qb2luKCdcXG4nKSlcbiAgICByZXR1cm4gcHJvYyhnbCwgcHJvZ3JhbSwgbG9jYXRpb25zKVxuICB9XG5cbiAgZnVuY3Rpb24gZGVmYXVsdFZhbHVlKHR5cGUpIHtcbiAgICBzd2l0Y2godHlwZSkge1xuICAgICAgY2FzZSAnYm9vbCc6XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgY2FzZSAnaW50JzpcbiAgICAgIGNhc2UgJ3NhbXBsZXIyRCc6XG4gICAgICBjYXNlICdzYW1wbGVyQ3ViZSc6XG4gICAgICAgIHJldHVybiAwXG4gICAgICBjYXNlICdmbG9hdCc6XG4gICAgICAgIHJldHVybiAwLjBcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHZhciB2aWR4ID0gdHlwZS5pbmRleE9mKCd2ZWMnKVxuICAgICAgICBpZigwIDw9IHZpZHggJiYgdmlkeCA8PSAxICYmIHR5cGUubGVuZ3RoID09PSA0ICsgdmlkeCkge1xuICAgICAgICAgIHZhciBkID0gdHlwZS5jaGFyQ29kZUF0KHR5cGUubGVuZ3RoLTEpIC0gNDhcbiAgICAgICAgICBpZihkIDwgMiB8fCBkID4gNCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdnbC1zaGFkZXI6IEludmFsaWQgZGF0YSB0eXBlJylcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYodHlwZS5jaGFyQXQoMCkgPT09ICdiJykge1xuICAgICAgICAgICAgcmV0dXJuIGR1cChkLCBmYWxzZSlcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGR1cChkKVxuICAgICAgICB9IGVsc2UgaWYodHlwZS5pbmRleE9mKCdtYXQnKSA9PT0gMCAmJiB0eXBlLmxlbmd0aCA9PT0gNCkge1xuICAgICAgICAgIHZhciBkID0gdHlwZS5jaGFyQ29kZUF0KHR5cGUubGVuZ3RoLTEpIC0gNDhcbiAgICAgICAgICBpZihkIDwgMiB8fCBkID4gNCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdnbC1zaGFkZXI6IEludmFsaWQgdW5pZm9ybSBkaW1lbnNpb24gdHlwZSBmb3IgbWF0cml4ICcgKyBuYW1lICsgJzogJyArIHR5cGUpXG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBkdXAoW2QsZF0pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdnbC1zaGFkZXI6IFVua25vd24gdW5pZm9ybSBkYXRhIHR5cGUgZm9yICcgKyBuYW1lICsgJzogJyArIHR5cGUpXG4gICAgICAgIH1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc3RvcmVQcm9wZXJ0eShvYmosIHByb3AsIHR5cGUpIHtcbiAgICBpZih0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHZhciBjaGlsZCA9IHByb2Nlc3NPYmplY3QodHlwZSlcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIHByb3AsIHtcbiAgICAgICAgZ2V0OiBpZGVudGl0eShjaGlsZCksXG4gICAgICAgIHNldDogbWFrZVNldHRlcih0eXBlKSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZVxuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgaWYobG9jYXRpb25zW3R5cGVdKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIHByb3AsIHtcbiAgICAgICAgICBnZXQ6IG1ha2VHZXR0ZXIodHlwZSksXG4gICAgICAgICAgc2V0OiBtYWtlU2V0dGVyKHR5cGUpLFxuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2JqW3Byb3BdID0gZGVmYXVsdFZhbHVlKHVuaWZvcm1zW3R5cGVdLnR5cGUpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcHJvY2Vzc09iamVjdChvYmopIHtcbiAgICB2YXIgcmVzdWx0XG4gICAgaWYoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICByZXN1bHQgPSBuZXcgQXJyYXkob2JqLmxlbmd0aClcbiAgICAgIGZvcih2YXIgaT0wOyBpPG9iai5sZW5ndGg7ICsraSkge1xuICAgICAgICBzdG9yZVByb3BlcnR5KHJlc3VsdCwgaSwgb2JqW2ldKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSB7fVxuICAgICAgZm9yKHZhciBpZCBpbiBvYmopIHtcbiAgICAgICAgc3RvcmVQcm9wZXJ0eShyZXN1bHQsIGlkLCBvYmpbaWRdKVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICAvL1JldHVybiBkYXRhXG4gIHZhciBjb2FsbGVzY2VkID0gY29hbGxlc2NlVW5pZm9ybXModW5pZm9ybXMsIHRydWUpXG4gIHJldHVybiB7XG4gICAgZ2V0OiBpZGVudGl0eShwcm9jZXNzT2JqZWN0KGNvYWxsZXNjZWQpKSxcbiAgICBzZXQ6IG1ha2VTZXR0ZXIoY29hbGxlc2NlZCksXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzID0gbWFrZVJlZmxlY3RUeXBlc1xuXG4vL0NvbnN0cnVjdCB0eXBlIGluZm8gZm9yIHJlZmxlY3Rpb24uXG4vL1xuLy8gVGhpcyBpdGVyYXRlcyBvdmVyIHRoZSBmbGF0dGVuZWQgbGlzdCBvZiB1bmlmb3JtIHR5cGUgdmFsdWVzIGFuZCBzbWFzaGVzIHRoZW0gaW50byBhIEpTT04gb2JqZWN0LlxuLy9cbi8vIFRoZSBsZWF2ZXMgb2YgdGhlIHJlc3VsdGluZyBvYmplY3QgYXJlIGVpdGhlciBpbmRpY2VzIG9yIHR5cGUgc3RyaW5ncyByZXByZXNlbnRpbmcgcHJpbWl0aXZlIGdsc2xpZnkgdHlwZXNcbmZ1bmN0aW9uIG1ha2VSZWZsZWN0VHlwZXModW5pZm9ybXMsIHVzZUluZGV4KSB7XG4gIHZhciBvYmogPSB7fVxuICBmb3IodmFyIGk9MDsgaTx1bmlmb3Jtcy5sZW5ndGg7ICsraSkge1xuICAgIHZhciBuID0gdW5pZm9ybXNbaV0ubmFtZVxuICAgIHZhciBwYXJ0cyA9IG4uc3BsaXQoXCIuXCIpXG4gICAgdmFyIG8gPSBvYmpcbiAgICBmb3IodmFyIGo9MDsgajxwYXJ0cy5sZW5ndGg7ICsraikge1xuICAgICAgdmFyIHggPSBwYXJ0c1tqXS5zcGxpdChcIltcIilcbiAgICAgIGlmKHgubGVuZ3RoID4gMSkge1xuICAgICAgICBpZighKHhbMF0gaW4gbykpIHtcbiAgICAgICAgICBvW3hbMF1dID0gW11cbiAgICAgICAgfVxuICAgICAgICBvID0gb1t4WzBdXVxuICAgICAgICBmb3IodmFyIGs9MTsgazx4Lmxlbmd0aDsgKytrKSB7XG4gICAgICAgICAgdmFyIHkgPSBwYXJzZUludCh4W2tdKVxuICAgICAgICAgIGlmKGs8eC5sZW5ndGgtMSB8fCBqPHBhcnRzLmxlbmd0aC0xKSB7XG4gICAgICAgICAgICBpZighKHkgaW4gbykpIHtcbiAgICAgICAgICAgICAgaWYoayA8IHgubGVuZ3RoLTEpIHtcbiAgICAgICAgICAgICAgICBvW3ldID0gW11cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvW3ldID0ge31cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbyA9IG9beV1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYodXNlSW5kZXgpIHtcbiAgICAgICAgICAgICAgb1t5XSA9IGlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG9beV0gPSB1bmlmb3Jtc1tpXS50eXBlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYoaiA8IHBhcnRzLmxlbmd0aC0xKSB7XG4gICAgICAgIGlmKCEoeFswXSBpbiBvKSkge1xuICAgICAgICAgIG9beFswXV0gPSB7fVxuICAgICAgICB9XG4gICAgICAgIG8gPSBvW3hbMF1dXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZih1c2VJbmRleCkge1xuICAgICAgICAgIG9beFswXV0gPSBpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb1t4WzBdXSA9IHVuaWZvcm1zW2ldLnR5cGVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gb2JqXG59IiwibW9kdWxlLmV4cG9ydHM9cmVxdWlyZShcIi9wcm9qZWN0cy9ibGFja2ljZS9ub2RlX21vZHVsZXMvZ2wtdGV4dHVyZTJkL25vZGVfbW9kdWxlcy90eXBlZGFycmF5LXBvb2wvbm9kZV9tb2R1bGVzL2R1cC9kdXAuanNcIikiLCIndXNlIHN0cmljdCdcblxudmFyIGNyZWF0ZVVuaWZvcm1XcmFwcGVyID0gcmVxdWlyZSgnLi9saWIvY3JlYXRlLXVuaWZvcm1zJylcbnZhciBjcmVhdGVBdHRyaWJ1dGVXcmFwcGVyID0gcmVxdWlyZSgnLi9saWIvY3JlYXRlLWF0dHJpYnV0ZXMnKVxudmFyIG1ha2VSZWZsZWN0ID0gcmVxdWlyZSgnLi9saWIvcmVmbGVjdCcpXG5cbi8vU2hhZGVyIG9iamVjdFxuZnVuY3Rpb24gU2hhZGVyKGdsLCBwcm9nLCB2ZXJ0U2hhZGVyLCBmcmFnU2hhZGVyKSB7XG4gIHRoaXMuZ2wgPSBnbFxuICB0aGlzLmhhbmRsZSA9IHByb2dcbiAgdGhpcy5hdHRyaWJ1dGVzID0gbnVsbFxuICB0aGlzLnVuaWZvcm1zID0gbnVsbFxuICB0aGlzLnR5cGVzID0gbnVsbFxuICB0aGlzLnZlcnRleFNoYWRlciA9IHZlcnRTaGFkZXJcbiAgdGhpcy5mcmFnbWVudFNoYWRlciA9IGZyYWdTaGFkZXJcbn1cblxuLy9CaW5kcyB0aGUgc2hhZGVyXG5TaGFkZXIucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5nbC51c2VQcm9ncmFtKHRoaXMuaGFuZGxlKVxufVxuXG4vL0Rlc3Ryb3kgc2hhZGVyLCByZWxlYXNlIHJlc291cmNlc1xuU2hhZGVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24oKSB7XG4gIHZhciBnbCA9IHRoaXMuZ2xcbiAgZ2wuZGVsZXRlU2hhZGVyKHRoaXMudmVydGV4U2hhZGVyKVxuICBnbC5kZWxldGVTaGFkZXIodGhpcy5mcmFnbWVudFNoYWRlcilcbiAgZ2wuZGVsZXRlUHJvZ3JhbSh0aGlzLmhhbmRsZSlcbn1cblxuU2hhZGVyLnByb3RvdHlwZS51cGRhdGVFeHBvcnRzID0gZnVuY3Rpb24odW5pZm9ybXMsIGF0dHJpYnV0ZXMpIHtcbiAgdmFyIGxvY2F0aW9ucyA9IG5ldyBBcnJheSh1bmlmb3Jtcy5sZW5ndGgpXG4gIHZhciBwcm9ncmFtID0gdGhpcy5oYW5kbGVcbiAgdmFyIGdsID0gdGhpcy5nbFxuXG4gIHZhciBkb0xpbmsgPSByZWxpbmtVbmlmb3Jtcy5iaW5kKHZvaWQgMCxcbiAgICBnbCxcbiAgICBwcm9ncmFtLFxuICAgIGxvY2F0aW9ucyxcbiAgICB1bmlmb3Jtc1xuICApXG4gIGRvTGluaygpXG5cbiAgdGhpcy50eXBlcyA9IHtcbiAgICB1bmlmb3JtczogbWFrZVJlZmxlY3QodW5pZm9ybXMpLFxuICAgIGF0dHJpYnV0ZXM6IG1ha2VSZWZsZWN0KGF0dHJpYnV0ZXMpXG4gIH1cblxuICB0aGlzLmF0dHJpYnV0ZXMgPSBjcmVhdGVBdHRyaWJ1dGVXcmFwcGVyKFxuICAgIGdsLFxuICAgIHByb2dyYW0sXG4gICAgYXR0cmlidXRlcyxcbiAgICBkb0xpbmtcbiAgKVxuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAndW5pZm9ybXMnLCBjcmVhdGVVbmlmb3JtV3JhcHBlcihcbiAgICBnbCxcbiAgICBwcm9ncmFtLFxuICAgIHVuaWZvcm1zLFxuICAgIGxvY2F0aW9uc1xuICApKVxufVxuXG4vL1JlbGlua3MgYWxsIHVuaWZvcm1zXG5mdW5jdGlvbiByZWxpbmtVbmlmb3JtcyhnbCwgcHJvZ3JhbSwgbG9jYXRpb25zLCB1bmlmb3Jtcykge1xuICBmb3IodmFyIGk9MDsgaTx1bmlmb3Jtcy5sZW5ndGg7ICsraSkge1xuICAgIGxvY2F0aW9uc1tpXSA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCB1bmlmb3Jtc1tpXS5uYW1lKVxuICB9XG59XG5cbi8vQ29tcGlsZXMgYW5kIGxpbmtzIGEgc2hhZGVyIHByb2dyYW0gd2l0aCB0aGUgZ2l2ZW4gYXR0cmlidXRlIGFuZCB2ZXJ0ZXggbGlzdFxuZnVuY3Rpb24gY3JlYXRlU2hhZGVyKFxuICAgIGdsXG4gICwgdmVydFNvdXJjZVxuICAsIGZyYWdTb3VyY2VcbiAgLCB1bmlmb3Jtc1xuICAsIGF0dHJpYnV0ZXMpIHtcbiAgXG4gIC8vQ29tcGlsZSB2ZXJ0ZXggc2hhZGVyXG4gIHZhciB2ZXJ0U2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKGdsLlZFUlRFWF9TSEFERVIpXG4gIGdsLnNoYWRlclNvdXJjZSh2ZXJ0U2hhZGVyLCB2ZXJ0U291cmNlKVxuICBnbC5jb21waWxlU2hhZGVyKHZlcnRTaGFkZXIpXG4gIGlmKCFnbC5nZXRTaGFkZXJQYXJhbWV0ZXIodmVydFNoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMpKSB7XG4gICAgdmFyIGVyckxvZyA9IGdsLmdldFNoYWRlckluZm9Mb2codmVydFNoYWRlcilcbiAgICBjb25zb2xlLmVycm9yKCdnbC1zaGFkZXI6IEVycm9yIGNvbXBsaW5nIHZlcnRleCBzaGFkZXI6JywgZXJyTG9nKVxuICAgIHRocm93IG5ldyBFcnJvcignZ2wtc2hhZGVyOiBFcnJvciBjb21waWxpbmcgdmVydGV4IHNoYWRlcjonICsgZXJyTG9nKVxuICB9XG4gIFxuICAvL0NvbXBpbGUgZnJhZ21lbnQgc2hhZGVyXG4gIHZhciBmcmFnU2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKGdsLkZSQUdNRU5UX1NIQURFUilcbiAgZ2wuc2hhZGVyU291cmNlKGZyYWdTaGFkZXIsIGZyYWdTb3VyY2UpXG4gIGdsLmNvbXBpbGVTaGFkZXIoZnJhZ1NoYWRlcilcbiAgaWYoIWdsLmdldFNoYWRlclBhcmFtZXRlcihmcmFnU2hhZGVyLCBnbC5DT01QSUxFX1NUQVRVUykpIHtcbiAgICB2YXIgZXJyTG9nID0gZ2wuZ2V0U2hhZGVySW5mb0xvZyhmcmFnU2hhZGVyKVxuICAgIGNvbnNvbGUuZXJyb3IoJ2dsLXNoYWRlcjogRXJyb3IgY29tcGlsaW5nIGZyYWdtZW50IHNoYWRlcjonLCBlcnJMb2cpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdnbC1zaGFkZXI6IEVycm9yIGNvbXBpbGluZyBmcmFnbWVudCBzaGFkZXI6JyArIGVyckxvZylcbiAgfVxuICBcbiAgLy9MaW5rIHByb2dyYW1cbiAgdmFyIHByb2dyYW0gPSBnbC5jcmVhdGVQcm9ncmFtKClcbiAgZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIGZyYWdTaGFkZXIpXG4gIGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCB2ZXJ0U2hhZGVyKVxuXG4gIC8vT3B0aW9uYWwgZGVmYXVsdCBhdHRyaXVidGUgbG9jYXRpb25zXG4gIGF0dHJpYnV0ZXMuZm9yRWFjaChmdW5jdGlvbihhKSB7XG4gICAgaWYgKHR5cGVvZiBhLmxvY2F0aW9uID09PSAnbnVtYmVyJykgXG4gICAgICBnbC5iaW5kQXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgYS5sb2NhdGlvbiwgYS5uYW1lKVxuICB9KVxuXG4gIGdsLmxpbmtQcm9ncmFtKHByb2dyYW0pXG4gIGlmKCFnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHByb2dyYW0sIGdsLkxJTktfU1RBVFVTKSkge1xuICAgIHZhciBlcnJMb2cgPSBnbC5nZXRQcm9ncmFtSW5mb0xvZyhwcm9ncmFtKVxuICAgIGNvbnNvbGUuZXJyb3IoJ2dsLXNoYWRlcjogRXJyb3IgbGlua2luZyBzaGFkZXIgcHJvZ3JhbTonLCBlcnJMb2cpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdnbC1zaGFkZXI6IEVycm9yIGxpbmtpbmcgc2hhZGVyIHByb2dyYW06JyArIGVyckxvZylcbiAgfVxuICBcbiAgLy9SZXR1cm4gZmluYWwgbGlua2VkIHNoYWRlciBvYmplY3RcbiAgdmFyIHNoYWRlciA9IG5ldyBTaGFkZXIoXG4gICAgZ2wsXG4gICAgcHJvZ3JhbSxcbiAgICB2ZXJ0U2hhZGVyLFxuICAgIGZyYWdTaGFkZXJcbiAgKVxuICBzaGFkZXIudXBkYXRlRXhwb3J0cyh1bmlmb3JtcywgYXR0cmlidXRlcylcblxuICByZXR1cm4gc2hhZGVyXG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlU2hhZGVyXG4iLCJtb2R1bGUuZXhwb3J0cyA9IHByb2dyYW1pZnlcblxuZnVuY3Rpb24gcHJvZ3JhbWlmeSh2ZXJ0ZXgsIGZyYWdtZW50LCB1bmlmb3JtcywgYXR0cmlidXRlcykge1xuICByZXR1cm4ge1xuICAgIHZlcnRleDogdmVydGV4LCBcbiAgICBmcmFnbWVudDogZnJhZ21lbnQsXG4gICAgdW5pZm9ybXM6IHVuaWZvcm1zLCBcbiAgICBhdHRyaWJ1dGVzOiBhdHRyaWJ1dGVzXG4gIH07XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGltZztcblxuZnVuY3Rpb24gaW1nIChzcmMsIG9wdCwgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBvcHQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdFxuICAgIG9wdCA9IG51bGxcbiAgfVxuXG5cbiAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XG4gIHZhciBsb2NrZWQ7XG5cbiAgZWwub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChsb2NrZWQpIHJldHVybjtcbiAgICBsb2NrZWQgPSB0cnVlO1xuXG4gICAgY2FsbGJhY2sgJiYgY2FsbGJhY2sodW5kZWZpbmVkLCBlbCk7XG4gIH07XG5cbiAgZWwub25lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAobG9ja2VkKSByZXR1cm47XG4gICAgbG9ja2VkID0gdHJ1ZTtcblxuICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKG5ldyBFcnJvcignVW5hYmxlIHRvIGxvYWQgXCInICsgc3JjICsgJ1wiJyksIGVsKTtcbiAgfTtcbiAgXG4gIGlmIChvcHQgJiYgb3B0LmNyb3NzT3JpZ2luKVxuICAgIGVsLmNyb3NzT3JpZ2luID0gb3B0LmNyb3NzT3JpZ2luO1xuXG4gIGVsLnNyYyA9IHNyYztcblxuICByZXR1cm4gZWw7XG59XG4iLCJpZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgLy8gaW1wbGVtZW50YXRpb24gZnJvbSBzdGFuZGFyZCBub2RlLmpzICd1dGlsJyBtb2R1bGVcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLCB7XG4gICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICB2YWx1ZTogY3RvcixcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbn0gZWxzZSB7XG4gIC8vIG9sZCBzY2hvb2wgc2hpbSBmb3Igb2xkIGJyb3dzZXJzXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fVxuICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGVcbiAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpXG4gICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yXG4gIH1cbn1cbiIsImZ1bmN0aW9uIGxlcnAodjAsIHYxLCB0KSB7XG4gICAgcmV0dXJuIHYwKigxLXQpK3YxKnRcbn1cbm1vZHVsZS5leHBvcnRzID0gbGVycCIsInZhciB4dGVuZCA9IHJlcXVpcmUoJ3h0ZW5kJylcblxudmFyIGRlZmF1bHRzID0ge1xuXHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRjb25maWd1cmFibGU6IHRydWVcbn1cblxuZnVuY3Rpb24gbWl4KG9iaiwgZW50cmllcykge1xuXHRmb3IgKHZhciBrIGluIGVudHJpZXMpIHtcblx0XHRpZiAoIWVudHJpZXMuaGFzT3duUHJvcGVydHkoaykpXG5cdFx0XHRjb250aW51ZVxuXHRcdHZhciBmID0gZW50cmllc1trXVxuXHRcdGlmICh0eXBlb2YgZiA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0b2JqW2tdID0gZlxuXHRcdH0gZWxzZSBpZiAoZiAmJiB0eXBlb2YgZiA9PT0gJ29iamVjdCcpIHtcblx0XHRcdHZhciBkZWYgPSB4dGVuZChkZWZhdWx0cywgZilcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGssIGRlZik7XG5cdFx0fVxuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbWl4ZXMoY3RvciwgZW50cmllcykge1xuXHRtaXgoY3Rvci5wcm90b3R5cGUsIGVudHJpZXMpXG59XG5cbm1vZHVsZS5leHBvcnRzLm1peCA9IG1peCIsInZhciBib3VuZHMgPSByZXF1aXJlKCdnZXRib3VuZGluZ2JveCcpXG52YXIgdW5sZXJwID0gcmVxdWlyZSgndW5sZXJwJylcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBub3JtYWxpemUocGF0aCwgYm94KSB7XG4gICAgdmFyIGJcbiAgICBpZiAoYm94ICYmIHR5cGVvZiBib3ggPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGIgPSBib3hcbiAgICB9IGVsc2VcbiAgICAgICAgYiA9IGJvdW5kcyhwYXRoKVxuXG4gICAgLy9UT0RPOiBobW0sIGRvZXNuJ3QgcmVhbGx5IGhhbmRsZSBkaXYgYnkgemVyb1xuICAgIC8vaW4gYW55IHNhbmUgbWFubmVyXG5cbiAgICB2YXIgdyA9IChiLm1heFgtYi5taW5YKSxcbiAgICAgICAgaCA9IChiLm1heFktYi5taW5ZKVxuXG4gICAgdmFyIGFzcGVjdFggPSB3PmggPyAxIDogaC93LFxuICAgICAgICBhc3BlY3RZID0gdz5oID8gdy9oIDogMVxuXG4gICAgcmV0dXJuIHBhdGgubWFwKGZ1bmN0aW9uKHApIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHJhbmdlKGIubWluWCwgYi5tYXhYLCBwWzBdKSoxL2FzcGVjdFgsXG4gICAgICAgICAgICByYW5nZShiLm1pblksIGIubWF4WSwgcFsxXSkqMS9hc3BlY3RZXG4gICAgICAgIF1cbiAgICB9KVxufVxuXG5mdW5jdGlvbiByYW5nZShtaW4sIG1heCwgdmFsdWUpIHtcbiAgICByZXR1cm4gKChtYXgtbWluPT09MCkgPyAwIDogdW5sZXJwKG1pbiwgbWF4LCB2YWx1ZSkpKjItMVxufSIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oIHBhdGgsIGJveCwgeEtleSwgeUtleSApIHtcbiAgICB4S2V5ID0gdHlwZW9mIHhLZXkgPT09ICdzdHJpbmcnID8geEtleSA6IDA7XG4gICAgeUtleSA9IHR5cGVvZiB5S2V5ID09PSAnc3RyaW5nJyA/IHlLZXkgOiAxO1xuICAgIGlmICghYm94IHx8IHR5cGVvZiBib3ggPT09ICdudW1iZXInKVxuICAgICAgICBib3ggPSB7fTtcblxuICAgIGJveC5taW5YID0gSW5maW5pdHk7XG4gICAgYm94Lm1pblkgPSBJbmZpbml0eTtcbiAgICBib3gubWF4WCA9IC1JbmZpbml0eTtcbiAgICBib3gubWF4WSA9IC1JbmZpbml0eTtcblxuICAgIGZvciAodmFyIGk9MDsgaTxwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB4ID0gcGF0aFtpXVsgeEtleSBdLFxuICAgICAgICAgICAgeSA9IHBhdGhbaV1bIHlLZXkgXTtcbiAgICAgICAgYm94Lm1pblggPSBNYXRoLm1pbiggYm94Lm1pblgsIHggKTtcbiAgICAgICAgYm94Lm1pblkgPSBNYXRoLm1pbiggYm94Lm1pblksIHkgKTtcbiAgICAgICAgYm94Lm1heFggPSBNYXRoLm1heCggYm94Lm1heFgsIHggKTtcbiAgICAgICAgYm94Lm1heFkgPSBNYXRoLm1heCggYm94Lm1heFksIHkgKTtcbiAgICB9XG4gICAgXG4gICAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSBcbiAgICAgICAgYm94Lm1pblggPSBib3gubWF4WCA9IGJveC5taW5ZID0gYm94Lm1heFkgPSAwXG4gICAgcmV0dXJuIGJveDtcbn07IiwiXG5tb2R1bGUuZXhwb3J0cyA9IHBhcnNlXG5cbi8qKlxuICogZXhwZWN0ZWQgYXJndW1lbnQgbGVuZ3Roc1xuICogQHR5cGUge09iamVjdH1cbiAqL1xuXG52YXIgbGVuZ3RoID0ge2E6IDcsIGM6IDYsIGg6IDEsIGw6IDIsIG06IDIsIHE6IDQsIHM6IDQsIHQ6IDIsIHY6IDEsIHo6IDB9XG5cbi8qKlxuICogc2VnbWVudCBwYXR0ZXJuXG4gKiBAdHlwZSB7UmVnRXhwfVxuICovXG5cbnZhciBzZWdtZW50ID0gLyhbYXN0dnpxbWhsY10pKFteYXN0dnpxbWhsY10qKS9pZ1xuXG4vKipcbiAqIHBhcnNlIGFuIHN2ZyBwYXRoIGRhdGEgc3RyaW5nLiBHZW5lcmF0ZXMgYW4gQXJyYXlcbiAqIG9mIGNvbW1hbmRzIHdoZXJlIGVhY2ggY29tbWFuZCBpcyBhbiBBcnJheSBvZiB0aGVcbiAqIGZvcm0gYFtjb21tYW5kLCBhcmcxLCBhcmcyLCAuLi5dYFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuXG5mdW5jdGlvbiBwYXJzZShwYXRoKSB7XG5cdHZhciBkYXRhID0gW11cblx0cGF0aC5yZXBsYWNlKHNlZ21lbnQsIGZ1bmN0aW9uKF8sIGNvbW1hbmQsIGFyZ3Mpe1xuXHRcdHZhciB0eXBlID0gY29tbWFuZC50b0xvd2VyQ2FzZSgpXG5cdFx0YXJncyA9IHBhcnNlVmFsdWVzKGFyZ3MpXG5cblx0XHQvLyBvdmVybG9hZGVkIG1vdmVUb1xuXHRcdGlmICh0eXBlID09ICdtJyAmJiBhcmdzLmxlbmd0aCA+IDIpIHtcblx0XHRcdGRhdGEucHVzaChbY29tbWFuZF0uY29uY2F0KGFyZ3Muc3BsaWNlKDAsIDIpKSlcblx0XHRcdHR5cGUgPSAnbCdcblx0XHRcdGNvbW1hbmQgPSBjb21tYW5kID09ICdtJyA/ICdsJyA6ICdMJ1xuXHRcdH1cblxuXHRcdHdoaWxlICh0cnVlKSB7XG5cdFx0XHRpZiAoYXJncy5sZW5ndGggPT0gbGVuZ3RoW3R5cGVdKSB7XG5cdFx0XHRcdGFyZ3MudW5zaGlmdChjb21tYW5kKVxuXHRcdFx0XHRyZXR1cm4gZGF0YS5wdXNoKGFyZ3MpXG5cdFx0XHR9XG5cdFx0XHRpZiAoYXJncy5sZW5ndGggPCBsZW5ndGhbdHlwZV0pIHRocm93IG5ldyBFcnJvcignbWFsZm9ybWVkIHBhdGggZGF0YScpXG5cdFx0XHRkYXRhLnB1c2goW2NvbW1hbmRdLmNvbmNhdChhcmdzLnNwbGljZSgwLCBsZW5ndGhbdHlwZV0pKSlcblx0XHR9XG5cdH0pXG5cdHJldHVybiBkYXRhXG59XG5cbmZ1bmN0aW9uIHBhcnNlVmFsdWVzKGFyZ3Mpe1xuXHRhcmdzID0gYXJncy5tYXRjaCgvLT9bLjAtOV0rKD86ZVstK10/XFxkKyk/L2lnKVxuXHRyZXR1cm4gYXJncyA/IGFyZ3MubWFwKE51bWJlcikgOiBbXVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBwbHVja2VyXG5cbmZ1bmN0aW9uIHBsdWNrZXIocGF0aCwgb2JqZWN0KSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID49IDJcbiAgICA/IHBsdWNrKHBhdGgpKG9iamVjdClcbiAgICA6IHBsdWNrKHBhdGgpXG59XG5cbmZ1bmN0aW9uIHBsdWNrKHBhdGgpIHtcbiAgcGF0aCA9IHR5cGVvZiBwYXRoID09PSAnc3RyaW5nJ1xuICAgID8gU3RyaW5nKHBhdGgpLnRyaW0oKS5zcGxpdCgnLicpXG4gICAgOiBwYXRoXG5cbiAgaWYgKHBhdGgubGVuZ3RoIDwgMikge1xuICAgIHBhdGggPSBwYXRoWzBdXG4gICAgcmV0dXJuIHBsdWNrU2luZ2xlXG4gIH0gZWxzZSB7XG4gICAgdmFyIGwgPSBwYXRoLmxlbmd0aFxuICAgIHJldHVybiBwbHVja1BhdGhcbiAgfVxuXG4gIGZ1bmN0aW9uIHBsdWNrU2luZ2xlKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3RbcGF0aF1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBsdWNrUGF0aChvYmplY3QpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKHR5cGVvZiBvYmplY3QgPT09ICd1bmRlZmluZWQnKSBicmVha1xuXG4gICAgICBvYmplY3QgPSBvYmplY3RbcGF0aFtpXV1cbiAgICB9XG5cbiAgICByZXR1cm4gb2JqZWN0XG4gIH1cbn1cbiIsIi8qXHJcbiAqIHJhZi5qc1xyXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbmdyeW1hbi9yYWYuanNcclxuICpcclxuICogb3JpZ2luYWwgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIHBvbHlmaWxsIGJ5IEVyaWsgTcO2bGxlclxyXG4gKiBpbnNwaXJlZCBmcm9tIHBhdWxfaXJpc2ggZ2lzdCBhbmQgcG9zdFxyXG4gKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMgbmdyeW1hblxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXHJcbiAqL1xyXG5cclxuKGZ1bmN0aW9uKHdpbmRvdykge1xyXG5cdHZhciBsYXN0VGltZSA9IDAsXHJcblx0XHR2ZW5kb3JzID0gWyd3ZWJraXQnLCAnbW96J10sXHJcblx0XHRyZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lLFxyXG5cdFx0Y2FuY2VsQW5pbWF0aW9uRnJhbWUgPSB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUsXHJcblx0XHRpID0gdmVuZG9ycy5sZW5ndGg7XHJcblxyXG5cdC8vIHRyeSB0byB1bi1wcmVmaXggZXhpc3RpbmcgcmFmXHJcblx0d2hpbGUgKC0taSA+PSAwICYmICFyZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHtcclxuXHRcdHJlcXVlc3RBbmltYXRpb25GcmFtZSA9IHdpbmRvd1t2ZW5kb3JzW2ldICsgJ1JlcXVlc3RBbmltYXRpb25GcmFtZSddO1xyXG5cdFx0Y2FuY2VsQW5pbWF0aW9uRnJhbWUgPSB3aW5kb3dbdmVuZG9yc1tpXSArICdDYW5jZWxBbmltYXRpb25GcmFtZSddO1xyXG5cdH1cclxuXHJcblx0Ly8gcG9seWZpbGwgd2l0aCBzZXRUaW1lb3V0IGZhbGxiYWNrXHJcblx0Ly8gaGVhdmlseSBpbnNwaXJlZCBmcm9tIEBkYXJpdXMgZ2lzdCBtb2Q6IGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL3BhdWxpcmlzaC8xNTc5NjcxI2NvbW1lbnQtODM3OTQ1XHJcblx0aWYgKCFyZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgIWNhbmNlbEFuaW1hdGlvbkZyYW1lKSB7XHJcblx0XHRyZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbihjYWxsYmFjaykge1xyXG5cdFx0XHR2YXIgbm93ID0gK25ldyBEYXRlKCksIG5leHRUaW1lID0gTWF0aC5tYXgobGFzdFRpbWUgKyAxNiwgbm93KTtcclxuXHRcdFx0cmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0Y2FsbGJhY2sobGFzdFRpbWUgPSBuZXh0VGltZSk7XHJcblx0XHRcdH0sIG5leHRUaW1lIC0gbm93KTtcclxuXHRcdH07XHJcblxyXG5cdFx0Y2FuY2VsQW5pbWF0aW9uRnJhbWUgPSBjbGVhclRpbWVvdXQ7XHJcblx0fVxyXG5cclxuXHQvLyBleHBvcnQgdG8gd2luZG93XHJcblx0d2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZTtcclxuXHR3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUgPSBjYW5jZWxBbmltYXRpb25GcmFtZTtcclxufSh3aW5kb3cpKTtcclxuIiwiLy8gc3F1YXJlIGRpc3RhbmNlIGZyb20gYSBwb2ludCB0byBhIHNlZ21lbnRcbmZ1bmN0aW9uIGdldFNxU2VnRGlzdChwLCBwMSwgcDIpIHtcbiAgICB2YXIgeCA9IHAxWzBdLFxuICAgICAgICB5ID0gcDFbMV0sXG4gICAgICAgIGR4ID0gcDJbMF0gLSB4LFxuICAgICAgICBkeSA9IHAyWzFdIC0geTtcblxuICAgIGlmIChkeCAhPT0gMCB8fCBkeSAhPT0gMCkge1xuXG4gICAgICAgIHZhciB0ID0gKChwWzBdIC0geCkgKiBkeCArIChwWzFdIC0geSkgKiBkeSkgLyAoZHggKiBkeCArIGR5ICogZHkpO1xuXG4gICAgICAgIGlmICh0ID4gMSkge1xuICAgICAgICAgICAgeCA9IHAyWzBdO1xuICAgICAgICAgICAgeSA9IHAyWzFdO1xuXG4gICAgICAgIH0gZWxzZSBpZiAodCA+IDApIHtcbiAgICAgICAgICAgIHggKz0gZHggKiB0O1xuICAgICAgICAgICAgeSArPSBkeSAqIHQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkeCA9IHBbMF0gLSB4O1xuICAgIGR5ID0gcFsxXSAtIHk7XG5cbiAgICByZXR1cm4gZHggKiBkeCArIGR5ICogZHk7XG59XG5cbi8vIHNpbXBsaWZpY2F0aW9uIHVzaW5nIG9wdGltaXplZCBEb3VnbGFzLVBldWNrZXIgYWxnb3JpdGhtIHdpdGggcmVjdXJzaW9uIGVsaW1pbmF0aW9uXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNpbXBsaWZ5RG91Z2xhc1BldWNrZXIocG9pbnRzLCB0b2xlcmFuY2UpIHtcbiAgICBpZiAocG9pbnRzLmxlbmd0aDw9MSlcbiAgICAgICAgcmV0dXJuIHBvaW50cztcbiAgICB0b2xlcmFuY2UgPSB0eXBlb2YgdG9sZXJhbmNlID09PSAnbnVtYmVyJyA/IHRvbGVyYW5jZSA6IDE7XG4gICAgdmFyIHNxVG9sZXJhbmNlID0gdG9sZXJhbmNlICogdG9sZXJhbmNlO1xuXG4gICAgdmFyIGxlbiA9IHBvaW50cy5sZW5ndGgsXG4gICAgICAgIE1hcmtlckFycmF5ID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnID8gVWludDhBcnJheSA6IEFycmF5LFxuICAgICAgICBtYXJrZXJzID0gbmV3IE1hcmtlckFycmF5KGxlbiksXG4gICAgICAgIGZpcnN0ID0gMCxcbiAgICAgICAgbGFzdCA9IGxlbiAtIDEsXG4gICAgICAgIHN0YWNrID0gW10sXG4gICAgICAgIG5ld1BvaW50cyA9IFtdLFxuICAgICAgICBpLCBtYXhTcURpc3QsIHNxRGlzdCwgaW5kZXg7XG5cbiAgICBtYXJrZXJzW2ZpcnN0XSA9IG1hcmtlcnNbbGFzdF0gPSAxO1xuXG4gICAgd2hpbGUgKGxhc3QpIHtcblxuICAgICAgICBtYXhTcURpc3QgPSAwO1xuXG4gICAgICAgIGZvciAoaSA9IGZpcnN0ICsgMTsgaSA8IGxhc3Q7IGkrKykge1xuICAgICAgICAgICAgc3FEaXN0ID0gZ2V0U3FTZWdEaXN0KHBvaW50c1tpXSwgcG9pbnRzW2ZpcnN0XSwgcG9pbnRzW2xhc3RdKTtcblxuICAgICAgICAgICAgaWYgKHNxRGlzdCA+IG1heFNxRGlzdCkge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICBtYXhTcURpc3QgPSBzcURpc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWF4U3FEaXN0ID4gc3FUb2xlcmFuY2UpIHtcbiAgICAgICAgICAgIG1hcmtlcnNbaW5kZXhdID0gMTtcbiAgICAgICAgICAgIHN0YWNrLnB1c2goZmlyc3QsIGluZGV4LCBpbmRleCwgbGFzdCk7XG4gICAgICAgIH1cblxuICAgICAgICBsYXN0ID0gc3RhY2sucG9wKCk7XG4gICAgICAgIGZpcnN0ID0gc3RhY2sucG9wKCk7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmIChtYXJrZXJzW2ldKSBuZXdQb2ludHMucHVzaChwb2ludHNbaV0pO1xuICAgIH1cblxuICAgIHJldHVybiBuZXdQb2ludHM7XG59IiwidmFyIHNpbXBsaWZ5UmFkaWFsRGlzdCA9IHJlcXVpcmUoJy4vcmFkaWFsLWRpc3RhbmNlJylcbnZhciBzaW1wbGlmeURvdWdsYXNQZXVja2VyID0gcmVxdWlyZSgnLi9kb3VnbGFzLXBldWNrZXInKVxuXG4vL3NpbXBsaWZpZXMgdXNpbmcgYm90aCBhbGdvcml0aG1zXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNpbXBsaWZ5KHBvaW50cywgdG9sZXJhbmNlKSB7XG4gICAgcG9pbnRzID0gc2ltcGxpZnlSYWRpYWxEaXN0KHBvaW50cywgdG9sZXJhbmNlKTtcbiAgICBwb2ludHMgPSBzaW1wbGlmeURvdWdsYXNQZXVja2VyKHBvaW50cywgdG9sZXJhbmNlKTtcbiAgICByZXR1cm4gcG9pbnRzO1xufVxuXG5tb2R1bGUuZXhwb3J0cy5yYWRpYWxEaXN0YW5jZSA9IHNpbXBsaWZ5UmFkaWFsRGlzdDtcbm1vZHVsZS5leHBvcnRzLmRvdWdsYXNQZXVja2VyID0gc2ltcGxpZnlEb3VnbGFzUGV1Y2tlcjsiLCJmdW5jdGlvbiBnZXRTcURpc3QocDEsIHAyKSB7XG4gICAgdmFyIGR4ID0gcDFbMF0gLSBwMlswXSxcbiAgICAgICAgZHkgPSBwMVsxXSAtIHAyWzFdO1xuXG4gICAgcmV0dXJuIGR4ICogZHggKyBkeSAqIGR5O1xufVxuXG4vLyBiYXNpYyBkaXN0YW5jZS1iYXNlZCBzaW1wbGlmaWNhdGlvblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzaW1wbGlmeVJhZGlhbERpc3QocG9pbnRzLCB0b2xlcmFuY2UpIHtcbiAgICBpZiAocG9pbnRzLmxlbmd0aDw9MSlcbiAgICAgICAgcmV0dXJuIHBvaW50cztcbiAgICB0b2xlcmFuY2UgPSB0eXBlb2YgdG9sZXJhbmNlID09PSAnbnVtYmVyJyA/IHRvbGVyYW5jZSA6IDE7XG4gICAgdmFyIHNxVG9sZXJhbmNlID0gdG9sZXJhbmNlICogdG9sZXJhbmNlO1xuICAgIFxuICAgIHZhciBwcmV2UG9pbnQgPSBwb2ludHNbMF0sXG4gICAgICAgIG5ld1BvaW50cyA9IFtwcmV2UG9pbnRdLFxuICAgICAgICBwb2ludDtcblxuICAgIGZvciAodmFyIGkgPSAxLCBsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgcG9pbnQgPSBwb2ludHNbaV07XG5cbiAgICAgICAgaWYgKGdldFNxRGlzdChwb2ludCwgcHJldlBvaW50KSA+IHNxVG9sZXJhbmNlKSB7XG4gICAgICAgICAgICBuZXdQb2ludHMucHVzaChwb2ludCk7XG4gICAgICAgICAgICBwcmV2UG9pbnQgPSBwb2ludDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwcmV2UG9pbnQgIT09IHBvaW50KSBuZXdQb2ludHMucHVzaChwb2ludCk7XG5cbiAgICByZXR1cm4gbmV3UG9pbnRzO1xufSIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc21vb3Roc3RlcCAobWluLCBtYXgsIHZhbHVlKSB7XG4gIHZhciB4ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgKHZhbHVlLW1pbikvKG1heC1taW4pKSk7XG4gIHJldHVybiB4KngqKDMgLSAyKngpO1xufTtcbiIsInZhciBiZXppZXIgPSByZXF1aXJlKCdhZGFwdGl2ZS1iZXppZXItY3VydmUnKVxudmFyIGFicyA9IHJlcXVpcmUoJ2Ficy1zdmctcGF0aCcpXG52YXIgbm9ybSA9IHJlcXVpcmUoJ25vcm1hbGl6ZS1zdmctcGF0aCcpXG52YXIgY29weSA9IHJlcXVpcmUoJ3ZlYzItY29weScpXG5cbmZ1bmN0aW9uIHNldChvdXQsIHgsIHkpIHtcbiAgICBvdXRbMF0gPSB4XG4gICAgb3V0WzFdID0geVxuICAgIHJldHVybiBvdXRcbn1cblxudmFyIHRtcDEgPSBbMCwwXSxcbiAgICB0bXAyID0gWzAsMF0sXG4gICAgdG1wMyA9IFswLDBdXG5cbmZ1bmN0aW9uIGJlemllclRvKHBvaW50cywgc2NhbGUsIHN0YXJ0LCBzZWcpIHtcbiAgICBiZXppZXIoc3RhcnQsIFxuICAgICAgICBzZXQodG1wMSwgc2VnWzFdLCBzZWdbMl0pLCBcbiAgICAgICAgc2V0KHRtcDIsIHNlZ1szXSwgc2VnWzRdKSxcbiAgICAgICAgc2V0KHRtcDMsIHNlZ1s1XSwgc2VnWzZdKSwgc2NhbGUsIHBvaW50cylcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjb250b3VycyhzdmcsIHNjYWxlKSB7XG4gICAgdmFyIHBhdGhzID0gW11cblxuICAgIHZhciBwb2ludHMgPSBbXVxuICAgIHZhciBwZW4gPSBbMCwgMF1cbiAgICBub3JtKGFicyhzdmcpKS5mb3JFYWNoKGZ1bmN0aW9uKHNlZ21lbnQsIGksIHNlbGYpIHtcbiAgICAgICAgaWYgKHNlZ21lbnRbMF0gPT09ICdNJykge1xuICAgICAgICAgICAgY29weShwZW4sIHNlZ21lbnQuc2xpY2UoMSkpXG4gICAgICAgICAgICBpZiAocG9pbnRzLmxlbmd0aD4wKSB7XG4gICAgICAgICAgICAgICAgcGF0aHMucHVzaChwb2ludHMpXG4gICAgICAgICAgICAgICAgcG9pbnRzID0gW11cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvaW50cy5wdXNoKHBlbilcbiAgICAgICAgfSBlbHNlIGlmIChzZWdtZW50WzBdID09PSAnQycpIHtcbiAgICAgICAgICAgIGJlemllclRvKHBvaW50cywgc2NhbGUsIHBlbiwgc2VnbWVudClcbiAgICAgICAgICAgIHNldChwZW4sIHNlZ21lbnRbNV0sIHNlZ21lbnRbNl0pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lsbGVnYWwgdHlwZSBpbiBTVkc6ICcrc2VnbWVudFswXSlcbiAgICAgICAgfVxuICAgIH0pXG4gICAgaWYgKHBvaW50cy5sZW5ndGg+MClcbiAgICAgICAgcGF0aHMucHVzaChwb2ludHMpXG4gICAgcmV0dXJuIHBhdGhzXG59IiwiXG5tb2R1bGUuZXhwb3J0cyA9IGFic29sdXRpemVcblxuLyoqXG4gKiByZWRlZmluZSBgcGF0aGAgd2l0aCBhYnNvbHV0ZSBjb29yZGluYXRlc1xuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHBhdGhcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5cbmZ1bmN0aW9uIGFic29sdXRpemUocGF0aCl7XG5cdHZhciBzdGFydFggPSAwXG5cdHZhciBzdGFydFkgPSAwXG5cdHZhciB4ID0gMFxuXHR2YXIgeSA9IDBcblxuXHRyZXR1cm4gcGF0aC5tYXAoZnVuY3Rpb24oc2VnKXtcblx0XHRzZWcgPSBzZWcuc2xpY2UoKVxuXHRcdHZhciB0eXBlID0gc2VnWzBdXG5cdFx0dmFyIGNvbW1hbmQgPSB0eXBlLnRvVXBwZXJDYXNlKClcblxuXHRcdC8vIGlzIHJlbGF0aXZlXG5cdFx0aWYgKHR5cGUgIT0gY29tbWFuZCkge1xuXHRcdFx0c2VnWzBdID0gY29tbWFuZFxuXHRcdFx0c3dpdGNoICh0eXBlKSB7XG5cdFx0XHRcdGNhc2UgJ2EnOlxuXHRcdFx0XHRcdHNlZ1s2XSArPSB4XG5cdFx0XHRcdFx0c2VnWzddICs9IHlcblx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHRjYXNlICd2Jzpcblx0XHRcdFx0XHRzZWdbMV0gKz0geVxuXHRcdFx0XHRcdGJyZWFrXG5cdFx0XHRcdGNhc2UgJ2gnOlxuXHRcdFx0XHRcdHNlZ1sxXSArPSB4XG5cdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRmb3IgKHZhciBpID0gMTsgaSA8IHNlZy5sZW5ndGg7KSB7XG5cdFx0XHRcdFx0XHRzZWdbaSsrXSArPSB4XG5cdFx0XHRcdFx0XHRzZWdbaSsrXSArPSB5XG5cdFx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIHVwZGF0ZSBjdXJzb3Igc3RhdGVcblx0XHRzd2l0Y2ggKGNvbW1hbmQpIHtcblx0XHRcdGNhc2UgJ1onOlxuXHRcdFx0XHR4ID0gc3RhcnRYXG5cdFx0XHRcdHkgPSBzdGFydFlcblx0XHRcdFx0YnJlYWtcblx0XHRcdGNhc2UgJ0gnOlxuXHRcdFx0XHR4ID0gc2VnWzFdXG5cdFx0XHRcdGJyZWFrXG5cdFx0XHRjYXNlICdWJzpcblx0XHRcdFx0eSA9IHNlZ1sxXVxuXHRcdFx0XHRicmVha1xuXHRcdFx0Y2FzZSAnTSc6XG5cdFx0XHRcdHggPSBzdGFydFggPSBzZWdbMV1cblx0XHRcdFx0eSA9IHN0YXJ0WSA9IHNlZ1syXVxuXHRcdFx0XHRicmVha1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0eCA9IHNlZ1tzZWcubGVuZ3RoIC0gMl1cblx0XHRcdFx0eSA9IHNlZ1tzZWcubGVuZ3RoIC0gMV1cblx0XHR9XG5cblx0XHRyZXR1cm4gc2VnXG5cdH0pXG59XG4iLCJmdW5jdGlvbiBjbG9uZShwb2ludCkgeyAvL1RPRE86IHVzZSBnbC12ZWMyIGZvciB0aGlzXG4gICAgcmV0dXJuIFtwb2ludFswXSwgcG9pbnRbMV1dXG59XG5cbmZ1bmN0aW9uIHZlYzIoeCwgeSkge1xuICAgIHJldHVybiBbeCwgeV1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjcmVhdGVCZXppZXJCdWlsZGVyKG9wdCkge1xuICAgIG9wdCA9IG9wdHx8e31cblxuICAgIHZhciBSRUNVUlNJT05fTElNSVQgPSB0eXBlb2Ygb3B0LnJlY3Vyc2lvbiA9PT0gJ251bWJlcicgPyBvcHQucmVjdXJzaW9uIDogOFxuICAgIHZhciBGTFRfRVBTSUxPTiA9IHR5cGVvZiBvcHQuZXBzaWxvbiA9PT0gJ251bWJlcicgPyBvcHQuZXBzaWxvbiA6IDEuMTkyMDkyOTBlLTdcbiAgICB2YXIgUEFUSF9ESVNUQU5DRV9FUFNJTE9OID0gdHlwZW9mIG9wdC5wYXRoRXBzaWxvbiA9PT0gJ251bWJlcicgPyBvcHQucGF0aEVwc2lsb24gOiAxLjBcblxuICAgIHZhciBjdXJ2ZV9hbmdsZV90b2xlcmFuY2VfZXBzaWxvbiA9IHR5cGVvZiBvcHQuYW5nbGVFcHNpbG9uID09PSAnbnVtYmVyJyA/IG9wdC5hbmdsZUVwc2lsb24gOiAwLjAxXG4gICAgdmFyIG1fYW5nbGVfdG9sZXJhbmNlID0gb3B0LmFuZ2xlVG9sZXJhbmNlIHx8IDBcbiAgICB2YXIgbV9jdXNwX2xpbWl0ID0gb3B0LmN1c3BMaW1pdCB8fCAwXG5cbiAgICByZXR1cm4gZnVuY3Rpb24gYmV6aWVyQ3VydmUoc3RhcnQsIGMxLCBjMiwgZW5kLCBzY2FsZSwgcG9pbnRzKSB7XG4gICAgICAgIGlmICghcG9pbnRzKVxuICAgICAgICAgICAgcG9pbnRzID0gW11cblxuICAgICAgICBzY2FsZSA9IHR5cGVvZiBzY2FsZSA9PT0gJ251bWJlcicgPyBzY2FsZSA6IDEuMFxuICAgICAgICB2YXIgZGlzdGFuY2VUb2xlcmFuY2UgPSBQQVRIX0RJU1RBTkNFX0VQU0lMT04gLyBzY2FsZVxuICAgICAgICBkaXN0YW5jZVRvbGVyYW5jZSAqPSBkaXN0YW5jZVRvbGVyYW5jZVxuICAgICAgICBiZWdpbihzdGFydCwgYzEsIGMyLCBlbmQsIHBvaW50cywgZGlzdGFuY2VUb2xlcmFuY2UpXG4gICAgICAgIHJldHVybiBwb2ludHNcbiAgICB9XG5cblxuICAgIC8vLy8vLyBCYXNlZCBvbjpcbiAgICAvLy8vLy8gaHR0cHM6Ly9naXRodWIuY29tL3BlbHNvbi9hbnRpZ3JhaW4vYmxvYi9tYXN0ZXIvYWdnLTIuNC9zcmMvYWdnX2N1cnZlcy5jcHBcblxuICAgIGZ1bmN0aW9uIGJlZ2luKHN0YXJ0LCBjMSwgYzIsIGVuZCwgcG9pbnRzLCBkaXN0YW5jZVRvbGVyYW5jZSkge1xuICAgICAgICBwb2ludHMucHVzaChjbG9uZShzdGFydCkpXG4gICAgICAgIHZhciB4MSA9IHN0YXJ0WzBdLFxuICAgICAgICAgICAgeTEgPSBzdGFydFsxXSxcbiAgICAgICAgICAgIHgyID0gYzFbMF0sXG4gICAgICAgICAgICB5MiA9IGMxWzFdLFxuICAgICAgICAgICAgeDMgPSBjMlswXSxcbiAgICAgICAgICAgIHkzID0gYzJbMV0sXG4gICAgICAgICAgICB4NCA9IGVuZFswXSxcbiAgICAgICAgICAgIHk0ID0gZW5kWzFdXG4gICAgICAgIHJlY3Vyc2l2ZSh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCB4NCwgeTQsIHBvaW50cywgZGlzdGFuY2VUb2xlcmFuY2UsIDApXG4gICAgICAgIHBvaW50cy5wdXNoKGNsb25lKGVuZCkpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVjdXJzaXZlKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIHg0LCB5NCwgcG9pbnRzLCBkaXN0YW5jZVRvbGVyYW5jZSwgbGV2ZWwpIHtcbiAgICAgICAgaWYobGV2ZWwgPiBSRUNVUlNJT05fTElNSVQpIFxuICAgICAgICAgICAgcmV0dXJuXG5cbiAgICAgICAgdmFyIHBpID0gTWF0aC5QSVxuXG4gICAgICAgIC8vIENhbGN1bGF0ZSBhbGwgdGhlIG1pZC1wb2ludHMgb2YgdGhlIGxpbmUgc2VnbWVudHNcbiAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIHZhciB4MTIgICA9ICh4MSArIHgyKSAvIDJcbiAgICAgICAgdmFyIHkxMiAgID0gKHkxICsgeTIpIC8gMlxuICAgICAgICB2YXIgeDIzICAgPSAoeDIgKyB4MykgLyAyXG4gICAgICAgIHZhciB5MjMgICA9ICh5MiArIHkzKSAvIDJcbiAgICAgICAgdmFyIHgzNCAgID0gKHgzICsgeDQpIC8gMlxuICAgICAgICB2YXIgeTM0ICAgPSAoeTMgKyB5NCkgLyAyXG4gICAgICAgIHZhciB4MTIzICA9ICh4MTIgKyB4MjMpIC8gMlxuICAgICAgICB2YXIgeTEyMyAgPSAoeTEyICsgeTIzKSAvIDJcbiAgICAgICAgdmFyIHgyMzQgID0gKHgyMyArIHgzNCkgLyAyXG4gICAgICAgIHZhciB5MjM0ICA9ICh5MjMgKyB5MzQpIC8gMlxuICAgICAgICB2YXIgeDEyMzQgPSAoeDEyMyArIHgyMzQpIC8gMlxuICAgICAgICB2YXIgeTEyMzQgPSAoeTEyMyArIHkyMzQpIC8gMlxuXG4gICAgICAgIGlmKGxldmVsID4gMCkgeyAvLyBFbmZvcmNlIHN1YmRpdmlzaW9uIGZpcnN0IHRpbWVcbiAgICAgICAgICAgIC8vIFRyeSB0byBhcHByb3hpbWF0ZSB0aGUgZnVsbCBjdWJpYyBjdXJ2ZSBieSBhIHNpbmdsZSBzdHJhaWdodCBsaW5lXG4gICAgICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgdmFyIGR4ID0geDQteDFcbiAgICAgICAgICAgIHZhciBkeSA9IHk0LXkxXG5cbiAgICAgICAgICAgIHZhciBkMiA9IE1hdGguYWJzKCh4MiAtIHg0KSAqIGR5IC0gKHkyIC0geTQpICogZHgpXG4gICAgICAgICAgICB2YXIgZDMgPSBNYXRoLmFicygoeDMgLSB4NCkgKiBkeSAtICh5MyAtIHk0KSAqIGR4KVxuXG4gICAgICAgICAgICB2YXIgZGExLCBkYTJcblxuICAgICAgICAgICAgaWYoZDIgPiBGTFRfRVBTSUxPTiAmJiBkMyA+IEZMVF9FUFNJTE9OKSB7XG4gICAgICAgICAgICAgICAgLy8gUmVndWxhciBjYXJlXG4gICAgICAgICAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgICAgIGlmKChkMiArIGQzKSooZDIgKyBkMykgPD0gZGlzdGFuY2VUb2xlcmFuY2UgKiAoZHgqZHggKyBkeSpkeSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIGN1cnZhdHVyZSBkb2Vzbid0IGV4Y2VlZCB0aGUgZGlzdGFuY2VUb2xlcmFuY2UgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgLy8gd2UgdGVuZCB0byBmaW5pc2ggc3ViZGl2aXNpb25zLlxuICAgICAgICAgICAgICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgICAgICAgICAgaWYobV9hbmdsZV90b2xlcmFuY2UgPCBjdXJ2ZV9hbmdsZV90b2xlcmFuY2VfZXBzaWxvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2godmVjMih4MTIzNCwgeTEyMzQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBBbmdsZSAmIEN1c3AgQ29uZGl0aW9uXG4gICAgICAgICAgICAgICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgICAgICAgICB2YXIgYTIzID0gTWF0aC5hdGFuMih5MyAtIHkyLCB4MyAtIHgyKVxuICAgICAgICAgICAgICAgICAgICBkYTEgPSBNYXRoLmFicyhhMjMgLSBNYXRoLmF0YW4yKHkyIC0geTEsIHgyIC0geDEpKVxuICAgICAgICAgICAgICAgICAgICBkYTIgPSBNYXRoLmFicyhNYXRoLmF0YW4yKHk0IC0geTMsIHg0IC0geDMpIC0gYTIzKVxuICAgICAgICAgICAgICAgICAgICBpZihkYTEgPj0gcGkpIGRhMSA9IDIqcGkgLSBkYTFcbiAgICAgICAgICAgICAgICAgICAgaWYoZGEyID49IHBpKSBkYTIgPSAyKnBpIC0gZGEyXG5cbiAgICAgICAgICAgICAgICAgICAgaWYoZGExICsgZGEyIDwgbV9hbmdsZV90b2xlcmFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpbmFsbHkgd2UgY2FuIHN0b3AgdGhlIHJlY3Vyc2lvblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaCh2ZWMyKHgxMjM0LCB5MTIzNCkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmKG1fY3VzcF9saW1pdCAhPT0gMC4wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihkYTEgPiBtX2N1c3BfbGltaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaCh2ZWMyKHgyLCB5MikpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGRhMiA+IG1fY3VzcF9saW1pdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKHZlYzIoeDMsIHkzKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmKGQyID4gRkxUX0VQU0lMT04pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcDEscDMscDQgYXJlIGNvbGxpbmVhciwgcDIgaXMgY29uc2lkZXJhYmxlXG4gICAgICAgICAgICAgICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgICAgICAgICBpZihkMiAqIGQyIDw9IGRpc3RhbmNlVG9sZXJhbmNlICogKGR4KmR4ICsgZHkqZHkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihtX2FuZ2xlX3RvbGVyYW5jZSA8IGN1cnZlX2FuZ2xlX3RvbGVyYW5jZV9lcHNpbG9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2godmVjMih4MTIzNCwgeTEyMzQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBbmdsZSBDb25kaXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgICAgICAgICAgICAgZGExID0gTWF0aC5hYnMoTWF0aC5hdGFuMih5MyAtIHkyLCB4MyAtIHgyKSAtIE1hdGguYXRhbjIoeTIgLSB5MSwgeDIgLSB4MSkpXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihkYTEgPj0gcGkpIGRhMSA9IDIqcGkgLSBkYTFcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoZGExIDwgbV9hbmdsZV90b2xlcmFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaCh2ZWMyKHgyLCB5MikpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2godmVjMih4MywgeTMpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihtX2N1c3BfbGltaXQgIT09IDAuMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGRhMSA+IG1fY3VzcF9saW1pdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaCh2ZWMyKHgyLCB5MikpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmKGQzID4gRkxUX0VQU0lMT04pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcDEscDIscDQgYXJlIGNvbGxpbmVhciwgcDMgaXMgY29uc2lkZXJhYmxlXG4gICAgICAgICAgICAgICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgICAgICAgICBpZihkMyAqIGQzIDw9IGRpc3RhbmNlVG9sZXJhbmNlICogKGR4KmR4ICsgZHkqZHkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihtX2FuZ2xlX3RvbGVyYW5jZSA8IGN1cnZlX2FuZ2xlX3RvbGVyYW5jZV9lcHNpbG9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2godmVjMih4MTIzNCwgeTEyMzQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBbmdsZSBDb25kaXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgICAgICAgICAgICAgZGExID0gTWF0aC5hYnMoTWF0aC5hdGFuMih5NCAtIHkzLCB4NCAtIHgzKSAtIE1hdGguYXRhbjIoeTMgLSB5MiwgeDMgLSB4MikpXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihkYTEgPj0gcGkpIGRhMSA9IDIqcGkgLSBkYTFcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoZGExIDwgbV9hbmdsZV90b2xlcmFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaCh2ZWMyKHgyLCB5MikpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2godmVjMih4MywgeTMpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihtX2N1c3BfbGltaXQgIT09IDAuMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGRhMSA+IG1fY3VzcF9saW1pdClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKHZlYzIoeDMsIHkzKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBDb2xsaW5lYXIgY2FzZVxuICAgICAgICAgICAgICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgICAgICAgICAgICAgIGR4ID0geDEyMzQgLSAoeDEgKyB4NCkgLyAyXG4gICAgICAgICAgICAgICAgICAgIGR5ID0geTEyMzQgLSAoeTEgKyB5NCkgLyAyXG4gICAgICAgICAgICAgICAgICAgIGlmKGR4KmR4ICsgZHkqZHkgPD0gZGlzdGFuY2VUb2xlcmFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKHZlYzIoeDEyMzQsIHkxMjM0KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ29udGludWUgc3ViZGl2aXNpb25cbiAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIHJlY3Vyc2l2ZSh4MSwgeTEsIHgxMiwgeTEyLCB4MTIzLCB5MTIzLCB4MTIzNCwgeTEyMzQsIHBvaW50cywgZGlzdGFuY2VUb2xlcmFuY2UsIGxldmVsICsgMSkgXG4gICAgICAgIHJlY3Vyc2l2ZSh4MTIzNCwgeTEyMzQsIHgyMzQsIHkyMzQsIHgzNCwgeTM0LCB4NCwgeTQsIHBvaW50cywgZGlzdGFuY2VUb2xlcmFuY2UsIGxldmVsICsgMSkgXG4gICAgfVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Z1bmN0aW9uJykoKSIsIlxudmFyIM+AID0gTWF0aC5QSVxudmFyIF8xMjAgPSByYWRpYW5zKDEyMClcblxubW9kdWxlLmV4cG9ydHMgPSBub3JtYWxpemVcblxuLyoqXG4gKiBkZXNjcmliZSBgcGF0aGAgaW4gdGVybXMgb2YgY3ViaWMgYsOpemllciBcbiAqIGN1cnZlcyBhbmQgbW92ZSBjb21tYW5kc1xuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHBhdGhcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZShwYXRoKXtcblx0Ly8gaW5pdCBzdGF0ZVxuXHR2YXIgcHJldlxuXHR2YXIgcmVzdWx0ID0gW11cblx0dmFyIGJlemllclggPSAwXG5cdHZhciBiZXppZXJZID0gMFxuXHR2YXIgc3RhcnRYID0gMFxuXHR2YXIgc3RhcnRZID0gMFxuXHR2YXIgcXVhZFggPSBudWxsXG5cdHZhciBxdWFkWSA9IG51bGxcblx0dmFyIHggPSAwXG5cdHZhciB5ID0gMFxuXG5cdGZvciAodmFyIGkgPSAwLCBsZW4gPSBwYXRoLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0dmFyIHNlZyA9IHBhdGhbaV1cblx0XHR2YXIgY29tbWFuZCA9IHNlZ1swXVxuXHRcdHN3aXRjaCAoY29tbWFuZCkge1xuXHRcdFx0Y2FzZSAnTSc6XG5cdFx0XHRcdHN0YXJ0WCA9IHNlZ1sxXVxuXHRcdFx0XHRzdGFydFkgPSBzZWdbMl1cblx0XHRcdFx0YnJlYWtcblx0XHRcdGNhc2UgJ0EnOlxuXHRcdFx0XHRzZWcgPSBhcmMoeCwgeSxzZWdbMV0sc2VnWzJdLHJhZGlhbnMoc2VnWzNdKSxzZWdbNF0sc2VnWzVdLHNlZ1s2XSxzZWdbN10pXG5cdFx0XHRcdC8vIHNwbGl0IG11bHRpIHBhcnRcblx0XHRcdFx0c2VnLnVuc2hpZnQoJ0MnKVxuXHRcdFx0XHRpZiAoc2VnLmxlbmd0aCA+IDcpIHtcblx0XHRcdFx0XHRyZXN1bHQucHVzaChzZWcuc3BsaWNlKDAsIDcpKVxuXHRcdFx0XHRcdHNlZy51bnNoaWZ0KCdDJylcblx0XHRcdFx0fVxuXHRcdFx0XHRicmVha1xuXHRcdFx0Y2FzZSAnUyc6XG5cdFx0XHRcdC8vIGRlZmF1bHQgY29udHJvbCBwb2ludFxuXHRcdFx0XHR2YXIgY3ggPSB4XG5cdFx0XHRcdHZhciBjeSA9IHlcblx0XHRcdFx0aWYgKHByZXYgPT0gJ0MnIHx8IHByZXYgPT0gJ1MnKSB7XG5cdFx0XHRcdFx0Y3ggKz0gY3ggLSBiZXppZXJYIC8vIHJlZmxlY3QgdGhlIHByZXZpb3VzIGNvbW1hbmQncyBjb250cm9sXG5cdFx0XHRcdFx0Y3kgKz0gY3kgLSBiZXppZXJZIC8vIHBvaW50IHJlbGF0aXZlIHRvIHRoZSBjdXJyZW50IHBvaW50XG5cdFx0XHRcdH1cblx0XHRcdFx0c2VnID0gWydDJywgY3gsIGN5LCBzZWdbMV0sIHNlZ1syXSwgc2VnWzNdLCBzZWdbNF1dXG5cdFx0XHRcdGJyZWFrXG5cdFx0XHRjYXNlICdUJzpcblx0XHRcdFx0aWYgKHByZXYgPT0gJ1EnIHx8IHByZXYgPT0gJ1QnKSB7XG5cdFx0XHRcdFx0cXVhZFggPSB4ICogMiAtIHF1YWRYIC8vIGFzIHdpdGggJ1MnIHJlZmxlY3QgcHJldmlvdXMgY29udHJvbCBwb2ludFxuXHRcdFx0XHRcdHF1YWRZID0geSAqIDIgLSBxdWFkWVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHF1YWRYID0geFxuXHRcdFx0XHRcdHF1YWRZID0geVxuXHRcdFx0XHR9XG5cdFx0XHRcdHNlZyA9IHF1YWRyYXRpYyh4LCB5LCBxdWFkWCwgcXVhZFksIHNlZ1sxXSwgc2VnWzJdKVxuXHRcdFx0XHRicmVha1xuXHRcdFx0Y2FzZSAnUSc6XG5cdFx0XHRcdHF1YWRYID0gc2VnWzFdXG5cdFx0XHRcdHF1YWRZID0gc2VnWzJdXG5cdFx0XHRcdHNlZyA9IHF1YWRyYXRpYyh4LCB5LCBzZWdbMV0sIHNlZ1syXSwgc2VnWzNdLCBzZWdbNF0pXG5cdFx0XHRcdGJyZWFrXG5cdFx0XHRjYXNlICdMJzpcblx0XHRcdFx0c2VnID0gbGluZSh4LCB5LCBzZWdbMV0sIHNlZ1syXSlcblx0XHRcdFx0YnJlYWtcblx0XHRcdGNhc2UgJ0gnOlxuXHRcdFx0XHRzZWcgPSBsaW5lKHgsIHksIHNlZ1sxXSwgeSlcblx0XHRcdFx0YnJlYWtcblx0XHRcdGNhc2UgJ1YnOlxuXHRcdFx0XHRzZWcgPSBsaW5lKHgsIHksIHgsIHNlZ1sxXSlcblx0XHRcdFx0YnJlYWtcblx0XHRcdGNhc2UgJ1onOlxuXHRcdFx0XHRzZWcgPSBsaW5lKHgsIHksIHN0YXJ0WCwgc3RhcnRZKVxuXHRcdFx0XHRicmVha1xuXHRcdH1cblxuXHRcdC8vIHVwZGF0ZSBzdGF0ZVxuXHRcdHByZXYgPSBjb21tYW5kXG5cdFx0eCA9IHNlZ1tzZWcubGVuZ3RoIC0gMl1cblx0XHR5ID0gc2VnW3NlZy5sZW5ndGggLSAxXVxuXHRcdGlmIChzZWcubGVuZ3RoID4gNCkge1xuXHRcdFx0YmV6aWVyWCA9IHNlZ1tzZWcubGVuZ3RoIC0gNF1cblx0XHRcdGJlemllclkgPSBzZWdbc2VnLmxlbmd0aCAtIDNdXG5cdFx0fSBlbHNlIHtcblx0XHRcdGJlemllclggPSB4XG5cdFx0XHRiZXppZXJZID0geVxuXHRcdH1cblx0XHRyZXN1bHQucHVzaChzZWcpXG5cdH1cblxuXHRyZXR1cm4gcmVzdWx0XG59XG5cbmZ1bmN0aW9uIGxpbmUoeDEsIHkxLCB4MiwgeTIpe1xuXHRyZXR1cm4gWydDJywgeDEsIHkxLCB4MiwgeTIsIHgyLCB5Ml1cbn1cblxuZnVuY3Rpb24gcXVhZHJhdGljKHgxLCB5MSwgY3gsIGN5LCB4MiwgeTIpe1xuXHRyZXR1cm4gW1xuXHRcdCdDJyxcblx0XHR4MS8zICsgKDIvMykgKiBjeCxcblx0XHR5MS8zICsgKDIvMykgKiBjeSxcblx0XHR4Mi8zICsgKDIvMykgKiBjeCxcblx0XHR5Mi8zICsgKDIvMykgKiBjeSxcblx0XHR4Mixcblx0XHR5MlxuXHRdXG59XG5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgcmlwcGVkIGZyb20gXG4vLyBnaXRodWIuY29tL0RtaXRyeUJhcmFub3Zza2l5L3JhcGhhZWwvYmxvYi80ZDk3ZDQvcmFwaGFlbC5qcyNMMjIxNi1MMjMwNCBcbi8vIHdoaWNoIHJlZmVyZW5jZXMgdzMub3JnL1RSL1NWRzExL2ltcGxub3RlLmh0bWwjQXJjSW1wbGVtZW50YXRpb25Ob3Rlc1xuLy8gVE9ETzogbWFrZSBpdCBodW1hbiByZWFkYWJsZVxuXG5mdW5jdGlvbiBhcmMoeDEsIHkxLCByeCwgcnksIGFuZ2xlLCBsYXJnZV9hcmNfZmxhZywgc3dlZXBfZmxhZywgeDIsIHkyLCByZWN1cnNpdmUpIHtcblx0aWYgKCFyZWN1cnNpdmUpIHtcblx0XHR2YXIgeHkgPSByb3RhdGUoeDEsIHkxLCAtYW5nbGUpXG5cdFx0eDEgPSB4eS54XG5cdFx0eTEgPSB4eS55XG5cdFx0eHkgPSByb3RhdGUoeDIsIHkyLCAtYW5nbGUpXG5cdFx0eDIgPSB4eS54XG5cdFx0eTIgPSB4eS55XG5cdFx0dmFyIHggPSAoeDEgLSB4MikgLyAyXG5cdFx0dmFyIHkgPSAoeTEgLSB5MikgLyAyXG5cdFx0dmFyIGggPSAoeCAqIHgpIC8gKHJ4ICogcngpICsgKHkgKiB5KSAvIChyeSAqIHJ5KVxuXHRcdGlmIChoID4gMSkge1xuXHRcdFx0aCA9IE1hdGguc3FydChoKVxuXHRcdFx0cnggPSBoICogcnhcblx0XHRcdHJ5ID0gaCAqIHJ5XG5cdFx0fVxuXHRcdHZhciByeDIgPSByeCAqIHJ4XG5cdFx0dmFyIHJ5MiA9IHJ5ICogcnlcblx0XHR2YXIgayA9IChsYXJnZV9hcmNfZmxhZyA9PSBzd2VlcF9mbGFnID8gLTEgOiAxKVxuXHRcdFx0KiBNYXRoLnNxcnQoTWF0aC5hYnMoKHJ4MiAqIHJ5MiAtIHJ4MiAqIHkgKiB5IC0gcnkyICogeCAqIHgpIC8gKHJ4MiAqIHkgKiB5ICsgcnkyICogeCAqIHgpKSlcblx0XHRpZiAoayA9PSBJbmZpbml0eSkgayA9IDEgLy8gbmV1dHJhbGl6ZVxuXHRcdHZhciBjeCA9IGsgKiByeCAqIHkgLyByeSArICh4MSArIHgyKSAvIDJcblx0XHR2YXIgY3kgPSBrICogLXJ5ICogeCAvIHJ4ICsgKHkxICsgeTIpIC8gMlxuXHRcdHZhciBmMSA9IE1hdGguYXNpbigoKHkxIC0gY3kpIC8gcnkpLnRvRml4ZWQoOSkpXG5cdFx0dmFyIGYyID0gTWF0aC5hc2luKCgoeTIgLSBjeSkgLyByeSkudG9GaXhlZCg5KSlcblxuXHRcdGYxID0geDEgPCBjeCA/IM+AIC0gZjEgOiBmMVxuXHRcdGYyID0geDIgPCBjeCA/IM+AIC0gZjIgOiBmMlxuXHRcdGlmIChmMSA8IDApIGYxID0gz4AgKiAyICsgZjFcblx0XHRpZiAoZjIgPCAwKSBmMiA9IM+AICogMiArIGYyXG5cdFx0aWYgKHN3ZWVwX2ZsYWcgJiYgZjEgPiBmMikgZjEgPSBmMSAtIM+AICogMlxuXHRcdGlmICghc3dlZXBfZmxhZyAmJiBmMiA+IGYxKSBmMiA9IGYyIC0gz4AgKiAyXG5cdH0gZWxzZSB7XG5cdFx0ZjEgPSByZWN1cnNpdmVbMF1cblx0XHRmMiA9IHJlY3Vyc2l2ZVsxXVxuXHRcdGN4ID0gcmVjdXJzaXZlWzJdXG5cdFx0Y3kgPSByZWN1cnNpdmVbM11cblx0fVxuXHQvLyBncmVhdGVyIHRoYW4gMTIwIGRlZ3JlZXMgcmVxdWlyZXMgbXVsdGlwbGUgc2VnbWVudHNcblx0aWYgKE1hdGguYWJzKGYyIC0gZjEpID4gXzEyMCkge1xuXHRcdHZhciBmMm9sZCA9IGYyXG5cdFx0dmFyIHgyb2xkID0geDJcblx0XHR2YXIgeTJvbGQgPSB5MlxuXHRcdGYyID0gZjEgKyBfMTIwICogKHN3ZWVwX2ZsYWcgJiYgZjIgPiBmMSA/IDEgOiAtMSlcblx0XHR4MiA9IGN4ICsgcnggKiBNYXRoLmNvcyhmMilcblx0XHR5MiA9IGN5ICsgcnkgKiBNYXRoLnNpbihmMilcblx0XHR2YXIgcmVzID0gYXJjKHgyLCB5MiwgcngsIHJ5LCBhbmdsZSwgMCwgc3dlZXBfZmxhZywgeDJvbGQsIHkyb2xkLCBbZjIsIGYyb2xkLCBjeCwgY3ldKVxuXHR9XG5cdHZhciB0ID0gTWF0aC50YW4oKGYyIC0gZjEpIC8gNClcblx0dmFyIGh4ID0gNCAvIDMgKiByeCAqIHRcblx0dmFyIGh5ID0gNCAvIDMgKiByeSAqIHRcblx0dmFyIGN1cnZlID0gW1xuXHRcdDIgKiB4MSAtICh4MSArIGh4ICogTWF0aC5zaW4oZjEpKSxcblx0XHQyICogeTEgLSAoeTEgLSBoeSAqIE1hdGguY29zKGYxKSksXG5cdFx0eDIgKyBoeCAqIE1hdGguc2luKGYyKSxcblx0XHR5MiAtIGh5ICogTWF0aC5jb3MoZjIpLFxuXHRcdHgyLFxuXHRcdHkyXG5cdF1cblx0aWYgKHJlY3Vyc2l2ZSkgcmV0dXJuIGN1cnZlXG5cdGlmIChyZXMpIGN1cnZlID0gY3VydmUuY29uY2F0KHJlcylcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBjdXJ2ZS5sZW5ndGg7KSB7XG5cdFx0dmFyIHJvdCA9IHJvdGF0ZShjdXJ2ZVtpXSwgY3VydmVbaSsxXSwgYW5nbGUpXG5cdFx0Y3VydmVbaSsrXSA9IHJvdC54XG5cdFx0Y3VydmVbaSsrXSA9IHJvdC55XG5cdH1cblx0cmV0dXJuIGN1cnZlXG59XG5cbmZ1bmN0aW9uIHJvdGF0ZSh4LCB5LCByYWQpe1xuXHRyZXR1cm4ge1xuXHRcdHg6IHggKiBNYXRoLmNvcyhyYWQpIC0geSAqIE1hdGguc2luKHJhZCksXG5cdFx0eTogeCAqIE1hdGguc2luKHJhZCkgKyB5ICogTWF0aC5jb3MocmFkKVxuXHR9XG59XG5cbmZ1bmN0aW9uIHJhZGlhbnMoZGVncmVzcyl7XG5cdHJldHVybiBkZWdyZXNzICogKM+AIC8gMTgwKVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB2ZWMyQ29weShvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSBhWzBdXG4gICAgb3V0WzFdID0gYVsxXVxuICAgIHJldHVybiBvdXRcbn0iLCIvKipcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihUSFJFRSkge1xuICB2YXIgQ29weVNoYWRlciA9IEVmZmVjdENvbXBvc2VyLkNvcHlTaGFkZXIgPSByZXF1aXJlKCd0aHJlZS1jb3B5c2hhZGVyJylcbiAgICAsIFJlbmRlclBhc3MgPSBFZmZlY3RDb21wb3Nlci5SZW5kZXJQYXNzID0gcmVxdWlyZSgnLi9saWIvcmVuZGVycGFzcycpKFRIUkVFKVxuICAgICwgU2hhZGVyUGFzcyA9IEVmZmVjdENvbXBvc2VyLlNoYWRlclBhc3MgPSByZXF1aXJlKCcuL2xpYi9zaGFkZXJwYXNzJykoVEhSRUUsIEVmZmVjdENvbXBvc2VyKVxuICAgICwgTWFza1Bhc3MgPSBFZmZlY3RDb21wb3Nlci5NYXNrUGFzcyA9IHJlcXVpcmUoJy4vbGliL21hc2twYXNzJykoVEhSRUUpXG4gICAgLCBDbGVhck1hc2tQYXNzID0gRWZmZWN0Q29tcG9zZXIuQ2xlYXJNYXNrUGFzcyA9IHJlcXVpcmUoJy4vbGliL2NsZWFybWFza3Bhc3MnKShUSFJFRSlcblxuICBmdW5jdGlvbiBFZmZlY3RDb21wb3NlciggcmVuZGVyZXIsIHJlbmRlclRhcmdldCApIHtcbiAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG5cbiAgICBpZiAoIHJlbmRlclRhcmdldCA9PT0gdW5kZWZpbmVkICkge1xuICAgICAgdmFyIHdpZHRoID0gd2luZG93LmlubmVyV2lkdGggfHwgMTtcbiAgICAgIHZhciBoZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQgfHwgMTtcbiAgICAgIHZhciBwYXJhbWV0ZXJzID0geyBtaW5GaWx0ZXI6IFRIUkVFLkxpbmVhckZpbHRlciwgbWFnRmlsdGVyOiBUSFJFRS5MaW5lYXJGaWx0ZXIsIGZvcm1hdDogVEhSRUUuUkdCRm9ybWF0LCBzdGVuY2lsQnVmZmVyOiBmYWxzZSB9O1xuXG4gICAgICByZW5kZXJUYXJnZXQgPSBuZXcgVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQoIHdpZHRoLCBoZWlnaHQsIHBhcmFtZXRlcnMgKTtcbiAgICB9XG5cbiAgICB0aGlzLnJlbmRlclRhcmdldDEgPSByZW5kZXJUYXJnZXQ7XG4gICAgdGhpcy5yZW5kZXJUYXJnZXQyID0gcmVuZGVyVGFyZ2V0LmNsb25lKCk7XG5cbiAgICB0aGlzLndyaXRlQnVmZmVyID0gdGhpcy5yZW5kZXJUYXJnZXQxO1xuICAgIHRoaXMucmVhZEJ1ZmZlciA9IHRoaXMucmVuZGVyVGFyZ2V0MjtcblxuICAgIHRoaXMucGFzc2VzID0gW107XG5cbiAgICB0aGlzLmNvcHlQYXNzID0gbmV3IFNoYWRlclBhc3MoIENvcHlTaGFkZXIgKTtcbiAgfTtcblxuICBFZmZlY3RDb21wb3Nlci5wcm90b3R5cGUgPSB7XG4gICAgc3dhcEJ1ZmZlcnM6IGZ1bmN0aW9uKCkge1xuXG4gICAgICB2YXIgdG1wID0gdGhpcy5yZWFkQnVmZmVyO1xuICAgICAgdGhpcy5yZWFkQnVmZmVyID0gdGhpcy53cml0ZUJ1ZmZlcjtcbiAgICAgIHRoaXMud3JpdGVCdWZmZXIgPSB0bXA7XG5cbiAgICB9LFxuXG4gICAgYWRkUGFzczogZnVuY3Rpb24gKCBwYXNzICkge1xuXG4gICAgICB0aGlzLnBhc3Nlcy5wdXNoKCBwYXNzICk7XG5cbiAgICB9LFxuXG4gICAgaW5zZXJ0UGFzczogZnVuY3Rpb24gKCBwYXNzLCBpbmRleCApIHtcblxuICAgICAgdGhpcy5wYXNzZXMuc3BsaWNlKCBpbmRleCwgMCwgcGFzcyApO1xuXG4gICAgfSxcblxuICAgIHJlbmRlcjogZnVuY3Rpb24gKCBkZWx0YSApIHtcblxuICAgICAgdGhpcy53cml0ZUJ1ZmZlciA9IHRoaXMucmVuZGVyVGFyZ2V0MTtcbiAgICAgIHRoaXMucmVhZEJ1ZmZlciA9IHRoaXMucmVuZGVyVGFyZ2V0MjtcblxuICAgICAgdmFyIG1hc2tBY3RpdmUgPSBmYWxzZTtcblxuICAgICAgdmFyIHBhc3MsIGksIGlsID0gdGhpcy5wYXNzZXMubGVuZ3RoO1xuXG4gICAgICBmb3IgKCBpID0gMDsgaSA8IGlsOyBpICsrICkge1xuXG4gICAgICAgIHBhc3MgPSB0aGlzLnBhc3Nlc1sgaSBdO1xuXG4gICAgICAgIGlmICggIXBhc3MuZW5hYmxlZCApIGNvbnRpbnVlO1xuXG4gICAgICAgIHBhc3MucmVuZGVyKCB0aGlzLnJlbmRlcmVyLCB0aGlzLndyaXRlQnVmZmVyLCB0aGlzLnJlYWRCdWZmZXIsIGRlbHRhLCBtYXNrQWN0aXZlICk7XG5cbiAgICAgICAgaWYgKCBwYXNzLm5lZWRzU3dhcCApIHtcblxuICAgICAgICAgIGlmICggbWFza0FjdGl2ZSApIHtcblxuICAgICAgICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLnJlbmRlcmVyLmNvbnRleHQ7XG5cbiAgICAgICAgICAgIGNvbnRleHQuc3RlbmNpbEZ1bmMoIGNvbnRleHQuTk9URVFVQUwsIDEsIDB4ZmZmZmZmZmYgKTtcblxuICAgICAgICAgICAgdGhpcy5jb3B5UGFzcy5yZW5kZXIoIHRoaXMucmVuZGVyZXIsIHRoaXMud3JpdGVCdWZmZXIsIHRoaXMucmVhZEJ1ZmZlciwgZGVsdGEgKTtcblxuICAgICAgICAgICAgY29udGV4dC5zdGVuY2lsRnVuYyggY29udGV4dC5FUVVBTCwgMSwgMHhmZmZmZmZmZiApO1xuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5zd2FwQnVmZmVycygpO1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIHBhc3MgaW5zdGFuY2VvZiBNYXNrUGFzcyApIHtcblxuICAgICAgICAgIG1hc2tBY3RpdmUgPSB0cnVlO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoIHBhc3MgaW5zdGFuY2VvZiBDbGVhck1hc2tQYXNzICkge1xuXG4gICAgICAgICAgbWFza0FjdGl2ZSA9IGZhbHNlO1xuXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgfSxcblxuICAgIHJlc2V0OiBmdW5jdGlvbiAoIHJlbmRlclRhcmdldCApIHtcblxuICAgICAgaWYgKCByZW5kZXJUYXJnZXQgPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICByZW5kZXJUYXJnZXQgPSB0aGlzLnJlbmRlclRhcmdldDEuY2xvbmUoKTtcblxuICAgICAgICByZW5kZXJUYXJnZXQud2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICAgICAgcmVuZGVyVGFyZ2V0LmhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodDtcblxuICAgICAgfVxuXG4gICAgICB0aGlzLnJlbmRlclRhcmdldDEgPSByZW5kZXJUYXJnZXQ7XG4gICAgICB0aGlzLnJlbmRlclRhcmdldDIgPSByZW5kZXJUYXJnZXQuY2xvbmUoKTtcblxuICAgICAgdGhpcy53cml0ZUJ1ZmZlciA9IHRoaXMucmVuZGVyVGFyZ2V0MTtcbiAgICAgIHRoaXMucmVhZEJ1ZmZlciA9IHRoaXMucmVuZGVyVGFyZ2V0MjtcblxuICAgIH0sXG5cbiAgICBzZXRTaXplOiBmdW5jdGlvbiAoIHdpZHRoLCBoZWlnaHQgKSB7XG5cbiAgICAgIHZhciByZW5kZXJUYXJnZXQgPSB0aGlzLnJlbmRlclRhcmdldDEuY2xvbmUoKTtcblxuICAgICAgcmVuZGVyVGFyZ2V0LndpZHRoID0gd2lkdGg7XG4gICAgICByZW5kZXJUYXJnZXQuaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgICB0aGlzLnJlc2V0KCByZW5kZXJUYXJnZXQgKTtcblxuICAgIH1cblxuICB9O1xuXG4gIC8vIHNoYXJlZCBvcnRobyBjYW1lcmFcblxuICBFZmZlY3RDb21wb3Nlci5jYW1lcmEgPSBuZXcgVEhSRUUuT3J0aG9ncmFwaGljQ2FtZXJhKCAtMSwgMSwgMSwgLTEsIDAsIDEgKTtcblxuICBFZmZlY3RDb21wb3Nlci5xdWFkID0gbmV3IFRIUkVFLk1lc2goIG5ldyBUSFJFRS5QbGFuZUdlb21ldHJ5KCAyLCAyICksIG51bGwgKTtcblxuICBFZmZlY3RDb21wb3Nlci5zY2VuZSA9IG5ldyBUSFJFRS5TY2VuZSgpO1xuICBFZmZlY3RDb21wb3Nlci5zY2VuZS5hZGQoIEVmZmVjdENvbXBvc2VyLnF1YWQgKTtcblxuICByZXR1cm4gRWZmZWN0Q29tcG9zZXJcbn07IiwiLyoqXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oVEhSRUUpIHtcbiAgZnVuY3Rpb24gQ2xlYXJNYXNrUGFzcygpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQ2xlYXJNYXNrUGFzcykpIHJldHVybiBuZXcgQ2xlYXJNYXNrUGFzcyhzY2VuZSwgY2FtZXJhKTtcbiAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xuICB9O1xuXG4gIENsZWFyTWFza1Bhc3MucHJvdG90eXBlID0ge1xuICAgIHJlbmRlcjogZnVuY3Rpb24gKCByZW5kZXJlciwgd3JpdGVCdWZmZXIsIHJlYWRCdWZmZXIsIGRlbHRhICkge1xuICAgICAgdmFyIGNvbnRleHQgPSByZW5kZXJlci5jb250ZXh0O1xuICAgICAgY29udGV4dC5kaXNhYmxlKCBjb250ZXh0LlNURU5DSUxfVEVTVCApO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gQ2xlYXJNYXNrUGFzc1xufTsiLCIvKipcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihUSFJFRSkge1xuICBmdW5jdGlvbiBNYXNrUGFzcyggc2NlbmUsIGNhbWVyYSApIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgTWFza1Bhc3MpKSByZXR1cm4gbmV3IE1hc2tQYXNzKHNjZW5lLCBjYW1lcmEpO1xuXG4gICAgdGhpcy5zY2VuZSA9IHNjZW5lO1xuICAgIHRoaXMuY2FtZXJhID0gY2FtZXJhO1xuXG4gICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcbiAgICB0aGlzLmNsZWFyID0gdHJ1ZTtcbiAgICB0aGlzLm5lZWRzU3dhcCA9IGZhbHNlO1xuXG4gICAgdGhpcy5pbnZlcnNlID0gZmFsc2U7XG4gIH07XG5cbiAgTWFza1Bhc3MucHJvdG90eXBlID0ge1xuXG4gICAgcmVuZGVyOiBmdW5jdGlvbiAoIHJlbmRlcmVyLCB3cml0ZUJ1ZmZlciwgcmVhZEJ1ZmZlciwgZGVsdGEgKSB7XG5cbiAgICAgIHZhciBjb250ZXh0ID0gcmVuZGVyZXIuY29udGV4dDtcblxuICAgICAgLy8gZG9uJ3QgdXBkYXRlIGNvbG9yIG9yIGRlcHRoXG5cbiAgICAgIGNvbnRleHQuY29sb3JNYXNrKCBmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZSApO1xuICAgICAgY29udGV4dC5kZXB0aE1hc2soIGZhbHNlICk7XG5cbiAgICAgIC8vIHNldCB1cCBzdGVuY2lsXG5cbiAgICAgIHZhciB3cml0ZVZhbHVlLCBjbGVhclZhbHVlO1xuXG4gICAgICBpZiAoIHRoaXMuaW52ZXJzZSApIHtcblxuICAgICAgICB3cml0ZVZhbHVlID0gMDtcbiAgICAgICAgY2xlYXJWYWx1ZSA9IDE7XG5cbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgd3JpdGVWYWx1ZSA9IDE7XG4gICAgICAgIGNsZWFyVmFsdWUgPSAwO1xuXG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQuZW5hYmxlKCBjb250ZXh0LlNURU5DSUxfVEVTVCApO1xuICAgICAgY29udGV4dC5zdGVuY2lsT3AoIGNvbnRleHQuUkVQTEFDRSwgY29udGV4dC5SRVBMQUNFLCBjb250ZXh0LlJFUExBQ0UgKTtcbiAgICAgIGNvbnRleHQuc3RlbmNpbEZ1bmMoIGNvbnRleHQuQUxXQVlTLCB3cml0ZVZhbHVlLCAweGZmZmZmZmZmICk7XG4gICAgICBjb250ZXh0LmNsZWFyU3RlbmNpbCggY2xlYXJWYWx1ZSApO1xuXG4gICAgICAvLyBkcmF3IGludG8gdGhlIHN0ZW5jaWwgYnVmZmVyXG5cbiAgICAgIHJlbmRlcmVyLnJlbmRlciggdGhpcy5zY2VuZSwgdGhpcy5jYW1lcmEsIHJlYWRCdWZmZXIsIHRoaXMuY2xlYXIgKTtcbiAgICAgIHJlbmRlcmVyLnJlbmRlciggdGhpcy5zY2VuZSwgdGhpcy5jYW1lcmEsIHdyaXRlQnVmZmVyLCB0aGlzLmNsZWFyICk7XG5cbiAgICAgIC8vIHJlLWVuYWJsZSB1cGRhdGUgb2YgY29sb3IgYW5kIGRlcHRoXG5cbiAgICAgIGNvbnRleHQuY29sb3JNYXNrKCB0cnVlLCB0cnVlLCB0cnVlLCB0cnVlICk7XG4gICAgICBjb250ZXh0LmRlcHRoTWFzayggdHJ1ZSApO1xuXG4gICAgICAvLyBvbmx5IHJlbmRlciB3aGVyZSBzdGVuY2lsIGlzIHNldCB0byAxXG5cbiAgICAgIGNvbnRleHQuc3RlbmNpbEZ1bmMoIGNvbnRleHQuRVFVQUwsIDEsIDB4ZmZmZmZmZmYgKTsgIC8vIGRyYXcgaWYgPT0gMVxuICAgICAgY29udGV4dC5zdGVuY2lsT3AoIGNvbnRleHQuS0VFUCwgY29udGV4dC5LRUVQLCBjb250ZXh0LktFRVAgKTtcblxuICAgIH1cblxuICB9O1xuXG4gIHJldHVybiBNYXNrUGFzc1xufTtcbiIsIi8qKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFRIUkVFKSB7XG4gIGZ1bmN0aW9uIFJlbmRlclBhc3MoIHNjZW5lLCBjYW1lcmEsIG92ZXJyaWRlTWF0ZXJpYWwsIGNsZWFyQ29sb3IsIGNsZWFyQWxwaGEgKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlbmRlclBhc3MpKSByZXR1cm4gbmV3IFJlbmRlclBhc3Moc2NlbmUsIGNhbWVyYSwgb3ZlcnJpZGVNYXRlcmlhbCwgY2xlYXJDb2xvciwgY2xlYXJBbHBoYSk7XG5cbiAgICB0aGlzLnNjZW5lID0gc2NlbmU7XG4gICAgdGhpcy5jYW1lcmEgPSBjYW1lcmE7XG5cbiAgICB0aGlzLm92ZXJyaWRlTWF0ZXJpYWwgPSBvdmVycmlkZU1hdGVyaWFsO1xuXG4gICAgdGhpcy5jbGVhckNvbG9yID0gY2xlYXJDb2xvcjtcbiAgICB0aGlzLmNsZWFyQWxwaGEgPSAoIGNsZWFyQWxwaGEgIT09IHVuZGVmaW5lZCApID8gY2xlYXJBbHBoYSA6IDE7XG5cbiAgICB0aGlzLm9sZENsZWFyQ29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoKTtcbiAgICB0aGlzLm9sZENsZWFyQWxwaGEgPSAxO1xuXG4gICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcbiAgICB0aGlzLmNsZWFyID0gdHJ1ZTtcbiAgICB0aGlzLm5lZWRzU3dhcCA9IGZhbHNlO1xuXG4gIH07XG5cbiAgUmVuZGVyUGFzcy5wcm90b3R5cGUgPSB7XG5cbiAgICByZW5kZXI6IGZ1bmN0aW9uICggcmVuZGVyZXIsIHdyaXRlQnVmZmVyLCByZWFkQnVmZmVyLCBkZWx0YSApIHtcblxuICAgICAgdGhpcy5zY2VuZS5vdmVycmlkZU1hdGVyaWFsID0gdGhpcy5vdmVycmlkZU1hdGVyaWFsO1xuXG4gICAgICBpZiAoIHRoaXMuY2xlYXJDb2xvciApIHtcblxuICAgICAgICB0aGlzLm9sZENsZWFyQ29sb3IuY29weSggcmVuZGVyZXIuZ2V0Q2xlYXJDb2xvcigpICk7XG4gICAgICAgIHRoaXMub2xkQ2xlYXJBbHBoYSA9IHJlbmRlcmVyLmdldENsZWFyQWxwaGEoKTtcblxuICAgICAgICByZW5kZXJlci5zZXRDbGVhckNvbG9yKCB0aGlzLmNsZWFyQ29sb3IsIHRoaXMuY2xlYXJBbHBoYSApO1xuXG4gICAgICB9XG5cbiAgICAgIHJlbmRlcmVyLnJlbmRlciggdGhpcy5zY2VuZSwgdGhpcy5jYW1lcmEsIHJlYWRCdWZmZXIsIHRoaXMuY2xlYXIgKTtcblxuICAgICAgaWYgKCB0aGlzLmNsZWFyQ29sb3IgKSB7XG5cbiAgICAgICAgcmVuZGVyZXIuc2V0Q2xlYXJDb2xvciggdGhpcy5vbGRDbGVhckNvbG9yLCB0aGlzLm9sZENsZWFyQWxwaGEgKTtcblxuICAgICAgfVxuXG4gICAgICB0aGlzLnNjZW5lLm92ZXJyaWRlTWF0ZXJpYWwgPSBudWxsO1xuXG4gICAgfVxuXG4gIH07XG5cbiAgcmV0dXJuIFJlbmRlclBhc3M7XG5cbn07XG4iLCIvKipcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihUSFJFRSwgRWZmZWN0Q29tcG9zZXIpIHtcbiAgZnVuY3Rpb24gU2hhZGVyUGFzcyggc2hhZGVyLCB0ZXh0dXJlSUQgKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNoYWRlclBhc3MpKSByZXR1cm4gbmV3IFNoYWRlclBhc3Moc2hhZGVyLCB0ZXh0dXJlSUQpO1xuXG4gICAgdGhpcy50ZXh0dXJlSUQgPSAoIHRleHR1cmVJRCAhPT0gdW5kZWZpbmVkICkgPyB0ZXh0dXJlSUQgOiBcInREaWZmdXNlXCI7XG5cbiAgICB0aGlzLnVuaWZvcm1zID0gVEhSRUUuVW5pZm9ybXNVdGlscy5jbG9uZSggc2hhZGVyLnVuaWZvcm1zICk7XG5cbiAgICB0aGlzLm1hdGVyaWFsID0gbmV3IFRIUkVFLlNoYWRlck1hdGVyaWFsKCB7XG5cbiAgICAgIHVuaWZvcm1zOiB0aGlzLnVuaWZvcm1zLFxuICAgICAgdmVydGV4U2hhZGVyOiBzaGFkZXIudmVydGV4U2hhZGVyLFxuICAgICAgZnJhZ21lbnRTaGFkZXI6IHNoYWRlci5mcmFnbWVudFNoYWRlclxuXG4gICAgfSApO1xuXG4gICAgdGhpcy5yZW5kZXJUb1NjcmVlbiA9IGZhbHNlO1xuXG4gICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcbiAgICB0aGlzLm5lZWRzU3dhcCA9IHRydWU7XG4gICAgdGhpcy5jbGVhciA9IGZhbHNlO1xuXG4gIH07XG5cbiAgU2hhZGVyUGFzcy5wcm90b3R5cGUgPSB7XG5cbiAgICByZW5kZXI6IGZ1bmN0aW9uICggcmVuZGVyZXIsIHdyaXRlQnVmZmVyLCByZWFkQnVmZmVyLCBkZWx0YSApIHtcblxuICAgICAgaWYgKCB0aGlzLnVuaWZvcm1zWyB0aGlzLnRleHR1cmVJRCBdICkge1xuXG4gICAgICAgIHRoaXMudW5pZm9ybXNbIHRoaXMudGV4dHVyZUlEIF0udmFsdWUgPSByZWFkQnVmZmVyO1xuXG4gICAgICB9XG5cbiAgICAgIEVmZmVjdENvbXBvc2VyLnF1YWQubWF0ZXJpYWwgPSB0aGlzLm1hdGVyaWFsO1xuXG4gICAgICBpZiAoIHRoaXMucmVuZGVyVG9TY3JlZW4gKSB7XG5cbiAgICAgICAgcmVuZGVyZXIucmVuZGVyKCBFZmZlY3RDb21wb3Nlci5zY2VuZSwgRWZmZWN0Q29tcG9zZXIuY2FtZXJhICk7XG5cbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgcmVuZGVyZXIucmVuZGVyKCBFZmZlY3RDb21wb3Nlci5zY2VuZSwgRWZmZWN0Q29tcG9zZXIuY2FtZXJhLCB3cml0ZUJ1ZmZlciwgdGhpcy5jbGVhciApO1xuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgfTtcblxuICByZXR1cm4gU2hhZGVyUGFzcztcblxufTsiLCIvKipcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKlxuICogRnVsbC1zY3JlZW4gdGV4dHVyZWQgcXVhZCBzaGFkZXJcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgdW5pZm9ybXM6IHtcbiAgICBcInREaWZmdXNlXCI6IHsgdHlwZTogXCJ0XCIsIHZhbHVlOiBudWxsIH0sXG4gICAgXCJvcGFjaXR5XCI6ICB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMS4wIH1cbiAgfSxcbiAgdmVydGV4U2hhZGVyOiBbXG4gICAgXCJ2YXJ5aW5nIHZlYzIgdlV2O1wiLFxuXG4gICAgXCJ2b2lkIG1haW4oKSB7XCIsXG5cbiAgICAgIFwidlV2ID0gdXY7XCIsXG4gICAgICBcImdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG1vZGVsVmlld01hdHJpeCAqIHZlYzQoIHBvc2l0aW9uLCAxLjAgKTtcIixcblxuICAgIFwifVwiXG4gIF0uam9pbihcIlxcblwiKSxcbiAgZnJhZ21lbnRTaGFkZXI6IFtcbiAgICBcInVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcIixcblxuICAgIFwidW5pZm9ybSBzYW1wbGVyMkQgdERpZmZ1c2U7XCIsXG5cbiAgICBcInZhcnlpbmcgdmVjMiB2VXY7XCIsXG5cbiAgICBcInZvaWQgbWFpbigpIHtcIixcblxuICAgICAgXCJ2ZWM0IHRleGVsID0gdGV4dHVyZTJEKCB0RGlmZnVzZSwgdlV2ICk7XCIsXG4gICAgICBcImdsX0ZyYWdDb2xvciA9IG9wYWNpdHkgKiB0ZXhlbDtcIixcblxuICAgIFwifVwiXG4gIF0uam9pbihcIlxcblwiKVxufTtcbiIsInZhciBjcmVhdGVUeXBlcyA9IHJlcXVpcmUoJy4vdHlwZXMnKVxuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oVEhSRUUpIHtcblxuICAgIHZhciB0eXBlcyA9IGNyZWF0ZVR5cGVzKFRIUkVFKSBcblxuICAgIHJldHVybiBmdW5jdGlvbiBjcmVhdGUoZ2xTaGFkZXIsIG9wdHMpIHtcbiAgICAgICAgb3B0cyA9IG9wdHN8fHt9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBvcHRzLmNvbG9ycyA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICBvcHRzLmNvbG9ycyA9IFtvcHRzLmNvbG9yc11cbiAgICAgICAgXG4gICAgICAgIHZhciB0VW5pZm9ybXMgPSB0eXBlcyggZ2xTaGFkZXIudW5pZm9ybXMsIG9wdHMuY29sb3JzIClcbiAgICAgICAgdmFyIHRBdHRyaWJzID0gdHlwZXMoIGdsU2hhZGVyLmF0dHJpYnV0ZXMsIG9wdHMuY29sb3JzIClcbiAgICAgICAgICAgIFxuICAgICAgICAvL2NsZWFyIHRoZSBhdHRyaWJ1dGUgYXJyYXlzXG4gICAgICAgIGZvciAodmFyIGsgaW4gdEF0dHJpYnMpIHtcbiAgICAgICAgICAgIHRBdHRyaWJzW2tdLnZhbHVlID0gW11cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2ZXJ0ZXhTaGFkZXI6IGdsU2hhZGVyLnZlcnRleCxcbiAgICAgICAgICAgIGZyYWdtZW50U2hhZGVyOiBnbFNoYWRlci5mcmFnbWVudCxcbiAgICAgICAgICAgIHVuaWZvcm1zOiB0VW5pZm9ybXMsXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiB0QXR0cmlic1xuICAgICAgICB9XG4gICAgfVxufSIsInZhciB0eXBlTWFwID0ge1xuICAgICdpbnQnOiAnaScsXG4gICAgJ2Zsb2F0JzogJ2YnLFxuICAgICdpdmVjMic6ICdpMicsXG4gICAgJ2l2ZWMzJzogJ2kzJyxcbiAgICAnaXZlYzQnOiAnaTQnLFxuICAgICd2ZWMyJzogJ3YyJyxcbiAgICAndmVjMyc6ICd2MycsXG4gICAgJ3ZlYzQnOiAndjQnLFxuICAgICdtYXQ0JzogJ200JyxcbiAgICAnbWF0Myc6ICdtMycsXG4gICAgJ3NhbXBsZXIyRCc6ICd0JyxcbiAgICAnc2FtcGxlckN1YmUnOiAndCdcbn1cblxuZnVuY3Rpb24gY3JlYXRlKFRIUkVFKSB7XG4gICAgZnVuY3Rpb24gbmV3SW5zdGFuY2UodHlwZSwgaXNBcnJheSkge1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2Zsb2F0JzogXG4gICAgICAgICAgICBjYXNlICdpbnQnOlxuICAgICAgICAgICAgICAgIHJldHVybiAwXG4gICAgICAgICAgICBjYXNlICd2ZWMyJzpcbiAgICAgICAgICAgIGNhc2UgJ2l2ZWMyJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFRIUkVFLlZlY3RvcjIoKVxuICAgICAgICAgICAgY2FzZSAndmVjMyc6XG4gICAgICAgICAgICBjYXNlICdpdmVjMyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBUSFJFRS5WZWN0b3IzKClcbiAgICAgICAgICAgIGNhc2UgJ3ZlYzQnOlxuICAgICAgICAgICAgY2FzZSAnaXZlYzQnOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVEhSRUUuVmVjdG9yNCgpXG4gICAgICAgICAgICBjYXNlICdtYXQ0JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFRIUkVFLk1hdHJpeDQoKVxuICAgICAgICAgICAgY2FzZSAnbWF0Myc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBUSFJFRS5NYXRyaXgzKClcbiAgICAgICAgICAgIGNhc2UgJ3NhbXBsZXJDdWJlJzpcbiAgICAgICAgICAgIGNhc2UgJ3NhbXBsZXIyRCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBUSFJFRS5UZXh0dXJlKClcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVmYXVsdFZhbHVlKHR5cGUsIGlzQXJyYXksIGFycmF5TGVuKSB7XG4gICAgICAgIGlmIChpc0FycmF5KSB7XG4gICAgICAgICAgICAvL1RocmVlSlMgZmxhdHRlbnMgaXZlYzMgdHlwZVxuICAgICAgICAgICAgLy8od2UgZG9uJ3Qgc3VwcG9ydCAnZnYnIHR5cGUpXG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gJ2l2ZWMzJylcbiAgICAgICAgICAgICAgICBhcnJheUxlbiAqPSAzXG4gICAgICAgICAgICB2YXIgYXIgPSBuZXcgQXJyYXkoYXJyYXlMZW4pXG4gICAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8YXIubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgYXJbaV0gPSBuZXdJbnN0YW5jZSh0eXBlLCBpc0FycmF5KVxuICAgICAgICAgICAgcmV0dXJuIGFyXG4gICAgICAgIH0gIFxuICAgICAgICByZXR1cm4gbmV3SW5zdGFuY2UodHlwZSlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRUeXBlKHR5cGUsIGlzQXJyYXkpIHtcbiAgICAgICAgaWYgKCFpc0FycmF5KVxuICAgICAgICAgICAgcmV0dXJuIHR5cGVNYXBbdHlwZV1cblxuICAgICAgICBpZiAodHlwZSA9PT0gJ2ludCcpXG4gICAgICAgICAgICByZXR1cm4gJ2l2MSdcbiAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gJ2Zsb2F0JylcbiAgICAgICAgICAgIHJldHVybiAnZnYxJ1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gdHlwZU1hcFt0eXBlXSsndidcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gc2V0dXBVbmlmb3JtcyhnbFVuaWZvcm1zLCBjb2xvck5hbWVzKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShjb2xvck5hbWVzKSlcbiAgICAgICAgICAgIGNvbG9yTmFtZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpXG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9XG4gICAgICAgIHZhciBhcnJheXMgPSB7fVxuXG4gICAgICAgIC8vbWFwIHVuaWZvcm0gdHlwZXNcbiAgICAgICAgZ2xVbmlmb3Jtcy5mb3JFYWNoKGZ1bmN0aW9uKHVuaWZvcm0pIHtcbiAgICAgICAgICAgIHZhciBuYW1lID0gdW5pZm9ybS5uYW1lXG4gICAgICAgICAgICB2YXIgaXNBcnJheSA9IC8oLispXFxbWzAtOV0rXFxdLy5leGVjKG5hbWUpXG5cbiAgICAgICAgICAgIC8vc3BlY2lhbCBjYXNlOiBjb2xvcnMuLi5cbiAgICAgICAgICAgIGlmIChjb2xvck5hbWVzICYmIGNvbG9yTmFtZXMuaW5kZXhPZihuYW1lKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNBcnJheSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYXJyYXkgb2YgY29sb3IgdW5pZm9ybXMgbm90IHN1cHBvcnRlZFwiKVxuICAgICAgICAgICAgICAgIGlmICh1bmlmb3JtLnR5cGUgIT09ICd2ZWMzJylcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhyZWVKUyBleHBlY3RzIHZlYzMgZm9yIENvbG9yIHVuaWZvcm1zXCIpIFxuICAgICAgICAgICAgICAgIHJlc3VsdFtuYW1lXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2MnLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbmV3IFRIUkVFLkNvbG9yKClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpc0FycmF5KSB7XG4gICAgICAgICAgICAgICAgbmFtZSA9IGlzQXJyYXlbMV1cbiAgICAgICAgICAgICAgICBpZiAobmFtZSBpbiBhcnJheXMpIFxuICAgICAgICAgICAgICAgICAgICBhcnJheXNbbmFtZV0uY291bnQrKyBcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGFycmF5c1tuYW1lXSA9IHsgY291bnQ6IDEsIHR5cGU6IHVuaWZvcm0udHlwZSB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHRbbmFtZV0gPSB7IFxuICAgICAgICAgICAgICAgIHR5cGU6IGdldFR5cGUodW5pZm9ybS50eXBlLCBpc0FycmF5KSwgXG4gICAgICAgICAgICAgICAgdmFsdWU6IGlzQXJyYXkgPyBudWxsIDogZGVmYXVsdFZhbHVlKHVuaWZvcm0udHlwZSkgXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG5cbiAgICAgICAgLy9ub3cgY2xlYW4gdXAgYW55IGFycmF5IHZhbHVlc1xuICAgICAgICBmb3IgKHZhciBrIGluIHJlc3VsdCkge1xuICAgICAgICAgICAgdmFyIHUgPSByZXN1bHRba11cbiAgICAgICAgICAgIGlmIChrIGluIGFycmF5cykgeyAvL2lzIGFuIGFycmF5XG4gICAgICAgICAgICAgICAgdmFyIGEgPSBhcnJheXNba11cbiAgICAgICAgICAgICAgICB1LnZhbHVlID0gZGVmYXVsdFZhbHVlKGEudHlwZSwgdHJ1ZSwgYS5jb3VudClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZSIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvcmVuZGVyZXInKSIsInZhciBjcmVhdGVUZXh0ID0gcmVxdWlyZSgnZ2wtc3ByaXRlLXRleHQnKVxudmFyIG1hdDQgPSB7XG4gICAgY3JlYXRlOiByZXF1aXJlKCdnbC1tYXQ0L2NyZWF0ZScpLFxuICAgIHNjYWxlOiByZXF1aXJlKCdnbC1tYXQ0L3NjYWxlJyksXG4gICAgbXVsdGlwbHk6IHJlcXVpcmUoJ2dsLW1hdDQvbXVsdGlwbHknKVxufVxuXG52YXIgbW9kZWxUcmFuc2Zvcm0gPSBtYXQ0LmNyZWF0ZSgpXG52YXIgZmxpcCA9IG1hdDQuY3JlYXRlKClcbm1hdDQuc2NhbGUoZmxpcCwgZmxpcCwgWzEsIC0xLCAxXSlcblxudmFyIFdyYXBUZXh0dXJlID0gcmVxdWlyZSgnLi90ZXh0dXJlLXdyYXAnKVxudmFyIG51bWJlciA9IHJlcXVpcmUoJ2FzLW51bWJlcicpXG52YXIgeHRlbmQgPSByZXF1aXJlKCd4dGVuZCcpXG5cbnZhciBjcmVhdGVTaGFkZXIgPSByZXF1aXJlKCdnbC1zaGFkZXItY29yZScpXG52YXIgdmVydGV4ID0gJ2F0dHJpYnV0ZSB2ZWM0IHBvc2l0aW9uO1xcbmF0dHJpYnV0ZSB2ZWM0IGNvbG9yO1xcbmF0dHJpYnV0ZSB2ZWMyIHRleGNvb3JkMDtcXG5cXG51bmlmb3JtIG1hdDQgcHJvamVjdGlvbjtcXG51bmlmb3JtIG1hdDQgdmlldztcXG51bmlmb3JtIG1hdDQgbW9kZWw7XFxuXFxudmFyeWluZyB2ZWM0IHZfY29sO1xcbnZhcnlpbmcgdmVjMiB2X3RleDA7XFxuXFxudm9pZCBtYWluKCkge1xcbiBnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb24gKiB2aWV3ICogbW9kZWwgKiBwb3NpdGlvbjtcXG4gdl9jb2wgPSBjb2xvcjtcXG4gdl90ZXgwID0gdGV4Y29vcmQwO1xcbiBnbF9Qb2ludFNpemUgPSAxLjA7XFxufSdcbnZhciBmcmFnbWVudCA9ICcjaWZkZWYgR0xfRVNcXG5wcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG4jZW5kaWZcXG5cXG52YXJ5aW5nIHZlYzQgdl9jb2w7XFxudmFyeWluZyB2ZWMyIHZfdGV4MDtcXG51bmlmb3JtIHNhbXBsZXIyRCB0ZXh0dXJlMDtcXG5cXG51bmlmb3JtIGZsb2F0IHNtb290aGluZztcXG4vLyA9IDEuMC8zMi4wO1xcblxcbi8vIGRyb3Agc2hhZG93IGNvbXB1dGVkIGluIGZyYWdtZW50IHNoYWRlclxcbnZvaWQgbWFpbigpIHtcXG4gdmVjNCB0ZXhDb2xvciA9IHRleHR1cmUyRCh0ZXh0dXJlMCwgdl90ZXgwKTtcXG5cXG4gZmxvYXQgZHN0ID0gdGV4Q29sb3IuYTtcXG4gZmxvYXQgYWxwaGEgPSBzbW9vdGhzdGVwKDAuNSAtIHNtb290aGluZywgMC41ICsgc21vb3RoaW5nLCBkc3QpO1xcbiB2ZWM0IGJhc2UgPSB2X2NvbCAqIHZlYzQoYWxwaGEpO1xcblxcbiBnbF9GcmFnQ29sb3IgPSBiYXNlO1xcbiBpZiAoZ2xfRnJhZ0NvbG9yLmE8MC4xKVxcbiBkaXNjYXJkO1xcbn0nXG5cbnZhciB1bmlmb3JtcyA9IFtcbiAgICAgICAgeyB0eXBlOiAnZmxvYXQnLCBuYW1lOiAnc21vb3RoaW5nJyB9LFxuICAgICAgICB7IHR5cGU6ICdzYW1wbGVyMkQnLCBuYW1lOiAndGV4dHVyZTAnIH0sXG4gICAgICAgIHsgdHlwZTogJ21hdDQnLCBuYW1lOiAncHJvamVjdGlvbicgfSxcbiAgICAgICAgeyB0eXBlOiAnbWF0NCcsIG5hbWU6ICd2aWV3JyB9LFxuICAgICAgICB7IHR5cGU6ICdtYXQ0JywgbmFtZTogJ21vZGVsJyB9ICAgICAgICBcbiAgICBdLFxuICAgIGF0dHJpYnV0ZXMgPSBbXG4gICAgICAgIHsgdHlwZTogJ3ZlYzQnLCBuYW1lOiAncG9zaXRpb24nIH0sXG4gICAgICAgIHsgdHlwZTogJ3ZlYzQnLCBuYW1lOiAnY29sb3InIH0sXG4gICAgICAgIHsgdHlwZTogJ3ZlYzInLCBuYW1lOiAndGV4Y29vcmQwJyB9XG4gICAgXVxuXG5cblxuZnVuY3Rpb24gY29weUNvbG9yKG91dCwgY29sb3IsIG9wYWNpdHkpIHtcbiAgICBvdXRbMF0gPSBjb2xvci5yXG4gICAgb3V0WzFdID0gY29sb3IuZyBcbiAgICBvdXRbMl0gPSBjb2xvci5iIFxuICAgIG91dFszXSA9IG9wYWNpdHlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihUSFJFRSkge1xuICAgIHZhciBzaGFyZWRTaGFkZXJcblxuICAgIGZ1bmN0aW9uIFRleHRSZW5kZXJlcihyZW5kZXJlciwgb3B0KSB7XG4gICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBUZXh0UmVuZGVyZXIpKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBUZXh0UmVuZGVyZXIocmVuZGVyZXIsIG9wdClcbiAgICAgICAgb3B0PW9wdHx8e31cblxuICAgICAgICB2YXIgZ2wgPSByZW5kZXJlci5nZXRDb250ZXh0KClcbiAgICAgICAgdGhpcy5nbCA9IGdsXG4gICAgICAgIHRoaXMuY29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoKVxuICAgICAgICBpZiAob3B0LmNvbG9yICE9PSBudWxsICYmIHR5cGVvZiBvcHQuY29sb3IgIT09ICd1bmRlZmluZWQnKVxuICAgICAgICAgICAgdGhpcy5jb2xvci5zZXQob3B0LmNvbG9yKVxuICAgICAgICB0aGlzLm9wYWNpdHkgPSBudW1iZXIob3B0Lm9wYWNpdHksIDEuMClcblxuICAgICAgICAvL2lmIG5vIHRleHR1cmVzIGFyZSBnaXZlbiwgcHJlc3VtZSB0aGV5IGFyZSBiYXNlNjQgcGFja2VkXG4gICAgICAgIC8vaW50byB0aGUgRm9udCBvYmplY3QgKGxpa2Ugd2l0aCBibWZvbnQtbGF0bylcbiAgICAgICAgdmFyIHRleHRPcHRzID0geHRlbmQob3B0KVxuICAgICAgICBpZiAodGV4dE9wdHMudGV4dHVyZXMpIHtcbiAgICAgICAgICAgIHRleHRPcHRzLnRleHR1cmVzID0gdGV4dE9wdHMudGV4dHVyZXMubWFwKGZ1bmN0aW9uKHRleCkge1xuICAgICAgICAgICAgICAgIC8vIHJldHVybiByZXF1aXJlKCdnbC10ZXh0dXJlMmQnKShnbCwgdGV4LmltYWdlKVxuICAgICAgICAgICAgICAgIGlmICh0ZXggaW5zdGFuY2VvZiBUSFJFRS5UZXh0dXJlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gV3JhcFRleHR1cmUocmVuZGVyZXIsIHRleClcbiAgICAgICAgICAgICAgICByZXR1cm4gdGV4XG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICB0aGlzLmVsZW1lbnQgPSBjcmVhdGVUZXh0KGdsLCB0ZXh0T3B0cylcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0gPSBtYXQ0LmNyZWF0ZSgpXG5cbiAgICAgICAgaWYgKCFzaGFyZWRTaGFkZXIgJiYgIW9wdC5zaGFkZXIpXG4gICAgICAgICAgICBzaGFyZWRTaGFkZXIgPSBjcmVhdGVTaGFkZXIoZ2wsIHZlcnRleCwgZnJhZ21lbnQsIHVuaWZvcm1zLCBhdHRyaWJ1dGVzKVxuICAgICAgICB0aGlzLnNoYWRlciA9IG9wdC5zaGFkZXIgfHwgc2hhcmVkU2hhZGVyXG4gICAgICAgIHRoaXMuc2hhZGVyLmJpbmQoKVxuXG4gICAgICAgIHRoaXMucGFkZGluZyA9IG51bWJlcihvcHQucGFkZGluZywgMClcblxuICAgICAgICB2YXIgcyA9IG51bWJlcihvcHQuc21vb3RoaW5nLCAxLjAvMzIuMClcbiAgICAgICAgdGhpcy5zaGFkZXIudW5pZm9ybXMuc21vb3RoaW5nID0gc1xuICAgICAgICB0aGlzLnNoYWRlci51bmlmb3Jtcy50ZXh0dXJlMCA9IDBcbiAgICB9XG5cbiAgICBUZXh0UmVuZGVyZXIucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbihjYW1lcmEsIG9iamVjdCkge1xuICAgICAgICB2YXIgZ2wgPSB0aGlzLmdsXG5cbiAgICAgICAgaWYgKCFvYmplY3QudmlzaWJsZSlcbiAgICAgICAgICAgIHJldHVyblxuXG4gICAgICAgIGlmICghdGhpcy5lbGVtZW50LnRleHR1cmVzIHx8IHRoaXMuZWxlbWVudC50ZXh0dXJlcy5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm5cblxuICAgICAgICBnbC5lbmFibGUoZ2wuQkxFTkQpXG4gICAgICAgIC8vIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgbnVsbClcblxuICAgICAgICBnbC5lbmFibGUoZ2wuREVQVEhfVEVTVClcbiAgICAgICAgZ2wuZGVwdGhGdW5jKGdsLkxFUVVBTClcblxuICAgICAgICAvLyBnbC5mcm9udEZhY2UoIGdsLkNDVyApICAgIFxuICAgICAgICBnbC5lbmFibGUoZ2wuQ1VMTF9GQUNFKVxuICAgICAgICAvLyBnbC5jdWxsRmFjZSggZ2wuRlJPTlQgKVxuICAgICAgICBnbC5jb2xvck1hc2sodHJ1ZSwgdHJ1ZSwgdHJ1ZSwgdHJ1ZSlcbiAgICAgICAgZ2wuZGlzYWJsZShnbC5TVEVOQ0lMX1RFU1QpXG4gICAgICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTApXG4gICAgICAgIGdsLmRlcHRoTWFzayh0cnVlKVxuICAgICAgICBnbC5ibGVuZEZ1bmMoZ2wuU1JDX0FMUEhBLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBKVxuXG4gICAgICAgIHRoaXMuc2hhZGVyLmJpbmQoKVxuICAgICAgICB0aGlzLmVsZW1lbnQudGV4dHVyZXNbMF0uYmluZCgwKVxuXG4gICAgICAgIC8vIGdsLmNvbG9yTWFzayh0cnVlLCB0cnVlLCB0cnVlLCB0cnVlKVxuXG4gICAgICAgIGdsLmN1bGxGYWNlKGdsLkZST05UKVxuXG4gICAgICAgIG1hdDQubXVsdGlwbHkobW9kZWxUcmFuc2Zvcm0sIG9iamVjdC5tYXRyaXhXb3JsZC5lbGVtZW50cywgdGhpcy50cmFuc2Zvcm0pXG4gICAgICAgIG1hdDQubXVsdGlwbHkobW9kZWxUcmFuc2Zvcm0sIG1vZGVsVHJhbnNmb3JtLCBmbGlwKVxuXG4gICAgICAgIHRoaXMuc2hhZGVyLmJpbmQoKVxuICAgICAgICB0aGlzLnNoYWRlci51bmlmb3Jtcy5wcm9qZWN0aW9uID0gY2FtZXJhLnByb2plY3Rpb25NYXRyaXguZWxlbWVudHNcbiAgICAgICAgdGhpcy5zaGFkZXIudW5pZm9ybXMudmlldyA9IGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UuZWxlbWVudHNcbiAgICAgICAgdGhpcy5zaGFkZXIudW5pZm9ybXMubW9kZWwgPSBtb2RlbFRyYW5zZm9ybVxuICAgICAgICAgICAgXG4gICAgICAgIGNvcHlDb2xvcih0aGlzLmVsZW1lbnQuYmF0Y2guY29sb3IsIHRoaXMuY29sb3IsIHRoaXMub3BhY2l0eSlcbiAgICAgICAgdGhpcy5lbGVtZW50LmRyYXcodGhpcy5zaGFkZXIsIHRoaXMucGFkZGluZywgdGhpcy5wYWRkaW5nKVxuXG4gICAgICAgIGdsLmN1bGxGYWNlKCBnbC5CQUNLIClcbiAgICB9XG5cblxuICAgIHJldHVybiBUZXh0UmVuZGVyZXJcbn0iLCIvLyBpbiB0aW1lIHRoaXMgd2lsbCBiZSByZXBsYWNlZCB3aXRoIGEgc29sdXRpb25cbi8vIHRoYXQgYmV0dGVyIHN1cHBvcnRlZCBUaHJlZUpTIFRleHR1cmUgb2JqZWN0c1xuXG5cbmZ1bmN0aW9uIFRleHR1cmVXcmFwKHJlbmRlcmVyLCB0ZXgpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVGV4dHVyZVdyYXApKVxuICAgICAgICByZXR1cm4gbmV3IFRleHR1cmVXcmFwKHJlbmRlcmVyLCB0ZXgpXG4gICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyXG4gICAgdGhpcy50ZXh0dXJlID0gdGV4XG4gICAgdGhpcy5fc2hhcGUgPSBbMCwgMF1cbn1cblxuVGV4dHVyZVdyYXAucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbih1bml0KSB7XG4gICAgdXBkYXRlU2l6ZSh0aGlzLl9zaGFwZSwgdGhpcy50ZXh0dXJlKVxuXG5cbiAgICB2YXIgZ2wgPSB0aGlzLnJlbmRlcmVyLmdldENvbnRleHQoKVxuICAgIHRoaXMucmVuZGVyZXIuc2V0VGV4dHVyZSh0aGlzLnRleHR1cmUsIHVuaXR8MClcbiAgICBcbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLnRleHR1cmUuX193ZWJnbFRleHR1cmUpXG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShUZXh0dXJlV3JhcC5wcm90b3R5cGUsIFwic2hhcGVcIiwge1xuXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdXBkYXRlU2l6ZSh0aGlzLl9zaGFwZSwgdGhpcy50ZXh0dXJlKVxuICAgICAgICByZXR1cm4gdGhpcy5fc2hhcGVcbiAgICB9XG59KVxuXG5mdW5jdGlvbiB1cGRhdGVTaXplKHNoYXBlLCB0ZXh0dXJlKSB7XG4gICAgc2hhcGVbMF0gPSAodGV4dHVyZS5pbWFnZSAmJiB0ZXh0dXJlLmltYWdlLndpZHRoKSAgfDBcbiAgICBzaGFwZVsxXSA9ICh0ZXh0dXJlLmltYWdlICYmIHRleHR1cmUuaW1hZ2UuaGVpZ2h0KSB8MFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFRleHR1cmVXcmFwIiwibW9kdWxlLmV4cG9ydHM9cmVxdWlyZShcIi9wcm9qZWN0cy9ibGFja2ljZS9ub2RlX21vZHVsZXMvYXMtbnVtYmVyL2luZGV4LmpzXCIpIiwibW9kdWxlLmV4cG9ydHMgPSBjcmVhdGU7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBpZGVudGl0eSBtYXQ0XG4gKlxuICogQHJldHVybnMge21hdDR9IGEgbmV3IDR4NCBtYXRyaXhcbiAqL1xuZnVuY3Rpb24gY3JlYXRlKCkge1xuICAgIHZhciBvdXQgPSBuZXcgRmxvYXQzMkFycmF5KDE2KTtcbiAgICBvdXRbMF0gPSAxO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs0XSA9IDA7XG4gICAgb3V0WzVdID0gMTtcbiAgICBvdXRbNl0gPSAwO1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0gMDtcbiAgICBvdXRbOV0gPSAwO1xuICAgIG91dFsxMF0gPSAxO1xuICAgIG91dFsxMV0gPSAwO1xuICAgIG91dFsxMl0gPSAwO1xuICAgIG91dFsxM10gPSAwO1xuICAgIG91dFsxNF0gPSAwO1xuICAgIG91dFsxNV0gPSAxO1xuICAgIHJldHVybiBvdXQ7XG59OyIsIm1vZHVsZS5leHBvcnRzPXJlcXVpcmUoXCIvcHJvamVjdHMvYmxhY2tpY2Uvbm9kZV9tb2R1bGVzL2dsLW1hdDQvbXVsdGlwbHkuanNcIikiLCJtb2R1bGUuZXhwb3J0cz1yZXF1aXJlKFwiL3Byb2plY3RzL2JsYWNraWNlL25vZGVfbW9kdWxlcy9nbC1tYXQ0L3NjYWxlLmpzXCIpIiwibW9kdWxlLmV4cG9ydHM9cmVxdWlyZShcIi9wcm9qZWN0cy9ibGFja2ljZS9ub2RlX21vZHVsZXMvZ2xzbGlmeS9ub2RlX21vZHVsZXMvZ2wtc2hhZGVyLWNvcmUvc2hhZGVyLWNvcmUuanNcIikiLCJ2YXIgQmFzZSA9IHJlcXVpcmUoJ2ZvbnRwYXRoLXNpbXBsZS1yZW5kZXJlcicpXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgYm1mb250MmZvbnRwYXRoID0gcmVxdWlyZSgnZm9udHBhdGgtYm1mb250JylcbnZhciB0ZXhjb29yZCA9IHJlcXVpcmUoJ3RleGNvb3JkJylcbnZhciB4dGVuZCA9IHJlcXVpcmUoJ3h0ZW5kJylcbnZhciBjcmVhdGVUZXh0dXJlID0gcmVxdWlyZSgnZ2wtdGV4dHVyZTJkJylcblxudmFyIEJhdGNoID0gcmVxdWlyZSgnZ2wtc3ByaXRlLWJhdGNoJylcblxudmFyIHRtcFBvcyA9IFswLCAwXSxcbiAgICB0bXBTaGFwZSA9IFswLCAwXSxcbiAgICB0bXAxID0gWzAsIDBdLFxuICAgIHRtcDIgPSBbMCwgMF1cbnZhciBERUZBVUxUX1RFWENPT1JEID0gWzAsIDAsIDEsIDFdXG52YXIgbWF4SW5pdGlhbENhcGFjaXR5ID0gNTAwXG5cbmZ1bmN0aW9uIHRleGNvb3JkR2x5cGgoZ2x5cGgsIGF0bGFzLCBvdXQpIHtcbiAgICB0bXAxWzBdID0gZ2x5cGgueFxuICAgIHRtcDFbMV0gPSBnbHlwaC55XG4gICAgdG1wMlswXSA9IGdseXBoLndpZHRoXG4gICAgdG1wMlsxXSA9IGdseXBoLmhlaWdodFxuICAgIHJldHVybiB0ZXhjb29yZCh0bXAxLCB0bXAyLCBhdGxhcywgb3V0KVxufVxuXG5mdW5jdGlvbiBUZXh0UmVuZGVyZXIoZ2wsIG9wdCkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBUZXh0UmVuZGVyZXIpKVxuICAgICAgICByZXR1cm4gbmV3IFRleHRSZW5kZXJlcihnbCwgb3B0KVxuICAgIG9wdCA9IG9wdHx8e31cblxuICAgIGlmICghb3B0LmZvbnQpIFxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ211c3Qgc3BlY2lmeSBibWZvbnQgYXQgY3JlYXRpb24gdGltZScpXG5cbiAgICAvL2lmIHRoZSBmb250IGhhcyBJbWFnZS9uZGFycmF5IGFycmF5XG4gICAgaWYgKCFvcHQudGV4dHVyZXMgJiYgQXJyYXkuaXNBcnJheShvcHQuZm9udC5pbWFnZXMpKSB7XG4gICAgICAgIG9wdC50ZXh0dXJlcyA9IG9wdC5mb250LmltYWdlcy5tYXAoZnVuY3Rpb24oaW1nKSB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlVGV4dHVyZShnbCwgaW1nKVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIG9wdC5mb250ID0gYm1mb250MmZvbnRwYXRoKG9wdC5mb250KVxuXG4gICAgQmFzZS5jYWxsKHRoaXMsIG9wdClcblxuICAgIHRoaXMudGV4dHVyZXMgPSBvcHQudGV4dHVyZXMgfHwgW11cbiAgICB0aGlzLmdsID0gZ2xcbiAgICBpZiAoIWdsKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtdXN0IHNwZWNpZnkgZ2wgY29udGV4dFwiKVxuICAgIFxuICAgIC8vYXNzdW1lIHRleHQgd2lsbCBiZSB1c2VkIGR5bmFtaWNhbGx5IFxuICAgIGlmICh0eXBlb2Ygb3B0LmR5bmFtaWMgIT09ICdib29sZWFuJylcbiAgICAgICAgb3B0LmR5bmFtaWMgPSB0cnVlXG5cbiAgICB2YXIgYmF0Y2ggPSBvcHQuYmF0Y2hcbiAgICBpZiAoIWJhdGNoKVxuICAgICAgICB0aGlzLmRlZmF1bHRCYXRjaCA9IEJhdGNoKGdsLCBvcHQpXG4gICAgdGhpcy5iYXRjaCA9IGJhdGNoIHx8IHRoaXMuZGVmYXVsdEJhdGNoXG5cbiAgICBpZiAodHlwZW9mIG9wdC53cmFwV2lkdGggIT09ICdudW1iZXInKVxuICAgICAgICB0aGlzLmxheW91dCgpXG59XG5cbmluaGVyaXRzKFRleHRSZW5kZXJlciwgQmFzZSlcblxuVGV4dFJlbmRlcmVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24odGV4dHVyZXMpIHtcbiAgICBpZiAodGhpcy5kZWZhdWx0QmF0Y2gpXG4gICAgICAgIHRoaXMuZGVmYXVsdEJhdGNoLmRpc3Bvc2UoKVxuICAgIGlmICh0ZXh0dXJlcykge1xuICAgICAgICB0aGlzLnRleHR1cmVzLmZvckVhY2goZnVuY3Rpb24odCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0LmRpc3Bvc2UgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICAgICAgdC5kaXNwb3NlKClcbiAgICAgICAgfSlcbiAgICB9XG4gICAgcmV0dXJuIHRoaXNcbn1cblxuVGV4dFJlbmRlcmVyLnByb3RvdHlwZS51bmNhY2hlID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fY2FjaGUgPSBmYWxzZVxuICAgIHRoaXMuYmF0Y2guY2xlYXIoKVxuICAgIHJldHVybiB0aGlzXG59XG5cblRleHRSZW5kZXJlci5wcm90b3R5cGUuY2FjaGUgPSBmdW5jdGlvbih4LCB5LCBzdGFydCwgZW5kKSB7XG4gICAgLy8gaWYgKHRoaXMudW5kZXJsaW5lIHx8IHRoaXMuZm9udC5wYWdlcy5sZW5ndGggPiAxKVxuICAgIC8vICAgICB0aHJvdyBuZXcgRXJyb3IoJ2N1cnJlbnRseSBjYWNoZWQgdGV4dCBkb2VzIG5vdCBzdXBwb3J0IHVuZGVybGluZXMgb3IgbXVsdGlwbGUgdGV4dHVyZSBwYWdlcycpXG4gICAgXG4gICAgdGhpcy5fY2FjaGUgPSB0cnVlXG4gICAgdGhpcy5iYXRjaC5lbnN1cmVDYXBhY2l0eSh0aGlzLnRleHQubGVuZ3RoKVxuICAgIHRoaXMuYmF0Y2guY2xlYXIoKVxuICAgIHRoaXMuX2J1aWxkKHgsIHksIHN0YXJ0LCBlbmQpXG4gICAgcmV0dXJuIHRoaXNcbn1cblxuVGV4dFJlbmRlcmVyLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24oc2hhZGVyLCB4LCB5LCBzdGFydCwgZW5kKSB7XG4gICAgdmFyIGJhdGNoID0gdGhpcy5iYXRjaFxuICAgIGJhdGNoLmJpbmQoc2hhZGVyKVxuXG4gICAgLy9pZiB3ZSdyZSBkcmF3aW5nIGR5bmFtaWNhbGx5XG4gICAgaWYgKCF0aGlzLl9jYWNoZSkge1xuICAgICAgICBiYXRjaC5jbGVhcigpXG4gICAgICAgIHRoaXMuX2J1aWxkKHgsIHksIHN0YXJ0LCBlbmQpXG4gICAgfVxuICAgIFxuICAgIGJhdGNoLmRyYXcoKVxuICAgIGJhdGNoLnVuYmluZCgpXG4gICAgcmV0dXJuIHRoaXNcbn1cblxuVGV4dFJlbmRlcmVyLnByb3RvdHlwZS5fYnVpbGQgPSBmdW5jdGlvbih4LCB5LCBzdGFydCwgZW5kKSB7XG4gICAgdmFyIHJlc3VsdCA9IHRoaXMucmVuZGVyKHgsIHksIHN0YXJ0LCBlbmQpXG5cbiAgICB2YXIgYmF0Y2ggPSB0aGlzLmJhdGNoXG4gICAgdmFyIGkgPSAwXG4gICAgXG4gICAgLy91bmRlcmxpbmVzIGN1cnJlbnRseSBub3Qgc3VwcG9ydGVkIHdpdGggY2FjaGUoKVxuICAgIGlmICghdGhpcy5fY2FjaGUpIHtcbiAgICAgICAgYmF0Y2gudGV4Y29vcmQgPSBERUZBVUxUX1RFWENPT1JEXG4gICAgICAgIGJhdGNoLnRleHR1cmUgPSBudWxsXG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHJlc3VsdC51bmRlcmxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgdW5kZXJsaW5lID0gcmVzdWx0LnVuZGVybGluZXNbaV1cbiAgICAgICAgICAgIGJhdGNoLnBvc2l0aW9uID0gdW5kZXJsaW5lLnBvc2l0aW9uXG4gICAgICAgICAgICBiYXRjaC5zaGFwZSA9IHVuZGVybGluZS5zaXplXG4gICAgICAgICAgICBiYXRjaC5wdXNoKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vbm93IGRyYXcgb3VyIGdseXBocyBpbnRvIHRoZSBiYXRjaC4uLlxuICAgIGZvciAoaSA9IDA7IGkgPCByZXN1bHQuZ2x5cGhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBnID0gcmVzdWx0LmdseXBoc1tpXVxuICAgICAgICB0aGlzLl9kcmF3R2x5cGgoYmF0Y2gsIGcpXG4gICAgfVxufVxuXG5UZXh0UmVuZGVyZXIucHJvdG90eXBlLl9kcmF3R2x5cGggPSBmdW5jdGlvbihiYXRjaCwgZGF0YSkge1xuICAgIC8vLi4uIHdlIGNvdWxkIHNvcnQgdGhlc2UgYnkgdGV4dHVyZSBwYWdlIHRvIHJlZHVjZSBkcmF3c1xuICAgIHZhciBnbHlwaCA9IGRhdGEuZ2x5cGhcbiAgICB2YXIgaW1nID0gdGhpcy50ZXh0dXJlc1tnbHlwaC5wYWdlXVxuICAgIHRtcFBvc1swXSA9IGRhdGEucG9zaXRpb25bMF0rZ2x5cGguaGJ4XG4gICAgdG1wUG9zWzFdID0gZGF0YS5wb3NpdGlvblsxXStnbHlwaC5oYnkgLSB0aGlzLmZvbnQuZGVzY2VuZGVyXG4gICAgdG1wU2hhcGVbMF0gPSBnbHlwaC53aWR0aCAqIGRhdGEuc2NhbGVbMF1cbiAgICB0bXBTaGFwZVsxXSA9IGdseXBoLmhlaWdodCAqIGRhdGEuc2NhbGVbMV1cbiAgICBcbiAgICBiYXRjaC50ZXh0dXJlID0gaW1nXG4gICAgdGV4Y29vcmRHbHlwaChnbHlwaCwgaW1nICYmIGltZy5zaGFwZSwgYmF0Y2gudGV4Y29vcmQpXG4gICAgYmF0Y2gucG9zaXRpb24gPSB0bXBQb3NcbiAgICBiYXRjaC5zaGFwZSA9IHRtcFNoYXBlXG4gICAgYmF0Y2gucHVzaCgpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gVGV4dFJlbmRlcmVyIiwiZnVuY3Rpb24gZ2x5cGgoZGF0YSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHBhZ2U6IGRhdGEucGFnZSxcbiAgICAgICAgaGJ4OiBkYXRhLnhvZmZzZXQsXG4gICAgICAgIGhieTogZGF0YS55b2Zmc2V0LFxuICAgICAgICB3aWR0aDogZGF0YS53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBkYXRhLmhlaWdodCxcbiAgICAgICAgeG9mZjogZGF0YS54YWR2YW5jZSxcbiAgICAgICAgeDogZGF0YS54LFxuICAgICAgICB5OiBkYXRhLnlcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGdseXBocyhjaGFycykge1xuICAgIHZhciBvdXQgPSB7fVxuICAgIGNoYXJzLmZvckVhY2goZnVuY3Rpb24oYykge1xuICAgICAgICBvdXRbU3RyaW5nLmZyb21DaGFyQ29kZShjLmlkKV0gPSBnbHlwaChjKVxuICAgIH0pXG4gICAgcmV0dXJuIG91dFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGJtZm9udCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHBhZ2VzOiBibWZvbnQucGFnZXMsXG4gICAgICAgIHJlc29sdXRpb246IDcyLFxuICAgICAgICBzaXplOiBibWZvbnQuaW5mby5zaXplLFxuICAgICAgICB1bml0c19wZXJfRU06IDEsXG4gICAgICAgIGJpdG1hcDogdHJ1ZSxcbiAgICAgICAgZmFtaWx5X25hbWU6IGJtZm9udC5pbmZvLmZhY2UsXG4gICAgICAgIGhlaWdodDogYm1mb250LmNvbW1vbi5saW5lSGVpZ2h0LFxuICAgICAgICBkZXNjZW5kZXI6IGJtZm9udC5jb21tb24uYmFzZSxcbiAgICAgICAgYXNjZW5kZXI6IGJtZm9udC5jb21tb24uYmFzZSxcbiAgICAgICAgZ2x5cGhzOiBnbHlwaHMoYm1mb250LmNoYXJzKSxcbiAgICAgICAga2VybmluZzogYm1mb250Lmtlcm5pbmdzLm1hcChmdW5jdGlvbihrKSB7XG4gICAgICAgICAgICByZXR1cm4gW1N0cmluZy5mcm9tQ2hhckNvZGUoay5maXJzdCksU3RyaW5nLmZyb21DaGFyQ29kZShrLnNlY29uZCksay5hbW91bnRdXG4gICAgICAgIH0pXG4gICAgfVxufSIsInZhciBCYXNlID0gcmVxdWlyZSgnZm9udHBhdGgtcmVuZGVyZXInKVxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuXG4vL1RPRE86IEV2ZW50dWFsbHkgbG90cyBvZiB0aGlzIGNvZGUgd2lsbCBqdXN0IHJlcGxhY2UgZm9udHBhdGgtcmVuZGVyZXIuLi5cblxuZnVuY3Rpb24gRm9udHBhdGhSZW5kZXJlcihvcHRpb25zKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEZvbnRwYXRoUmVuZGVyZXIpKVxuICAgICAgICByZXR1cm4gbmV3IEZvbnRwYXRoUmVuZGVyZXIob3B0aW9ucylcbiAgICBCYXNlLmNhbGwodGhpcywgb3B0aW9ucylcblxuICAgIHRoaXMuZGF0YSA9IHtcbiAgICAgICAgZ2x5cGhzOiBbXSxcbiAgICAgICAgdW5kZXJsaW5lczogW11cbiAgICB9XG59XG5cbmluaGVyaXRzKEZvbnRwYXRoUmVuZGVyZXIsIEJhc2UpXG5cbkZvbnRwYXRoUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlckdseXBoID0gZnVuY3Rpb24oaSwgZ2x5cGgsIHNjYWxlLCB4LCB5KSB7XG4gICAgdGhpcy5kYXRhLmdseXBocy5wdXNoKG5ldyBHbHlwaChpLCBnbHlwaCwgXG4gICAgICAgICAgICAgICAgdGhpcy50ZXh0LmNoYXJDb2RlQXQoaSksIFxuICAgICAgICAgICAgICAgIFsgc2NhbGUsIHRoaXMuZm9udC5iaXRtYXAgPyBzY2FsZSA6IC1zY2FsZSBdLFxuICAgICAgICAgICAgICAgIFsgeCwgeSBdKSlcbn1cblxuRm9udHBhdGhSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyVW5kZXJsaW5lID0gZnVuY3Rpb24oeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgIHRoaXMuZGF0YS51bmRlcmxpbmVzLnB1c2gobmV3IFVuZGVybGluZShcbiAgICAgICAgWyB4LCB5IF0sXG4gICAgICAgIFsgd2lkdGgsIGhlaWdodCBdXG4gICAgKSlcbn1cblxuRm9udHBhdGhSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24oeCwgeSwgc3RhcnQsIGVuZCkge1xuICAgIC8vbmV3IGRhdGEgZm9yIHJlc3VsdFxuICAgIHRoaXMuZGF0YS5nbHlwaHMubGVuZ3RoID0gMFxuICAgIHRoaXMuZGF0YS51bmRlcmxpbmVzLmxlbmd0aCA9IDBcbiAgICBCYXNlLnByb3RvdHlwZS5yZW5kZXIuY2FsbCh0aGlzLCB4LCB5LCBzdGFydCwgZW5kKVxuICAgIHJldHVybiB0aGlzLmRhdGFcbn1cblxuZnVuY3Rpb24gR2x5cGgoaW5kZXgsIGdseXBoLCBjaGFyQ29kZSwgc2NhbGUsIHBvc2l0aW9uKSB7XG4gICAgdGhpcy5nbHlwaCA9IGdseXBoXG4gICAgdGhpcy5pbmRleCA9IGluZGV4XG4gICAgdGhpcy5jaGFyQ29kZSA9IGNoYXJDb2RlXG4gICAgdGhpcy5wb3NpdGlvbiA9IHBvc2l0aW9uXG4gICAgdGhpcy5zY2FsZSA9IHNjYWxlXG59XG5cbmZ1bmN0aW9uIFVuZGVybGluZShwb3NpdGlvbiwgc2l6ZSkge1xuICAgIHRoaXMucG9zaXRpb24gPSBwb3NpdGlvblxuICAgIHRoaXMuc2l6ZSA9IHNpemVcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBGb250cGF0aFJlbmRlcmVyIiwidmFyIEdseXBoSXRlcmF0b3IgPSByZXF1aXJlKCdmb250cGF0aC1nbHlwaC1pdGVyYXRvcicpO1xudmFyIFdvcmRXcmFwID0gcmVxdWlyZSgnZm9udHBhdGgtd29yZHdyYXAnKTtcblxudmFyIHRtcEJvdW5kcyA9IHsgeDogMCwgeTogMCwgd2lkdGg6IDAsIGhlaWdodDogMCwgZ2x5cGhzOiAwIH07XG5cbmZ1bmN0aW9uIFRleHRSZW5kZXJlcihvcHRpb25zKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFRleHRSZW5kZXJlcikpXG4gICAgICAgIHJldHVybiBuZXcgVGV4dFJlbmRlcmVyKG9wdGlvbnMpO1xuICAgIG9wdGlvbnMgPSBvcHRpb25zfHx7fVxuXG4gICAgdGhpcy5pdGVyYXRvciA9IG5ldyBHbHlwaEl0ZXJhdG9yKG9wdGlvbnMuZm9udCwgb3B0aW9ucy5mb250U2l6ZSk7XG4gICAgdGhpcy53b3Jkd3JhcCA9IG5ldyBXb3JkV3JhcCgpO1xuXG4gICAgdGhpcy5hbGlnbiA9ICdsZWZ0JztcbiAgICB0aGlzLnVuZGVybGluZSA9IGZhbHNlO1xuXG4gICAgdGhpcy51bmRlcmxpbmVUaGlja25lc3MgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy51bmRlcmxpbmVQb3NpdGlvbiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl90ZXh0ID0gXCJcIjtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5hbGlnbiA9PT0gJ3N0cmluZycpXG4gICAgICAgIHRoaXMuYWxpZ24gPSBvcHRpb25zLmFsaWduO1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy51bmRlcmxpbmUgPT09ICdib29sZWFuJylcbiAgICAgICAgdGhpcy51bmRlcmxpbmUgPSBvcHRpb25zLnVuZGVybGluZTtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMudW5kZXJsaW5lVGhpY2tuZXNzID09PSAnbnVtYmVyJylcbiAgICAgICAgdGhpcy51bmRlcmxpbmVUaGlja25lc3MgPSBvcHRpb25zLnVuZGVybGluZVRoaWNrbmVzcztcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMudW5kZXJsaW5lUG9zaXRpb24gPT09ICdudW1iZXInKVxuICAgICAgICB0aGlzLnVuZGVybGluZVBvc2l0aW9uID0gb3B0aW9ucy51bmRlcmxpbmVQb3NpdGlvbjtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMudGV4dCA9PT0gJ3N0cmluZycpXG4gICAgICAgIHRoaXMudGV4dCA9IG9wdGlvbnMudGV4dDtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMubGluZUhlaWdodCA9PT0gJ251bWJlcicpXG4gICAgICAgIHRoaXMubGluZUhlaWdodCA9IG9wdGlvbnMubGluZUhlaWdodDtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMubGV0dGVyU3BhY2luZyA9PT0gJ251bWJlcicpXG4gICAgICAgIHRoaXMubGV0dGVyU3BhY2luZyA9IG9wdGlvbnMubGV0dGVyU3BhY2luZztcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMud3JhcE1vZGUgPT09ICdzdHJpbmcnKVxuICAgICAgICB0aGlzLndvcmR3cmFwLm1vZGUgPSBvcHRpb25zLndyYXBNb2RlO1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy53cmFwV2lkdGggPT09ICdudW1iZXInKVxuICAgICAgICB0aGlzLmxheW91dChvcHRpb25zLndyYXBXaWR0aCk7XG59XG5cbi8vSW50ZXJuYWxseSB3ZSB3aWxsIHVzZSBpbnRlZ2VycyB0byBhdm9pZCBzdHJpbmcgY29tcGFyaXNvbiBmb3IgZWFjaCBnbHlwaFxudmFyIExFRlRfQUxJR04gPSAwLCBDRU5URVJfQUxJR04gPSAxLCBSSUdIVF9BTElHTiA9IDI7XG52YXIgQUxJR05fQVJSQVkgPSBbXG4gICAgJ2xlZnQnLCBcbiAgICAnY2VudGVyJywgXG4gICAgJ3JpZ2h0J1xuXTtcbiAgICBcbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFRleHRSZW5kZXJlci5wcm90b3R5cGUsIHtcbiAgICAvKipcbiAgICAgKiBJZiB0aGUgbmV3IGZvbnQgZGlmZmVycyBmcm9tIHRoZSBsYXN0LCB0aGUgdGV4dCBsYXlvdXQgaXMgY2xlYXJlZFxuICAgICAqIGFuZCBwbGFjZWQgb250byBhIHNpbmdsZSBsaW5lLiBVc2VycyBtdXN0IG1hbnVhbGx5IHJlLWxheW91dCB0aGUgdGV4dCBcbiAgICAgKiBmb3Igd29yZCB3cmFwcGluZy5cbiAgICAgKi9cbiAgICBcImZvbnRcIjoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXRlcmF0b3IuZm9udDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgICAgIHZhciBvbGRGb250ID0gdGhpcy5pdGVyYXRvci5mb250O1xuICAgICAgICAgICAgdGhpcy5pdGVyYXRvci5mb250ID0gdmFsO1xuICAgICAgICAgICAgaWYgKG9sZEZvbnQgIT09IHRoaXMuaXRlcmF0b3IuZm9udClcbiAgICAgICAgICAgICAgICB0aGlzLmNsZWFyTGF5b3V0KCk7XG4gICAgICAgIH0sXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIElmIHRoZSBuZXcgZm9udCBzaXplIGRpZmZlcnMgZnJvbSB0aGUgbGFzdCwgdGhlIHRleHQgbGF5b3V0IGlzIGNsZWFyZWRcbiAgICAgKiBhbmQgcGxhY2VkIG9udG8gYSBzaW5nbGUgbGluZS4gVXNlcnMgbXVzdCBtYW51YWxseSByZS1sYXlvdXQgdGhlIHRleHQgXG4gICAgICogZm9yIHdvcmQgd3JhcHBpbmcuXG4gICAgICovXG4gICAgXCJmb250U2l6ZVwiOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pdGVyYXRvci5mb250U2l6ZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgICAgIHZhciBvbGRTaXplID0gdGhpcy5pdGVyYXRvci5mb250U2l6ZTtcblxuICAgICAgICAgICAgdGhpcy5pdGVyYXRvci5mb250U2l6ZSA9IHZhbDtcblxuICAgICAgICAgICAgaWYgKG9sZFNpemUgIT09IHRoaXMuaXRlcmF0b3IuZm9udFNpemUpXG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhckxheW91dCgpO1xuICAgICAgICB9LFxuICAgIH0sXG4gICAgXCJsaW5lSGVpZ2h0XCI6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZXJhdG9yLmxpbmVIZWlnaHQ7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICB0aGlzLml0ZXJhdG9yLmxpbmVIZWlnaHQgPSB2YWw7XG4gICAgICAgIH0sXG4gICAgfSxcbiAgICBcImxldHRlclNwYWNpbmdcIjoge1xuICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZXJhdG9yLmxldHRlclNwYWNpbmc7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICB0aGlzLml0ZXJhdG9yLmxldHRlclNwYWNpbmcgPSB2YWw7XG4gICAgICAgIH0sXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIElmIHRoZSBuZXcgdGV4dCBpcyBkaWZmZXJlbnQgZnJvbSB0aGUgbGFzdCwgdGhlIGxheW91dCAoaS5lLiB3b3JkLXdyYXBwaW5nKVxuICAgICAqIGlzIGNsZWFyZWQgYW5kIHRoZSByZXN1bHQgaXMgYSBzaW5nbGUgbGluZSBvZiB0ZXh0IChzaW1pbGFyIHRvIEhUTUw1IGNhbnZhcyB0ZXh0XG4gICAgICogcmVuZGVyaW5nKS5cbiAgICAgKiBcbiAgICAgKiBUaGUgdGV4dCB0aGVuIG5lZWRzIHRvIGJlIHJlLXdvcmR3cmFwcGVkIHdpdGggYSBjYWxsIHRvIGBsYXlvdXQoKWAuXG4gICAgICovXG4gICAgXCJ0ZXh0XCI6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90ZXh0O1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldDogZnVuY3Rpb24odGV4dCkge1xuICAgICAgICAgICAgdGV4dCA9IHRleHR8fFwiXCI7XG5cbiAgICAgICAgICAgIHZhciBvbGQgPSB0aGlzLl90ZXh0O1xuICAgICAgICAgICAgdGhpcy5fdGV4dCA9IHRleHQ7XG4gICAgICAgICAgICB0aGlzLndvcmR3cmFwLnRleHQgPSB0aGlzLnRleHQ7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl90ZXh0ICE9PSBvbGQpIFxuICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJMYXlvdXQoKTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG4vKipcbiAqIENsZWFycyB0aGUgdGV4dCBsYXlvdXQgYW5kIHdvcmQtd3JhcHBpbmcsIHBsYWNpbmcgYWxsIG9mIGl0IG9uIGEgc2luZ2xlIGxpbmUuXG4gKi9cblRleHRSZW5kZXJlci5wcm90b3R5cGUuY2xlYXJMYXlvdXQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLndvcmR3cmFwLnRleHQgPSB0aGlzLnRleHQ7XG4gICAgdGhpcy53b3Jkd3JhcC5lbXB0eSgpO1xuXG4gICAgaWYgKHRoaXMuaXRlcmF0b3IuZm9udCkgLy9mb250IG1pZ2h0IG5vdCBoYXZlIGJlZW4gcGFzc2VkIGF0IGNvbnN0cnVjdG9yXG4gICAgICAgIHRoaXMud29yZHdyYXAuY2xlYXJMYXlvdXQodGhpcy5pdGVyYXRvcik7XG59O1xuXG4vKipcbiAqIENhbGxzIHRoZSB3b3JkIHdyYXBwZXIgdG8gbGF5b3V0IHRoZSBjdXJyZW50IHRleHQgc3RyaW5nLFxuICogYmFzZWQgb24gdGhlIHdyYXAgd2lkdGggYW5kIGFueSBjdXJyZW50IHdvcmR3cmFwcGluZyBvcHRpb25zLlxuICpcbiAqIFRoaXMgaXMgY2FsbGVkIHdoZW4gdGhlIHRleHQgaXMgY2hhbmdlZC4gXG4gKiBcbiAqIEByZXR1cm4ge1t0eXBlXX0gW2Rlc2NyaXB0aW9uXVxuICovXG5UZXh0UmVuZGVyZXIucHJvdG90eXBlLmxheW91dCA9IGZ1bmN0aW9uKHdyYXBXaWR0aCkge1xuICAgIHRoaXMud29yZHdyYXAudGV4dCA9IHRoaXMudGV4dDtcbiAgICB0aGlzLndvcmR3cmFwLmVtcHR5KCk7XG4gICAgdGhpcy53b3Jkd3JhcC5sYXlvdXQodGhpcy5pdGVyYXRvciwgd3JhcFdpZHRoKTtcbn07XG5cbi8qKlxuICogXCJSZW5kZXJzXCIgdGhpcyBnbHlwaCBhdCB0aGUgZ2l2ZW4gbG9jYXRpb24uIFRoaXMgbWF5IGludm9sdmUgZmlsbGluZ1xuICogYSBWQk8gd2l0aCB2ZXJ0ZXggZGF0YSwgb3IgaXQgbWF5IGJlIGEgZGlyZWN0IGNhbGwgdG8gZHJhdyBhIGJpdG1hcCBnbHlwaFxuICogb3Igc2hhcGUgb3V0bGluZS5cbiAqIEByZXR1cm4ge1t0eXBlXX0gW2Rlc2NyaXB0aW9uXVxuICovXG5UZXh0UmVuZGVyZXIucHJvdG90eXBlLnJlbmRlckdseXBoID0gZnVuY3Rpb24oKSB7XG5cbn07XG5cblRleHRSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyVW5kZXJsaW5lID0gZnVuY3Rpb24oKSB7XG5cbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgYm91bmRzIG9mIHRoZSBjdXJyZW50IHRleHQgbGF5b3V0LiBcbiAqXG4gKiBUaGUgaGVpZ2h0IGRvZXMgbm90IGV4dGVuZCBwYXN0IHRoZSBiYXNlbGluZSBvZiB0aGVcbiAqIGxhc3QgbGluZTsgdW5sZXNzIGBpbmNsdWRlVW5kZXJsaW5lYCBpcyB0cnVlLCBpbiB3aGljaFxuICogY2FzZSB0aGUgdW5kZXJsaW5lJ3MgcG9zaXRpb24gYW5kIGhlaWdodCBpcyBpbmNsdWRlZFxuICogaW4gdGhlIGNhbGN1bGF0aW9uLiBcbiAqXG4gKiBUaGUgYm91bmRpbmcgeSBwb3NpdGlvbiBpcyBvZmZzZXQgc28gdGhhdCB0aGUgYm94IGhhcyBhbiB1cHBlci1sZWZ0XG4gKiBvcmlnaW4sIGZvciBwYXJpdHkgd2l0aCBIVE1MNSBjYW52YXMgcmVuZGVyaW5nLlxuICogXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGluY2x1ZGVVbmRlcmxpbmUgd2hldGhlciB0byBpbmNsdWRlIHRoZSB1bmRlcmxpbmUgaW4gdGhlIGNhbGN1bGF0aW9uLCBkZWZhdWx0IGZhbHNlXG4gKiBAcGFyYW0ge09iamVjdH0gb3V0IGFuIG9wdGlvbmFsIHt3aWR0aCwgaGVpZ2h0fSBvYmplY3QgZm9yIHJlLXVzZVxuICogQHJldHVybiB7T2JqZWN0fSBhIHNpemUgd2l0aCB7IHdpZHRoLCBoZWlnaHQgfSBwcm9wZXJ0aWVzXG4gKi9cblRleHRSZW5kZXJlci5wcm90b3R5cGUuZ2V0Qm91bmRzID0gZnVuY3Rpb24gKGluY2x1ZGVVbmRlcmxpbmUsIG91dCkge1xuICAgIGlmICghb3V0KVxuICAgICAgICBvdXQgPSB7IHg6IDAsIHk6IDAsIHdpZHRoOiAwLCBoZWlnaHQ6IDAgfTtcblxuICAgIHZhciB3b3Jkd3JhcHBlciA9IHRoaXMud29yZHdyYXA7XG4gICAgdmFyIGl0ciA9IHRoaXMuaXRlcmF0b3I7XG5cbiAgICAvL3RpZ2h0ZW4gdGhlIGJvdW5kaW5nIGJveCBhcm91bmQgdGhlIGZpcnN0IGxpbmUuLlxuICAgIHZhciBmaXJzdExpbmVIZWlnaHQgPSAwO1xuICAgIGlmICh3b3Jkd3JhcHBlci5saW5lcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciBmaXJzdExpbmUgPSB3b3Jkd3JhcHBlci5saW5lc1swXTtcbiAgICAgICAgaXRyLmdldEJvdW5kcyh0aGlzLnRleHQsIGZpcnN0TGluZS5zdGFydCwgZmlyc3RMaW5lLmVuZCwgdW5kZWZpbmVkLCB0bXBCb3VuZHMpO1xuICAgICAgICBmaXJzdExpbmVIZWlnaHQgPSB0bXBCb3VuZHMuaGVpZ2h0O1xuICAgIH1cblxuICAgIG91dC53aWR0aCA9IHdvcmR3cmFwcGVyLmdldE1heExpbmVXaWR0aCgpOyAgIFxuICAgIG91dC5oZWlnaHQgPSBNYXRoLm1heCgwLCB3b3Jkd3JhcHBlci5saW5lcy5sZW5ndGgtMSkgKiBpdHIuZ2V0TGluZUdhcCgpICsgZmlyc3RMaW5lSGVpZ2h0O1xuXG4gICAgb3V0LnggPSAwO1xuICAgIG91dC55ID0gLW91dC5oZWlnaHQ7XG5cbiAgICBpZiAoaW5jbHVkZVVuZGVybGluZSkge1xuICAgICAgICB2YXIgdW5kZXJsaW5lSGVpZ2h0ID0gdGhpcy5jb21wdXRlVW5kZXJsaW5lSGVpZ2h0KCk7XG4gICAgICAgIHZhciB1bmRlcmxpbmVQb3NpdGlvbiA9IHRoaXMuY29tcHV0ZVVuZGVybGluZVBvc2l0aW9uKCk7XG4gICAgICAgIHZhciB1bmRlcmxpbmVPZmYgPSB1bmRlcmxpbmVQb3NpdGlvbit1bmRlcmxpbmVIZWlnaHQvMjtcbiAgICAgICAgb3V0LmhlaWdodCArPSB1bmRlcmxpbmVPZmY7XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIHNjYWxlZCB1bmRlcmxpbmUgaGVpZ2h0IGFzIHBpeGVscywgYmFzZWQgb24gXG4gKiB0aGUgZXhwbGljaXQgYHVuZGVybGluZUhlaWdodGAgKGluIHBpeGVscykuIElmIGB1bmRlcmxpbmVIZWlnaHRgIGlzXG4gKiB1bmRlZmluZWQgb3IgbnVsbCwgaXQgd2lsbCB0cnkgdG8gdXNlIHRoZSBmb250J3Mgbm9uLXplcm8gdW5kZXJsaW5lIGhlaWdodCwgXG4gKiBvdGhlcndpc2UgZGVmYXVsdCB0byAxLzggb2YgdGhlIGZvbnQncyBFTSBzcXVhcmUuXG4gKiBcbiAqIEByZXR1cm4ge051bWJlcn0gdGhlIHBpeGVsIGhlaWdodCBvZiB0aGUgdW5kZXJsaW5lIFxuICovXG5UZXh0UmVuZGVyZXIucHJvdG90eXBlLmNvbXB1dGVVbmRlcmxpbmVIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGZvbnQgPSB0aGlzLmZvbnQ7XG4gICAgdmFyIHNjYWxlID0gdGhpcy5pdGVyYXRvci5mb250U2NhbGU7XG4gICAgaWYgKHRoaXMudW5kZXJsaW5lVGhpY2tuZXNzPT09MHx8dGhpcy51bmRlcmxpbmVUaGlja25lc3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudW5kZXJsaW5lVGhpY2tuZXNzOyBcbiAgICB9IGVsc2UgaWYgKGZvbnQudW5kZXJsaW5lX3RoaWNrbmVzcykge1xuICAgICAgICByZXR1cm4gZm9udC51bmRlcmxpbmVfdGhpY2tuZXNzICogc2NhbGU7IFxuICAgIH0gZWxzZSBpZiAoZm9udC5iaXRtYXApXG4gICAgICAgIHJldHVybiBmb250LnNpemUvODtcbiAgICBlbHNlXG4gICAgICAgIHJldHVybiAoZm9udC51bml0c19wZXJfRU0vOCkqc2NhbGU7XG59O1xuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBzY2FsZWQgdW5kZXJsaW5lIGhlaWdodCBhcyBwaXhlbHMsIGJhc2VkIG9uIFxuICogdGhlIGV4cGxpY2l0IGB1bmRlcmxpbmVQb3NpdGlvbmAgKGluIHBpeGVscykuIElmIGB1bmRlcmxpbmVQb3NpdGlvbmAgaXNcbiAqIHVuZGVmaW5lZCBvciBudWxsLCBpdCB3aWxsIHRyeSB0byB1c2UgdGhlIGZvbnQncyBub24temVybyB1bmRlcmxpbmUgcG9zaXRpb24sIFxuICogb3RoZXJ3aXNlIGRlZmF1bHQgdG8gMS80IG9mIHRoZSBmb250J3MgRU0gc3F1YXJlLlxuICpcbiAqIFRoaXMgaXMgdGhlIFkgb2Zmc2V0IGZyb20gdGhlIHRleHQgYmFzZWxpbmUgdG8gdGhlIGNlbnRlciBvZiB0aGUgdW5kZXJsaW5lIFxuICogYmFyLCBpbiBwaXhlbHMuIEl0IGlzIGdlbmVyYWxseSBhIHBvc2l0aXZlIHZhbHVlLlxuICogXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IHRoZSBwaXhlbCBwb3NpdGlvbiBvZiB0aGUgdW5kZXJsaW5lIFxuICovXG5UZXh0UmVuZGVyZXIucHJvdG90eXBlLmNvbXB1dGVVbmRlcmxpbmVQb3NpdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZm9udCA9IHRoaXMuZm9udDtcbiAgICB2YXIgc2NhbGUgPSB0aGlzLml0ZXJhdG9yLmZvbnRTY2FsZTtcbiAgICAgICAgXG4gICAgaWYgKHRoaXMudW5kZXJsaW5lUG9zaXRpb249PT0wfHx0aGlzLnVuZGVybGluZVBvc2l0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVuZGVybGluZVBvc2l0aW9uOyBcbiAgICB9IGVsc2UgaWYgKGZvbnQudW5kZXJsaW5lX3Bvc2l0aW9uKSB7XG4gICAgICAgIHJldHVybiAtZm9udC51bmRlcmxpbmVfcG9zaXRpb24gKiBzY2FsZTsgXG4gICAgfSBlbHNlIGlmIChmb250LmJpdG1hcCkge1xuICAgICAgICByZXR1cm4gZm9udC5zaXplLzQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIChmb250LnVuaXRzX3Blcl9FTS80KSpzY2FsZTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEdldHMgdGhlIGRlc2NlbnQgb2YgdGhlIGN1cnJlbnQgZm9udCAoYXNzdW1lcyBpdHMgc2l6ZSBcbiAqIGlzIGFscmVhZHkgc2V0KS4gVGhpcyBpcyBhbiBhYnNvbHV0ZSAocG9zaXRpdmUpIHZhbHVlLlxuICogXG4gKiBAcmV0dXJuIHtbdHlwZV19IFtkZXNjcmlwdGlvbl1cbiAqL1xuVGV4dFJlbmRlcmVyLnByb3RvdHlwZS5nZXREZXNjZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIE1hdGguYWJzKHRoaXMuaXRlcmF0b3IuZm9udFNjYWxlICogdGhpcy5pdGVyYXRvci5mb250LmRlc2NlbmRlcik7XG59O1xuXG4vKipcbiAqIEdldHMgdGhlIGRlc2NlbnQgb2YgdGhlIGN1cnJlbnQgZm9udCAoYXNzdW1lcyBpdHMgc2l6ZSBcbiAqIGlzIGFscmVhZHkgc2V0KS4gVGhpcyBpcyBhbiBhYnNvbHV0ZSAocG9zaXRpdmUpIHZhbHVlLlxuICogXG4gKiBAcmV0dXJuIHtbdHlwZV19IFtkZXNjcmlwdGlvbl1cbiAqL1xuVGV4dFJlbmRlcmVyLnByb3RvdHlwZS5nZXRBc2NlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gTWF0aC5hYnModGhpcy5pdGVyYXRvci5mb250U2NhbGUgKiB0aGlzLml0ZXJhdG9yLmZvbnQuYXNjZW5kZXIpO1xufTtcblxuLy9TaWduYWxzIGZvciBzdWJjbGFzc2VzIHRvIG9wdGlvbmFsbHkgaW1wbG1lZW50XG4vL1RoaXMgbWF5IGJlIHVzZWZ1bCB0byBzdG9wL3N0YXJ0IHBhdGhzIHdpdGggZGlmZmVyZW50IGZpbGxzXG5UZXh0UmVuZGVyZXIucHJvdG90eXBlLm9uQmVnaW4gPSBmdW5jdGlvbigpIHsgfVxuVGV4dFJlbmRlcmVyLnByb3RvdHlwZS5vbkVuZCA9IGZ1bmN0aW9uKCkgeyB9XG5UZXh0UmVuZGVyZXIucHJvdG90eXBlLm9uQmVnaW5MaW5lID0gZnVuY3Rpb24obGluZUluZGV4KSB7IH1cblRleHRSZW5kZXJlci5wcm90b3R5cGUub25FbmRMaW5lID0gZnVuY3Rpb24obGluZUluZGV4KSB7IH1cblxuLyoqXG4gKiBSZW5kZXJzIHRoZSBjdXJyZW50IHRleHQgbGF5b3V0LCB3aGVyZSBsb3dlci1sZWZ0IGlzIFxuICogdGhlIG9yaWdpbi4gTXVsdGlwbGUgbGluZXMgd2lsbCBiZSBwb3NpdGlvbmVkIGFib3ZlIHRoZVxuICogb3JpZ2luLlxuICovXG5UZXh0UmVuZGVyZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICh4LCB5LCBzdGFydCwgZW5kKSB7XG4gICAgeCA9IHh8fDA7XG4gICAgeSA9IHl8fDA7XG5cbiAgICB2YXIgdGV4dCA9IHRoaXMudGV4dDtcbiAgICB2YXIgd29yZHdyYXBwZXIgPSB0aGlzLndvcmR3cmFwO1xuXG4gICAgLy9pZiB3ZSBoYXZlIG5vdGhpbmcgdG8gZHJhd1xuICAgIGlmICghdGV4dCB8fCB3b3Jkd3JhcHBlci5saW5lcy5sZW5ndGggPT09IDApXG4gICAgICAgIHJldHVybjtcblxuICAgIC8vZGVmYXVsdCBzdGFydC9lbmQgcGFyYW1zXG4gICAgc3RhcnQgPSBzdGFydHx8MDtcbiAgICBlbmQgPSB0eXBlb2YgZW5kID09PSBcIm51bWJlclwiID8gZW5kIDogdGV4dC5sZW5ndGg7XG5cbiAgICB2YXIgaXRyID0gdGhpcy5pdGVyYXRvcjtcbiAgICB2YXIgc2NhbGUgPSBpdHIuZm9udFNjYWxlO1xuICAgIHZhciBmb250ID0gaXRyLmZvbnQ7XG4gICAgdmFyIHVuZGVybGluZSA9IHRoaXMudW5kZXJsaW5lO1xuXG4gICAgLy91c2VkIGZvciBhbGlnbm1lbnQuLi5cbiAgICB2YXIgbWF4TGluZVdpZHRoID0gd29yZHdyYXBwZXIuZ2V0TWF4TGluZVdpZHRoKCk7XG4gICAgXG4gICAgeSAtPSBNYXRoLm1heCgwLCB3b3Jkd3JhcHBlci5saW5lcy5sZW5ndGgtMSkgKiBpdHIuZ2V0TGluZUdhcCgpO1xuXG5cbiAgICAvL3VzZSBudW1iZXJzIHRvIGF2b2lkIHN0ciBjb21wYXJlIGZvciBlYWNoIGdseXBoXG4gICAgdmFyIGFsaWduVHlwZSA9IEFMSUdOX0FSUkFZLmluZGV4T2YodGhpcy5hbGlnbnx8XCJcIik7XG4gICAgaWYgKGFsaWduVHlwZT09PS0xKVxuICAgICAgICBhbGlnblR5cGUgPSBMRUZUX0FMSUdOO1xuXG4gICAgdmFyIHVuZGVybGluZVggPSAwO1xuICAgIHZhciB1bmRlcmxpbmVTdGFydFggPSAwO1xuICAgIHZhciB1bmRlcmxpbmVZID0gMDtcbiAgICB2YXIgdW5kZXJsaW5lV2lkdGggPSAwO1xuXG4gICAgdmFyIHVuZGVybGluZVN0YXJ0ZWQgPSBmYWxzZTtcblxuICAgIC8vVHJ5IHRvIHVzZSB1c2VyLXNwZWNpZmllZCB1bmRlcmxpbmUgc2V0dGluZ3MsIG90aGVyd2lzZSB1c2UgdGhlIGZvbnQgaWYgcG9zc2libGUsXG4gICAgLy9vdGhlcndpc2UganVzdCB1c2UgYSByb3VnaCBkZWZhdWx0IGJhc2VkIG9uIEVNIHNxdWFyZS4gICAgXG4gICAgdmFyIHVuZGVybGluZVBvcyA9IHRoaXMuY29tcHV0ZVVuZGVybGluZVBvc2l0aW9uKCk7XG4gICAgdmFyIHVuZGVybGluZUhlaWdodCA9IHRoaXMuY29tcHV0ZVVuZGVybGluZUhlaWdodCgpO1xuXG4gICAgdGhpcy5vbkJlZ2luKCk7XG4gICAgXG4gICAgLy9zZXQgdGhlIG9yaWdpbiBhbmQgcGVuIHBvc2l0aW9uXG4gICAgaXRyLmJlZ2luKHgsIHkpO1xuICAgIGZvciAodmFyIGs9MDsgazx3b3Jkd3JhcHBlci5saW5lcy5sZW5ndGg7IGsrKykge1xuICAgICAgICB2YXIgbGluZSA9IHdvcmR3cmFwcGVyLmxpbmVzW2tdO1xuICAgICAgICB1bmRlcmxpbmVTdGFydGVkID0gZmFsc2U7XG5cbiAgICAgICAgdmFyIGxhc3RBZHZhbmNlID0gMDtcblxuICAgICAgICB2YXIgbGluZVggPSBpdHIucGVuLng7XG4gICAgICAgIHZhciBsaW5lWSA9IGl0ci5wZW4ueTtcblxuICAgICAgICB0aGlzLm9uQmVnaW5MaW5lKGspO1xuXG4gICAgICAgIC8vVE9ETzogdXNlIG11bHRpcGxlIE5vZGVzIGluc2lkZSBhIHNpbmdsZSBsaW5lXG4gICAgICAgIC8vYSBub2RlIHdpbGwgaGF2ZSBhdHRyaWJ1dGVzIGxpa2UgZm9udCwgc2l6ZSwgY29sb3IsIFxuICAgICAgICAvL2xldHRlci1zcGFjaW5nLCB1bmRlcmxpbmUsIGV0Yy5cbiAgICAgICAgLy9UaGlzIHdpbGwgYWZmZWN0IHRoZSBsaW5lIGhlaWdodCwgYXMgaXQgd2lsbCBoYXZlIHRvIGJlIHRoZSBtYXggb2YgYWxsIG5vZGVzLlxuXG4gICAgICAgIGZvciAodmFyIGk9bGluZS5zdGFydDsgaTxsaW5lLmVuZDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgY2hyID0gdGV4dC5jaGFyQXQoaSk7XG5cbiAgICAgICAgICAgIC8vU3RlcCB0aGUgaXRlcmF0b3IsIG1vdmluZyBmb3J3YXJkIGJhc2VkIG9uIGtlcm5pbmcgZnJvbSBsYXN0IGNoYXJcbiAgICAgICAgICAgIHZhciBnbHlwaCA9IGl0ci5zdGVwKHRleHQsIGkpO1xuXG4gICAgICAgICAgICBpZiAoIWdseXBoKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAvL3dpdGhpbiBkZXNpcmVkIHJhbmdlXG4gICAgICAgICAgICBpZiAoaSA+PSBzdGFydCAmJiBpIDwgZW5kKSB7XG4gICAgICAgICAgICAgICAgdmFyIHR4ID0gaXRyLnBlbi54O1xuICAgICAgICAgICAgICAgIHZhciB0eSA9IGl0ci5wZW4ueTtcblxuICAgICAgICAgICAgICAgIGlmIChhbGlnblR5cGUgPT09IENFTlRFUl9BTElHTikge1xuICAgICAgICAgICAgICAgICAgICB0eCArPSAobWF4TGluZVdpZHRoLWxpbmUud2lkdGgpLzI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChhbGlnblR5cGUgPT09IFJJR0hUX0FMSUdOKSB7XG4gICAgICAgICAgICAgICAgICAgIHR4ICs9IChtYXhMaW5lV2lkdGgtbGluZS53aWR0aCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCF1bmRlcmxpbmVTdGFydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHVuZGVybGluZVggPSB0eDtcbiAgICAgICAgICAgICAgICAgICAgdW5kZXJsaW5lU3RhcnRYID0gdHg7XG4gICAgICAgICAgICAgICAgICAgIHVuZGVybGluZVkgPSB0eSArIHVuZGVybGluZVBvcztcbiAgICAgICAgICAgICAgICAgICAgdW5kZXJsaW5lV2lkdGggPSAwO1xuICAgICAgICAgICAgICAgICAgICB1bmRlcmxpbmVTdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB1bmRlcmxpbmVXaWR0aCA9IHR4IC0gdW5kZXJsaW5lU3RhcnRYO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyR2x5cGgoaSwgZ2x5cGgsIHNjYWxlLCB0eCwgdHkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL0FkdmFuY2UgdGhlIGl0ZXJhdG9yIHRvIHRoZSBuZXh0IGdseXBoIGluIHRoZSBzdHJpbmdcbiAgICAgICAgICAgIHZhciBuZXdBZHZhbmNlID0gaXRyLmFkdmFuY2UoZ2x5cGgpO1xuXG4gICAgICAgICAgICBpZiAoaSA+PSBzdGFydCAmJiBpIDwgZW5kKVxuICAgICAgICAgICAgICAgIGxhc3RBZHZhbmNlID0gbmV3QWR2YW5jZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMub25FbmRMaW5lKGspO1xuXG4gICAgICAgIGlmICh1bmRlcmxpbmUpIHtcbiAgICAgICAgICAgIHVuZGVybGluZVdpZHRoICs9IGxhc3RBZHZhbmNlO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJVbmRlcmxpbmUodW5kZXJsaW5lWCwgdW5kZXJsaW5lWS11bmRlcmxpbmVIZWlnaHQvMiwgdW5kZXJsaW5lV2lkdGgsIHVuZGVybGluZUhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vU3RlcHMgZG93biBhIGxpbmUuLi5cbiAgICAgICAgaWYgKGsgPCB3b3Jkd3JhcHBlci5saW5lcy5sZW5ndGgtMSkge1xuICAgICAgICAgICAgaXRyLmFkdmFuY2VMaW5lKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvL2ZpbmlzaCB0aGUgaXRlcmF0b3IuLi5cbiAgICBpdHIuZW5kKCk7XG4gICAgdGhpcy5vbkVuZCgpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBUZXh0UmVuZGVyZXI7IiwidmFyIHV0aWwgPSByZXF1aXJlKCdmb250cGF0aC11dGlsJyk7XG5cbnZhciBERUZBVUxUX1RBQl9XSURUSCA9IDQ7XG5cbmZ1bmN0aW9uIEdseXBoSXRlcmF0b3IoZm9udCwgZm9udFNpemUpIHtcbiAgICB0aGlzLl9mb250U2l6ZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9mb250U2NhbGUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fZm9udCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmZvbnRTY2FsZSA9IDEuMDtcbiAgICB0aGlzLmtlcm5pbmcgPSB0cnVlO1xuICAgIHRoaXMubGV0dGVyU3BhY2luZyA9IDA7XG4gICAgdGhpcy5saW5lSGVpZ2h0ID0gdW5kZWZpbmVkO1xuICAgIFxuICAgIHRoaXMuZm9udFNpemUgPSB0eXBlb2YgZm9udFNpemUgPT09ICdudW1iZXInXG4gICAgICAgICAgICA/IGZvbnRTaXplXG4gICAgICAgICAgICA6IChmb250ID8gZm9udC5zaXplIDogdW5kZWZpbmVkKTtcbiAgICB0aGlzLmZvbnQgPSBmb250O1xuXG4gICAgLy9OdW1iZXIgb2Ygc3BhY2VzIGZvciBhIHRhYiBjaGFyYWN0ZXJcbiAgICB0aGlzLnRhYldpZHRoID0gREVGQVVMVF9UQUJfV0lEVEg7XG4gICAgdGhpcy5fdGFiR2x5cGggPSBudWxsO1xuXG4gICAgdGhpcy5vcmlnaW4gPSB7IHg6IDAsIHk6IDAgfTtcbiAgICB0aGlzLnBlbiA9IHsgeDogMCwgeTogMCB9O1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoR2x5cGhJdGVyYXRvci5wcm90b3R5cGUsIFwiZm9udFwiLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZvbnQ7XG4gICAgfSxcblxuICAgIHNldDogZnVuY3Rpb24oZm9udCkge1xuICAgICAgICB0aGlzLl9mb250ID0gZm9udDtcblxuICAgICAgICAvL0RldGVybWluZSB0aGUgbmV3IHNjYWxpbmcgZmFjdG9yLi4uXG4gICAgICAgIGlmIChmb250KSB7XG4gICAgICAgICAgICB0aGlzLmZvbnRTY2FsZSA9IHV0aWwuZ2V0UHhTY2FsZShmb250LCB0aGlzLmZvbnRTaXplKTtcblxuICAgICAgICAgICAgLy9VcGRhdGVzIHRoZSB0YWIgZ2x5cGhcbiAgICAgICAgICAgIHRoaXMudGFiV2lkdGggPSB0aGlzLl90YWJXaWR0aDtcbiAgICAgICAgfVxuICAgIH0sXG59KTtcblxuLy9UaGVyZSBtaWdodCBiZSBhIGJldHRlciB3YXkgb2YgaGFuZGxpbmcgdGFiIHdpZHRoIHVzaW5nIEZyZWVUeXBlID8gXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoR2x5cGhJdGVyYXRvci5wcm90b3R5cGUsIFwidGFiV2lkdGhcIiwge1xuXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RhYldpZHRoO1xuICAgIH0sXG5cbiAgICBzZXQ6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICB0aGlzLl90YWJXaWR0aCA9IHZhbD09PTAgfHwgdmFsID8gdmFsIDogREVGQVVMVF9UQUJfV0lEVEg7XG4gICAgICAgIHRoaXMuX3RhYkdseXBoID0ge307XG5cbiAgICAgICAgdmFyIHNwYWNlR2x5cGggPSB0aGlzLmZvbnQgPyB0aGlzLmZvbnQuZ2x5cGhzW1wiIFwiXSA6IG51bGw7XG4gICAgICAgIGlmIChzcGFjZUdseXBoKSB7XG4gICAgICAgICAgICB0aGlzLl90YWJHbHlwaCA9IHt9O1xuICAgICAgICAgICAgZm9yICh2YXIgayBpbiBzcGFjZUdseXBoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGFiR2x5cGhba10gPSBzcGFjZUdseXBoW2tdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX3RhYkdseXBoLnhvZmYpXG4gICAgICAgICAgICAgICAgdGhpcy5fdGFiR2x5cGgueG9mZiAqPSB0aGlzLl90YWJXaWR0aDtcbiAgICAgICAgfVxuICAgIH0sXG59KTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEdseXBoSXRlcmF0b3IucHJvdG90eXBlLCBcImZvbnRTaXplXCIsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuX2ZvbnRTaXplICE9PSAnbnVtYmVyJylcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZvbnQuYml0bWFwIFxuICAgICAgICAgICAgICAgID8gdGhpcy5mb250LnNpemUgXG4gICAgICAgICAgICAgICAgOiB1dGlsLnBvaW50VG9QaXhlbCh0aGlzLmZvbnQuc2l6ZSlcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZvbnRTaXplO1xuICAgIH0sXG5cbiAgICBzZXQ6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICB0aGlzLl9mb250U2l6ZSA9IHZhbDtcblxuICAgICAgICAvL0lmIHRoZSBmb250IGlzIGFscmVhZHkgc2V0LCBkZXRlcm1pbmUgdGhlIG5ldyBzY2FsaW5nIGZhY3RvclxuICAgICAgICBpZiAodGhpcy5fZm9udCkge1xuICAgICAgICAgICAgdGhpcy5mb250U2NhbGUgPSB1dGlsLmdldFB4U2NhbGUodGhpcy5fZm9udCwgdGhpcy5fZm9udFNpemUpO1xuICAgICAgICB9XG4gICAgfSxcbn0pO1xuXG5HbHlwaEl0ZXJhdG9yLnByb3RvdHlwZS5nZXRLZXJuaW5nID0gZnVuY3Rpb24obGVmdCwgcmlnaHQpIHtcbiAgICB2YXIgZm9udCA9IHRoaXMuZm9udDtcblxuICAgIGlmICghZm9udCB8fCAhZm9udC5rZXJuaW5nKVxuICAgICAgICByZXR1cm4gMDtcblxuICAgIHZhciB0YWJsZSA9IHRoaXMua2VybmluZ1RhYmxlO1xuXG4gICAgZm9yICh2YXIgaT0wOyBpPGZvbnQua2VybmluZy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgayA9IGZvbnQua2VybmluZ1tpXTtcbiAgICAgICAgaWYgKGtbMF0gPT09IGxlZnQgJiYga1sxXSA9PT0gcmlnaHQpIFxuICAgICAgICAgICAgcmV0dXJuIGtbMl07XG4gICAgfVxuICAgIHJldHVybiAwO1xufTtcblxuR2x5cGhJdGVyYXRvci5wcm90b3R5cGUuYmVnaW4gPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgdGhpcy5vcmlnaW4ueCA9IHh8fDA7XG4gICAgdGhpcy5vcmlnaW4ueSA9IHl8fDA7XG5cbiAgICB0aGlzLnBlbi54ID0gdGhpcy5vcmlnaW4ueDtcbiAgICB0aGlzLnBlbi55ID0gdGhpcy5vcmlnaW4ueTtcbn07XG5cbkdseXBoSXRlcmF0b3IucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uKCkge1xuICAgIC8vLi4gbWFpbmx5IGZvciBjb25zaXN0ZW5jeSB3aXRoIGJlZ2luKClcbiAgICAvL01pZ2h0IGJlIHVzZWZ1bCBsYXRlciBvblxufTtcblxuR2x5cGhJdGVyYXRvci5wcm90b3R5cGUuZ2V0TGluZUdhcCA9IGZ1bmN0aW9uKCkge1xuICAgIC8vTGluZSBoZWlnaHQgaGFuZGxpbmcgaXMgYSBtZXNzIGluIGJyb3dzZXJzLlxuICAgIC8vTWF5YmUgdGhlIGJlc3Qgc29sdXRpb24gaXMgdG8gZW5jb3VyYWdlIHVzZXJzIHRvIFxuICAgIC8vc3BlY2lmeSBwaXhlbCBsaW5lIGhlaWdodHMgaWYgdGhleSB3YW50IHRvIG1hdGNoIGJyb3dzZXIgc3RhbmRhcmRzLFxuICAgIC8vb3RoZXJ3aXNlIGl0J3MgdW5yZWFzb25hYmxlIHRvIGV4cGVjdCB0aGUgbGluZSBnYXBzIHRvIGxpbmUgdXAgZXhhY3RseVxuICAgIC8vYWNyb3NzIGFsbCBicm93c2Vycy4gRXhhbXBsZSBvZiB0aGUgZGlzYXN0ZXI6XG4gICAgLy9odHRwOi8vbGlzdHMudzMub3JnL0FyY2hpdmVzL1B1YmxpYy93d3ctc3R5bGUvMjAwOEphbi8wNDEzLmh0bWxcblxuICAgIC8vRm9yIHJlZmVyZW5jZSwgc29tZSBiYXNlbGluZS10by1iYXNlbGluZSBjYWxjdWxhdGlvbnM6XG4gICAgLy9odHRwOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9vdHNwZWMvcmVjb20uaHRtXG4gICAgLy9mcmVldHlwZS5vcmcvZnJlZXR5cGUyL2RvY3MvcmVmZXJlbmNlL2Z0Mi1iYXNlX2ludGVyZmFjZS5odG1sXG4gICAgLy9odHRwOi8vd3d3LmZyZWV0eXBlLm9yZy9mcmVldHlwZTIvZG9jcy9nbHlwaHMvZ2x5cGhzLTMuaHRtbFxuXG4gICAgLy9VbmZvcnR1bmF0ZWx5IG5vbmUgb2YgdGhlc2UgYXJlIHByb2R1Y2luZyBsaW5lLWhlaWdodHMgdGhhdCBhdm9pZCBvdmVybGFwcGluZ1xuICAgIC8vb3IgcmVzZW1ibGUgYnJvd3NlciByZW5kZXJpbmcgaW4gYW55IHdheS4gXG5cbiAgICAvLyBJZiBDU1MgdXNlcyAxZW0gb3IgMSwgdGhlIGJyb3dzZXIgb2Zmc2V0cyB0aGUgbGluZSBieSB0aGUgXG4gICAgLy8gZm9udCdzIHBpeGVsIHNpemUuIElmIGFuIGV4YWN0IHBpeGVsIGxpbmUtaGVpZ2h0IGlzIHNwZWNpZmllZCxcbiAgICAvLyB0aGUgYnJvd3NlciB3aWxsIHVzZSB0aGF0ICsgYSBjb21wdXRlZCBcImxpbmVnYXAuXCIgXG4gICAgLy8gSWYgJ2F1dG8nIGlzIHNwZWNpZmllZCBmb3IgbGluZS1oZWlnaHQsIHRoZSBjYWxjdWxhdGlvbnMgc2VlbVxuICAgIC8vIG11Y2ggbW9yZSBjb21wbGV4IGFuZCBicm93c2VyL3BsYXRmb3JtIGRlcGVuZGVudCAobm90IGluY2x1ZGVkIGhlcmUpLlxuICAgIFxuICAgIHZhciBmb250ID0gdGhpcy5mb250LFxuICAgICAgICBzY2FsZSA9IHRoaXMuZm9udFNjYWxlO1xuICAgIHZhciBnYXAgPSAoZm9udC5oZWlnaHQgLSBmb250LmFzY2VuZGVyICsgTWF0aC5hYnMoZm9udC5kZXNjZW5kZXIpKSAqIHNjYWxlOyAgICBcbiAgICB2YXIgbGluZUhlaWdodCA9IHRoaXMubGluZUhlaWdodDtcbiAgICBcbiAgICBsaW5lSGVpZ2h0ID0gKGxpbmVIZWlnaHQ9PT0wfHxsaW5lSGVpZ2h0KSBcbiAgICAgICAgICAgID8gKGxpbmVIZWlnaHQgKyBnYXApXG4gICAgICAgICAgICA6IHRoaXMuZm9udFNpemU7XG4gICAgcmV0dXJuIGxpbmVIZWlnaHQ7XG59O1xuXG5HbHlwaEl0ZXJhdG9yLnByb3RvdHlwZS50cmFuc2xhdGUgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgdGhpcy5vcmlnaW4ueCArPSB4fHwwO1xuICAgIHRoaXMub3JpZ2luLnkgKz0geXx8MDtcblxuICAgIHRoaXMucGVuLnggKz0geHx8MDtcbiAgICB0aGlzLnBlbi55ICs9IHl8fDA7XG59O1xuXG5HbHlwaEl0ZXJhdG9yLnByb3RvdHlwZS5zdGVwID0gZnVuY3Rpb24odGV4dCwgaW5kZXgpIHtcbiAgICB2YXIgc2NhbGUgPSB0aGlzLmZvbnRTY2FsZSxcbiAgICAgICAgZm9udCA9IHRoaXMuX2ZvbnQ7XG5cbiAgICB2YXIgY2hyID0gdGV4dC5jaGFyQXQoaW5kZXgpOyBcblxuICAgIGlmIChjaHIgPT09ICdcXHQnICYmIHRoaXMuX3RhYkdseXBoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90YWJHbHlwaDtcbiAgICB9XG5cbiAgICAvL1NraXAgbWlzc2luZyBjaGFyYWN0ZXJzLi4uXG4gICAgaWYgKCEoY2hyIGluIGZvbnQuZ2x5cGhzKSlcbiAgICAgICAgcmV0dXJuO1xuICAgIFxuICAgIHZhciBnbHlwaCA9IGZvbnQuZ2x5cGhzW2Nocl07XG5cbiAgICAvL0lmIHdlIGhhdmUgYSBjaGFyIHRvIHRoZSBsZWZ0LCBkZXRlcm1pbmUgaXRzIGtlcm5pbmdcbiAgICBpZiAoaW5kZXggPiAwICYmIHRoaXMua2VybmluZykge1xuICAgICAgICB2YXIga2VybiA9IHRoaXMuZ2V0S2VybmluZyh0ZXh0LmNoYXJBdChpbmRleC0xKSwgY2hyKTtcbiAgICAgICAgdGhpcy5wZW4ueCArPSAoa2VybipzY2FsZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGdseXBoO1xufTtcblxuR2x5cGhJdGVyYXRvci5wcm90b3R5cGUuYWR2YW5jZUxpbmUgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnBlbi55ICs9IHRoaXMuZ2V0TGluZUdhcCgpO1xuICAgIHRoaXMucGVuLnggPSB0aGlzLm9yaWdpbi54O1xufTtcblxuLyoqXG4gKiBDYWxsZWQgYWZ0ZXIgc3RlcC4gXG4gKi9cbkdseXBoSXRlcmF0b3IucHJvdG90eXBlLmFkdmFuY2UgPSBmdW5jdGlvbihnbHlwaCkge1xuICAgIHZhciBhZHZhbmNlID0gKGdseXBoLnhvZmYgKiB0aGlzLmZvbnRTY2FsZSk7XG4gICAgLy8gQWR2YW5jZSB0byBuZXh0IHBlbiBwb3NpdGlvblxuICAgIHRoaXMucGVuLnggKz0gYWR2YW5jZSArIHRoaXMubGV0dGVyU3BhY2luZztcbiAgICByZXR1cm4gYWR2YW5jZTtcbn07XG5cbi8qKlxuICogVGhpcyBpcyBhIHV0aWxpdHkgZnVuY3Rpb24gdGhhdCBwcm92aWRlcyB0aGUgYm91bmRzIG9mIHRoZSBnaXZlblxuICogdGV4dCAoZnJvbSBzdGFydCBhbmQgZW5kIHBvc2l0aW9ucykgYXMgaWYgdGhleSB3ZXJlIGxhaWQgb3V0IGhvcml6b250YWxseSxcbiAqIGxlZnQgdG8gcmlnaHQuXG4gKlxuICogRm9yIGNvbnZlbmllbmNlLCB0aGlzIHdpbGwgbm90IGFsdGVyIHRoZSBjdXJyZW50IHBlbiBhbmQgb3JpZ2luIHBvc2l0aW9ucy5cbiAqIFRoaXMgd2F5IGl0IGNhbiBiZSB1dGlsaXplZCBpbnNpZGUgYSBnbHlwaCBpdGVyYXRpb24gKGkuZS4gZm9yIHJlbmRlcmluZykuXG4gKlxuICogSWYgYGF2YWlsYWJsZVdpZHRoYCBpcyBzcGVjaWZpZWQsIHRoaXMgd2lsbCBicmVhayBiZWZvcmUgcmVhY2hpbmcgdGhlIHNwZWNpZmllZFxuICogcGl4ZWwgd2lkdGgsIHRvIGVuc3VyZSB0aGF0IGFsbCBnbHlwaHMgd2lsbCBmaXQgaW5zaWRlIHRoZSBib3VuZHMuIFxuICpcbiAqIFRoZSByZXR1cm4gb2JqZWN0IGFsc28gaW5jbHVkZXMgYSBgZ2x5cGhzYCBwcm9wZXJ0eSwgd2hpY2ggaXMgdGhlIG51bWJlciBvZiBnbHlwaHNcbiAqIHRoYXQgYXJlIHZpc2libGUgd2l0aGluIHRoZSByZXR1cm5lZCBib3VuZHMuIFxuICpcbiAqIElmIGBvdXRgIGlzIHNwZWNpZmllZCAoYW4gb2JqZWN0IHdpdGggeCwgeSwgd2lkdGgsIGhlaWdodCwgYW5kIGdseXBoIHByb3BlcnRpZXMpLFxuICogaXQgd2lsbCBiZSByZS11c2VkLiBPdGhlcndpc2UgYSBuZXcgb2JqZWN0IGlzIGNyZWF0ZWQuXG4gKiBcbiAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0IHRoZSB0ZXh0IHRvIGNoZWNrXG4gKiBAcGFyYW0ge051bWJlcn0gc3RhcnQgdGhlIHN0YXJ0IHBvc2l0aW9uLCBkZWZhdWx0cyB0byAwXG4gKiBAcGFyYW0ge051bWJlcn0gZW5kIHRoZSBlbmQgcG9zaXRpb24sIGV4Y2x1c2l2ZSwgZGVmYXVsdHMgdG8gdGV4dCBsZW5ndGhcbiAqIEBwYXJhbSB7TnVtYmVyfSBhdmFpbGFibGVXaWR0aCB0aGUgd2lkdGggYmVmb3JlIHN0b3BwaW5nIHRoZSBib3VuZCBjaGVja1xuICogQHBhcmFtIHtPYmplY3R9IG91dCBhbiBvYmplY3QgdG8gcmUtdXNlIGZvciB0aGUgcmV0dXJuIHZhbHVlXG4gKiBAcmV0dXJuIHtPYmplY3R9IHRoZSBib3VuZHMgYW5kIGdseXBoIGNvdW50IHt4LHksd2lkdGgsaGVpZ2h0LGdseXBoc31cbiAqL1xuR2x5cGhJdGVyYXRvci5wcm90b3R5cGUuZ2V0Qm91bmRzID0gZnVuY3Rpb24odGV4dCwgc3RhcnQsIGVuZCwgYXZhaWxhYmxlV2lkdGgsIG91dCkge1xuICAgIGlmICghb3V0KVxuICAgICAgICBvdXQgPSB7IHg6MCwgeTowLCB3aWR0aDogMCwgaGVpZ2h0OiAwLCBnbHlwaHM6IDAgfTtcblxuICAgIHZhciBjaGVja1dpZHRoID0gYXZhaWxhYmxlV2lkdGg9PT0wfHxhdmFpbGFibGVXaWR0aDtcblxuICAgIHN0YXJ0ID0gc3RhcnR8fDA7XG4gICAgZW5kID0gZW5kPT09MHx8ZW5kID8gZW5kIDogdGV4dC5sZW5ndGg7XG5cbiAgICB2YXIgbWF4SGVpZ2h0ID0gMDtcblxuICAgIG91dC54ID0gMDtcbiAgICBvdXQueSA9IDA7XG4gICAgb3V0LmdseXBocyA9IDA7XG5cbiAgICB2YXIgb2xkUGVuWCA9IHRoaXMucGVuLngsXG4gICAgICAgIG9sZFBlblkgPSB0aGlzLnBlbi55LFxuICAgICAgICBvbGRPcmlnaW5YID0gdGhpcy5vcmlnaW4ueCxcbiAgICAgICAgb2xkT3JpZ2luWSA9IHRoaXMub3JpZ2luLnk7XG5cblxuICAgIHZhciBmb250ID0gdGhpcy5mb250O1xuICAgIHRoaXMuYmVnaW4oKTtcbiAgICBmb3IgKHZhciBpPXN0YXJ0OyBpPGVuZDsgaSsrKSB7XG4gICAgICAgIHZhciBjaHIgPSB0ZXh0LmNoYXJBdChpKTtcblxuICAgICAgICAvL3N0ZXAgdGhlIGl0ZXJhdG9yXG4gICAgICAgIHZhciBnbHlwaCA9IHRoaXMuc3RlcCh0ZXh0LCBpKTtcblxuICAgICAgICAvL2lmIHRoZSBnbHlwaCBpcyB2YWxpZCwgd2UgY2FuIGFkdmFuY2UgcGFzdCBpdCBhbmQgY2FsY3VsYXRlIG5ldyBoZWlnaHRcbiAgICAgICAgaWYgKGdseXBoKSB7XG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gKGdseXBoLmhlaWdodCkqdGhpcy5mb250U2NhbGU7XG5cbiAgICAgICAgICAgIG91dC55ID0gTWF0aC5tYXgob3V0LnksIHRoaXMuZm9udFNjYWxlKihnbHlwaC5oZWlnaHQtZ2x5cGguaGJ5KSk7XG5cbiAgICAgICAgICAgIG1heEhlaWdodCA9IE1hdGgubWF4KG1heEhlaWdodCwgaGVpZ2h0KTtcbiAgICAgICAgICAgIHZhciBsYXN0QWR2YW5jZSA9IHRoaXMuYWR2YW5jZShnbHlwaCk7XG5cbiAgICAgICAgICAgIC8vaWYgd2UncmUgcGFzdCB0aGUgYXZhaWxhYmxlIHdpZHRoXG4gICAgICAgICAgICB2YXIgbmV3V2lkdGggPSB0aGlzLnBlbi54IC0gdGhpcy5vcmlnaW4ueDtcbiAgICAgICAgICAgIGlmIChjaGVja1dpZHRoICYmIChuZXdXaWR0aCAtIGF2YWlsYWJsZVdpZHRoID4gMC4wMDEpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wZW4ueCAtPSBsYXN0QWR2YW5jZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb3V0LmdseXBocysrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRoaXMuZW5kKCk7XG5cbiAgICBvdXQud2lkdGggPSB0aGlzLnBlbi54IC0gdGhpcy5vcmlnaW4ueDtcbiAgICBvdXQuaGVpZ2h0ID0gbWF4SGVpZ2h0O1xuXG4gICAgdGhpcy5wZW4ueCA9IG9sZFBlblg7XG4gICAgdGhpcy5wZW4ueSA9IG9sZFBlblk7XG4gICAgdGhpcy5vcmlnaW4ueCA9IG9sZE9yaWdpblg7XG4gICAgdGhpcy5vcmlnaW4ueSA9IG9sZE9yaWdpblk7XG5cbiAgICByZXR1cm4gb3V0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBHbHlwaEl0ZXJhdG9yOyIsIi8vIG1vZHVsZS5leHBvcnRzLnBvaW50c1RvUGl4ZWxzID0gZnVuY3Rpb24ocG9pbnRTaXplLCByZXNvbHV0aW9uKSB7XG4vLyBcdHJlc29sdXRpb24gPSB0eXBlb2YgcmVzb2x1dGlvbiA9PT0gXCJudW1iZXJcIiA/IHJlc29sdXRpb24gOiA3Mjtcbi8vIFx0cmV0dXJuIHBvaW50U2l6ZSAqIHJlc29sdXRpb24gLyA3Mjtcbi8vIH07XG5cbi8vIG1vZHVsZS5leHBvcnRzLmNvb3JkVG9QaXhlbCA9IGZ1bmN0aW9uKGNvb3JkLCBwaXhlbFNpemUsIGVtU2l6ZSkge1xuLy8gXHRlbVNpemUgPSB0eXBlb2YgZW1TaXplID09PSBcIm51bWJlclwiID8gZW1TaXplIDogMjA0ODtcbi8vIFx0cmV0dXJuIGNvb3JkICogcGl4ZWxTaXplIC8gZW1TaXplO1xuLy8gfTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIHB0IHNpemUgdG8gcHggc2l6ZSwgbmFtZWx5IHVzZWZ1bCBmb3IgbWF0Y2hpbmdcbiAqIHNpemUgd2l0aCBDU1Mgc3R5bGVzLiBJZiBubyBEUEkgaXMgc3BlY2lmaWVkLCA5NiBpcyBhc3N1bWVkXG4gKiAoYXMgaXQgbGVhZHMgdG8gY29ycmVjdCByZW5kZXJpbmcgaW4gYWxsIGJyb3dzZXJzKS5cbiAqIFxuICogQHBhcmFtICB7TnVtYmVyfSBmb250U2l6ZSB0aGUgZGVzaXJlZCBmb250IHNpemUgaW4gcG9pbnRzXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGRwaSAgICAgIHRoZSBleHBlY3RlZCBEUEksIGdlbmVyYWxseSA5NiBmb3IgYnJvd3NlcnNcbiAqIEByZXR1cm4ge051bWJlcn0gICAgICAgICAgdGhlIHJvdW5kZWQgcGl4ZWwgZm9udCBzaXplXG4gKi9cbm1vZHVsZS5leHBvcnRzLnBvaW50VG9QaXhlbCA9IGZ1bmN0aW9uKGZvbnRTaXplLCBkcGkpIHtcbiAgICBkcGkgPSBkcGl8fGRwaT09PTAgPyBkcGkgOiA5NjtcbiAgICBmb250U2l6ZSA9IGZvbnRTaXplICogZHBpIC8gNzI7XG4gICAgcmV0dXJuIE1hdGgucm91bmQoZm9udFNpemUpO1xufTtcblxuLyoqXG4gKiBGb3IgdGhlIGdpdmVuIGZvbnQgYW5kIChwaXhlbCkgZm9udCBzaXplLCB0aGlzIG1ldGhvZCByZXR1cm5zIHRoZVxuICogc2NhbGUgdGhhdCB3aWxsIG5lZWQgdG8gYmUgYXBwbGllZCB0byBFTSB1bml0cyAoaS5lLiBmb250IHBhdGhzKSBcbiAqIHRvIGhhdmUgdGhlIGZvbnQgcmVuZGVyIGF0IHRoZSBleHBlY3RlZCBzaXplIChpLmUuIHRvIG1hdGNoIHRoZSBicm93c2VyKS5cbiAqXG4gKiBJZiBubyBmb250IHNpemUgaXMgc3BlY2lmaWVkLCB3ZSB3aWxsIHVzZSB0aGUgZGVmYXVsdCBmb250IHNpemUgKHdoaWNoIGlzIGluIHBvaW50cylcbiAqIGFuZCBjb252ZXJ0IGl0IHRvIHBpeGVscy4gXG4gKiBcbiAqIEBwYXJhbSAge0ZvbnR9IGZvbnQgICAgIGEgZm9udCBvYmplY3QgZnJvbSB0aGUgZm9udHBhdGggdG9vbFxuICogQHBhcmFtICB7TnVtYmVyfSBmb250U2l6ZSB0aGUgZGVzaXJlZCBmb250IHNpemUsIGRlZmF1bHRzIHRvIHRoZSBmb250J3MgZGVmYXVsdCBzaXplXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IHJldHVybnMgdGhlIHNjYWxlIGZvciB0aGlzIGZvbnQgc2l6ZSAgICAgICAgIFxuICovXG5tb2R1bGUuZXhwb3J0cy5nZXRQeFNjYWxlID0gZnVuY3Rpb24oZm9udCwgZm9udFNpemUpIHtcbiAgICBpZiAoZm9udC5iaXRtYXApXG4gICAgICAgIHJldHVybiAxLjA7XG5cbiAgICAvL0lmIG5vIGZvbnRTaXplIGlzIHNwZWNpZmllZCwgaXQgd2lsbCBqdXN0IGZhbGwgYmFjayB0byB1c2luZyB0aGUgZm9udCdzIG93biBzaXplIHdpdGggOTYgRFBJLlxuICAgIGZvbnRTaXplID0gdHlwZW9mIGZvbnRTaXplID09PSBcIm51bWJlclwiID8gZm9udFNpemUgOiB0aGlzLnBvaW50VG9QaXhlbChmb250LnNpemUpO1xuXG4gICAgLy9UYWtlcyBpbiBhIGZvbnQgc2l6ZSBpbiBQSVhFTFMgYW5kIGdpdmVzIHVzIHRoZSBleHBlY3RlZCBzY2FsaW5nIGZhY3RvclxuICAgIHZhciBzeiA9IGZvbnQudW5pdHNfcGVyX0VNLzY0O1xuICAgIHN6ID0gKHN6L2ZvbnQuc2l6ZSAqIGZvbnRTaXplKTtcblxuICAgIHJldHVybiAoKGZvbnQucmVzb2x1dGlvbiAqIDEvNzIgKiBzeikgLyBmb250LnVuaXRzX3Blcl9FTSk7XG59O1xuXG4vKipcbiAqIEZvciB0aGUgZ2l2ZW4gZm9udCBhbmQgKHBvaW50KSBmb250IHNpemUsIHRoaXMgbWV0aG9kIHJldHVybnMgdGhlXG4gKiBzY2FsZSB0aGF0IHdpbGwgbmVlZCB0byBiZSBhcHBsaWVkIHRvIEVNIHVuaXRzIChpLmUuIGZvbnQgcGF0aHMpIFxuICogdG8gaGF2ZSB0aGUgZm9udCByZW5kZXIgYXQgdGhlIGV4cGVjdGVkIHNpemUgKGkuZS4gdG8gbWF0Y2ggdGhlIGJyb3dzZXIpLlxuICogXG4gKiBJZiBubyBmb250IHNpemUgaXMgc3BlY2lmaWVkLCB3ZSB3aWxsIHVzZSB0aGUgZGVmYXVsdCBmb250IHNpemUuXG4gKiBcbiAqIEBwYXJhbSAge0ZvbnR9IGZvbnQgICAgICAgYSBmb250IG9iamVjdCBmcm9tIHRoZSBmb250cGF0aCB0b29sXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGZvbnRTaXplIHRoZSBkZXNpcmVkIGZvbnQgc2l6ZSwgZGVmYXVsdHMgdG8gdGhlIGZvbnQncyBkZWZhdWx0IHNpemVcbiAqIEByZXR1cm4ge051bWJlcn0gICAgICAgICAgdGhlIHNjYWxlIGZvciB0aGlzIGZvbnQgc2l6ZVxuICovXG5tb2R1bGUuZXhwb3J0cy5nZXRQdFNjYWxlID0gZnVuY3Rpb24oZm9udCwgZm9udFNpemUpIHtcbiAgICBmb250U2l6ZSA9IHR5cGVvZiBmb250U2l6ZSA9PT0gXCJudW1iZXJcIiA/IGZvbnRTaXplIDogZm9udC5zaXplO1xuICAgIGZvbnRTaXplID0gdGhpcy5wb2ludFRvUGl4ZWwoZm9udFNpemUpO1xuICAgIHJldHVybiB0aGlzLmdldFB4U2NhbGUoZm9udCwgZm9udFNpemUpO1xufTtcbiIsInZhciB0bXBCb3VuZHMgPSB7IHg6IDAsIHk6IDAsIHdpZHRoOiAwLCBoZWlnaHQ6IDAsIGdseXBoczogMCB9O1xuXG5mdW5jdGlvbiBpc1doaXRlc3BhY2UoY2hyKSB7XG5cdHJldHVybiBjaHI9PT0nICdcblx0XHR8fCBjaHI9PT0nXFxuJ1xuXHRcdHx8IGNocj09PSdcXHInXG5cdFx0fHwgY2hyPT09J1xcdCc7XG59XG5cbmZ1bmN0aW9uIGlkeE9mKHRleHQsIGNociwgc3RhcnQsIGVuZCkge1xuXHR2YXIgaWR4ID0gdGV4dC5pbmRleE9mKGNociwgc3RhcnQpO1xuXHRpZiAoaWR4ID09PSAtMSB8fCBpZHggPiBlbmQpXG5cdFx0cmV0dXJuIGVuZDtcblx0cmV0dXJuIGlkeDtcbn1cblxuZnVuY3Rpb24gV29yZFdyYXAodGV4dCkge1xuXHQvKipcblx0ICogVGhlIHRleHQgYmVpbmcgb3BlcmF0ZWQgb24uXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0XG5cdCAqL1xuXHR0aGlzLnRleHQgPSB0ZXh0fHxcIlwiO1xuXG5cdC8qKlxuXHQgKiBBbiBhcnJheSBvZiBsaW5lcyByZXByZXNlbnRpbmcgdGhlIHN0YXRlIG9mIHRoaXMgd29yZCB3cmFwcGVyLlxuXHQgKiBAcGFyYW0ge0FycmF5fSBsaW5lc1xuXHQgKi9cblx0dGhpcy5saW5lcyA9IFtdO1xuXG5cdC8qKiBcblx0ICogVGhlIG5ld2xpbmUgY2hhcmFjdGVyIHRvIGJyZWFrIG9uLCBkZWZhdWx0ICdcXG4nXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBuZXdsaW5lXG5cdCAqL1xuXHR0aGlzLm5ld2xpbmUgPSAnXFxuJztcblxuXHQvKipcblx0ICogV2hldGhlciB0byBjbGlwIG5vbi1icmVha2luZyB0ZXh0IChub3dyYXAgYW5kIHByZSlcblx0ICogaWYgdGhlIHdyYXBXaWR0aCBpcyB0b28gc21hbGwuIFxuXHQgKiAgXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gY2xpcFxuXHQgKi9cblx0dGhpcy5jbGlwID0gZmFsc2U7XG5cblx0LyoqXG5cdCAqIFRoZSBtb2RlIGZvciB3b3Jkd3JhcHBpbmc6ICdwcmUnLCAnbm9ybWFsJywgb3IgJ25vd3JhcCcuXG5cdCAqXG5cdCAqIFlvdSBjYW4gYWxzbyB1c2UgdGhlIGBQUkVgLCBgTk9STUFMYCwgYW5kIGBOT1dSQVBgIGNvbnN0YW50c1xuXHQgKiBpbiBgV29yZFdyYXAuTW9kZWAuXG5cdCAqIFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gbW9kZVxuXHQgKi9cblx0dGhpcy5tb2RlID0gV29yZFdyYXAuTW9kZS5OT1JNQUw7XG59XG5cbldvcmRXcmFwLk1vZGUgPSB7XG5cdFBSRTogJ3ByZScsICAgICAgIC8vd2hpdGVzcGFjZSBpc24ndCBjb2xsYXBzZWRcblx0Tk9STUFMOiAnbm9ybWFsJywgLy93aGl0ZXNwYWNlIGlzIGNvbGxhcHNlZFxuXHROT1dSQVA6ICdub3dyYXAnICAvL29ubHkgYnJlYWsgb24gJ1xcbidcbn07XG5cbi8qKlxuICogQ2xlYXJzIGFueSBtdWx0aS1saW5lIGxheW91dCBieSBwbGFjaW5nIGFsbCB0aGUgdGV4dCBpbiBhIHNpbmdsZSBMaW5lIG9iamVjdC5cbiAqIFxuICogQHBhcmFtIHtHbHlwaEl0ZXJhdG9yfSBpdGVyYXRvciB0aGUgaXRlcmF0b3IgdG8gdXNlIFxuICogQG1ldGhvZCAgY2xlYXJMYXlvdXRcbiAqL1xuV29yZFdyYXAucHJvdG90eXBlLmNsZWFyTGF5b3V0ID0gZnVuY3Rpb24oaXRlcmF0b3IpIHtcblx0dGhpcy5saW5lcy5sZW5ndGggPSAwO1xuXHRcblx0aWYgKHRoaXMudGV4dC5sZW5ndGggPiAwKSB7XG5cdFx0aXRlcmF0b3IuZ2V0Qm91bmRzKHRoaXMudGV4dCwgMCwgdGhpcy50ZXh0Lmxlbmd0aCwgdW5kZWZpbmVkLCB0bXBCb3VuZHMpO1xuXHRcdFxuXHRcdHZhciBsaW5lID0gbmV3IFdvcmRXcmFwLkxpbmUoMCwgdGhpcy50ZXh0Lmxlbmd0aCwgdG1wQm91bmRzLndpZHRoKTtcblx0XHR0aGlzLmxpbmVzLnB1c2gobGluZSk7XG5cdH1cbn07XG5cbi8qKlxuICogUmVzZXRzIHRoZSB3b3JkIHdyYXBwZXIgYnkgZW1wdHlpbmcgYWxsIGN1cnJlbnQgbGluZXMuXG4gKiBAbWV0aG9kICBlbXB0eVxuICovXG5Xb3JkV3JhcC5wcm90b3R5cGUuZW1wdHkgPSBmdW5jdGlvbigpIHtcblx0dGhpcy5saW5lcy5sZW5ndGggPSAwO1xufTtcblxuLyoqXG4gKiBXb3JkLXdyYXBzIHRoZSBnaXZlbiB0ZXh0IGludG8gbXVsdGlwbGUgbGluZXMuXG4gKiBAcGFyYW0gIHtbdHlwZV19IGl0ZXJhdG9yIFtkZXNjcmlwdGlvbl1cbiAqIEBwYXJhbSAge1t0eXBlXX0gd2lkdGggICAgW2Rlc2NyaXB0aW9uXVxuICogQHBhcmFtICB7W3R5cGVdfSBzdGFydCAgICBbZGVzY3JpcHRpb25dXG4gKiBAcGFyYW0gIHtbdHlwZV19IGVuZCAgICAgIFtkZXNjcmlwdGlvbl1cbiAqIEByZXR1cm4ge1t0eXBlXX0gICAgICAgICAgW2Rlc2NyaXB0aW9uXVxuICovXG5Xb3JkV3JhcC5wcm90b3R5cGUubGF5b3V0ID0gZnVuY3Rpb24oaXRlcmF0b3IsIHdyYXBXaWR0aCwgc3RhcnQsIGVuZCkge1xuXHR2YXIgdGV4dCA9IHRoaXMudGV4dDtcblxuXHR2YXIgbGluZXMgPSB0aGlzLmxpbmVzO1xuXG5cdHN0YXJ0ID0gTWF0aC5tYXgoMCwgc3RhcnR8fDApO1xuXHRlbmQgPSAoZW5kPT09MHx8ZW5kKSA/IGVuZCA6IHRleHQubGVuZ3RoO1xuXG5cdGl0ZXJhdG9yLmJlZ2luKCk7XG5cblx0Ly9kZWZhdWx0IHdyYXAgd2lkdGguLi5cblx0d3JhcFdpZHRoID0gKHdyYXBXaWR0aD09PTAgfHwgd3JhcFdpZHRoKSA/IHdyYXBXaWR0aCA6IE51bWJlci5NQVhfVkFMVUU7XG5cblx0Ly88cHJlPiBtb2RlIGp1c3QgdXNlcyBhIHNpbXBsZSBhbGdvcml0aG0uLi5cblx0aWYgKHRoaXMubW9kZSA9PT0gV29yZFdyYXAuTW9kZS5QUkUpIHtcblx0XHR2YXIgbGluZVN0YXJ0ID0gc3RhcnQ7XG5cdFx0Zm9yICh2YXIgaT1zdGFydDsgaTxlbmQ7IGkrKykge1xuXHRcdFx0dmFyIGNociA9IHRleHQuY2hhckF0KGkpO1xuXG5cdFx0XHQvL0lmIHdlJ3ZlIHJlYWNoZWQgYSBuZXdsaW5lLCB0aGVuIHN0ZXAgZG93biBhIGxpbmVcblx0XHRcdC8vT3IgaWYgd2UndmUgcmVhY2hlZCB0aGUgRU9GXG5cdFx0XHRpZiAoIGNociA9PT0gdGhpcy5uZXdsaW5lIHx8IGk9PT1lbmQtMSkge1xuXHRcdFx0XHR2YXIgYXZhaWxhYmxlV2lkdGggPSB0aGlzLmNsaXAgPyB3cmFwV2lkdGggOiB1bmRlZmluZWQ7XG5cdFx0XHRcdGl0ZXJhdG9yLmdldEJvdW5kcyh0ZXh0LCBsaW5lU3RhcnQsIGkrMSwgYXZhaWxhYmxlV2lkdGgsIHRtcEJvdW5kcyk7XG5cdFx0XHRcdGxpbmVzLnB1c2goIG5ldyBXb3JkV3JhcC5MaW5lKGxpbmVTdGFydCwgbGluZVN0YXJ0K3RtcEJvdW5kcy5nbHlwaHMsIHRtcEJvdW5kcy53aWR0aCkgKTtcblx0XHRcdFx0bGluZVN0YXJ0ID0gaSsxO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBcblx0Ly8nbm9ybWFsJyBtb2RlIHVzZXMgTGliR0RYJ3Mgd29yZCB3cmFwcGluZyBhbGdvcml0aG06XG5cdC8vaHR0cHM6Ly9naXRodWIuY29tL2xpYmdkeC9saWJnZHgvYmxvYi9tYXN0ZXIvZ2R4L3NyYy9jb20vYmFkbG9naWMvZ2R4L2dyYXBoaWNzL2cyZC9CaXRtYXBGb250Q2FjaGUuamF2YVxuXHRlbHNlIHtcblx0XHQvL2lmICdub3dyYXAnIGlzIHNwZWNpZmllZCwgd2Ugb25seSB3cmFwIG9uIG5ld2xpbmUgY2hhcnNcblx0XHRcblx0XHR2YXIgdGVzdFdpZHRoID0gd3JhcFdpZHRoO1xuXHRcdGlmICh0aGlzLm1vZGUgPT09IFdvcmRXcmFwLk1vZGUuTk9XUkFQKSB7XG5cdFx0XHR0ZXN0V2lkdGggPSBOdW1iZXIuTUFYX1ZBTFVFO1xuXHRcdH1cblxuXHRcdHdoaWxlIChzdGFydCA8IGVuZCkge1xuXHRcdFx0Ly9nZXQgbmV4dCBuZXdsaW5lIHBvc2l0aW9uXG5cdFx0XHR2YXIgbmV3TGluZSA9IGlkeE9mKHRleHQsIHRoaXMubmV3bGluZSwgc3RhcnQsIGVuZCk7XG5cblx0XHRcdC8vZWF0IHdoaXRlc3BhY2UgYXQgc3RhcnQgb2YgbGluZVxuXHRcdFx0d2hpbGUgKHN0YXJ0IDwgbmV3TGluZSkge1xuXHRcdFx0XHRpZiAoIWlzV2hpdGVzcGFjZSggdGV4dC5jaGFyQXQoc3RhcnQpICkpXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdHN0YXJ0Kys7XG5cdFx0XHR9XG5cblx0XHRcdC8vZGV0ZXJtaW5lIHZpc2libGUgIyBvZiBnbHlwaHMgZm9yIHRoZSBhdmFpbGFibGUgd2lkdGhcblx0XHRcdGl0ZXJhdG9yLmdldEJvdW5kcyh0ZXh0LCBzdGFydCwgbmV3TGluZSwgdGVzdFdpZHRoLCB0bXBCb3VuZHMpXG5cblx0XHRcdHZhciBsaW5lRW5kID0gc3RhcnQgKyB0bXBCb3VuZHMuZ2x5cGhzO1xuXHRcdFx0dmFyIG5leHRTdGFydCA9IGxpbmVFbmQgKyB0aGlzLm5ld2xpbmUubGVuZ3RoO1xuXG5cdFx0XHQvL2lmIHdlIGhhZCB0byBjdXQgdGhlIGxpbmUgYmVmb3JlIHRoZSBuZXh0IG5ld2xpbmUuLi5cblx0XHRcdGlmIChsaW5lRW5kIDwgbmV3TGluZSkge1xuXHRcdFx0XHQvL2ZpbmQgY2hhciB0byBicmVhayBvblxuXHRcdFx0XHR3aGlsZSAobGluZUVuZCA+IHN0YXJ0KSB7XG5cdFx0XHRcdFx0aWYgKGlzV2hpdGVzcGFjZSh0ZXh0LmNoYXJBdChsaW5lRW5kKSkpXG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRsaW5lRW5kLS07XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGxpbmVFbmQgPT09IHN0YXJ0KSB7XG5cdFx0XHRcdFx0aWYgKG5leHRTdGFydCA+IHN0YXJ0ICsgdGhpcy5uZXdsaW5lLmxlbmd0aCkgbmV4dFN0YXJ0LS07XG5cdFx0XHRcdFx0bGluZUVuZCA9IG5leHRTdGFydDsgLy8gSWYgbm8gY2hhcmFjdGVycyB0byBicmVhaywgc2hvdyBhbGwuXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bmV4dFN0YXJ0ID0gbGluZUVuZDtcblx0XHRcdFx0XHQvL2VhdCB3aGl0ZXNwYWNlIGF0IGVuZCBvZiBsaW5lXG5cdFx0XHRcdFx0d2hpbGUgKGxpbmVFbmQgPiBzdGFydCkge1xuXHRcdFx0XHRcdFx0aWYgKCFpc1doaXRlc3BhY2UodGV4dC5jaGFyQXQobGluZUVuZCAtIHRoaXMubmV3bGluZS5sZW5ndGgpKSlcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRsaW5lRW5kLS07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmIChsaW5lRW5kID4gc3RhcnQpIHtcblx0XHRcdFx0Ly90byBjbGlwLCB1c2UgdGhlIG9yaWdpbmFsIHdyYXAgd2lkdGggKHVuYWx0ZXJlZCBieSBtb2RlKVxuXHRcdFx0XHR2YXIgYXZhaWxhYmxlV2lkdGggPSB0aGlzLmNsaXAgPyB3cmFwV2lkdGggOiB1bmRlZmluZWQ7XG5cdFx0XHRcdGl0ZXJhdG9yLmdldEJvdW5kcyh0ZXh0LCBzdGFydCwgbGluZUVuZCwgYXZhaWxhYmxlV2lkdGgsIHRtcEJvdW5kcyk7XG5cdFx0XHRcdHZhciBsaW5lV2lkdGggPSB0bXBCb3VuZHMud2lkdGg7XG5cblx0XHRcdFx0dmFyIHJMaW5lRW5kID0gdGhpcy5jbGlwID8gc3RhcnQrdG1wQm91bmRzLmdseXBocyA6IGxpbmVFbmQ7XG5cdFx0XHRcdGxpbmVzLnB1c2goIG5ldyBXb3JkV3JhcC5MaW5lKHN0YXJ0LCByTGluZUVuZCwgbGluZVdpZHRoKSApO1xuXHRcdFx0fVxuXHRcdFx0c3RhcnQgPSBuZXh0U3RhcnQ7XG5cblx0XHR9XG5cdH1cblxuXHRpdGVyYXRvci5lbmQoKTtcbn07XG5cbi8qKlxuICogQSBjb252ZW5pZW5jZSBtZXRob2QgdG8gcmV0dXJuIHRoZSBtYXhpbXVtIHdpZHRoIG9mIGFsbCBjdXJyZW50IGxpbmVzLlxuICogVGhpcyBpcyB1c2VmdWwgZm9yIGFsaWduaW5nIGJsb2NrcyBvZiB0ZXh0LlxuICpcbiAqIEBtZXRob2QgIGdldE1heExpbmVXaWR0aFxuICogQHJldHVybiB7TnVtYmVyfSB0aGUgbWF4aW11bSB3aWR0aCBvZiBhbGwgbGluZXNcbiAqL1xuV29yZFdyYXAucHJvdG90eXBlLmdldE1heExpbmVXaWR0aCA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgbWF4V2lkdGggPSAwO1xuXHRmb3IgKHZhciBpPTA7IGk8dGhpcy5saW5lcy5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBsaW5lID0gdGhpcy5saW5lc1tpXTtcblx0XHRtYXhXaWR0aCA9IE1hdGgubWF4KGxpbmUud2lkdGgsIG1heFdpZHRoKTtcblx0fVxuXHRyZXR1cm4gbWF4V2lkdGg7XG59O1xuXG4vKipcbiAqIFRoZSBMaW5lIG9iamVjdCBob2xkcyB0aGUgc3RhcnQgYW5kIGVuZCBpbmRpY2VzIGludG8gdGhlIHN0cmluZyxcbiAqIGFuZCB0aGUgd2lkdGggYXMgY29tcHV0ZWQgYnkgR2x5cGhJdGVyYXRvci5cbiAqIFxuICogQGNsYXNzICBXb3JkV3JhcC5MaW5lXG4gKiBAcGFyYW0ge051bWJlcn0gc3RhcnQgdGhlIHN0YXJ0IGluZGV4LCBpbmNsdXNpdmVcbiAqIEBwYXJhbSB7TnVtYmVyfSBlbmQgICB0aGUgZW5kIGluZGV4LCBleGNsdXNpdmVcbiAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCB0aGUgY29tcHV0ZWQgd2lkdGggb2YgdGhpcyBsaW5lXG4gKi9cbldvcmRXcmFwLkxpbmUgPSBmdW5jdGlvbihzdGFydCwgZW5kLCB3aWR0aCkge1xuXHR0aGlzLnN0YXJ0ID0gc3RhcnQ7XG5cdHRoaXMuZW5kID0gZW5kO1xuXHR0aGlzLndpZHRoID0gd2lkdGg7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdvcmRXcmFwOyIsInZhciBjcmVhdGVWQU8gPSByZXF1aXJlKCdnbC1hbGlhc2VkLXZhbycpIC8vVE9ETzogaW1wcm92ZSB0aGlzIHdpdGggZ2wtdmFvXG52YXIgY3JlYXRlQnVmZmVyID0gcmVxdWlyZSgnZ2wtYnVmZmVyJylcblxubW9kdWxlLmV4cG9ydHMuZmxvYXRzUGVyVmVydGV4ID0gNVxuXG5mdW5jdGlvbiBjcmVhdGVJbmRpY2VzKGNhcGFjaXR5KSB7XG4gICAgdmFyIG51bUluZGljZXMgPSBjYXBhY2l0eSAqIDZcbiAgICB2YXIgaW5kaWNlcyA9IG5ldyBVaW50MTZBcnJheShudW1JbmRpY2VzKVxuXG4gICAgZm9yICh2YXIgaSA9IDAsIGogPSAwOyBpIDwgbnVtSW5kaWNlczsgaSArPSA2LCBqICs9IDQpIHtcbiAgICAgICAgaW5kaWNlc1tpICsgMF0gPSBqICsgMFxuICAgICAgICBpbmRpY2VzW2kgKyAxXSA9IGogKyAxXG4gICAgICAgIGluZGljZXNbaSArIDJdID0gaiArIDJcbiAgICAgICAgaW5kaWNlc1tpICsgM10gPSBqICsgMFxuICAgICAgICBpbmRpY2VzW2kgKyA0XSA9IGogKyAyXG4gICAgICAgIGluZGljZXNbaSArIDVdID0gaiArIDNcbiAgICB9XG4gICAgcmV0dXJuIGluZGljZXNcbn1cblxubW9kdWxlLmV4cG9ydHMubWl4aW5zID0ge1xuXG4gICAgY3JlYXRlOiBmdW5jdGlvbiBjcmVhdGUob3B0KSB7XG4gICAgICAgIG9wdCA9IG9wdHx8e31cbiAgICAgICAgdGhpcy5jbGVhcigpXG5cbiAgICAgICAgLy9kaXNwb3NlIGJlZm9yZSBidWlsZGluZy4uLlxuICAgICAgICBpZiAodGhpcy52YW8pXG4gICAgICAgICAgICB0aGlzLmRpc3Bvc2UoKVxuXG4gICAgICAgIHZhciBjYXBhY2l0eSA9IHR5cGVvZiBvcHQuY2FwYWNpdHkgPT09ICdudW1iZXInID8gb3B0LmNhcGFjaXR5IDogMTAwXG5cbiAgICAgICAgLy8gNjU1MzUgaXMgbWF4IGluZGV4LCBzbyA2NTUzNSAvIDYgPSAxMDkyMi5cbiAgICAgICAgaWYgKGNhcGFjaXR5ID4gMTA5MjIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBoYXZlIG1vcmUgdGhhbiAxMDkyMiBxdWFkcyBwZXIgYmF0Y2g6IFwiICsgY2FwYWNpdHkpXG5cbiAgICAgICAgdGhpcy5fY2FwYWNpdHkgPSBjYXBhY2l0eVxuXG4gICAgICAgIC8vdGhlIHRvdGFsIG51bWJlciBvZiBmbG9hdHMgaW4gb3VyIGJhdGNoXG4gICAgICAgIHZhciBudW1WZXJ0cyA9IGNhcGFjaXR5ICogNCAqIG1vZHVsZS5leHBvcnRzLmZsb2F0c1BlclZlcnRleFxuXG4gICAgICAgIHRoaXMudmVydGljZXMgPSBuZXcgRmxvYXQzMkFycmF5KG51bVZlcnRzKVxuICAgICAgICB0aGlzLmluZGljZXMgPSBjcmVhdGVJbmRpY2VzKGNhcGFjaXR5KVxuXG4gICAgICAgIHZhciBnbCA9IHRoaXMuZ2xcbiAgICAgICAgdmFyIHVzYWdlID0gb3B0LmR5bmFtaWMgPyBnbC5EWU5BTUlDX0RSQVcgOiBnbC5TVEFUSUNfRFJBV1xuICAgICAgICB0aGlzLnZlcnRleEJ1ZmZlciA9IGNyZWF0ZUJ1ZmZlcihnbCwgdGhpcy52ZXJ0aWNlcywgZ2wuQVJSQVlfQlVGRkVSLCB1c2FnZSlcbiAgICAgICAgdGhpcy5pbmRleEJ1ZmZlciA9IGNyZWF0ZUJ1ZmZlcihnbCwgdGhpcy5pbmRpY2VzLCBnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgZ2wuU1RBVElDX0RSQVcpXG5cbiAgICAgICAgdmFyIHN0cmlkZSA9IDUgKiA0XG4gICAgICAgIHRoaXMudmFvID0gY3JlYXRlVkFPKGdsLCBbeyAvL3Bvc2l0aW9uIFhZXG4gICAgICAgICAgICBuYW1lOiAncG9zaXRpb24nLFxuICAgICAgICAgICAgYnVmZmVyOiB0aGlzLnZlcnRleEJ1ZmZlcixcbiAgICAgICAgICAgIHNpemU6IDIsXG4gICAgICAgICAgICBzdHJpZGU6IHN0cmlkZVxuICAgICAgICB9LCB7IC8vdGV4Y29vcmQgVVZcbiAgICAgICAgICAgIG5hbWU6ICd0ZXhjb29yZDAnLFxuICAgICAgICAgICAgYnVmZmVyOiB0aGlzLnZlcnRleEJ1ZmZlcixcbiAgICAgICAgICAgIHNpemU6IDIsXG4gICAgICAgICAgICBvZmZzZXQ6IDIgKiA0LFxuICAgICAgICAgICAgc3RyaWRlOiBzdHJpZGVcbiAgICAgICAgfSwgeyAvL2NvbG9yIChwYWNrZWQpIENcbiAgICAgICAgICAgIG5hbWU6ICdjb2xvcicsXG4gICAgICAgICAgICBidWZmZXI6IHRoaXMudmVydGV4QnVmZmVyLFxuICAgICAgICAgICAgc2l6ZTogNCxcbiAgICAgICAgICAgIHN0cmlkZTogc3RyaWRlLFxuICAgICAgICAgICAgb2Zmc2V0OiA0ICogNCxcbiAgICAgICAgICAgIHR5cGU6IGdsLlVOU0lHTkVEX0JZVEUsXG4gICAgICAgICAgICBub3JtYWxpemVkOiB0cnVlXG4gICAgICAgIH1dLCB0aGlzLmluZGV4QnVmZmVyKVxuICAgICAgICByZXR1cm4gdGhpc1xuICAgIH0sXG5cbiAgICBlbnN1cmVDYXBhY2l0eTogZnVuY3Rpb24oY2FwYWNpdHkpIHtcbiAgICAgICAgaWYgKHRoaXMuY2FwYWNpdHkgPCBjYXBhY2l0eSlcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlKHsgY2FwYWNpdHk6IGNhcGFjaXR5IH0pXG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgfVxufSIsInZhciBjb2xvclRvRmxvYXQgPSByZXF1aXJlKCcuL3BhY2stcmdiYS1mbG9hdCcpXG52YXIgbWl4ZXMgPSByZXF1aXJlKCdtaXhlcycpXG52YXIgcHJlbXVsdCA9IHJlcXVpcmUoJ3ByZW11bHRpcGxpZWQtcmdiYScpXG52YXIgV2hpdGVUZXggPSByZXF1aXJlKCdnbC13aGl0ZS10ZXh0dXJlJylcblxudmFyIHZlcnROdW1GbG9hdHMgPSByZXF1aXJlKCcuL2NvbW1vbicpLmZsb2F0c1BlclZlcnRleFxuXG4vL1RlbXBvcmFyeSBhcnJheXMgdG8gYXZvaWQgR0MgdGhyYXNoaW5nXG52YXIgcG9zaXRpb24gPSBbMCwgMF0sXG4gICAgc2hhcGUgPSBbMCwgMF0sXG4gICAgdGV4Y29vcmQgPSBbMCwgMCwgMCwgMF0sXG4gICAgY29sb3IgPSBbMCwgMCwgMCwgMF1cblxudmFyIHRtcDQgPSBbMCwgMCwgMCwgMF0sXG4gICAgcm90T3JpZ2luID0gWzAsIDBdLFxuICAgIHRtcDIgPSBbMCwgMF1cblxuZnVuY3Rpb24gU3ByaXRlQmF0Y2goZ2wsIG9wdCkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTcHJpdGVCYXRjaCkpXG4gICAgICAgIHJldHVybiBuZXcgU3ByaXRlQmF0Y2goZ2wsIG9wdClcbiAgICBpZiAoIWdsKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtdXN0IHNwZWNpZnkgZ2wgY29udGV4dFwiKVxuICAgIHRoaXMuZ2wgPSBnbFxuICAgIG9wdCA9IG9wdCB8fCB7fVxuICAgIFxuICAgIHRoaXMuX2JvdW5kID0gZmFsc2VcbiAgICB0aGlzLmlkeCA9IDBcblxuICAgIC8vbm8gdHJhbnNmb3JtIG1lYW5zIGlkZW50aXR5XG4gICAgdGhpcy50cmFuc2Zvcm0gPSBudWxsXG5cbiAgICAvL3doaXRlIHRleHR1cmUgaXMgYWtpbiB0byBcIm5vIHRleHR1cmVcIiAod2l0aG91dCBzd2l0Y2hpbmcgc2hhZGVycylcbiAgICB0aGlzLl9kZWZhdWx0VGV4dHVyZSA9IG9wdC5kZWZhdWx0VGV4dHVyZSB8fCBXaGl0ZVRleChnbClcbiAgICB0aGlzLl9vd25zRGVmYXVsdCA9ICFvcHQuZGVmYXVsdFRleHR1cmVcbiAgICB0aGlzLl9sYXN0VGV4dHVyZSA9IHRoaXMuX2RlZmF1bHRUZXh0dXJlXG4gICAgdGhpcy5fdGV4dHVyZSA9IHRoaXMuX2RlZmF1bHRUZXh0dXJlXG4gICAgdGhpcy50ZXh0dXJlID0gbnVsbFxuXG4gICAgdGhpcy5tb2RlID0gdHlwZW9mIG9wdC5tb2RlID09PSAnbnVtYmVyJyA/IG9wdC5tb2RlIDogZ2wuVFJJQU5HTEVTXG4gICAgdGhpcy5wcmVtdWx0aXBsaWVkID0gb3B0LnByZW11bHRpcGxpZWQgfHwgZmFsc2VcblxuICAgIHRoaXMuX2RpcnR5ID0gdHJ1ZVxuICAgIHRoaXMuY3JlYXRlKG9wdClcblxuICAgIC8vc2V0IGRlZmF1bHQgYXR0cmlidXRlc1xuICAgIHRoaXMuZGVmYXVsdHMoKVxufVxuXG4vL21peCBpbiBjcmVhdGUoKSBhbmQgZW5zdXJlQ2FwYWNpdHkoKSBmdW5jdGlvbnNcbm1peGVzKFNwcml0ZUJhdGNoLCByZXF1aXJlKCcuL2NvbW1vbicpLm1peGlucylcblxubWl4ZXMoU3ByaXRlQmF0Y2gsIHtcblxuICAgIGNhcGFjaXR5OiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2FwYWNpdHlcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICB0ZXh0dXJlOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdGV4dHVyZVxuICAgICAgICB9LFxuXG4gICAgICAgIHNldDogZnVuY3Rpb24odGV4KSB7XG4gICAgICAgICAgICB0aGlzLl90ZXh0dXJlID0gdGV4IHx8IHRoaXMuX2RlZmF1bHRUZXh0dXJlXG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZGlzcG9zZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLnZlcnRleEJ1ZmZlcilcbiAgICAgICAgICAgIHRoaXMudmVydGV4QnVmZmVyLmRpc3Bvc2UoKVxuICAgICAgICBpZiAodGhpcy5pbmRleEJ1ZmZlcilcbiAgICAgICAgICAgIHRoaXMuaW5kZXhCdWZmZXIuZGlzcG9zZSgpXG4gICAgICAgIGlmICh0aGlzLnZhbylcbiAgICAgICAgICAgIHRoaXMudmFvLmRpc3Bvc2UoKVxuICAgICAgICBpZiAodGhpcy5fb3duc0RlZmF1bHQpXG4gICAgICAgICAgICB0aGlzLl9kZWZhdWx0VGV4dHVyZS5kaXNwb3NlKClcbiAgICB9LFxuXG4gICAgY2xlYXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmlkeCA9IDBcbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICB9LFxuXG4gICAgYmluZDogZnVuY3Rpb24oc2hhZGVyKSB7XG4gICAgICAgIHNoYWRlci5iaW5kKClcbiAgICAgICAgdGhpcy52YW8uYmluZChzaGFkZXIpXG4gICAgICAgIHRoaXMuX2JvdW5kID0gdHJ1ZVxuICAgIH0sXG5cbiAgICB1bmJpbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnZhby51bmJpbmQoKVxuICAgICAgICB0aGlzLl9ib3VuZCA9IGZhbHNlXG4gICAgfSxcblxuICAgIGRlZmF1bHRzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IGNvcHkyKHBvc2l0aW9uLCAwLCAwKVxuICAgICAgICB0aGlzLnRleGNvb3JkID0gY29weTQodGV4Y29vcmQsIDAsIDAsIDEsIDEpXG4gICAgICAgIHRoaXMuY29sb3IgPSBjb3B5NChjb2xvciwgMSwgMSwgMSwgMSlcbiAgICAgICAgdGhpcy5zaGFwZSA9IGNvcHkyKHNoYXBlLCAwLCAwKVxuICAgICAgICByZXR1cm4gdGhpc1xuICAgIH0sXG5cbiAgICBwdXNoOiBmdW5jdGlvbihzcHJpdGUpIHtcbiAgICAgICAgLy9pZiB3ZSBhcmUgZGVmaW5pbmcgYXR0cmlidXRlcyBvbiB0aGUgZmx5XG4gICAgICAgIGlmIChzcHJpdGUpIHtcbiAgICAgICAgICAgIHRoaXMudGV4dHVyZSA9IHNwcml0ZS50ZXh0dXJlXG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uID0gc3ByaXRlLnBvc2l0aW9uIHx8IGNvcHkyKHBvc2l0aW9uLCAwLCAwKVxuICAgICAgICAgICAgdGhpcy50ZXhjb29yZCA9IHNwcml0ZS50ZXhjb29yZCB8fCBjb3B5NCh0ZXhjb29yZCwgMCwgMCwgMSwgMSlcbiAgICAgICAgICAgIHRoaXMuY29sb3IgPSBzcHJpdGUuY29sb3IgfHwgY29weTQoY29sb3IsIDEsIDEsIDEsIDEpXG4gICAgICAgICAgICB0aGlzLnNoYXBlID0gc3ByaXRlLnNoYXBlIHx8IGNvcHkyKHNoYXBlLCAwLCAwKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMudGV4dHVyZSAhPT0gdGhpcy5fbGFzdFRleHR1cmUpIHtcbiAgICAgICAgICAgIC8vbmV3IHRleHR1cmUsIGZsdXNoIHByZXZpb3VzIGRhdGFcbiAgICAgICAgICAgIGlmICh0aGlzLl9ib3VuZClcbiAgICAgICAgICAgICAgICB0aGlzLmZsdXNoKClcbiAgICAgICAgICAgIHRoaXMuX2xhc3RUZXh0dXJlID0gdGhpcy50ZXh0dXJlXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5pZHggPT09IHRoaXMudmVydGljZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAvL2lmIHdlIEFSRU4nVCBib3VuZCwgd2UgbmVlZCB0byBzdG9wIHB1c2hpbmcgdmVydGV4IGRhdGEhXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2JvdW5kKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzXG5cbiAgICAgICAgICAgIC8vaWYgd2UgQVJFIGJvdW5kLCB3ZSBjYW4gZmx1c2ggdGhlIGJhdGNoIGFuZCBjb250aW51ZSBkcmF3aW5nXG4gICAgICAgICAgICB0aGlzLmZsdXNoKClcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2RpcnR5ID0gdHJ1ZVxuXG4gICAgICAgIC8vZ2V0IFJHQkEgY29tcG9uZW50cyBhbmQgcGFjayBpbnRvIGEgc2luZ2xlIGZsb2F0XG4gICAgICAgIHZhciBjb2xvclJHQkEgPSB0aGlzLnByZW11bHRpcGxpZWQgPyBwcmVtdWx0KHRoaXMuY29sb3IsIHRtcDQpIDogdGhpcy5jb2xvclxuICAgICAgICB2YXIgYyA9IGNvbG9yVG9GbG9hdChjb2xvclJHQkEpXG5cbiAgICAgICAgdmFyIHUxID0gdGhpcy50ZXhjb29yZFswXSxcbiAgICAgICAgICAgIHYxID0gdGhpcy50ZXhjb29yZFsxXSxcbiAgICAgICAgICAgIHUyID0gdGhpcy50ZXhjb29yZFsyXSxcbiAgICAgICAgICAgIHYyID0gdGhpcy50ZXhjb29yZFszXVxuXG4gICAgICAgIHZhciB4ID0gdGhpcy5wb3NpdGlvblswXSxcbiAgICAgICAgICAgIHkgPSB0aGlzLnBvc2l0aW9uWzFdLFxuICAgICAgICAgICAgd2lkdGggPSB0aGlzLnNoYXBlWzBdLFxuICAgICAgICAgICAgaGVpZ2h0ID0gdGhpcy5zaGFwZVsxXVxuXG4gICAgICAgIHRoaXMuX3ZlcnQoeCwgeSwgdTEsIHYxLCBjKVxuICAgICAgICB0aGlzLl92ZXJ0KHgrd2lkdGgsIHksIHUyLCB2MSwgYylcbiAgICAgICAgdGhpcy5fdmVydCh4K3dpZHRoLCB5K2hlaWdodCwgdTIsIHYyLCBjKVxuICAgICAgICB0aGlzLl92ZXJ0KHgsIHkraGVpZ2h0LCB1MSwgdjIsIGMpXG4gICAgICAgIFxuICAgICAgICByZXR1cm4gdGhpc1xuICAgIH0sXG5cbiAgICBfdmVydDogZnVuY3Rpb24oeDEsIHkxLCB1MSwgdjEsIGMpIHtcbiAgICAgICAgdmFyIGlkeCA9IHRoaXMuaWR4LFxuICAgICAgICAgICAgdmVydHMgPSB0aGlzLnZlcnRpY2VzLFxuICAgICAgICAgICAgdHJhbnNmb3JtID0gdGhpcy50cmFuc2Zvcm1cblxuICAgICAgICBpZiAodHJhbnNmb3JtKSB7XG4gICAgICAgICAgICB2YXIgeCA9IHgxLCB5ID0geTFcbiAgICAgICAgICAgIHgxID0gdHJhbnNmb3JtWzBdICogeCArIHRyYW5zZm9ybVs0XSAqIHkgKyB0cmFuc2Zvcm1bMTJdXG4gICAgICAgICAgICB5MSA9IHRyYW5zZm9ybVsxXSAqIHggKyB0cmFuc2Zvcm1bNV0gKiB5ICsgdHJhbnNmb3JtWzEzXVxuICAgICAgICB9XG5cbiAgICAgICAgLy94eVxuICAgICAgICB2ZXJ0c1tpZHgrK10gPSB4MVxuICAgICAgICB2ZXJ0c1tpZHgrK10gPSB5MVxuICAgICAgICAvL3V2XG4gICAgICAgIHZlcnRzW2lkeCsrXSA9IHUxXG4gICAgICAgIHZlcnRzW2lkeCsrXSA9IHYxXG4gICAgICAgIC8vY29sb3JcbiAgICAgICAgdmVydHNbaWR4KytdID0gY1xuICAgICAgICB0aGlzLmlkeCA9IGlkeFxuICAgIH0sXG5cbiAgICBmbHVzaDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZHJhdygpXG4gICAgICAgIHJldHVybiB0aGlzLmNsZWFyKClcbiAgICB9LFxuXG4gICAgZHJhdzogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vSWYgd2UndmUgcmVhY2hlZCBhIG5ldyB0ZXh0dXJlIG9yIGNhcGFjaXR5XG4gICAgICAgIC8vd2hpbGUgbm90IGJvdW5kLCB0aGVuIHdlIHdpbGwganVzdCBjbGVhciB0aGUgYmF0Y2hcbiAgICAgICAgLy90byB6ZXJvIGFuZCBkcmF3IG5vdGhpbmdcbiAgICAgICAgaWYgKHRoaXMuaWR4ID09PSAwIHx8ICF0aGlzLl9ib3VuZClcbiAgICAgICAgICAgIHJldHVybiB0aGlzXG5cbiAgICAgICAgdmFyIGdsID0gdGhpcy5nbFxuICAgICAgICBcbiAgICAgICAgaWYgKHRoaXMuX2RpcnR5KSB7XG4gICAgICAgICAgICB2YXIgdmlldyA9IHRoaXMudmVydGljZXMuc3ViYXJyYXkoMCwgdGhpcy5pZHgpXG4gICAgICAgICAgICB0aGlzLnZlcnRleEJ1ZmZlci51cGRhdGUodmlldywgMClcbiAgICAgICAgICAgIHRoaXMuX2RpcnR5ID0gZmFsc2VcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9sYXN0VGV4dHVyZSlcbiAgICAgICAgICAgIHRoaXMuX2xhc3RUZXh0dXJlLmJpbmQoKVxuICAgICAgICB0aGlzLl9sYXN0VGV4dHVyZSA9IHRoaXMudGV4dHVyZVxuXG4gICAgICAgIHZhciBzcHJpdGVzID0gKHRoaXMuaWR4IC8gKHZlcnROdW1GbG9hdHMgKiA0KSlcbiAgICAgICAgaWYgKHNwcml0ZXMgPiAwKVxuICAgICAgICAgICAgdGhpcy52YW8uZHJhdyh0aGlzLm1vZGUsIHNwcml0ZXMgKiA2LCAwKVxuICAgICAgICByZXR1cm4gdGhpc1xuICAgIH0sXG59KVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNwcml0ZUJhdGNoXG5cbi8vVE9ETzogd2lsbCB1c2UgbW9kdWxhciBnbC1tYXRyaXggZm9yIHRoZXNlLi4uXG5mdW5jdGlvbiBjb3B5MihvdXQsIHgsIHkpIHtcbiAgICBvdXRbMF0gPSB4XG4gICAgb3V0WzFdID0geVxuICAgIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gY29weTQob3V0LCB4LCB5LCB6LCB3KSB7XG4gICAgb3V0WzBdID0geFxuICAgIG91dFsxXSA9IHlcbiAgICBvdXRbMl0gPSB6XG4gICAgb3V0WzNdID0gd1xuICAgIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gY29weVZlYzIob3V0LCB2ZWMpIHtcbiAgICByZXR1cm4gY29weTIob3V0LCB2ZWNbMF0sIHZlY1sxXSlcbn1cblxuZnVuY3Rpb24gdHJhbnNmb3JtTWF0NChvdXQsIGEsIG0pIHtcbiAgICB2YXIgeCA9IGFbMF0sIFxuICAgICAgICB5ID0gYVsxXVxuICAgIG91dFswXSA9IG1bMF0gKiB4ICsgbVs0XSAqIHkgKyBtWzEyXVxuICAgIG91dFsxXSA9IG1bMV0gKiB4ICsgbVs1XSAqIHkgKyBtWzEzXVxuICAgIHJldHVybiBvdXRcbn0iLCJ2YXIgY3JlYXRlVkFPRW11bGF0ZWQgPSByZXF1aXJlKFwiLi9saWIvdmFvLWVtdWxhdGVkLmpzXCIpXG5cbmZ1bmN0aW9uIGNyZWF0ZVZBTyhnbCwgYXR0cmlidXRlcywgZWxlbWVudHMsIGVsZW1lbnRzVHlwZSkge1xuICB2YXIgdmFvID0gY3JlYXRlVkFPRW11bGF0ZWQoZ2wpXG4gIHZhby51cGRhdGUoYXR0cmlidXRlcywgZWxlbWVudHMsIGVsZW1lbnRzVHlwZSlcbiAgcmV0dXJuIHZhb1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZVZBTyIsImZ1bmN0aW9uIGdldEF0dHJpYnV0ZUxvY2F0aW9uKG5hbWUsIHNoYWRlcikge1xuICAgIGlmICghbmFtZSlcbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICB2YXIgYXR0ciA9IHNoYWRlci5hdHRyaWJ1dGVzXG4gICAgaWYgKGF0dHJbbmFtZV0pIFxuICAgICAgICByZXR1cm4gYXR0cltuYW1lXS5sb2NhdGlvblxuICAgIHJldHVybiBudWxsXG59XG5cbnZhciBuYXR0cmlicyA9IG51bGxcbnZhciBib3VuZCA9IG51bGxcblxuZnVuY3Rpb24gZG9CaW5kKGdsLCBlbGVtZW50cywgYXR0cmlidXRlcywgc2hhZGVyKSB7XG4gICAgaWYgKGVsZW1lbnRzKSB7XG4gICAgICAgIGVsZW1lbnRzLmJpbmQoKVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIG51bGwpXG4gICAgfVxuICAgIGlmIChuYXR0cmlicyA9PT0gbnVsbCkge1xuICAgICAgbmF0dHJpYnMgPSBnbC5nZXRQYXJhbWV0ZXIoZ2wuTUFYX1ZFUlRFWF9BVFRSSUJTKSB8IDBcbiAgICAgIGJvdW5kID0gbmV3IEFycmF5KG5hdHRyaWJzKVxuICAgIH1cblxuICAgIGlmIChhdHRyaWJ1dGVzKSB7XG4gICAgICAgIGlmIChhdHRyaWJ1dGVzLmxlbmd0aCA+IG5hdHRyaWJzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJnbC12YW86IFRvbyBtYW55IHZlcnRleCBhdHRyaWJ1dGVzXCIpXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbGFzdEJvdW5kID0gbnVsbFxuXG4gICAgICAgIGZvciAoaT0wOyBpPG5hdHRyaWJzOyBpKyspXG4gICAgICAgICAgYm91bmRbaV0gPSBmYWxzZVxuXG4gICAgICAgIC8vbm93IGJpbmQgYWxpYXNlZCBhdHRyaWJ1dGVzXG4gICAgICAgIGZvciAoaT0wOyBpPGF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBhdHRyaWIgPSBhdHRyaWJ1dGVzW2ldXG4gICAgICAgICAgICB2YXIgbG9jID0gZ2V0QXR0cmlidXRlTG9jYXRpb24oYXR0cmliLm5hbWUsIHNoYWRlcilcbiAgICAgICAgICAgIGlmIChsb2MgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgY29udGludWVcblxuICAgICAgICAgICAgYm91bmRbbG9jXSA9IHRydWVcblxuICAgICAgICAgICAgaWYoYXR0cmliLmJ1ZmZlcikge1xuICAgICAgICAgICAgICB2YXIgYnVmZmVyID0gYXR0cmliLmJ1ZmZlclxuICAgICAgICAgICAgICB2YXIgc2l6ZSA9IGF0dHJpYi5zaXplIHx8IDRcbiAgICAgICAgICAgICAgdmFyIHR5cGUgPSBhdHRyaWIudHlwZSB8fCBnbC5GTE9BVFxuICAgICAgICAgICAgICB2YXIgbm9ybWFsaXplZCA9ICEhYXR0cmliLm5vcm1hbGl6ZWRcbiAgICAgICAgICAgICAgdmFyIHN0cmlkZSA9IGF0dHJpYi5zdHJpZGUgfHwgMFxuICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gYXR0cmliLm9mZnNldCB8fCAwXG4gICAgICAgICAgICAgIGlmIChsYXN0Qm91bmQgIT09IGJ1ZmZlcikge1xuICAgICAgICAgICAgICAgIGJ1ZmZlci5iaW5kKClcbiAgICAgICAgICAgICAgICBsYXN0Qm91bmQgPSBidWZmZXJcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShsb2MpXG4gICAgICAgICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIobG9jLCBzaXplLCB0eXBlLCBub3JtYWxpemVkLCBzdHJpZGUsIG9mZnNldClcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmKHR5cGVvZiBhdHRyaWIgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICBnbC52ZXJ0ZXhBdHRyaWIxZihsb2MsIGF0dHJpYilcbiAgICAgICAgICAgICAgfSBlbHNlIGlmKGF0dHJpYi5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICBnbC52ZXJ0ZXhBdHRyaWIxZihsb2MsIGF0dHJpYlswXSlcbiAgICAgICAgICAgICAgfSBlbHNlIGlmKGF0dHJpYi5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgICAgICBnbC52ZXJ0ZXhBdHRyaWIyZihsb2MsIGF0dHJpYlswXSwgYXR0cmliWzFdKVxuICAgICAgICAgICAgICB9IGVsc2UgaWYoYXR0cmliLmxlbmd0aCA9PT0gMykge1xuICAgICAgICAgICAgICAgIGdsLnZlcnRleEF0dHJpYjNmKGxvYywgYXR0cmliWzBdLCBhdHRyaWJbMV0sIGF0dHJpYlsyXSlcbiAgICAgICAgICAgICAgfSBlbHNlIGlmKGF0dHJpYi5sZW5ndGggPT09IDQpIHtcbiAgICAgICAgICAgICAgICBnbC52ZXJ0ZXhBdHRyaWI0Zihsb2MsIGF0dHJpYlswXSwgYXR0cmliWzFdLCBhdHRyaWJbMl0sIGF0dHJpYlszXSlcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJnbC12YW86IEludmFsaWQgdmVydGV4IGF0dHJpYnV0ZVwiKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGdsLmRpc2FibGVWZXJ0ZXhBdHRyaWJBcnJheShsb2MpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgZm9yIChpPTA7IGk8bmF0dHJpYnM7IGkrKykge1xuICAgICAgICAgIGlmICghYm91bmRbaV0pXG4gICAgICAgICAgICBnbC5kaXNhYmxlVmVydGV4QXR0cmliQXJyYXkoaSlcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgbnVsbClcbiAgICAgIGZvcih2YXIgaT0wOyBpPG5hdHRyaWJzOyArK2kpIHtcbiAgICAgICAgZ2wuZGlzYWJsZVZlcnRleEF0dHJpYkFycmF5KGkpXG4gICAgICB9XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGRvQmluZCIsInZhciBiaW5kQXR0cmlicyA9IHJlcXVpcmUoXCIuL2RvLWJpbmQuanNcIilcblxuZnVuY3Rpb24gVkFPRW11bGF0ZWQoZ2wpIHtcbiAgdGhpcy5nbCA9IGdsXG4gIHRoaXMuX2VsZW1lbnRzID0gbnVsbFxuICB0aGlzLl9hdHRyaWJ1dGVzID0gbnVsbFxuICB0aGlzLl9lbGVtZW50c1R5cGUgPSBnbC5VTlNJR05FRF9TSE9SVFxufVxuXG5WQU9FbXVsYXRlZC5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uKHNoYWRlcikge1xuICBpZiAoIXNoYWRlcilcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ211c3QgYXNzb2NpYXRlIHNoYWRlciB3aXRoIHZlcnRleCBhcnJheScpXG4gIGJpbmRBdHRyaWJzKHRoaXMuZ2wsIHRoaXMuX2VsZW1lbnRzLCB0aGlzLl9hdHRyaWJ1dGVzLCBzaGFkZXIpXG59XG5cblZBT0VtdWxhdGVkLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbihhdHRyaWJ1dGVzLCBlbGVtZW50cywgZWxlbWVudHNUeXBlKSB7XG4gIHRoaXMuX2VsZW1lbnRzID0gZWxlbWVudHNcbiAgdGhpcy5fYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXNcbiAgdGhpcy5fZWxlbWVudHNUeXBlID0gZWxlbWVudHNUeXBlIHx8IHRoaXMuZ2wuVU5TSUdORURfU0hPUlRcbn1cblxuVkFPRW11bGF0ZWQucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbigpIHsgfVxuVkFPRW11bGF0ZWQucHJvdG90eXBlLnVuYmluZCA9IGZ1bmN0aW9uKCkge1xuICBiaW5kQXR0cmlicyh0aGlzLmdsKVxufVxuXG5WQU9FbXVsYXRlZC5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uKG1vZGUsIGNvdW50LCBvZmZzZXQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDBcbiAgdmFyIGdsID0gdGhpcy5nbFxuICBpZih0aGlzLl9lbGVtZW50cykge1xuICAgIGdsLmRyYXdFbGVtZW50cyhtb2RlLCBjb3VudCwgdGhpcy5fZWxlbWVudHNUeXBlLCBvZmZzZXQpXG4gIH0gZWxzZSB7XG4gICAgZ2wuZHJhd0FycmF5cyhtb2RlLCBvZmZzZXQsIGNvdW50KVxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVZBT0VtdWxhdGVkKGdsKSB7XG4gIHJldHVybiBuZXcgVkFPRW11bGF0ZWQoZ2wpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlVkFPRW11bGF0ZWQiLCJcInVzZSBzdHJpY3RcIlxuXG52YXIgcG9vbCA9IHJlcXVpcmUoXCJ0eXBlZGFycmF5LXBvb2xcIilcbnZhciBvcHMgPSByZXF1aXJlKFwibmRhcnJheS1vcHNcIilcbnZhciBuZGFycmF5ID0gcmVxdWlyZShcIm5kYXJyYXlcIilcbnZhciB3ZWJnbGV3ID0gcmVxdWlyZShcIndlYmdsZXdcIilcblxudmFyIFNVUFBPUlRFRF9UWVBFUyA9IFtcbiAgXCJ1aW50OFwiLFxuICBcInVpbnQ4X2NsYW1wZWRcIixcbiAgXCJ1aW50MTZcIixcbiAgXCJ1aW50MzJcIixcbiAgXCJpbnQ4XCIsXG4gIFwiaW50MTZcIixcbiAgXCJpbnQzMlwiLFxuICBcImZsb2F0MzJcIiBdXG5cbmZ1bmN0aW9uIEdMQnVmZmVyKGdsLCB0eXBlLCBoYW5kbGUsIGxlbmd0aCwgdXNhZ2UpIHtcbiAgdGhpcy5nbCA9IGdsXG4gIHRoaXMudHlwZSA9IHR5cGVcbiAgdGhpcy5oYW5kbGUgPSBoYW5kbGVcbiAgdGhpcy5sZW5ndGggPSBsZW5ndGhcbiAgdGhpcy51c2FnZSA9IHVzYWdlXG59XG5cbnZhciBwcm90byA9IEdMQnVmZmVyLnByb3RvdHlwZVxuXG5wcm90by5iaW5kID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZ2wuYmluZEJ1ZmZlcih0aGlzLnR5cGUsIHRoaXMuaGFuZGxlKVxufVxuXG5wcm90by51bmJpbmQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5nbC5iaW5kQnVmZmVyKHRoaXMudHlwZSwgbnVsbClcbn1cblxucHJvdG8uZGlzcG9zZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmdsLmRlbGV0ZUJ1ZmZlcih0aGlzLmhhbmRsZSlcbn1cblxuZnVuY3Rpb24gdXBkYXRlVHlwZUFycmF5KGdsLCB0eXBlLCBsZW4sIHVzYWdlLCBkYXRhLCBvZmZzZXQpIHtcbiAgdmFyIGRhdGFMZW4gPSBkYXRhLmxlbmd0aCAqIGRhdGEuQllURVNfUEVSX0VMRU1FTlQgXG4gIGlmKG9mZnNldCA8IDApIHtcbiAgICBnbC5idWZmZXJEYXRhKHR5cGUsIGRhdGEsIHVzYWdlKVxuICAgIHJldHVybiBkYXRhTGVuXG4gIH1cbiAgaWYoZGF0YUxlbiArIG9mZnNldCA+IGxlbikge1xuICAgIHRocm93IG5ldyBFcnJvcihcImdsLWJ1ZmZlcjogSWYgcmVzaXppbmcgYnVmZmVyLCBtdXN0IG5vdCBzcGVjaWZ5IG9mZnNldFwiKVxuICB9XG4gIGdsLmJ1ZmZlclN1YkRhdGEodHlwZSwgb2Zmc2V0LCBkYXRhKVxuICByZXR1cm4gbGVuXG59XG5cbmZ1bmN0aW9uIG1ha2VTY3JhdGNoVHlwZUFycmF5KGFycmF5LCBkdHlwZSkge1xuICB2YXIgcmVzID0gcG9vbC5tYWxsb2MoYXJyYXkubGVuZ3RoLCBkdHlwZSlcbiAgdmFyIG4gPSBhcnJheS5sZW5ndGhcbiAgZm9yKHZhciBpPTA7IGk8bjsgKytpKSB7XG4gICAgcmVzW2ldID0gYXJyYXlbaV1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGlzUGFja2VkKHNoYXBlLCBzdHJpZGUpIHtcbiAgdmFyIG4gPSAxXG4gIGZvcih2YXIgaT1zdHJpZGUubGVuZ3RoLTE7IGk+PTA7IC0taSkge1xuICAgIGlmKHN0cmlkZVtpXSAhPT0gbikge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIG4gKj0gc2hhcGVbaV1cbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG5wcm90by51cGRhdGUgPSBmdW5jdGlvbihhcnJheSwgb2Zmc2V0KSB7XG4gIGlmKHR5cGVvZiBvZmZzZXQgIT09IFwibnVtYmVyXCIpIHtcbiAgICBvZmZzZXQgPSAtMVxuICB9XG4gIHRoaXMuYmluZCgpXG4gIGlmKHR5cGVvZiBhcnJheSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgYXJyYXkuc2hhcGUgIT09IFwidW5kZWZpbmVkXCIpIHsgLy9uZGFycmF5XG4gICAgdmFyIGR0eXBlID0gYXJyYXkuZHR5cGVcbiAgICBpZihTVVBQT1JURURfVFlQRVMuaW5kZXhPZihkdHlwZSkgPCAwKSB7XG4gICAgICBkdHlwZSA9IFwiZmxvYXQzMlwiXG4gICAgfVxuICAgIGlmKHRoaXMudHlwZSA9PT0gdGhpcy5nbC5FTEVNRU5UX0FSUkFZX0JVRkZFUikge1xuICAgICAgdmFyIHdnbCA9IHdlYmdsZXcodGhpcy5nbClcbiAgICAgIHZhciBleHQgPSB3Z2wuT0VTX2VsZW1lbnRfaW5kZXhfdWludFxuICAgICAgaWYoZXh0ICYmIGR0eXBlICE9PSBcInVpbnQxNlwiKSB7XG4gICAgICAgIGR0eXBlID0gXCJ1aW50MzJcIlxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZHR5cGUgPSBcInVpbnQxNlwiXG4gICAgICB9XG4gICAgfVxuICAgIGlmKGR0eXBlID09PSBhcnJheS5kdHlwZSAmJiBpc1BhY2tlZChhcnJheS5zaGFwZSwgYXJyYXkuc3RyaWRlKSkge1xuICAgICAgaWYoYXJyYXkub2Zmc2V0ID09PSAwICYmIGFycmF5LmRhdGEubGVuZ3RoID09PSBhcnJheS5zaGFwZVswXSkge1xuICAgICAgICB0aGlzLmxlbmd0aCA9IHVwZGF0ZVR5cGVBcnJheSh0aGlzLmdsLCB0aGlzLnR5cGUsIHRoaXMubGVuZ3RoLCB0aGlzLnVzYWdlLCBhcnJheS5kYXRhLCBvZmZzZXQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxlbmd0aCA9IHVwZGF0ZVR5cGVBcnJheSh0aGlzLmdsLCB0aGlzLnR5cGUsIHRoaXMubGVuZ3RoLCB0aGlzLnVzYWdlLCBhcnJheS5kYXRhLnN1YmFycmF5KGFycmF5Lm9mZnNldCwgYXJyYXkuc2hhcGVbMF0pLCBvZmZzZXQpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB0bXAgPSBwb29sLm1hbGxvYyhhcnJheS5zaXplLCBkdHlwZSlcbiAgICAgIHZhciBuZHQgPSBuZGFycmF5KHRtcCwgYXJyYXkuc2hhcGUpXG4gICAgICBvcHMuYXNzaWduKG5kdCwgYXJyYXkpXG4gICAgICBpZihvZmZzZXQgPCAwKSB7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gdXBkYXRlVHlwZUFycmF5KHRoaXMuZ2wsIHRoaXMudHlwZSwgdGhpcy5sZW5ndGgsIHRoaXMudXNhZ2UsIHRtcCwgb2Zmc2V0KSAgXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxlbmd0aCA9IHVwZGF0ZVR5cGVBcnJheSh0aGlzLmdsLCB0aGlzLnR5cGUsIHRoaXMubGVuZ3RoLCB0aGlzLnVzYWdlLCB0bXAuc3ViYXJyYXkoMCwgYXJyYXkuc2l6ZSksIG9mZnNldCkgIFxuICAgICAgfVxuICAgICAgcG9vbC5mcmVlKHRtcClcbiAgICB9XG4gIH0gZWxzZSBpZihBcnJheS5pc0FycmF5KGFycmF5KSkgeyAvL1ZhbmlsbGEgYXJyYXlcbiAgICB2YXIgdFxuICAgIGlmKHRoaXMudHlwZSA9PT0gdGhpcy5nbC5FTEVNRU5UX0FSUkFZX0JVRkZFUikge1xuICAgICAgdCA9IG1ha2VTY3JhdGNoVHlwZUFycmF5KGFycmF5LCBcInVpbnQxNlwiKVxuICAgIH0gZWxzZSB7XG4gICAgICB0ID0gbWFrZVNjcmF0Y2hUeXBlQXJyYXkoYXJyYXksIFwiZmxvYXQzMlwiKVxuICAgIH1cbiAgICBpZihvZmZzZXQgPCAwKSB7XG4gICAgICB0aGlzLmxlbmd0aCA9IHVwZGF0ZVR5cGVBcnJheSh0aGlzLmdsLCB0aGlzLnR5cGUsIHRoaXMubGVuZ3RoLCB0aGlzLnVzYWdlLCB0LCBvZmZzZXQpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubGVuZ3RoID0gdXBkYXRlVHlwZUFycmF5KHRoaXMuZ2wsIHRoaXMudHlwZSwgdGhpcy5sZW5ndGgsIHRoaXMudXNhZ2UsIHQuc3ViYXJyYXkoMCwgYXJyYXkubGVuZ3RoKSwgb2Zmc2V0KVxuICAgIH1cbiAgICBwb29sLmZyZWUodClcbiAgfSBlbHNlIGlmKHR5cGVvZiBhcnJheSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgYXJyYXkubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IC8vVHlwZWQgYXJyYXlcbiAgICB0aGlzLmxlbmd0aCA9IHVwZGF0ZVR5cGVBcnJheSh0aGlzLmdsLCB0aGlzLnR5cGUsIHRoaXMubGVuZ3RoLCB0aGlzLnVzYWdlLCBhcnJheSwgb2Zmc2V0KVxuICB9IGVsc2UgaWYodHlwZW9mIGFycmF5ID09PSBcIm51bWJlclwiIHx8IGFycmF5ID09PSB1bmRlZmluZWQpIHsgLy9OdW1iZXIvZGVmYXVsdFxuICAgIGlmKG9mZnNldCA+PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJnbC1idWZmZXI6IENhbm5vdCBzcGVjaWZ5IG9mZnNldCB3aGVuIHJlc2l6aW5nIGJ1ZmZlclwiKVxuICAgIH1cbiAgICBhcnJheSA9IGFycmF5IHwgMFxuICAgIGlmKGFycmF5IDw9IDApIHtcbiAgICAgIGFycmF5ID0gMVxuICAgIH1cbiAgICB0aGlzLmdsLmJ1ZmZlckRhdGEodGhpcy50eXBlLCBhcnJheXwwLCB0aGlzLnVzYWdlKVxuICAgIHRoaXMubGVuZ3RoID0gYXJyYXlcbiAgfSBlbHNlIHsgLy9FcnJvciwgY2FzZSBzaG91bGQgbm90IGhhcHBlblxuICAgIHRocm93IG5ldyBFcnJvcihcImdsLWJ1ZmZlcjogSW52YWxpZCBkYXRhIHR5cGVcIilcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVCdWZmZXIoZ2wsIGRhdGEsIHR5cGUsIHVzYWdlKSB7XG4gIHdlYmdsZXcoZ2wpXG4gIHR5cGUgPSB0eXBlIHx8IGdsLkFSUkFZX0JVRkZFUlxuICB1c2FnZSA9IHVzYWdlIHx8IGdsLkRZTkFNSUNfRFJBV1xuICBpZih0eXBlICE9PSBnbC5BUlJBWV9CVUZGRVIgJiYgdHlwZSAhPT0gZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJnbC1idWZmZXI6IEludmFsaWQgdHlwZSBmb3Igd2ViZ2wgYnVmZmVyLCBtdXN0IGJlIGVpdGhlciBnbC5BUlJBWV9CVUZGRVIgb3IgZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVJcIilcbiAgfVxuICBpZih1c2FnZSAhPT0gZ2wuRFlOQU1JQ19EUkFXICYmIHVzYWdlICE9PSBnbC5TVEFUSUNfRFJBVyAmJiB1c2FnZSAhPT0gZ2wuU1RSRUFNX0RSQVcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJnbC1idWZmZXI6IEludmFsaWQgdXNhZ2UgZm9yIGJ1ZmZlciwgbXVzdCBiZSBlaXRoZXIgZ2wuRFlOQU1JQ19EUkFXLCBnbC5TVEFUSUNfRFJBVyBvciBnbC5TVFJFQU1fRFJBV1wiKVxuICB9XG4gIHZhciBoYW5kbGUgPSBnbC5jcmVhdGVCdWZmZXIoKVxuICB2YXIgcmVzdWx0ID0gbmV3IEdMQnVmZmVyKGdsLCB0eXBlLCBoYW5kbGUsIDAsIHVzYWdlKVxuICByZXN1bHQudXBkYXRlKGRhdGEpXG4gIHJldHVybiByZXN1bHRcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVCdWZmZXIiLCJtb2R1bGUuZXhwb3J0cz1yZXF1aXJlKFwiL3Byb2plY3RzL2JsYWNraWNlL25vZGVfbW9kdWxlcy9nbC10ZXh0dXJlMmQvbm9kZV9tb2R1bGVzL25kYXJyYXktb3BzL25kYXJyYXktb3BzLmpzXCIpIiwiKGZ1bmN0aW9uIChCdWZmZXIpe1xudmFyIGlvdGEgPSByZXF1aXJlKFwiaW90YS1hcnJheVwiKVxuXG52YXIgaGFzVHlwZWRBcnJheXMgID0gKCh0eXBlb2YgRmxvYXQ2NEFycmF5KSAhPT0gXCJ1bmRlZmluZWRcIilcbnZhciBoYXNCdWZmZXIgICAgICAgPSAoKHR5cGVvZiBCdWZmZXIpICE9PSBcInVuZGVmaW5lZFwiKVxuXG5mdW5jdGlvbiBjb21wYXJlMXN0KGEsIGIpIHtcbiAgcmV0dXJuIGFbMF0gLSBiWzBdXG59XG5cbmZ1bmN0aW9uIG9yZGVyKCkge1xuICB2YXIgc3RyaWRlID0gdGhpcy5zdHJpZGVcbiAgdmFyIHRlcm1zID0gbmV3IEFycmF5KHN0cmlkZS5sZW5ndGgpXG4gIHZhciBpXG4gIGZvcihpPTA7IGk8dGVybXMubGVuZ3RoOyArK2kpIHtcbiAgICB0ZXJtc1tpXSA9IFtNYXRoLmFicyhzdHJpZGVbaV0pLCBpXVxuICB9XG4gIHRlcm1zLnNvcnQoY29tcGFyZTFzdClcbiAgdmFyIHJlc3VsdCA9IG5ldyBBcnJheSh0ZXJtcy5sZW5ndGgpXG4gIGZvcihpPTA7IGk8cmVzdWx0Lmxlbmd0aDsgKytpKSB7XG4gICAgcmVzdWx0W2ldID0gdGVybXNbaV1bMV1cbiAgfVxuICByZXR1cm4gcmVzdWx0XG59XG5cbmZ1bmN0aW9uIGNvbXBpbGVDb25zdHJ1Y3RvcihkdHlwZSwgZGltZW5zaW9uKSB7XG4gIHZhciBjbGFzc05hbWUgPSBbXCJWaWV3XCIsIGRpbWVuc2lvbiwgXCJkXCIsIGR0eXBlXS5qb2luKFwiXCIpXG4gIGlmKGRpbWVuc2lvbiA8IDApIHtcbiAgICBjbGFzc05hbWUgPSBcIlZpZXdfTmlsXCIgKyBkdHlwZVxuICB9XG4gIHZhciB1c2VHZXR0ZXJzID0gKGR0eXBlID09PSBcImdlbmVyaWNcIilcbiAgXG4gIGlmKGRpbWVuc2lvbiA9PT0gLTEpIHtcbiAgICAvL1NwZWNpYWwgY2FzZSBmb3IgdHJpdmlhbCBhcnJheXNcbiAgICB2YXIgY29kZSA9IFxuICAgICAgXCJmdW5jdGlvbiBcIitjbGFzc05hbWUrXCIoYSl7dGhpcy5kYXRhPWE7fTtcXFxudmFyIHByb3RvPVwiK2NsYXNzTmFtZStcIi5wcm90b3R5cGU7XFxcbnByb3RvLmR0eXBlPSdcIitkdHlwZStcIic7XFxcbnByb3RvLmluZGV4PWZ1bmN0aW9uKCl7cmV0dXJuIC0xfTtcXFxucHJvdG8uc2l6ZT0wO1xcXG5wcm90by5kaW1lbnNpb249LTE7XFxcbnByb3RvLnNoYXBlPXByb3RvLnN0cmlkZT1wcm90by5vcmRlcj1bXTtcXFxucHJvdG8ubG89cHJvdG8uaGk9cHJvdG8udHJhbnNwb3NlPXByb3RvLnN0ZXA9XFxcbmZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBcIitjbGFzc05hbWUrXCIodGhpcy5kYXRhKTt9O1xcXG5wcm90by5nZXQ9cHJvdG8uc2V0PWZ1bmN0aW9uKCl7fTtcXFxucHJvdG8ucGljaz1mdW5jdGlvbigpe3JldHVybiBudWxsfTtcXFxucmV0dXJuIGZ1bmN0aW9uIGNvbnN0cnVjdF9cIitjbGFzc05hbWUrXCIoYSl7cmV0dXJuIG5ldyBcIitjbGFzc05hbWUrXCIoYSk7fVwiXG4gICAgdmFyIHByb2NlZHVyZSA9IG5ldyBGdW5jdGlvbihjb2RlKVxuICAgIHJldHVybiBwcm9jZWR1cmUoKVxuICB9IGVsc2UgaWYoZGltZW5zaW9uID09PSAwKSB7XG4gICAgLy9TcGVjaWFsIGNhc2UgZm9yIDBkIGFycmF5c1xuICAgIHZhciBjb2RlID1cbiAgICAgIFwiZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiKGEsZCkge1xcXG50aGlzLmRhdGEgPSBhO1xcXG50aGlzLm9mZnNldCA9IGRcXFxufTtcXFxudmFyIHByb3RvPVwiK2NsYXNzTmFtZStcIi5wcm90b3R5cGU7XFxcbnByb3RvLmR0eXBlPSdcIitkdHlwZStcIic7XFxcbnByb3RvLmluZGV4PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMub2Zmc2V0fTtcXFxucHJvdG8uZGltZW5zaW9uPTA7XFxcbnByb3RvLnNpemU9MTtcXFxucHJvdG8uc2hhcGU9XFxcbnByb3RvLnN0cmlkZT1cXFxucHJvdG8ub3JkZXI9W107XFxcbnByb3RvLmxvPVxcXG5wcm90by5oaT1cXFxucHJvdG8udHJhbnNwb3NlPVxcXG5wcm90by5zdGVwPWZ1bmN0aW9uIFwiK2NsYXNzTmFtZStcIl9jb3B5KCkge1xcXG5yZXR1cm4gbmV3IFwiK2NsYXNzTmFtZStcIih0aGlzLmRhdGEsdGhpcy5vZmZzZXQpXFxcbn07XFxcbnByb3RvLnBpY2s9ZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiX3BpY2soKXtcXFxucmV0dXJuIFRyaXZpYWxBcnJheSh0aGlzLmRhdGEpO1xcXG59O1xcXG5wcm90by52YWx1ZU9mPXByb3RvLmdldD1mdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfZ2V0KCl7XFxcbnJldHVybiBcIisodXNlR2V0dGVycyA/IFwidGhpcy5kYXRhLmdldCh0aGlzLm9mZnNldClcIiA6IFwidGhpcy5kYXRhW3RoaXMub2Zmc2V0XVwiKStcblwifTtcXFxucHJvdG8uc2V0PWZ1bmN0aW9uIFwiK2NsYXNzTmFtZStcIl9zZXQodil7XFxcbnJldHVybiBcIisodXNlR2V0dGVycyA/IFwidGhpcy5kYXRhLnNldCh0aGlzLm9mZnNldCx2KVwiIDogXCJ0aGlzLmRhdGFbdGhpcy5vZmZzZXRdPXZcIikrXCJcXFxufTtcXFxucmV0dXJuIGZ1bmN0aW9uIGNvbnN0cnVjdF9cIitjbGFzc05hbWUrXCIoYSxiLGMsZCl7cmV0dXJuIG5ldyBcIitjbGFzc05hbWUrXCIoYSxkKX1cIlxuICAgIHZhciBwcm9jZWR1cmUgPSBuZXcgRnVuY3Rpb24oXCJUcml2aWFsQXJyYXlcIiwgY29kZSlcbiAgICByZXR1cm4gcHJvY2VkdXJlKENBQ0hFRF9DT05TVFJVQ1RPUlNbZHR5cGVdWzBdKVxuICB9XG5cbiAgdmFyIGNvZGUgPSBbXCIndXNlIHN0cmljdCdcIl1cbiAgICBcbiAgLy9DcmVhdGUgY29uc3RydWN0b3IgZm9yIHZpZXdcbiAgdmFyIGluZGljZXMgPSBpb3RhKGRpbWVuc2lvbilcbiAgdmFyIGFyZ3MgPSBpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7IHJldHVybiBcImlcIitpIH0pXG4gIHZhciBpbmRleF9zdHIgPSBcInRoaXMub2Zmc2V0K1wiICsgaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkge1xuICAgICAgICByZXR1cm4gXCJ0aGlzLnN0cmlkZVtcIiArIGkgKyBcIl0qaVwiICsgaVxuICAgICAgfSkuam9pbihcIitcIilcbiAgdmFyIHNoYXBlQXJnID0gaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIFwiYlwiK2lcbiAgICB9KS5qb2luKFwiLFwiKVxuICB2YXIgc3RyaWRlQXJnID0gaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIFwiY1wiK2lcbiAgICB9KS5qb2luKFwiLFwiKVxuICBjb2RlLnB1c2goXG4gICAgXCJmdW5jdGlvbiBcIitjbGFzc05hbWUrXCIoYSxcIiArIHNoYXBlQXJnICsgXCIsXCIgKyBzdHJpZGVBcmcgKyBcIixkKXt0aGlzLmRhdGE9YVwiLFxuICAgICAgXCJ0aGlzLnNoYXBlPVtcIiArIHNoYXBlQXJnICsgXCJdXCIsXG4gICAgICBcInRoaXMuc3RyaWRlPVtcIiArIHN0cmlkZUFyZyArIFwiXVwiLFxuICAgICAgXCJ0aGlzLm9mZnNldD1kfDB9XCIsXG4gICAgXCJ2YXIgcHJvdG89XCIrY2xhc3NOYW1lK1wiLnByb3RvdHlwZVwiLFxuICAgIFwicHJvdG8uZHR5cGU9J1wiK2R0eXBlK1wiJ1wiLFxuICAgIFwicHJvdG8uZGltZW5zaW9uPVwiK2RpbWVuc2lvbilcbiAgXG4gIC8vdmlldy5zaXplOlxuICBjb2RlLnB1c2goXCJPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG8sJ3NpemUnLHtnZXQ6ZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiX3NpemUoKXtcXFxucmV0dXJuIFwiK2luZGljZXMubWFwKGZ1bmN0aW9uKGkpIHsgcmV0dXJuIFwidGhpcy5zaGFwZVtcIitpK1wiXVwiIH0pLmpvaW4oXCIqXCIpLFxuXCJ9fSlcIilcblxuICAvL3ZpZXcub3JkZXI6XG4gIGlmKGRpbWVuc2lvbiA9PT0gMSkge1xuICAgIGNvZGUucHVzaChcInByb3RvLm9yZGVyPVswXVwiKVxuICB9IGVsc2Uge1xuICAgIGNvZGUucHVzaChcIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90bywnb3JkZXInLHtnZXQ6XCIpXG4gICAgaWYoZGltZW5zaW9uIDwgNCkge1xuICAgICAgY29kZS5wdXNoKFwiZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiX29yZGVyKCl7XCIpXG4gICAgICBpZihkaW1lbnNpb24gPT09IDIpIHtcbiAgICAgICAgY29kZS5wdXNoKFwicmV0dXJuIChNYXRoLmFicyh0aGlzLnN0cmlkZVswXSk+TWF0aC5hYnModGhpcy5zdHJpZGVbMV0pKT9bMSwwXTpbMCwxXX19KVwiKVxuICAgICAgfSBlbHNlIGlmKGRpbWVuc2lvbiA9PT0gMykge1xuICAgICAgICBjb2RlLnB1c2goXG5cInZhciBzMD1NYXRoLmFicyh0aGlzLnN0cmlkZVswXSksczE9TWF0aC5hYnModGhpcy5zdHJpZGVbMV0pLHMyPU1hdGguYWJzKHRoaXMuc3RyaWRlWzJdKTtcXFxuaWYoczA+czEpe1xcXG5pZihzMT5zMil7XFxcbnJldHVybiBbMiwxLDBdO1xcXG59ZWxzZSBpZihzMD5zMil7XFxcbnJldHVybiBbMSwyLDBdO1xcXG59ZWxzZXtcXFxucmV0dXJuIFsxLDAsMl07XFxcbn1cXFxufWVsc2UgaWYoczA+czIpe1xcXG5yZXR1cm4gWzIsMCwxXTtcXFxufWVsc2UgaWYoczI+czEpe1xcXG5yZXR1cm4gWzAsMSwyXTtcXFxufWVsc2V7XFxcbnJldHVybiBbMCwyLDFdO1xcXG59fX0pXCIpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvZGUucHVzaChcIk9SREVSfSlcIilcbiAgICB9XG4gIH1cbiAgXG4gIC8vdmlldy5zZXQoaTAsIC4uLiwgdik6XG4gIGNvZGUucHVzaChcblwicHJvdG8uc2V0PWZ1bmN0aW9uIFwiK2NsYXNzTmFtZStcIl9zZXQoXCIrYXJncy5qb2luKFwiLFwiKStcIix2KXtcIilcbiAgaWYodXNlR2V0dGVycykge1xuICAgIGNvZGUucHVzaChcInJldHVybiB0aGlzLmRhdGEuc2V0KFwiK2luZGV4X3N0citcIix2KX1cIilcbiAgfSBlbHNlIHtcbiAgICBjb2RlLnB1c2goXCJyZXR1cm4gdGhpcy5kYXRhW1wiK2luZGV4X3N0citcIl09dn1cIilcbiAgfVxuICBcbiAgLy92aWV3LmdldChpMCwgLi4uKTpcbiAgY29kZS5wdXNoKFwicHJvdG8uZ2V0PWZ1bmN0aW9uIFwiK2NsYXNzTmFtZStcIl9nZXQoXCIrYXJncy5qb2luKFwiLFwiKStcIil7XCIpXG4gIGlmKHVzZUdldHRlcnMpIHtcbiAgICBjb2RlLnB1c2goXCJyZXR1cm4gdGhpcy5kYXRhLmdldChcIitpbmRleF9zdHIrXCIpfVwiKVxuICB9IGVsc2Uge1xuICAgIGNvZGUucHVzaChcInJldHVybiB0aGlzLmRhdGFbXCIraW5kZXhfc3RyK1wiXX1cIilcbiAgfVxuICBcbiAgLy92aWV3LmluZGV4OlxuICBjb2RlLnB1c2goXG4gICAgXCJwcm90by5pbmRleD1mdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfaW5kZXgoXCIsIGFyZ3Muam9pbigpLCBcIil7cmV0dXJuIFwiK2luZGV4X3N0citcIn1cIilcblxuICAvL3ZpZXcuaGkoKTpcbiAgY29kZS5wdXNoKFwicHJvdG8uaGk9ZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiX2hpKFwiK2FyZ3Muam9pbihcIixcIikrXCIpe3JldHVybiBuZXcgXCIrY2xhc3NOYW1lK1wiKHRoaXMuZGF0YSxcIitcbiAgICBpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gW1wiKHR5cGVvZiBpXCIsaSxcIiE9PSdudW1iZXInfHxpXCIsaSxcIjwwKT90aGlzLnNoYXBlW1wiLCBpLCBcIl06aVwiLCBpLFwifDBcIl0uam9pbihcIlwiKVxuICAgIH0pLmpvaW4oXCIsXCIpK1wiLFwiK1xuICAgIGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBcInRoaXMuc3RyaWRlW1wiK2kgKyBcIl1cIlxuICAgIH0pLmpvaW4oXCIsXCIpK1wiLHRoaXMub2Zmc2V0KX1cIilcbiAgXG4gIC8vdmlldy5sbygpOlxuICB2YXIgYV92YXJzID0gaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkgeyByZXR1cm4gXCJhXCIraStcIj10aGlzLnNoYXBlW1wiK2krXCJdXCIgfSlcbiAgdmFyIGNfdmFycyA9IGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHsgcmV0dXJuIFwiY1wiK2krXCI9dGhpcy5zdHJpZGVbXCIraStcIl1cIiB9KVxuICBjb2RlLnB1c2goXCJwcm90by5sbz1mdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfbG8oXCIrYXJncy5qb2luKFwiLFwiKStcIil7dmFyIGI9dGhpcy5vZmZzZXQsZD0wLFwiK2FfdmFycy5qb2luKFwiLFwiKStcIixcIitjX3ZhcnMuam9pbihcIixcIikpXG4gIGZvcih2YXIgaT0wOyBpPGRpbWVuc2lvbjsgKytpKSB7XG4gICAgY29kZS5wdXNoKFxuXCJpZih0eXBlb2YgaVwiK2krXCI9PT0nbnVtYmVyJyYmaVwiK2krXCI+PTApe1xcXG5kPWlcIitpK1wifDA7XFxcbmIrPWNcIitpK1wiKmQ7XFxcbmFcIitpK1wiLT1kfVwiKVxuICB9XG4gIGNvZGUucHVzaChcInJldHVybiBuZXcgXCIrY2xhc3NOYW1lK1wiKHRoaXMuZGF0YSxcIitcbiAgICBpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gXCJhXCIraVxuICAgIH0pLmpvaW4oXCIsXCIpK1wiLFwiK1xuICAgIGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBcImNcIitpXG4gICAgfSkuam9pbihcIixcIikrXCIsYil9XCIpXG4gIFxuICAvL3ZpZXcuc3RlcCgpOlxuICBjb2RlLnB1c2goXCJwcm90by5zdGVwPWZ1bmN0aW9uIFwiK2NsYXNzTmFtZStcIl9zdGVwKFwiK2FyZ3Muam9pbihcIixcIikrXCIpe3ZhciBcIitcbiAgICBpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gXCJhXCIraStcIj10aGlzLnNoYXBlW1wiK2krXCJdXCJcbiAgICB9KS5qb2luKFwiLFwiKStcIixcIitcbiAgICBpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gXCJiXCIraStcIj10aGlzLnN0cmlkZVtcIitpK1wiXVwiXG4gICAgfSkuam9pbihcIixcIikrXCIsYz10aGlzLm9mZnNldCxkPTAsY2VpbD1NYXRoLmNlaWxcIilcbiAgZm9yKHZhciBpPTA7IGk8ZGltZW5zaW9uOyArK2kpIHtcbiAgICBjb2RlLnB1c2goXG5cImlmKHR5cGVvZiBpXCIraStcIj09PSdudW1iZXInKXtcXFxuZD1pXCIraStcInwwO1xcXG5pZihkPDApe1xcXG5jKz1iXCIraStcIiooYVwiK2krXCItMSk7XFxcbmFcIitpK1wiPWNlaWwoLWFcIitpK1wiL2QpXFxcbn1lbHNle1xcXG5hXCIraStcIj1jZWlsKGFcIitpK1wiL2QpXFxcbn1cXFxuYlwiK2krXCIqPWRcXFxufVwiKVxuICB9XG4gIGNvZGUucHVzaChcInJldHVybiBuZXcgXCIrY2xhc3NOYW1lK1wiKHRoaXMuZGF0YSxcIitcbiAgICBpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gXCJhXCIgKyBpXG4gICAgfSkuam9pbihcIixcIikrXCIsXCIrXG4gICAgaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIFwiYlwiICsgaVxuICAgIH0pLmpvaW4oXCIsXCIpK1wiLGMpfVwiKVxuICBcbiAgLy92aWV3LnRyYW5zcG9zZSgpOlxuICB2YXIgdFNoYXBlID0gbmV3IEFycmF5KGRpbWVuc2lvbilcbiAgdmFyIHRTdHJpZGUgPSBuZXcgQXJyYXkoZGltZW5zaW9uKVxuICBmb3IodmFyIGk9MDsgaTxkaW1lbnNpb247ICsraSkge1xuICAgIHRTaGFwZVtpXSA9IFwiYVtpXCIraStcIl1cIlxuICAgIHRTdHJpZGVbaV0gPSBcImJbaVwiK2krXCJdXCJcbiAgfVxuICBjb2RlLnB1c2goXCJwcm90by50cmFuc3Bvc2U9ZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiX3RyYW5zcG9zZShcIithcmdzK1wiKXtcIitcbiAgICBhcmdzLm1hcChmdW5jdGlvbihuLGlkeCkgeyByZXR1cm4gbiArIFwiPShcIiArIG4gKyBcIj09PXVuZGVmaW5lZD9cIiArIGlkeCArIFwiOlwiICsgbiArIFwifDApXCJ9KS5qb2luKFwiO1wiKSxcbiAgICBcInZhciBhPXRoaXMuc2hhcGUsYj10aGlzLnN0cmlkZTtyZXR1cm4gbmV3IFwiK2NsYXNzTmFtZStcIih0aGlzLmRhdGEsXCIrdFNoYXBlLmpvaW4oXCIsXCIpK1wiLFwiK3RTdHJpZGUuam9pbihcIixcIikrXCIsdGhpcy5vZmZzZXQpfVwiKVxuICBcbiAgLy92aWV3LnBpY2soKTpcbiAgY29kZS5wdXNoKFwicHJvdG8ucGljaz1mdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfcGljayhcIithcmdzK1wiKXt2YXIgYT1bXSxiPVtdLGM9dGhpcy5vZmZzZXRcIilcbiAgZm9yKHZhciBpPTA7IGk8ZGltZW5zaW9uOyArK2kpIHtcbiAgICBjb2RlLnB1c2goXCJpZih0eXBlb2YgaVwiK2krXCI9PT0nbnVtYmVyJyYmaVwiK2krXCI+PTApe2M9KGMrdGhpcy5zdHJpZGVbXCIraStcIl0qaVwiK2krXCIpfDB9ZWxzZXthLnB1c2godGhpcy5zaGFwZVtcIitpK1wiXSk7Yi5wdXNoKHRoaXMuc3RyaWRlW1wiK2krXCJdKX1cIilcbiAgfVxuICBjb2RlLnB1c2goXCJ2YXIgY3Rvcj1DVE9SX0xJU1RbYS5sZW5ndGgrMV07cmV0dXJuIGN0b3IodGhpcy5kYXRhLGEsYixjKX1cIilcbiAgICBcbiAgLy9BZGQgcmV0dXJuIHN0YXRlbWVudFxuICBjb2RlLnB1c2goXCJyZXR1cm4gZnVuY3Rpb24gY29uc3RydWN0X1wiK2NsYXNzTmFtZStcIihkYXRhLHNoYXBlLHN0cmlkZSxvZmZzZXQpe3JldHVybiBuZXcgXCIrY2xhc3NOYW1lK1wiKGRhdGEsXCIrXG4gICAgaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIFwic2hhcGVbXCIraStcIl1cIlxuICAgIH0pLmpvaW4oXCIsXCIpK1wiLFwiK1xuICAgIGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBcInN0cmlkZVtcIitpK1wiXVwiXG4gICAgfSkuam9pbihcIixcIikrXCIsb2Zmc2V0KX1cIilcblxuICAvL0NvbXBpbGUgcHJvY2VkdXJlXG4gIHZhciBwcm9jZWR1cmUgPSBuZXcgRnVuY3Rpb24oXCJDVE9SX0xJU1RcIiwgXCJPUkRFUlwiLCBjb2RlLmpvaW4oXCJcXG5cIikpXG4gIHJldHVybiBwcm9jZWR1cmUoQ0FDSEVEX0NPTlNUUlVDVE9SU1tkdHlwZV0sIG9yZGVyKVxufVxuXG5mdW5jdGlvbiBhcnJheURUeXBlKGRhdGEpIHtcbiAgaWYoaGFzQnVmZmVyKSB7XG4gICAgaWYoQnVmZmVyLmlzQnVmZmVyKGRhdGEpKSB7XG4gICAgICByZXR1cm4gXCJidWZmZXJcIlxuICAgIH1cbiAgfVxuICBpZihoYXNUeXBlZEFycmF5cykge1xuICAgIHN3aXRjaChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZGF0YSkpIHtcbiAgICAgIGNhc2UgXCJbb2JqZWN0IEZsb2F0NjRBcnJheV1cIjpcbiAgICAgICAgcmV0dXJuIFwiZmxvYXQ2NFwiXG4gICAgICBjYXNlIFwiW29iamVjdCBGbG9hdDMyQXJyYXldXCI6XG4gICAgICAgIHJldHVybiBcImZsb2F0MzJcIlxuICAgICAgY2FzZSBcIltvYmplY3QgSW50OEFycmF5XVwiOlxuICAgICAgICByZXR1cm4gXCJpbnQ4XCJcbiAgICAgIGNhc2UgXCJbb2JqZWN0IEludDE2QXJyYXldXCI6XG4gICAgICAgIHJldHVybiBcImludDE2XCJcbiAgICAgIGNhc2UgXCJbb2JqZWN0IEludDMyQXJyYXldXCI6XG4gICAgICAgIHJldHVybiBcImludDMyXCJcbiAgICAgIGNhc2UgXCJbb2JqZWN0IFVpbnQ4QXJyYXldXCI6XG4gICAgICAgIHJldHVybiBcInVpbnQ4XCJcbiAgICAgIGNhc2UgXCJbb2JqZWN0IFVpbnQxNkFycmF5XVwiOlxuICAgICAgICByZXR1cm4gXCJ1aW50MTZcIlxuICAgICAgY2FzZSBcIltvYmplY3QgVWludDMyQXJyYXldXCI6XG4gICAgICAgIHJldHVybiBcInVpbnQzMlwiXG4gICAgICBjYXNlIFwiW29iamVjdCBVaW50OENsYW1wZWRBcnJheV1cIjpcbiAgICAgICAgcmV0dXJuIFwidWludDhfY2xhbXBlZFwiXG4gICAgfVxuICB9XG4gIGlmKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICByZXR1cm4gXCJhcnJheVwiXG4gIH1cbiAgcmV0dXJuIFwiZ2VuZXJpY1wiXG59XG5cbnZhciBDQUNIRURfQ09OU1RSVUNUT1JTID0ge1xuICBcImZsb2F0MzJcIjpbXSxcbiAgXCJmbG9hdDY0XCI6W10sXG4gIFwiaW50OFwiOltdLFxuICBcImludDE2XCI6W10sXG4gIFwiaW50MzJcIjpbXSxcbiAgXCJ1aW50OFwiOltdLFxuICBcInVpbnQxNlwiOltdLFxuICBcInVpbnQzMlwiOltdLFxuICBcImFycmF5XCI6W10sXG4gIFwidWludDhfY2xhbXBlZFwiOltdLFxuICBcImJ1ZmZlclwiOltdLFxuICBcImdlbmVyaWNcIjpbXVxufVxuXG47KGZ1bmN0aW9uKCkge1xuICBmb3IodmFyIGlkIGluIENBQ0hFRF9DT05TVFJVQ1RPUlMpIHtcbiAgICBDQUNIRURfQ09OU1RSVUNUT1JTW2lkXS5wdXNoKGNvbXBpbGVDb25zdHJ1Y3RvcihpZCwgLTEpKVxuICB9XG59KTtcblxuZnVuY3Rpb24gd3JhcHBlZE5EQXJyYXlDdG9yKGRhdGEsIHNoYXBlLCBzdHJpZGUsIG9mZnNldCkge1xuICBpZihkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgY3RvciA9IENBQ0hFRF9DT05TVFJVQ1RPUlMuYXJyYXlbMF1cbiAgICByZXR1cm4gY3RvcihbXSlcbiAgfSBlbHNlIGlmKHR5cGVvZiBkYXRhID09PSBcIm51bWJlclwiKSB7XG4gICAgZGF0YSA9IFtkYXRhXVxuICB9XG4gIGlmKHNoYXBlID09PSB1bmRlZmluZWQpIHtcbiAgICBzaGFwZSA9IFsgZGF0YS5sZW5ndGggXVxuICB9XG4gIHZhciBkID0gc2hhcGUubGVuZ3RoXG4gIGlmKHN0cmlkZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RyaWRlID0gbmV3IEFycmF5KGQpXG4gICAgZm9yKHZhciBpPWQtMSwgc3o9MTsgaT49MDsgLS1pKSB7XG4gICAgICBzdHJpZGVbaV0gPSBzelxuICAgICAgc3ogKj0gc2hhcGVbaV1cbiAgICB9XG4gIH1cbiAgaWYob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICBvZmZzZXQgPSAwXG4gICAgZm9yKHZhciBpPTA7IGk8ZDsgKytpKSB7XG4gICAgICBpZihzdHJpZGVbaV0gPCAwKSB7XG4gICAgICAgIG9mZnNldCAtPSAoc2hhcGVbaV0tMSkqc3RyaWRlW2ldXG4gICAgICB9XG4gICAgfVxuICB9XG4gIHZhciBkdHlwZSA9IGFycmF5RFR5cGUoZGF0YSlcbiAgdmFyIGN0b3JfbGlzdCA9IENBQ0hFRF9DT05TVFJVQ1RPUlNbZHR5cGVdXG4gIHdoaWxlKGN0b3JfbGlzdC5sZW5ndGggPD0gZCsxKSB7XG4gICAgY3Rvcl9saXN0LnB1c2goY29tcGlsZUNvbnN0cnVjdG9yKGR0eXBlLCBjdG9yX2xpc3QubGVuZ3RoLTEpKVxuICB9XG4gIHZhciBjdG9yID0gY3Rvcl9saXN0W2QrMV1cbiAgcmV0dXJuIGN0b3IoZGF0YSwgc2hhcGUsIHN0cmlkZSwgb2Zmc2V0KVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHdyYXBwZWROREFycmF5Q3RvclxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyKSIsIm1vZHVsZS5leHBvcnRzPXJlcXVpcmUoXCIvcHJvamVjdHMvYmxhY2tpY2Uvbm9kZV9tb2R1bGVzL2dsLXRleHR1cmUyZC9ub2RlX21vZHVsZXMvbmRhcnJheS9ub2RlX21vZHVsZXMvaW90YS1hcnJheS9pb3RhLmpzXCIpIiwibW9kdWxlLmV4cG9ydHM9cmVxdWlyZShcIi9wcm9qZWN0cy9ibGFja2ljZS9ub2RlX21vZHVsZXMvZ2wtdGV4dHVyZTJkL25vZGVfbW9kdWxlcy90eXBlZGFycmF5LXBvb2wvcG9vbC5qc1wiKSIsIi8vIENvcHlyaWdodCAoQykgMjAxMSBHb29nbGUgSW5jLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgSW5zdGFsbCBhIGxlYWt5IFdlYWtNYXAgZW11bGF0aW9uIG9uIHBsYXRmb3JtcyB0aGF0XG4gKiBkb24ndCBwcm92aWRlIGEgYnVpbHQtaW4gb25lLlxuICpcbiAqIDxwPkFzc3VtZXMgdGhhdCBhbiBFUzUgcGxhdGZvcm0gd2hlcmUsIGlmIHtAY29kZSBXZWFrTWFwfSBpc1xuICogYWxyZWFkeSBwcmVzZW50LCB0aGVuIGl0IGNvbmZvcm1zIHRvIHRoZSBhbnRpY2lwYXRlZCBFUzZcbiAqIHNwZWNpZmljYXRpb24uIFRvIHJ1biB0aGlzIGZpbGUgb24gYW4gRVM1IG9yIGFsbW9zdCBFUzVcbiAqIGltcGxlbWVudGF0aW9uIHdoZXJlIHRoZSB7QGNvZGUgV2Vha01hcH0gc3BlY2lmaWNhdGlvbiBkb2VzIG5vdFxuICogcXVpdGUgY29uZm9ybSwgcnVuIDxjb2RlPnJlcGFpckVTNS5qczwvY29kZT4gZmlyc3QuXG4gKlxuICogPHA+RXZlbiB0aG91Z2ggV2Vha01hcE1vZHVsZSBpcyBub3QgZ2xvYmFsLCB0aGUgbGludGVyIHRoaW5rcyBpdFxuICogaXMsIHdoaWNoIGlzIHdoeSBpdCBpcyBpbiB0aGUgb3ZlcnJpZGVzIGxpc3QgYmVsb3cuXG4gKlxuICogPHA+Tk9URTogQmVmb3JlIHVzaW5nIHRoaXMgV2Vha01hcCBlbXVsYXRpb24gaW4gYSBub24tU0VTXG4gKiBlbnZpcm9ubWVudCwgc2VlIHRoZSBub3RlIGJlbG93IGFib3V0IGhpZGRlblJlY29yZC5cbiAqXG4gKiBAYXV0aG9yIE1hcmsgUy4gTWlsbGVyXG4gKiBAcmVxdWlyZXMgY3J5cHRvLCBBcnJheUJ1ZmZlciwgVWludDhBcnJheSwgbmF2aWdhdG9yLCBjb25zb2xlXG4gKiBAb3ZlcnJpZGVzIFdlYWtNYXAsIHNlcywgUHJveHlcbiAqIEBvdmVycmlkZXMgV2Vha01hcE1vZHVsZVxuICovXG5cbi8qKlxuICogVGhpcyB7QGNvZGUgV2Vha01hcH0gZW11bGF0aW9uIGlzIG9ic2VydmFibHkgZXF1aXZhbGVudCB0byB0aGVcbiAqIEVTLUhhcm1vbnkgV2Vha01hcCwgYnV0IHdpdGggbGVha2llciBnYXJiYWdlIGNvbGxlY3Rpb24gcHJvcGVydGllcy5cbiAqXG4gKiA8cD5BcyB3aXRoIHRydWUgV2Vha01hcHMsIGluIHRoaXMgZW11bGF0aW9uLCBhIGtleSBkb2VzIG5vdFxuICogcmV0YWluIG1hcHMgaW5kZXhlZCBieSB0aGF0IGtleSBhbmQgKGNydWNpYWxseSkgYSBtYXAgZG9lcyBub3RcbiAqIHJldGFpbiB0aGUga2V5cyBpdCBpbmRleGVzLiBBIG1hcCBieSBpdHNlbGYgYWxzbyBkb2VzIG5vdCByZXRhaW5cbiAqIHRoZSB2YWx1ZXMgYXNzb2NpYXRlZCB3aXRoIHRoYXQgbWFwLlxuICpcbiAqIDxwPkhvd2V2ZXIsIHRoZSB2YWx1ZXMgYXNzb2NpYXRlZCB3aXRoIGEga2V5IGluIHNvbWUgbWFwIGFyZVxuICogcmV0YWluZWQgc28gbG9uZyBhcyB0aGF0IGtleSBpcyByZXRhaW5lZCBhbmQgdGhvc2UgYXNzb2NpYXRpb25zIGFyZVxuICogbm90IG92ZXJyaWRkZW4uIEZvciBleGFtcGxlLCB3aGVuIHVzZWQgdG8gc3VwcG9ydCBtZW1icmFuZXMsIGFsbFxuICogdmFsdWVzIGV4cG9ydGVkIGZyb20gYSBnaXZlbiBtZW1icmFuZSB3aWxsIGxpdmUgZm9yIHRoZSBsaWZldGltZVxuICogdGhleSB3b3VsZCBoYXZlIGhhZCBpbiB0aGUgYWJzZW5jZSBvZiBhbiBpbnRlcnBvc2VkIG1lbWJyYW5lLiBFdmVuXG4gKiB3aGVuIHRoZSBtZW1icmFuZSBpcyByZXZva2VkLCBhbGwgb2JqZWN0cyB0aGF0IHdvdWxkIGhhdmUgYmVlblxuICogcmVhY2hhYmxlIGluIHRoZSBhYnNlbmNlIG9mIHJldm9jYXRpb24gd2lsbCBzdGlsbCBiZSByZWFjaGFibGUsIGFzXG4gKiBmYXIgYXMgdGhlIEdDIGNhbiB0ZWxsLCBldmVuIHRob3VnaCB0aGV5IHdpbGwgbm8gbG9uZ2VyIGJlIHJlbGV2YW50XG4gKiB0byBvbmdvaW5nIGNvbXB1dGF0aW9uLlxuICpcbiAqIDxwPlRoZSBBUEkgaW1wbGVtZW50ZWQgaGVyZSBpcyBhcHByb3hpbWF0ZWx5IHRoZSBBUEkgYXMgaW1wbGVtZW50ZWRcbiAqIGluIEZGNi4wYTEgYW5kIGFncmVlZCB0byBieSBNYXJrTSwgQW5kcmVhcyBHYWwsIGFuZCBEYXZlIEhlcm1hbixcbiAqIHJhdGhlciB0aGFuIHRoZSBvZmZpYWxseSBhcHByb3ZlZCBwcm9wb3NhbCBwYWdlLiBUT0RPKGVyaWdodHMpOlxuICogdXBncmFkZSB0aGUgZWNtYXNjcmlwdCBXZWFrTWFwIHByb3Bvc2FsIHBhZ2UgdG8gZXhwbGFpbiB0aGlzIEFQSVxuICogY2hhbmdlIGFuZCBwcmVzZW50IHRvIEVjbWFTY3JpcHQgY29tbWl0dGVlIGZvciB0aGVpciBhcHByb3ZhbC5cbiAqXG4gKiA8cD5UaGUgZmlyc3QgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBlbXVsYXRpb24gaGVyZSBhbmQgdGhhdCBpblxuICogRkY2LjBhMSBpcyB0aGUgcHJlc2VuY2Ugb2Ygbm9uIGVudW1lcmFibGUge0Bjb2RlIGdldF9fXywgaGFzX19fLFxuICogc2V0X19fLCBhbmQgZGVsZXRlX19ffSBtZXRob2RzIG9uIFdlYWtNYXAgaW5zdGFuY2VzIHRvIHJlcHJlc2VudFxuICogd2hhdCB3b3VsZCBiZSB0aGUgaGlkZGVuIGludGVybmFsIHByb3BlcnRpZXMgb2YgYSBwcmltaXRpdmVcbiAqIGltcGxlbWVudGF0aW9uLiBXaGVyZWFzIHRoZSBGRjYuMGExIFdlYWtNYXAucHJvdG90eXBlIG1ldGhvZHNcbiAqIHJlcXVpcmUgdGhlaXIge0Bjb2RlIHRoaXN9IHRvIGJlIGEgZ2VudWluZSBXZWFrTWFwIGluc3RhbmNlIChpLmUuLFxuICogYW4gb2JqZWN0IG9mIHtAY29kZSBbW0NsYXNzXV19IFwiV2Vha01hcH0pLCBzaW5jZSB0aGVyZSBpcyBub3RoaW5nXG4gKiB1bmZvcmdlYWJsZSBhYm91dCB0aGUgcHNldWRvLWludGVybmFsIG1ldGhvZCBuYW1lcyB1c2VkIGhlcmUsXG4gKiBub3RoaW5nIHByZXZlbnRzIHRoZXNlIGVtdWxhdGVkIHByb3RvdHlwZSBtZXRob2RzIGZyb20gYmVpbmdcbiAqIGFwcGxpZWQgdG8gbm9uLVdlYWtNYXBzIHdpdGggcHNldWRvLWludGVybmFsIG1ldGhvZHMgb2YgdGhlIHNhbWVcbiAqIG5hbWVzLlxuICpcbiAqIDxwPkFub3RoZXIgZGlmZmVyZW5jZSBpcyB0aGF0IG91ciBlbXVsYXRlZCB7QGNvZGVcbiAqIFdlYWtNYXAucHJvdG90eXBlfSBpcyBub3QgaXRzZWxmIGEgV2Vha01hcC4gQSBwcm9ibGVtIHdpdGggdGhlXG4gKiBjdXJyZW50IEZGNi4wYTEgQVBJIGlzIHRoYXQgV2Vha01hcC5wcm90b3R5cGUgaXMgaXRzZWxmIGEgV2Vha01hcFxuICogcHJvdmlkaW5nIGFtYmllbnQgbXV0YWJpbGl0eSBhbmQgYW4gYW1iaWVudCBjb21tdW5pY2F0aW9uc1xuICogY2hhbm5lbC4gVGh1cywgaWYgYSBXZWFrTWFwIGlzIGFscmVhZHkgcHJlc2VudCBhbmQgaGFzIHRoaXNcbiAqIHByb2JsZW0sIHJlcGFpckVTNS5qcyB3cmFwcyBpdCBpbiBhIHNhZmUgd3JhcHBwZXIgaW4gb3JkZXIgdG9cbiAqIHByZXZlbnQgYWNjZXNzIHRvIHRoaXMgY2hhbm5lbC4gKFNlZVxuICogUEFUQ0hfTVVUQUJMRV9GUk9aRU5fV0VBS01BUF9QUk9UTyBpbiByZXBhaXJFUzUuanMpLlxuICovXG5cbi8qKlxuICogSWYgdGhpcyBpcyBhIGZ1bGwgPGEgaHJlZj1cbiAqIFwiaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2VzLWxhYi93aWtpL1NlY3VyZWFibGVFUzVcIlxuICogPnNlY3VyZWFibGUgRVM1PC9hPiBwbGF0Zm9ybSBhbmQgdGhlIEVTLUhhcm1vbnkge0Bjb2RlIFdlYWtNYXB9IGlzXG4gKiBhYnNlbnQsIGluc3RhbGwgYW4gYXBwcm94aW1hdGUgZW11bGF0aW9uLlxuICpcbiAqIDxwPklmIFdlYWtNYXAgaXMgcHJlc2VudCBidXQgY2Fubm90IHN0b3JlIHNvbWUgb2JqZWN0cywgdXNlIG91ciBhcHByb3hpbWF0ZVxuICogZW11bGF0aW9uIGFzIGEgd3JhcHBlci5cbiAqXG4gKiA8cD5JZiB0aGlzIGlzIGFsbW9zdCBhIHNlY3VyZWFibGUgRVM1IHBsYXRmb3JtLCB0aGVuIFdlYWtNYXAuanNcbiAqIHNob3VsZCBiZSBydW4gYWZ0ZXIgcmVwYWlyRVM1LmpzLlxuICpcbiAqIDxwPlNlZSB7QGNvZGUgV2Vha01hcH0gZm9yIGRvY3VtZW50YXRpb24gb2YgdGhlIGdhcmJhZ2UgY29sbGVjdGlvblxuICogcHJvcGVydGllcyBvZiB0aGlzIFdlYWtNYXAgZW11bGF0aW9uLlxuICovXG4oZnVuY3Rpb24gV2Vha01hcE1vZHVsZSgpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgaWYgKHR5cGVvZiBzZXMgIT09ICd1bmRlZmluZWQnICYmIHNlcy5vayAmJiAhc2VzLm9rKCkpIHtcbiAgICAvLyBhbHJlYWR5IHRvbyBicm9rZW4sIHNvIGdpdmUgdXBcbiAgICByZXR1cm47XG4gIH1cblxuICAvKipcbiAgICogSW4gc29tZSBjYXNlcyAoY3VycmVudCBGaXJlZm94KSwgd2UgbXVzdCBtYWtlIGEgY2hvaWNlIGJldHdlZWVuIGFcbiAgICogV2Vha01hcCB3aGljaCBpcyBjYXBhYmxlIG9mIHVzaW5nIGFsbCB2YXJpZXRpZXMgb2YgaG9zdCBvYmplY3RzIGFzXG4gICAqIGtleXMgYW5kIG9uZSB3aGljaCBpcyBjYXBhYmxlIG9mIHNhZmVseSB1c2luZyBwcm94aWVzIGFzIGtleXMuIFNlZVxuICAgKiBjb21tZW50cyBiZWxvdyBhYm91dCBIb3N0V2Vha01hcCBhbmQgRG91YmxlV2Vha01hcCBmb3IgZGV0YWlscy5cbiAgICpcbiAgICogVGhpcyBmdW5jdGlvbiAod2hpY2ggaXMgYSBnbG9iYWwsIG5vdCBleHBvc2VkIHRvIGd1ZXN0cykgbWFya3MgYVxuICAgKiBXZWFrTWFwIGFzIHBlcm1pdHRlZCB0byBkbyB3aGF0IGlzIG5lY2Vzc2FyeSB0byBpbmRleCBhbGwgaG9zdFxuICAgKiBvYmplY3RzLCBhdCB0aGUgY29zdCBvZiBtYWtpbmcgaXQgdW5zYWZlIGZvciBwcm94aWVzLlxuICAgKlxuICAgKiBEbyBub3QgYXBwbHkgdGhpcyBmdW5jdGlvbiB0byBhbnl0aGluZyB3aGljaCBpcyBub3QgYSBnZW51aW5lXG4gICAqIGZyZXNoIFdlYWtNYXAuXG4gICAqL1xuICBmdW5jdGlvbiB3ZWFrTWFwUGVybWl0SG9zdE9iamVjdHMobWFwKSB7XG4gICAgLy8gaWRlbnRpdHkgb2YgZnVuY3Rpb24gdXNlZCBhcyBhIHNlY3JldCAtLSBnb29kIGVub3VnaCBhbmQgY2hlYXBcbiAgICBpZiAobWFwLnBlcm1pdEhvc3RPYmplY3RzX19fKSB7XG4gICAgICBtYXAucGVybWl0SG9zdE9iamVjdHNfX18od2Vha01hcFBlcm1pdEhvc3RPYmplY3RzKTtcbiAgICB9XG4gIH1cbiAgaWYgKHR5cGVvZiBzZXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgc2VzLndlYWtNYXBQZXJtaXRIb3N0T2JqZWN0cyA9IHdlYWtNYXBQZXJtaXRIb3N0T2JqZWN0cztcbiAgfVxuXG4gIC8vIElFIDExIGhhcyBubyBQcm94eSBidXQgaGFzIGEgYnJva2VuIFdlYWtNYXAgc3VjaCB0aGF0IHdlIG5lZWQgdG8gcGF0Y2hcbiAgLy8gaXQgdXNpbmcgRG91YmxlV2Vha01hcDsgdGhpcyBmbGFnIHRlbGxzIERvdWJsZVdlYWtNYXAgc28uXG4gIHZhciBkb3VibGVXZWFrTWFwQ2hlY2tTaWxlbnRGYWlsdXJlID0gZmFsc2U7XG5cbiAgLy8gQ2hlY2sgaWYgdGhlcmUgaXMgYWxyZWFkeSBhIGdvb2QtZW5vdWdoIFdlYWtNYXAgaW1wbGVtZW50YXRpb24sIGFuZCBpZiBzb1xuICAvLyBleGl0IHdpdGhvdXQgcmVwbGFjaW5nIGl0LlxuICBpZiAodHlwZW9mIFdlYWtNYXAgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgSG9zdFdlYWtNYXAgPSBXZWFrTWFwO1xuICAgIC8vIFRoZXJlIGlzIGEgV2Vha01hcCAtLSBpcyBpdCBnb29kIGVub3VnaD9cbiAgICBpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgL0ZpcmVmb3gvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkpIHtcbiAgICAgIC8vIFdlJ3JlIG5vdyAqYXNzdW1pbmcgbm90KiwgYmVjYXVzZSBhcyBvZiB0aGlzIHdyaXRpbmcgKDIwMTMtMDUtMDYpXG4gICAgICAvLyBGaXJlZm94J3MgV2Vha01hcHMgaGF2ZSBhIG1pc2NlbGxhbnkgb2Ygb2JqZWN0cyB0aGV5IHdvbid0IGFjY2VwdCwgYW5kXG4gICAgICAvLyB3ZSBkb24ndCB3YW50IHRvIG1ha2UgYW4gZXhoYXVzdGl2ZSBsaXN0LCBhbmQgdGVzdGluZyBmb3IganVzdCBvbmVcbiAgICAgIC8vIHdpbGwgYmUgYSBwcm9ibGVtIGlmIHRoYXQgb25lIGlzIGZpeGVkIGFsb25lIChhcyB0aGV5IGRpZCBmb3IgRXZlbnQpLlxuXG4gICAgICAvLyBJZiB0aGVyZSBpcyBhIHBsYXRmb3JtIHRoYXQgd2UgKmNhbiogcmVsaWFibHkgdGVzdCBvbiwgaGVyZSdzIGhvdyB0b1xuICAgICAgLy8gZG8gaXQ6XG4gICAgICAvLyAgdmFyIHByb2JsZW1hdGljID0gLi4uIDtcbiAgICAgIC8vICB2YXIgdGVzdEhvc3RNYXAgPSBuZXcgSG9zdFdlYWtNYXAoKTtcbiAgICAgIC8vICB0cnkge1xuICAgICAgLy8gICAgdGVzdEhvc3RNYXAuc2V0KHByb2JsZW1hdGljLCAxKTsgIC8vIEZpcmVmb3ggMjAgd2lsbCB0aHJvdyBoZXJlXG4gICAgICAvLyAgICBpZiAodGVzdEhvc3RNYXAuZ2V0KHByb2JsZW1hdGljKSA9PT0gMSkge1xuICAgICAgLy8gICAgICByZXR1cm47XG4gICAgICAvLyAgICB9XG4gICAgICAvLyAgfSBjYXRjaCAoZSkge31cblxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJRSAxMSBidWc6IFdlYWtNYXBzIHNpbGVudGx5IGZhaWwgdG8gc3RvcmUgZnJvemVuIG9iamVjdHMuXG4gICAgICB2YXIgdGVzdE1hcCA9IG5ldyBIb3N0V2Vha01hcCgpO1xuICAgICAgdmFyIHRlc3RPYmplY3QgPSBPYmplY3QuZnJlZXplKHt9KTtcbiAgICAgIHRlc3RNYXAuc2V0KHRlc3RPYmplY3QsIDEpO1xuICAgICAgaWYgKHRlc3RNYXAuZ2V0KHRlc3RPYmplY3QpICE9PSAxKSB7XG4gICAgICAgIGRvdWJsZVdlYWtNYXBDaGVja1NpbGVudEZhaWx1cmUgPSB0cnVlO1xuICAgICAgICAvLyBGYWxsIHRocm91Z2ggdG8gaW5zdGFsbGluZyBvdXIgV2Vha01hcC5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gV2Vha01hcDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBob3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuICB2YXIgZ29wbiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xuICB2YXIgZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbiAgdmFyIGlzRXh0ZW5zaWJsZSA9IE9iamVjdC5pc0V4dGVuc2libGU7XG5cbiAgLyoqXG4gICAqIFNlY3VyaXR5IGRlcGVuZHMgb24gSElEREVOX05BTUUgYmVpbmcgYm90aCA8aT51bmd1ZXNzYWJsZTwvaT4gYW5kXG4gICAqIDxpPnVuZGlzY292ZXJhYmxlPC9pPiBieSB1bnRydXN0ZWQgY29kZS5cbiAgICpcbiAgICogPHA+R2l2ZW4gdGhlIGtub3duIHdlYWtuZXNzZXMgb2YgTWF0aC5yYW5kb20oKSBvbiBleGlzdGluZ1xuICAgKiBicm93c2VycywgaXQgZG9lcyBub3QgZ2VuZXJhdGUgdW5ndWVzc2FiaWxpdHkgd2UgY2FuIGJlIGNvbmZpZGVudFxuICAgKiBvZi5cbiAgICpcbiAgICogPHA+SXQgaXMgdGhlIG1vbmtleSBwYXRjaGluZyBsb2dpYyBpbiB0aGlzIGZpbGUgdGhhdCBpcyBpbnRlbmRlZFxuICAgKiB0byBlbnN1cmUgdW5kaXNjb3ZlcmFiaWxpdHkuIFRoZSBiYXNpYyBpZGVhIGlzIHRoYXQgdGhlcmUgYXJlXG4gICAqIHRocmVlIGZ1bmRhbWVudGFsIG1lYW5zIG9mIGRpc2NvdmVyaW5nIHByb3BlcnRpZXMgb2YgYW4gb2JqZWN0OlxuICAgKiBUaGUgZm9yL2luIGxvb3AsIE9iamVjdC5rZXlzKCksIGFuZCBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcygpLFxuICAgKiBhcyB3ZWxsIGFzIHNvbWUgcHJvcG9zZWQgRVM2IGV4dGVuc2lvbnMgdGhhdCBhcHBlYXIgb24gb3VyXG4gICAqIHdoaXRlbGlzdC4gVGhlIGZpcnN0IHR3byBvbmx5IGRpc2NvdmVyIGVudW1lcmFibGUgcHJvcGVydGllcywgYW5kXG4gICAqIHdlIG9ubHkgdXNlIEhJRERFTl9OQU1FIHRvIG5hbWUgYSBub24tZW51bWVyYWJsZSBwcm9wZXJ0eSwgc28gdGhlXG4gICAqIG9ubHkgcmVtYWluaW5nIHRocmVhdCBzaG91bGQgYmUgZ2V0T3duUHJvcGVydHlOYW1lcyBhbmQgc29tZVxuICAgKiBwcm9wb3NlZCBFUzYgZXh0ZW5zaW9ucyB0aGF0IGFwcGVhciBvbiBvdXIgd2hpdGVsaXN0LiBXZSBtb25rZXlcbiAgICogcGF0Y2ggdGhlbSB0byByZW1vdmUgSElEREVOX05BTUUgZnJvbSB0aGUgbGlzdCBvZiBwcm9wZXJ0aWVzIHRoZXlcbiAgICogcmV0dXJucy5cbiAgICpcbiAgICogPHA+VE9ETyhlcmlnaHRzKTogT24gYSBwbGF0Zm9ybSB3aXRoIGJ1aWx0LWluIFByb3hpZXMsIHByb3hpZXNcbiAgICogY291bGQgYmUgdXNlZCB0byB0cmFwIGFuZCB0aGVyZWJ5IGRpc2NvdmVyIHRoZSBISURERU5fTkFNRSwgc28gd2VcbiAgICogbmVlZCB0byBtb25rZXkgcGF0Y2ggUHJveHkuY3JlYXRlLCBQcm94eS5jcmVhdGVGdW5jdGlvbiwgZXRjLCBpblxuICAgKiBvcmRlciB0byB3cmFwIHRoZSBwcm92aWRlZCBoYW5kbGVyIHdpdGggdGhlIHJlYWwgaGFuZGxlciB3aGljaFxuICAgKiBmaWx0ZXJzIG91dCBhbGwgdHJhcHMgdXNpbmcgSElEREVOX05BTUUuXG4gICAqXG4gICAqIDxwPlRPRE8oZXJpZ2h0cyk6IFJldmlzaXQgTWlrZSBTdGF5J3Mgc3VnZ2VzdGlvbiB0aGF0IHdlIHVzZSBhblxuICAgKiBlbmNhcHN1bGF0ZWQgZnVuY3Rpb24gYXQgYSBub3QtbmVjZXNzYXJpbHktc2VjcmV0IG5hbWUsIHdoaWNoXG4gICAqIHVzZXMgdGhlIFN0aWVnbGVyIHNoYXJlZC1zdGF0ZSByaWdodHMgYW1wbGlmaWNhdGlvbiBwYXR0ZXJuIHRvXG4gICAqIHJldmVhbCB0aGUgYXNzb2NpYXRlZCB2YWx1ZSBvbmx5IHRvIHRoZSBXZWFrTWFwIGluIHdoaWNoIHRoaXMga2V5XG4gICAqIGlzIGFzc29jaWF0ZWQgd2l0aCB0aGF0IHZhbHVlLiBTaW5jZSBvbmx5IHRoZSBrZXkgcmV0YWlucyB0aGVcbiAgICogZnVuY3Rpb24sIHRoZSBmdW5jdGlvbiBjYW4gYWxzbyByZW1lbWJlciB0aGUga2V5IHdpdGhvdXQgY2F1c2luZ1xuICAgKiBsZWFrYWdlIG9mIHRoZSBrZXksIHNvIHRoaXMgZG9lc24ndCB2aW9sYXRlIG91ciBnZW5lcmFsIGdjXG4gICAqIGdvYWxzLiBJbiBhZGRpdGlvbiwgYmVjYXVzZSB0aGUgbmFtZSBuZWVkIG5vdCBiZSBhIGd1YXJkZWRcbiAgICogc2VjcmV0LCB3ZSBjb3VsZCBlZmZpY2llbnRseSBoYW5kbGUgY3Jvc3MtZnJhbWUgZnJvemVuIGtleXMuXG4gICAqL1xuICB2YXIgSElEREVOX05BTUVfUFJFRklYID0gJ3dlYWttYXA6JztcbiAgdmFyIEhJRERFTl9OQU1FID0gSElEREVOX05BTUVfUFJFRklYICsgJ2lkZW50OicgKyBNYXRoLnJhbmRvbSgpICsgJ19fXyc7XG5cbiAgaWYgKHR5cGVvZiBjcnlwdG8gIT09ICd1bmRlZmluZWQnICYmXG4gICAgICB0eXBlb2YgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgdHlwZW9mIEFycmF5QnVmZmVyID09PSAnZnVuY3Rpb24nICYmXG4gICAgICB0eXBlb2YgVWludDhBcnJheSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBhYiA9IG5ldyBBcnJheUJ1ZmZlcigyNSk7XG4gICAgdmFyIHU4cyA9IG5ldyBVaW50OEFycmF5KGFiKTtcbiAgICBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKHU4cyk7XG4gICAgSElEREVOX05BTUUgPSBISURERU5fTkFNRV9QUkVGSVggKyAncmFuZDonICtcbiAgICAgIEFycmF5LnByb3RvdHlwZS5tYXAuY2FsbCh1OHMsIGZ1bmN0aW9uKHU4KSB7XG4gICAgICAgIHJldHVybiAodTggJSAzNikudG9TdHJpbmcoMzYpO1xuICAgICAgfSkuam9pbignJykgKyAnX19fJztcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzTm90SGlkZGVuTmFtZShuYW1lKSB7XG4gICAgcmV0dXJuICEoXG4gICAgICAgIG5hbWUuc3Vic3RyKDAsIEhJRERFTl9OQU1FX1BSRUZJWC5sZW5ndGgpID09IEhJRERFTl9OQU1FX1BSRUZJWCAmJlxuICAgICAgICBuYW1lLnN1YnN0cihuYW1lLmxlbmd0aCAtIDMpID09PSAnX19fJyk7XG4gIH1cblxuICAvKipcbiAgICogTW9ua2V5IHBhdGNoIGdldE93blByb3BlcnR5TmFtZXMgdG8gYXZvaWQgcmV2ZWFsaW5nIHRoZVxuICAgKiBISURERU5fTkFNRS5cbiAgICpcbiAgICogPHA+VGhlIEVTNS4xIHNwZWMgcmVxdWlyZXMgZWFjaCBuYW1lIHRvIGFwcGVhciBvbmx5IG9uY2UsIGJ1dCBhc1xuICAgKiBvZiB0aGlzIHdyaXRpbmcsIHRoaXMgcmVxdWlyZW1lbnQgaXMgY29udHJvdmVyc2lhbCBmb3IgRVM2LCBzbyB3ZVxuICAgKiBtYWRlIHRoaXMgY29kZSByb2J1c3QgYWdhaW5zdCB0aGlzIGNhc2UuIElmIHRoZSByZXN1bHRpbmcgZXh0cmFcbiAgICogc2VhcmNoIHR1cm5zIG91dCB0byBiZSBleHBlbnNpdmUsIHdlIGNhbiBwcm9iYWJseSByZWxheCB0aGlzIG9uY2VcbiAgICogRVM2IGlzIGFkZXF1YXRlbHkgc3VwcG9ydGVkIG9uIGFsbCBtYWpvciBicm93c2VycywgaWZmIG5vIGJyb3dzZXJcbiAgICogdmVyc2lvbnMgd2Ugc3VwcG9ydCBhdCB0aGF0IHRpbWUgaGF2ZSByZWxheGVkIHRoaXMgY29uc3RyYWludFxuICAgKiB3aXRob3V0IHByb3ZpZGluZyBidWlsdC1pbiBFUzYgV2Vha01hcHMuXG4gICAqL1xuICBkZWZQcm9wKE9iamVjdCwgJ2dldE93blByb3BlcnR5TmFtZXMnLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZha2VHZXRPd25Qcm9wZXJ0eU5hbWVzKG9iaikge1xuICAgICAgcmV0dXJuIGdvcG4ob2JqKS5maWx0ZXIoaXNOb3RIaWRkZW5OYW1lKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBnZXRQcm9wZXJ0eU5hbWVzIGlzIG5vdCBpbiBFUzUgYnV0IGl0IGlzIHByb3Bvc2VkIGZvciBFUzYgYW5kXG4gICAqIGRvZXMgYXBwZWFyIGluIG91ciB3aGl0ZWxpc3QsIHNvIHdlIG5lZWQgdG8gY2xlYW4gaXQgdG9vLlxuICAgKi9cbiAgaWYgKCdnZXRQcm9wZXJ0eU5hbWVzJyBpbiBPYmplY3QpIHtcbiAgICB2YXIgb3JpZ2luYWxHZXRQcm9wZXJ0eU5hbWVzID0gT2JqZWN0LmdldFByb3BlcnR5TmFtZXM7XG4gICAgZGVmUHJvcChPYmplY3QsICdnZXRQcm9wZXJ0eU5hbWVzJywge1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZha2VHZXRQcm9wZXJ0eU5hbWVzKG9iaikge1xuICAgICAgICByZXR1cm4gb3JpZ2luYWxHZXRQcm9wZXJ0eU5hbWVzKG9iaikuZmlsdGVyKGlzTm90SGlkZGVuTmFtZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogPHA+VG8gdHJlYXQgb2JqZWN0cyBhcyBpZGVudGl0eS1rZXlzIHdpdGggcmVhc29uYWJsZSBlZmZpY2llbmN5XG4gICAqIG9uIEVTNSBieSBpdHNlbGYgKGkuZS4sIHdpdGhvdXQgYW55IG9iamVjdC1rZXllZCBjb2xsZWN0aW9ucyksIHdlXG4gICAqIG5lZWQgdG8gYWRkIGEgaGlkZGVuIHByb3BlcnR5IHRvIHN1Y2gga2V5IG9iamVjdHMgd2hlbiB3ZVxuICAgKiBjYW4uIFRoaXMgcmFpc2VzIHNldmVyYWwgaXNzdWVzOlxuICAgKiA8dWw+XG4gICAqIDxsaT5BcnJhbmdpbmcgdG8gYWRkIHRoaXMgcHJvcGVydHkgdG8gb2JqZWN0cyBiZWZvcmUgd2UgbG9zZSB0aGVcbiAgICogICAgIGNoYW5jZSwgYW5kXG4gICAqIDxsaT5IaWRpbmcgdGhlIGV4aXN0ZW5jZSBvZiB0aGlzIG5ldyBwcm9wZXJ0eSBmcm9tIG1vc3RcbiAgICogICAgIEphdmFTY3JpcHQgY29kZS5cbiAgICogPGxpPlByZXZlbnRpbmcgPGk+Y2VydGlmaWNhdGlvbiB0aGVmdDwvaT4sIHdoZXJlIG9uZSBvYmplY3QgaXNcbiAgICogICAgIGNyZWF0ZWQgZmFsc2VseSBjbGFpbWluZyB0byBiZSB0aGUga2V5IG9mIGFuIGFzc29jaWF0aW9uXG4gICAqICAgICBhY3R1YWxseSBrZXllZCBieSBhbm90aGVyIG9iamVjdC5cbiAgICogPGxpPlByZXZlbnRpbmcgPGk+dmFsdWUgdGhlZnQ8L2k+LCB3aGVyZSB1bnRydXN0ZWQgY29kZSB3aXRoXG4gICAqICAgICBhY2Nlc3MgdG8gYSBrZXkgb2JqZWN0IGJ1dCBub3QgYSB3ZWFrIG1hcCBuZXZlcnRoZWxlc3NcbiAgICogICAgIG9idGFpbnMgYWNjZXNzIHRvIHRoZSB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggdGhhdCBrZXkgaW4gdGhhdFxuICAgKiAgICAgd2VhayBtYXAuXG4gICAqIDwvdWw+XG4gICAqIFdlIGRvIHNvIGJ5XG4gICAqIDx1bD5cbiAgICogPGxpPk1ha2luZyB0aGUgbmFtZSBvZiB0aGUgaGlkZGVuIHByb3BlcnR5IHVuZ3Vlc3NhYmxlLCBzbyBcIltdXCJcbiAgICogICAgIGluZGV4aW5nLCB3aGljaCB3ZSBjYW5ub3QgaW50ZXJjZXB0LCBjYW5ub3QgYmUgdXNlZCB0byBhY2Nlc3NcbiAgICogICAgIGEgcHJvcGVydHkgd2l0aG91dCBrbm93aW5nIHRoZSBuYW1lLlxuICAgKiA8bGk+TWFraW5nIHRoZSBoaWRkZW4gcHJvcGVydHkgbm9uLWVudW1lcmFibGUsIHNvIHdlIG5lZWQgbm90XG4gICAqICAgICB3b3JyeSBhYm91dCBmb3ItaW4gbG9vcHMgb3Ige0Bjb2RlIE9iamVjdC5rZXlzfSxcbiAgICogPGxpPm1vbmtleSBwYXRjaGluZyB0aG9zZSByZWZsZWN0aXZlIG1ldGhvZHMgdGhhdCB3b3VsZFxuICAgKiAgICAgcHJldmVudCBleHRlbnNpb25zLCB0byBhZGQgdGhpcyBoaWRkZW4gcHJvcGVydHkgZmlyc3QsXG4gICAqIDxsaT5tb25rZXkgcGF0Y2hpbmcgdGhvc2UgbWV0aG9kcyB0aGF0IHdvdWxkIHJldmVhbCB0aGlzXG4gICAqICAgICBoaWRkZW4gcHJvcGVydHkuXG4gICAqIDwvdWw+XG4gICAqIFVuZm9ydHVuYXRlbHksIGJlY2F1c2Ugb2Ygc2FtZS1vcmlnaW4gaWZyYW1lcywgd2UgY2Fubm90IHJlbGlhYmx5XG4gICAqIGFkZCB0aGlzIGhpZGRlbiBwcm9wZXJ0eSBiZWZvcmUgYW4gb2JqZWN0IGJlY29tZXNcbiAgICogbm9uLWV4dGVuc2libGUuIEluc3RlYWQsIGlmIHdlIGVuY291bnRlciBhIG5vbi1leHRlbnNpYmxlIG9iamVjdFxuICAgKiB3aXRob3V0IGEgaGlkZGVuIHJlY29yZCB0aGF0IHdlIGNhbiBkZXRlY3QgKHdoZXRoZXIgb3Igbm90IGl0IGhhc1xuICAgKiBhIGhpZGRlbiByZWNvcmQgc3RvcmVkIHVuZGVyIGEgbmFtZSBzZWNyZXQgdG8gdXMpLCB0aGVuIHdlIGp1c3RcbiAgICogdXNlIHRoZSBrZXkgb2JqZWN0IGl0c2VsZiB0byByZXByZXNlbnQgaXRzIGlkZW50aXR5IGluIGEgYnJ1dGVcbiAgICogZm9yY2UgbGVha3kgbWFwIHN0b3JlZCBpbiB0aGUgd2VhayBtYXAsIGxvc2luZyBhbGwgdGhlIGFkdmFudGFnZXNcbiAgICogb2Ygd2Vha25lc3MgZm9yIHRoZXNlLlxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0SGlkZGVuUmVjb3JkKGtleSkge1xuICAgIGlmIChrZXkgIT09IE9iamVjdChrZXkpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdOb3QgYW4gb2JqZWN0OiAnICsga2V5KTtcbiAgICB9XG4gICAgdmFyIGhpZGRlblJlY29yZCA9IGtleVtISURERU5fTkFNRV07XG4gICAgaWYgKGhpZGRlblJlY29yZCAmJiBoaWRkZW5SZWNvcmQua2V5ID09PSBrZXkpIHsgcmV0dXJuIGhpZGRlblJlY29yZDsgfVxuICAgIGlmICghaXNFeHRlbnNpYmxlKGtleSkpIHtcbiAgICAgIC8vIFdlYWsgbWFwIG11c3QgYnJ1dGUgZm9yY2UsIGFzIGV4cGxhaW5lZCBpbiBkb2MtY29tbWVudCBhYm92ZS5cbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuXG4gICAgLy8gVGhlIGhpZGRlblJlY29yZCBhbmQgdGhlIGtleSBwb2ludCBkaXJlY3RseSBhdCBlYWNoIG90aGVyLCB2aWFcbiAgICAvLyB0aGUgXCJrZXlcIiBhbmQgSElEREVOX05BTUUgcHJvcGVydGllcyByZXNwZWN0aXZlbHkuIFRoZSBrZXlcbiAgICAvLyBmaWVsZCBpcyBmb3IgcXVpY2tseSB2ZXJpZnlpbmcgdGhhdCB0aGlzIGhpZGRlbiByZWNvcmQgaXMgYW5cbiAgICAvLyBvd24gcHJvcGVydHksIG5vdCBhIGhpZGRlbiByZWNvcmQgZnJvbSB1cCB0aGUgcHJvdG90eXBlIGNoYWluLlxuICAgIC8vXG4gICAgLy8gTk9URTogQmVjYXVzZSB0aGlzIFdlYWtNYXAgZW11bGF0aW9uIGlzIG1lYW50IG9ubHkgZm9yIHN5c3RlbXMgbGlrZVxuICAgIC8vIFNFUyB3aGVyZSBPYmplY3QucHJvdG90eXBlIGlzIGZyb3plbiB3aXRob3V0IGFueSBudW1lcmljXG4gICAgLy8gcHJvcGVydGllcywgaXQgaXMgb2sgdG8gdXNlIGFuIG9iamVjdCBsaXRlcmFsIGZvciB0aGUgaGlkZGVuUmVjb3JkLlxuICAgIC8vIFRoaXMgaGFzIHR3byBhZHZhbnRhZ2VzOlxuICAgIC8vICogSXQgaXMgbXVjaCBmYXN0ZXIgaW4gYSBwZXJmb3JtYW5jZSBjcml0aWNhbCBwbGFjZVxuICAgIC8vICogSXQgYXZvaWRzIHJlbHlpbmcgb24gT2JqZWN0LmNyZWF0ZShudWxsKSwgd2hpY2ggaGFkIGJlZW5cbiAgICAvLyAgIHByb2JsZW1hdGljIG9uIENocm9tZSAyOC4wLjE0ODAuMC4gU2VlXG4gICAgLy8gICBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2dvb2dsZS1jYWphL2lzc3Vlcy9kZXRhaWw/aWQ9MTY4N1xuICAgIGhpZGRlblJlY29yZCA9IHsga2V5OiBrZXkgfTtcblxuICAgIC8vIFdoZW4gdXNpbmcgdGhpcyBXZWFrTWFwIGVtdWxhdGlvbiBvbiBwbGF0Zm9ybXMgd2hlcmVcbiAgICAvLyBPYmplY3QucHJvdG90eXBlIG1pZ2h0IG5vdCBiZSBmcm96ZW4gYW5kIE9iamVjdC5jcmVhdGUobnVsbCkgaXNcbiAgICAvLyByZWxpYWJsZSwgdXNlIHRoZSBmb2xsb3dpbmcgdHdvIGNvbW1lbnRlZCBvdXQgbGluZXMgaW5zdGVhZC5cbiAgICAvLyBoaWRkZW5SZWNvcmQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIC8vIGhpZGRlblJlY29yZC5rZXkgPSBrZXk7XG5cbiAgICAvLyBQbGVhc2UgY29udGFjdCB1cyBpZiB5b3UgbmVlZCB0aGlzIHRvIHdvcmsgb24gcGxhdGZvcm1zIHdoZXJlXG4gICAgLy8gT2JqZWN0LnByb3RvdHlwZSBtaWdodCBub3QgYmUgZnJvemVuIGFuZFxuICAgIC8vIE9iamVjdC5jcmVhdGUobnVsbCkgbWlnaHQgbm90IGJlIHJlbGlhYmxlLlxuXG4gICAgdHJ5IHtcbiAgICAgIGRlZlByb3Aoa2V5LCBISURERU5fTkFNRSwge1xuICAgICAgICB2YWx1ZTogaGlkZGVuUmVjb3JkLFxuICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBoaWRkZW5SZWNvcmQ7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIFVuZGVyIHNvbWUgY2lyY3Vtc3RhbmNlcywgaXNFeHRlbnNpYmxlIHNlZW1zIHRvIG1pc3JlcG9ydCB3aGV0aGVyXG4gICAgICAvLyB0aGUgSElEREVOX05BTUUgY2FuIGJlIGRlZmluZWQuXG4gICAgICAvLyBUaGUgY2lyY3Vtc3RhbmNlcyBoYXZlIG5vdCBiZWVuIGlzb2xhdGVkLCBidXQgYXQgbGVhc3QgYWZmZWN0XG4gICAgICAvLyBOb2RlLmpzIHYwLjEwLjI2IG9uIFRyYXZpc0NJIC8gTGludXgsIGJ1dCBub3QgdGhlIHNhbWUgdmVyc2lvbiBvZlxuICAgICAgLy8gTm9kZS5qcyBvbiBPUyBYLlxuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTW9ua2V5IHBhdGNoIG9wZXJhdGlvbnMgdGhhdCB3b3VsZCBtYWtlIHRoZWlyIGFyZ3VtZW50XG4gICAqIG5vbi1leHRlbnNpYmxlLlxuICAgKlxuICAgKiA8cD5UaGUgbW9ua2V5IHBhdGNoZWQgdmVyc2lvbnMgdGhyb3cgYSBUeXBlRXJyb3IgaWYgdGhlaXJcbiAgICogYXJndW1lbnQgaXMgbm90IGFuIG9iamVjdCwgc28gaXQgc2hvdWxkIG9ubHkgYmUgZG9uZSB0byBmdW5jdGlvbnNcbiAgICogdGhhdCBzaG91bGQgdGhyb3cgYSBUeXBlRXJyb3IgYW55d2F5IGlmIHRoZWlyIGFyZ3VtZW50IGlzIG5vdCBhblxuICAgKiBvYmplY3QuXG4gICAqL1xuICAoZnVuY3Rpb24oKXtcbiAgICB2YXIgb2xkRnJlZXplID0gT2JqZWN0LmZyZWV6ZTtcbiAgICBkZWZQcm9wKE9iamVjdCwgJ2ZyZWV6ZScsIHtcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBpZGVudGlmeWluZ0ZyZWV6ZShvYmopIHtcbiAgICAgICAgZ2V0SGlkZGVuUmVjb3JkKG9iaik7XG4gICAgICAgIHJldHVybiBvbGRGcmVlemUob2JqKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB2YXIgb2xkU2VhbCA9IE9iamVjdC5zZWFsO1xuICAgIGRlZlByb3AoT2JqZWN0LCAnc2VhbCcsIHtcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBpZGVudGlmeWluZ1NlYWwob2JqKSB7XG4gICAgICAgIGdldEhpZGRlblJlY29yZChvYmopO1xuICAgICAgICByZXR1cm4gb2xkU2VhbChvYmopO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHZhciBvbGRQcmV2ZW50RXh0ZW5zaW9ucyA9IE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucztcbiAgICBkZWZQcm9wKE9iamVjdCwgJ3ByZXZlbnRFeHRlbnNpb25zJywge1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGlkZW50aWZ5aW5nUHJldmVudEV4dGVuc2lvbnMob2JqKSB7XG4gICAgICAgIGdldEhpZGRlblJlY29yZChvYmopO1xuICAgICAgICByZXR1cm4gb2xkUHJldmVudEV4dGVuc2lvbnMob2JqKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSkoKTtcblxuICBmdW5jdGlvbiBjb25zdEZ1bmMoZnVuYykge1xuICAgIGZ1bmMucHJvdG90eXBlID0gbnVsbDtcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZShmdW5jKTtcbiAgfVxuXG4gIHZhciBjYWxsZWRBc0Z1bmN0aW9uV2FybmluZ0RvbmUgPSBmYWxzZTtcbiAgZnVuY3Rpb24gY2FsbGVkQXNGdW5jdGlvbldhcm5pbmcoKSB7XG4gICAgLy8gRnV0dXJlIEVTNiBXZWFrTWFwIGlzIGN1cnJlbnRseSAoMjAxMy0wOS0xMCkgZXhwZWN0ZWQgdG8gcmVqZWN0IFdlYWtNYXAoKVxuICAgIC8vIGJ1dCB3ZSB1c2VkIHRvIHBlcm1pdCBpdCBhbmQgZG8gaXQgb3Vyc2VsdmVzLCBzbyB3YXJuIG9ubHkuXG4gICAgaWYgKCFjYWxsZWRBc0Z1bmN0aW9uV2FybmluZ0RvbmUgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjYWxsZWRBc0Z1bmN0aW9uV2FybmluZ0RvbmUgPSB0cnVlO1xuICAgICAgY29uc29sZS53YXJuKCdXZWFrTWFwIHNob3VsZCBiZSBpbnZva2VkIGFzIG5ldyBXZWFrTWFwKCksIG5vdCAnICtcbiAgICAgICAgICAnV2Vha01hcCgpLiBUaGlzIHdpbGwgYmUgYW4gZXJyb3IgaW4gdGhlIGZ1dHVyZS4nKTtcbiAgICB9XG4gIH1cblxuICB2YXIgbmV4dElkID0gMDtcblxuICB2YXIgT3VyV2Vha01hcCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBPdXJXZWFrTWFwKSkgeyAgLy8gYXBwcm94aW1hdGUgdGVzdCBmb3IgbmV3IC4uLigpXG4gICAgICBjYWxsZWRBc0Z1bmN0aW9uV2FybmluZygpO1xuICAgIH1cblxuICAgIC8vIFdlIGFyZSBjdXJyZW50bHkgKDEyLzI1LzIwMTIpIG5ldmVyIGVuY291bnRlcmluZyBhbnkgcHJlbWF0dXJlbHlcbiAgICAvLyBub24tZXh0ZW5zaWJsZSBrZXlzLlxuICAgIHZhciBrZXlzID0gW107IC8vIGJydXRlIGZvcmNlIGZvciBwcmVtYXR1cmVseSBub24tZXh0ZW5zaWJsZSBrZXlzLlxuICAgIHZhciB2YWx1ZXMgPSBbXTsgLy8gYnJ1dGUgZm9yY2UgZm9yIGNvcnJlc3BvbmRpbmcgdmFsdWVzLlxuICAgIHZhciBpZCA9IG5leHRJZCsrO1xuXG4gICAgZnVuY3Rpb24gZ2V0X19fKGtleSwgb3B0X2RlZmF1bHQpIHtcbiAgICAgIHZhciBpbmRleDtcbiAgICAgIHZhciBoaWRkZW5SZWNvcmQgPSBnZXRIaWRkZW5SZWNvcmQoa2V5KTtcbiAgICAgIGlmIChoaWRkZW5SZWNvcmQpIHtcbiAgICAgICAgcmV0dXJuIGlkIGluIGhpZGRlblJlY29yZCA/IGhpZGRlblJlY29yZFtpZF0gOiBvcHRfZGVmYXVsdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluZGV4ID0ga2V5cy5pbmRleE9mKGtleSk7XG4gICAgICAgIHJldHVybiBpbmRleCA+PSAwID8gdmFsdWVzW2luZGV4XSA6IG9wdF9kZWZhdWx0O1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhc19fXyhrZXkpIHtcbiAgICAgIHZhciBoaWRkZW5SZWNvcmQgPSBnZXRIaWRkZW5SZWNvcmQoa2V5KTtcbiAgICAgIGlmIChoaWRkZW5SZWNvcmQpIHtcbiAgICAgICAgcmV0dXJuIGlkIGluIGhpZGRlblJlY29yZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBrZXlzLmluZGV4T2Yoa2V5KSA+PSAwO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldF9fXyhrZXksIHZhbHVlKSB7XG4gICAgICB2YXIgaW5kZXg7XG4gICAgICB2YXIgaGlkZGVuUmVjb3JkID0gZ2V0SGlkZGVuUmVjb3JkKGtleSk7XG4gICAgICBpZiAoaGlkZGVuUmVjb3JkKSB7XG4gICAgICAgIGhpZGRlblJlY29yZFtpZF0gPSB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluZGV4ID0ga2V5cy5pbmRleE9mKGtleSk7XG4gICAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgICAgdmFsdWVzW2luZGV4XSA9IHZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFNpbmNlIHNvbWUgYnJvd3NlcnMgcHJlZW1wdGl2ZWx5IHRlcm1pbmF0ZSBzbG93IHR1cm5zIGJ1dFxuICAgICAgICAgIC8vIHRoZW4gY29udGludWUgY29tcHV0aW5nIHdpdGggcHJlc3VtYWJseSBjb3JydXB0ZWQgaGVhcFxuICAgICAgICAgIC8vIHN0YXRlLCB3ZSBoZXJlIGRlZmVuc2l2ZWx5IGdldCBrZXlzLmxlbmd0aCBmaXJzdCBhbmQgdGhlblxuICAgICAgICAgIC8vIHVzZSBpdCB0byB1cGRhdGUgYm90aCB0aGUgdmFsdWVzIGFuZCBrZXlzIGFycmF5cywga2VlcGluZ1xuICAgICAgICAgIC8vIHRoZW0gaW4gc3luYy5cbiAgICAgICAgICBpbmRleCA9IGtleXMubGVuZ3RoO1xuICAgICAgICAgIHZhbHVlc1tpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgICAvLyBJZiB3ZSBjcmFzaCBoZXJlLCB2YWx1ZXMgd2lsbCBiZSBvbmUgbG9uZ2VyIHRoYW4ga2V5cy5cbiAgICAgICAgICBrZXlzW2luZGV4XSA9IGtleTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVsZXRlX19fKGtleSkge1xuICAgICAgdmFyIGhpZGRlblJlY29yZCA9IGdldEhpZGRlblJlY29yZChrZXkpO1xuICAgICAgdmFyIGluZGV4LCBsYXN0SW5kZXg7XG4gICAgICBpZiAoaGlkZGVuUmVjb3JkKSB7XG4gICAgICAgIHJldHVybiBpZCBpbiBoaWRkZW5SZWNvcmQgJiYgZGVsZXRlIGhpZGRlblJlY29yZFtpZF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbmRleCA9IGtleXMuaW5kZXhPZihrZXkpO1xuICAgICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNpbmNlIHNvbWUgYnJvd3NlcnMgcHJlZW1wdGl2ZWx5IHRlcm1pbmF0ZSBzbG93IHR1cm5zIGJ1dFxuICAgICAgICAvLyB0aGVuIGNvbnRpbnVlIGNvbXB1dGluZyB3aXRoIHBvdGVudGlhbGx5IGNvcnJ1cHRlZCBoZWFwXG4gICAgICAgIC8vIHN0YXRlLCB3ZSBoZXJlIGRlZmVuc2l2ZWx5IGdldCBrZXlzLmxlbmd0aCBmaXJzdCBhbmQgdGhlbiB1c2VcbiAgICAgICAgLy8gaXQgdG8gdXBkYXRlIGJvdGggdGhlIGtleXMgYW5kIHRoZSB2YWx1ZXMgYXJyYXksIGtlZXBpbmdcbiAgICAgICAgLy8gdGhlbSBpbiBzeW5jLiBXZSB1cGRhdGUgdGhlIHR3byB3aXRoIGFuIG9yZGVyIG9mIGFzc2lnbm1lbnRzLFxuICAgICAgICAvLyBzdWNoIHRoYXQgYW55IHByZWZpeCBvZiB0aGVzZSBhc3NpZ25tZW50cyB3aWxsIHByZXNlcnZlIHRoZVxuICAgICAgICAvLyBrZXkvdmFsdWUgY29ycmVzcG9uZGVuY2UsIGVpdGhlciBiZWZvcmUgb3IgYWZ0ZXIgdGhlIGRlbGV0ZS5cbiAgICAgICAgLy8gTm90ZSB0aGF0IHRoaXMgbmVlZHMgdG8gd29yayBjb3JyZWN0bHkgd2hlbiBpbmRleCA9PT0gbGFzdEluZGV4LlxuICAgICAgICBsYXN0SW5kZXggPSBrZXlzLmxlbmd0aCAtIDE7XG4gICAgICAgIGtleXNbaW5kZXhdID0gdm9pZCAwO1xuICAgICAgICAvLyBJZiB3ZSBjcmFzaCBoZXJlLCB0aGVyZSdzIGEgdm9pZCAwIGluIHRoZSBrZXlzIGFycmF5LCBidXRcbiAgICAgICAgLy8gbm8gb3BlcmF0aW9uIHdpbGwgY2F1c2UgYSBcImtleXMuaW5kZXhPZih2b2lkIDApXCIsIHNpbmNlXG4gICAgICAgIC8vIGdldEhpZGRlblJlY29yZCh2b2lkIDApIHdpbGwgYWx3YXlzIHRocm93IGFuIGVycm9yIGZpcnN0LlxuICAgICAgICB2YWx1ZXNbaW5kZXhdID0gdmFsdWVzW2xhc3RJbmRleF07XG4gICAgICAgIC8vIElmIHdlIGNyYXNoIGhlcmUsIHZhbHVlc1tpbmRleF0gY2Fubm90IGJlIGZvdW5kIGhlcmUsXG4gICAgICAgIC8vIGJlY2F1c2Uga2V5c1tpbmRleF0gaXMgdm9pZCAwLlxuICAgICAgICBrZXlzW2luZGV4XSA9IGtleXNbbGFzdEluZGV4XTtcbiAgICAgICAgLy8gSWYgaW5kZXggPT09IGxhc3RJbmRleCBhbmQgd2UgY3Jhc2ggaGVyZSwgdGhlbiBrZXlzW2luZGV4XVxuICAgICAgICAvLyBpcyBzdGlsbCB2b2lkIDAsIHNpbmNlIHRoZSBhbGlhc2luZyBraWxsZWQgdGhlIHByZXZpb3VzIGtleS5cbiAgICAgICAga2V5cy5sZW5ndGggPSBsYXN0SW5kZXg7XG4gICAgICAgIC8vIElmIHdlIGNyYXNoIGhlcmUsIGtleXMgd2lsbCBiZSBvbmUgc2hvcnRlciB0aGFuIHZhbHVlcy5cbiAgICAgICAgdmFsdWVzLmxlbmd0aCA9IGxhc3RJbmRleDtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIE9iamVjdC5jcmVhdGUoT3VyV2Vha01hcC5wcm90b3R5cGUsIHtcbiAgICAgIGdldF9fXzogICAgeyB2YWx1ZTogY29uc3RGdW5jKGdldF9fXykgfSxcbiAgICAgIGhhc19fXzogICAgeyB2YWx1ZTogY29uc3RGdW5jKGhhc19fXykgfSxcbiAgICAgIHNldF9fXzogICAgeyB2YWx1ZTogY29uc3RGdW5jKHNldF9fXykgfSxcbiAgICAgIGRlbGV0ZV9fXzogeyB2YWx1ZTogY29uc3RGdW5jKGRlbGV0ZV9fXykgfVxuICAgIH0pO1xuICB9O1xuXG4gIE91cldlYWtNYXAucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShPYmplY3QucHJvdG90eXBlLCB7XG4gICAgZ2V0OiB7XG4gICAgICAvKipcbiAgICAgICAqIFJldHVybiB0aGUgdmFsdWUgbW9zdCByZWNlbnRseSBhc3NvY2lhdGVkIHdpdGgga2V5LCBvclxuICAgICAgICogb3B0X2RlZmF1bHQgaWYgbm9uZS5cbiAgICAgICAqL1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldChrZXksIG9wdF9kZWZhdWx0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldF9fXyhrZXksIG9wdF9kZWZhdWx0KTtcbiAgICAgIH0sXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0sXG5cbiAgICBoYXM6IHtcbiAgICAgIC8qKlxuICAgICAgICogSXMgdGhlcmUgYSB2YWx1ZSBhc3NvY2lhdGVkIHdpdGgga2V5IGluIHRoaXMgV2Vha01hcD9cbiAgICAgICAqL1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGhhcyhrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFzX19fKGtleSk7XG4gICAgICB9LFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9LFxuXG4gICAgc2V0OiB7XG4gICAgICAvKipcbiAgICAgICAqIEFzc29jaWF0ZSB2YWx1ZSB3aXRoIGtleSBpbiB0aGlzIFdlYWtNYXAsIG92ZXJ3cml0aW5nIGFueVxuICAgICAgICogcHJldmlvdXMgYXNzb2NpYXRpb24gaWYgcHJlc2VudC5cbiAgICAgICAqL1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldChrZXksIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldF9fXyhrZXksIHZhbHVlKTtcbiAgICAgIH0sXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0sXG5cbiAgICAnZGVsZXRlJzoge1xuICAgICAgLyoqXG4gICAgICAgKiBSZW1vdmUgYW55IGFzc29jaWF0aW9uIGZvciBrZXkgaW4gdGhpcyBXZWFrTWFwLCByZXR1cm5pbmdcbiAgICAgICAqIHdoZXRoZXIgdGhlcmUgd2FzIG9uZS5cbiAgICAgICAqXG4gICAgICAgKiA8cD5Ob3RlIHRoYXQgdGhlIGJvb2xlYW4gcmV0dXJuIGhlcmUgZG9lcyBub3Qgd29yayBsaWtlIHRoZVxuICAgICAgICoge0Bjb2RlIGRlbGV0ZX0gb3BlcmF0b3IuIFRoZSB7QGNvZGUgZGVsZXRlfSBvcGVyYXRvciByZXR1cm5zXG4gICAgICAgKiB3aGV0aGVyIHRoZSBkZWxldGlvbiBzdWNjZWVkcyBhdCBicmluZ2luZyBhYm91dCBhIHN0YXRlIGluXG4gICAgICAgKiB3aGljaCB0aGUgZGVsZXRlZCBwcm9wZXJ0eSBpcyBhYnNlbnQuIFRoZSB7QGNvZGUgZGVsZXRlfVxuICAgICAgICogb3BlcmF0b3IgdGhlcmVmb3JlIHJldHVybnMgdHJ1ZSBpZiB0aGUgcHJvcGVydHkgd2FzIGFscmVhZHlcbiAgICAgICAqIGFic2VudCwgd2hlcmVhcyB0aGlzIHtAY29kZSBkZWxldGV9IG1ldGhvZCByZXR1cm5zIGZhbHNlIGlmXG4gICAgICAgKiB0aGUgYXNzb2NpYXRpb24gd2FzIGFscmVhZHkgYWJzZW50LlxuICAgICAgICovXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWxldGVfX18oa2V5KTtcbiAgICAgIH0sXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG5cbiAgaWYgKHR5cGVvZiBIb3N0V2Vha01hcCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIChmdW5jdGlvbigpIHtcbiAgICAgIC8vIElmIHdlIGdvdCBoZXJlLCB0aGVuIHRoZSBwbGF0Zm9ybSBoYXMgYSBXZWFrTWFwIGJ1dCB3ZSBhcmUgY29uY2VybmVkXG4gICAgICAvLyB0aGF0IGl0IG1heSByZWZ1c2UgdG8gc3RvcmUgc29tZSBrZXkgdHlwZXMuIFRoZXJlZm9yZSwgbWFrZSBhIG1hcFxuICAgICAgLy8gaW1wbGVtZW50YXRpb24gd2hpY2ggbWFrZXMgdXNlIG9mIGJvdGggYXMgcG9zc2libGUuXG5cbiAgICAgIC8vIEluIHRoaXMgbW9kZSB3ZSBhcmUgYWx3YXlzIHVzaW5nIGRvdWJsZSBtYXBzLCBzbyB3ZSBhcmUgbm90IHByb3h5LXNhZmUuXG4gICAgICAvLyBUaGlzIGNvbWJpbmF0aW9uIGRvZXMgbm90IG9jY3VyIGluIGFueSBrbm93biBicm93c2VyLCBidXQgd2UgaGFkIGJlc3RcbiAgICAgIC8vIGJlIHNhZmUuXG4gICAgICBpZiAoZG91YmxlV2Vha01hcENoZWNrU2lsZW50RmFpbHVyZSAmJiB0eXBlb2YgUHJveHkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIFByb3h5ID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBEb3VibGVXZWFrTWFwKCkge1xuICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgT3VyV2Vha01hcCkpIHsgIC8vIGFwcHJveGltYXRlIHRlc3QgZm9yIG5ldyAuLi4oKVxuICAgICAgICAgIGNhbGxlZEFzRnVuY3Rpb25XYXJuaW5nKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBQcmVmZXJhYmxlLCB0cnVseSB3ZWFrIG1hcC5cbiAgICAgICAgdmFyIGhtYXAgPSBuZXcgSG9zdFdlYWtNYXAoKTtcblxuICAgICAgICAvLyBPdXIgaGlkZGVuLXByb3BlcnR5LWJhc2VkIHBzZXVkby13ZWFrLW1hcC4gTGF6aWx5IGluaXRpYWxpemVkIGluIHRoZVxuICAgICAgICAvLyAnc2V0JyBpbXBsZW1lbnRhdGlvbjsgdGh1cyB3ZSBjYW4gYXZvaWQgcGVyZm9ybWluZyBleHRyYSBsb29rdXBzIGlmXG4gICAgICAgIC8vIHdlIGtub3cgYWxsIGVudHJpZXMgYWN0dWFsbHkgc3RvcmVkIGFyZSBlbnRlcmVkIGluICdobWFwJy5cbiAgICAgICAgdmFyIG9tYXAgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgLy8gSGlkZGVuLXByb3BlcnR5IG1hcHMgYXJlIG5vdCBjb21wYXRpYmxlIHdpdGggcHJveGllcyBiZWNhdXNlIHByb3hpZXNcbiAgICAgICAgLy8gY2FuIG9ic2VydmUgdGhlIGhpZGRlbiBuYW1lIGFuZCBlaXRoZXIgYWNjaWRlbnRhbGx5IGV4cG9zZSBpdCBvciBmYWlsXG4gICAgICAgIC8vIHRvIGFsbG93IHRoZSBoaWRkZW4gcHJvcGVydHkgdG8gYmUgc2V0LiBUaGVyZWZvcmUsIHdlIGRvIG5vdCBhbGxvd1xuICAgICAgICAvLyBhcmJpdHJhcnkgV2Vha01hcHMgdG8gc3dpdGNoIHRvIHVzaW5nIGhpZGRlbiBwcm9wZXJ0aWVzLCBidXQgb25seVxuICAgICAgICAvLyB0aG9zZSB3aGljaCBuZWVkIHRoZSBhYmlsaXR5LCBhbmQgdW5wcml2aWxlZ2VkIGNvZGUgaXMgbm90IGFsbG93ZWRcbiAgICAgICAgLy8gdG8gc2V0IHRoZSBmbGFnLlxuICAgICAgICAvL1xuICAgICAgICAvLyAoRXhjZXB0IGluIGRvdWJsZVdlYWtNYXBDaGVja1NpbGVudEZhaWx1cmUgbW9kZSBpbiB3aGljaCBjYXNlIHdlXG4gICAgICAgIC8vIGRpc2FibGUgcHJveGllcy4pXG4gICAgICAgIHZhciBlbmFibGVTd2l0Y2hpbmcgPSBmYWxzZTtcblxuICAgICAgICBmdW5jdGlvbiBkZ2V0KGtleSwgb3B0X2RlZmF1bHQpIHtcbiAgICAgICAgICBpZiAob21hcCkge1xuICAgICAgICAgICAgcmV0dXJuIGhtYXAuaGFzKGtleSkgPyBobWFwLmdldChrZXkpXG4gICAgICAgICAgICAgICAgOiBvbWFwLmdldF9fXyhrZXksIG9wdF9kZWZhdWx0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGhtYXAuZ2V0KGtleSwgb3B0X2RlZmF1bHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGRoYXMoa2V5KSB7XG4gICAgICAgICAgcmV0dXJuIGhtYXAuaGFzKGtleSkgfHwgKG9tYXAgPyBvbWFwLmhhc19fXyhrZXkpIDogZmFsc2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRzZXQ7XG4gICAgICAgIGlmIChkb3VibGVXZWFrTWFwQ2hlY2tTaWxlbnRGYWlsdXJlKSB7XG4gICAgICAgICAgZHNldCA9IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIGhtYXAuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgaWYgKCFobWFwLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICAgIGlmICghb21hcCkgeyBvbWFwID0gbmV3IE91cldlYWtNYXAoKTsgfVxuICAgICAgICAgICAgICBvbWFwLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZHNldCA9IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChlbmFibGVTd2l0Y2hpbmcpIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBobWFwLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGlmICghb21hcCkgeyBvbWFwID0gbmV3IE91cldlYWtNYXAoKTsgfVxuICAgICAgICAgICAgICAgIG9tYXAuc2V0X19fKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBobWFwLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBkZGVsZXRlKGtleSkge1xuICAgICAgICAgIHZhciByZXN1bHQgPSAhIWhtYXBbJ2RlbGV0ZSddKGtleSk7XG4gICAgICAgICAgaWYgKG9tYXApIHsgcmV0dXJuIG9tYXAuZGVsZXRlX19fKGtleSkgfHwgcmVzdWx0OyB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBPYmplY3QuY3JlYXRlKE91cldlYWtNYXAucHJvdG90eXBlLCB7XG4gICAgICAgICAgZ2V0X19fOiAgICB7IHZhbHVlOiBjb25zdEZ1bmMoZGdldCkgfSxcbiAgICAgICAgICBoYXNfX186ICAgIHsgdmFsdWU6IGNvbnN0RnVuYyhkaGFzKSB9LFxuICAgICAgICAgIHNldF9fXzogICAgeyB2YWx1ZTogY29uc3RGdW5jKGRzZXQpIH0sXG4gICAgICAgICAgZGVsZXRlX19fOiB7IHZhbHVlOiBjb25zdEZ1bmMoZGRlbGV0ZSkgfSxcbiAgICAgICAgICBwZXJtaXRIb3N0T2JqZWN0c19fXzogeyB2YWx1ZTogY29uc3RGdW5jKGZ1bmN0aW9uKHRva2VuKSB7XG4gICAgICAgICAgICBpZiAodG9rZW4gPT09IHdlYWtNYXBQZXJtaXRIb3N0T2JqZWN0cykge1xuICAgICAgICAgICAgICBlbmFibGVTd2l0Y2hpbmcgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdib2d1cyBjYWxsIHRvIHBlcm1pdEhvc3RPYmplY3RzX19fJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSl9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgRG91YmxlV2Vha01hcC5wcm90b3R5cGUgPSBPdXJXZWFrTWFwLnByb3RvdHlwZTtcbiAgICAgIG1vZHVsZS5leHBvcnRzID0gRG91YmxlV2Vha01hcDtcblxuICAgICAgLy8gZGVmaW5lIC5jb25zdHJ1Y3RvciB0byBoaWRlIE91cldlYWtNYXAgY3RvclxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdlYWtNYXAucHJvdG90eXBlLCAnY29uc3RydWN0b3InLCB7XG4gICAgICAgIHZhbHVlOiBXZWFrTWFwLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSwgIC8vIGFzIGRlZmF1bHQgLmNvbnN0cnVjdG9yIGlzXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgIH0pKCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gVGhlcmUgaXMgbm8gaG9zdCBXZWFrTWFwLCBzbyB3ZSBtdXN0IHVzZSB0aGUgZW11bGF0aW9uLlxuXG4gICAgLy8gRW11bGF0ZWQgV2Vha01hcHMgYXJlIGluY29tcGF0aWJsZSB3aXRoIG5hdGl2ZSBwcm94aWVzIChiZWNhdXNlIHByb3hpZXNcbiAgICAvLyBjYW4gb2JzZXJ2ZSB0aGUgaGlkZGVuIG5hbWUpLCBzbyB3ZSBtdXN0IGRpc2FibGUgUHJveHkgdXNhZ2UgKGluXG4gICAgLy8gQXJyYXlMaWtlIGFuZCBEb21hZG8sIGN1cnJlbnRseSkuXG4gICAgaWYgKHR5cGVvZiBQcm94eSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIFByb3h5ID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gT3VyV2Vha01hcDtcbiAgfVxufSkoKTtcbiIsIid1c2Ugc3RyaWN0J1xuXG52YXIgd2Vha01hcCA9IHR5cGVvZiBXZWFrTWFwID09PSAndW5kZWZpbmVkJyA/IHJlcXVpcmUoJ3dlYWstbWFwJykgOiBXZWFrTWFwXG5cbnZhciBXZWJHTEVXU3RydWN0ID0gbmV3IHdlYWtNYXAoKVxuXG5mdW5jdGlvbiBiYXNlTmFtZShleHRfbmFtZSkge1xuICByZXR1cm4gZXh0X25hbWUucmVwbGFjZSgvXltBLVpdK18vLCAnJylcbn1cblxuZnVuY3Rpb24gaW5pdFdlYkdMRVcoZ2wpIHtcbiAgdmFyIHN0cnVjdCA9IFdlYkdMRVdTdHJ1Y3QuZ2V0KGdsKVxuICBpZihzdHJ1Y3QpIHtcbiAgICByZXR1cm4gc3RydWN0XG4gIH1cbiAgdmFyIGV4dGVuc2lvbnMgPSB7fVxuICB2YXIgc3VwcG9ydGVkID0gZ2wuZ2V0U3VwcG9ydGVkRXh0ZW5zaW9ucygpXG4gIGZvcih2YXIgaT0wOyBpPHN1cHBvcnRlZC5sZW5ndGg7ICsraSkge1xuICAgIHZhciBleHROYW1lID0gc3VwcG9ydGVkW2ldXG5cbiAgICAvL1NraXAgTU9aXyBleHRlbnNpb25zXG4gICAgaWYoZXh0TmFtZS5pbmRleE9mKCdNT1pfJykgPT09IDApIHtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIHZhciBleHQgPSBnbC5nZXRFeHRlbnNpb24oc3VwcG9ydGVkW2ldKVxuICAgIGlmKCFleHQpIHtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIHdoaWxlKHRydWUpIHtcbiAgICAgIGV4dGVuc2lvbnNbZXh0TmFtZV0gPSBleHRcbiAgICAgIHZhciBiYXNlID0gYmFzZU5hbWUoZXh0TmFtZSlcbiAgICAgIGlmKGJhc2UgPT09IGV4dE5hbWUpIHtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGV4dE5hbWUgPSBiYXNlXG4gICAgfVxuICB9XG4gIFdlYkdMRVdTdHJ1Y3Quc2V0KGdsLCBleHRlbnNpb25zKVxuICByZXR1cm4gZXh0ZW5zaW9uc1xufVxubW9kdWxlLmV4cG9ydHMgPSBpbml0V2ViR0xFVyIsInZhciBjcmVhdGUgPSByZXF1aXJlKCdnbC10ZXh0dXJlMmQnKVxudmFyIG5kYXJyYXkgPSByZXF1aXJlKCduZGFycmF5JylcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihnbCkge1xuICAgIC8vZmlsbCBhbiBhcnJheSB3aXRoIDB4ZmZcbiAgICB2YXIgZGF0YSA9IEFycmF5LmFwcGx5KG51bGwsIG5ldyBBcnJheSgxNikpXG4gICAgICAgICAgICAubWFwKE51bWJlci5wcm90b3R5cGUudmFsdWVPZiwgMHhGRik7XG4gICAgLy9jcmVhdGUgYSAyRCBuZGFycmF5XG4gICAgdmFyIGFycmF5ID0gbmRhcnJheShuZXcgVWludDhBcnJheShkYXRhKSwgWzIsIDIsIDRdKVxuICAgIHJldHVybiBjcmVhdGUoZ2wsIGFycmF5KVxufSIsIm1vZHVsZS5leHBvcnRzPXJlcXVpcmUoXCIvcHJvamVjdHMvYmxhY2tpY2Uvbm9kZV9tb2R1bGVzL3RocmVlLXNkZi10ZXh0L25vZGVfbW9kdWxlcy9nbC1zcHJpdGUtdGV4dC9ub2RlX21vZHVsZXMvZ2wtc3ByaXRlLWJhdGNoL25vZGVfbW9kdWxlcy9nbC1idWZmZXIvbm9kZV9tb2R1bGVzL25kYXJyYXkvbmRhcnJheS5qc1wiKSIsIm1vZHVsZS5leHBvcnRzPXJlcXVpcmUoXCIvcHJvamVjdHMvYmxhY2tpY2Uvbm9kZV9tb2R1bGVzL21peGVzL2luZGV4LmpzXCIpIiwidmFyIGludDggPSBuZXcgSW50OEFycmF5KDQpO1xudmFyIGludDMyID0gbmV3IEludDMyQXJyYXkoaW50OC5idWZmZXIsIDAsIDEpO1xudmFyIGZsb2F0MzIgPSBuZXcgRmxvYXQzMkFycmF5KGludDguYnVmZmVyLCAwLCAxKTtcblxuLyoqXG4gKiBBIHNpbmdsZXRvbiBmb3IgbnVtYmVyIHV0aWxpdGllcy4gXG4gKiBAY2xhc3MgTnVtYmVyVXRpbFxuICovXG52YXIgTnVtYmVyVXRpbCA9IGZ1bmN0aW9uKCkge1xuXG59O1xuXG5cbi8qKlxuICogUmV0dXJucyBhIGZsb2F0IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBpbnQgYml0cy4gQXJyYXlCdWZmZXJcbiAqIGlzIHVzZWQgZm9yIHRoZSBjb252ZXJzaW9uLlxuICpcbiAqIEBtZXRob2QgIGludEJpdHNUb0Zsb2F0XG4gKiBAc3RhdGljXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGkgdGhlIGludCB0byBjYXN0XG4gKiBAcmV0dXJuIHtOdW1iZXJ9ICAgdGhlIGZsb2F0XG4gKi9cbk51bWJlclV0aWwuaW50Qml0c1RvRmxvYXQgPSBmdW5jdGlvbihpKSB7XG5cdGludDMyWzBdID0gaTtcblx0cmV0dXJuIGZsb2F0MzJbMF07XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGludCBiaXRzIGZyb20gdGhlIGdpdmVuIGZsb2F0LiBBcnJheUJ1ZmZlciBpcyB1c2VkXG4gKiBmb3IgdGhlIGNvbnZlcnNpb24uXG4gKlxuICogQG1ldGhvZCAgZmxvYXRUb0ludEJpdHNcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSAge051bWJlcn0gZiB0aGUgZmxvYXQgdG8gY2FzdFxuICogQHJldHVybiB7TnVtYmVyfSAgIHRoZSBpbnQgYml0c1xuICovXG5OdW1iZXJVdGlsLmZsb2F0VG9JbnRCaXRzID0gZnVuY3Rpb24oZikge1xuXHRmbG9hdDMyWzBdID0gZjtcblx0cmV0dXJuIGludDMyWzBdO1xufTtcblxuLyoqXG4gKiBFbmNvZGVzIEFCR1IgaW50IGFzIGEgZmxvYXQsIHdpdGggc2xpZ2h0IHByZWNpc2lvbiBsb3NzLlxuICpcbiAqIEBtZXRob2QgIGludFRvRmxvYXRDb2xvclxuICogQHN0YXRpY1xuICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIGFuIEFCR1IgcGFja2VkIGludGVnZXJcbiAqL1xuTnVtYmVyVXRpbC5pbnRUb0Zsb2F0Q29sb3IgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRyZXR1cm4gTnVtYmVyVXRpbC5pbnRCaXRzVG9GbG9hdCggdmFsdWUgJiAweGZlZmZmZmZmICk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBmbG9hdCBlbmNvZGVkIEFCR1IgdmFsdWUgZnJvbSB0aGUgZ2l2ZW4gUkdCQVxuICogYnl0ZXMgKDAgLSAyNTUpLiBVc2VmdWwgZm9yIHNhdmluZyBiYW5kd2lkdGggaW4gdmVydGV4IGRhdGEuXG4gKlxuICogQG1ldGhvZCAgY29sb3JUb0Zsb2F0XG4gKiBAc3RhdGljXG4gKiBAcGFyYW0ge051bWJlcn0gciB0aGUgUmVkIGJ5dGUgKDAgLSAyNTUpXG4gKiBAcGFyYW0ge051bWJlcn0gZyB0aGUgR3JlZW4gYnl0ZSAoMCAtIDI1NSlcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIHRoZSBCbHVlIGJ5dGUgKDAgLSAyNTUpXG4gKiBAcGFyYW0ge051bWJlcn0gYSB0aGUgQWxwaGEgYnl0ZSAoMCAtIDI1NSlcbiAqIEByZXR1cm4ge0Zsb2F0MzJ9ICBhIEZsb2F0MzIgb2YgdGhlIFJHQkEgY29sb3JcbiAqL1xuTnVtYmVyVXRpbC5jb2xvclRvRmxvYXQgPSBmdW5jdGlvbihyLCBnLCBiLCBhKSB7XG5cdHZhciBiaXRzID0gKGEgPDwgMjQgfCBiIDw8IDE2IHwgZyA8PCA4IHwgcik7XG5cdHJldHVybiBOdW1iZXJVdGlsLmludFRvRmxvYXRDb2xvcihiaXRzKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBudW1iZXIgaXMgYSBwb3dlci1vZi10d28uXG4gKlxuICogQG1ldGhvZCAgaXNQb3dlck9mVHdvXG4gKiBAcGFyYW0gIHtOdW1iZXJ9ICBuIHRoZSBudW1iZXIgdG8gdGVzdFxuICogQHJldHVybiB7Qm9vbGVhbn0gICB0cnVlIGlmIHBvd2VyLW9mLXR3b1xuICovXG5OdW1iZXJVdGlsLmlzUG93ZXJPZlR3byA9IGZ1bmN0aW9uKG4pIHtcblx0cmV0dXJuIChuICYgKG4gLSAxKSkgPT09IDA7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG5leHQgaGlnaGVzdCBwb3dlci1vZi10d28gZnJvbSB0aGUgc3BlY2lmaWVkIG51bWJlci4gXG4gKiBcbiAqIEBwYXJhbSAge051bWJlcn0gbiB0aGUgbnVtYmVyIHRvIHRlc3RcbiAqIEByZXR1cm4ge051bWJlcn0gICB0aGUgbmV4dCBoaWdoZXN0IHBvd2VyIG9mIHR3b1xuICovXG5OdW1iZXJVdGlsLm5leHRQb3dlck9mVHdvID0gZnVuY3Rpb24obikge1xuXHRuLS07XG5cdG4gfD0gbiA+PiAxO1xuXHRuIHw9IG4gPj4gMjtcblx0biB8PSBuID4+IDQ7XG5cdG4gfD0gbiA+PiA4O1xuXHRuIHw9IG4gPj4gMTY7XG5cdHJldHVybiBuKzE7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE51bWJlclV0aWw7IiwiZnVuY3Rpb24gcHJlbXVsdGlwbHkocmdiYSwgb3V0KSB7XG5cdGlmICghb3V0IHx8IHR5cGVvZiBvdXQgPT09ICdudW1iZXInKVxuXHRcdG91dCA9IFswLDAsMCwwXVxuXHRvdXRbMF0gPSByZ2JhWzBdICogcmdiYVszXVxuXHRvdXRbMV0gPSByZ2JhWzFdICogcmdiYVszXVxuXHRvdXRbMl0gPSByZ2JhWzJdICogcmdiYVszXVxuXHRvdXRbM10gPSByZ2JhWzNdXG5cdHJldHVybiBvdXRcbn1cbm1vZHVsZS5leHBvcnRzID0gcHJlbXVsdGlwbHkiLCJ2YXIgcGFja0NvbG9yID0gcmVxdWlyZSgnbnVtYmVyLXV0aWwnKS5jb2xvclRvRmxvYXRcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjb2xvclRvRmxvYXQocmdiYSkge1xuICAgIHJldHVybiBwYWNrQ29sb3IoXG4gICAgICAgIH5+KHJnYmFbMF0gKiAyNTUpLFxuICAgICAgICB+fihyZ2JhWzFdICogMjU1KSxcbiAgICAgICAgfn4ocmdiYVsyXSAqIDI1NSksXG4gICAgICAgIH5+KHJnYmFbM10gKiAyNTUpXG4gICAgKVxufSIsIm1vZHVsZS5leHBvcnRzPXJlcXVpcmUoXCIvcHJvamVjdHMvYmxhY2tpY2Uvbm9kZV9tb2R1bGVzL2luaGVyaXRzL2luaGVyaXRzX2Jyb3dzZXIuanNcIikiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHRleGNvb3JkKHBvc2l0aW9uLCBzaGFwZSwgdGV4U2hhcGUsIG91dCkge1xuICAgIGlmICghb3V0KVxuICAgICAgICBvdXQgPSBbMCwgMCwgMSwgMV1cblxuICAgIHBvc2l0aW9uID0gcG9zaXRpb24gfHwgWzAsIDBdXG4gICAgc2hhcGUgPSBzaGFwZSB8fCBbMSwgMV1cblxuICAgIHRleFNoYXBlID0gdGV4U2hhcGUgfHwgc2hhcGVcblxuICAgIHZhciBpbnZXaWR0aCA9IDEgLyB0ZXhTaGFwZVswXVxuICAgIHZhciBpbnZIZWlnaHQgPSAxIC8gdGV4U2hhcGVbMV1cbiAgICB2YXIgeCA9IHBvc2l0aW9uWzBdLFxuICAgICAgICB5ID0gcG9zaXRpb25bMV0sXG4gICAgICAgIHcgPSBzaGFwZVswXSxcbiAgICAgICAgaCA9IHNoYXBlWzFdXG5cbiAgICBvdXRbMF0gPSB4ICogaW52V2lkdGhcbiAgICBvdXRbMV0gPSB5ICogaW52SGVpZ2h0XG4gICAgb3V0WzJdID0gKHggKyB3KSAqIGludldpZHRoXG4gICAgb3V0WzNdID0gKHkgKyBoKSAqIGludkhlaWdodFxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cz1yZXF1aXJlKFwiL3Byb2plY3RzL2JsYWNraWNlL25vZGVfbW9kdWxlcy9nbC10ZXh0dXJlMmQvdGV4dHVyZS5qc1wiKSIsIm1vZHVsZS5leHBvcnRzID0gZXh0ZW5kXG5cbmZ1bmN0aW9uIGV4dGVuZCgpIHtcbiAgICB2YXIgdGFyZ2V0ID0ge31cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV1cblxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgICAgICBpZiAoc291cmNlLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0XG59XG4iLCJ2YXIgZ2xzbGlmeSA9IHJlcXVpcmUoXCJnbHNsaWZ5XCIpO1xudmFyIHRocmVlaWZ5ID0gcmVxdWlyZShcInRocmVlLWdsc2xpZnlcIik7XG52YXIgc291cmNlID0gcmVxdWlyZShcImdsc2xpZnkvc2ltcGxlLWFkYXB0ZXIuanNcIikoXCJcXG4jZGVmaW5lIEdMU0xJRlkgMVxcblxcbnZhcnlpbmcgdmVjMiB2VXY7XFxudmFyeWluZyB2ZWMyIHZfcmdiTlc7XFxudmFyeWluZyB2ZWMyIHZfcmdiTkU7XFxudmFyeWluZyB2ZWMyIHZfcmdiU1c7XFxudmFyeWluZyB2ZWMyIHZfcmdiU0U7XFxudmFyeWluZyB2ZWMyIHZfcmdiTTtcXG51bmlmb3JtIHZlYzIgcmVzb2x1dGlvbjtcXG52b2lkIGFfeF90ZXhjb29yZHModmVjMiBmcmFnQ29vcmQsIHZlYzIgcmVzb2x1dGlvbiwgb3V0IHZlYzIgdl9yZ2JOVywgb3V0IHZlYzIgdl9yZ2JORSwgb3V0IHZlYzIgdl9yZ2JTVywgb3V0IHZlYzIgdl9yZ2JTRSwgb3V0IHZlYzIgdl9yZ2JNKSB7XFxuICB2ZWMyIGludmVyc2VWUCA9IDEuMCAvIHJlc29sdXRpb24ueHk7XFxuICB2X3JnYk5XID0gKGZyYWdDb29yZCArIHZlYzIoLTEuMCwgLTEuMCkpICogaW52ZXJzZVZQO1xcbiAgdl9yZ2JORSA9IChmcmFnQ29vcmQgKyB2ZWMyKDEuMCwgLTEuMCkpICogaW52ZXJzZVZQO1xcbiAgdl9yZ2JTVyA9IChmcmFnQ29vcmQgKyB2ZWMyKC0xLjAsIDEuMCkpICogaW52ZXJzZVZQO1xcbiAgdl9yZ2JTRSA9IChmcmFnQ29vcmQgKyB2ZWMyKDEuMCwgMS4wKSkgKiBpbnZlcnNlVlA7XFxuICB2X3JnYk0gPSB2ZWMyKGZyYWdDb29yZCAqIGludmVyc2VWUCk7XFxufVxcbnZvaWQgbWFpbigpIHtcXG4gIHZVdiA9IHV2O1xcbiAgdmVjMiBmcmFnQ29vcmQgPSB1diAqIHJlc29sdXRpb247XFxuICBhX3hfdGV4Y29vcmRzKGZyYWdDb29yZCwgcmVzb2x1dGlvbiwgdl9yZ2JOVywgdl9yZ2JORSwgdl9yZ2JTVywgdl9yZ2JTRSwgdl9yZ2JNKTtcXG4gIGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG1vZGVsVmlld01hdHJpeCAqIHZlYzQocG9zaXRpb24sIDEuMCk7XFxufVwiLCBcIlxcbiNkZWZpbmUgR0xTTElGWSAxXFxuXFxudmFyeWluZyB2ZWMyIHZVdjtcXG52YXJ5aW5nIHZlYzIgdl9yZ2JOVztcXG52YXJ5aW5nIHZlYzIgdl9yZ2JORTtcXG52YXJ5aW5nIHZlYzIgdl9yZ2JTVztcXG52YXJ5aW5nIHZlYzIgdl9yZ2JTRTtcXG52YXJ5aW5nIHZlYzIgdl9yZ2JNO1xcbnVuaWZvcm0gdmVjMiByZXNvbHV0aW9uO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHREaWZmdXNlO1xcbiNpZm5kZWYgRlhBQV9SRURVQ0VfTUlOXFxuXFxuI2RlZmluZSBGWEFBX1JFRFVDRV9NSU4gICAoMS4wLyAxMjguMClcXG5cXG4jZW5kaWZcXG5cXG4jaWZuZGVmIEZYQUFfUkVEVUNFX01VTFxcblxcbiNkZWZpbmUgRlhBQV9SRURVQ0VfTVVMICAgKDEuMCAvIDguMClcXG5cXG4jZW5kaWZcXG5cXG4jaWZuZGVmIEZYQUFfU1BBTl9NQVhcXG5cXG4jZGVmaW5lIEZYQUFfU1BBTl9NQVggICAgIDguMFxcblxcbiNlbmRpZlxcblxcbnZlYzQgYV94X2Z4YWEoc2FtcGxlcjJEIHRleCwgdmVjMiBmcmFnQ29vcmQsIHZlYzIgcmVzb2x1dGlvbiwgdmVjMiB2X3JnYk5XLCB2ZWMyIHZfcmdiTkUsIHZlYzIgdl9yZ2JTVywgdmVjMiB2X3JnYlNFLCB2ZWMyIHZfcmdiTSkge1xcbiAgdmVjNCBjb2xvcjtcXG4gIG1lZGl1bXAgdmVjMiBpbnZlcnNlVlAgPSB2ZWMyKDEuMCAvIHJlc29sdXRpb24ueCwgMS4wIC8gcmVzb2x1dGlvbi55KTtcXG4gIHZlYzMgcmdiTlcgPSB0ZXh0dXJlMkQodGV4LCB2X3JnYk5XKS54eXo7XFxuICB2ZWMzIHJnYk5FID0gdGV4dHVyZTJEKHRleCwgdl9yZ2JORSkueHl6O1xcbiAgdmVjMyByZ2JTVyA9IHRleHR1cmUyRCh0ZXgsIHZfcmdiU1cpLnh5ejtcXG4gIHZlYzMgcmdiU0UgPSB0ZXh0dXJlMkQodGV4LCB2X3JnYlNFKS54eXo7XFxuICB2ZWM0IHRleENvbG9yID0gdGV4dHVyZTJEKHRleCwgdl9yZ2JNKTtcXG4gIHZlYzMgcmdiTSA9IHRleENvbG9yLnh5ejtcXG4gIHZlYzMgbHVtYSA9IHZlYzMoMC4yOTksIDAuNTg3LCAwLjExNCk7XFxuICBmbG9hdCBsdW1hTlcgPSBkb3QocmdiTlcsIGx1bWEpO1xcbiAgZmxvYXQgbHVtYU5FID0gZG90KHJnYk5FLCBsdW1hKTtcXG4gIGZsb2F0IGx1bWFTVyA9IGRvdChyZ2JTVywgbHVtYSk7XFxuICBmbG9hdCBsdW1hU0UgPSBkb3QocmdiU0UsIGx1bWEpO1xcbiAgZmxvYXQgbHVtYU0gPSBkb3QocmdiTSwgbHVtYSk7XFxuICBmbG9hdCBsdW1hTWluID0gbWluKGx1bWFNLCBtaW4obWluKGx1bWFOVywgbHVtYU5FKSwgbWluKGx1bWFTVywgbHVtYVNFKSkpO1xcbiAgZmxvYXQgbHVtYU1heCA9IG1heChsdW1hTSwgbWF4KG1heChsdW1hTlcsIGx1bWFORSksIG1heChsdW1hU1csIGx1bWFTRSkpKTtcXG4gIG1lZGl1bXAgdmVjMiBkaXI7XFxuICBkaXIueCA9IC0oKGx1bWFOVyArIGx1bWFORSkgLSAobHVtYVNXICsgbHVtYVNFKSk7XFxuICBkaXIueSA9ICgobHVtYU5XICsgbHVtYVNXKSAtIChsdW1hTkUgKyBsdW1hU0UpKTtcXG4gIGZsb2F0IGRpclJlZHVjZSA9IG1heCgobHVtYU5XICsgbHVtYU5FICsgbHVtYVNXICsgbHVtYVNFKSAqICgwLjI1ICogRlhBQV9SRURVQ0VfTVVMKSwgRlhBQV9SRURVQ0VfTUlOKTtcXG4gIGZsb2F0IHJjcERpck1pbiA9IDEuMCAvIChtaW4oYWJzKGRpci54KSwgYWJzKGRpci55KSkgKyBkaXJSZWR1Y2UpO1xcbiAgZGlyID0gbWluKHZlYzIoRlhBQV9TUEFOX01BWCwgRlhBQV9TUEFOX01BWCksIG1heCh2ZWMyKC1GWEFBX1NQQU5fTUFYLCAtRlhBQV9TUEFOX01BWCksIGRpciAqIHJjcERpck1pbikpICogaW52ZXJzZVZQO1xcbiAgdmVjMyByZ2JBID0gMC41ICogKHRleHR1cmUyRCh0ZXgsIGZyYWdDb29yZCAqIGludmVyc2VWUCArIGRpciAqICgxLjAgLyAzLjAgLSAwLjUpKS54eXogKyB0ZXh0dXJlMkQodGV4LCBmcmFnQ29vcmQgKiBpbnZlcnNlVlAgKyBkaXIgKiAoMi4wIC8gMy4wIC0gMC41KSkueHl6KTtcXG4gIHZlYzMgcmdiQiA9IHJnYkEgKiAwLjUgKyAwLjI1ICogKHRleHR1cmUyRCh0ZXgsIGZyYWdDb29yZCAqIGludmVyc2VWUCArIGRpciAqIC0wLjUpLnh5eiArIHRleHR1cmUyRCh0ZXgsIGZyYWdDb29yZCAqIGludmVyc2VWUCArIGRpciAqIDAuNSkueHl6KTtcXG4gIGZsb2F0IGx1bWFCID0gZG90KHJnYkIsIGx1bWEpO1xcbiAgaWYoKGx1bWFCIDwgbHVtYU1pbikgfHwgKGx1bWFCID4gbHVtYU1heCkpXFxuICAgIGNvbG9yID0gdmVjNChyZ2JBLCB0ZXhDb2xvci5hKTtcXG4gIGVsc2VcXG4gICAgY29sb3IgPSB2ZWM0KHJnYkIsIHRleENvbG9yLmEpO1xcbiAgcmV0dXJuIGNvbG9yO1xcbn1cXG52b2lkIG1haW4oKSB7XFxuICB2ZWMyIGZyYWdDb29yZCA9IHZVdiAqIHJlc29sdXRpb247XFxuICBnbF9GcmFnQ29sb3IgPSBhX3hfZnhhYSh0RGlmZnVzZSwgZnJhZ0Nvb3JkLCByZXNvbHV0aW9uLCB2X3JnYk5XLCB2X3JnYk5FLCB2X3JnYlNXLCB2X3JnYlNFLCB2X3JnYk0pO1xcbn1cIiwgW3tcIm5hbWVcIjpcInJlc29sdXRpb25cIixcInR5cGVcIjpcInZlYzJcIn0se1wibmFtZVwiOlwicmVzb2x1dGlvblwiLFwidHlwZVwiOlwidmVjMlwifSx7XCJuYW1lXCI6XCJ0RGlmZnVzZVwiLFwidHlwZVwiOlwic2FtcGxlcjJEXCJ9XSwgW10pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFRIUkVFKSB7XG4gICAgdmFyIGNyZWF0ZVNoYWRlciA9IHRocmVlaWZ5KFRIUkVFKTtcblxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVNoYWRlcihzb3VyY2UpO1xuICAgIH07XG59OyIsInZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihUSFJFRSkge1xuXG4gICAgZnVuY3Rpb24gQ29tcGxleChtZXNoKSB7XG4gICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBDb21wbGV4KSlcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29tcGxleChtZXNoKVxuICAgICAgICBUSFJFRS5HZW9tZXRyeS5jYWxsKHRoaXMpXG4gICAgICAgIHRoaXMuZHluYW1pYyA9IHRydWVcblxuICAgICAgICBpZiAobWVzaClcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKG1lc2gpXG4gICAgfVxuXG4gICAgaW5oZXJpdHMoQ29tcGxleCwgVEhSRUUuR2VvbWV0cnkpXG5cbiAgICAvL21heSBleHBvc2UgdGhlc2UgaW4gbmV4dCB2ZXJzaW9uXG4gICAgQ29tcGxleC5wcm90b3R5cGUuX3VwZGF0ZVBvc2l0aW9ucyA9IGZ1bmN0aW9uKHBvc2l0aW9ucykge1xuICAgICAgICBmb3IgKHZhciBpPTA7IGk8cG9zaXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcG9zID0gcG9zaXRpb25zW2ldXG4gICAgICAgICAgICBpZiAoaSA+IHRoaXMudmVydGljZXMubGVuZ3RoLTEpXG4gICAgICAgICAgICAgICAgdGhpcy52ZXJ0aWNlcy5wdXNoKG5ldyBUSFJFRS5WZWN0b3IzKCkuZnJvbUFycmF5KHBvcykpXG4gICAgICAgICAgICBlbHNlIFxuICAgICAgICAgICAgICAgIHRoaXMudmVydGljZXNbaV0uZnJvbUFycmF5KHBvcylcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZlcnRpY2VzLmxlbmd0aCA9IHBvc2l0aW9ucy5sZW5ndGhcbiAgICAgICAgdGhpcy52ZXJ0aWNlc05lZWRVcGRhdGUgPSB0cnVlXG4gICAgfVxuXG4gICAgQ29tcGxleC5wcm90b3R5cGUuX3VwZGF0ZUNlbGxzID0gZnVuY3Rpb24oY2VsbHMpIHtcbiAgICAgICAgZm9yICh2YXIgaT0wOyBpPGNlbGxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZmFjZSA9IGNlbGxzW2ldXG4gICAgICAgICAgICBpZiAoaSA+IHRoaXMuZmFjZXMubGVuZ3RoLTEpXG4gICAgICAgICAgICAgICAgdGhpcy5mYWNlcy5wdXNoKG5ldyBUSFJFRS5GYWNlMyhmYWNlWzBdLCBmYWNlWzFdLCBmYWNlWzJdKSlcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciB0ZiA9IHRoaXMuZmFjZXNbaV1cbiAgICAgICAgICAgICAgICB0Zi5hID0gZmFjZVswXVxuICAgICAgICAgICAgICAgIHRmLmIgPSBmYWNlWzFdXG4gICAgICAgICAgICAgICAgdGYuYyA9IGZhY2VbMl1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZmFjZXMubGVuZ3RoID0gY2VsbHMubGVuZ3RoXG4gICAgICAgIHRoaXMuZWxlbWVudHNOZWVkVXBkYXRlID0gdHJ1ZVxuICAgIH1cblxuICAgIENvbXBsZXgucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKG1lc2gpIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlUG9zaXRpb25zKG1lc2gucG9zaXRpb25zKVxuICAgICAgICB0aGlzLl91cGRhdGVDZWxscyhtZXNoLmNlbGxzKVxuICAgIH1cblxuICAgIHJldHVybiBDb21wbGV4XG59IiwidmFyIFRlc3MyID0gcmVxdWlyZSgndGVzczInKVxudmFyIHh0ZW5kID0gcmVxdWlyZSgneHRlbmQnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGNvbnRvdXJzLCBvcHQpIHtcbiAgICBvcHQgPSBvcHR8fHt9XG4gICAgY29udG91cnMgPSBjb250b3Vycy5maWx0ZXIoZnVuY3Rpb24oYykge1xuICAgICAgICByZXR1cm4gYy5sZW5ndGg+MFxuICAgIH0pXG4gICAgXG4gICAgaWYgKGNvbnRvdXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4geyBcbiAgICAgICAgICAgIHBvc2l0aW9uczogW10sXG4gICAgICAgICAgICBjZWxsczogW11cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygb3B0LnZlcnRleFNpemUgIT09ICdudW1iZXInKVxuICAgICAgICBvcHQudmVydGV4U2l6ZSA9IGNvbnRvdXJzWzBdWzBdLmxlbmd0aFxuXG4gICAgLy9mbGF0dGVuIGZvciB0ZXNzMi5qc1xuICAgIGNvbnRvdXJzID0gY29udG91cnMubWFwKGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgcmV0dXJuIGMucmVkdWNlKGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBhLmNvbmNhdChiKVxuICAgICAgICB9KVxuICAgIH0pXG5cbiAgICAvLyBUZXNzZWxhdGVcbiAgICB2YXIgcmVzID0gVGVzczIudGVzc2VsYXRlKHh0ZW5kKHtcbiAgICAgICAgY29udG91cnM6IGNvbnRvdXJzLFxuICAgICAgICB3aW5kaW5nUnVsZTogVGVzczIuV0lORElOR19PREQsXG4gICAgICAgIGVsZW1lbnRUeXBlOiBUZXNzMi5QT0xZR09OUyxcbiAgICAgICAgcG9seVNpemU6IDMsXG4gICAgICAgIHZlcnRleFNpemU6IDJcbiAgICB9LCBvcHQpKVxuXG4gICAgdmFyIHBvc2l0aW9ucyA9IFtdXG4gICAgZm9yICh2YXIgaT0wOyBpPHJlcy52ZXJ0aWNlcy5sZW5ndGg7IGkrPW9wdC52ZXJ0ZXhTaXplKSB7XG4gICAgICAgIHZhciBwb3MgPSByZXMudmVydGljZXMuc2xpY2UoaSwgaStvcHQudmVydGV4U2l6ZSlcbiAgICAgICAgcG9zaXRpb25zLnB1c2gocG9zKVxuICAgIH1cbiAgICBcbiAgICB2YXIgY2VsbHMgPSBbXVxuICAgIGZvciAoaT0wOyBpPHJlcy5lbGVtZW50cy5sZW5ndGg7IGkrPTMpIHtcbiAgICAgICAgdmFyIGEgPSByZXMuZWxlbWVudHNbaV0sXG4gICAgICAgICAgICBiID0gcmVzLmVsZW1lbnRzW2krMV0sXG4gICAgICAgICAgICBjID0gcmVzLmVsZW1lbnRzW2krMl1cbiAgICAgICAgY2VsbHMucHVzaChbYSwgYiwgY10pXG4gICAgfVxuXG4gICAgLy9yZXR1cm4gYSBzaW1wbGljaWFsIGNvbXBsZXhcbiAgICByZXR1cm4ge1xuICAgICAgICBwb3NpdGlvbnM6IHBvc2l0aW9ucyxcbiAgICAgICAgY2VsbHM6IGNlbGxzXG4gICAgfVxufSIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9zcmMvdGVzczInKTsiLCIvKlxuKiogU0dJIEZSRUUgU09GVFdBUkUgTElDRU5TRSBCIChWZXJzaW9uIDIuMCwgU2VwdC4gMTgsIDIwMDgpIFxuKiogQ29weXJpZ2h0IChDKSBbZGF0ZXMgb2YgZmlyc3QgcHVibGljYXRpb25dIFNpbGljb24gR3JhcGhpY3MsIEluYy5cbioqIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4qKlxuKiogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuKiogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuKiogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuKiogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXNcbioqIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbioqIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuKiogXG4qKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBpbmNsdWRpbmcgdGhlIGRhdGVzIG9mIGZpcnN0IHB1YmxpY2F0aW9uIGFuZCBlaXRoZXIgdGhpc1xuKiogcGVybWlzc2lvbiBub3RpY2Ugb3IgYSByZWZlcmVuY2UgdG8gaHR0cDovL29zcy5zZ2kuY29tL3Byb2plY3RzL0ZyZWVCLyBzaGFsbCBiZVxuKiogaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuIFxuKipcbioqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1IgSU1QTElFRCxcbioqIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBXG4qKiBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgU0lMSUNPTiBHUkFQSElDUywgSU5DLlxuKiogQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCxcbioqIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0VcbioqIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbioqIFxuKiogRXhjZXB0IGFzIGNvbnRhaW5lZCBpbiB0aGlzIG5vdGljZSwgdGhlIG5hbWUgb2YgU2lsaWNvbiBHcmFwaGljcywgSW5jLiBzaGFsbCBub3RcbioqIGJlIHVzZWQgaW4gYWR2ZXJ0aXNpbmcgb3Igb3RoZXJ3aXNlIHRvIHByb21vdGUgdGhlIHNhbGUsIHVzZSBvciBvdGhlciBkZWFsaW5ncyBpblxuKiogdGhpcyBTb2Z0d2FyZSB3aXRob3V0IHByaW9yIHdyaXR0ZW4gYXV0aG9yaXphdGlvbiBmcm9tIFNpbGljb24gR3JhcGhpY3MsIEluYy5cbiovXG4vKlxuKiogQXV0aG9yOiBNaWtrbyBNb25vbmVuLCBBdWcgMjAxMy5cbioqIFRoZSBjb2RlIGlzIGJhc2VkIG9uIEdMVSBsaWJ0ZXNzIGJ5IEVyaWMgVmVhY2gsIEp1bHkgMTk5NFxuKi9cblxuXHRcInVzZSBzdHJpY3RcIjtcblxuXHQvKiBQdWJsaWMgQVBJICovXG5cblx0dmFyIFRlc3MyID0ge307XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBUZXNzMjtcblx0XG5cdFRlc3MyLldJTkRJTkdfT0REID0gMDtcblx0VGVzczIuV0lORElOR19OT05aRVJPID0gMTtcblx0VGVzczIuV0lORElOR19QT1NJVElWRSA9IDI7XG5cdFRlc3MyLldJTkRJTkdfTkVHQVRJVkUgPSAzO1xuXHRUZXNzMi5XSU5ESU5HX0FCU19HRVFfVFdPID0gNDtcblxuXHRUZXNzMi5QT0xZR09OUyA9IDA7XG5cdFRlc3MyLkNPTk5FQ1RFRF9QT0xZR09OUyA9IDE7XG5cdFRlc3MyLkJPVU5EQVJZX0NPTlRPVVJTID0gMjtcblxuXHRUZXNzMi50ZXNzZWxhdGUgPSBmdW5jdGlvbihvcHRzKSB7XG5cdFx0dmFyIGRlYnVnID0gIG9wdHMuZGVidWcgfHwgZmFsc2U7XG5cdFx0dmFyIHRlc3MgPSBuZXcgVGVzc2VsYXRvcigpO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgb3B0cy5jb250b3Vycy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dGVzcy5hZGRDb250b3VyKG9wdHMudmVydGV4U2l6ZSB8fCAyLCBvcHRzLmNvbnRvdXJzW2ldKTtcblx0XHR9XG5cdFx0dGVzcy50ZXNzZWxhdGUob3B0cy53aW5kaW5nUnVsZSB8fCBUZXNzMi5XSU5ESU5HX09ERCxcblx0XHRcdFx0XHQgICBvcHRzLmVsZW1lbnRUeXBlIHx8IFRlc3MyLlBPTFlHT05TLFxuXHRcdFx0XHRcdCAgIG9wdHMucG9seVNpemUgfHwgMyxcblx0XHRcdFx0XHQgICBvcHRzLnZlcnRleFNpemUgfHwgMixcblx0XHRcdFx0XHQgICBvcHRzLm5vcm1hbCB8fCBbMCwwLDFdKTtcblx0XHRyZXR1cm4ge1xuXHRcdFx0dmVydGljZXM6IHRlc3MudmVydGljZXMsXG5cdFx0XHR2ZXJ0ZXhJbmRpY2VzOiB0ZXNzLnZlcnRleEluZGljZXMsXG5cdFx0XHR2ZXJ0ZXhDb3VudDogdGVzcy52ZXJ0ZXhDb3VudCxcblx0XHRcdGVsZW1lbnRzOiB0ZXNzLmVsZW1lbnRzLFxuXHRcdFx0ZWxlbWVudENvdW50OiB0ZXNzLmVsZW1lbnRDb3VudCxcblx0XHRcdG1lc2g6IGRlYnVnID8gdGVzcy5tZXNoIDogdW5kZWZpbmVkXG5cdFx0fTtcblx0fTtcblxuXHQvKiBJbnRlcm5hbCAqL1xuXG5cdHZhciBhc3NlcnQgPSBmdW5jdGlvbihjb25kKSB7XG5cdFx0aWYgKCFjb25kKSB7XG5cdFx0XHR0aHJvdyBcIkFzc2VydGlvbiBGYWlsZWQhXCI7XG5cdFx0fVxuXHR9XG5cblx0LyogVGhlIG1lc2ggc3RydWN0dXJlIGlzIHNpbWlsYXIgaW4gc3Bpcml0LCBub3RhdGlvbiwgYW5kIG9wZXJhdGlvbnNcblx0KiB0byB0aGUgXCJxdWFkLWVkZ2VcIiBzdHJ1Y3R1cmUgKHNlZSBMLiBHdWliYXMgYW5kIEouIFN0b2xmaSwgUHJpbWl0aXZlc1xuXHQqIGZvciB0aGUgbWFuaXB1bGF0aW9uIG9mIGdlbmVyYWwgc3ViZGl2aXNpb25zIGFuZCB0aGUgY29tcHV0YXRpb24gb2Zcblx0KiBWb3Jvbm9pIGRpYWdyYW1zLCBBQ00gVHJhbnNhY3Rpb25zIG9uIEdyYXBoaWNzLCA0KDIpOjc0LTEyMywgQXByaWwgMTk4NSkuXG5cdCogRm9yIGEgc2ltcGxpZmllZCBkZXNjcmlwdGlvbiwgc2VlIHRoZSBjb3Vyc2Ugbm90ZXMgZm9yIENTMzQ4YSxcblx0KiBcIk1hdGhlbWF0aWNhbCBGb3VuZGF0aW9ucyBvZiBDb21wdXRlciBHcmFwaGljc1wiLCBhdmFpbGFibGUgYXQgdGhlXG5cdCogU3RhbmZvcmQgYm9va3N0b3JlIChhbmQgdGF1Z2h0IGR1cmluZyB0aGUgZmFsbCBxdWFydGVyKS5cblx0KiBUaGUgaW1wbGVtZW50YXRpb24gYWxzbyBib3Jyb3dzIGEgdGlueSBzdWJzZXQgb2YgdGhlIGdyYXBoLWJhc2VkIGFwcHJvYWNoXG5cdCogdXNlIGluIE1hbnR5bGEncyBHZW9tZXRyaWMgV29yayBCZW5jaCAoc2VlIE0uIE1hbnR5bGEsIEFuIEludHJvZHVjdGlvblxuXHQqIHRvIFNvbGQgTW9kZWxpbmcsIENvbXB1dGVyIFNjaWVuY2UgUHJlc3MsIFJvY2t2aWxsZSwgTWFyeWxhbmQsIDE5ODgpLlxuXHQqXG5cdCogVGhlIGZ1bmRhbWVudGFsIGRhdGEgc3RydWN0dXJlIGlzIHRoZSBcImhhbGYtZWRnZVwiLiAgVHdvIGhhbGYtZWRnZXNcblx0KiBnbyB0b2dldGhlciB0byBtYWtlIGFuIGVkZ2UsIGJ1dCB0aGV5IHBvaW50IGluIG9wcG9zaXRlIGRpcmVjdGlvbnMuXG5cdCogRWFjaCBoYWxmLWVkZ2UgaGFzIGEgcG9pbnRlciB0byBpdHMgbWF0ZSAodGhlIFwic3ltbWV0cmljXCIgaGFsZi1lZGdlIFN5bSksXG5cdCogaXRzIG9yaWdpbiB2ZXJ0ZXggKE9yZyksIHRoZSBmYWNlIG9uIGl0cyBsZWZ0IHNpZGUgKExmYWNlKSwgYW5kIHRoZVxuXHQqIGFkamFjZW50IGhhbGYtZWRnZXMgaW4gdGhlIENDVyBkaXJlY3Rpb24gYXJvdW5kIHRoZSBvcmlnaW4gdmVydGV4XG5cdCogKE9uZXh0KSBhbmQgYXJvdW5kIHRoZSBsZWZ0IGZhY2UgKExuZXh0KS4gIFRoZXJlIGlzIGFsc28gYSBcIm5leHRcIlxuXHQqIHBvaW50ZXIgZm9yIHRoZSBnbG9iYWwgZWRnZSBsaXN0IChzZWUgYmVsb3cpLlxuXHQqXG5cdCogVGhlIG5vdGF0aW9uIHVzZWQgZm9yIG1lc2ggbmF2aWdhdGlvbjpcblx0KiAgU3ltICAgPSB0aGUgbWF0ZSBvZiBhIGhhbGYtZWRnZSAoc2FtZSBlZGdlLCBidXQgb3Bwb3NpdGUgZGlyZWN0aW9uKVxuXHQqICBPbmV4dCA9IGVkZ2UgQ0NXIGFyb3VuZCBvcmlnaW4gdmVydGV4IChrZWVwIHNhbWUgb3JpZ2luKVxuXHQqICBEbmV4dCA9IGVkZ2UgQ0NXIGFyb3VuZCBkZXN0aW5hdGlvbiB2ZXJ0ZXggKGtlZXAgc2FtZSBkZXN0KVxuXHQqICBMbmV4dCA9IGVkZ2UgQ0NXIGFyb3VuZCBsZWZ0IGZhY2UgKGRlc3QgYmVjb21lcyBuZXcgb3JpZ2luKVxuXHQqICBSbmV4dCA9IGVkZ2UgQ0NXIGFyb3VuZCByaWdodCBmYWNlIChvcmlnaW4gYmVjb21lcyBuZXcgZGVzdClcblx0KlxuXHQqIFwicHJldlwiIG1lYW5zIHRvIHN1YnN0aXR1dGUgQ1cgZm9yIENDVyBpbiB0aGUgZGVmaW5pdGlvbnMgYWJvdmUuXG5cdCpcblx0KiBUaGUgbWVzaCBrZWVwcyBnbG9iYWwgbGlzdHMgb2YgYWxsIHZlcnRpY2VzLCBmYWNlcywgYW5kIGVkZ2VzLFxuXHQqIHN0b3JlZCBhcyBkb3VibHktbGlua2VkIGNpcmN1bGFyIGxpc3RzIHdpdGggYSBkdW1teSBoZWFkZXIgbm9kZS5cblx0KiBUaGUgbWVzaCBzdG9yZXMgcG9pbnRlcnMgdG8gdGhlc2UgZHVtbXkgaGVhZGVycyAodkhlYWQsIGZIZWFkLCBlSGVhZCkuXG5cdCpcblx0KiBUaGUgY2lyY3VsYXIgZWRnZSBsaXN0IGlzIHNwZWNpYWw7IHNpbmNlIGhhbGYtZWRnZXMgYWx3YXlzIG9jY3VyXG5cdCogaW4gcGFpcnMgKGUgYW5kIGUtPlN5bSksIGVhY2ggaGFsZi1lZGdlIHN0b3JlcyBhIHBvaW50ZXIgaW4gb25seVxuXHQqIG9uZSBkaXJlY3Rpb24uICBTdGFydGluZyBhdCBlSGVhZCBhbmQgZm9sbG93aW5nIHRoZSBlLT5uZXh0IHBvaW50ZXJzXG5cdCogd2lsbCB2aXNpdCBlYWNoICplZGdlKiBvbmNlIChpZS4gZSBvciBlLT5TeW0sIGJ1dCBub3QgYm90aCkuXG5cdCogZS0+U3ltIHN0b3JlcyBhIHBvaW50ZXIgaW4gdGhlIG9wcG9zaXRlIGRpcmVjdGlvbiwgdGh1cyBpdCBpc1xuXHQqIGFsd2F5cyB0cnVlIHRoYXQgZS0+U3ltLT5uZXh0LT5TeW0tPm5leHQgPT0gZS5cblx0KlxuXHQqIEVhY2ggdmVydGV4IGhhcyBhIHBvaW50ZXIgdG8gbmV4dCBhbmQgcHJldmlvdXMgdmVydGljZXMgaW4gdGhlXG5cdCogY2lyY3VsYXIgbGlzdCwgYW5kIGEgcG9pbnRlciB0byBhIGhhbGYtZWRnZSB3aXRoIHRoaXMgdmVydGV4IGFzXG5cdCogdGhlIG9yaWdpbiAoTlVMTCBpZiB0aGlzIGlzIHRoZSBkdW1teSBoZWFkZXIpLiAgVGhlcmUgaXMgYWxzbyBhXG5cdCogZmllbGQgXCJkYXRhXCIgZm9yIGNsaWVudCBkYXRhLlxuXHQqXG5cdCogRWFjaCBmYWNlIGhhcyBhIHBvaW50ZXIgdG8gdGhlIG5leHQgYW5kIHByZXZpb3VzIGZhY2VzIGluIHRoZVxuXHQqIGNpcmN1bGFyIGxpc3QsIGFuZCBhIHBvaW50ZXIgdG8gYSBoYWxmLWVkZ2Ugd2l0aCB0aGlzIGZhY2UgYXNcblx0KiB0aGUgbGVmdCBmYWNlIChOVUxMIGlmIHRoaXMgaXMgdGhlIGR1bW15IGhlYWRlcikuICBUaGVyZSBpcyBhbHNvXG5cdCogYSBmaWVsZCBcImRhdGFcIiBmb3IgY2xpZW50IGRhdGEuXG5cdCpcblx0KiBOb3RlIHRoYXQgd2hhdCB3ZSBjYWxsIGEgXCJmYWNlXCIgaXMgcmVhbGx5IGEgbG9vcDsgZmFjZXMgbWF5IGNvbnNpc3Rcblx0KiBvZiBtb3JlIHRoYW4gb25lIGxvb3AgKGllLiBub3Qgc2ltcGx5IGNvbm5lY3RlZCksIGJ1dCB0aGVyZSBpcyBub1xuXHQqIHJlY29yZCBvZiB0aGlzIGluIHRoZSBkYXRhIHN0cnVjdHVyZS4gIFRoZSBtZXNoIG1heSBjb25zaXN0IG9mXG5cdCogc2V2ZXJhbCBkaXNjb25uZWN0ZWQgcmVnaW9ucywgc28gaXQgbWF5IG5vdCBiZSBwb3NzaWJsZSB0byB2aXNpdFxuXHQqIHRoZSBlbnRpcmUgbWVzaCBieSBzdGFydGluZyBhdCBhIGhhbGYtZWRnZSBhbmQgdHJhdmVyc2luZyB0aGUgZWRnZVxuXHQqIHN0cnVjdHVyZS5cblx0KlxuXHQqIFRoZSBtZXNoIGRvZXMgTk9UIHN1cHBvcnQgaXNvbGF0ZWQgdmVydGljZXM7IGEgdmVydGV4IGlzIGRlbGV0ZWQgYWxvbmdcblx0KiB3aXRoIGl0cyBsYXN0IGVkZ2UuICBTaW1pbGFybHkgd2hlbiB0d28gZmFjZXMgYXJlIG1lcmdlZCwgb25lIG9mIHRoZVxuXHQqIGZhY2VzIGlzIGRlbGV0ZWQgKHNlZSB0ZXNzTWVzaERlbGV0ZSBiZWxvdykuICBGb3IgbWVzaCBvcGVyYXRpb25zLFxuXHQqIGFsbCBmYWNlIChsb29wKSBhbmQgdmVydGV4IHBvaW50ZXJzIG11c3Qgbm90IGJlIE5VTEwuICBIb3dldmVyLCBvbmNlXG5cdCogbWVzaCBtYW5pcHVsYXRpb24gaXMgZmluaXNoZWQsIFRFU1NtZXNoWmFwRmFjZSBjYW4gYmUgdXNlZCB0byBkZWxldGVcblx0KiBmYWNlcyBvZiB0aGUgbWVzaCwgb25lIGF0IGEgdGltZS4gIEFsbCBleHRlcm5hbCBmYWNlcyBjYW4gYmUgXCJ6YXBwZWRcIlxuXHQqIGJlZm9yZSB0aGUgbWVzaCBpcyByZXR1cm5lZCB0byB0aGUgY2xpZW50OyB0aGVuIGEgTlVMTCBmYWNlIGluZGljYXRlc1xuXHQqIGEgcmVnaW9uIHdoaWNoIGlzIG5vdCBwYXJ0IG9mIHRoZSBvdXRwdXQgcG9seWdvbi5cblx0Ki9cblxuXHRmdW5jdGlvbiBURVNTdmVydGV4KCkge1xuXHRcdHRoaXMubmV4dCA9IG51bGw7XHQvKiBuZXh0IHZlcnRleCAobmV2ZXIgTlVMTCkgKi9cblx0XHR0aGlzLnByZXYgPSBudWxsO1x0LyogcHJldmlvdXMgdmVydGV4IChuZXZlciBOVUxMKSAqL1xuXHRcdHRoaXMuYW5FZGdlID0gbnVsbDtcdC8qIGEgaGFsZi1lZGdlIHdpdGggdGhpcyBvcmlnaW4gKi9cblxuXHRcdC8qIEludGVybmFsIGRhdGEgKGtlZXAgaGlkZGVuKSAqL1xuXHRcdHRoaXMuY29vcmRzID0gWzAsMCwwXTtcdC8qIHZlcnRleCBsb2NhdGlvbiBpbiAzRCAqL1xuXHRcdHRoaXMucyA9IDAuMDtcblx0XHR0aGlzLnQgPSAwLjA7XHRcdFx0LyogcHJvamVjdGlvbiBvbnRvIHRoZSBzd2VlcCBwbGFuZSAqL1xuXHRcdHRoaXMucHFIYW5kbGUgPSAwO1x0XHQvKiB0byBhbGxvdyBkZWxldGlvbiBmcm9tIHByaW9yaXR5IHF1ZXVlICovXG5cdFx0dGhpcy5uID0gMDtcdFx0XHRcdC8qIHRvIGFsbG93IGlkZW50aWZ5IHVuaXF1ZSB2ZXJ0aWNlcyAqL1xuXHRcdHRoaXMuaWR4ID0gMDtcdFx0XHQvKiB0byBhbGxvdyBtYXAgcmVzdWx0IHRvIG9yaWdpbmFsIHZlcnRzICovXG5cdH0gXG5cblx0ZnVuY3Rpb24gVEVTU2ZhY2UoKSB7XG5cdFx0dGhpcy5uZXh0ID0gbnVsbDtcdFx0LyogbmV4dCBmYWNlIChuZXZlciBOVUxMKSAqL1xuXHRcdHRoaXMucHJldiA9IG51bGw7XHRcdC8qIHByZXZpb3VzIGZhY2UgKG5ldmVyIE5VTEwpICovXG5cdFx0dGhpcy5hbkVkZ2UgPSBudWxsO1x0XHQvKiBhIGhhbGYgZWRnZSB3aXRoIHRoaXMgbGVmdCBmYWNlICovXG5cblx0XHQvKiBJbnRlcm5hbCBkYXRhIChrZWVwIGhpZGRlbikgKi9cblx0XHR0aGlzLnRyYWlsID0gbnVsbDtcdFx0LyogXCJzdGFja1wiIGZvciBjb252ZXJzaW9uIHRvIHN0cmlwcyAqL1xuXHRcdHRoaXMubiA9IDA7XHRcdFx0XHQvKiB0byBhbGxvdyBpZGVudGl5IHVuaXF1ZSBmYWNlcyAqL1xuXHRcdHRoaXMubWFya2VkID0gZmFsc2U7XHQvKiBmbGFnIGZvciBjb252ZXJzaW9uIHRvIHN0cmlwcyAqL1xuXHRcdHRoaXMuaW5zaWRlID0gZmFsc2U7XHQvKiB0aGlzIGZhY2UgaXMgaW4gdGhlIHBvbHlnb24gaW50ZXJpb3IgKi9cblx0fTtcblxuXHRmdW5jdGlvbiBURVNTaGFsZkVkZ2Uoc2lkZSkge1xuXHRcdHRoaXMubmV4dCA9IG51bGw7XHRcdC8qIGRvdWJseS1saW5rZWQgbGlzdCAocHJldj09U3ltLT5uZXh0KSAqL1xuXHRcdHRoaXMuU3ltID0gbnVsbDtcdFx0Lyogc2FtZSBlZGdlLCBvcHBvc2l0ZSBkaXJlY3Rpb24gKi9cblx0XHR0aGlzLk9uZXh0ID0gbnVsbDtcdFx0LyogbmV4dCBlZGdlIENDVyBhcm91bmQgb3JpZ2luICovXG5cdFx0dGhpcy5MbmV4dCA9IG51bGw7XHRcdC8qIG5leHQgZWRnZSBDQ1cgYXJvdW5kIGxlZnQgZmFjZSAqL1xuXHRcdHRoaXMuT3JnID0gbnVsbDtcdFx0Lyogb3JpZ2luIHZlcnRleCAoT3ZlcnRleCB0b28gbG9uZykgKi9cblx0XHR0aGlzLkxmYWNlID0gbnVsbDtcdFx0LyogbGVmdCBmYWNlICovXG5cblx0XHQvKiBJbnRlcm5hbCBkYXRhIChrZWVwIGhpZGRlbikgKi9cblx0XHR0aGlzLmFjdGl2ZVJlZ2lvbiA9IG51bGw7XHQvKiBhIHJlZ2lvbiB3aXRoIHRoaXMgdXBwZXIgZWRnZSAoc3dlZXAuYykgKi9cblx0XHR0aGlzLndpbmRpbmcgPSAwO1x0XHRcdC8qIGNoYW5nZSBpbiB3aW5kaW5nIG51bWJlciB3aGVuIGNyb3NzaW5nXG5cdFx0XHRcdFx0XHRcdFx0XHQgICBmcm9tIHRoZSByaWdodCBmYWNlIHRvIHRoZSBsZWZ0IGZhY2UgKi9cblx0XHR0aGlzLnNpZGUgPSBzaWRlO1xuXHR9O1xuXG5cdFRFU1NoYWxmRWRnZS5wcm90b3R5cGUgPSB7XG5cdFx0Z2V0IFJmYWNlKCkgeyByZXR1cm4gdGhpcy5TeW0uTGZhY2U7IH0sXG5cdFx0c2V0IFJmYWNlKHYpIHsgdGhpcy5TeW0uTGZhY2UgPSB2OyB9LFxuXHRcdGdldCBEc3QoKSB7IHJldHVybiB0aGlzLlN5bS5Pcmc7IH0sXG5cdFx0c2V0IERzdCh2KSB7IHRoaXMuU3ltLk9yZyA9IHY7IH0sXG5cdFx0Z2V0IE9wcmV2KCkgeyByZXR1cm4gdGhpcy5TeW0uTG5leHQ7IH0sXG5cdFx0c2V0IE9wcmV2KHYpIHsgdGhpcy5TeW0uTG5leHQgPSB2OyB9LFxuXHRcdGdldCBMcHJldigpIHsgcmV0dXJuIHRoaXMuT25leHQuU3ltOyB9LFxuXHRcdHNldCBMcHJldih2KSB7IHRoaXMuT25leHQuU3ltID0gdjsgfSxcblx0XHRnZXQgRHByZXYoKSB7IHJldHVybiB0aGlzLkxuZXh0LlN5bTsgfSxcblx0XHRzZXQgRHByZXYodikgeyB0aGlzLkxuZXh0LlN5bSA9IHY7IH0sXG5cdFx0Z2V0IFJwcmV2KCkgeyByZXR1cm4gdGhpcy5TeW0uT25leHQ7IH0sXG5cdFx0c2V0IFJwcmV2KHYpIHsgdGhpcy5TeW0uT25leHQgPSB2OyB9LFxuXHRcdGdldCBEbmV4dCgpIHsgcmV0dXJuIC8qdGhpcy5ScHJldiovdGhpcy5TeW0uT25leHQuU3ltOyB9LCAgLyogMyBwb2ludGVycyAqL1xuXHRcdHNldCBEbmV4dCh2KSB7IC8qdGhpcy5ScHJldiovdGhpcy5TeW0uT25leHQuU3ltID0gdjsgfSwgIC8qIDMgcG9pbnRlcnMgKi9cblx0XHRnZXQgUm5leHQoKSB7IHJldHVybiAvKnRoaXMuT3ByZXYqL3RoaXMuU3ltLkxuZXh0LlN5bTsgfSwgIC8qIDMgcG9pbnRlcnMgKi9cblx0XHRzZXQgUm5leHQodikgeyAvKnRoaXMuT3ByZXYqL3RoaXMuU3ltLkxuZXh0LlN5bSA9IHY7IH0sICAvKiAzIHBvaW50ZXJzICovXG5cdH07XG5cblxuXG5cdGZ1bmN0aW9uIFRFU1NtZXNoKCkge1xuXHRcdHZhciB2ID0gbmV3IFRFU1N2ZXJ0ZXgoKTtcblx0XHR2YXIgZiA9IG5ldyBURVNTZmFjZSgpO1xuXHRcdHZhciBlID0gbmV3IFRFU1NoYWxmRWRnZSgwKTtcblx0XHR2YXIgZVN5bSA9IG5ldyBURVNTaGFsZkVkZ2UoMSk7XG5cblx0XHR2Lm5leHQgPSB2LnByZXYgPSB2O1xuXHRcdHYuYW5FZGdlID0gbnVsbDtcblxuXHRcdGYubmV4dCA9IGYucHJldiA9IGY7XG5cdFx0Zi5hbkVkZ2UgPSBudWxsO1xuXHRcdGYudHJhaWwgPSBudWxsO1xuXHRcdGYubWFya2VkID0gZmFsc2U7XG5cdFx0Zi5pbnNpZGUgPSBmYWxzZTtcblxuXHRcdGUubmV4dCA9IGU7XG5cdFx0ZS5TeW0gPSBlU3ltO1xuXHRcdGUuT25leHQgPSBudWxsO1xuXHRcdGUuTG5leHQgPSBudWxsO1xuXHRcdGUuT3JnID0gbnVsbDtcblx0XHRlLkxmYWNlID0gbnVsbDtcblx0XHRlLndpbmRpbmcgPSAwO1xuXHRcdGUuYWN0aXZlUmVnaW9uID0gbnVsbDtcblxuXHRcdGVTeW0ubmV4dCA9IGVTeW07XG5cdFx0ZVN5bS5TeW0gPSBlO1xuXHRcdGVTeW0uT25leHQgPSBudWxsO1xuXHRcdGVTeW0uTG5leHQgPSBudWxsO1xuXHRcdGVTeW0uT3JnID0gbnVsbDtcblx0XHRlU3ltLkxmYWNlID0gbnVsbDtcblx0XHRlU3ltLndpbmRpbmcgPSAwO1xuXHRcdGVTeW0uYWN0aXZlUmVnaW9uID0gbnVsbDtcblxuXHRcdHRoaXMudkhlYWQgPSB2O1x0XHQvKiBkdW1teSBoZWFkZXIgZm9yIHZlcnRleCBsaXN0ICovXG5cdFx0dGhpcy5mSGVhZCA9IGY7XHRcdC8qIGR1bW15IGhlYWRlciBmb3IgZmFjZSBsaXN0ICovXG5cdFx0dGhpcy5lSGVhZCA9IGU7XHRcdC8qIGR1bW15IGhlYWRlciBmb3IgZWRnZSBsaXN0ICovXG5cdFx0dGhpcy5lSGVhZFN5bSA9IGVTeW07XHQvKiBhbmQgaXRzIHN5bW1ldHJpYyBjb3VudGVycGFydCAqL1xuXHR9O1xuXG5cdC8qIFRoZSBtZXNoIG9wZXJhdGlvbnMgYmVsb3cgaGF2ZSB0aHJlZSBtb3RpdmF0aW9uczogY29tcGxldGVuZXNzLFxuXHQqIGNvbnZlbmllbmNlLCBhbmQgZWZmaWNpZW5jeS4gIFRoZSBiYXNpYyBtZXNoIG9wZXJhdGlvbnMgYXJlIE1ha2VFZGdlLFxuXHQqIFNwbGljZSwgYW5kIERlbGV0ZS4gIEFsbCB0aGUgb3RoZXIgZWRnZSBvcGVyYXRpb25zIGNhbiBiZSBpbXBsZW1lbnRlZFxuXHQqIGluIHRlcm1zIG9mIHRoZXNlLiAgVGhlIG90aGVyIG9wZXJhdGlvbnMgYXJlIHByb3ZpZGVkIGZvciBjb252ZW5pZW5jZVxuXHQqIGFuZC9vciBlZmZpY2llbmN5LlxuXHQqXG5cdCogV2hlbiBhIGZhY2UgaXMgc3BsaXQgb3IgYSB2ZXJ0ZXggaXMgYWRkZWQsIHRoZXkgYXJlIGluc2VydGVkIGludG8gdGhlXG5cdCogZ2xvYmFsIGxpc3QgKmJlZm9yZSogdGhlIGV4aXN0aW5nIHZlcnRleCBvciBmYWNlIChpZS4gZS0+T3JnIG9yIGUtPkxmYWNlKS5cblx0KiBUaGlzIG1ha2VzIGl0IGVhc2llciB0byBwcm9jZXNzIGFsbCB2ZXJ0aWNlcyBvciBmYWNlcyBpbiB0aGUgZ2xvYmFsIGxpc3RzXG5cdCogd2l0aG91dCB3b3JyeWluZyBhYm91dCBwcm9jZXNzaW5nIHRoZSBzYW1lIGRhdGEgdHdpY2UuICBBcyBhIGNvbnZlbmllbmNlLFxuXHQqIHdoZW4gYSBmYWNlIGlzIHNwbGl0LCB0aGUgXCJpbnNpZGVcIiBmbGFnIGlzIGNvcGllZCBmcm9tIHRoZSBvbGQgZmFjZS5cblx0KiBPdGhlciBpbnRlcm5hbCBkYXRhICh2LT5kYXRhLCB2LT5hY3RpdmVSZWdpb24sIGYtPmRhdGEsIGYtPm1hcmtlZCxcblx0KiBmLT50cmFpbCwgZS0+d2luZGluZykgaXMgc2V0IHRvIHplcm8uXG5cdCpcblx0KiAqKioqKioqKioqKioqKioqKioqKioqIEJhc2ljIEVkZ2UgT3BlcmF0aW9ucyAqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXHQqXG5cdCogdGVzc01lc2hNYWtlRWRnZSggbWVzaCApIGNyZWF0ZXMgb25lIGVkZ2UsIHR3byB2ZXJ0aWNlcywgYW5kIGEgbG9vcC5cblx0KiBUaGUgbG9vcCAoZmFjZSkgY29uc2lzdHMgb2YgdGhlIHR3byBuZXcgaGFsZi1lZGdlcy5cblx0KlxuXHQqIHRlc3NNZXNoU3BsaWNlKCBlT3JnLCBlRHN0ICkgaXMgdGhlIGJhc2ljIG9wZXJhdGlvbiBmb3IgY2hhbmdpbmcgdGhlXG5cdCogbWVzaCBjb25uZWN0aXZpdHkgYW5kIHRvcG9sb2d5LiAgSXQgY2hhbmdlcyB0aGUgbWVzaCBzbyB0aGF0XG5cdCogIGVPcmctPk9uZXh0IDwtIE9MRCggZURzdC0+T25leHQgKVxuXHQqICBlRHN0LT5PbmV4dCA8LSBPTEQoIGVPcmctPk9uZXh0IClcblx0KiB3aGVyZSBPTEQoLi4uKSBtZWFucyB0aGUgdmFsdWUgYmVmb3JlIHRoZSBtZXNoU3BsaWNlIG9wZXJhdGlvbi5cblx0KlxuXHQqIFRoaXMgY2FuIGhhdmUgdHdvIGVmZmVjdHMgb24gdGhlIHZlcnRleCBzdHJ1Y3R1cmU6XG5cdCogIC0gaWYgZU9yZy0+T3JnICE9IGVEc3QtPk9yZywgdGhlIHR3byB2ZXJ0aWNlcyBhcmUgbWVyZ2VkIHRvZ2V0aGVyXG5cdCogIC0gaWYgZU9yZy0+T3JnID09IGVEc3QtPk9yZywgdGhlIG9yaWdpbiBpcyBzcGxpdCBpbnRvIHR3byB2ZXJ0aWNlc1xuXHQqIEluIGJvdGggY2FzZXMsIGVEc3QtPk9yZyBpcyBjaGFuZ2VkIGFuZCBlT3JnLT5PcmcgaXMgdW50b3VjaGVkLlxuXHQqXG5cdCogU2ltaWxhcmx5IChhbmQgaW5kZXBlbmRlbnRseSkgZm9yIHRoZSBmYWNlIHN0cnVjdHVyZSxcblx0KiAgLSBpZiBlT3JnLT5MZmFjZSA9PSBlRHN0LT5MZmFjZSwgb25lIGxvb3AgaXMgc3BsaXQgaW50byB0d29cblx0KiAgLSBpZiBlT3JnLT5MZmFjZSAhPSBlRHN0LT5MZmFjZSwgdHdvIGRpc3RpbmN0IGxvb3BzIGFyZSBqb2luZWQgaW50byBvbmVcblx0KiBJbiBib3RoIGNhc2VzLCBlRHN0LT5MZmFjZSBpcyBjaGFuZ2VkIGFuZCBlT3JnLT5MZmFjZSBpcyB1bmFmZmVjdGVkLlxuXHQqXG5cdCogdGVzc01lc2hEZWxldGUoIGVEZWwgKSByZW1vdmVzIHRoZSBlZGdlIGVEZWwuICBUaGVyZSBhcmUgc2V2ZXJhbCBjYXNlczpcblx0KiBpZiAoZURlbC0+TGZhY2UgIT0gZURlbC0+UmZhY2UpLCB3ZSBqb2luIHR3byBsb29wcyBpbnRvIG9uZTsgdGhlIGxvb3Bcblx0KiBlRGVsLT5MZmFjZSBpcyBkZWxldGVkLiAgT3RoZXJ3aXNlLCB3ZSBhcmUgc3BsaXR0aW5nIG9uZSBsb29wIGludG8gdHdvO1xuXHQqIHRoZSBuZXdseSBjcmVhdGVkIGxvb3Agd2lsbCBjb250YWluIGVEZWwtPkRzdC4gIElmIHRoZSBkZWxldGlvbiBvZiBlRGVsXG5cdCogd291bGQgY3JlYXRlIGlzb2xhdGVkIHZlcnRpY2VzLCB0aG9zZSBhcmUgZGVsZXRlZCBhcyB3ZWxsLlxuXHQqXG5cdCogKioqKioqKioqKioqKioqKioqKioqKiBPdGhlciBFZGdlIE9wZXJhdGlvbnMgKioqKioqKioqKioqKioqKioqKioqKioqKipcblx0KlxuXHQqIHRlc3NNZXNoQWRkRWRnZVZlcnRleCggZU9yZyApIGNyZWF0ZXMgYSBuZXcgZWRnZSBlTmV3IHN1Y2ggdGhhdFxuXHQqIGVOZXcgPT0gZU9yZy0+TG5leHQsIGFuZCBlTmV3LT5Ec3QgaXMgYSBuZXdseSBjcmVhdGVkIHZlcnRleC5cblx0KiBlT3JnIGFuZCBlTmV3IHdpbGwgaGF2ZSB0aGUgc2FtZSBsZWZ0IGZhY2UuXG5cdCpcblx0KiB0ZXNzTWVzaFNwbGl0RWRnZSggZU9yZyApIHNwbGl0cyBlT3JnIGludG8gdHdvIGVkZ2VzIGVPcmcgYW5kIGVOZXcsXG5cdCogc3VjaCB0aGF0IGVOZXcgPT0gZU9yZy0+TG5leHQuICBUaGUgbmV3IHZlcnRleCBpcyBlT3JnLT5Ec3QgPT0gZU5ldy0+T3JnLlxuXHQqIGVPcmcgYW5kIGVOZXcgd2lsbCBoYXZlIHRoZSBzYW1lIGxlZnQgZmFjZS5cblx0KlxuXHQqIHRlc3NNZXNoQ29ubmVjdCggZU9yZywgZURzdCApIGNyZWF0ZXMgYSBuZXcgZWRnZSBmcm9tIGVPcmctPkRzdFxuXHQqIHRvIGVEc3QtPk9yZywgYW5kIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgaGFsZi1lZGdlIGVOZXcuXG5cdCogSWYgZU9yZy0+TGZhY2UgPT0gZURzdC0+TGZhY2UsIHRoaXMgc3BsaXRzIG9uZSBsb29wIGludG8gdHdvLFxuXHQqIGFuZCB0aGUgbmV3bHkgY3JlYXRlZCBsb29wIGlzIGVOZXctPkxmYWNlLiAgT3RoZXJ3aXNlLCB0d28gZGlzam9pbnRcblx0KiBsb29wcyBhcmUgbWVyZ2VkIGludG8gb25lLCBhbmQgdGhlIGxvb3AgZURzdC0+TGZhY2UgaXMgZGVzdHJveWVkLlxuXHQqXG5cdCogKioqKioqKioqKioqKioqKioqKioqKioqIE90aGVyIE9wZXJhdGlvbnMgKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblx0KlxuXHQqIHRlc3NNZXNoTmV3TWVzaCgpIGNyZWF0ZXMgYSBuZXcgbWVzaCB3aXRoIG5vIGVkZ2VzLCBubyB2ZXJ0aWNlcyxcblx0KiBhbmQgbm8gbG9vcHMgKHdoYXQgd2UgdXN1YWxseSBjYWxsIGEgXCJmYWNlXCIpLlxuXHQqXG5cdCogdGVzc01lc2hVbmlvbiggbWVzaDEsIG1lc2gyICkgZm9ybXMgdGhlIHVuaW9uIG9mIGFsbCBzdHJ1Y3R1cmVzIGluXG5cdCogYm90aCBtZXNoZXMsIGFuZCByZXR1cm5zIHRoZSBuZXcgbWVzaCAodGhlIG9sZCBtZXNoZXMgYXJlIGRlc3Ryb3llZCkuXG5cdCpcblx0KiB0ZXNzTWVzaERlbGV0ZU1lc2goIG1lc2ggKSB3aWxsIGZyZWUgYWxsIHN0b3JhZ2UgZm9yIGFueSB2YWxpZCBtZXNoLlxuXHQqXG5cdCogdGVzc01lc2haYXBGYWNlKCBmWmFwICkgZGVzdHJveXMgYSBmYWNlIGFuZCByZW1vdmVzIGl0IGZyb20gdGhlXG5cdCogZ2xvYmFsIGZhY2UgbGlzdC4gIEFsbCBlZGdlcyBvZiBmWmFwIHdpbGwgaGF2ZSBhIE5VTEwgcG9pbnRlciBhcyB0aGVpclxuXHQqIGxlZnQgZmFjZS4gIEFueSBlZGdlcyB3aGljaCBhbHNvIGhhdmUgYSBOVUxMIHBvaW50ZXIgYXMgdGhlaXIgcmlnaHQgZmFjZVxuXHQqIGFyZSBkZWxldGVkIGVudGlyZWx5IChhbG9uZyB3aXRoIGFueSBpc29sYXRlZCB2ZXJ0aWNlcyB0aGlzIHByb2R1Y2VzKS5cblx0KiBBbiBlbnRpcmUgbWVzaCBjYW4gYmUgZGVsZXRlZCBieSB6YXBwaW5nIGl0cyBmYWNlcywgb25lIGF0IGEgdGltZSxcblx0KiBpbiBhbnkgb3JkZXIuICBaYXBwZWQgZmFjZXMgY2Fubm90IGJlIHVzZWQgaW4gZnVydGhlciBtZXNoIG9wZXJhdGlvbnMhXG5cdCpcblx0KiB0ZXNzTWVzaENoZWNrTWVzaCggbWVzaCApIGNoZWNrcyBhIG1lc2ggZm9yIHNlbGYtY29uc2lzdGVuY3kuXG5cdCovXG5cblx0VEVTU21lc2gucHJvdG90eXBlID0ge1xuXG5cdFx0LyogTWFrZUVkZ2UgY3JlYXRlcyBhIG5ldyBwYWlyIG9mIGhhbGYtZWRnZXMgd2hpY2ggZm9ybSB0aGVpciBvd24gbG9vcC5cblx0XHQqIE5vIHZlcnRleCBvciBmYWNlIHN0cnVjdHVyZXMgYXJlIGFsbG9jYXRlZCwgYnV0IHRoZXNlIG11c3QgYmUgYXNzaWduZWRcblx0XHQqIGJlZm9yZSB0aGUgY3VycmVudCBlZGdlIG9wZXJhdGlvbiBpcyBjb21wbGV0ZWQuXG5cdFx0Ki9cblx0XHQvL3N0YXRpYyBURVNTaGFsZkVkZ2UgKk1ha2VFZGdlKCBURVNTbWVzaCogbWVzaCwgVEVTU2hhbGZFZGdlICplTmV4dCApXG5cdFx0bWFrZUVkZ2VfOiBmdW5jdGlvbihlTmV4dCkge1xuXHRcdFx0dmFyIGUgPSBuZXcgVEVTU2hhbGZFZGdlKDApO1xuXHRcdFx0dmFyIGVTeW0gPSBuZXcgVEVTU2hhbGZFZGdlKDEpO1xuXG5cdFx0XHQvKiBNYWtlIHN1cmUgZU5leHQgcG9pbnRzIHRvIHRoZSBmaXJzdCBlZGdlIG9mIHRoZSBlZGdlIHBhaXIgKi9cblx0XHRcdGlmKCBlTmV4dC5TeW0uc2lkZSA8IGVOZXh0LnNpZGUgKSB7IGVOZXh0ID0gZU5leHQuU3ltOyB9XG5cblx0XHRcdC8qIEluc2VydCBpbiBjaXJjdWxhciBkb3VibHktbGlua2VkIGxpc3QgYmVmb3JlIGVOZXh0LlxuXHRcdFx0KiBOb3RlIHRoYXQgdGhlIHByZXYgcG9pbnRlciBpcyBzdG9yZWQgaW4gU3ltLT5uZXh0LlxuXHRcdFx0Ki9cblx0XHRcdHZhciBlUHJldiA9IGVOZXh0LlN5bS5uZXh0O1xuXHRcdFx0ZVN5bS5uZXh0ID0gZVByZXY7XG5cdFx0XHRlUHJldi5TeW0ubmV4dCA9IGU7XG5cdFx0XHRlLm5leHQgPSBlTmV4dDtcblx0XHRcdGVOZXh0LlN5bS5uZXh0ID0gZVN5bTtcblxuXHRcdFx0ZS5TeW0gPSBlU3ltO1xuXHRcdFx0ZS5PbmV4dCA9IGU7XG5cdFx0XHRlLkxuZXh0ID0gZVN5bTtcblx0XHRcdGUuT3JnID0gbnVsbDtcblx0XHRcdGUuTGZhY2UgPSBudWxsO1xuXHRcdFx0ZS53aW5kaW5nID0gMDtcblx0XHRcdGUuYWN0aXZlUmVnaW9uID0gbnVsbDtcblxuXHRcdFx0ZVN5bS5TeW0gPSBlO1xuXHRcdFx0ZVN5bS5PbmV4dCA9IGVTeW07XG5cdFx0XHRlU3ltLkxuZXh0ID0gZTtcblx0XHRcdGVTeW0uT3JnID0gbnVsbDtcblx0XHRcdGVTeW0uTGZhY2UgPSBudWxsO1xuXHRcdFx0ZVN5bS53aW5kaW5nID0gMDtcblx0XHRcdGVTeW0uYWN0aXZlUmVnaW9uID0gbnVsbDtcblxuXHRcdFx0cmV0dXJuIGU7XG5cdFx0fSxcblxuXHRcdC8qIFNwbGljZSggYSwgYiApIGlzIGJlc3QgZGVzY3JpYmVkIGJ5IHRoZSBHdWliYXMvU3RvbGZpIHBhcGVyIG9yIHRoZVxuXHRcdCogQ1MzNDhhIG5vdGVzIChzZWUgbWVzaC5oKS4gIEJhc2ljYWxseSBpdCBtb2RpZmllcyB0aGUgbWVzaCBzbyB0aGF0XG5cdFx0KiBhLT5PbmV4dCBhbmQgYi0+T25leHQgYXJlIGV4Y2hhbmdlZC4gIFRoaXMgY2FuIGhhdmUgdmFyaW91cyBlZmZlY3RzXG5cdFx0KiBkZXBlbmRpbmcgb24gd2hldGhlciBhIGFuZCBiIGJlbG9uZyB0byBkaWZmZXJlbnQgZmFjZSBvciB2ZXJ0ZXggcmluZ3MuXG5cdFx0KiBGb3IgbW9yZSBleHBsYW5hdGlvbiBzZWUgdGVzc01lc2hTcGxpY2UoKSBiZWxvdy5cblx0XHQqL1xuXHRcdC8vIHN0YXRpYyB2b2lkIFNwbGljZSggVEVTU2hhbGZFZGdlICphLCBURVNTaGFsZkVkZ2UgKmIgKVxuXHRcdHNwbGljZV86IGZ1bmN0aW9uKGEsIGIpIHtcblx0XHRcdHZhciBhT25leHQgPSBhLk9uZXh0O1xuXHRcdFx0dmFyIGJPbmV4dCA9IGIuT25leHQ7XG5cdFx0XHRhT25leHQuU3ltLkxuZXh0ID0gYjtcblx0XHRcdGJPbmV4dC5TeW0uTG5leHQgPSBhO1xuXHRcdFx0YS5PbmV4dCA9IGJPbmV4dDtcblx0XHRcdGIuT25leHQgPSBhT25leHQ7XG5cdFx0fSxcblxuXHRcdC8qIE1ha2VWZXJ0ZXgoIG5ld1ZlcnRleCwgZU9yaWcsIHZOZXh0ICkgYXR0YWNoZXMgYSBuZXcgdmVydGV4IGFuZCBtYWtlcyBpdCB0aGVcblx0XHQqIG9yaWdpbiBvZiBhbGwgZWRnZXMgaW4gdGhlIHZlcnRleCBsb29wIHRvIHdoaWNoIGVPcmlnIGJlbG9uZ3MuIFwidk5leHRcIiBnaXZlc1xuXHRcdCogYSBwbGFjZSB0byBpbnNlcnQgdGhlIG5ldyB2ZXJ0ZXggaW4gdGhlIGdsb2JhbCB2ZXJ0ZXggbGlzdC4gIFdlIGluc2VydFxuXHRcdCogdGhlIG5ldyB2ZXJ0ZXggKmJlZm9yZSogdk5leHQgc28gdGhhdCBhbGdvcml0aG1zIHdoaWNoIHdhbGsgdGhlIHZlcnRleFxuXHRcdCogbGlzdCB3aWxsIG5vdCBzZWUgdGhlIG5ld2x5IGNyZWF0ZWQgdmVydGljZXMuXG5cdFx0Ki9cblx0XHQvL3N0YXRpYyB2b2lkIE1ha2VWZXJ0ZXgoIFRFU1N2ZXJ0ZXggKm5ld1ZlcnRleCwgVEVTU2hhbGZFZGdlICplT3JpZywgVEVTU3ZlcnRleCAqdk5leHQgKVxuXHRcdG1ha2VWZXJ0ZXhfOiBmdW5jdGlvbihuZXdWZXJ0ZXgsIGVPcmlnLCB2TmV4dCkge1xuXHRcdFx0dmFyIHZOZXcgPSBuZXdWZXJ0ZXg7XG5cdFx0XHRhc3NlcnQodk5ldyAhPT0gbnVsbCk7XG5cblx0XHRcdC8qIGluc2VydCBpbiBjaXJjdWxhciBkb3VibHktbGlua2VkIGxpc3QgYmVmb3JlIHZOZXh0ICovXG5cdFx0XHR2YXIgdlByZXYgPSB2TmV4dC5wcmV2O1xuXHRcdFx0dk5ldy5wcmV2ID0gdlByZXY7XG5cdFx0XHR2UHJldi5uZXh0ID0gdk5ldztcblx0XHRcdHZOZXcubmV4dCA9IHZOZXh0O1xuXHRcdFx0dk5leHQucHJldiA9IHZOZXc7XG5cblx0XHRcdHZOZXcuYW5FZGdlID0gZU9yaWc7XG5cdFx0XHQvKiBsZWF2ZSBjb29yZHMsIHMsIHQgdW5kZWZpbmVkICovXG5cblx0XHRcdC8qIGZpeCBvdGhlciBlZGdlcyBvbiB0aGlzIHZlcnRleCBsb29wICovXG5cdFx0XHR2YXIgZSA9IGVPcmlnO1xuXHRcdFx0ZG8ge1xuXHRcdFx0XHRlLk9yZyA9IHZOZXc7XG5cdFx0XHRcdGUgPSBlLk9uZXh0O1xuXHRcdFx0fSB3aGlsZShlICE9PSBlT3JpZyk7XG5cdFx0fSxcblxuXHRcdC8qIE1ha2VGYWNlKCBuZXdGYWNlLCBlT3JpZywgZk5leHQgKSBhdHRhY2hlcyBhIG5ldyBmYWNlIGFuZCBtYWtlcyBpdCB0aGUgbGVmdFxuXHRcdCogZmFjZSBvZiBhbGwgZWRnZXMgaW4gdGhlIGZhY2UgbG9vcCB0byB3aGljaCBlT3JpZyBiZWxvbmdzLiAgXCJmTmV4dFwiIGdpdmVzXG5cdFx0KiBhIHBsYWNlIHRvIGluc2VydCB0aGUgbmV3IGZhY2UgaW4gdGhlIGdsb2JhbCBmYWNlIGxpc3QuICBXZSBpbnNlcnRcblx0XHQqIHRoZSBuZXcgZmFjZSAqYmVmb3JlKiBmTmV4dCBzbyB0aGF0IGFsZ29yaXRobXMgd2hpY2ggd2FsayB0aGUgZmFjZVxuXHRcdCogbGlzdCB3aWxsIG5vdCBzZWUgdGhlIG5ld2x5IGNyZWF0ZWQgZmFjZXMuXG5cdFx0Ki9cblx0XHQvLyBzdGF0aWMgdm9pZCBNYWtlRmFjZSggVEVTU2ZhY2UgKm5ld0ZhY2UsIFRFU1NoYWxmRWRnZSAqZU9yaWcsIFRFU1NmYWNlICpmTmV4dCApXG5cdFx0bWFrZUZhY2VfOiBmdW5jdGlvbihuZXdGYWNlLCBlT3JpZywgZk5leHQpIHtcblx0XHRcdHZhciBmTmV3ID0gbmV3RmFjZTtcblx0XHRcdGFzc2VydChmTmV3ICE9PSBudWxsKTsgXG5cblx0XHRcdC8qIGluc2VydCBpbiBjaXJjdWxhciBkb3VibHktbGlua2VkIGxpc3QgYmVmb3JlIGZOZXh0ICovXG5cdFx0XHR2YXIgZlByZXYgPSBmTmV4dC5wcmV2O1xuXHRcdFx0Zk5ldy5wcmV2ID0gZlByZXY7XG5cdFx0XHRmUHJldi5uZXh0ID0gZk5ldztcblx0XHRcdGZOZXcubmV4dCA9IGZOZXh0O1xuXHRcdFx0Zk5leHQucHJldiA9IGZOZXc7XG5cblx0XHRcdGZOZXcuYW5FZGdlID0gZU9yaWc7XG5cdFx0XHRmTmV3LnRyYWlsID0gbnVsbDtcblx0XHRcdGZOZXcubWFya2VkID0gZmFsc2U7XG5cblx0XHRcdC8qIFRoZSBuZXcgZmFjZSBpcyBtYXJrZWQgXCJpbnNpZGVcIiBpZiB0aGUgb2xkIG9uZSB3YXMuICBUaGlzIGlzIGFcblx0XHRcdCogY29udmVuaWVuY2UgZm9yIHRoZSBjb21tb24gY2FzZSB3aGVyZSBhIGZhY2UgaGFzIGJlZW4gc3BsaXQgaW4gdHdvLlxuXHRcdFx0Ki9cblx0XHRcdGZOZXcuaW5zaWRlID0gZk5leHQuaW5zaWRlO1xuXG5cdFx0XHQvKiBmaXggb3RoZXIgZWRnZXMgb24gdGhpcyBmYWNlIGxvb3AgKi9cblx0XHRcdHZhciBlID0gZU9yaWc7XG5cdFx0XHRkbyB7XG5cdFx0XHRcdGUuTGZhY2UgPSBmTmV3O1xuXHRcdFx0XHRlID0gZS5MbmV4dDtcblx0XHRcdH0gd2hpbGUoZSAhPT0gZU9yaWcpO1xuXHRcdH0sXG5cblx0XHQvKiBLaWxsRWRnZSggZURlbCApIGRlc3Ryb3lzIGFuIGVkZ2UgKHRoZSBoYWxmLWVkZ2VzIGVEZWwgYW5kIGVEZWwtPlN5bSksXG5cdFx0KiBhbmQgcmVtb3ZlcyBmcm9tIHRoZSBnbG9iYWwgZWRnZSBsaXN0LlxuXHRcdCovXG5cdFx0Ly9zdGF0aWMgdm9pZCBLaWxsRWRnZSggVEVTU21lc2ggKm1lc2gsIFRFU1NoYWxmRWRnZSAqZURlbCApXG5cdFx0a2lsbEVkZ2VfOiBmdW5jdGlvbihlRGVsKSB7XG5cdFx0XHQvKiBIYWxmLWVkZ2VzIGFyZSBhbGxvY2F0ZWQgaW4gcGFpcnMsIHNlZSBFZGdlUGFpciBhYm92ZSAqL1xuXHRcdFx0aWYoIGVEZWwuU3ltLnNpZGUgPCBlRGVsLnNpZGUgKSB7IGVEZWwgPSBlRGVsLlN5bTsgfVxuXG5cdFx0XHQvKiBkZWxldGUgZnJvbSBjaXJjdWxhciBkb3VibHktbGlua2VkIGxpc3QgKi9cblx0XHRcdHZhciBlTmV4dCA9IGVEZWwubmV4dDtcblx0XHRcdHZhciBlUHJldiA9IGVEZWwuU3ltLm5leHQ7XG5cdFx0XHRlTmV4dC5TeW0ubmV4dCA9IGVQcmV2O1xuXHRcdFx0ZVByZXYuU3ltLm5leHQgPSBlTmV4dDtcblx0XHR9LFxuXG5cblx0XHQvKiBLaWxsVmVydGV4KCB2RGVsICkgZGVzdHJveXMgYSB2ZXJ0ZXggYW5kIHJlbW92ZXMgaXQgZnJvbSB0aGUgZ2xvYmFsXG5cdFx0KiB2ZXJ0ZXggbGlzdC4gIEl0IHVwZGF0ZXMgdGhlIHZlcnRleCBsb29wIHRvIHBvaW50IHRvIGEgZ2l2ZW4gbmV3IHZlcnRleC5cblx0XHQqL1xuXHRcdC8vc3RhdGljIHZvaWQgS2lsbFZlcnRleCggVEVTU21lc2ggKm1lc2gsIFRFU1N2ZXJ0ZXggKnZEZWwsIFRFU1N2ZXJ0ZXggKm5ld09yZyApXG5cdFx0a2lsbFZlcnRleF86IGZ1bmN0aW9uKHZEZWwsIG5ld09yZykge1xuXHRcdFx0dmFyIGVTdGFydCA9IHZEZWwuYW5FZGdlO1xuXHRcdFx0LyogY2hhbmdlIHRoZSBvcmlnaW4gb2YgYWxsIGFmZmVjdGVkIGVkZ2VzICovXG5cdFx0XHR2YXIgZSA9IGVTdGFydDtcblx0XHRcdGRvIHtcblx0XHRcdFx0ZS5PcmcgPSBuZXdPcmc7XG5cdFx0XHRcdGUgPSBlLk9uZXh0O1xuXHRcdFx0fSB3aGlsZShlICE9PSBlU3RhcnQpO1xuXG5cdFx0XHQvKiBkZWxldGUgZnJvbSBjaXJjdWxhciBkb3VibHktbGlua2VkIGxpc3QgKi9cblx0XHRcdHZhciB2UHJldiA9IHZEZWwucHJldjtcblx0XHRcdHZhciB2TmV4dCA9IHZEZWwubmV4dDtcblx0XHRcdHZOZXh0LnByZXYgPSB2UHJldjtcblx0XHRcdHZQcmV2Lm5leHQgPSB2TmV4dDtcblx0XHR9LFxuXG5cdFx0LyogS2lsbEZhY2UoIGZEZWwgKSBkZXN0cm95cyBhIGZhY2UgYW5kIHJlbW92ZXMgaXQgZnJvbSB0aGUgZ2xvYmFsIGZhY2Vcblx0XHQqIGxpc3QuICBJdCB1cGRhdGVzIHRoZSBmYWNlIGxvb3AgdG8gcG9pbnQgdG8gYSBnaXZlbiBuZXcgZmFjZS5cblx0XHQqL1xuXHRcdC8vc3RhdGljIHZvaWQgS2lsbEZhY2UoIFRFU1NtZXNoICptZXNoLCBURVNTZmFjZSAqZkRlbCwgVEVTU2ZhY2UgKm5ld0xmYWNlIClcblx0XHRraWxsRmFjZV86IGZ1bmN0aW9uKGZEZWwsIG5ld0xmYWNlKSB7XG5cdFx0XHR2YXIgZVN0YXJ0ID0gZkRlbC5hbkVkZ2U7XG5cblx0XHRcdC8qIGNoYW5nZSB0aGUgbGVmdCBmYWNlIG9mIGFsbCBhZmZlY3RlZCBlZGdlcyAqL1xuXHRcdFx0dmFyIGUgPSBlU3RhcnQ7XG5cdFx0XHRkbyB7XG5cdFx0XHRcdGUuTGZhY2UgPSBuZXdMZmFjZTtcblx0XHRcdFx0ZSA9IGUuTG5leHQ7XG5cdFx0XHR9IHdoaWxlKGUgIT09IGVTdGFydCk7XG5cblx0XHRcdC8qIGRlbGV0ZSBmcm9tIGNpcmN1bGFyIGRvdWJseS1saW5rZWQgbGlzdCAqL1xuXHRcdFx0dmFyIGZQcmV2ID0gZkRlbC5wcmV2O1xuXHRcdFx0dmFyIGZOZXh0ID0gZkRlbC5uZXh0O1xuXHRcdFx0Zk5leHQucHJldiA9IGZQcmV2O1xuXHRcdFx0ZlByZXYubmV4dCA9IGZOZXh0O1xuXHRcdH0sXG5cblx0XHQvKioqKioqKioqKioqKioqKioqIEJhc2ljIEVkZ2UgT3BlcmF0aW9ucyAqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cdFx0LyogdGVzc01lc2hNYWtlRWRnZSBjcmVhdGVzIG9uZSBlZGdlLCB0d28gdmVydGljZXMsIGFuZCBhIGxvb3AgKGZhY2UpLlxuXHRcdCogVGhlIGxvb3AgY29uc2lzdHMgb2YgdGhlIHR3byBuZXcgaGFsZi1lZGdlcy5cblx0XHQqL1xuXHRcdC8vVEVTU2hhbGZFZGdlICp0ZXNzTWVzaE1ha2VFZGdlKCBURVNTbWVzaCAqbWVzaCApXG5cdFx0bWFrZUVkZ2U6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld1ZlcnRleDEgPSBuZXcgVEVTU3ZlcnRleCgpO1xuXHRcdFx0dmFyIG5ld1ZlcnRleDIgPSBuZXcgVEVTU3ZlcnRleCgpO1xuXHRcdFx0dmFyIG5ld0ZhY2UgPSBuZXcgVEVTU2ZhY2UoKTtcblx0XHRcdHZhciBlID0gdGhpcy5tYWtlRWRnZV8oIHRoaXMuZUhlYWQpO1xuXHRcdFx0dGhpcy5tYWtlVmVydGV4XyggbmV3VmVydGV4MSwgZSwgdGhpcy52SGVhZCApO1xuXHRcdFx0dGhpcy5tYWtlVmVydGV4XyggbmV3VmVydGV4MiwgZS5TeW0sIHRoaXMudkhlYWQgKTtcblx0XHRcdHRoaXMubWFrZUZhY2VfKCBuZXdGYWNlLCBlLCB0aGlzLmZIZWFkICk7XG5cdFx0XHRyZXR1cm4gZTtcblx0XHR9LFxuXG5cdFx0LyogdGVzc01lc2hTcGxpY2UoIGVPcmcsIGVEc3QgKSBpcyB0aGUgYmFzaWMgb3BlcmF0aW9uIGZvciBjaGFuZ2luZyB0aGVcblx0XHQqIG1lc2ggY29ubmVjdGl2aXR5IGFuZCB0b3BvbG9neS4gIEl0IGNoYW5nZXMgdGhlIG1lc2ggc28gdGhhdFxuXHRcdCpcdGVPcmctPk9uZXh0IDwtIE9MRCggZURzdC0+T25leHQgKVxuXHRcdCpcdGVEc3QtPk9uZXh0IDwtIE9MRCggZU9yZy0+T25leHQgKVxuXHRcdCogd2hlcmUgT0xEKC4uLikgbWVhbnMgdGhlIHZhbHVlIGJlZm9yZSB0aGUgbWVzaFNwbGljZSBvcGVyYXRpb24uXG5cdFx0KlxuXHRcdCogVGhpcyBjYW4gaGF2ZSB0d28gZWZmZWN0cyBvbiB0aGUgdmVydGV4IHN0cnVjdHVyZTpcblx0XHQqICAtIGlmIGVPcmctPk9yZyAhPSBlRHN0LT5PcmcsIHRoZSB0d28gdmVydGljZXMgYXJlIG1lcmdlZCB0b2dldGhlclxuXHRcdCogIC0gaWYgZU9yZy0+T3JnID09IGVEc3QtPk9yZywgdGhlIG9yaWdpbiBpcyBzcGxpdCBpbnRvIHR3byB2ZXJ0aWNlc1xuXHRcdCogSW4gYm90aCBjYXNlcywgZURzdC0+T3JnIGlzIGNoYW5nZWQgYW5kIGVPcmctPk9yZyBpcyB1bnRvdWNoZWQuXG5cdFx0KlxuXHRcdCogU2ltaWxhcmx5IChhbmQgaW5kZXBlbmRlbnRseSkgZm9yIHRoZSBmYWNlIHN0cnVjdHVyZSxcblx0XHQqICAtIGlmIGVPcmctPkxmYWNlID09IGVEc3QtPkxmYWNlLCBvbmUgbG9vcCBpcyBzcGxpdCBpbnRvIHR3b1xuXHRcdCogIC0gaWYgZU9yZy0+TGZhY2UgIT0gZURzdC0+TGZhY2UsIHR3byBkaXN0aW5jdCBsb29wcyBhcmUgam9pbmVkIGludG8gb25lXG5cdFx0KiBJbiBib3RoIGNhc2VzLCBlRHN0LT5MZmFjZSBpcyBjaGFuZ2VkIGFuZCBlT3JnLT5MZmFjZSBpcyB1bmFmZmVjdGVkLlxuXHRcdCpcblx0XHQqIFNvbWUgc3BlY2lhbCBjYXNlczpcblx0XHQqIElmIGVEc3QgPT0gZU9yZywgdGhlIG9wZXJhdGlvbiBoYXMgbm8gZWZmZWN0LlxuXHRcdCogSWYgZURzdCA9PSBlT3JnLT5MbmV4dCwgdGhlIG5ldyBmYWNlIHdpbGwgaGF2ZSBhIHNpbmdsZSBlZGdlLlxuXHRcdCogSWYgZURzdCA9PSBlT3JnLT5McHJldiwgdGhlIG9sZCBmYWNlIHdpbGwgaGF2ZSBhIHNpbmdsZSBlZGdlLlxuXHRcdCogSWYgZURzdCA9PSBlT3JnLT5PbmV4dCwgdGhlIG5ldyB2ZXJ0ZXggd2lsbCBoYXZlIGEgc2luZ2xlIGVkZ2UuXG5cdFx0KiBJZiBlRHN0ID09IGVPcmctPk9wcmV2LCB0aGUgb2xkIHZlcnRleCB3aWxsIGhhdmUgYSBzaW5nbGUgZWRnZS5cblx0XHQqL1xuXHRcdC8vaW50IHRlc3NNZXNoU3BsaWNlKCBURVNTbWVzaCogbWVzaCwgVEVTU2hhbGZFZGdlICplT3JnLCBURVNTaGFsZkVkZ2UgKmVEc3QgKVxuXHRcdHNwbGljZTogZnVuY3Rpb24oZU9yZywgZURzdCkge1xuXHRcdFx0dmFyIGpvaW5pbmdMb29wcyA9IGZhbHNlO1xuXHRcdFx0dmFyIGpvaW5pbmdWZXJ0aWNlcyA9IGZhbHNlO1xuXG5cdFx0XHRpZiggZU9yZyA9PT0gZURzdCApIHJldHVybjtcblxuXHRcdFx0aWYoIGVEc3QuT3JnICE9PSBlT3JnLk9yZyApIHtcblx0XHRcdFx0LyogV2UgYXJlIG1lcmdpbmcgdHdvIGRpc2pvaW50IHZlcnRpY2VzIC0tIGRlc3Ryb3kgZURzdC0+T3JnICovXG5cdFx0XHRcdGpvaW5pbmdWZXJ0aWNlcyA9IHRydWU7XG5cdFx0XHRcdHRoaXMua2lsbFZlcnRleF8oIGVEc3QuT3JnLCBlT3JnLk9yZyApO1xuXHRcdFx0fVxuXHRcdFx0aWYoIGVEc3QuTGZhY2UgIT09IGVPcmcuTGZhY2UgKSB7XG5cdFx0XHRcdC8qIFdlIGFyZSBjb25uZWN0aW5nIHR3byBkaXNqb2ludCBsb29wcyAtLSBkZXN0cm95IGVEc3QtPkxmYWNlICovXG5cdFx0XHRcdGpvaW5pbmdMb29wcyA9IHRydWU7XG5cdFx0XHRcdHRoaXMua2lsbEZhY2VfKCBlRHN0LkxmYWNlLCBlT3JnLkxmYWNlICk7XG5cdFx0XHR9XG5cblx0XHRcdC8qIENoYW5nZSB0aGUgZWRnZSBzdHJ1Y3R1cmUgKi9cblx0XHRcdHRoaXMuc3BsaWNlXyggZURzdCwgZU9yZyApO1xuXG5cdFx0XHRpZiggISBqb2luaW5nVmVydGljZXMgKSB7XG5cdFx0XHRcdHZhciBuZXdWZXJ0ZXggPSBuZXcgVEVTU3ZlcnRleCgpO1xuXG5cdFx0XHRcdC8qIFdlIHNwbGl0IG9uZSB2ZXJ0ZXggaW50byB0d28gLS0gdGhlIG5ldyB2ZXJ0ZXggaXMgZURzdC0+T3JnLlxuXHRcdFx0XHQqIE1ha2Ugc3VyZSB0aGUgb2xkIHZlcnRleCBwb2ludHMgdG8gYSB2YWxpZCBoYWxmLWVkZ2UuXG5cdFx0XHRcdCovXG5cdFx0XHRcdHRoaXMubWFrZVZlcnRleF8oIG5ld1ZlcnRleCwgZURzdCwgZU9yZy5PcmcgKTtcblx0XHRcdFx0ZU9yZy5PcmcuYW5FZGdlID0gZU9yZztcblx0XHRcdH1cblx0XHRcdGlmKCAhIGpvaW5pbmdMb29wcyApIHtcblx0XHRcdFx0dmFyIG5ld0ZhY2UgPSBuZXcgVEVTU2ZhY2UoKTsgIFxuXG5cdFx0XHRcdC8qIFdlIHNwbGl0IG9uZSBsb29wIGludG8gdHdvIC0tIHRoZSBuZXcgbG9vcCBpcyBlRHN0LT5MZmFjZS5cblx0XHRcdFx0KiBNYWtlIHN1cmUgdGhlIG9sZCBmYWNlIHBvaW50cyB0byBhIHZhbGlkIGhhbGYtZWRnZS5cblx0XHRcdFx0Ki9cblx0XHRcdFx0dGhpcy5tYWtlRmFjZV8oIG5ld0ZhY2UsIGVEc3QsIGVPcmcuTGZhY2UgKTtcblx0XHRcdFx0ZU9yZy5MZmFjZS5hbkVkZ2UgPSBlT3JnO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKiB0ZXNzTWVzaERlbGV0ZSggZURlbCApIHJlbW92ZXMgdGhlIGVkZ2UgZURlbC4gIFRoZXJlIGFyZSBzZXZlcmFsIGNhc2VzOlxuXHRcdCogaWYgKGVEZWwtPkxmYWNlICE9IGVEZWwtPlJmYWNlKSwgd2Ugam9pbiB0d28gbG9vcHMgaW50byBvbmU7IHRoZSBsb29wXG5cdFx0KiBlRGVsLT5MZmFjZSBpcyBkZWxldGVkLiAgT3RoZXJ3aXNlLCB3ZSBhcmUgc3BsaXR0aW5nIG9uZSBsb29wIGludG8gdHdvO1xuXHRcdCogdGhlIG5ld2x5IGNyZWF0ZWQgbG9vcCB3aWxsIGNvbnRhaW4gZURlbC0+RHN0LiAgSWYgdGhlIGRlbGV0aW9uIG9mIGVEZWxcblx0XHQqIHdvdWxkIGNyZWF0ZSBpc29sYXRlZCB2ZXJ0aWNlcywgdGhvc2UgYXJlIGRlbGV0ZWQgYXMgd2VsbC5cblx0XHQqXG5cdFx0KiBUaGlzIGZ1bmN0aW9uIGNvdWxkIGJlIGltcGxlbWVudGVkIGFzIHR3byBjYWxscyB0byB0ZXNzTWVzaFNwbGljZVxuXHRcdCogcGx1cyBhIGZldyBjYWxscyB0byBtZW1GcmVlLCBidXQgdGhpcyB3b3VsZCBhbGxvY2F0ZSBhbmQgZGVsZXRlXG5cdFx0KiB1bm5lY2Vzc2FyeSB2ZXJ0aWNlcyBhbmQgZmFjZXMuXG5cdFx0Ki9cblx0XHQvL2ludCB0ZXNzTWVzaERlbGV0ZSggVEVTU21lc2ggKm1lc2gsIFRFU1NoYWxmRWRnZSAqZURlbCApXG5cdFx0ZGVsZXRlOiBmdW5jdGlvbihlRGVsKSB7XG5cdFx0XHR2YXIgZURlbFN5bSA9IGVEZWwuU3ltO1xuXHRcdFx0dmFyIGpvaW5pbmdMb29wcyA9IGZhbHNlO1xuXG5cdFx0XHQvKiBGaXJzdCBzdGVwOiBkaXNjb25uZWN0IHRoZSBvcmlnaW4gdmVydGV4IGVEZWwtPk9yZy4gIFdlIG1ha2UgYWxsXG5cdFx0XHQqIGNoYW5nZXMgdG8gZ2V0IGEgY29uc2lzdGVudCBtZXNoIGluIHRoaXMgXCJpbnRlcm1lZGlhdGVcIiBzdGF0ZS5cblx0XHRcdCovXG5cdFx0XHRpZiggZURlbC5MZmFjZSAhPT0gZURlbC5SZmFjZSApIHtcblx0XHRcdFx0LyogV2UgYXJlIGpvaW5pbmcgdHdvIGxvb3BzIGludG8gb25lIC0tIHJlbW92ZSB0aGUgbGVmdCBmYWNlICovXG5cdFx0XHRcdGpvaW5pbmdMb29wcyA9IHRydWU7XG5cdFx0XHRcdHRoaXMua2lsbEZhY2VfKCBlRGVsLkxmYWNlLCBlRGVsLlJmYWNlICk7XG5cdFx0XHR9XG5cblx0XHRcdGlmKCBlRGVsLk9uZXh0ID09PSBlRGVsICkge1xuXHRcdFx0XHR0aGlzLmtpbGxWZXJ0ZXhfKCBlRGVsLk9yZywgbnVsbCApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0LyogTWFrZSBzdXJlIHRoYXQgZURlbC0+T3JnIGFuZCBlRGVsLT5SZmFjZSBwb2ludCB0byB2YWxpZCBoYWxmLWVkZ2VzICovXG5cdFx0XHRcdGVEZWwuUmZhY2UuYW5FZGdlID0gZURlbC5PcHJldjtcblx0XHRcdFx0ZURlbC5PcmcuYW5FZGdlID0gZURlbC5PbmV4dDtcblxuXHRcdFx0XHR0aGlzLnNwbGljZV8oIGVEZWwsIGVEZWwuT3ByZXYgKTtcblx0XHRcdFx0aWYoICEgam9pbmluZ0xvb3BzICkge1xuXHRcdFx0XHRcdHZhciBuZXdGYWNlID0gbmV3IFRFU1NmYWNlKCk7XG5cblx0XHRcdFx0XHQvKiBXZSBhcmUgc3BsaXR0aW5nIG9uZSBsb29wIGludG8gdHdvIC0tIGNyZWF0ZSBhIG5ldyBsb29wIGZvciBlRGVsLiAqL1xuXHRcdFx0XHRcdHRoaXMubWFrZUZhY2VfKCBuZXdGYWNlLCBlRGVsLCBlRGVsLkxmYWNlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0LyogQ2xhaW06IHRoZSBtZXNoIGlzIG5vdyBpbiBhIGNvbnNpc3RlbnQgc3RhdGUsIGV4Y2VwdCB0aGF0IGVEZWwtPk9yZ1xuXHRcdFx0KiBtYXkgaGF2ZSBiZWVuIGRlbGV0ZWQuICBOb3cgd2UgZGlzY29ubmVjdCBlRGVsLT5Ec3QuXG5cdFx0XHQqL1xuXHRcdFx0aWYoIGVEZWxTeW0uT25leHQgPT09IGVEZWxTeW0gKSB7XG5cdFx0XHRcdHRoaXMua2lsbFZlcnRleF8oIGVEZWxTeW0uT3JnLCBudWxsICk7XG5cdFx0XHRcdHRoaXMua2lsbEZhY2VfKCBlRGVsU3ltLkxmYWNlLCBudWxsICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvKiBNYWtlIHN1cmUgdGhhdCBlRGVsLT5Ec3QgYW5kIGVEZWwtPkxmYWNlIHBvaW50IHRvIHZhbGlkIGhhbGYtZWRnZXMgKi9cblx0XHRcdFx0ZURlbC5MZmFjZS5hbkVkZ2UgPSBlRGVsU3ltLk9wcmV2O1xuXHRcdFx0XHRlRGVsU3ltLk9yZy5hbkVkZ2UgPSBlRGVsU3ltLk9uZXh0O1xuXHRcdFx0XHR0aGlzLnNwbGljZV8oIGVEZWxTeW0sIGVEZWxTeW0uT3ByZXYgKTtcblx0XHRcdH1cblxuXHRcdFx0LyogQW55IGlzb2xhdGVkIHZlcnRpY2VzIG9yIGZhY2VzIGhhdmUgYWxyZWFkeSBiZWVuIGZyZWVkLiAqL1xuXHRcdFx0dGhpcy5raWxsRWRnZV8oIGVEZWwgKTtcblx0XHR9LFxuXG5cdFx0LyoqKioqKioqKioqKioqKioqKioqIE90aGVyIEVkZ2UgT3BlcmF0aW9ucyAqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cdFx0LyogQWxsIHRoZXNlIHJvdXRpbmVzIGNhbiBiZSBpbXBsZW1lbnRlZCB3aXRoIHRoZSBiYXNpYyBlZGdlXG5cdFx0KiBvcGVyYXRpb25zIGFib3ZlLiAgVGhleSBhcmUgcHJvdmlkZWQgZm9yIGNvbnZlbmllbmNlIGFuZCBlZmZpY2llbmN5LlxuXHRcdCovXG5cblxuXHRcdC8qIHRlc3NNZXNoQWRkRWRnZVZlcnRleCggZU9yZyApIGNyZWF0ZXMgYSBuZXcgZWRnZSBlTmV3IHN1Y2ggdGhhdFxuXHRcdCogZU5ldyA9PSBlT3JnLT5MbmV4dCwgYW5kIGVOZXctPkRzdCBpcyBhIG5ld2x5IGNyZWF0ZWQgdmVydGV4LlxuXHRcdCogZU9yZyBhbmQgZU5ldyB3aWxsIGhhdmUgdGhlIHNhbWUgbGVmdCBmYWNlLlxuXHRcdCovXG5cdFx0Ly8gVEVTU2hhbGZFZGdlICp0ZXNzTWVzaEFkZEVkZ2VWZXJ0ZXgoIFRFU1NtZXNoICptZXNoLCBURVNTaGFsZkVkZ2UgKmVPcmcgKTtcblx0XHRhZGRFZGdlVmVydGV4OiBmdW5jdGlvbihlT3JnKSB7XG5cdFx0XHR2YXIgZU5ldyA9IHRoaXMubWFrZUVkZ2VfKCBlT3JnICk7XG5cdFx0XHR2YXIgZU5ld1N5bSA9IGVOZXcuU3ltO1xuXG5cdFx0XHQvKiBDb25uZWN0IHRoZSBuZXcgZWRnZSBhcHByb3ByaWF0ZWx5ICovXG5cdFx0XHR0aGlzLnNwbGljZV8oIGVOZXcsIGVPcmcuTG5leHQgKTtcblxuXHRcdFx0LyogU2V0IHRoZSB2ZXJ0ZXggYW5kIGZhY2UgaW5mb3JtYXRpb24gKi9cblx0XHRcdGVOZXcuT3JnID0gZU9yZy5Ec3Q7XG5cblx0XHRcdHZhciBuZXdWZXJ0ZXggPSBuZXcgVEVTU3ZlcnRleCgpO1xuXHRcdFx0dGhpcy5tYWtlVmVydGV4XyggbmV3VmVydGV4LCBlTmV3U3ltLCBlTmV3Lk9yZyApO1xuXG5cdFx0XHRlTmV3LkxmYWNlID0gZU5ld1N5bS5MZmFjZSA9IGVPcmcuTGZhY2U7XG5cblx0XHRcdHJldHVybiBlTmV3O1xuXHRcdH0sXG5cblxuXHRcdC8qIHRlc3NNZXNoU3BsaXRFZGdlKCBlT3JnICkgc3BsaXRzIGVPcmcgaW50byB0d28gZWRnZXMgZU9yZyBhbmQgZU5ldyxcblx0XHQqIHN1Y2ggdGhhdCBlTmV3ID09IGVPcmctPkxuZXh0LiAgVGhlIG5ldyB2ZXJ0ZXggaXMgZU9yZy0+RHN0ID09IGVOZXctPk9yZy5cblx0XHQqIGVPcmcgYW5kIGVOZXcgd2lsbCBoYXZlIHRoZSBzYW1lIGxlZnQgZmFjZS5cblx0XHQqL1xuXHRcdC8vIFRFU1NoYWxmRWRnZSAqdGVzc01lc2hTcGxpdEVkZ2UoIFRFU1NtZXNoICptZXNoLCBURVNTaGFsZkVkZ2UgKmVPcmcgKTtcblx0XHRzcGxpdEVkZ2U6IGZ1bmN0aW9uKGVPcmcsIGVEc3QpIHtcblx0XHRcdHZhciB0ZW1wSGFsZkVkZ2UgPSB0aGlzLmFkZEVkZ2VWZXJ0ZXgoIGVPcmcgKTtcblx0XHRcdHZhciBlTmV3ID0gdGVtcEhhbGZFZGdlLlN5bTtcblxuXHRcdFx0LyogRGlzY29ubmVjdCBlT3JnIGZyb20gZU9yZy0+RHN0IGFuZCBjb25uZWN0IGl0IHRvIGVOZXctPk9yZyAqL1xuXHRcdFx0dGhpcy5zcGxpY2VfKCBlT3JnLlN5bSwgZU9yZy5TeW0uT3ByZXYgKTtcblx0XHRcdHRoaXMuc3BsaWNlXyggZU9yZy5TeW0sIGVOZXcgKTtcblxuXHRcdFx0LyogU2V0IHRoZSB2ZXJ0ZXggYW5kIGZhY2UgaW5mb3JtYXRpb24gKi9cblx0XHRcdGVPcmcuRHN0ID0gZU5ldy5Pcmc7XG5cdFx0XHRlTmV3LkRzdC5hbkVkZ2UgPSBlTmV3LlN5bTtcdC8qIG1heSBoYXZlIHBvaW50ZWQgdG8gZU9yZy0+U3ltICovXG5cdFx0XHRlTmV3LlJmYWNlID0gZU9yZy5SZmFjZTtcblx0XHRcdGVOZXcud2luZGluZyA9IGVPcmcud2luZGluZztcdC8qIGNvcHkgb2xkIHdpbmRpbmcgaW5mb3JtYXRpb24gKi9cblx0XHRcdGVOZXcuU3ltLndpbmRpbmcgPSBlT3JnLlN5bS53aW5kaW5nO1xuXG5cdFx0XHRyZXR1cm4gZU5ldztcblx0XHR9LFxuXG5cblx0XHQvKiB0ZXNzTWVzaENvbm5lY3QoIGVPcmcsIGVEc3QgKSBjcmVhdGVzIGEgbmV3IGVkZ2UgZnJvbSBlT3JnLT5Ec3Rcblx0XHQqIHRvIGVEc3QtPk9yZywgYW5kIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgaGFsZi1lZGdlIGVOZXcuXG5cdFx0KiBJZiBlT3JnLT5MZmFjZSA9PSBlRHN0LT5MZmFjZSwgdGhpcyBzcGxpdHMgb25lIGxvb3AgaW50byB0d28sXG5cdFx0KiBhbmQgdGhlIG5ld2x5IGNyZWF0ZWQgbG9vcCBpcyBlTmV3LT5MZmFjZS4gIE90aGVyd2lzZSwgdHdvIGRpc2pvaW50XG5cdFx0KiBsb29wcyBhcmUgbWVyZ2VkIGludG8gb25lLCBhbmQgdGhlIGxvb3AgZURzdC0+TGZhY2UgaXMgZGVzdHJveWVkLlxuXHRcdCpcblx0XHQqIElmIChlT3JnID09IGVEc3QpLCB0aGUgbmV3IGZhY2Ugd2lsbCBoYXZlIG9ubHkgdHdvIGVkZ2VzLlxuXHRcdCogSWYgKGVPcmctPkxuZXh0ID09IGVEc3QpLCB0aGUgb2xkIGZhY2UgaXMgcmVkdWNlZCB0byBhIHNpbmdsZSBlZGdlLlxuXHRcdCogSWYgKGVPcmctPkxuZXh0LT5MbmV4dCA9PSBlRHN0KSwgdGhlIG9sZCBmYWNlIGlzIHJlZHVjZWQgdG8gdHdvIGVkZ2VzLlxuXHRcdCovXG5cblx0XHQvLyBURVNTaGFsZkVkZ2UgKnRlc3NNZXNoQ29ubmVjdCggVEVTU21lc2ggKm1lc2gsIFRFU1NoYWxmRWRnZSAqZU9yZywgVEVTU2hhbGZFZGdlICplRHN0ICk7XG5cdFx0Y29ubmVjdDogZnVuY3Rpb24oZU9yZywgZURzdCkge1xuXHRcdFx0dmFyIGpvaW5pbmdMb29wcyA9IGZhbHNlOyAgXG5cdFx0XHR2YXIgZU5ldyA9IHRoaXMubWFrZUVkZ2VfKCBlT3JnICk7XG5cdFx0XHR2YXIgZU5ld1N5bSA9IGVOZXcuU3ltO1xuXG5cdFx0XHRpZiggZURzdC5MZmFjZSAhPT0gZU9yZy5MZmFjZSApIHtcblx0XHRcdFx0LyogV2UgYXJlIGNvbm5lY3RpbmcgdHdvIGRpc2pvaW50IGxvb3BzIC0tIGRlc3Ryb3kgZURzdC0+TGZhY2UgKi9cblx0XHRcdFx0am9pbmluZ0xvb3BzID0gdHJ1ZTtcblx0XHRcdFx0dGhpcy5raWxsRmFjZV8oIGVEc3QuTGZhY2UsIGVPcmcuTGZhY2UgKTtcblx0XHRcdH1cblxuXHRcdFx0LyogQ29ubmVjdCB0aGUgbmV3IGVkZ2UgYXBwcm9wcmlhdGVseSAqL1xuXHRcdFx0dGhpcy5zcGxpY2VfKCBlTmV3LCBlT3JnLkxuZXh0ICk7XG5cdFx0XHR0aGlzLnNwbGljZV8oIGVOZXdTeW0sIGVEc3QgKTtcblxuXHRcdFx0LyogU2V0IHRoZSB2ZXJ0ZXggYW5kIGZhY2UgaW5mb3JtYXRpb24gKi9cblx0XHRcdGVOZXcuT3JnID0gZU9yZy5Ec3Q7XG5cdFx0XHRlTmV3U3ltLk9yZyA9IGVEc3QuT3JnO1xuXHRcdFx0ZU5ldy5MZmFjZSA9IGVOZXdTeW0uTGZhY2UgPSBlT3JnLkxmYWNlO1xuXG5cdFx0XHQvKiBNYWtlIHN1cmUgdGhlIG9sZCBmYWNlIHBvaW50cyB0byBhIHZhbGlkIGhhbGYtZWRnZSAqL1xuXHRcdFx0ZU9yZy5MZmFjZS5hbkVkZ2UgPSBlTmV3U3ltO1xuXG5cdFx0XHRpZiggISBqb2luaW5nTG9vcHMgKSB7XG5cdFx0XHRcdHZhciBuZXdGYWNlID0gbmV3IFRFU1NmYWNlKCk7XG5cdFx0XHRcdC8qIFdlIHNwbGl0IG9uZSBsb29wIGludG8gdHdvIC0tIHRoZSBuZXcgbG9vcCBpcyBlTmV3LT5MZmFjZSAqL1xuXHRcdFx0XHR0aGlzLm1ha2VGYWNlXyggbmV3RmFjZSwgZU5ldywgZU9yZy5MZmFjZSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGVOZXc7XG5cdFx0fSxcblxuXHRcdC8qIHRlc3NNZXNoWmFwRmFjZSggZlphcCApIGRlc3Ryb3lzIGEgZmFjZSBhbmQgcmVtb3ZlcyBpdCBmcm9tIHRoZVxuXHRcdCogZ2xvYmFsIGZhY2UgbGlzdC4gIEFsbCBlZGdlcyBvZiBmWmFwIHdpbGwgaGF2ZSBhIE5VTEwgcG9pbnRlciBhcyB0aGVpclxuXHRcdCogbGVmdCBmYWNlLiAgQW55IGVkZ2VzIHdoaWNoIGFsc28gaGF2ZSBhIE5VTEwgcG9pbnRlciBhcyB0aGVpciByaWdodCBmYWNlXG5cdFx0KiBhcmUgZGVsZXRlZCBlbnRpcmVseSAoYWxvbmcgd2l0aCBhbnkgaXNvbGF0ZWQgdmVydGljZXMgdGhpcyBwcm9kdWNlcykuXG5cdFx0KiBBbiBlbnRpcmUgbWVzaCBjYW4gYmUgZGVsZXRlZCBieSB6YXBwaW5nIGl0cyBmYWNlcywgb25lIGF0IGEgdGltZSxcblx0XHQqIGluIGFueSBvcmRlci4gIFphcHBlZCBmYWNlcyBjYW5ub3QgYmUgdXNlZCBpbiBmdXJ0aGVyIG1lc2ggb3BlcmF0aW9ucyFcblx0XHQqL1xuXHRcdHphcEZhY2U6IGZ1bmN0aW9uKCBmWmFwIClcblx0XHR7XG5cdFx0XHR2YXIgZVN0YXJ0ID0gZlphcC5hbkVkZ2U7XG5cdFx0XHR2YXIgZSwgZU5leHQsIGVTeW07XG5cdFx0XHR2YXIgZlByZXYsIGZOZXh0O1xuXG5cdFx0XHQvKiB3YWxrIGFyb3VuZCBmYWNlLCBkZWxldGluZyBlZGdlcyB3aG9zZSByaWdodCBmYWNlIGlzIGFsc28gTlVMTCAqL1xuXHRcdFx0ZU5leHQgPSBlU3RhcnQuTG5leHQ7XG5cdFx0XHRkbyB7XG5cdFx0XHRcdGUgPSBlTmV4dDtcblx0XHRcdFx0ZU5leHQgPSBlLkxuZXh0O1xuXG5cdFx0XHRcdGUuTGZhY2UgPSBudWxsO1xuXHRcdFx0XHRpZiggZS5SZmFjZSA9PT0gbnVsbCApIHtcblx0XHRcdFx0XHQvKiBkZWxldGUgdGhlIGVkZ2UgLS0gc2VlIFRFU1NtZXNoRGVsZXRlIGFib3ZlICovXG5cblx0XHRcdFx0XHRpZiggZS5PbmV4dCA9PT0gZSApIHtcblx0XHRcdFx0XHRcdHRoaXMua2lsbFZlcnRleF8oIGUuT3JnLCBudWxsICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdC8qIE1ha2Ugc3VyZSB0aGF0IGUtPk9yZyBwb2ludHMgdG8gYSB2YWxpZCBoYWxmLWVkZ2UgKi9cblx0XHRcdFx0XHRcdGUuT3JnLmFuRWRnZSA9IGUuT25leHQ7XG5cdFx0XHRcdFx0XHR0aGlzLnNwbGljZV8oIGUsIGUuT3ByZXYgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZVN5bSA9IGUuU3ltO1xuXHRcdFx0XHRcdGlmKCBlU3ltLk9uZXh0ID09PSBlU3ltICkge1xuXHRcdFx0XHRcdFx0dGhpcy5raWxsVmVydGV4XyggZVN5bS5PcmcsIG51bGwgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0LyogTWFrZSBzdXJlIHRoYXQgZVN5bS0+T3JnIHBvaW50cyB0byBhIHZhbGlkIGhhbGYtZWRnZSAqL1xuXHRcdFx0XHRcdFx0ZVN5bS5PcmcuYW5FZGdlID0gZVN5bS5PbmV4dDtcblx0XHRcdFx0XHRcdHRoaXMuc3BsaWNlXyggZVN5bSwgZVN5bS5PcHJldiApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aGlzLmtpbGxFZGdlXyggZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9IHdoaWxlKCBlICE9IGVTdGFydCApO1xuXG5cdFx0XHQvKiBkZWxldGUgZnJvbSBjaXJjdWxhciBkb3VibHktbGlua2VkIGxpc3QgKi9cblx0XHRcdGZQcmV2ID0gZlphcC5wcmV2O1xuXHRcdFx0Zk5leHQgPSBmWmFwLm5leHQ7XG5cdFx0XHRmTmV4dC5wcmV2ID0gZlByZXY7XG5cdFx0XHRmUHJldi5uZXh0ID0gZk5leHQ7XG5cdFx0fSxcblxuXHRcdGNvdW50RmFjZVZlcnRzXzogZnVuY3Rpb24oZikge1xuXHRcdFx0dmFyIGVDdXIgPSBmLmFuRWRnZTtcblx0XHRcdHZhciBuID0gMDtcblx0XHRcdGRvXG5cdFx0XHR7XG5cdFx0XHRcdG4rKztcblx0XHRcdFx0ZUN1ciA9IGVDdXIuTG5leHQ7XG5cdFx0XHR9XG5cdFx0XHR3aGlsZSAoZUN1ciAhPT0gZi5hbkVkZ2UpO1xuXHRcdFx0cmV0dXJuIG47XG5cdFx0fSxcblxuXHRcdC8vaW50IHRlc3NNZXNoTWVyZ2VDb252ZXhGYWNlcyggVEVTU21lc2ggKm1lc2gsIGludCBtYXhWZXJ0c1BlckZhY2UgKVxuXHRcdG1lcmdlQ29udmV4RmFjZXM6IGZ1bmN0aW9uKG1heFZlcnRzUGVyRmFjZSkge1xuXHRcdFx0dmFyIGY7XG5cdFx0XHR2YXIgZUN1ciwgZU5leHQsIGVTeW07XG5cdFx0XHR2YXIgdlN0YXJ0O1xuXHRcdFx0dmFyIGN1ck52LCBzeW1OdjtcblxuXHRcdFx0Zm9yKCBmID0gdGhpcy5mSGVhZC5uZXh0OyBmICE9PSB0aGlzLmZIZWFkOyBmID0gZi5uZXh0IClcblx0XHRcdHtcblx0XHRcdFx0Ly8gU2tpcCBmYWNlcyB3aGljaCBhcmUgb3V0c2lkZSB0aGUgcmVzdWx0LlxuXHRcdFx0XHRpZiggIWYuaW5zaWRlIClcblx0XHRcdFx0XHRjb250aW51ZTtcblxuXHRcdFx0XHRlQ3VyID0gZi5hbkVkZ2U7XG5cdFx0XHRcdHZTdGFydCA9IGVDdXIuT3JnO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHR3aGlsZSAodHJ1ZSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGVOZXh0ID0gZUN1ci5MbmV4dDtcblx0XHRcdFx0XHRlU3ltID0gZUN1ci5TeW07XG5cblx0XHRcdFx0XHQvLyBUcnkgdG8gbWVyZ2UgaWYgdGhlIG5laWdoYm91ciBmYWNlIGlzIHZhbGlkLlxuXHRcdFx0XHRcdGlmKCBlU3ltICYmIGVTeW0uTGZhY2UgJiYgZVN5bS5MZmFjZS5pbnNpZGUgKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdC8vIFRyeSB0byBtZXJnZSB0aGUgbmVpZ2hib3VyIGZhY2VzIGlmIHRoZSByZXN1bHRpbmcgcG9seWdvbnNcblx0XHRcdFx0XHRcdC8vIGRvZXMgbm90IGV4Y2VlZCBtYXhpbXVtIG51bWJlciBvZiB2ZXJ0aWNlcy5cblx0XHRcdFx0XHRcdGN1ck52ID0gdGhpcy5jb3VudEZhY2VWZXJ0c18oIGYgKTtcblx0XHRcdFx0XHRcdHN5bU52ID0gdGhpcy5jb3VudEZhY2VWZXJ0c18oIGVTeW0uTGZhY2UgKTtcblx0XHRcdFx0XHRcdGlmKCAoY3VyTnYrc3ltTnYtMikgPD0gbWF4VmVydHNQZXJGYWNlIClcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0Ly8gTWVyZ2UgaWYgdGhlIHJlc3VsdGluZyBwb2x5IGlzIGNvbnZleC5cblx0XHRcdFx0XHRcdFx0aWYoIEdlb20udmVydENDVyggZUN1ci5McHJldi5PcmcsIGVDdXIuT3JnLCBlU3ltLkxuZXh0LkxuZXh0Lk9yZyApICYmXG5cdFx0XHRcdFx0XHRcdFx0R2VvbS52ZXJ0Q0NXKCBlU3ltLkxwcmV2Lk9yZywgZVN5bS5PcmcsIGVDdXIuTG5leHQuTG5leHQuT3JnICkgKVxuXHRcdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdFx0ZU5leHQgPSBlU3ltLkxuZXh0O1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuZGVsZXRlKCBlU3ltICk7XG5cdFx0XHRcdFx0XHRcdFx0ZUN1ciA9IG51bGw7XG5cdFx0XHRcdFx0XHRcdFx0ZVN5bSA9IG51bGw7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYoIGVDdXIgJiYgZUN1ci5MbmV4dC5PcmcgPT09IHZTdGFydCApXG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdC8vIENvbnRpbnVlIHRvIG5leHQgZWRnZS5cblx0XHRcdFx0XHRlQ3VyID0gZU5leHQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSxcblxuXHRcdC8qIHRlc3NNZXNoQ2hlY2tNZXNoKCBtZXNoICkgY2hlY2tzIGEgbWVzaCBmb3Igc2VsZi1jb25zaXN0ZW5jeS5cblx0XHQqL1xuXHRcdGNoZWNrOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBmSGVhZCA9IHRoaXMuZkhlYWQ7XG5cdFx0XHR2YXIgdkhlYWQgPSB0aGlzLnZIZWFkO1xuXHRcdFx0dmFyIGVIZWFkID0gdGhpcy5lSGVhZDtcblx0XHRcdHZhciBmLCBmUHJldiwgdiwgdlByZXYsIGUsIGVQcmV2O1xuXG5cdFx0XHRmUHJldiA9IGZIZWFkO1xuXHRcdFx0Zm9yKCBmUHJldiA9IGZIZWFkIDsgKGYgPSBmUHJldi5uZXh0KSAhPT0gZkhlYWQ7IGZQcmV2ID0gZikge1xuXHRcdFx0XHRhc3NlcnQoIGYucHJldiA9PT0gZlByZXYgKTtcblx0XHRcdFx0ZSA9IGYuYW5FZGdlO1xuXHRcdFx0XHRkbyB7XG5cdFx0XHRcdFx0YXNzZXJ0KCBlLlN5bSAhPT0gZSApO1xuXHRcdFx0XHRcdGFzc2VydCggZS5TeW0uU3ltID09PSBlICk7XG5cdFx0XHRcdFx0YXNzZXJ0KCBlLkxuZXh0Lk9uZXh0LlN5bSA9PT0gZSApO1xuXHRcdFx0XHRcdGFzc2VydCggZS5PbmV4dC5TeW0uTG5leHQgPT09IGUgKTtcblx0XHRcdFx0XHRhc3NlcnQoIGUuTGZhY2UgPT09IGYgKTtcblx0XHRcdFx0XHRlID0gZS5MbmV4dDtcblx0XHRcdFx0fSB3aGlsZSggZSAhPT0gZi5hbkVkZ2UgKTtcblx0XHRcdH1cblx0XHRcdGFzc2VydCggZi5wcmV2ID09PSBmUHJldiAmJiBmLmFuRWRnZSA9PT0gbnVsbCApO1xuXG5cdFx0XHR2UHJldiA9IHZIZWFkO1xuXHRcdFx0Zm9yKCB2UHJldiA9IHZIZWFkIDsgKHYgPSB2UHJldi5uZXh0KSAhPT0gdkhlYWQ7IHZQcmV2ID0gdikge1xuXHRcdFx0XHRhc3NlcnQoIHYucHJldiA9PT0gdlByZXYgKTtcblx0XHRcdFx0ZSA9IHYuYW5FZGdlO1xuXHRcdFx0XHRkbyB7XG5cdFx0XHRcdFx0YXNzZXJ0KCBlLlN5bSAhPT0gZSApO1xuXHRcdFx0XHRcdGFzc2VydCggZS5TeW0uU3ltID09PSBlICk7XG5cdFx0XHRcdFx0YXNzZXJ0KCBlLkxuZXh0Lk9uZXh0LlN5bSA9PT0gZSApO1xuXHRcdFx0XHRcdGFzc2VydCggZS5PbmV4dC5TeW0uTG5leHQgPT09IGUgKTtcblx0XHRcdFx0XHRhc3NlcnQoIGUuT3JnID09PSB2ICk7XG5cdFx0XHRcdFx0ZSA9IGUuT25leHQ7XG5cdFx0XHRcdH0gd2hpbGUoIGUgIT09IHYuYW5FZGdlICk7XG5cdFx0XHR9XG5cdFx0XHRhc3NlcnQoIHYucHJldiA9PT0gdlByZXYgJiYgdi5hbkVkZ2UgPT09IG51bGwgKTtcblxuXHRcdFx0ZVByZXYgPSBlSGVhZDtcblx0XHRcdGZvciggZVByZXYgPSBlSGVhZCA7IChlID0gZVByZXYubmV4dCkgIT09IGVIZWFkOyBlUHJldiA9IGUpIHtcblx0XHRcdFx0YXNzZXJ0KCBlLlN5bS5uZXh0ID09PSBlUHJldi5TeW0gKTtcblx0XHRcdFx0YXNzZXJ0KCBlLlN5bSAhPT0gZSApO1xuXHRcdFx0XHRhc3NlcnQoIGUuU3ltLlN5bSA9PT0gZSApO1xuXHRcdFx0XHRhc3NlcnQoIGUuT3JnICE9PSBudWxsICk7XG5cdFx0XHRcdGFzc2VydCggZS5Ec3QgIT09IG51bGwgKTtcblx0XHRcdFx0YXNzZXJ0KCBlLkxuZXh0Lk9uZXh0LlN5bSA9PT0gZSApO1xuXHRcdFx0XHRhc3NlcnQoIGUuT25leHQuU3ltLkxuZXh0ID09PSBlICk7XG5cdFx0XHR9XG5cdFx0XHRhc3NlcnQoIGUuU3ltLm5leHQgPT09IGVQcmV2LlN5bVxuXHRcdFx0XHQmJiBlLlN5bSA9PT0gdGhpcy5lSGVhZFN5bVxuXHRcdFx0XHQmJiBlLlN5bS5TeW0gPT09IGVcblx0XHRcdFx0JiYgZS5PcmcgPT09IG51bGwgJiYgZS5Ec3QgPT09IG51bGxcblx0XHRcdFx0JiYgZS5MZmFjZSA9PT0gbnVsbCAmJiBlLlJmYWNlID09PSBudWxsICk7XG5cdFx0fVxuXG5cdH07XG5cblx0dmFyIEdlb20gPSB7fTtcblxuXHRHZW9tLnZlcnRFcSA9IGZ1bmN0aW9uKHUsdikge1xuXHRcdHJldHVybiAodS5zID09PSB2LnMgJiYgdS50ID09PSB2LnQpO1xuXHR9O1xuXG5cdC8qIFJldHVybnMgVFJVRSBpZiB1IGlzIGxleGljb2dyYXBoaWNhbGx5IDw9IHYuICovXG5cdEdlb20udmVydExlcSA9IGZ1bmN0aW9uKHUsdikge1xuXHRcdHJldHVybiAoKHUucyA8IHYucykgfHwgKHUucyA9PT0gdi5zICYmIHUudCA8PSB2LnQpKTtcblx0fTtcblxuXHQvKiBWZXJzaW9ucyBvZiBWZXJ0TGVxLCBFZGdlU2lnbiwgRWRnZUV2YWwgd2l0aCBzIGFuZCB0IHRyYW5zcG9zZWQuICovXG5cdEdlb20udHJhbnNMZXEgPSBmdW5jdGlvbih1LHYpIHtcblx0XHRyZXR1cm4gKCh1LnQgPCB2LnQpIHx8ICh1LnQgPT09IHYudCAmJiB1LnMgPD0gdi5zKSk7XG5cdH07XG5cblx0R2VvbS5lZGdlR29lc0xlZnQgPSBmdW5jdGlvbihlKSB7XG5cdFx0cmV0dXJuIEdlb20udmVydExlcSggZS5Ec3QsIGUuT3JnICk7XG5cdH07XG5cblx0R2VvbS5lZGdlR29lc1JpZ2h0ID0gZnVuY3Rpb24oZSkge1xuXHRcdHJldHVybiBHZW9tLnZlcnRMZXEoIGUuT3JnLCBlLkRzdCApO1xuXHR9O1xuXG5cdEdlb20udmVydEwxZGlzdCA9IGZ1bmN0aW9uKHUsdikge1xuXHRcdHJldHVybiAoTWF0aC5hYnModS5zIC0gdi5zKSArIE1hdGguYWJzKHUudCAtIHYudCkpO1xuXHR9O1xuXG5cdC8vVEVTU3JlYWwgdGVzZWRnZUV2YWwoIFRFU1N2ZXJ0ZXggKnUsIFRFU1N2ZXJ0ZXggKnYsIFRFU1N2ZXJ0ZXggKncgKVxuXHRHZW9tLmVkZ2VFdmFsID0gZnVuY3Rpb24oIHUsIHYsIHcgKSB7XG5cdFx0LyogR2l2ZW4gdGhyZWUgdmVydGljZXMgdSx2LHcgc3VjaCB0aGF0IFZlcnRMZXEodSx2KSAmJiBWZXJ0TGVxKHYsdyksXG5cdFx0KiBldmFsdWF0ZXMgdGhlIHQtY29vcmQgb2YgdGhlIGVkZ2UgdXcgYXQgdGhlIHMtY29vcmQgb2YgdGhlIHZlcnRleCB2LlxuXHRcdCogUmV0dXJucyB2LT50IC0gKHV3KSh2LT5zKSwgaWUuIHRoZSBzaWduZWQgZGlzdGFuY2UgZnJvbSB1dyB0byB2LlxuXHRcdCogSWYgdXcgaXMgdmVydGljYWwgKGFuZCB0aHVzIHBhc3NlcyB0aHJ1IHYpLCB0aGUgcmVzdWx0IGlzIHplcm8uXG5cdFx0KlxuXHRcdCogVGhlIGNhbGN1bGF0aW9uIGlzIGV4dHJlbWVseSBhY2N1cmF0ZSBhbmQgc3RhYmxlLCBldmVuIHdoZW4gdlxuXHRcdCogaXMgdmVyeSBjbG9zZSB0byB1IG9yIHcuICBJbiBwYXJ0aWN1bGFyIGlmIHdlIHNldCB2LT50ID0gMCBhbmRcblx0XHQqIGxldCByIGJlIHRoZSBuZWdhdGVkIHJlc3VsdCAodGhpcyBldmFsdWF0ZXMgKHV3KSh2LT5zKSksIHRoZW5cblx0XHQqIHIgaXMgZ3VhcmFudGVlZCB0byBzYXRpc2Z5IE1JTih1LT50LHctPnQpIDw9IHIgPD0gTUFYKHUtPnQsdy0+dCkuXG5cdFx0Ki9cblx0XHRhc3NlcnQoIEdlb20udmVydExlcSggdSwgdiApICYmIEdlb20udmVydExlcSggdiwgdyApKTtcblxuXHRcdHZhciBnYXBMID0gdi5zIC0gdS5zO1xuXHRcdHZhciBnYXBSID0gdy5zIC0gdi5zO1xuXG5cdFx0aWYoIGdhcEwgKyBnYXBSID4gMC4wICkge1xuXHRcdFx0aWYoIGdhcEwgPCBnYXBSICkge1xuXHRcdFx0XHRyZXR1cm4gKHYudCAtIHUudCkgKyAodS50IC0gdy50KSAqIChnYXBMIC8gKGdhcEwgKyBnYXBSKSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gKHYudCAtIHcudCkgKyAody50IC0gdS50KSAqIChnYXBSIC8gKGdhcEwgKyBnYXBSKSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdC8qIHZlcnRpY2FsIGxpbmUgKi9cblx0XHRyZXR1cm4gMC4wO1xuXHR9O1xuXG5cdC8vVEVTU3JlYWwgdGVzZWRnZVNpZ24oIFRFU1N2ZXJ0ZXggKnUsIFRFU1N2ZXJ0ZXggKnYsIFRFU1N2ZXJ0ZXggKncgKVxuXHRHZW9tLmVkZ2VTaWduID0gZnVuY3Rpb24oIHUsIHYsIHcgKSB7XG5cdFx0LyogUmV0dXJucyBhIG51bWJlciB3aG9zZSBzaWduIG1hdGNoZXMgRWRnZUV2YWwodSx2LHcpIGJ1dCB3aGljaFxuXHRcdCogaXMgY2hlYXBlciB0byBldmFsdWF0ZS4gIFJldHVybnMgPiAwLCA9PSAwICwgb3IgPCAwXG5cdFx0KiBhcyB2IGlzIGFib3ZlLCBvbiwgb3IgYmVsb3cgdGhlIGVkZ2UgdXcuXG5cdFx0Ki9cblx0XHRhc3NlcnQoIEdlb20udmVydExlcSggdSwgdiApICYmIEdlb20udmVydExlcSggdiwgdyApKTtcblxuXHRcdHZhciBnYXBMID0gdi5zIC0gdS5zO1xuXHRcdHZhciBnYXBSID0gdy5zIC0gdi5zO1xuXG5cdFx0aWYoIGdhcEwgKyBnYXBSID4gMC4wICkge1xuXHRcdFx0cmV0dXJuICh2LnQgLSB3LnQpICogZ2FwTCArICh2LnQgLSB1LnQpICogZ2FwUjtcblx0XHR9XG5cdFx0LyogdmVydGljYWwgbGluZSAqL1xuXHRcdHJldHVybiAwLjA7XG5cdH07XG5cblxuXHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblx0KiBEZWZpbmUgdmVyc2lvbnMgb2YgRWRnZVNpZ24sIEVkZ2VFdmFsIHdpdGggcyBhbmQgdCB0cmFuc3Bvc2VkLlxuXHQqL1xuXG5cdC8vVEVTU3JlYWwgdGVzdHJhbnNFdmFsKCBURVNTdmVydGV4ICp1LCBURVNTdmVydGV4ICp2LCBURVNTdmVydGV4ICp3IClcblx0R2VvbS50cmFuc0V2YWwgPSBmdW5jdGlvbiggdSwgdiwgdyApIHtcblx0XHQvKiBHaXZlbiB0aHJlZSB2ZXJ0aWNlcyB1LHYsdyBzdWNoIHRoYXQgVHJhbnNMZXEodSx2KSAmJiBUcmFuc0xlcSh2LHcpLFxuXHRcdCogZXZhbHVhdGVzIHRoZSB0LWNvb3JkIG9mIHRoZSBlZGdlIHV3IGF0IHRoZSBzLWNvb3JkIG9mIHRoZSB2ZXJ0ZXggdi5cblx0XHQqIFJldHVybnMgdi0+cyAtICh1dykodi0+dCksIGllLiB0aGUgc2lnbmVkIGRpc3RhbmNlIGZyb20gdXcgdG8gdi5cblx0XHQqIElmIHV3IGlzIHZlcnRpY2FsIChhbmQgdGh1cyBwYXNzZXMgdGhydSB2KSwgdGhlIHJlc3VsdCBpcyB6ZXJvLlxuXHRcdCpcblx0XHQqIFRoZSBjYWxjdWxhdGlvbiBpcyBleHRyZW1lbHkgYWNjdXJhdGUgYW5kIHN0YWJsZSwgZXZlbiB3aGVuIHZcblx0XHQqIGlzIHZlcnkgY2xvc2UgdG8gdSBvciB3LiAgSW4gcGFydGljdWxhciBpZiB3ZSBzZXQgdi0+cyA9IDAgYW5kXG5cdFx0KiBsZXQgciBiZSB0aGUgbmVnYXRlZCByZXN1bHQgKHRoaXMgZXZhbHVhdGVzICh1dykodi0+dCkpLCB0aGVuXG5cdFx0KiByIGlzIGd1YXJhbnRlZWQgdG8gc2F0aXNmeSBNSU4odS0+cyx3LT5zKSA8PSByIDw9IE1BWCh1LT5zLHctPnMpLlxuXHRcdCovXG5cdFx0YXNzZXJ0KCBHZW9tLnRyYW5zTGVxKCB1LCB2ICkgJiYgR2VvbS50cmFuc0xlcSggdiwgdyApKTtcblxuXHRcdHZhciBnYXBMID0gdi50IC0gdS50O1xuXHRcdHZhciBnYXBSID0gdy50IC0gdi50O1xuXG5cdFx0aWYoIGdhcEwgKyBnYXBSID4gMC4wICkge1xuXHRcdFx0aWYoIGdhcEwgPCBnYXBSICkge1xuXHRcdFx0XHRyZXR1cm4gKHYucyAtIHUucykgKyAodS5zIC0gdy5zKSAqIChnYXBMIC8gKGdhcEwgKyBnYXBSKSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gKHYucyAtIHcucykgKyAody5zIC0gdS5zKSAqIChnYXBSIC8gKGdhcEwgKyBnYXBSKSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdC8qIHZlcnRpY2FsIGxpbmUgKi9cblx0XHRyZXR1cm4gMC4wO1xuXHR9O1xuXG5cdC8vVEVTU3JlYWwgdGVzdHJhbnNTaWduKCBURVNTdmVydGV4ICp1LCBURVNTdmVydGV4ICp2LCBURVNTdmVydGV4ICp3IClcblx0R2VvbS50cmFuc1NpZ24gPSBmdW5jdGlvbiggdSwgdiwgdyApIHtcblx0XHQvKiBSZXR1cm5zIGEgbnVtYmVyIHdob3NlIHNpZ24gbWF0Y2hlcyBUcmFuc0V2YWwodSx2LHcpIGJ1dCB3aGljaFxuXHRcdCogaXMgY2hlYXBlciB0byBldmFsdWF0ZS4gIFJldHVybnMgPiAwLCA9PSAwICwgb3IgPCAwXG5cdFx0KiBhcyB2IGlzIGFib3ZlLCBvbiwgb3IgYmVsb3cgdGhlIGVkZ2UgdXcuXG5cdFx0Ki9cblx0XHRhc3NlcnQoIEdlb20udHJhbnNMZXEoIHUsIHYgKSAmJiBHZW9tLnRyYW5zTGVxKCB2LCB3ICkpO1xuXG5cdFx0dmFyIGdhcEwgPSB2LnQgLSB1LnQ7XG5cdFx0dmFyIGdhcFIgPSB3LnQgLSB2LnQ7XG5cblx0XHRpZiggZ2FwTCArIGdhcFIgPiAwLjAgKSB7XG5cdFx0XHRyZXR1cm4gKHYucyAtIHcucykgKiBnYXBMICsgKHYucyAtIHUucykgKiBnYXBSO1xuXHRcdH1cblx0XHQvKiB2ZXJ0aWNhbCBsaW5lICovXG5cdFx0cmV0dXJuIDAuMDtcblx0fTtcblxuXG5cdC8vaW50IHRlc3ZlcnRDQ1coIFRFU1N2ZXJ0ZXggKnUsIFRFU1N2ZXJ0ZXggKnYsIFRFU1N2ZXJ0ZXggKncgKVxuXHRHZW9tLnZlcnRDQ1cgPSBmdW5jdGlvbiggdSwgdiwgdyApIHtcblx0XHQvKiBGb3IgYWxtb3N0LWRlZ2VuZXJhdGUgc2l0dWF0aW9ucywgdGhlIHJlc3VsdHMgYXJlIG5vdCByZWxpYWJsZS5cblx0XHQqIFVubGVzcyB0aGUgZmxvYXRpbmctcG9pbnQgYXJpdGhtZXRpYyBjYW4gYmUgcGVyZm9ybWVkIHdpdGhvdXRcblx0XHQqIHJvdW5kaW5nIGVycm9ycywgKmFueSogaW1wbGVtZW50YXRpb24gd2lsbCBnaXZlIGluY29ycmVjdCByZXN1bHRzXG5cdFx0KiBvbiBzb21lIGRlZ2VuZXJhdGUgaW5wdXRzLCBzbyB0aGUgY2xpZW50IG11c3QgaGF2ZSBzb21lIHdheSB0b1xuXHRcdCogaGFuZGxlIHRoaXMgc2l0dWF0aW9uLlxuXHRcdCovXG5cdFx0cmV0dXJuICh1LnMqKHYudCAtIHcudCkgKyB2LnMqKHcudCAtIHUudCkgKyB3LnMqKHUudCAtIHYudCkpID49IDAuMDtcblx0fTtcblxuXHQvKiBHaXZlbiBwYXJhbWV0ZXJzIGEseCxiLHkgcmV0dXJucyB0aGUgdmFsdWUgKGIqeCthKnkpLyhhK2IpLFxuXHQqIG9yICh4K3kpLzIgaWYgYT09Yj09MC4gIEl0IHJlcXVpcmVzIHRoYXQgYSxiID49IDAsIGFuZCBlbmZvcmNlc1xuXHQqIHRoaXMgaW4gdGhlIHJhcmUgY2FzZSB0aGF0IG9uZSBhcmd1bWVudCBpcyBzbGlnaHRseSBuZWdhdGl2ZS5cblx0KiBUaGUgaW1wbGVtZW50YXRpb24gaXMgZXh0cmVtZWx5IHN0YWJsZSBudW1lcmljYWxseS5cblx0KiBJbiBwYXJ0aWN1bGFyIGl0IGd1YXJhbnRlZXMgdGhhdCB0aGUgcmVzdWx0IHIgc2F0aXNmaWVzXG5cdCogTUlOKHgseSkgPD0gciA8PSBNQVgoeCx5KSwgYW5kIHRoZSByZXN1bHRzIGFyZSB2ZXJ5IGFjY3VyYXRlXG5cdCogZXZlbiB3aGVuIGEgYW5kIGIgZGlmZmVyIGdyZWF0bHkgaW4gbWFnbml0dWRlLlxuXHQqL1xuXHRHZW9tLmludGVycG9sYXRlID0gZnVuY3Rpb24oYSx4LGIseSkge1xuXHRcdHJldHVybiAoYSA9IChhIDwgMCkgPyAwIDogYSwgYiA9IChiIDwgMCkgPyAwIDogYiwgKChhIDw9IGIpID8gKChiID09IDApID8gKCh4K3kpIC8gMikgOiAoeCArICh5LXgpICogKGEvKGErYikpKSkgOiAoeSArICh4LXkpICogKGIvKGErYikpKSkpO1xuXHR9O1xuXG5cdC8qXG5cdCNpZm5kZWYgRk9SX1RSSVRFX1RFU1RfUFJPR1JBTVxuXHQjZGVmaW5lIEludGVycG9sYXRlKGEseCxiLHkpXHRSZWFsSW50ZXJwb2xhdGUoYSx4LGIseSlcblx0I2Vsc2VcblxuXHQvLyBDbGFpbTogdGhlIE9OTFkgcHJvcGVydHkgdGhlIHN3ZWVwIGFsZ29yaXRobSByZWxpZXMgb24gaXMgdGhhdFxuXHQvLyBNSU4oeCx5KSA8PSByIDw9IE1BWCh4LHkpLiAgVGhpcyBpcyBhIG5hc3R5IHdheSB0byB0ZXN0IHRoYXQuXG5cdCNpbmNsdWRlIDxzdGRsaWIuaD5cblx0ZXh0ZXJuIGludCBSYW5kb21JbnRlcnBvbGF0ZTtcblxuXHRkb3VibGUgSW50ZXJwb2xhdGUoIGRvdWJsZSBhLCBkb3VibGUgeCwgZG91YmxlIGIsIGRvdWJsZSB5KVxuXHR7XG5cdFx0cHJpbnRmKFwiKioqKioqKioqKioqKioqKioqKioqJWRcXG5cIixSYW5kb21JbnRlcnBvbGF0ZSk7XG5cdFx0aWYoIFJhbmRvbUludGVycG9sYXRlICkge1xuXHRcdFx0YSA9IDEuMiAqIGRyYW5kNDgoKSAtIDAuMTtcblx0XHRcdGEgPSAoYSA8IDApID8gMCA6ICgoYSA+IDEpID8gMSA6IGEpO1xuXHRcdFx0YiA9IDEuMCAtIGE7XG5cdFx0fVxuXHRcdHJldHVybiBSZWFsSW50ZXJwb2xhdGUoYSx4LGIseSk7XG5cdH1cblx0I2VuZGlmKi9cblxuXHRHZW9tLmludGVyc2VjdCA9IGZ1bmN0aW9uKCBvMSwgZDEsIG8yLCBkMiwgdiApIHtcblx0XHQvKiBHaXZlbiBlZGdlcyAobzEsZDEpIGFuZCAobzIsZDIpLCBjb21wdXRlIHRoZWlyIHBvaW50IG9mIGludGVyc2VjdGlvbi5cblx0XHQqIFRoZSBjb21wdXRlZCBwb2ludCBpcyBndWFyYW50ZWVkIHRvIGxpZSBpbiB0aGUgaW50ZXJzZWN0aW9uIG9mIHRoZVxuXHRcdCogYm91bmRpbmcgcmVjdGFuZ2xlcyBkZWZpbmVkIGJ5IGVhY2ggZWRnZS5cblx0XHQqL1xuXHRcdHZhciB6MSwgejI7XG5cdFx0dmFyIHQ7XG5cblx0XHQvKiBUaGlzIGlzIGNlcnRhaW5seSBub3QgdGhlIG1vc3QgZWZmaWNpZW50IHdheSB0byBmaW5kIHRoZSBpbnRlcnNlY3Rpb25cblx0XHQqIG9mIHR3byBsaW5lIHNlZ21lbnRzLCBidXQgaXQgaXMgdmVyeSBudW1lcmljYWxseSBzdGFibGUuXG5cdFx0KlxuXHRcdCogU3RyYXRlZ3k6IGZpbmQgdGhlIHR3byBtaWRkbGUgdmVydGljZXMgaW4gdGhlIFZlcnRMZXEgb3JkZXJpbmcsXG5cdFx0KiBhbmQgaW50ZXJwb2xhdGUgdGhlIGludGVyc2VjdGlvbiBzLXZhbHVlIGZyb20gdGhlc2UuICBUaGVuIHJlcGVhdFxuXHRcdCogdXNpbmcgdGhlIFRyYW5zTGVxIG9yZGVyaW5nIHRvIGZpbmQgdGhlIGludGVyc2VjdGlvbiB0LXZhbHVlLlxuXHRcdCovXG5cblx0XHRpZiggISBHZW9tLnZlcnRMZXEoIG8xLCBkMSApKSB7IHQgPSBvMTsgbzEgPSBkMTsgZDEgPSB0OyB9IC8vc3dhcCggbzEsIGQxICk7IH1cblx0XHRpZiggISBHZW9tLnZlcnRMZXEoIG8yLCBkMiApKSB7IHQgPSBvMjsgbzIgPSBkMjsgZDIgPSB0OyB9IC8vc3dhcCggbzIsIGQyICk7IH1cblx0XHRpZiggISBHZW9tLnZlcnRMZXEoIG8xLCBvMiApKSB7IHQgPSBvMTsgbzEgPSBvMjsgbzIgPSB0OyB0ID0gZDE7IGQxID0gZDI7IGQyID0gdDsgfS8vc3dhcCggbzEsIG8yICk7IHN3YXAoIGQxLCBkMiApOyB9XG5cblx0XHRpZiggISBHZW9tLnZlcnRMZXEoIG8yLCBkMSApKSB7XG5cdFx0XHQvKiBUZWNobmljYWxseSwgbm8gaW50ZXJzZWN0aW9uIC0tIGRvIG91ciBiZXN0ICovXG5cdFx0XHR2LnMgPSAobzIucyArIGQxLnMpIC8gMjtcblx0XHR9IGVsc2UgaWYoIEdlb20udmVydExlcSggZDEsIGQyICkpIHtcblx0XHRcdC8qIEludGVycG9sYXRlIGJldHdlZW4gbzIgYW5kIGQxICovXG5cdFx0XHR6MSA9IEdlb20uZWRnZUV2YWwoIG8xLCBvMiwgZDEgKTtcblx0XHRcdHoyID0gR2VvbS5lZGdlRXZhbCggbzIsIGQxLCBkMiApO1xuXHRcdFx0aWYoIHoxK3oyIDwgMCApIHsgejEgPSAtejE7IHoyID0gLXoyOyB9XG5cdFx0XHR2LnMgPSBHZW9tLmludGVycG9sYXRlKCB6MSwgbzIucywgejIsIGQxLnMgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0LyogSW50ZXJwb2xhdGUgYmV0d2VlbiBvMiBhbmQgZDIgKi9cblx0XHRcdHoxID0gR2VvbS5lZGdlU2lnbiggbzEsIG8yLCBkMSApO1xuXHRcdFx0ejIgPSAtR2VvbS5lZGdlU2lnbiggbzEsIGQyLCBkMSApO1xuXHRcdFx0aWYoIHoxK3oyIDwgMCApIHsgejEgPSAtejE7IHoyID0gLXoyOyB9XG5cdFx0XHR2LnMgPSBHZW9tLmludGVycG9sYXRlKCB6MSwgbzIucywgejIsIGQyLnMgKTtcblx0XHR9XG5cblx0XHQvKiBOb3cgcmVwZWF0IHRoZSBwcm9jZXNzIGZvciB0ICovXG5cblx0XHRpZiggISBHZW9tLnRyYW5zTGVxKCBvMSwgZDEgKSkgeyB0ID0gbzE7IG8xID0gZDE7IGQxID0gdDsgfSAvL3N3YXAoIG8xLCBkMSApOyB9XG5cdFx0aWYoICEgR2VvbS50cmFuc0xlcSggbzIsIGQyICkpIHsgdCA9IG8yOyBvMiA9IGQyOyBkMiA9IHQ7IH0gLy9zd2FwKCBvMiwgZDIgKTsgfVxuXHRcdGlmKCAhIEdlb20udHJhbnNMZXEoIG8xLCBvMiApKSB7IHQgPSBvMTsgbzEgPSBvMjsgbzIgPSB0OyB0ID0gZDE7IGQxID0gZDI7IGQyID0gdDsgfSAvL3N3YXAoIG8xLCBvMiApOyBzd2FwKCBkMSwgZDIgKTsgfVxuXG5cdFx0aWYoICEgR2VvbS50cmFuc0xlcSggbzIsIGQxICkpIHtcblx0XHRcdC8qIFRlY2huaWNhbGx5LCBubyBpbnRlcnNlY3Rpb24gLS0gZG8gb3VyIGJlc3QgKi9cblx0XHRcdHYudCA9IChvMi50ICsgZDEudCkgLyAyO1xuXHRcdH0gZWxzZSBpZiggR2VvbS50cmFuc0xlcSggZDEsIGQyICkpIHtcblx0XHRcdC8qIEludGVycG9sYXRlIGJldHdlZW4gbzIgYW5kIGQxICovXG5cdFx0XHR6MSA9IEdlb20udHJhbnNFdmFsKCBvMSwgbzIsIGQxICk7XG5cdFx0XHR6MiA9IEdlb20udHJhbnNFdmFsKCBvMiwgZDEsIGQyICk7XG5cdFx0XHRpZiggejErejIgPCAwICkgeyB6MSA9IC16MTsgejIgPSAtejI7IH1cblx0XHRcdHYudCA9IEdlb20uaW50ZXJwb2xhdGUoIHoxLCBvMi50LCB6MiwgZDEudCApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvKiBJbnRlcnBvbGF0ZSBiZXR3ZWVuIG8yIGFuZCBkMiAqL1xuXHRcdFx0ejEgPSBHZW9tLnRyYW5zU2lnbiggbzEsIG8yLCBkMSApO1xuXHRcdFx0ejIgPSAtR2VvbS50cmFuc1NpZ24oIG8xLCBkMiwgZDEgKTtcblx0XHRcdGlmKCB6MSt6MiA8IDAgKSB7IHoxID0gLXoxOyB6MiA9IC16MjsgfVxuXHRcdFx0di50ID0gR2VvbS5pbnRlcnBvbGF0ZSggejEsIG8yLnQsIHoyLCBkMi50ICk7XG5cdFx0fVxuXHR9O1xuXG5cblxuXHRmdW5jdGlvbiBEaWN0Tm9kZSgpIHtcblx0XHR0aGlzLmtleSA9IG51bGw7XG5cdFx0dGhpcy5uZXh0ID0gbnVsbDtcblx0XHR0aGlzLnByZXYgPSBudWxsO1xuXHR9O1xuXG5cdGZ1bmN0aW9uIERpY3QoZnJhbWUsIGxlcSkge1xuXHRcdHRoaXMuaGVhZCA9IG5ldyBEaWN0Tm9kZSgpO1xuXHRcdHRoaXMuaGVhZC5uZXh0ID0gdGhpcy5oZWFkO1xuXHRcdHRoaXMuaGVhZC5wcmV2ID0gdGhpcy5oZWFkO1xuXHRcdHRoaXMuZnJhbWUgPSBmcmFtZTtcblx0XHR0aGlzLmxlcSA9IGxlcTtcblx0fTtcblxuXHREaWN0LnByb3RvdHlwZSA9IHtcblx0XHRtaW46IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuaGVhZC5uZXh0O1xuXHRcdH0sXG5cblx0XHRtYXg6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuaGVhZC5wcmV2O1xuXHRcdH0sXG5cblx0XHRpbnNlcnQ6IGZ1bmN0aW9uKGspIHtcblx0XHRcdHJldHVybiB0aGlzLmluc2VydEJlZm9yZSh0aGlzLmhlYWQsIGspO1xuXHRcdH0sXG5cblx0XHRzZWFyY2g6IGZ1bmN0aW9uKGtleSkge1xuXHRcdFx0LyogU2VhcmNoIHJldHVybnMgdGhlIG5vZGUgd2l0aCB0aGUgc21hbGxlc3Qga2V5IGdyZWF0ZXIgdGhhbiBvciBlcXVhbFxuXHRcdFx0KiB0byB0aGUgZ2l2ZW4ga2V5LiAgSWYgdGhlcmUgaXMgbm8gc3VjaCBrZXksIHJldHVybnMgYSBub2RlIHdob3NlXG5cdFx0XHQqIGtleSBpcyBOVUxMLiAgU2ltaWxhcmx5LCBTdWNjKE1heChkKSkgaGFzIGEgTlVMTCBrZXksIGV0Yy5cblx0XHRcdCovXG5cdFx0XHR2YXIgbm9kZSA9IHRoaXMuaGVhZDtcblx0XHRcdGRvIHtcblx0XHRcdFx0bm9kZSA9IG5vZGUubmV4dDtcblx0XHRcdH0gd2hpbGUoIG5vZGUua2V5ICE9PSBudWxsICYmICEgdGhpcy5sZXEodGhpcy5mcmFtZSwga2V5LCBub2RlLmtleSkpO1xuXG5cdFx0XHRyZXR1cm4gbm9kZTtcblx0XHR9LFxuXG5cdFx0aW5zZXJ0QmVmb3JlOiBmdW5jdGlvbihub2RlLCBrZXkpIHtcblx0XHRcdGRvIHtcblx0XHRcdFx0bm9kZSA9IG5vZGUucHJldjtcblx0XHRcdH0gd2hpbGUoIG5vZGUua2V5ICE9PSBudWxsICYmICEgdGhpcy5sZXEodGhpcy5mcmFtZSwgbm9kZS5rZXksIGtleSkpO1xuXG5cdFx0XHR2YXIgbmV3Tm9kZSA9IG5ldyBEaWN0Tm9kZSgpO1xuXHRcdFx0bmV3Tm9kZS5rZXkgPSBrZXk7XG5cdFx0XHRuZXdOb2RlLm5leHQgPSBub2RlLm5leHQ7XG5cdFx0XHRub2RlLm5leHQucHJldiA9IG5ld05vZGU7XG5cdFx0XHRuZXdOb2RlLnByZXYgPSBub2RlO1xuXHRcdFx0bm9kZS5uZXh0ID0gbmV3Tm9kZTtcblxuXHRcdFx0cmV0dXJuIG5ld05vZGU7XG5cdFx0fSxcblxuXHRcdGRlbGV0ZTogZnVuY3Rpb24obm9kZSkge1xuXHRcdFx0bm9kZS5uZXh0LnByZXYgPSBub2RlLnByZXY7XG5cdFx0XHRub2RlLnByZXYubmV4dCA9IG5vZGUubmV4dDtcblx0XHR9XG5cdH07XG5cblxuXHRmdW5jdGlvbiBQUW5vZGUoKSB7XG5cdFx0dGhpcy5oYW5kbGUgPSBudWxsO1xuXHR9XG5cblx0ZnVuY3Rpb24gUFFoYW5kbGVFbGVtKCkge1xuXHRcdHRoaXMua2V5ID0gbnVsbDtcblx0XHR0aGlzLm5vZGUgPSBudWxsO1xuXHR9XG5cblx0ZnVuY3Rpb24gUHJpb3JpdHlRKHNpemUsIGxlcSkge1xuXHRcdHRoaXMuc2l6ZSA9IDA7XG5cdFx0dGhpcy5tYXggPSBzaXplO1xuXG5cdFx0dGhpcy5ub2RlcyA9IFtdO1xuXHRcdHRoaXMubm9kZXMubGVuZ3RoID0gc2l6ZSsxO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ub2Rlcy5sZW5ndGg7IGkrKylcblx0XHRcdHRoaXMubm9kZXNbaV0gPSBuZXcgUFFub2RlKCk7XG5cblx0XHR0aGlzLmhhbmRsZXMgPSBbXTtcblx0XHR0aGlzLmhhbmRsZXMubGVuZ3RoID0gc2l6ZSsxO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5oYW5kbGVzLmxlbmd0aDsgaSsrKVxuXHRcdFx0dGhpcy5oYW5kbGVzW2ldID0gbmV3IFBRaGFuZGxlRWxlbSgpO1xuXG5cdFx0dGhpcy5pbml0aWFsaXplZCA9IGZhbHNlO1xuXHRcdHRoaXMuZnJlZUxpc3QgPSAwO1xuXHRcdHRoaXMubGVxID0gbGVxO1xuXG5cdFx0dGhpcy5ub2Rlc1sxXS5oYW5kbGUgPSAxO1x0Lyogc28gdGhhdCBNaW5pbXVtKCkgcmV0dXJucyBOVUxMICovXG5cdFx0dGhpcy5oYW5kbGVzWzFdLmtleSA9IG51bGw7XG5cdH07XG5cblx0UHJpb3JpdHlRLnByb3RvdHlwZSA9IHtcblxuXHRcdGZsb2F0RG93bl86IGZ1bmN0aW9uKCBjdXJyIClcblx0XHR7XG5cdFx0XHR2YXIgbiA9IHRoaXMubm9kZXM7XG5cdFx0XHR2YXIgaCA9IHRoaXMuaGFuZGxlcztcblx0XHRcdHZhciBoQ3VyciwgaENoaWxkO1xuXHRcdFx0dmFyIGNoaWxkO1xuXG5cdFx0XHRoQ3VyciA9IG5bY3Vycl0uaGFuZGxlO1xuXHRcdFx0Zm9yKCA7OyApIHtcblx0XHRcdFx0Y2hpbGQgPSBjdXJyIDw8IDE7XG5cdFx0XHRcdGlmKCBjaGlsZCA8IHRoaXMuc2l6ZSAmJiB0aGlzLmxlcSggaFtuW2NoaWxkKzFdLmhhbmRsZV0ua2V5LCBoW25bY2hpbGRdLmhhbmRsZV0ua2V5ICkpIHtcblx0XHRcdFx0XHQrK2NoaWxkO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0YXNzZXJ0KGNoaWxkIDw9IHRoaXMubWF4KTtcblxuXHRcdFx0XHRoQ2hpbGQgPSBuW2NoaWxkXS5oYW5kbGU7XG5cdFx0XHRcdGlmKCBjaGlsZCA+IHRoaXMuc2l6ZSB8fCB0aGlzLmxlcSggaFtoQ3Vycl0ua2V5LCBoW2hDaGlsZF0ua2V5ICkpIHtcblx0XHRcdFx0XHRuW2N1cnJdLmhhbmRsZSA9IGhDdXJyO1xuXHRcdFx0XHRcdGhbaEN1cnJdLm5vZGUgPSBjdXJyO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG5bY3Vycl0uaGFuZGxlID0gaENoaWxkO1xuXHRcdFx0XHRoW2hDaGlsZF0ubm9kZSA9IGN1cnI7XG5cdFx0XHRcdGN1cnIgPSBjaGlsZDtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0ZmxvYXRVcF86IGZ1bmN0aW9uKCBjdXJyIClcblx0XHR7XG5cdFx0XHR2YXIgbiA9IHRoaXMubm9kZXM7XG5cdFx0XHR2YXIgaCA9IHRoaXMuaGFuZGxlcztcblx0XHRcdHZhciBoQ3VyciwgaFBhcmVudDtcblx0XHRcdHZhciBwYXJlbnQ7XG5cblx0XHRcdGhDdXJyID0gbltjdXJyXS5oYW5kbGU7XG5cdFx0XHRmb3IoIDs7ICkge1xuXHRcdFx0XHRwYXJlbnQgPSBjdXJyID4+IDE7XG5cdFx0XHRcdGhQYXJlbnQgPSBuW3BhcmVudF0uaGFuZGxlO1xuXHRcdFx0XHRpZiggcGFyZW50ID09IDAgfHwgdGhpcy5sZXEoIGhbaFBhcmVudF0ua2V5LCBoW2hDdXJyXS5rZXkgKSkge1xuXHRcdFx0XHRcdG5bY3Vycl0uaGFuZGxlID0gaEN1cnI7XG5cdFx0XHRcdFx0aFtoQ3Vycl0ubm9kZSA9IGN1cnI7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdFx0bltjdXJyXS5oYW5kbGUgPSBoUGFyZW50O1xuXHRcdFx0XHRoW2hQYXJlbnRdLm5vZGUgPSBjdXJyO1xuXHRcdFx0XHRjdXJyID0gcGFyZW50O1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRpbml0OiBmdW5jdGlvbigpIHtcblx0XHRcdC8qIFRoaXMgbWV0aG9kIG9mIGJ1aWxkaW5nIGEgaGVhcCBpcyBPKG4pLCByYXRoZXIgdGhhbiBPKG4gbGcgbikuICovXG5cdFx0XHRmb3IoIHZhciBpID0gdGhpcy5zaXplOyBpID49IDE7IC0taSApIHtcblx0XHRcdFx0dGhpcy5mbG9hdERvd25fKCBpICk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmluaXRpYWxpemVkID0gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0bWluOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLmhhbmRsZXNbdGhpcy5ub2Rlc1sxXS5oYW5kbGVdLmtleTtcblx0XHR9LFxuXG5cdFx0aXNFbXB0eTogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLnNpemUgPT09IDA7XG5cdFx0fSxcblxuXHRcdC8qIHJlYWxseSBwcUhlYXBJbnNlcnQgKi9cblx0XHQvKiByZXR1cm5zIElOVl9IQU5ETEUgaWZmIG91dCBvZiBtZW1vcnkgKi9cblx0XHQvL1BRaGFuZGxlIHBxSGVhcEluc2VydCggVEVTU2FsbG9jKiBhbGxvYywgUHJpb3JpdHlRSGVhcCAqcHEsIFBRa2V5IGtleU5ldyApXG5cdFx0aW5zZXJ0OiBmdW5jdGlvbihrZXlOZXcpXG5cdFx0e1xuXHRcdFx0dmFyIGN1cnI7XG5cdFx0XHR2YXIgZnJlZTtcblxuXHRcdFx0Y3VyciA9ICsrdGhpcy5zaXplO1xuXHRcdFx0aWYoIChjdXJyKjIpID4gdGhpcy5tYXggKSB7XG5cdFx0XHRcdHRoaXMubWF4ICo9IDI7XG5cdFx0XHRcdHZhciBzO1xuXHRcdFx0XHRzID0gdGhpcy5ub2Rlcy5sZW5ndGg7XG5cdFx0XHRcdHRoaXMubm9kZXMubGVuZ3RoID0gdGhpcy5tYXgrMTtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IHM7IGkgPCB0aGlzLm5vZGVzLmxlbmd0aDsgaSsrKVxuXHRcdFx0XHRcdHRoaXMubm9kZXNbaV0gPSBuZXcgUFFub2RlKCk7XG5cblx0XHRcdFx0cyA9IHRoaXMuaGFuZGxlcy5sZW5ndGg7XG5cdFx0XHRcdHRoaXMuaGFuZGxlcy5sZW5ndGggPSB0aGlzLm1heCsxO1xuXHRcdFx0XHRmb3IgKHZhciBpID0gczsgaSA8IHRoaXMuaGFuZGxlcy5sZW5ndGg7IGkrKylcblx0XHRcdFx0XHR0aGlzLmhhbmRsZXNbaV0gPSBuZXcgUFFoYW5kbGVFbGVtKCk7XG5cdFx0XHR9XG5cblx0XHRcdGlmKCB0aGlzLmZyZWVMaXN0ID09PSAwICkge1xuXHRcdFx0XHRmcmVlID0gY3Vycjtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGZyZWUgPSB0aGlzLmZyZWVMaXN0O1xuXHRcdFx0XHR0aGlzLmZyZWVMaXN0ID0gdGhpcy5oYW5kbGVzW2ZyZWVdLm5vZGU7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMubm9kZXNbY3Vycl0uaGFuZGxlID0gZnJlZTtcblx0XHRcdHRoaXMuaGFuZGxlc1tmcmVlXS5ub2RlID0gY3Vycjtcblx0XHRcdHRoaXMuaGFuZGxlc1tmcmVlXS5rZXkgPSBrZXlOZXc7XG5cblx0XHRcdGlmKCB0aGlzLmluaXRpYWxpemVkICkge1xuXHRcdFx0XHR0aGlzLmZsb2F0VXBfKCBjdXJyICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZnJlZTtcblx0XHR9LFxuXG5cdFx0Ly9QUWtleSBwcUhlYXBFeHRyYWN0TWluKCBQcmlvcml0eVFIZWFwICpwcSApXG5cdFx0ZXh0cmFjdE1pbjogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbiA9IHRoaXMubm9kZXM7XG5cdFx0XHR2YXIgaCA9IHRoaXMuaGFuZGxlcztcblx0XHRcdHZhciBoTWluID0gblsxXS5oYW5kbGU7XG5cdFx0XHR2YXIgbWluID0gaFtoTWluXS5rZXk7XG5cblx0XHRcdGlmKCB0aGlzLnNpemUgPiAwICkge1xuXHRcdFx0XHRuWzFdLmhhbmRsZSA9IG5bdGhpcy5zaXplXS5oYW5kbGU7XG5cdFx0XHRcdGhbblsxXS5oYW5kbGVdLm5vZGUgPSAxO1xuXG5cdFx0XHRcdGhbaE1pbl0ua2V5ID0gbnVsbDtcblx0XHRcdFx0aFtoTWluXS5ub2RlID0gdGhpcy5mcmVlTGlzdDtcblx0XHRcdFx0dGhpcy5mcmVlTGlzdCA9IGhNaW47XG5cblx0XHRcdFx0LS10aGlzLnNpemU7XG5cdFx0XHRcdGlmKCB0aGlzLnNpemUgPiAwICkge1xuXHRcdFx0XHRcdHRoaXMuZmxvYXREb3duXyggMSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWluO1xuXHRcdH0sXG5cblx0XHRkZWxldGU6IGZ1bmN0aW9uKCBoQ3VyciApIHtcblx0XHRcdHZhciBuID0gdGhpcy5ub2Rlcztcblx0XHRcdHZhciBoID0gdGhpcy5oYW5kbGVzO1xuXHRcdFx0dmFyIGN1cnI7XG5cblx0XHRcdGFzc2VydCggaEN1cnIgPj0gMSAmJiBoQ3VyciA8PSB0aGlzLm1heCAmJiBoW2hDdXJyXS5rZXkgIT09IG51bGwgKTtcblxuXHRcdFx0Y3VyciA9IGhbaEN1cnJdLm5vZGU7XG5cdFx0XHRuW2N1cnJdLmhhbmRsZSA9IG5bdGhpcy5zaXplXS5oYW5kbGU7XG5cdFx0XHRoW25bY3Vycl0uaGFuZGxlXS5ub2RlID0gY3VycjtcblxuXHRcdFx0LS10aGlzLnNpemU7XG5cdFx0XHRpZiggY3VyciA8PSB0aGlzLnNpemUgKSB7XG5cdFx0XHRcdGlmKCBjdXJyIDw9IDEgfHwgdGhpcy5sZXEoIGhbbltjdXJyPj4xXS5oYW5kbGVdLmtleSwgaFtuW2N1cnJdLmhhbmRsZV0ua2V5ICkpIHtcblx0XHRcdFx0XHR0aGlzLmZsb2F0RG93bl8oIGN1cnIgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLmZsb2F0VXBfKCBjdXJyICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGhbaEN1cnJdLmtleSA9IG51bGw7XG5cdFx0XHRoW2hDdXJyXS5ub2RlID0gdGhpcy5mcmVlTGlzdDtcblx0XHRcdHRoaXMuZnJlZUxpc3QgPSBoQ3Vycjtcblx0XHR9XG5cdH07XG5cblxuXHQvKiBGb3IgZWFjaCBwYWlyIG9mIGFkamFjZW50IGVkZ2VzIGNyb3NzaW5nIHRoZSBzd2VlcCBsaW5lLCB0aGVyZSBpc1xuXHQqIGFuIEFjdGl2ZVJlZ2lvbiB0byByZXByZXNlbnQgdGhlIHJlZ2lvbiBiZXR3ZWVuIHRoZW0uICBUaGUgYWN0aXZlXG5cdCogcmVnaW9ucyBhcmUga2VwdCBpbiBzb3J0ZWQgb3JkZXIgaW4gYSBkeW5hbWljIGRpY3Rpb25hcnkuICBBcyB0aGVcblx0KiBzd2VlcCBsaW5lIGNyb3NzZXMgZWFjaCB2ZXJ0ZXgsIHdlIHVwZGF0ZSB0aGUgYWZmZWN0ZWQgcmVnaW9ucy5cblx0Ki9cblxuXHRmdW5jdGlvbiBBY3RpdmVSZWdpb24oKSB7XG5cdFx0dGhpcy5lVXAgPSBudWxsO1x0XHQvKiB1cHBlciBlZGdlLCBkaXJlY3RlZCByaWdodCB0byBsZWZ0ICovXG5cdFx0dGhpcy5ub2RlVXAgPSBudWxsO1x0LyogZGljdGlvbmFyeSBub2RlIGNvcnJlc3BvbmRpbmcgdG8gZVVwICovXG5cdFx0dGhpcy53aW5kaW5nTnVtYmVyID0gMDtcdC8qIHVzZWQgdG8gZGV0ZXJtaW5lIHdoaWNoIHJlZ2lvbnMgYXJlXG5cdFx0XHRcdFx0XHRcdFx0KiBpbnNpZGUgdGhlIHBvbHlnb24gKi9cblx0XHR0aGlzLmluc2lkZSA9IGZhbHNlO1x0XHQvKiBpcyB0aGlzIHJlZ2lvbiBpbnNpZGUgdGhlIHBvbHlnb24/ICovXG5cdFx0dGhpcy5zZW50aW5lbCA9IGZhbHNlO1x0LyogbWFya3MgZmFrZSBlZGdlcyBhdCB0ID0gKy8taW5maW5pdHkgKi9cblx0XHR0aGlzLmRpcnR5ID0gZmFsc2U7XHRcdC8qIG1hcmtzIHJlZ2lvbnMgd2hlcmUgdGhlIHVwcGVyIG9yIGxvd2VyXG5cdFx0XHRcdFx0XHQqIGVkZ2UgaGFzIGNoYW5nZWQsIGJ1dCB3ZSBoYXZlbid0IGNoZWNrZWRcblx0XHRcdFx0XHRcdCogd2hldGhlciB0aGV5IGludGVyc2VjdCB5ZXQgKi9cblx0XHR0aGlzLmZpeFVwcGVyRWRnZSA9IGZhbHNlO1x0LyogbWFya3MgdGVtcG9yYXJ5IGVkZ2VzIGludHJvZHVjZWQgd2hlblxuXHRcdFx0XHRcdFx0XHQqIHdlIHByb2Nlc3MgYSBcInJpZ2h0IHZlcnRleFwiIChvbmUgd2l0aG91dFxuXHRcdFx0XHRcdFx0XHQqIGFueSBlZGdlcyBsZWF2aW5nIHRvIHRoZSByaWdodCkgKi9cblx0fTtcblxuXHR2YXIgU3dlZXAgPSB7fTtcblxuXHRTd2VlcC5yZWdpb25CZWxvdyA9IGZ1bmN0aW9uKHIpIHtcblx0XHRyZXR1cm4gci5ub2RlVXAucHJldi5rZXk7XG5cdH1cblxuXHRTd2VlcC5yZWdpb25BYm92ZSA9IGZ1bmN0aW9uKHIpIHtcblx0XHRyZXR1cm4gci5ub2RlVXAubmV4dC5rZXk7XG5cdH1cblxuXHRTd2VlcC5kZWJ1Z0V2ZW50ID0gZnVuY3Rpb24oIHRlc3MgKSB7XG5cdFx0Ly8gZW1wdHlcblx0fVxuXG5cblx0Lypcblx0KiBJbnZhcmlhbnRzIGZvciB0aGUgRWRnZSBEaWN0aW9uYXJ5LlxuXHQqIC0gZWFjaCBwYWlyIG9mIGFkamFjZW50IGVkZ2VzIGUyPVN1Y2MoZTEpIHNhdGlzZmllcyBFZGdlTGVxKGUxLGUyKVxuXHQqICAgYXQgYW55IHZhbGlkIGxvY2F0aW9uIG9mIHRoZSBzd2VlcCBldmVudFxuXHQqIC0gaWYgRWRnZUxlcShlMixlMSkgYXMgd2VsbCAoYXQgYW55IHZhbGlkIHN3ZWVwIGV2ZW50KSwgdGhlbiBlMSBhbmQgZTJcblx0KiAgIHNoYXJlIGEgY29tbW9uIGVuZHBvaW50XG5cdCogLSBmb3IgZWFjaCBlLCBlLT5Ec3QgaGFzIGJlZW4gcHJvY2Vzc2VkLCBidXQgbm90IGUtPk9yZ1xuXHQqIC0gZWFjaCBlZGdlIGUgc2F0aXNmaWVzIFZlcnRMZXEoZS0+RHN0LGV2ZW50KSAmJiBWZXJ0TGVxKGV2ZW50LGUtPk9yZylcblx0KiAgIHdoZXJlIFwiZXZlbnRcIiBpcyB0aGUgY3VycmVudCBzd2VlcCBsaW5lIGV2ZW50LlxuXHQqIC0gbm8gZWRnZSBlIGhhcyB6ZXJvIGxlbmd0aFxuXHQqXG5cdCogSW52YXJpYW50cyBmb3IgdGhlIE1lc2ggKHRoZSBwcm9jZXNzZWQgcG9ydGlvbikuXG5cdCogLSB0aGUgcG9ydGlvbiBvZiB0aGUgbWVzaCBsZWZ0IG9mIHRoZSBzd2VlcCBsaW5lIGlzIGEgcGxhbmFyIGdyYXBoLFxuXHQqICAgaWUuIHRoZXJlIGlzICpzb21lKiB3YXkgdG8gZW1iZWQgaXQgaW4gdGhlIHBsYW5lXG5cdCogLSBubyBwcm9jZXNzZWQgZWRnZSBoYXMgemVybyBsZW5ndGhcblx0KiAtIG5vIHR3byBwcm9jZXNzZWQgdmVydGljZXMgaGF2ZSBpZGVudGljYWwgY29vcmRpbmF0ZXNcblx0KiAtIGVhY2ggXCJpbnNpZGVcIiByZWdpb24gaXMgbW9ub3RvbmUsIGllLiBjYW4gYmUgYnJva2VuIGludG8gdHdvIGNoYWluc1xuXHQqICAgb2YgbW9ub3RvbmljYWxseSBpbmNyZWFzaW5nIHZlcnRpY2VzIGFjY29yZGluZyB0byBWZXJ0TGVxKHYxLHYyKVxuXHQqICAgLSBhIG5vbi1pbnZhcmlhbnQ6IHRoZXNlIGNoYWlucyBtYXkgaW50ZXJzZWN0ICh2ZXJ5IHNsaWdodGx5KVxuXHQqXG5cdCogSW52YXJpYW50cyBmb3IgdGhlIFN3ZWVwLlxuXHQqIC0gaWYgbm9uZSBvZiB0aGUgZWRnZXMgaW5jaWRlbnQgdG8gdGhlIGV2ZW50IHZlcnRleCBoYXZlIGFuIGFjdGl2ZVJlZ2lvblxuXHQqICAgKGllLiBub25lIG9mIHRoZXNlIGVkZ2VzIGFyZSBpbiB0aGUgZWRnZSBkaWN0aW9uYXJ5KSwgdGhlbiB0aGUgdmVydGV4XG5cdCogICBoYXMgb25seSByaWdodC1nb2luZyBlZGdlcy5cblx0KiAtIGlmIGFuIGVkZ2UgaXMgbWFya2VkIFwiZml4VXBwZXJFZGdlXCIgKGl0IGlzIGEgdGVtcG9yYXJ5IGVkZ2UgaW50cm9kdWNlZFxuXHQqICAgYnkgQ29ubmVjdFJpZ2h0VmVydGV4KSwgdGhlbiBpdCBpcyB0aGUgb25seSByaWdodC1nb2luZyBlZGdlIGZyb21cblx0KiAgIGl0cyBhc3NvY2lhdGVkIHZlcnRleC4gIChUaGlzIHNheXMgdGhhdCB0aGVzZSBlZGdlcyBleGlzdCBvbmx5XG5cdCogICB3aGVuIGl0IGlzIG5lY2Vzc2FyeS4pXG5cdCovXG5cblx0LyogV2hlbiB3ZSBtZXJnZSB0d28gZWRnZXMgaW50byBvbmUsIHdlIG5lZWQgdG8gY29tcHV0ZSB0aGUgY29tYmluZWRcblx0KiB3aW5kaW5nIG9mIHRoZSBuZXcgZWRnZS5cblx0Ki9cblx0U3dlZXAuYWRkV2luZGluZyA9IGZ1bmN0aW9uKGVEc3QsZVNyYykge1xuXHRcdGVEc3Qud2luZGluZyArPSBlU3JjLndpbmRpbmc7XG5cdFx0ZURzdC5TeW0ud2luZGluZyArPSBlU3JjLlN5bS53aW5kaW5nO1xuXHR9XG5cblxuXHQvL3N0YXRpYyBpbnQgRWRnZUxlcSggVEVTU3Rlc3NlbGF0b3IgKnRlc3MsIEFjdGl2ZVJlZ2lvbiAqcmVnMSwgQWN0aXZlUmVnaW9uICpyZWcyIClcblx0U3dlZXAuZWRnZUxlcSA9IGZ1bmN0aW9uKCB0ZXNzLCByZWcxLCByZWcyICkge1xuXHRcdC8qXG5cdFx0KiBCb3RoIGVkZ2VzIG11c3QgYmUgZGlyZWN0ZWQgZnJvbSByaWdodCB0byBsZWZ0ICh0aGlzIGlzIHRoZSBjYW5vbmljYWxcblx0XHQqIGRpcmVjdGlvbiBmb3IgdGhlIHVwcGVyIGVkZ2Ugb2YgZWFjaCByZWdpb24pLlxuXHRcdCpcblx0XHQqIFRoZSBzdHJhdGVneSBpcyB0byBldmFsdWF0ZSBhIFwidFwiIHZhbHVlIGZvciBlYWNoIGVkZ2UgYXQgdGhlXG5cdFx0KiBjdXJyZW50IHN3ZWVwIGxpbmUgcG9zaXRpb24sIGdpdmVuIGJ5IHRlc3MtPmV2ZW50LiAgVGhlIGNhbGN1bGF0aW9uc1xuXHRcdCogYXJlIGRlc2lnbmVkIHRvIGJlIHZlcnkgc3RhYmxlLCBidXQgb2YgY291cnNlIHRoZXkgYXJlIG5vdCBwZXJmZWN0LlxuXHRcdCpcblx0XHQqIFNwZWNpYWwgY2FzZTogaWYgYm90aCBlZGdlIGRlc3RpbmF0aW9ucyBhcmUgYXQgdGhlIHN3ZWVwIGV2ZW50LFxuXHRcdCogd2Ugc29ydCB0aGUgZWRnZXMgYnkgc2xvcGUgKHRoZXkgd291bGQgb3RoZXJ3aXNlIGNvbXBhcmUgZXF1YWxseSkuXG5cdFx0Ki9cblx0XHR2YXIgZXYgPSB0ZXNzLmV2ZW50O1xuXHRcdHZhciB0MSwgdDI7XG5cblx0XHR2YXIgZTEgPSByZWcxLmVVcDtcblx0XHR2YXIgZTIgPSByZWcyLmVVcDtcblxuXHRcdGlmKCBlMS5Ec3QgPT09IGV2ICkge1xuXHRcdFx0aWYoIGUyLkRzdCA9PT0gZXYgKSB7XG5cdFx0XHRcdC8qIFR3byBlZGdlcyByaWdodCBvZiB0aGUgc3dlZXAgbGluZSB3aGljaCBtZWV0IGF0IHRoZSBzd2VlcCBldmVudC5cblx0XHRcdFx0KiBTb3J0IHRoZW0gYnkgc2xvcGUuXG5cdFx0XHRcdCovXG5cdFx0XHRcdGlmKCBHZW9tLnZlcnRMZXEoIGUxLk9yZywgZTIuT3JnICkpIHtcblx0XHRcdFx0XHRyZXR1cm4gR2VvbS5lZGdlU2lnbiggZTIuRHN0LCBlMS5PcmcsIGUyLk9yZyApIDw9IDA7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIEdlb20uZWRnZVNpZ24oIGUxLkRzdCwgZTIuT3JnLCBlMS5PcmcgKSA+PSAwO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIEdlb20uZWRnZVNpZ24oIGUyLkRzdCwgZXYsIGUyLk9yZyApIDw9IDA7XG5cdFx0fVxuXHRcdGlmKCBlMi5Ec3QgPT09IGV2ICkge1xuXHRcdFx0cmV0dXJuIEdlb20uZWRnZVNpZ24oIGUxLkRzdCwgZXYsIGUxLk9yZyApID49IDA7XG5cdFx0fVxuXG5cdFx0LyogR2VuZXJhbCBjYXNlIC0gY29tcHV0ZSBzaWduZWQgZGlzdGFuY2UgKmZyb20qIGUxLCBlMiB0byBldmVudCAqL1xuXHRcdHZhciB0MSA9IEdlb20uZWRnZUV2YWwoIGUxLkRzdCwgZXYsIGUxLk9yZyApO1xuXHRcdHZhciB0MiA9IEdlb20uZWRnZUV2YWwoIGUyLkRzdCwgZXYsIGUyLk9yZyApO1xuXHRcdHJldHVybiAodDEgPj0gdDIpO1xuXHR9XG5cblxuXHQvL3N0YXRpYyB2b2lkIERlbGV0ZVJlZ2lvbiggVEVTU3Rlc3NlbGF0b3IgKnRlc3MsIEFjdGl2ZVJlZ2lvbiAqcmVnIClcblx0U3dlZXAuZGVsZXRlUmVnaW9uID0gZnVuY3Rpb24oIHRlc3MsIHJlZyApIHtcblx0XHRpZiggcmVnLmZpeFVwcGVyRWRnZSApIHtcblx0XHRcdC8qIEl0IHdhcyBjcmVhdGVkIHdpdGggemVybyB3aW5kaW5nIG51bWJlciwgc28gaXQgYmV0dGVyIGJlXG5cdFx0XHQqIGRlbGV0ZWQgd2l0aCB6ZXJvIHdpbmRpbmcgbnVtYmVyIChpZS4gaXQgYmV0dGVyIG5vdCBnZXQgbWVyZ2VkXG5cdFx0XHQqIHdpdGggYSByZWFsIGVkZ2UpLlxuXHRcdFx0Ki9cblx0XHRcdGFzc2VydCggcmVnLmVVcC53aW5kaW5nID09PSAwICk7XG5cdFx0fVxuXHRcdHJlZy5lVXAuYWN0aXZlUmVnaW9uID0gbnVsbDtcblx0XHR0ZXNzLmRpY3QuZGVsZXRlKCByZWcubm9kZVVwICk7XG5cdH1cblxuXHQvL3N0YXRpYyBpbnQgRml4VXBwZXJFZGdlKCBURVNTdGVzc2VsYXRvciAqdGVzcywgQWN0aXZlUmVnaW9uICpyZWcsIFRFU1NoYWxmRWRnZSAqbmV3RWRnZSApXG5cdFN3ZWVwLmZpeFVwcGVyRWRnZSA9IGZ1bmN0aW9uKCB0ZXNzLCByZWcsIG5ld0VkZ2UgKSB7XG5cdFx0Lypcblx0XHQqIFJlcGxhY2UgYW4gdXBwZXIgZWRnZSB3aGljaCBuZWVkcyBmaXhpbmcgKHNlZSBDb25uZWN0UmlnaHRWZXJ0ZXgpLlxuXHRcdCovXG5cdFx0YXNzZXJ0KCByZWcuZml4VXBwZXJFZGdlICk7XG5cdFx0dGVzcy5tZXNoLmRlbGV0ZSggcmVnLmVVcCApO1xuXHRcdHJlZy5maXhVcHBlckVkZ2UgPSBmYWxzZTtcblx0XHRyZWcuZVVwID0gbmV3RWRnZTtcblx0XHRuZXdFZGdlLmFjdGl2ZVJlZ2lvbiA9IHJlZztcblx0fVxuXG5cdC8vc3RhdGljIEFjdGl2ZVJlZ2lvbiAqVG9wTGVmdFJlZ2lvbiggVEVTU3Rlc3NlbGF0b3IgKnRlc3MsIEFjdGl2ZVJlZ2lvbiAqcmVnIClcblx0U3dlZXAudG9wTGVmdFJlZ2lvbiA9IGZ1bmN0aW9uKCB0ZXNzLCByZWcgKSB7XG5cdFx0dmFyIG9yZyA9IHJlZy5lVXAuT3JnO1xuXHRcdHZhciBlO1xuXG5cdFx0LyogRmluZCB0aGUgcmVnaW9uIGFib3ZlIHRoZSB1cHBlcm1vc3QgZWRnZSB3aXRoIHRoZSBzYW1lIG9yaWdpbiAqL1xuXHRcdGRvIHtcblx0XHRcdHJlZyA9IFN3ZWVwLnJlZ2lvbkFib3ZlKCByZWcgKTtcblx0XHR9IHdoaWxlKCByZWcuZVVwLk9yZyA9PT0gb3JnICk7XG5cblx0XHQvKiBJZiB0aGUgZWRnZSBhYm92ZSB3YXMgYSB0ZW1wb3JhcnkgZWRnZSBpbnRyb2R1Y2VkIGJ5IENvbm5lY3RSaWdodFZlcnRleCxcblx0XHQqIG5vdyBpcyB0aGUgdGltZSB0byBmaXggaXQuXG5cdFx0Ki9cblx0XHRpZiggcmVnLmZpeFVwcGVyRWRnZSApIHtcblx0XHRcdGUgPSB0ZXNzLm1lc2guY29ubmVjdCggU3dlZXAucmVnaW9uQmVsb3cocmVnKS5lVXAuU3ltLCByZWcuZVVwLkxuZXh0ICk7XG5cdFx0XHRpZiAoZSA9PT0gbnVsbCkgcmV0dXJuIG51bGw7XG5cdFx0XHRTd2VlcC5maXhVcHBlckVkZ2UoIHRlc3MsIHJlZywgZSApO1xuXHRcdFx0cmVnID0gU3dlZXAucmVnaW9uQWJvdmUoIHJlZyApO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVnO1xuXHR9XG5cblx0Ly9zdGF0aWMgQWN0aXZlUmVnaW9uICpUb3BSaWdodFJlZ2lvbiggQWN0aXZlUmVnaW9uICpyZWcgKVxuXHRTd2VlcC50b3BSaWdodFJlZ2lvbiA9IGZ1bmN0aW9uKCByZWcgKVxuXHR7XG5cdFx0dmFyIGRzdCA9IHJlZy5lVXAuRHN0O1xuXHRcdHZhciByZWcgPSBudWxsO1xuXHRcdC8qIEZpbmQgdGhlIHJlZ2lvbiBhYm92ZSB0aGUgdXBwZXJtb3N0IGVkZ2Ugd2l0aCB0aGUgc2FtZSBkZXN0aW5hdGlvbiAqL1xuXHRcdGRvIHtcblx0XHRcdHJlZyA9IFN3ZWVwLnJlZ2lvbkFib3ZlKCByZWcgKTtcblx0XHR9IHdoaWxlKCByZWcuZVVwLkRzdCA9PT0gZHN0ICk7XG5cdFx0cmV0dXJuIHJlZztcblx0fVxuXG5cdC8vc3RhdGljIEFjdGl2ZVJlZ2lvbiAqQWRkUmVnaW9uQmVsb3coIFRFU1N0ZXNzZWxhdG9yICp0ZXNzLCBBY3RpdmVSZWdpb24gKnJlZ0Fib3ZlLCBURVNTaGFsZkVkZ2UgKmVOZXdVcCApXG5cdFN3ZWVwLmFkZFJlZ2lvbkJlbG93ID0gZnVuY3Rpb24oIHRlc3MsIHJlZ0Fib3ZlLCBlTmV3VXAgKSB7XG5cdFx0Lypcblx0XHQqIEFkZCBhIG5ldyBhY3RpdmUgcmVnaW9uIHRvIHRoZSBzd2VlcCBsaW5lLCAqc29tZXdoZXJlKiBiZWxvdyBcInJlZ0Fib3ZlXCJcblx0XHQqIChhY2NvcmRpbmcgdG8gd2hlcmUgdGhlIG5ldyBlZGdlIGJlbG9uZ3MgaW4gdGhlIHN3ZWVwLWxpbmUgZGljdGlvbmFyeSkuXG5cdFx0KiBUaGUgdXBwZXIgZWRnZSBvZiB0aGUgbmV3IHJlZ2lvbiB3aWxsIGJlIFwiZU5ld1VwXCIuXG5cdFx0KiBXaW5kaW5nIG51bWJlciBhbmQgXCJpbnNpZGVcIiBmbGFnIGFyZSBub3QgdXBkYXRlZC5cblx0XHQqL1xuXHRcdHZhciByZWdOZXcgPSBuZXcgQWN0aXZlUmVnaW9uKCk7XG5cdFx0cmVnTmV3LmVVcCA9IGVOZXdVcDtcblx0XHRyZWdOZXcubm9kZVVwID0gdGVzcy5kaWN0Lmluc2VydEJlZm9yZSggcmVnQWJvdmUubm9kZVVwLCByZWdOZXcgKTtcblx0Ly9cdGlmIChyZWdOZXctPm5vZGVVcCA9PSBOVUxMKSBsb25nam1wKHRlc3MtPmVudiwxKTtcblx0XHRyZWdOZXcuZml4VXBwZXJFZGdlID0gZmFsc2U7XG5cdFx0cmVnTmV3LnNlbnRpbmVsID0gZmFsc2U7XG5cdFx0cmVnTmV3LmRpcnR5ID0gZmFsc2U7XG5cblx0XHRlTmV3VXAuYWN0aXZlUmVnaW9uID0gcmVnTmV3O1xuXHRcdHJldHVybiByZWdOZXc7XG5cdH1cblxuXHQvL3N0YXRpYyBpbnQgSXNXaW5kaW5nSW5zaWRlKCBURVNTdGVzc2VsYXRvciAqdGVzcywgaW50IG4gKVxuXHRTd2VlcC5pc1dpbmRpbmdJbnNpZGUgPSBmdW5jdGlvbiggdGVzcywgbiApIHtcblx0XHRzd2l0Y2goIHRlc3Mud2luZGluZ1J1bGUgKSB7XG5cdFx0XHRjYXNlIFRlc3MyLldJTkRJTkdfT0REOlxuXHRcdFx0XHRyZXR1cm4gKG4gJiAxKSAhPSAwO1xuXHRcdFx0Y2FzZSBUZXNzMi5XSU5ESU5HX05PTlpFUk86XG5cdFx0XHRcdHJldHVybiAobiAhPSAwKTtcblx0XHRcdGNhc2UgVGVzczIuV0lORElOR19QT1NJVElWRTpcblx0XHRcdFx0cmV0dXJuIChuID4gMCk7XG5cdFx0XHRjYXNlIFRlc3MyLldJTkRJTkdfTkVHQVRJVkU6XG5cdFx0XHRcdHJldHVybiAobiA8IDApO1xuXHRcdFx0Y2FzZSBUZXNzMi5XSU5ESU5HX0FCU19HRVFfVFdPOlxuXHRcdFx0XHRyZXR1cm4gKG4gPj0gMikgfHwgKG4gPD0gLTIpO1xuXHRcdH1cblx0XHRhc3NlcnQoIGZhbHNlICk7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0Ly9zdGF0aWMgdm9pZCBDb21wdXRlV2luZGluZyggVEVTU3Rlc3NlbGF0b3IgKnRlc3MsIEFjdGl2ZVJlZ2lvbiAqcmVnIClcblx0U3dlZXAuY29tcHV0ZVdpbmRpbmcgPSBmdW5jdGlvbiggdGVzcywgcmVnICkge1xuXHRcdHJlZy53aW5kaW5nTnVtYmVyID0gU3dlZXAucmVnaW9uQWJvdmUocmVnKS53aW5kaW5nTnVtYmVyICsgcmVnLmVVcC53aW5kaW5nO1xuXHRcdHJlZy5pbnNpZGUgPSBTd2VlcC5pc1dpbmRpbmdJbnNpZGUoIHRlc3MsIHJlZy53aW5kaW5nTnVtYmVyICk7XG5cdH1cblxuXG5cdC8vc3RhdGljIHZvaWQgRmluaXNoUmVnaW9uKCBURVNTdGVzc2VsYXRvciAqdGVzcywgQWN0aXZlUmVnaW9uICpyZWcgKVxuXHRTd2VlcC5maW5pc2hSZWdpb24gPSBmdW5jdGlvbiggdGVzcywgcmVnICkge1xuXHRcdC8qXG5cdFx0KiBEZWxldGUgYSByZWdpb24gZnJvbSB0aGUgc3dlZXAgbGluZS4gIFRoaXMgaGFwcGVucyB3aGVuIHRoZSB1cHBlclxuXHRcdCogYW5kIGxvd2VyIGNoYWlucyBvZiBhIHJlZ2lvbiBtZWV0IChhdCBhIHZlcnRleCBvbiB0aGUgc3dlZXAgbGluZSkuXG5cdFx0KiBUaGUgXCJpbnNpZGVcIiBmbGFnIGlzIGNvcGllZCB0byB0aGUgYXBwcm9wcmlhdGUgbWVzaCBmYWNlICh3ZSBjb3VsZFxuXHRcdCogbm90IGRvIHRoaXMgYmVmb3JlIC0tIHNpbmNlIHRoZSBzdHJ1Y3R1cmUgb2YgdGhlIG1lc2ggaXMgYWx3YXlzXG5cdFx0KiBjaGFuZ2luZywgdGhpcyBmYWNlIG1heSBub3QgaGF2ZSBldmVuIGV4aXN0ZWQgdW50aWwgbm93KS5cblx0XHQqL1xuXHRcdHZhciBlID0gcmVnLmVVcDtcblx0XHR2YXIgZiA9IGUuTGZhY2U7XG5cblx0XHRmLmluc2lkZSA9IHJlZy5pbnNpZGU7XG5cdFx0Zi5hbkVkZ2UgPSBlOyAgIC8qIG9wdGltaXphdGlvbiBmb3IgdGVzc01lc2hUZXNzZWxsYXRlTW9ub1JlZ2lvbigpICovXG5cdFx0U3dlZXAuZGVsZXRlUmVnaW9uKCB0ZXNzLCByZWcgKTtcblx0fVxuXG5cblx0Ly9zdGF0aWMgVEVTU2hhbGZFZGdlICpGaW5pc2hMZWZ0UmVnaW9ucyggVEVTU3Rlc3NlbGF0b3IgKnRlc3MsIEFjdGl2ZVJlZ2lvbiAqcmVnRmlyc3QsIEFjdGl2ZVJlZ2lvbiAqcmVnTGFzdCApXG5cdFN3ZWVwLmZpbmlzaExlZnRSZWdpb25zID0gZnVuY3Rpb24oIHRlc3MsIHJlZ0ZpcnN0LCByZWdMYXN0ICkge1xuXHRcdC8qXG5cdFx0KiBXZSBhcmUgZ2l2ZW4gYSB2ZXJ0ZXggd2l0aCBvbmUgb3IgbW9yZSBsZWZ0LWdvaW5nIGVkZ2VzLiAgQWxsIGFmZmVjdGVkXG5cdFx0KiBlZGdlcyBzaG91bGQgYmUgaW4gdGhlIGVkZ2UgZGljdGlvbmFyeS4gIFN0YXJ0aW5nIGF0IHJlZ0ZpcnN0LT5lVXAsXG5cdFx0KiB3ZSB3YWxrIGRvd24gZGVsZXRpbmcgYWxsIHJlZ2lvbnMgd2hlcmUgYm90aCBlZGdlcyBoYXZlIHRoZSBzYW1lXG5cdFx0KiBvcmlnaW4gdk9yZy4gIEF0IHRoZSBzYW1lIHRpbWUgd2UgY29weSB0aGUgXCJpbnNpZGVcIiBmbGFnIGZyb20gdGhlXG5cdFx0KiBhY3RpdmUgcmVnaW9uIHRvIHRoZSBmYWNlLCBzaW5jZSBhdCB0aGlzIHBvaW50IGVhY2ggZmFjZSB3aWxsIGJlbG9uZ1xuXHRcdCogdG8gYXQgbW9zdCBvbmUgcmVnaW9uICh0aGlzIHdhcyBub3QgbmVjZXNzYXJpbHkgdHJ1ZSB1bnRpbCB0aGlzIHBvaW50XG5cdFx0KiBpbiB0aGUgc3dlZXApLiAgVGhlIHdhbGsgc3RvcHMgYXQgdGhlIHJlZ2lvbiBhYm92ZSByZWdMYXN0OyBpZiByZWdMYXN0XG5cdFx0KiBpcyBOVUxMIHdlIHdhbGsgYXMgZmFyIGFzIHBvc3NpYmxlLiAgQXQgdGhlIHNhbWUgdGltZSB3ZSByZWxpbmsgdGhlXG5cdFx0KiBtZXNoIGlmIG5lY2Vzc2FyeSwgc28gdGhhdCB0aGUgb3JkZXJpbmcgb2YgZWRnZXMgYXJvdW5kIHZPcmcgaXMgdGhlXG5cdFx0KiBzYW1lIGFzIGluIHRoZSBkaWN0aW9uYXJ5LlxuXHRcdCovXG5cdFx0dmFyIGUsIGVQcmV2O1xuXHRcdHZhciByZWcgPSBudWxsO1xuXHRcdHZhciByZWdQcmV2ID0gcmVnRmlyc3Q7XG5cdFx0dmFyIGVQcmV2ID0gcmVnRmlyc3QuZVVwO1xuXHRcdHdoaWxlKCByZWdQcmV2ICE9PSByZWdMYXN0ICkge1xuXHRcdFx0cmVnUHJldi5maXhVcHBlckVkZ2UgPSBmYWxzZTtcdC8qIHBsYWNlbWVudCB3YXMgT0sgKi9cblx0XHRcdHJlZyA9IFN3ZWVwLnJlZ2lvbkJlbG93KCByZWdQcmV2ICk7XG5cdFx0XHRlID0gcmVnLmVVcDtcblx0XHRcdGlmKCBlLk9yZyAhPSBlUHJldi5PcmcgKSB7XG5cdFx0XHRcdGlmKCAhIHJlZy5maXhVcHBlckVkZ2UgKSB7XG5cdFx0XHRcdFx0LyogUmVtb3ZlIHRoZSBsYXN0IGxlZnQtZ29pbmcgZWRnZS4gIEV2ZW4gdGhvdWdoIHRoZXJlIGFyZSBubyBmdXJ0aGVyXG5cdFx0XHRcdFx0KiBlZGdlcyBpbiB0aGUgZGljdGlvbmFyeSB3aXRoIHRoaXMgb3JpZ2luLCB0aGVyZSBtYXkgYmUgZnVydGhlclxuXHRcdFx0XHRcdCogc3VjaCBlZGdlcyBpbiB0aGUgbWVzaCAoaWYgd2UgYXJlIGFkZGluZyBsZWZ0IGVkZ2VzIHRvIGEgdmVydGV4XG5cdFx0XHRcdFx0KiB0aGF0IGhhcyBhbHJlYWR5IGJlZW4gcHJvY2Vzc2VkKS4gIFRodXMgaXQgaXMgaW1wb3J0YW50IHRvIGNhbGxcblx0XHRcdFx0XHQqIEZpbmlzaFJlZ2lvbiByYXRoZXIgdGhhbiBqdXN0IERlbGV0ZVJlZ2lvbi5cblx0XHRcdFx0XHQqL1xuXHRcdFx0XHRcdFN3ZWVwLmZpbmlzaFJlZ2lvbiggdGVzcywgcmVnUHJldiApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8qIElmIHRoZSBlZGdlIGJlbG93IHdhcyBhIHRlbXBvcmFyeSBlZGdlIGludHJvZHVjZWQgYnlcblx0XHRcdFx0KiBDb25uZWN0UmlnaHRWZXJ0ZXgsIG5vdyBpcyB0aGUgdGltZSB0byBmaXggaXQuXG5cdFx0XHRcdCovXG5cdFx0XHRcdGUgPSB0ZXNzLm1lc2guY29ubmVjdCggZVByZXYuTHByZXYsIGUuU3ltICk7XG5cdC8vXHRcdFx0aWYgKGUgPT0gTlVMTCkgbG9uZ2ptcCh0ZXNzLT5lbnYsMSk7XG5cdFx0XHRcdFN3ZWVwLmZpeFVwcGVyRWRnZSggdGVzcywgcmVnLCBlICk7XG5cdFx0XHR9XG5cblx0XHRcdC8qIFJlbGluayBlZGdlcyBzbyB0aGF0IGVQcmV2LT5PbmV4dCA9PSBlICovXG5cdFx0XHRpZiggZVByZXYuT25leHQgIT09IGUgKSB7XG5cdFx0XHRcdHRlc3MubWVzaC5zcGxpY2UoIGUuT3ByZXYsIGUgKTtcblx0XHRcdFx0dGVzcy5tZXNoLnNwbGljZSggZVByZXYsIGUgKTtcblx0XHRcdH1cblx0XHRcdFN3ZWVwLmZpbmlzaFJlZ2lvbiggdGVzcywgcmVnUHJldiApO1x0LyogbWF5IGNoYW5nZSByZWctPmVVcCAqL1xuXHRcdFx0ZVByZXYgPSByZWcuZVVwO1xuXHRcdFx0cmVnUHJldiA9IHJlZztcblx0XHR9XG5cdFx0cmV0dXJuIGVQcmV2O1xuXHR9XG5cblxuXHQvL3N0YXRpYyB2b2lkIEFkZFJpZ2h0RWRnZXMoIFRFU1N0ZXNzZWxhdG9yICp0ZXNzLCBBY3RpdmVSZWdpb24gKnJlZ1VwLCBURVNTaGFsZkVkZ2UgKmVGaXJzdCwgVEVTU2hhbGZFZGdlICplTGFzdCwgVEVTU2hhbGZFZGdlICplVG9wTGVmdCwgaW50IGNsZWFuVXAgKVxuXHRTd2VlcC5hZGRSaWdodEVkZ2VzID0gZnVuY3Rpb24oIHRlc3MsIHJlZ1VwLCBlRmlyc3QsIGVMYXN0LCBlVG9wTGVmdCwgY2xlYW5VcCApIHtcblx0XHQvKlxuXHRcdCogUHVycG9zZTogaW5zZXJ0IHJpZ2h0LWdvaW5nIGVkZ2VzIGludG8gdGhlIGVkZ2UgZGljdGlvbmFyeSwgYW5kIHVwZGF0ZVxuXHRcdCogd2luZGluZyBudW1iZXJzIGFuZCBtZXNoIGNvbm5lY3Rpdml0eSBhcHByb3ByaWF0ZWx5LiAgQWxsIHJpZ2h0LWdvaW5nXG5cdFx0KiBlZGdlcyBzaGFyZSBhIGNvbW1vbiBvcmlnaW4gdk9yZy4gIEVkZ2VzIGFyZSBpbnNlcnRlZCBDQ1cgc3RhcnRpbmcgYXRcblx0XHQqIGVGaXJzdDsgdGhlIGxhc3QgZWRnZSBpbnNlcnRlZCBpcyBlTGFzdC0+T3ByZXYuICBJZiB2T3JnIGhhcyBhbnlcblx0XHQqIGxlZnQtZ29pbmcgZWRnZXMgYWxyZWFkeSBwcm9jZXNzZWQsIHRoZW4gZVRvcExlZnQgbXVzdCBiZSB0aGUgZWRnZVxuXHRcdCogc3VjaCB0aGF0IGFuIGltYWdpbmFyeSB1cHdhcmQgdmVydGljYWwgc2VnbWVudCBmcm9tIHZPcmcgd291bGQgYmVcblx0XHQqIGNvbnRhaW5lZCBiZXR3ZWVuIGVUb3BMZWZ0LT5PcHJldiBhbmQgZVRvcExlZnQ7IG90aGVyd2lzZSBlVG9wTGVmdFxuXHRcdCogc2hvdWxkIGJlIE5VTEwuXG5cdFx0Ki9cblx0XHR2YXIgcmVnLCByZWdQcmV2O1xuXHRcdHZhciBlLCBlUHJldjtcblx0XHR2YXIgZmlyc3RUaW1lID0gdHJ1ZTtcblxuXHRcdC8qIEluc2VydCB0aGUgbmV3IHJpZ2h0LWdvaW5nIGVkZ2VzIGluIHRoZSBkaWN0aW9uYXJ5ICovXG5cdFx0ZSA9IGVGaXJzdDtcblx0XHRkbyB7XG5cdFx0XHRhc3NlcnQoIEdlb20udmVydExlcSggZS5PcmcsIGUuRHN0ICkpO1xuXHRcdFx0U3dlZXAuYWRkUmVnaW9uQmVsb3coIHRlc3MsIHJlZ1VwLCBlLlN5bSApO1xuXHRcdFx0ZSA9IGUuT25leHQ7XG5cdFx0fSB3aGlsZSAoIGUgIT09IGVMYXN0ICk7XG5cblx0XHQvKiBXYWxrICphbGwqIHJpZ2h0LWdvaW5nIGVkZ2VzIGZyb20gZS0+T3JnLCBpbiB0aGUgZGljdGlvbmFyeSBvcmRlcixcblx0XHQqIHVwZGF0aW5nIHRoZSB3aW5kaW5nIG51bWJlcnMgb2YgZWFjaCByZWdpb24sIGFuZCByZS1saW5raW5nIHRoZSBtZXNoXG5cdFx0KiBlZGdlcyB0byBtYXRjaCB0aGUgZGljdGlvbmFyeSBvcmRlcmluZyAoaWYgbmVjZXNzYXJ5KS5cblx0XHQqL1xuXHRcdGlmKCBlVG9wTGVmdCA9PT0gbnVsbCApIHtcblx0XHRcdGVUb3BMZWZ0ID0gU3dlZXAucmVnaW9uQmVsb3coIHJlZ1VwICkuZVVwLlJwcmV2O1xuXHRcdH1cblx0XHRyZWdQcmV2ID0gcmVnVXA7XG5cdFx0ZVByZXYgPSBlVG9wTGVmdDtcblx0XHRmb3IoIDs7ICkge1xuXHRcdFx0cmVnID0gU3dlZXAucmVnaW9uQmVsb3coIHJlZ1ByZXYgKTtcblx0XHRcdGUgPSByZWcuZVVwLlN5bTtcblx0XHRcdGlmKCBlLk9yZyAhPT0gZVByZXYuT3JnICkgYnJlYWs7XG5cblx0XHRcdGlmKCBlLk9uZXh0ICE9PSBlUHJldiApIHtcblx0XHRcdFx0LyogVW5saW5rIGUgZnJvbSBpdHMgY3VycmVudCBwb3NpdGlvbiwgYW5kIHJlbGluayBiZWxvdyBlUHJldiAqL1xuXHRcdFx0XHR0ZXNzLm1lc2guc3BsaWNlKCBlLk9wcmV2LCBlICk7XG5cdFx0XHRcdHRlc3MubWVzaC5zcGxpY2UoIGVQcmV2Lk9wcmV2LCBlICk7XG5cdFx0XHR9XG5cdFx0XHQvKiBDb21wdXRlIHRoZSB3aW5kaW5nIG51bWJlciBhbmQgXCJpbnNpZGVcIiBmbGFnIGZvciB0aGUgbmV3IHJlZ2lvbnMgKi9cblx0XHRcdHJlZy53aW5kaW5nTnVtYmVyID0gcmVnUHJldi53aW5kaW5nTnVtYmVyIC0gZS53aW5kaW5nO1xuXHRcdFx0cmVnLmluc2lkZSA9IFN3ZWVwLmlzV2luZGluZ0luc2lkZSggdGVzcywgcmVnLndpbmRpbmdOdW1iZXIgKTtcblxuXHRcdFx0LyogQ2hlY2sgZm9yIHR3byBvdXRnb2luZyBlZGdlcyB3aXRoIHNhbWUgc2xvcGUgLS0gcHJvY2VzcyB0aGVzZVxuXHRcdFx0KiBiZWZvcmUgYW55IGludGVyc2VjdGlvbiB0ZXN0cyAoc2VlIGV4YW1wbGUgaW4gdGVzc0NvbXB1dGVJbnRlcmlvcikuXG5cdFx0XHQqL1xuXHRcdFx0cmVnUHJldi5kaXJ0eSA9IHRydWU7XG5cdFx0XHRpZiggISBmaXJzdFRpbWUgJiYgU3dlZXAuY2hlY2tGb3JSaWdodFNwbGljZSggdGVzcywgcmVnUHJldiApKSB7XG5cdFx0XHRcdFN3ZWVwLmFkZFdpbmRpbmcoIGUsIGVQcmV2ICk7XG5cdFx0XHRcdFN3ZWVwLmRlbGV0ZVJlZ2lvbiggdGVzcywgcmVnUHJldiApO1xuXHRcdFx0XHR0ZXNzLm1lc2guZGVsZXRlKCBlUHJldiApO1xuXHRcdFx0fVxuXHRcdFx0Zmlyc3RUaW1lID0gZmFsc2U7XG5cdFx0XHRyZWdQcmV2ID0gcmVnO1xuXHRcdFx0ZVByZXYgPSBlO1xuXHRcdH1cblx0XHRyZWdQcmV2LmRpcnR5ID0gdHJ1ZTtcblx0XHRhc3NlcnQoIHJlZ1ByZXYud2luZGluZ051bWJlciAtIGUud2luZGluZyA9PT0gcmVnLndpbmRpbmdOdW1iZXIgKTtcblxuXHRcdGlmKCBjbGVhblVwICkge1xuXHRcdFx0LyogQ2hlY2sgZm9yIGludGVyc2VjdGlvbnMgYmV0d2VlbiBuZXdseSBhZGphY2VudCBlZGdlcy4gKi9cblx0XHRcdFN3ZWVwLndhbGtEaXJ0eVJlZ2lvbnMoIHRlc3MsIHJlZ1ByZXYgKTtcblx0XHR9XG5cdH1cblxuXG5cdC8vc3RhdGljIHZvaWQgU3BsaWNlTWVyZ2VWZXJ0aWNlcyggVEVTU3Rlc3NlbGF0b3IgKnRlc3MsIFRFU1NoYWxmRWRnZSAqZTEsIFRFU1NoYWxmRWRnZSAqZTIgKVxuXHRTd2VlcC5zcGxpY2VNZXJnZVZlcnRpY2VzID0gZnVuY3Rpb24oIHRlc3MsIGUxLCBlMiApIHtcblx0XHQvKlxuXHRcdCogVHdvIHZlcnRpY2VzIHdpdGggaWRlbnRpYWwgY29vcmRpbmF0ZXMgYXJlIGNvbWJpbmVkIGludG8gb25lLlxuXHRcdCogZTEtPk9yZyBpcyBrZXB0LCB3aGlsZSBlMi0+T3JnIGlzIGRpc2NhcmRlZC5cblx0XHQqL1xuXHRcdHRlc3MubWVzaC5zcGxpY2UoIGUxLCBlMiApOyBcblx0fVxuXG5cdC8vc3RhdGljIHZvaWQgVmVydGV4V2VpZ2h0cyggVEVTU3ZlcnRleCAqaXNlY3QsIFRFU1N2ZXJ0ZXggKm9yZywgVEVTU3ZlcnRleCAqZHN0LCBURVNTcmVhbCAqd2VpZ2h0cyApXG5cdFN3ZWVwLnZlcnRleFdlaWdodHMgPSBmdW5jdGlvbiggaXNlY3QsIG9yZywgZHN0ICkge1xuXHRcdC8qXG5cdFx0KiBGaW5kIHNvbWUgd2VpZ2h0cyB3aGljaCBkZXNjcmliZSBob3cgdGhlIGludGVyc2VjdGlvbiB2ZXJ0ZXggaXNcblx0XHQqIGEgbGluZWFyIGNvbWJpbmF0aW9uIG9mIFwib3JnXCIgYW5kIFwiZGVzdFwiLiAgRWFjaCBvZiB0aGUgdHdvIGVkZ2VzXG5cdFx0KiB3aGljaCBnZW5lcmF0ZWQgXCJpc2VjdFwiIGlzIGFsbG9jYXRlZCA1MCUgb2YgdGhlIHdlaWdodDsgZWFjaCBlZGdlXG5cdFx0KiBzcGxpdHMgdGhlIHdlaWdodCBiZXR3ZWVuIGl0cyBvcmcgYW5kIGRzdCBhY2NvcmRpbmcgdG8gdGhlXG5cdFx0KiByZWxhdGl2ZSBkaXN0YW5jZSB0byBcImlzZWN0XCIuXG5cdFx0Ki9cblx0XHR2YXIgdDEgPSBHZW9tLnZlcnRMMWRpc3QoIG9yZywgaXNlY3QgKTtcblx0XHR2YXIgdDIgPSBHZW9tLnZlcnRMMWRpc3QoIGRzdCwgaXNlY3QgKTtcblx0XHR2YXIgdzAgPSAwLjUgKiB0MiAvICh0MSArIHQyKTtcblx0XHR2YXIgdzEgPSAwLjUgKiB0MSAvICh0MSArIHQyKTtcblx0XHRpc2VjdC5jb29yZHNbMF0gKz0gdzAqb3JnLmNvb3Jkc1swXSArIHcxKmRzdC5jb29yZHNbMF07XG5cdFx0aXNlY3QuY29vcmRzWzFdICs9IHcwKm9yZy5jb29yZHNbMV0gKyB3MSpkc3QuY29vcmRzWzFdO1xuXHRcdGlzZWN0LmNvb3Jkc1syXSArPSB3MCpvcmcuY29vcmRzWzJdICsgdzEqZHN0LmNvb3Jkc1syXTtcblx0fVxuXG5cblx0Ly9zdGF0aWMgdm9pZCBHZXRJbnRlcnNlY3REYXRhKCBURVNTdGVzc2VsYXRvciAqdGVzcywgVEVTU3ZlcnRleCAqaXNlY3QsIFRFU1N2ZXJ0ZXggKm9yZ1VwLCBURVNTdmVydGV4ICpkc3RVcCwgVEVTU3ZlcnRleCAqb3JnTG8sIFRFU1N2ZXJ0ZXggKmRzdExvIClcblx0U3dlZXAuZ2V0SW50ZXJzZWN0RGF0YSA9IGZ1bmN0aW9uKCB0ZXNzLCBpc2VjdCwgb3JnVXAsIGRzdFVwLCBvcmdMbywgZHN0TG8gKSB7XG5cdFx0IC8qXG5cdFx0ICogV2UndmUgY29tcHV0ZWQgYSBuZXcgaW50ZXJzZWN0aW9uIHBvaW50LCBub3cgd2UgbmVlZCBhIFwiZGF0YVwiIHBvaW50ZXJcblx0XHQgKiBmcm9tIHRoZSB1c2VyIHNvIHRoYXQgd2UgY2FuIHJlZmVyIHRvIHRoaXMgbmV3IHZlcnRleCBpbiB0aGVcblx0XHQgKiByZW5kZXJpbmcgY2FsbGJhY2tzLlxuXHRcdCAqL1xuXHRcdGlzZWN0LmNvb3Jkc1swXSA9IGlzZWN0LmNvb3Jkc1sxXSA9IGlzZWN0LmNvb3Jkc1syXSA9IDA7XG5cdFx0aXNlY3QuaWR4ID0gLTE7XG5cdFx0U3dlZXAudmVydGV4V2VpZ2h0cyggaXNlY3QsIG9yZ1VwLCBkc3RVcCApO1xuXHRcdFN3ZWVwLnZlcnRleFdlaWdodHMoIGlzZWN0LCBvcmdMbywgZHN0TG8gKTtcblx0fVxuXG5cdC8vc3RhdGljIGludCBDaGVja0ZvclJpZ2h0U3BsaWNlKCBURVNTdGVzc2VsYXRvciAqdGVzcywgQWN0aXZlUmVnaW9uICpyZWdVcCApXG5cdFN3ZWVwLmNoZWNrRm9yUmlnaHRTcGxpY2UgPSBmdW5jdGlvbiggdGVzcywgcmVnVXAgKSB7XG5cdFx0Lypcblx0XHQqIENoZWNrIHRoZSB1cHBlciBhbmQgbG93ZXIgZWRnZSBvZiBcInJlZ1VwXCIsIHRvIG1ha2Ugc3VyZSB0aGF0IHRoZVxuXHRcdCogZVVwLT5PcmcgaXMgYWJvdmUgZUxvLCBvciBlTG8tPk9yZyBpcyBiZWxvdyBlVXAgKGRlcGVuZGluZyBvbiB3aGljaFxuXHRcdCogb3JpZ2luIGlzIGxlZnRtb3N0KS5cblx0XHQqXG5cdFx0KiBUaGUgbWFpbiBwdXJwb3NlIGlzIHRvIHNwbGljZSByaWdodC1nb2luZyBlZGdlcyB3aXRoIHRoZSBzYW1lXG5cdFx0KiBkZXN0IHZlcnRleCBhbmQgbmVhcmx5IGlkZW50aWNhbCBzbG9wZXMgKGllLiB3ZSBjYW4ndCBkaXN0aW5ndWlzaFxuXHRcdCogdGhlIHNsb3BlcyBudW1lcmljYWxseSkuICBIb3dldmVyIHRoZSBzcGxpY2luZyBjYW4gYWxzbyBoZWxwIHVzXG5cdFx0KiB0byByZWNvdmVyIGZyb20gbnVtZXJpY2FsIGVycm9ycy4gIEZvciBleGFtcGxlLCBzdXBwb3NlIGF0IG9uZVxuXHRcdCogcG9pbnQgd2UgY2hlY2tlZCBlVXAgYW5kIGVMbywgYW5kIGRlY2lkZWQgdGhhdCBlVXAtPk9yZyBpcyBiYXJlbHlcblx0XHQqIGFib3ZlIGVMby4gIFRoZW4gbGF0ZXIsIHdlIHNwbGl0IGVMbyBpbnRvIHR3byBlZGdlcyAoZWcuIGZyb21cblx0XHQqIGEgc3BsaWNlIG9wZXJhdGlvbiBsaWtlIHRoaXMgb25lKS4gIFRoaXMgY2FuIGNoYW5nZSB0aGUgcmVzdWx0IG9mXG5cdFx0KiBvdXIgdGVzdCBzbyB0aGF0IG5vdyBlVXAtPk9yZyBpcyBpbmNpZGVudCB0byBlTG8sIG9yIGJhcmVseSBiZWxvdyBpdC5cblx0XHQqIFdlIG11c3QgY29ycmVjdCB0aGlzIGNvbmRpdGlvbiB0byBtYWludGFpbiB0aGUgZGljdGlvbmFyeSBpbnZhcmlhbnRzLlxuXHRcdCpcblx0XHQqIE9uZSBwb3NzaWJpbGl0eSBpcyB0byBjaGVjayB0aGVzZSBlZGdlcyBmb3IgaW50ZXJzZWN0aW9uIGFnYWluXG5cdFx0KiAoaWUuIENoZWNrRm9ySW50ZXJzZWN0KS4gIFRoaXMgaXMgd2hhdCB3ZSBkbyBpZiBwb3NzaWJsZS4gIEhvd2V2ZXJcblx0XHQqIENoZWNrRm9ySW50ZXJzZWN0IHJlcXVpcmVzIHRoYXQgdGVzcy0+ZXZlbnQgbGllcyBiZXR3ZWVuIGVVcCBhbmQgZUxvLFxuXHRcdCogc28gdGhhdCBpdCBoYXMgc29tZXRoaW5nIHRvIGZhbGwgYmFjayBvbiB3aGVuIHRoZSBpbnRlcnNlY3Rpb25cblx0XHQqIGNhbGN1bGF0aW9uIGdpdmVzIHVzIGFuIHVudXNhYmxlIGFuc3dlci4gIFNvLCBmb3IgdGhvc2UgY2FzZXMgd2hlcmVcblx0XHQqIHdlIGNhbid0IGNoZWNrIGZvciBpbnRlcnNlY3Rpb24sIHRoaXMgcm91dGluZSBmaXhlcyB0aGUgcHJvYmxlbVxuXHRcdCogYnkganVzdCBzcGxpY2luZyB0aGUgb2ZmZW5kaW5nIHZlcnRleCBpbnRvIHRoZSBvdGhlciBlZGdlLlxuXHRcdCogVGhpcyBpcyBhIGd1YXJhbnRlZWQgc29sdXRpb24sIG5vIG1hdHRlciBob3cgZGVnZW5lcmF0ZSB0aGluZ3MgZ2V0LlxuXHRcdCogQmFzaWNhbGx5IHRoaXMgaXMgYSBjb21iaW5hdG9yaWFsIHNvbHV0aW9uIHRvIGEgbnVtZXJpY2FsIHByb2JsZW0uXG5cdFx0Ki9cblx0XHR2YXIgcmVnTG8gPSBTd2VlcC5yZWdpb25CZWxvdyhyZWdVcCk7XG5cdFx0dmFyIGVVcCA9IHJlZ1VwLmVVcDtcblx0XHR2YXIgZUxvID0gcmVnTG8uZVVwO1xuXG5cdFx0aWYoIEdlb20udmVydExlcSggZVVwLk9yZywgZUxvLk9yZyApKSB7XG5cdFx0XHRpZiggR2VvbS5lZGdlU2lnbiggZUxvLkRzdCwgZVVwLk9yZywgZUxvLk9yZyApID4gMCApIHJldHVybiBmYWxzZTtcblxuXHRcdFx0LyogZVVwLT5PcmcgYXBwZWFycyB0byBiZSBiZWxvdyBlTG8gKi9cblx0XHRcdGlmKCAhIEdlb20udmVydEVxKCBlVXAuT3JnLCBlTG8uT3JnICkpIHtcblx0XHRcdFx0LyogU3BsaWNlIGVVcC0+T3JnIGludG8gZUxvICovXG5cdFx0XHRcdHRlc3MubWVzaC5zcGxpdEVkZ2UoIGVMby5TeW0gKTtcblx0XHRcdFx0dGVzcy5tZXNoLnNwbGljZSggZVVwLCBlTG8uT3ByZXYgKTtcblx0XHRcdFx0cmVnVXAuZGlydHkgPSByZWdMby5kaXJ0eSA9IHRydWU7XG5cblx0XHRcdH0gZWxzZSBpZiggZVVwLk9yZyAhPT0gZUxvLk9yZyApIHtcblx0XHRcdFx0LyogbWVyZ2UgdGhlIHR3byB2ZXJ0aWNlcywgZGlzY2FyZGluZyBlVXAtPk9yZyAqL1xuXHRcdFx0XHR0ZXNzLnBxLmRlbGV0ZSggZVVwLk9yZy5wcUhhbmRsZSApO1xuXHRcdFx0XHRTd2VlcC5zcGxpY2VNZXJnZVZlcnRpY2VzKCB0ZXNzLCBlTG8uT3ByZXYsIGVVcCApO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiggR2VvbS5lZGdlU2lnbiggZVVwLkRzdCwgZUxvLk9yZywgZVVwLk9yZyApIDwgMCApIHJldHVybiBmYWxzZTtcblxuXHRcdFx0LyogZUxvLT5PcmcgYXBwZWFycyB0byBiZSBhYm92ZSBlVXAsIHNvIHNwbGljZSBlTG8tPk9yZyBpbnRvIGVVcCAqL1xuXHRcdFx0U3dlZXAucmVnaW9uQWJvdmUocmVnVXApLmRpcnR5ID0gcmVnVXAuZGlydHkgPSB0cnVlO1xuXHRcdFx0dGVzcy5tZXNoLnNwbGl0RWRnZSggZVVwLlN5bSApO1xuXHRcdFx0dGVzcy5tZXNoLnNwbGljZSggZUxvLk9wcmV2LCBlVXAgKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHQvL3N0YXRpYyBpbnQgQ2hlY2tGb3JMZWZ0U3BsaWNlKCBURVNTdGVzc2VsYXRvciAqdGVzcywgQWN0aXZlUmVnaW9uICpyZWdVcCApXG5cdFN3ZWVwLmNoZWNrRm9yTGVmdFNwbGljZSA9IGZ1bmN0aW9uKCB0ZXNzLCByZWdVcCApIHtcblx0XHQvKlxuXHRcdCogQ2hlY2sgdGhlIHVwcGVyIGFuZCBsb3dlciBlZGdlIG9mIFwicmVnVXBcIiwgdG8gbWFrZSBzdXJlIHRoYXQgdGhlXG5cdFx0KiBlVXAtPkRzdCBpcyBhYm92ZSBlTG8sIG9yIGVMby0+RHN0IGlzIGJlbG93IGVVcCAoZGVwZW5kaW5nIG9uIHdoaWNoXG5cdFx0KiBkZXN0aW5hdGlvbiBpcyByaWdodG1vc3QpLlxuXHRcdCpcblx0XHQqIFRoZW9yZXRpY2FsbHksIHRoaXMgc2hvdWxkIGFsd2F5cyBiZSB0cnVlLiAgSG93ZXZlciwgc3BsaXR0aW5nIGFuIGVkZ2Vcblx0XHQqIGludG8gdHdvIHBpZWNlcyBjYW4gY2hhbmdlIHRoZSByZXN1bHRzIG9mIHByZXZpb3VzIHRlc3RzLiAgRm9yIGV4YW1wbGUsXG5cdFx0KiBzdXBwb3NlIGF0IG9uZSBwb2ludCB3ZSBjaGVja2VkIGVVcCBhbmQgZUxvLCBhbmQgZGVjaWRlZCB0aGF0IGVVcC0+RHN0XG5cdFx0KiBpcyBiYXJlbHkgYWJvdmUgZUxvLiAgVGhlbiBsYXRlciwgd2Ugc3BsaXQgZUxvIGludG8gdHdvIGVkZ2VzIChlZy4gZnJvbVxuXHRcdCogYSBzcGxpY2Ugb3BlcmF0aW9uIGxpa2UgdGhpcyBvbmUpLiAgVGhpcyBjYW4gY2hhbmdlIHRoZSByZXN1bHQgb2Zcblx0XHQqIHRoZSB0ZXN0IHNvIHRoYXQgbm93IGVVcC0+RHN0IGlzIGluY2lkZW50IHRvIGVMbywgb3IgYmFyZWx5IGJlbG93IGl0LlxuXHRcdCogV2UgbXVzdCBjb3JyZWN0IHRoaXMgY29uZGl0aW9uIHRvIG1haW50YWluIHRoZSBkaWN0aW9uYXJ5IGludmFyaWFudHNcblx0XHQqIChvdGhlcndpc2UgbmV3IGVkZ2VzIG1pZ2h0IGdldCBpbnNlcnRlZCBpbiB0aGUgd3JvbmcgcGxhY2UgaW4gdGhlXG5cdFx0KiBkaWN0aW9uYXJ5LCBhbmQgYmFkIHN0dWZmIHdpbGwgaGFwcGVuKS5cblx0XHQqXG5cdFx0KiBXZSBmaXggdGhlIHByb2JsZW0gYnkganVzdCBzcGxpY2luZyB0aGUgb2ZmZW5kaW5nIHZlcnRleCBpbnRvIHRoZVxuXHRcdCogb3RoZXIgZWRnZS5cblx0XHQqL1xuXHRcdHZhciByZWdMbyA9IFN3ZWVwLnJlZ2lvbkJlbG93KHJlZ1VwKTtcblx0XHR2YXIgZVVwID0gcmVnVXAuZVVwO1xuXHRcdHZhciBlTG8gPSByZWdMby5lVXA7XG5cdFx0dmFyIGU7XG5cblx0XHRhc3NlcnQoICEgR2VvbS52ZXJ0RXEoIGVVcC5Ec3QsIGVMby5Ec3QgKSk7XG5cblx0XHRpZiggR2VvbS52ZXJ0TGVxKCBlVXAuRHN0LCBlTG8uRHN0ICkpIHtcblx0XHRcdGlmKCBHZW9tLmVkZ2VTaWduKCBlVXAuRHN0LCBlTG8uRHN0LCBlVXAuT3JnICkgPCAwICkgcmV0dXJuIGZhbHNlO1xuXG5cdFx0XHQvKiBlTG8tPkRzdCBpcyBhYm92ZSBlVXAsIHNvIHNwbGljZSBlTG8tPkRzdCBpbnRvIGVVcCAqL1xuXHRcdFx0U3dlZXAucmVnaW9uQWJvdmUocmVnVXApLmRpcnR5ID0gcmVnVXAuZGlydHkgPSB0cnVlO1xuXHRcdFx0ZSA9IHRlc3MubWVzaC5zcGxpdEVkZ2UoIGVVcCApO1xuXHRcdFx0dGVzcy5tZXNoLnNwbGljZSggZUxvLlN5bSwgZSApO1xuXHRcdFx0ZS5MZmFjZS5pbnNpZGUgPSByZWdVcC5pbnNpZGU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmKCBHZW9tLmVkZ2VTaWduKCBlTG8uRHN0LCBlVXAuRHN0LCBlTG8uT3JnICkgPiAwICkgcmV0dXJuIGZhbHNlO1xuXG5cdFx0XHQvKiBlVXAtPkRzdCBpcyBiZWxvdyBlTG8sIHNvIHNwbGljZSBlVXAtPkRzdCBpbnRvIGVMbyAqL1xuXHRcdFx0cmVnVXAuZGlydHkgPSByZWdMby5kaXJ0eSA9IHRydWU7XG5cdFx0XHRlID0gdGVzcy5tZXNoLnNwbGl0RWRnZSggZUxvICk7XG5cdFx0XHR0ZXNzLm1lc2guc3BsaWNlKCBlVXAuTG5leHQsIGVMby5TeW0gKTtcblx0XHRcdGUuUmZhY2UuaW5zaWRlID0gcmVnVXAuaW5zaWRlO1xuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cblx0Ly9zdGF0aWMgaW50IENoZWNrRm9ySW50ZXJzZWN0KCBURVNTdGVzc2VsYXRvciAqdGVzcywgQWN0aXZlUmVnaW9uICpyZWdVcCApXG5cdFN3ZWVwLmNoZWNrRm9ySW50ZXJzZWN0ID0gZnVuY3Rpb24oIHRlc3MsIHJlZ1VwICkge1xuXHRcdC8qXG5cdFx0KiBDaGVjayB0aGUgdXBwZXIgYW5kIGxvd2VyIGVkZ2VzIG9mIHRoZSBnaXZlbiByZWdpb24gdG8gc2VlIGlmXG5cdFx0KiB0aGV5IGludGVyc2VjdC4gIElmIHNvLCBjcmVhdGUgdGhlIGludGVyc2VjdGlvbiBhbmQgYWRkIGl0XG5cdFx0KiB0byB0aGUgZGF0YSBzdHJ1Y3R1cmVzLlxuXHRcdCpcblx0XHQqIFJldHVybnMgVFJVRSBpZiBhZGRpbmcgdGhlIG5ldyBpbnRlcnNlY3Rpb24gcmVzdWx0ZWQgaW4gYSByZWN1cnNpdmVcblx0XHQqIGNhbGwgdG8gQWRkUmlnaHRFZGdlcygpOyBpbiB0aGlzIGNhc2UgYWxsIFwiZGlydHlcIiByZWdpb25zIGhhdmUgYmVlblxuXHRcdCogY2hlY2tlZCBmb3IgaW50ZXJzZWN0aW9ucywgYW5kIHBvc3NpYmx5IHJlZ1VwIGhhcyBiZWVuIGRlbGV0ZWQuXG5cdFx0Ki9cblx0XHR2YXIgcmVnTG8gPSBTd2VlcC5yZWdpb25CZWxvdyhyZWdVcCk7XG5cdFx0dmFyIGVVcCA9IHJlZ1VwLmVVcDtcblx0XHR2YXIgZUxvID0gcmVnTG8uZVVwO1xuXHRcdHZhciBvcmdVcCA9IGVVcC5Pcmc7XG5cdFx0dmFyIG9yZ0xvID0gZUxvLk9yZztcblx0XHR2YXIgZHN0VXAgPSBlVXAuRHN0O1xuXHRcdHZhciBkc3RMbyA9IGVMby5Ec3Q7XG5cdFx0dmFyIHRNaW5VcCwgdE1heExvO1xuXHRcdHZhciBpc2VjdCA9IG5ldyBURVNTdmVydGV4LCBvcmdNaW47XG5cdFx0dmFyIGU7XG5cblx0XHRhc3NlcnQoICEgR2VvbS52ZXJ0RXEoIGRzdExvLCBkc3RVcCApKTtcblx0XHRhc3NlcnQoIEdlb20uZWRnZVNpZ24oIGRzdFVwLCB0ZXNzLmV2ZW50LCBvcmdVcCApIDw9IDAgKTtcblx0XHRhc3NlcnQoIEdlb20uZWRnZVNpZ24oIGRzdExvLCB0ZXNzLmV2ZW50LCBvcmdMbyApID49IDAgKTtcblx0XHRhc3NlcnQoIG9yZ1VwICE9PSB0ZXNzLmV2ZW50ICYmIG9yZ0xvICE9PSB0ZXNzLmV2ZW50ICk7XG5cdFx0YXNzZXJ0KCAhIHJlZ1VwLmZpeFVwcGVyRWRnZSAmJiAhIHJlZ0xvLmZpeFVwcGVyRWRnZSApO1xuXG5cdFx0aWYoIG9yZ1VwID09PSBvcmdMbyApIHJldHVybiBmYWxzZTtcdC8qIHJpZ2h0IGVuZHBvaW50cyBhcmUgdGhlIHNhbWUgKi9cblxuXHRcdHRNaW5VcCA9IE1hdGgubWluKCBvcmdVcC50LCBkc3RVcC50ICk7XG5cdFx0dE1heExvID0gTWF0aC5tYXgoIG9yZ0xvLnQsIGRzdExvLnQgKTtcblx0XHRpZiggdE1pblVwID4gdE1heExvICkgcmV0dXJuIGZhbHNlO1x0LyogdCByYW5nZXMgZG8gbm90IG92ZXJsYXAgKi9cblxuXHRcdGlmKCBHZW9tLnZlcnRMZXEoIG9yZ1VwLCBvcmdMbyApKSB7XG5cdFx0XHRpZiggR2VvbS5lZGdlU2lnbiggZHN0TG8sIG9yZ1VwLCBvcmdMbyApID4gMCApIHJldHVybiBmYWxzZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYoIEdlb20uZWRnZVNpZ24oIGRzdFVwLCBvcmdMbywgb3JnVXAgKSA8IDAgKSByZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0LyogQXQgdGhpcyBwb2ludCB0aGUgZWRnZXMgaW50ZXJzZWN0LCBhdCBsZWFzdCBtYXJnaW5hbGx5ICovXG5cdFx0U3dlZXAuZGVidWdFdmVudCggdGVzcyApO1xuXG5cdFx0R2VvbS5pbnRlcnNlY3QoIGRzdFVwLCBvcmdVcCwgZHN0TG8sIG9yZ0xvLCBpc2VjdCApO1xuXHRcdC8qIFRoZSBmb2xsb3dpbmcgcHJvcGVydGllcyBhcmUgZ3VhcmFudGVlZDogKi9cblx0XHRhc3NlcnQoIE1hdGgubWluKCBvcmdVcC50LCBkc3RVcC50ICkgPD0gaXNlY3QudCApO1xuXHRcdGFzc2VydCggaXNlY3QudCA8PSBNYXRoLm1heCggb3JnTG8udCwgZHN0TG8udCApKTtcblx0XHRhc3NlcnQoIE1hdGgubWluKCBkc3RMby5zLCBkc3RVcC5zICkgPD0gaXNlY3QucyApO1xuXHRcdGFzc2VydCggaXNlY3QucyA8PSBNYXRoLm1heCggb3JnTG8ucywgb3JnVXAucyApKTtcblxuXHRcdGlmKCBHZW9tLnZlcnRMZXEoIGlzZWN0LCB0ZXNzLmV2ZW50ICkpIHtcblx0XHRcdC8qIFRoZSBpbnRlcnNlY3Rpb24gcG9pbnQgbGllcyBzbGlnaHRseSB0byB0aGUgbGVmdCBvZiB0aGUgc3dlZXAgbGluZSxcblx0XHRcdCogc28gbW92ZSBpdCB1bnRpbCBpdCcncyBzbGlnaHRseSB0byB0aGUgcmlnaHQgb2YgdGhlIHN3ZWVwIGxpbmUuXG5cdFx0XHQqIChJZiB3ZSBoYWQgcGVyZmVjdCBudW1lcmljYWwgcHJlY2lzaW9uLCB0aGlzIHdvdWxkIG5ldmVyIGhhcHBlblxuXHRcdFx0KiBpbiB0aGUgZmlyc3QgcGxhY2UpLiAgVGhlIGVhc2llc3QgYW5kIHNhZmVzdCB0aGluZyB0byBkbyBpc1xuXHRcdFx0KiByZXBsYWNlIHRoZSBpbnRlcnNlY3Rpb24gYnkgdGVzcy0+ZXZlbnQuXG5cdFx0XHQqL1xuXHRcdFx0aXNlY3QucyA9IHRlc3MuZXZlbnQucztcblx0XHRcdGlzZWN0LnQgPSB0ZXNzLmV2ZW50LnQ7XG5cdFx0fVxuXHRcdC8qIFNpbWlsYXJseSwgaWYgdGhlIGNvbXB1dGVkIGludGVyc2VjdGlvbiBsaWVzIHRvIHRoZSByaWdodCBvZiB0aGVcblx0XHQqIHJpZ2h0bW9zdCBvcmlnaW4gKHdoaWNoIHNob3VsZCByYXJlbHkgaGFwcGVuKSwgaXQgY2FuIGNhdXNlXG5cdFx0KiB1bmJlbGlldmFibGUgaW5lZmZpY2llbmN5IG9uIHN1ZmZpY2llbnRseSBkZWdlbmVyYXRlIGlucHV0cy5cblx0XHQqIChJZiB5b3UgaGF2ZSB0aGUgdGVzdCBwcm9ncmFtLCB0cnkgcnVubmluZyB0ZXN0NTQuZCB3aXRoIHRoZVxuXHRcdCogXCJYIHpvb21cIiBvcHRpb24gdHVybmVkIG9uKS5cblx0XHQqL1xuXHRcdG9yZ01pbiA9IEdlb20udmVydExlcSggb3JnVXAsIG9yZ0xvICkgPyBvcmdVcCA6IG9yZ0xvO1xuXHRcdGlmKCBHZW9tLnZlcnRMZXEoIG9yZ01pbiwgaXNlY3QgKSkge1xuXHRcdFx0aXNlY3QucyA9IG9yZ01pbi5zO1xuXHRcdFx0aXNlY3QudCA9IG9yZ01pbi50O1xuXHRcdH1cblxuXHRcdGlmKCBHZW9tLnZlcnRFcSggaXNlY3QsIG9yZ1VwICkgfHwgR2VvbS52ZXJ0RXEoIGlzZWN0LCBvcmdMbyApKSB7XG5cdFx0XHQvKiBFYXN5IGNhc2UgLS0gaW50ZXJzZWN0aW9uIGF0IG9uZSBvZiB0aGUgcmlnaHQgZW5kcG9pbnRzICovXG5cdFx0XHRTd2VlcC5jaGVja0ZvclJpZ2h0U3BsaWNlKCB0ZXNzLCByZWdVcCApO1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdGlmKCAgICAoISBHZW9tLnZlcnRFcSggZHN0VXAsIHRlc3MuZXZlbnQgKVxuXHRcdFx0JiYgR2VvbS5lZGdlU2lnbiggZHN0VXAsIHRlc3MuZXZlbnQsIGlzZWN0ICkgPj0gMClcblx0XHRcdHx8ICghIEdlb20udmVydEVxKCBkc3RMbywgdGVzcy5ldmVudCApXG5cdFx0XHQmJiBHZW9tLmVkZ2VTaWduKCBkc3RMbywgdGVzcy5ldmVudCwgaXNlY3QgKSA8PSAwICkpXG5cdFx0e1xuXHRcdFx0LyogVmVyeSB1bnVzdWFsIC0tIHRoZSBuZXcgdXBwZXIgb3IgbG93ZXIgZWRnZSB3b3VsZCBwYXNzIG9uIHRoZVxuXHRcdFx0KiB3cm9uZyBzaWRlIG9mIHRoZSBzd2VlcCBldmVudCwgb3IgdGhyb3VnaCBpdC4gIFRoaXMgY2FuIGhhcHBlblxuXHRcdFx0KiBkdWUgdG8gdmVyeSBzbWFsbCBudW1lcmljYWwgZXJyb3JzIGluIHRoZSBpbnRlcnNlY3Rpb24gY2FsY3VsYXRpb24uXG5cdFx0XHQqL1xuXHRcdFx0aWYoIGRzdExvID09PSB0ZXNzLmV2ZW50ICkge1xuXHRcdFx0XHQvKiBTcGxpY2UgZHN0TG8gaW50byBlVXAsIGFuZCBwcm9jZXNzIHRoZSBuZXcgcmVnaW9uKHMpICovXG5cdFx0XHRcdHRlc3MubWVzaC5zcGxpdEVkZ2UoIGVVcC5TeW0gKTtcblx0XHRcdFx0dGVzcy5tZXNoLnNwbGljZSggZUxvLlN5bSwgZVVwICk7XG5cdFx0XHRcdHJlZ1VwID0gU3dlZXAudG9wTGVmdFJlZ2lvbiggdGVzcywgcmVnVXAgKTtcblx0Ly9cdFx0XHRpZiAocmVnVXAgPT0gTlVMTCkgbG9uZ2ptcCh0ZXNzLT5lbnYsMSk7XG5cdFx0XHRcdGVVcCA9IFN3ZWVwLnJlZ2lvbkJlbG93KHJlZ1VwKS5lVXA7XG5cdFx0XHRcdFN3ZWVwLmZpbmlzaExlZnRSZWdpb25zKCB0ZXNzLCBTd2VlcC5yZWdpb25CZWxvdyhyZWdVcCksIHJlZ0xvICk7XG5cdFx0XHRcdFN3ZWVwLmFkZFJpZ2h0RWRnZXMoIHRlc3MsIHJlZ1VwLCBlVXAuT3ByZXYsIGVVcCwgZVVwLCB0cnVlICk7XG5cdFx0XHRcdHJldHVybiBUUlVFO1xuXHRcdFx0fVxuXHRcdFx0aWYoIGRzdFVwID09PSB0ZXNzLmV2ZW50ICkge1xuXHRcdFx0XHQvKiBTcGxpY2UgZHN0VXAgaW50byBlTG8sIGFuZCBwcm9jZXNzIHRoZSBuZXcgcmVnaW9uKHMpICovXG5cdFx0XHRcdHRlc3MubWVzaC5zcGxpdEVkZ2UoIGVMby5TeW0gKTtcblx0XHRcdFx0dGVzcy5tZXNoLnNwbGljZSggZVVwLkxuZXh0LCBlTG8uT3ByZXYgKTsgXG5cdFx0XHRcdHJlZ0xvID0gcmVnVXA7XG5cdFx0XHRcdHJlZ1VwID0gU3dlZXAudG9wUmlnaHRSZWdpb24oIHJlZ1VwICk7XG5cdFx0XHRcdGUgPSBTd2VlcC5yZWdpb25CZWxvdyhyZWdVcCkuZVVwLlJwcmV2O1xuXHRcdFx0XHRyZWdMby5lVXAgPSBlTG8uT3ByZXY7XG5cdFx0XHRcdGVMbyA9IFN3ZWVwLmZpbmlzaExlZnRSZWdpb25zKCB0ZXNzLCByZWdMbywgbnVsbCApO1xuXHRcdFx0XHRTd2VlcC5hZGRSaWdodEVkZ2VzKCB0ZXNzLCByZWdVcCwgZUxvLk9uZXh0LCBlVXAuUnByZXYsIGUsIHRydWUgKTtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0XHQvKiBTcGVjaWFsIGNhc2U6IGNhbGxlZCBmcm9tIENvbm5lY3RSaWdodFZlcnRleC4gIElmIGVpdGhlclxuXHRcdFx0KiBlZGdlIHBhc3NlcyBvbiB0aGUgd3Jvbmcgc2lkZSBvZiB0ZXNzLT5ldmVudCwgc3BsaXQgaXRcblx0XHRcdCogKGFuZCB3YWl0IGZvciBDb25uZWN0UmlnaHRWZXJ0ZXggdG8gc3BsaWNlIGl0IGFwcHJvcHJpYXRlbHkpLlxuXHRcdFx0Ki9cblx0XHRcdGlmKCBHZW9tLmVkZ2VTaWduKCBkc3RVcCwgdGVzcy5ldmVudCwgaXNlY3QgKSA+PSAwICkge1xuXHRcdFx0XHRTd2VlcC5yZWdpb25BYm92ZShyZWdVcCkuZGlydHkgPSByZWdVcC5kaXJ0eSA9IHRydWU7XG5cdFx0XHRcdHRlc3MubWVzaC5zcGxpdEVkZ2UoIGVVcC5TeW0gKTtcblx0XHRcdFx0ZVVwLk9yZy5zID0gdGVzcy5ldmVudC5zO1xuXHRcdFx0XHRlVXAuT3JnLnQgPSB0ZXNzLmV2ZW50LnQ7XG5cdFx0XHR9XG5cdFx0XHRpZiggR2VvbS5lZGdlU2lnbiggZHN0TG8sIHRlc3MuZXZlbnQsIGlzZWN0ICkgPD0gMCApIHtcblx0XHRcdFx0cmVnVXAuZGlydHkgPSByZWdMby5kaXJ0eSA9IHRydWU7XG5cdFx0XHRcdHRlc3MubWVzaC5zcGxpdEVkZ2UoIGVMby5TeW0gKTtcblx0XHRcdFx0ZUxvLk9yZy5zID0gdGVzcy5ldmVudC5zO1xuXHRcdFx0XHRlTG8uT3JnLnQgPSB0ZXNzLmV2ZW50LnQ7XG5cdFx0XHR9XG5cdFx0XHQvKiBsZWF2ZSB0aGUgcmVzdCBmb3IgQ29ubmVjdFJpZ2h0VmVydGV4ICovXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0LyogR2VuZXJhbCBjYXNlIC0tIHNwbGl0IGJvdGggZWRnZXMsIHNwbGljZSBpbnRvIG5ldyB2ZXJ0ZXguXG5cdFx0KiBXaGVuIHdlIGRvIHRoZSBzcGxpY2Ugb3BlcmF0aW9uLCB0aGUgb3JkZXIgb2YgdGhlIGFyZ3VtZW50cyBpc1xuXHRcdCogYXJiaXRyYXJ5IGFzIGZhciBhcyBjb3JyZWN0bmVzcyBnb2VzLiAgSG93ZXZlciwgd2hlbiB0aGUgb3BlcmF0aW9uXG5cdFx0KiBjcmVhdGVzIGEgbmV3IGZhY2UsIHRoZSB3b3JrIGRvbmUgaXMgcHJvcG9ydGlvbmFsIHRvIHRoZSBzaXplIG9mXG5cdFx0KiB0aGUgbmV3IGZhY2UuICBXZSBleHBlY3QgdGhlIGZhY2VzIGluIHRoZSBwcm9jZXNzZWQgcGFydCBvZlxuXHRcdCogdGhlIG1lc2ggKGllLiBlVXAtPkxmYWNlKSB0byBiZSBzbWFsbGVyIHRoYW4gdGhlIGZhY2VzIGluIHRoZVxuXHRcdCogdW5wcm9jZXNzZWQgb3JpZ2luYWwgY29udG91cnMgKHdoaWNoIHdpbGwgYmUgZUxvLT5PcHJldi0+TGZhY2UpLlxuXHRcdCovXG5cdFx0dGVzcy5tZXNoLnNwbGl0RWRnZSggZVVwLlN5bSApO1xuXHRcdHRlc3MubWVzaC5zcGxpdEVkZ2UoIGVMby5TeW0gKTtcblx0XHR0ZXNzLm1lc2guc3BsaWNlKCBlTG8uT3ByZXYsIGVVcCApO1xuXHRcdGVVcC5PcmcucyA9IGlzZWN0LnM7XG5cdFx0ZVVwLk9yZy50ID0gaXNlY3QudDtcblx0XHRlVXAuT3JnLnBxSGFuZGxlID0gdGVzcy5wcS5pbnNlcnQoIGVVcC5PcmcgKTtcblx0XHRTd2VlcC5nZXRJbnRlcnNlY3REYXRhKCB0ZXNzLCBlVXAuT3JnLCBvcmdVcCwgZHN0VXAsIG9yZ0xvLCBkc3RMbyApO1xuXHRcdFN3ZWVwLnJlZ2lvbkFib3ZlKHJlZ1VwKS5kaXJ0eSA9IHJlZ1VwLmRpcnR5ID0gcmVnTG8uZGlydHkgPSB0cnVlO1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdC8vc3RhdGljIHZvaWQgV2Fsa0RpcnR5UmVnaW9ucyggVEVTU3Rlc3NlbGF0b3IgKnRlc3MsIEFjdGl2ZVJlZ2lvbiAqcmVnVXAgKVxuXHRTd2VlcC53YWxrRGlydHlSZWdpb25zID0gZnVuY3Rpb24oIHRlc3MsIHJlZ1VwICkge1xuXHRcdC8qXG5cdFx0KiBXaGVuIHRoZSB1cHBlciBvciBsb3dlciBlZGdlIG9mIGFueSByZWdpb24gY2hhbmdlcywgdGhlIHJlZ2lvbiBpc1xuXHRcdCogbWFya2VkIFwiZGlydHlcIi4gIFRoaXMgcm91dGluZSB3YWxrcyB0aHJvdWdoIGFsbCB0aGUgZGlydHkgcmVnaW9uc1xuXHRcdCogYW5kIG1ha2VzIHN1cmUgdGhhdCB0aGUgZGljdGlvbmFyeSBpbnZhcmlhbnRzIGFyZSBzYXRpc2ZpZWRcblx0XHQqIChzZWUgdGhlIGNvbW1lbnRzIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhpcyBmaWxlKS4gIE9mIGNvdXJzZVxuXHRcdCogbmV3IGRpcnR5IHJlZ2lvbnMgY2FuIGJlIGNyZWF0ZWQgYXMgd2UgbWFrZSBjaGFuZ2VzIHRvIHJlc3RvcmVcblx0XHQqIHRoZSBpbnZhcmlhbnRzLlxuXHRcdCovXG5cdFx0dmFyIHJlZ0xvID0gU3dlZXAucmVnaW9uQmVsb3cocmVnVXApO1xuXHRcdHZhciBlVXAsIGVMbztcblxuXHRcdGZvciggOzsgKSB7XG5cdFx0XHQvKiBGaW5kIHRoZSBsb3dlc3QgZGlydHkgcmVnaW9uICh3ZSB3YWxrIGZyb20gdGhlIGJvdHRvbSB1cCkuICovXG5cdFx0XHR3aGlsZSggcmVnTG8uZGlydHkgKSB7XG5cdFx0XHRcdHJlZ1VwID0gcmVnTG87XG5cdFx0XHRcdHJlZ0xvID0gU3dlZXAucmVnaW9uQmVsb3cocmVnTG8pO1xuXHRcdFx0fVxuXHRcdFx0aWYoICEgcmVnVXAuZGlydHkgKSB7XG5cdFx0XHRcdHJlZ0xvID0gcmVnVXA7XG5cdFx0XHRcdHJlZ1VwID0gU3dlZXAucmVnaW9uQWJvdmUoIHJlZ1VwICk7XG5cdFx0XHRcdGlmKCByZWdVcCA9PSBudWxsIHx8ICEgcmVnVXAuZGlydHkgKSB7XG5cdFx0XHRcdFx0LyogV2UndmUgd2Fsa2VkIGFsbCB0aGUgZGlydHkgcmVnaW9ucyAqL1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmVnVXAuZGlydHkgPSBmYWxzZTtcblx0XHRcdGVVcCA9IHJlZ1VwLmVVcDtcblx0XHRcdGVMbyA9IHJlZ0xvLmVVcDtcblxuXHRcdFx0aWYoIGVVcC5Ec3QgIT09IGVMby5Ec3QgKSB7XG5cdFx0XHRcdC8qIENoZWNrIHRoYXQgdGhlIGVkZ2Ugb3JkZXJpbmcgaXMgb2JleWVkIGF0IHRoZSBEc3QgdmVydGljZXMuICovXG5cdFx0XHRcdGlmKCBTd2VlcC5jaGVja0ZvckxlZnRTcGxpY2UoIHRlc3MsIHJlZ1VwICkpIHtcblxuXHRcdFx0XHRcdC8qIElmIHRoZSB1cHBlciBvciBsb3dlciBlZGdlIHdhcyBtYXJrZWQgZml4VXBwZXJFZGdlLCB0aGVuXG5cdFx0XHRcdFx0KiB3ZSBubyBsb25nZXIgbmVlZCBpdCAoc2luY2UgdGhlc2UgZWRnZXMgYXJlIG5lZWRlZCBvbmx5IGZvclxuXHRcdFx0XHRcdCogdmVydGljZXMgd2hpY2ggb3RoZXJ3aXNlIGhhdmUgbm8gcmlnaHQtZ29pbmcgZWRnZXMpLlxuXHRcdFx0XHRcdCovXG5cdFx0XHRcdFx0aWYoIHJlZ0xvLmZpeFVwcGVyRWRnZSApIHtcblx0XHRcdFx0XHRcdFN3ZWVwLmRlbGV0ZVJlZ2lvbiggdGVzcywgcmVnTG8gKTtcblx0XHRcdFx0XHRcdHRlc3MubWVzaC5kZWxldGUoIGVMbyApO1xuXHRcdFx0XHRcdFx0cmVnTG8gPSBTd2VlcC5yZWdpb25CZWxvdyggcmVnVXAgKTtcblx0XHRcdFx0XHRcdGVMbyA9IHJlZ0xvLmVVcDtcblx0XHRcdFx0XHR9IGVsc2UgaWYoIHJlZ1VwLmZpeFVwcGVyRWRnZSApIHtcblx0XHRcdFx0XHRcdFN3ZWVwLmRlbGV0ZVJlZ2lvbiggdGVzcywgcmVnVXAgKTtcblx0XHRcdFx0XHRcdHRlc3MubWVzaC5kZWxldGUoIGVVcCApO1xuXHRcdFx0XHRcdFx0cmVnVXAgPSBTd2VlcC5yZWdpb25BYm92ZSggcmVnTG8gKTtcblx0XHRcdFx0XHRcdGVVcCA9IHJlZ1VwLmVVcDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmKCBlVXAuT3JnICE9PSBlTG8uT3JnICkge1xuXHRcdFx0XHRpZiggICAgZVVwLkRzdCAhPT0gZUxvLkRzdFxuXHRcdFx0XHRcdCYmICEgcmVnVXAuZml4VXBwZXJFZGdlICYmICEgcmVnTG8uZml4VXBwZXJFZGdlXG5cdFx0XHRcdFx0JiYgKGVVcC5Ec3QgPT09IHRlc3MuZXZlbnQgfHwgZUxvLkRzdCA9PT0gdGVzcy5ldmVudCkgKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0LyogV2hlbiBhbGwgZWxzZSBmYWlscyBpbiBDaGVja0ZvckludGVyc2VjdCgpLCBpdCB1c2VzIHRlc3MtPmV2ZW50XG5cdFx0XHRcdFx0KiBhcyB0aGUgaW50ZXJzZWN0aW9uIGxvY2F0aW9uLiAgVG8gbWFrZSB0aGlzIHBvc3NpYmxlLCBpdCByZXF1aXJlc1xuXHRcdFx0XHRcdCogdGhhdCB0ZXNzLT5ldmVudCBsaWUgYmV0d2VlbiB0aGUgdXBwZXIgYW5kIGxvd2VyIGVkZ2VzLCBhbmQgYWxzb1xuXHRcdFx0XHRcdCogdGhhdCBuZWl0aGVyIG9mIHRoZXNlIGlzIG1hcmtlZCBmaXhVcHBlckVkZ2UgKHNpbmNlIGluIHRoZSB3b3JzdFxuXHRcdFx0XHRcdCogY2FzZSBpdCBtaWdodCBzcGxpY2Ugb25lIG9mIHRoZXNlIGVkZ2VzIGludG8gdGVzcy0+ZXZlbnQsIGFuZFxuXHRcdFx0XHRcdCogdmlvbGF0ZSB0aGUgaW52YXJpYW50IHRoYXQgZml4YWJsZSBlZGdlcyBhcmUgdGhlIG9ubHkgcmlnaHQtZ29pbmdcblx0XHRcdFx0XHQqIGVkZ2UgZnJvbSB0aGVpciBhc3NvY2lhdGVkIHZlcnRleCkuXG5cdFx0XHRcdFx0Ki9cblx0XHRcdFx0XHRpZiggU3dlZXAuY2hlY2tGb3JJbnRlcnNlY3QoIHRlc3MsIHJlZ1VwICkpIHtcblx0XHRcdFx0XHRcdC8qIFdhbGtEaXJ0eVJlZ2lvbnMoKSB3YXMgY2FsbGVkIHJlY3Vyc2l2ZWx5OyB3ZSdyZSBkb25lICovXG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8qIEV2ZW4gdGhvdWdoIHdlIGNhbid0IHVzZSBDaGVja0ZvckludGVyc2VjdCgpLCB0aGUgT3JnIHZlcnRpY2VzXG5cdFx0XHRcdFx0KiBtYXkgdmlvbGF0ZSB0aGUgZGljdGlvbmFyeSBlZGdlIG9yZGVyaW5nLiAgQ2hlY2sgYW5kIGNvcnJlY3QgdGhpcy5cblx0XHRcdFx0XHQqL1xuXHRcdFx0XHRcdFN3ZWVwLmNoZWNrRm9yUmlnaHRTcGxpY2UoIHRlc3MsIHJlZ1VwICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmKCBlVXAuT3JnID09PSBlTG8uT3JnICYmIGVVcC5Ec3QgPT09IGVMby5Ec3QgKSB7XG5cdFx0XHRcdC8qIEEgZGVnZW5lcmF0ZSBsb29wIGNvbnNpc3Rpbmcgb2Ygb25seSB0d28gZWRnZXMgLS0gZGVsZXRlIGl0LiAqL1xuXHRcdFx0XHRTd2VlcC5hZGRXaW5kaW5nKCBlTG8sIGVVcCApO1xuXHRcdFx0XHRTd2VlcC5kZWxldGVSZWdpb24oIHRlc3MsIHJlZ1VwICk7XG5cdFx0XHRcdHRlc3MubWVzaC5kZWxldGUoIGVVcCApO1xuXHRcdFx0XHRyZWdVcCA9IFN3ZWVwLnJlZ2lvbkFib3ZlKCByZWdMbyApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cblx0Ly9zdGF0aWMgdm9pZCBDb25uZWN0UmlnaHRWZXJ0ZXgoIFRFU1N0ZXNzZWxhdG9yICp0ZXNzLCBBY3RpdmVSZWdpb24gKnJlZ1VwLCBURVNTaGFsZkVkZ2UgKmVCb3R0b21MZWZ0IClcblx0U3dlZXAuY29ubmVjdFJpZ2h0VmVydGV4ID0gZnVuY3Rpb24oIHRlc3MsIHJlZ1VwLCBlQm90dG9tTGVmdCApIHtcblx0XHQvKlxuXHRcdCogUHVycG9zZTogY29ubmVjdCBhIFwicmlnaHRcIiB2ZXJ0ZXggdkV2ZW50IChvbmUgd2hlcmUgYWxsIGVkZ2VzIGdvIGxlZnQpXG5cdFx0KiB0byB0aGUgdW5wcm9jZXNzZWQgcG9ydGlvbiBvZiB0aGUgbWVzaC4gIFNpbmNlIHRoZXJlIGFyZSBubyByaWdodC1nb2luZ1xuXHRcdCogZWRnZXMsIHR3byByZWdpb25zIChvbmUgYWJvdmUgdkV2ZW50IGFuZCBvbmUgYmVsb3cpIGFyZSBiZWluZyBtZXJnZWRcblx0XHQqIGludG8gb25lLiAgXCJyZWdVcFwiIGlzIHRoZSB1cHBlciBvZiB0aGVzZSB0d28gcmVnaW9ucy5cblx0XHQqXG5cdFx0KiBUaGVyZSBhcmUgdHdvIHJlYXNvbnMgZm9yIGRvaW5nIHRoaXMgKGFkZGluZyBhIHJpZ2h0LWdvaW5nIGVkZ2UpOlxuXHRcdCogIC0gaWYgdGhlIHR3byByZWdpb25zIGJlaW5nIG1lcmdlZCBhcmUgXCJpbnNpZGVcIiwgd2UgbXVzdCBhZGQgYW4gZWRnZVxuXHRcdCogICAgdG8ga2VlcCB0aGVtIHNlcGFyYXRlZCAodGhlIGNvbWJpbmVkIHJlZ2lvbiB3b3VsZCBub3QgYmUgbW9ub3RvbmUpLlxuXHRcdCogIC0gaW4gYW55IGNhc2UsIHdlIG11c3QgbGVhdmUgc29tZSByZWNvcmQgb2YgdkV2ZW50IGluIHRoZSBkaWN0aW9uYXJ5LFxuXHRcdCogICAgc28gdGhhdCB3ZSBjYW4gbWVyZ2UgdkV2ZW50IHdpdGggZmVhdHVyZXMgdGhhdCB3ZSBoYXZlIG5vdCBzZWVuIHlldC5cblx0XHQqICAgIEZvciBleGFtcGxlLCBtYXliZSB0aGVyZSBpcyBhIHZlcnRpY2FsIGVkZ2Ugd2hpY2ggcGFzc2VzIGp1c3QgdG9cblx0XHQqICAgIHRoZSByaWdodCBvZiB2RXZlbnQ7IHdlIHdvdWxkIGxpa2UgdG8gc3BsaWNlIHZFdmVudCBpbnRvIHRoaXMgZWRnZS5cblx0XHQqXG5cdFx0KiBIb3dldmVyLCB3ZSBkb24ndCB3YW50IHRvIGNvbm5lY3QgdkV2ZW50IHRvIGp1c3QgYW55IHZlcnRleC4gIFdlIGRvbicndFxuXHRcdCogd2FudCB0aGUgbmV3IGVkZ2UgdG8gY3Jvc3MgYW55IG90aGVyIGVkZ2VzOyBvdGhlcndpc2Ugd2Ugd2lsbCBjcmVhdGVcblx0XHQqIGludGVyc2VjdGlvbiB2ZXJ0aWNlcyBldmVuIHdoZW4gdGhlIGlucHV0IGRhdGEgaGFkIG5vIHNlbGYtaW50ZXJzZWN0aW9ucy5cblx0XHQqIChUaGlzIGlzIGEgYmFkIHRoaW5nOyBpZiB0aGUgdXNlcidzIGlucHV0IGRhdGEgaGFzIG5vIGludGVyc2VjdGlvbnMsXG5cdFx0KiB3ZSBkb24ndCB3YW50IHRvIGdlbmVyYXRlIGFueSBmYWxzZSBpbnRlcnNlY3Rpb25zIG91cnNlbHZlcy4pXG5cdFx0KlxuXHRcdCogT3VyIGV2ZW50dWFsIGdvYWwgaXMgdG8gY29ubmVjdCB2RXZlbnQgdG8gdGhlIGxlZnRtb3N0IHVucHJvY2Vzc2VkXG5cdFx0KiB2ZXJ0ZXggb2YgdGhlIGNvbWJpbmVkIHJlZ2lvbiAodGhlIHVuaW9uIG9mIHJlZ1VwIGFuZCByZWdMbykuXG5cdFx0KiBCdXQgYmVjYXVzZSBvZiB1bnNlZW4gdmVydGljZXMgd2l0aCBhbGwgcmlnaHQtZ29pbmcgZWRnZXMsIGFuZCBhbHNvXG5cdFx0KiBuZXcgdmVydGljZXMgd2hpY2ggbWF5IGJlIGNyZWF0ZWQgYnkgZWRnZSBpbnRlcnNlY3Rpb25zLCB3ZSBkb24nJ3Rcblx0XHQqIGtub3cgd2hlcmUgdGhhdCBsZWZ0bW9zdCB1bnByb2Nlc3NlZCB2ZXJ0ZXggaXMuICBJbiB0aGUgbWVhbnRpbWUsIHdlXG5cdFx0KiBjb25uZWN0IHZFdmVudCB0byB0aGUgY2xvc2VzdCB2ZXJ0ZXggb2YgZWl0aGVyIGNoYWluLCBhbmQgbWFyayB0aGUgcmVnaW9uXG5cdFx0KiBhcyBcImZpeFVwcGVyRWRnZVwiLiAgVGhpcyBmbGFnIHNheXMgdG8gZGVsZXRlIGFuZCByZWNvbm5lY3QgdGhpcyBlZGdlXG5cdFx0KiB0byB0aGUgbmV4dCBwcm9jZXNzZWQgdmVydGV4IG9uIHRoZSBib3VuZGFyeSBvZiB0aGUgY29tYmluZWQgcmVnaW9uLlxuXHRcdCogUXVpdGUgcG9zc2libHkgdGhlIHZlcnRleCB3ZSBjb25uZWN0ZWQgdG8gd2lsbCB0dXJuIG91dCB0byBiZSB0aGVcblx0XHQqIGNsb3Nlc3Qgb25lLCBpbiB3aGljaCBjYXNlIHdlIHdvbicndCBuZWVkIHRvIG1ha2UgYW55IGNoYW5nZXMuXG5cdFx0Ki9cblx0XHR2YXIgZU5ldztcblx0XHR2YXIgZVRvcExlZnQgPSBlQm90dG9tTGVmdC5PbmV4dDtcblx0XHR2YXIgcmVnTG8gPSBTd2VlcC5yZWdpb25CZWxvdyhyZWdVcCk7XG5cdFx0dmFyIGVVcCA9IHJlZ1VwLmVVcDtcblx0XHR2YXIgZUxvID0gcmVnTG8uZVVwO1xuXHRcdHZhciBkZWdlbmVyYXRlID0gZmFsc2U7XG5cblx0XHRpZiggZVVwLkRzdCAhPT0gZUxvLkRzdCApIHtcblx0XHRcdFN3ZWVwLmNoZWNrRm9ySW50ZXJzZWN0KCB0ZXNzLCByZWdVcCApO1xuXHRcdH1cblxuXHRcdC8qIFBvc3NpYmxlIG5ldyBkZWdlbmVyYWNpZXM6IHVwcGVyIG9yIGxvd2VyIGVkZ2Ugb2YgcmVnVXAgbWF5IHBhc3Ncblx0XHQqIHRocm91Z2ggdkV2ZW50LCBvciBtYXkgY29pbmNpZGUgd2l0aCBuZXcgaW50ZXJzZWN0aW9uIHZlcnRleFxuXHRcdCovXG5cdFx0aWYoIEdlb20udmVydEVxKCBlVXAuT3JnLCB0ZXNzLmV2ZW50ICkpIHtcblx0XHRcdHRlc3MubWVzaC5zcGxpY2UoIGVUb3BMZWZ0Lk9wcmV2LCBlVXAgKTtcblx0XHRcdHJlZ1VwID0gU3dlZXAudG9wTGVmdFJlZ2lvbiggdGVzcywgcmVnVXAgKTtcblx0XHRcdGVUb3BMZWZ0ID0gU3dlZXAucmVnaW9uQmVsb3coIHJlZ1VwICkuZVVwO1xuXHRcdFx0U3dlZXAuZmluaXNoTGVmdFJlZ2lvbnMoIHRlc3MsIFN3ZWVwLnJlZ2lvbkJlbG93KHJlZ1VwKSwgcmVnTG8gKTtcblx0XHRcdGRlZ2VuZXJhdGUgPSB0cnVlO1xuXHRcdH1cblx0XHRpZiggR2VvbS52ZXJ0RXEoIGVMby5PcmcsIHRlc3MuZXZlbnQgKSkge1xuXHRcdFx0dGVzcy5tZXNoLnNwbGljZSggZUJvdHRvbUxlZnQsIGVMby5PcHJldiApO1xuXHRcdFx0ZUJvdHRvbUxlZnQgPSBTd2VlcC5maW5pc2hMZWZ0UmVnaW9ucyggdGVzcywgcmVnTG8sIG51bGwgKTtcblx0XHRcdGRlZ2VuZXJhdGUgPSB0cnVlO1xuXHRcdH1cblx0XHRpZiggZGVnZW5lcmF0ZSApIHtcblx0XHRcdFN3ZWVwLmFkZFJpZ2h0RWRnZXMoIHRlc3MsIHJlZ1VwLCBlQm90dG9tTGVmdC5PbmV4dCwgZVRvcExlZnQsIGVUb3BMZWZ0LCB0cnVlICk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0LyogTm9uLWRlZ2VuZXJhdGUgc2l0dWF0aW9uIC0tIG5lZWQgdG8gYWRkIGEgdGVtcG9yYXJ5LCBmaXhhYmxlIGVkZ2UuXG5cdFx0KiBDb25uZWN0IHRvIHRoZSBjbG9zZXIgb2YgZUxvLT5PcmcsIGVVcC0+T3JnLlxuXHRcdCovXG5cdFx0aWYoIEdlb20udmVydExlcSggZUxvLk9yZywgZVVwLk9yZyApKSB7XG5cdFx0XHRlTmV3ID0gZUxvLk9wcmV2O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRlTmV3ID0gZVVwO1xuXHRcdH1cblx0XHRlTmV3ID0gdGVzcy5tZXNoLmNvbm5lY3QoIGVCb3R0b21MZWZ0LkxwcmV2LCBlTmV3ICk7XG5cblx0XHQvKiBQcmV2ZW50IGNsZWFudXAsIG90aGVyd2lzZSBlTmV3IG1pZ2h0IGRpc2FwcGVhciBiZWZvcmUgd2UndmUgZXZlblxuXHRcdCogaGFkIGEgY2hhbmNlIHRvIG1hcmsgaXQgYXMgYSB0ZW1wb3JhcnkgZWRnZS5cblx0XHQqL1xuXHRcdFN3ZWVwLmFkZFJpZ2h0RWRnZXMoIHRlc3MsIHJlZ1VwLCBlTmV3LCBlTmV3Lk9uZXh0LCBlTmV3Lk9uZXh0LCBmYWxzZSApO1xuXHRcdGVOZXcuU3ltLmFjdGl2ZVJlZ2lvbi5maXhVcHBlckVkZ2UgPSB0cnVlO1xuXHRcdFN3ZWVwLndhbGtEaXJ0eVJlZ2lvbnMoIHRlc3MsIHJlZ1VwICk7XG5cdH1cblxuXHQvKiBCZWNhdXNlIHZlcnRpY2VzIGF0IGV4YWN0bHkgdGhlIHNhbWUgbG9jYXRpb24gYXJlIG1lcmdlZCB0b2dldGhlclxuXHQqIGJlZm9yZSB3ZSBwcm9jZXNzIHRoZSBzd2VlcCBldmVudCwgc29tZSBkZWdlbmVyYXRlIGNhc2VzIGNhbid0IG9jY3VyLlxuXHQqIEhvd2V2ZXIgaWYgc29tZW9uZSBldmVudHVhbGx5IG1ha2VzIHRoZSBtb2RpZmljYXRpb25zIHJlcXVpcmVkIHRvXG5cdCogbWVyZ2UgZmVhdHVyZXMgd2hpY2ggYXJlIGNsb3NlIHRvZ2V0aGVyLCB0aGUgY2FzZXMgYmVsb3cgbWFya2VkXG5cdCogVE9MRVJBTkNFX05PTlpFUk8gd2lsbCBiZSB1c2VmdWwuICBUaGV5IHdlcmUgZGVidWdnZWQgYmVmb3JlIHRoZVxuXHQqIGNvZGUgdG8gbWVyZ2UgaWRlbnRpY2FsIHZlcnRpY2VzIGluIHRoZSBtYWluIGxvb3Agd2FzIGFkZGVkLlxuXHQqL1xuXHQvLyNkZWZpbmUgVE9MRVJBTkNFX05PTlpFUk9cdEZBTFNFXG5cblx0Ly9zdGF0aWMgdm9pZCBDb25uZWN0TGVmdERlZ2VuZXJhdGUoIFRFU1N0ZXNzZWxhdG9yICp0ZXNzLCBBY3RpdmVSZWdpb24gKnJlZ1VwLCBURVNTdmVydGV4ICp2RXZlbnQgKVxuXHRTd2VlcC5jb25uZWN0TGVmdERlZ2VuZXJhdGUgPSBmdW5jdGlvbiggdGVzcywgcmVnVXAsIHZFdmVudCApIHtcblx0XHQvKlxuXHRcdCogVGhlIGV2ZW50IHZlcnRleCBsaWVzIGV4YWN0eSBvbiBhbiBhbHJlYWR5LXByb2Nlc3NlZCBlZGdlIG9yIHZlcnRleC5cblx0XHQqIEFkZGluZyB0aGUgbmV3IHZlcnRleCBpbnZvbHZlcyBzcGxpY2luZyBpdCBpbnRvIHRoZSBhbHJlYWR5LXByb2Nlc3NlZFxuXHRcdCogcGFydCBvZiB0aGUgbWVzaC5cblx0XHQqL1xuXHRcdHZhciBlLCBlVG9wTGVmdCwgZVRvcFJpZ2h0LCBlTGFzdDtcblx0XHR2YXIgcmVnO1xuXG5cdFx0ZSA9IHJlZ1VwLmVVcDtcblx0XHRpZiggR2VvbS52ZXJ0RXEoIGUuT3JnLCB2RXZlbnQgKSkge1xuXHRcdFx0LyogZS0+T3JnIGlzIGFuIHVucHJvY2Vzc2VkIHZlcnRleCAtIGp1c3QgY29tYmluZSB0aGVtLCBhbmQgd2FpdFxuXHRcdFx0KiBmb3IgZS0+T3JnIHRvIGJlIHB1bGxlZCBmcm9tIHRoZSBxdWV1ZVxuXHRcdFx0Ki9cblx0XHRcdGFzc2VydCggZmFsc2UgLypUT0xFUkFOQ0VfTk9OWkVSTyovICk7XG5cdFx0XHRTd2VlcC5zcGxpY2VNZXJnZVZlcnRpY2VzKCB0ZXNzLCBlLCB2RXZlbnQuYW5FZGdlICk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYoICEgR2VvbS52ZXJ0RXEoIGUuRHN0LCB2RXZlbnQgKSkge1xuXHRcdFx0LyogR2VuZXJhbCBjYXNlIC0tIHNwbGljZSB2RXZlbnQgaW50byBlZGdlIGUgd2hpY2ggcGFzc2VzIHRocm91Z2ggaXQgKi9cblx0XHRcdHRlc3MubWVzaC5zcGxpdEVkZ2UoIGUuU3ltICk7XG5cdFx0XHRpZiggcmVnVXAuZml4VXBwZXJFZGdlICkge1xuXHRcdFx0XHQvKiBUaGlzIGVkZ2Ugd2FzIGZpeGFibGUgLS0gZGVsZXRlIHVudXNlZCBwb3J0aW9uIG9mIG9yaWdpbmFsIGVkZ2UgKi9cblx0XHRcdFx0dGVzcy5tZXNoLmRlbGV0ZSggZS5PbmV4dCApO1xuXHRcdFx0XHRyZWdVcC5maXhVcHBlckVkZ2UgPSBmYWxzZTtcblx0XHRcdH1cblx0XHRcdHRlc3MubWVzaC5zcGxpY2UoIHZFdmVudC5hbkVkZ2UsIGUgKTtcblx0XHRcdFN3ZWVwLnN3ZWVwRXZlbnQoIHRlc3MsIHZFdmVudCApO1x0LyogcmVjdXJzZSAqL1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8qIHZFdmVudCBjb2luY2lkZXMgd2l0aCBlLT5Ec3QsIHdoaWNoIGhhcyBhbHJlYWR5IGJlZW4gcHJvY2Vzc2VkLlxuXHRcdCogU3BsaWNlIGluIHRoZSBhZGRpdGlvbmFsIHJpZ2h0LWdvaW5nIGVkZ2VzLlxuXHRcdCovXG5cdFx0YXNzZXJ0KCBmYWxzZSAvKlRPTEVSQU5DRV9OT05aRVJPKi8gKTtcblx0XHRyZWdVcCA9IFN3ZWVwLnRvcFJpZ2h0UmVnaW9uKCByZWdVcCApO1xuXHRcdHJlZyA9IFN3ZWVwLnJlZ2lvbkJlbG93KCByZWdVcCApO1xuXHRcdGVUb3BSaWdodCA9IHJlZy5lVXAuU3ltO1xuXHRcdGVUb3BMZWZ0ID0gZUxhc3QgPSBlVG9wUmlnaHQuT25leHQ7XG5cdFx0aWYoIHJlZy5maXhVcHBlckVkZ2UgKSB7XG5cdFx0XHQvKiBIZXJlIGUtPkRzdCBoYXMgb25seSBhIHNpbmdsZSBmaXhhYmxlIGVkZ2UgZ29pbmcgcmlnaHQuXG5cdFx0XHQqIFdlIGNhbiBkZWxldGUgaXQgc2luY2Ugbm93IHdlIGhhdmUgc29tZSByZWFsIHJpZ2h0LWdvaW5nIGVkZ2VzLlxuXHRcdFx0Ki9cblx0XHRcdGFzc2VydCggZVRvcExlZnQgIT09IGVUb3BSaWdodCApOyAgIC8qIHRoZXJlIGFyZSBzb21lIGxlZnQgZWRnZXMgdG9vICovXG5cdFx0XHRTd2VlcC5kZWxldGVSZWdpb24oIHRlc3MsIHJlZyApO1xuXHRcdFx0dGVzcy5tZXNoLmRlbGV0ZSggZVRvcFJpZ2h0ICk7XG5cdFx0XHRlVG9wUmlnaHQgPSBlVG9wTGVmdC5PcHJldjtcblx0XHR9XG5cdFx0dGVzcy5tZXNoLnNwbGljZSggdkV2ZW50LmFuRWRnZSwgZVRvcFJpZ2h0ICk7XG5cdFx0aWYoICEgR2VvbS5lZGdlR29lc0xlZnQoIGVUb3BMZWZ0ICkpIHtcblx0XHRcdC8qIGUtPkRzdCBoYWQgbm8gbGVmdC1nb2luZyBlZGdlcyAtLSBpbmRpY2F0ZSB0aGlzIHRvIEFkZFJpZ2h0RWRnZXMoKSAqL1xuXHRcdFx0ZVRvcExlZnQgPSBudWxsO1xuXHRcdH1cblx0XHRTd2VlcC5hZGRSaWdodEVkZ2VzKCB0ZXNzLCByZWdVcCwgZVRvcFJpZ2h0Lk9uZXh0LCBlTGFzdCwgZVRvcExlZnQsIHRydWUgKTtcblx0fVxuXG5cblx0Ly9zdGF0aWMgdm9pZCBDb25uZWN0TGVmdFZlcnRleCggVEVTU3Rlc3NlbGF0b3IgKnRlc3MsIFRFU1N2ZXJ0ZXggKnZFdmVudCApXG5cdFN3ZWVwLmNvbm5lY3RMZWZ0VmVydGV4ID0gZnVuY3Rpb24oIHRlc3MsIHZFdmVudCApIHtcblx0XHQvKlxuXHRcdCogUHVycG9zZTogY29ubmVjdCBhIFwibGVmdFwiIHZlcnRleCAob25lIHdoZXJlIGJvdGggZWRnZXMgZ28gcmlnaHQpXG5cdFx0KiB0byB0aGUgcHJvY2Vzc2VkIHBvcnRpb24gb2YgdGhlIG1lc2guICBMZXQgUiBiZSB0aGUgYWN0aXZlIHJlZ2lvblxuXHRcdCogY29udGFpbmluZyB2RXZlbnQsIGFuZCBsZXQgVSBhbmQgTCBiZSB0aGUgdXBwZXIgYW5kIGxvd2VyIGVkZ2Vcblx0XHQqIGNoYWlucyBvZiBSLiAgVGhlcmUgYXJlIHR3byBwb3NzaWJpbGl0aWVzOlxuXHRcdCpcblx0XHQqIC0gdGhlIG5vcm1hbCBjYXNlOiBzcGxpdCBSIGludG8gdHdvIHJlZ2lvbnMsIGJ5IGNvbm5lY3RpbmcgdkV2ZW50IHRvXG5cdFx0KiAgIHRoZSByaWdodG1vc3QgdmVydGV4IG9mIFUgb3IgTCBseWluZyB0byB0aGUgbGVmdCBvZiB0aGUgc3dlZXAgbGluZVxuXHRcdCpcblx0XHQqIC0gdGhlIGRlZ2VuZXJhdGUgY2FzZTogaWYgdkV2ZW50IGlzIGNsb3NlIGVub3VnaCB0byBVIG9yIEwsIHdlXG5cdFx0KiAgIG1lcmdlIHZFdmVudCBpbnRvIHRoYXQgZWRnZSBjaGFpbi4gIFRoZSBzdWJjYXNlcyBhcmU6XG5cdFx0Klx0LSBtZXJnaW5nIHdpdGggdGhlIHJpZ2h0bW9zdCB2ZXJ0ZXggb2YgVSBvciBMXG5cdFx0Klx0LSBtZXJnaW5nIHdpdGggdGhlIGFjdGl2ZSBlZGdlIG9mIFUgb3IgTFxuXHRcdCpcdC0gbWVyZ2luZyB3aXRoIGFuIGFscmVhZHktcHJvY2Vzc2VkIHBvcnRpb24gb2YgVSBvciBMXG5cdFx0Ki9cblx0XHR2YXIgcmVnVXAsIHJlZ0xvLCByZWc7XG5cdFx0dmFyIGVVcCwgZUxvLCBlTmV3O1xuXHRcdHZhciB0bXAgPSBuZXcgQWN0aXZlUmVnaW9uKCk7XG5cblx0XHQvKiBhc3NlcnQoIHZFdmVudC0+YW5FZGdlLT5PbmV4dC0+T25leHQgPT0gdkV2ZW50LT5hbkVkZ2UgKTsgKi9cblxuXHRcdC8qIEdldCBhIHBvaW50ZXIgdG8gdGhlIGFjdGl2ZSByZWdpb24gY29udGFpbmluZyB2RXZlbnQgKi9cblx0XHR0bXAuZVVwID0gdkV2ZW50LmFuRWRnZS5TeW07XG5cdFx0LyogX19HTF9ESUNUTElTVEtFWSAqLyAvKiB0ZXNzRGljdExpc3RTZWFyY2ggKi9cblx0XHRyZWdVcCA9IHRlc3MuZGljdC5zZWFyY2goIHRtcCApLmtleTtcblx0XHRyZWdMbyA9IFN3ZWVwLnJlZ2lvbkJlbG93KCByZWdVcCApO1xuXHRcdGlmKCAhcmVnTG8gKSB7XG5cdFx0XHQvLyBUaGlzIG1heSBoYXBwZW4gaWYgdGhlIGlucHV0IHBvbHlnb24gaXMgY29wbGFuYXIuXG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGVVcCA9IHJlZ1VwLmVVcDtcblx0XHRlTG8gPSByZWdMby5lVXA7XG5cblx0XHQvKiBUcnkgbWVyZ2luZyB3aXRoIFUgb3IgTCBmaXJzdCAqL1xuXHRcdGlmKCBHZW9tLmVkZ2VTaWduKCBlVXAuRHN0LCB2RXZlbnQsIGVVcC5PcmcgKSA9PT0gMC4wICkge1xuXHRcdFx0U3dlZXAuY29ubmVjdExlZnREZWdlbmVyYXRlKCB0ZXNzLCByZWdVcCwgdkV2ZW50ICk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0LyogQ29ubmVjdCB2RXZlbnQgdG8gcmlnaHRtb3N0IHByb2Nlc3NlZCB2ZXJ0ZXggb2YgZWl0aGVyIGNoYWluLlxuXHRcdCogZS0+RHN0IGlzIHRoZSB2ZXJ0ZXggdGhhdCB3ZSB3aWxsIGNvbm5lY3QgdG8gdkV2ZW50LlxuXHRcdCovXG5cdFx0cmVnID0gR2VvbS52ZXJ0TGVxKCBlTG8uRHN0LCBlVXAuRHN0ICkgPyByZWdVcCA6IHJlZ0xvO1xuXG5cdFx0aWYoIHJlZ1VwLmluc2lkZSB8fCByZWcuZml4VXBwZXJFZGdlKSB7XG5cdFx0XHRpZiggcmVnID09PSByZWdVcCApIHtcblx0XHRcdFx0ZU5ldyA9IHRlc3MubWVzaC5jb25uZWN0KCB2RXZlbnQuYW5FZGdlLlN5bSwgZVVwLkxuZXh0ICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgdGVtcEhhbGZFZGdlID0gdGVzcy5tZXNoLmNvbm5lY3QoIGVMby5EbmV4dCwgdkV2ZW50LmFuRWRnZSk7XG5cdFx0XHRcdGVOZXcgPSB0ZW1wSGFsZkVkZ2UuU3ltO1xuXHRcdFx0fVxuXHRcdFx0aWYoIHJlZy5maXhVcHBlckVkZ2UgKSB7XG5cdFx0XHRcdFN3ZWVwLmZpeFVwcGVyRWRnZSggdGVzcywgcmVnLCBlTmV3ICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRTd2VlcC5jb21wdXRlV2luZGluZyggdGVzcywgU3dlZXAuYWRkUmVnaW9uQmVsb3coIHRlc3MsIHJlZ1VwLCBlTmV3ICkpO1xuXHRcdFx0fVxuXHRcdFx0U3dlZXAuc3dlZXBFdmVudCggdGVzcywgdkV2ZW50ICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8qIFRoZSBuZXcgdmVydGV4IGlzIGluIGEgcmVnaW9uIHdoaWNoIGRvZXMgbm90IGJlbG9uZyB0byB0aGUgcG9seWdvbi5cblx0XHRcdCogV2UgZG9uJyd0IG5lZWQgdG8gY29ubmVjdCB0aGlzIHZlcnRleCB0byB0aGUgcmVzdCBvZiB0aGUgbWVzaC5cblx0XHRcdCovXG5cdFx0XHRTd2VlcC5hZGRSaWdodEVkZ2VzKCB0ZXNzLCByZWdVcCwgdkV2ZW50LmFuRWRnZSwgdkV2ZW50LmFuRWRnZSwgbnVsbCwgdHJ1ZSApO1xuXHRcdH1cblx0fTtcblxuXG5cdC8vc3RhdGljIHZvaWQgU3dlZXBFdmVudCggVEVTU3Rlc3NlbGF0b3IgKnRlc3MsIFRFU1N2ZXJ0ZXggKnZFdmVudCApXG5cdFN3ZWVwLnN3ZWVwRXZlbnQgPSBmdW5jdGlvbiggdGVzcywgdkV2ZW50ICkge1xuXHRcdC8qXG5cdFx0KiBEb2VzIGV2ZXJ5dGhpbmcgbmVjZXNzYXJ5IHdoZW4gdGhlIHN3ZWVwIGxpbmUgY3Jvc3NlcyBhIHZlcnRleC5cblx0XHQqIFVwZGF0ZXMgdGhlIG1lc2ggYW5kIHRoZSBlZGdlIGRpY3Rpb25hcnkuXG5cdFx0Ki9cblxuXHRcdHRlc3MuZXZlbnQgPSB2RXZlbnQ7XHRcdC8qIGZvciBhY2Nlc3MgaW4gRWRnZUxlcSgpICovXG5cdFx0U3dlZXAuZGVidWdFdmVudCggdGVzcyApO1xuXG5cdFx0LyogQ2hlY2sgaWYgdGhpcyB2ZXJ0ZXggaXMgdGhlIHJpZ2h0IGVuZHBvaW50IG9mIGFuIGVkZ2UgdGhhdCBpc1xuXHRcdCogYWxyZWFkeSBpbiB0aGUgZGljdGlvbmFyeS4gIEluIHRoaXMgY2FzZSB3ZSBkb24ndCBuZWVkIHRvIHdhc3RlXG5cdFx0KiB0aW1lIHNlYXJjaGluZyBmb3IgdGhlIGxvY2F0aW9uIHRvIGluc2VydCBuZXcgZWRnZXMuXG5cdFx0Ki9cblx0XHR2YXIgZSA9IHZFdmVudC5hbkVkZ2U7XG5cdFx0d2hpbGUoIGUuYWN0aXZlUmVnaW9uID09PSBudWxsICkge1xuXHRcdFx0ZSA9IGUuT25leHQ7XG5cdFx0XHRpZiggZSA9PSB2RXZlbnQuYW5FZGdlICkge1xuXHRcdFx0XHQvKiBBbGwgZWRnZXMgZ28gcmlnaHQgLS0gbm90IGluY2lkZW50IHRvIGFueSBwcm9jZXNzZWQgZWRnZXMgKi9cblx0XHRcdFx0U3dlZXAuY29ubmVjdExlZnRWZXJ0ZXgoIHRlc3MsIHZFdmVudCApO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LyogUHJvY2Vzc2luZyBjb25zaXN0cyBvZiB0d28gcGhhc2VzOiBmaXJzdCB3ZSBcImZpbmlzaFwiIGFsbCB0aGVcblx0XHQqIGFjdGl2ZSByZWdpb25zIHdoZXJlIGJvdGggdGhlIHVwcGVyIGFuZCBsb3dlciBlZGdlcyB0ZXJtaW5hdGVcblx0XHQqIGF0IHZFdmVudCAoaWUuIHZFdmVudCBpcyBjbG9zaW5nIG9mZiB0aGVzZSByZWdpb25zKS5cblx0XHQqIFdlIG1hcmsgdGhlc2UgZmFjZXMgXCJpbnNpZGVcIiBvciBcIm91dHNpZGVcIiB0aGUgcG9seWdvbiBhY2NvcmRpbmdcblx0XHQqIHRvIHRoZWlyIHdpbmRpbmcgbnVtYmVyLCBhbmQgZGVsZXRlIHRoZSBlZGdlcyBmcm9tIHRoZSBkaWN0aW9uYXJ5LlxuXHRcdCogVGhpcyB0YWtlcyBjYXJlIG9mIGFsbCB0aGUgbGVmdC1nb2luZyBlZGdlcyBmcm9tIHZFdmVudC5cblx0XHQqL1xuXHRcdHZhciByZWdVcCA9IFN3ZWVwLnRvcExlZnRSZWdpb24oIHRlc3MsIGUuYWN0aXZlUmVnaW9uICk7XG5cdFx0YXNzZXJ0KCByZWdVcCAhPT0gbnVsbCApO1xuXHQvL1x0aWYgKHJlZ1VwID09IE5VTEwpIGxvbmdqbXAodGVzcy0+ZW52LDEpO1xuXHRcdHZhciByZWcgPSBTd2VlcC5yZWdpb25CZWxvdyggcmVnVXAgKTtcblx0XHR2YXIgZVRvcExlZnQgPSByZWcuZVVwO1xuXHRcdHZhciBlQm90dG9tTGVmdCA9IFN3ZWVwLmZpbmlzaExlZnRSZWdpb25zKCB0ZXNzLCByZWcsIG51bGwgKTtcblxuXHRcdC8qIE5leHQgd2UgcHJvY2VzcyBhbGwgdGhlIHJpZ2h0LWdvaW5nIGVkZ2VzIGZyb20gdkV2ZW50LiAgVGhpc1xuXHRcdCogaW52b2x2ZXMgYWRkaW5nIHRoZSBlZGdlcyB0byB0aGUgZGljdGlvbmFyeSwgYW5kIGNyZWF0aW5nIHRoZVxuXHRcdCogYXNzb2NpYXRlZCBcImFjdGl2ZSByZWdpb25zXCIgd2hpY2ggcmVjb3JkIGluZm9ybWF0aW9uIGFib3V0IHRoZVxuXHRcdCogcmVnaW9ucyBiZXR3ZWVuIGFkamFjZW50IGRpY3Rpb25hcnkgZWRnZXMuXG5cdFx0Ki9cblx0XHRpZiggZUJvdHRvbUxlZnQuT25leHQgPT09IGVUb3BMZWZ0ICkge1xuXHRcdFx0LyogTm8gcmlnaHQtZ29pbmcgZWRnZXMgLS0gYWRkIGEgdGVtcG9yYXJ5IFwiZml4YWJsZVwiIGVkZ2UgKi9cblx0XHRcdFN3ZWVwLmNvbm5lY3RSaWdodFZlcnRleCggdGVzcywgcmVnVXAsIGVCb3R0b21MZWZ0ICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdFN3ZWVwLmFkZFJpZ2h0RWRnZXMoIHRlc3MsIHJlZ1VwLCBlQm90dG9tTGVmdC5PbmV4dCwgZVRvcExlZnQsIGVUb3BMZWZ0LCB0cnVlICk7XG5cdFx0fVxuXHR9O1xuXG5cblx0LyogTWFrZSB0aGUgc2VudGluZWwgY29vcmRpbmF0ZXMgYmlnIGVub3VnaCB0aGF0IHRoZXkgd2lsbCBuZXZlciBiZVxuXHQqIG1lcmdlZCB3aXRoIHJlYWwgaW5wdXQgZmVhdHVyZXMuXG5cdCovXG5cblx0Ly9zdGF0aWMgdm9pZCBBZGRTZW50aW5lbCggVEVTU3Rlc3NlbGF0b3IgKnRlc3MsIFRFU1NyZWFsIHNtaW4sIFRFU1NyZWFsIHNtYXgsIFRFU1NyZWFsIHQgKVxuXHRTd2VlcC5hZGRTZW50aW5lbCA9IGZ1bmN0aW9uKCB0ZXNzLCBzbWluLCBzbWF4LCB0ICkge1xuXHRcdC8qXG5cdFx0KiBXZSBhZGQgdHdvIHNlbnRpbmVsIGVkZ2VzIGFib3ZlIGFuZCBiZWxvdyBhbGwgb3RoZXIgZWRnZXMsXG5cdFx0KiB0byBhdm9pZCBzcGVjaWFsIGNhc2VzIGF0IHRoZSB0b3AgYW5kIGJvdHRvbS5cblx0XHQqL1xuXHRcdHZhciByZWcgPSBuZXcgQWN0aXZlUmVnaW9uKCk7XG5cdFx0dmFyIGUgPSB0ZXNzLm1lc2gubWFrZUVkZ2UoKTtcblx0Ly9cdGlmIChlID09IE5VTEwpIGxvbmdqbXAodGVzcy0+ZW52LDEpO1xuXG5cdFx0ZS5PcmcucyA9IHNtYXg7XG5cdFx0ZS5PcmcudCA9IHQ7XG5cdFx0ZS5Ec3QucyA9IHNtaW47XG5cdFx0ZS5Ec3QudCA9IHQ7XG5cdFx0dGVzcy5ldmVudCA9IGUuRHN0O1x0XHQvKiBpbml0aWFsaXplIGl0ICovXG5cblx0XHRyZWcuZVVwID0gZTtcblx0XHRyZWcud2luZGluZ051bWJlciA9IDA7XG5cdFx0cmVnLmluc2lkZSA9IGZhbHNlO1xuXHRcdHJlZy5maXhVcHBlckVkZ2UgPSBmYWxzZTtcblx0XHRyZWcuc2VudGluZWwgPSB0cnVlO1xuXHRcdHJlZy5kaXJ0eSA9IGZhbHNlO1xuXHRcdHJlZy5ub2RlVXAgPSB0ZXNzLmRpY3QuaW5zZXJ0KCByZWcgKTtcblx0Ly9cdGlmIChyZWctPm5vZGVVcCA9PSBOVUxMKSBsb25nam1wKHRlc3MtPmVudiwxKTtcblx0fVxuXG5cblx0Ly9zdGF0aWMgdm9pZCBJbml0RWRnZURpY3QoIFRFU1N0ZXNzZWxhdG9yICp0ZXNzIClcblx0U3dlZXAuaW5pdEVkZ2VEaWN0ID0gZnVuY3Rpb24oIHRlc3MgKSB7XG5cdFx0Lypcblx0XHQqIFdlIG1haW50YWluIGFuIG9yZGVyaW5nIG9mIGVkZ2UgaW50ZXJzZWN0aW9ucyB3aXRoIHRoZSBzd2VlcCBsaW5lLlxuXHRcdCogVGhpcyBvcmRlciBpcyBtYWludGFpbmVkIGluIGEgZHluYW1pYyBkaWN0aW9uYXJ5LlxuXHRcdCovXG5cdFx0dGVzcy5kaWN0ID0gbmV3IERpY3QoIHRlc3MsIFN3ZWVwLmVkZ2VMZXEgKTtcblx0Ly9cdGlmICh0ZXNzLT5kaWN0ID09IE5VTEwpIGxvbmdqbXAodGVzcy0+ZW52LDEpO1xuXG5cdFx0dmFyIHcgPSAodGVzcy5ibWF4WzBdIC0gdGVzcy5ibWluWzBdKTtcblx0XHR2YXIgaCA9ICh0ZXNzLmJtYXhbMV0gLSB0ZXNzLmJtaW5bMV0pO1xuXG5cdFx0dmFyIHNtaW4gPSB0ZXNzLmJtaW5bMF0gLSB3O1xuXHRcdHZhciBzbWF4ID0gdGVzcy5ibWF4WzBdICsgdztcblx0XHR2YXIgdG1pbiA9IHRlc3MuYm1pblsxXSAtIGg7XG5cdFx0dmFyIHRtYXggPSB0ZXNzLmJtYXhbMV0gKyBoO1xuXG5cdFx0U3dlZXAuYWRkU2VudGluZWwoIHRlc3MsIHNtaW4sIHNtYXgsIHRtaW4gKTtcblx0XHRTd2VlcC5hZGRTZW50aW5lbCggdGVzcywgc21pbiwgc21heCwgdG1heCApO1xuXHR9XG5cblxuXHRTd2VlcC5kb25lRWRnZURpY3QgPSBmdW5jdGlvbiggdGVzcyApXG5cdHtcblx0XHR2YXIgcmVnO1xuXHRcdHZhciBmaXhlZEVkZ2VzID0gMDtcblxuXHRcdHdoaWxlKCAocmVnID0gdGVzcy5kaWN0Lm1pbigpLmtleSkgIT09IG51bGwgKSB7XG5cdFx0XHQvKlxuXHRcdFx0KiBBdCB0aGUgZW5kIG9mIGFsbCBwcm9jZXNzaW5nLCB0aGUgZGljdGlvbmFyeSBzaG91bGQgY29udGFpblxuXHRcdFx0KiBvbmx5IHRoZSB0d28gc2VudGluZWwgZWRnZXMsIHBsdXMgYXQgbW9zdCBvbmUgXCJmaXhhYmxlXCIgZWRnZVxuXHRcdFx0KiBjcmVhdGVkIGJ5IENvbm5lY3RSaWdodFZlcnRleCgpLlxuXHRcdFx0Ki9cblx0XHRcdGlmKCAhIHJlZy5zZW50aW5lbCApIHtcblx0XHRcdFx0YXNzZXJ0KCByZWcuZml4VXBwZXJFZGdlICk7XG5cdFx0XHRcdGFzc2VydCggKytmaXhlZEVkZ2VzID09IDEgKTtcblx0XHRcdH1cblx0XHRcdGFzc2VydCggcmVnLndpbmRpbmdOdW1iZXIgPT0gMCApO1xuXHRcdFx0U3dlZXAuZGVsZXRlUmVnaW9uKCB0ZXNzLCByZWcgKTtcblx0XHRcdC8qICAgIHRlc3NNZXNoRGVsZXRlKCByZWctPmVVcCApOyovXG5cdFx0fVxuXHQvL1x0ZGljdERlbGV0ZURpY3QoICZ0ZXNzLT5hbGxvYywgdGVzcy0+ZGljdCApO1xuXHR9XG5cblxuXHRTd2VlcC5yZW1vdmVEZWdlbmVyYXRlRWRnZXMgPSBmdW5jdGlvbiggdGVzcyApIHtcblx0XHQvKlxuXHRcdCogUmVtb3ZlIHplcm8tbGVuZ3RoIGVkZ2VzLCBhbmQgY29udG91cnMgd2l0aCBmZXdlciB0aGFuIDMgdmVydGljZXMuXG5cdFx0Ki9cblx0XHR2YXIgZSwgZU5leHQsIGVMbmV4dDtcblx0XHR2YXIgZUhlYWQgPSB0ZXNzLm1lc2guZUhlYWQ7XG5cblx0XHQvKkxJTlRFRCovXG5cdFx0Zm9yKCBlID0gZUhlYWQubmV4dDsgZSAhPT0gZUhlYWQ7IGUgPSBlTmV4dCApIHtcblx0XHRcdGVOZXh0ID0gZS5uZXh0O1xuXHRcdFx0ZUxuZXh0ID0gZS5MbmV4dDtcblxuXHRcdFx0aWYoIEdlb20udmVydEVxKCBlLk9yZywgZS5Ec3QgKSAmJiBlLkxuZXh0LkxuZXh0ICE9PSBlICkge1xuXHRcdFx0XHQvKiBaZXJvLWxlbmd0aCBlZGdlLCBjb250b3VyIGhhcyBhdCBsZWFzdCAzIGVkZ2VzICovXG5cdFx0XHRcdFN3ZWVwLnNwbGljZU1lcmdlVmVydGljZXMoIHRlc3MsIGVMbmV4dCwgZSApO1x0LyogZGVsZXRlcyBlLT5PcmcgKi9cblx0XHRcdFx0dGVzcy5tZXNoLmRlbGV0ZSggZSApOyAvKiBlIGlzIGEgc2VsZi1sb29wICovXG5cdFx0XHRcdGUgPSBlTG5leHQ7XG5cdFx0XHRcdGVMbmV4dCA9IGUuTG5leHQ7XG5cdFx0XHR9XG5cdFx0XHRpZiggZUxuZXh0LkxuZXh0ID09PSBlICkge1xuXHRcdFx0XHQvKiBEZWdlbmVyYXRlIGNvbnRvdXIgKG9uZSBvciB0d28gZWRnZXMpICovXG5cdFx0XHRcdGlmKCBlTG5leHQgIT09IGUgKSB7XG5cdFx0XHRcdFx0aWYoIGVMbmV4dCA9PT0gZU5leHQgfHwgZUxuZXh0ID09PSBlTmV4dC5TeW0gKSB7IGVOZXh0ID0gZU5leHQubmV4dDsgfVxuXHRcdFx0XHRcdHRlc3MubWVzaC5kZWxldGUoIGVMbmV4dCApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKCBlID09PSBlTmV4dCB8fCBlID09PSBlTmV4dC5TeW0gKSB7IGVOZXh0ID0gZU5leHQubmV4dDsgfVxuXHRcdFx0XHR0ZXNzLm1lc2guZGVsZXRlKCBlICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0U3dlZXAuaW5pdFByaW9yaXR5USA9IGZ1bmN0aW9uKCB0ZXNzICkge1xuXHRcdC8qXG5cdFx0KiBJbnNlcnQgYWxsIHZlcnRpY2VzIGludG8gdGhlIHByaW9yaXR5IHF1ZXVlIHdoaWNoIGRldGVybWluZXMgdGhlXG5cdFx0KiBvcmRlciBpbiB3aGljaCB2ZXJ0aWNlcyBjcm9zcyB0aGUgc3dlZXAgbGluZS5cblx0XHQqL1xuXHRcdHZhciBwcTtcblx0XHR2YXIgdiwgdkhlYWQ7XG5cdFx0dmFyIHZlcnRleENvdW50ID0gMDtcblx0XHRcblx0XHR2SGVhZCA9IHRlc3MubWVzaC52SGVhZDtcblx0XHRmb3IoIHYgPSB2SGVhZC5uZXh0OyB2ICE9PSB2SGVhZDsgdiA9IHYubmV4dCApIHtcblx0XHRcdHZlcnRleENvdW50Kys7XG5cdFx0fVxuXHRcdC8qIE1ha2Ugc3VyZSB0aGVyZSBpcyBlbm91Z2ggc3BhY2UgZm9yIHNlbnRpbmVscy4gKi9cblx0XHR2ZXJ0ZXhDb3VudCArPSA4OyAvL01BWCggOCwgdGVzcy0+YWxsb2MuZXh0cmFWZXJ0aWNlcyApO1xuXHRcdFxuXHRcdHBxID0gdGVzcy5wcSA9IG5ldyBQcmlvcml0eVEoIHZlcnRleENvdW50LCBHZW9tLnZlcnRMZXEgKTtcblx0Ly9cdGlmIChwcSA9PSBOVUxMKSByZXR1cm4gMDtcblxuXHRcdHZIZWFkID0gdGVzcy5tZXNoLnZIZWFkO1xuXHRcdGZvciggdiA9IHZIZWFkLm5leHQ7IHYgIT09IHZIZWFkOyB2ID0gdi5uZXh0ICkge1xuXHRcdFx0di5wcUhhbmRsZSA9IHBxLmluc2VydCggdiApO1xuXHQvL1x0XHRpZiAodi5wcUhhbmRsZSA9PSBJTlZfSEFORExFKVxuXHQvL1x0XHRcdGJyZWFrO1xuXHRcdH1cblxuXHRcdGlmICh2ICE9PSB2SGVhZCkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHBxLmluaXQoKTtcblxuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblxuXHRTd2VlcC5kb25lUHJpb3JpdHlRID0gZnVuY3Rpb24oIHRlc3MgKSB7XG5cdFx0dGVzcy5wcSA9IG51bGw7XG5cdH1cblxuXG5cdFN3ZWVwLnJlbW92ZURlZ2VuZXJhdGVGYWNlcyA9IGZ1bmN0aW9uKCB0ZXNzLCBtZXNoICkge1xuXHRcdC8qXG5cdFx0KiBEZWxldGUgYW55IGRlZ2VuZXJhdGUgZmFjZXMgd2l0aCBvbmx5IHR3byBlZGdlcy4gIFdhbGtEaXJ0eVJlZ2lvbnMoKVxuXHRcdCogd2lsbCBjYXRjaCBhbG1vc3QgYWxsIG9mIHRoZXNlLCBidXQgaXQgd29uJ3QgY2F0Y2ggZGVnZW5lcmF0ZSBmYWNlc1xuXHRcdCogcHJvZHVjZWQgYnkgc3BsaWNlIG9wZXJhdGlvbnMgb24gYWxyZWFkeS1wcm9jZXNzZWQgZWRnZXMuXG5cdFx0KiBUaGUgdHdvIHBsYWNlcyB0aGlzIGNhbiBoYXBwZW4gYXJlIGluIEZpbmlzaExlZnRSZWdpb25zKCksIHdoZW5cblx0XHQqIHdlIHNwbGljZSBpbiBhIFwidGVtcG9yYXJ5XCIgZWRnZSBwcm9kdWNlZCBieSBDb25uZWN0UmlnaHRWZXJ0ZXgoKSxcblx0XHQqIGFuZCBpbiBDaGVja0ZvckxlZnRTcGxpY2UoKSwgd2hlcmUgd2Ugc3BsaWNlIGFscmVhZHktcHJvY2Vzc2VkXG5cdFx0KiBlZGdlcyB0byBlbnN1cmUgdGhhdCBvdXIgZGljdGlvbmFyeSBpbnZhcmlhbnRzIGFyZSBub3QgdmlvbGF0ZWRcblx0XHQqIGJ5IG51bWVyaWNhbCBlcnJvcnMuXG5cdFx0KlxuXHRcdCogSW4gYm90aCB0aGVzZSBjYXNlcyBpdCBpcyAqdmVyeSogZGFuZ2Vyb3VzIHRvIGRlbGV0ZSB0aGUgb2ZmZW5kaW5nXG5cdFx0KiBlZGdlIGF0IHRoZSB0aW1lLCBzaW5jZSBvbmUgb2YgdGhlIHJvdXRpbmVzIGZ1cnRoZXIgdXAgdGhlIHN0YWNrXG5cdFx0KiB3aWxsIHNvbWV0aW1lcyBiZSBrZWVwaW5nIGEgcG9pbnRlciB0byB0aGF0IGVkZ2UuXG5cdFx0Ki9cblx0XHR2YXIgZiwgZk5leHQ7XG5cdFx0dmFyIGU7XG5cblx0XHQvKkxJTlRFRCovXG5cdFx0Zm9yKCBmID0gbWVzaC5mSGVhZC5uZXh0OyBmICE9PSBtZXNoLmZIZWFkOyBmID0gZk5leHQgKSB7XG5cdFx0XHRmTmV4dCA9IGYubmV4dDtcblx0XHRcdGUgPSBmLmFuRWRnZTtcblx0XHRcdGFzc2VydCggZS5MbmV4dCAhPT0gZSApO1xuXG5cdFx0XHRpZiggZS5MbmV4dC5MbmV4dCA9PT0gZSApIHtcblx0XHRcdFx0LyogQSBmYWNlIHdpdGggb25seSB0d28gZWRnZXMgKi9cblx0XHRcdFx0U3dlZXAuYWRkV2luZGluZyggZS5PbmV4dCwgZSApO1xuXHRcdFx0XHR0ZXNzLm1lc2guZGVsZXRlKCBlICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0U3dlZXAuY29tcHV0ZUludGVyaW9yID0gZnVuY3Rpb24oIHRlc3MgKSB7XG5cdFx0Lypcblx0XHQqIHRlc3NDb21wdXRlSW50ZXJpb3IoIHRlc3MgKSBjb21wdXRlcyB0aGUgcGxhbmFyIGFycmFuZ2VtZW50IHNwZWNpZmllZFxuXHRcdCogYnkgdGhlIGdpdmVuIGNvbnRvdXJzLCBhbmQgZnVydGhlciBzdWJkaXZpZGVzIHRoaXMgYXJyYW5nZW1lbnRcblx0XHQqIGludG8gcmVnaW9ucy4gIEVhY2ggcmVnaW9uIGlzIG1hcmtlZCBcImluc2lkZVwiIGlmIGl0IGJlbG9uZ3Ncblx0XHQqIHRvIHRoZSBwb2x5Z29uLCBhY2NvcmRpbmcgdG8gdGhlIHJ1bGUgZ2l2ZW4gYnkgdGVzcy0+d2luZGluZ1J1bGUuXG5cdFx0KiBFYWNoIGludGVyaW9yIHJlZ2lvbiBpcyBndWFyYW50ZWVkIGJlIG1vbm90b25lLlxuXHRcdCovXG5cdFx0dmFyIHYsIHZOZXh0O1xuXG5cdFx0LyogRWFjaCB2ZXJ0ZXggZGVmaW5lcyBhbiBldmVudCBmb3Igb3VyIHN3ZWVwIGxpbmUuICBTdGFydCBieSBpbnNlcnRpbmdcblx0XHQqIGFsbCB0aGUgdmVydGljZXMgaW4gYSBwcmlvcml0eSBxdWV1ZS4gIEV2ZW50cyBhcmUgcHJvY2Vzc2VkIGluXG5cdFx0KiBsZXhpY29ncmFwaGljIG9yZGVyLCBpZS5cblx0XHQqXG5cdFx0Klx0ZTEgPCBlMiAgaWZmICBlMS54IDwgZTIueCB8fCAoZTEueCA9PSBlMi54ICYmIGUxLnkgPCBlMi55KVxuXHRcdCovXG5cdFx0U3dlZXAucmVtb3ZlRGVnZW5lcmF0ZUVkZ2VzKCB0ZXNzICk7XG5cdFx0aWYgKCAhU3dlZXAuaW5pdFByaW9yaXR5USggdGVzcyApICkgcmV0dXJuIGZhbHNlOyAvKiBpZiBlcnJvciAqL1xuXHRcdFN3ZWVwLmluaXRFZGdlRGljdCggdGVzcyApO1xuXG5cdFx0d2hpbGUoICh2ID0gdGVzcy5wcS5leHRyYWN0TWluKCkpICE9PSBudWxsICkge1xuXHRcdFx0Zm9yKCA7OyApIHtcblx0XHRcdFx0dk5leHQgPSB0ZXNzLnBxLm1pbigpO1xuXHRcdFx0XHRpZiggdk5leHQgPT09IG51bGwgfHwgISBHZW9tLnZlcnRFcSggdk5leHQsIHYgKSkgYnJlYWs7XG5cblx0XHRcdFx0LyogTWVyZ2UgdG9nZXRoZXIgYWxsIHZlcnRpY2VzIGF0IGV4YWN0bHkgdGhlIHNhbWUgbG9jYXRpb24uXG5cdFx0XHRcdCogVGhpcyBpcyBtb3JlIGVmZmljaWVudCB0aGFuIHByb2Nlc3NpbmcgdGhlbSBvbmUgYXQgYSB0aW1lLFxuXHRcdFx0XHQqIHNpbXBsaWZpZXMgdGhlIGNvZGUgKHNlZSBDb25uZWN0TGVmdERlZ2VuZXJhdGUpLCBhbmQgaXMgYWxzb1xuXHRcdFx0XHQqIGltcG9ydGFudCBmb3IgY29ycmVjdCBoYW5kbGluZyBvZiBjZXJ0YWluIGRlZ2VuZXJhdGUgY2FzZXMuXG5cdFx0XHRcdCogRm9yIGV4YW1wbGUsIHN1cHBvc2UgdGhlcmUgYXJlIHR3byBpZGVudGljYWwgZWRnZXMgQSBhbmQgQlxuXHRcdFx0XHQqIHRoYXQgYmVsb25nIHRvIGRpZmZlcmVudCBjb250b3VycyAoc28gd2l0aG91dCB0aGlzIGNvZGUgdGhleSB3b3VsZFxuXHRcdFx0XHQqIGJlIHByb2Nlc3NlZCBieSBzZXBhcmF0ZSBzd2VlcCBldmVudHMpLiAgU3VwcG9zZSBhbm90aGVyIGVkZ2UgQ1xuXHRcdFx0XHQqIGNyb3NzZXMgQSBhbmQgQiBmcm9tIGFib3ZlLiAgV2hlbiBBIGlzIHByb2Nlc3NlZCwgd2Ugc3BsaXQgaXRcblx0XHRcdFx0KiBhdCBpdHMgaW50ZXJzZWN0aW9uIHBvaW50IHdpdGggQy4gIEhvd2V2ZXIgdGhpcyBhbHNvIHNwbGl0cyBDLFxuXHRcdFx0XHQqIHNvIHdoZW4gd2UgaW5zZXJ0IEIgd2UgbWF5IGNvbXB1dGUgYSBzbGlnaHRseSBkaWZmZXJlbnRcblx0XHRcdFx0KiBpbnRlcnNlY3Rpb24gcG9pbnQuICBUaGlzIG1pZ2h0IGxlYXZlIHR3byBlZGdlcyB3aXRoIGEgc21hbGxcblx0XHRcdFx0KiBnYXAgYmV0d2VlbiB0aGVtLiAgVGhpcyBraW5kIG9mIGVycm9yIGlzIGVzcGVjaWFsbHkgb2J2aW91c1xuXHRcdFx0XHQqIHdoZW4gdXNpbmcgYm91bmRhcnkgZXh0cmFjdGlvbiAoVEVTU19CT1VOREFSWV9PTkxZKS5cblx0XHRcdFx0Ki9cblx0XHRcdFx0dk5leHQgPSB0ZXNzLnBxLmV4dHJhY3RNaW4oKTtcblx0XHRcdFx0U3dlZXAuc3BsaWNlTWVyZ2VWZXJ0aWNlcyggdGVzcywgdi5hbkVkZ2UsIHZOZXh0LmFuRWRnZSApO1xuXHRcdFx0fVxuXHRcdFx0U3dlZXAuc3dlZXBFdmVudCggdGVzcywgdiApO1xuXHRcdH1cblxuXHRcdC8qIFNldCB0ZXNzLT5ldmVudCBmb3IgZGVidWdnaW5nIHB1cnBvc2VzICovXG5cdFx0dGVzcy5ldmVudCA9IHRlc3MuZGljdC5taW4oKS5rZXkuZVVwLk9yZztcblx0XHRTd2VlcC5kZWJ1Z0V2ZW50KCB0ZXNzICk7XG5cdFx0U3dlZXAuZG9uZUVkZ2VEaWN0KCB0ZXNzICk7XG5cdFx0U3dlZXAuZG9uZVByaW9yaXR5USggdGVzcyApO1xuXG5cdFx0aWYgKCAhU3dlZXAucmVtb3ZlRGVnZW5lcmF0ZUZhY2VzKCB0ZXNzLCB0ZXNzLm1lc2ggKSApIHJldHVybiBmYWxzZTtcblx0XHR0ZXNzLm1lc2guY2hlY2soKTtcblxuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblxuXHRmdW5jdGlvbiBUZXNzZWxhdG9yKCkge1xuXG5cdFx0LyoqKiBzdGF0ZSBuZWVkZWQgZm9yIGNvbGxlY3RpbmcgdGhlIGlucHV0IGRhdGEgKioqL1xuXHRcdHRoaXMubWVzaCA9IG51bGw7XHRcdC8qIHN0b3JlcyB0aGUgaW5wdXQgY29udG91cnMsIGFuZCBldmVudHVhbGx5XG5cdFx0XHRcdFx0XHRcdHRoZSB0ZXNzZWxsYXRpb24gaXRzZWxmICovXG5cblx0XHQvKioqIHN0YXRlIG5lZWRlZCBmb3IgcHJvamVjdGluZyBvbnRvIHRoZSBzd2VlcCBwbGFuZSAqKiovXG5cblx0XHR0aGlzLm5vcm1hbCA9IFswLjAsIDAuMCwgMC4wXTtcdC8qIHVzZXItc3BlY2lmaWVkIG5vcm1hbCAoaWYgcHJvdmlkZWQpICovXG5cdFx0dGhpcy5zVW5pdCA9IFswLjAsIDAuMCwgMC4wXTtcdC8qIHVuaXQgdmVjdG9yIGluIHMtZGlyZWN0aW9uIChkZWJ1Z2dpbmcpICovXG5cdFx0dGhpcy50VW5pdCA9IFswLjAsIDAuMCwgMC4wXTtcdC8qIHVuaXQgdmVjdG9yIGluIHQtZGlyZWN0aW9uIChkZWJ1Z2dpbmcpICovXG5cblx0XHR0aGlzLmJtaW4gPSBbMC4wLCAwLjBdO1xuXHRcdHRoaXMuYm1heCA9IFswLjAsIDAuMF07XG5cblx0XHQvKioqIHN0YXRlIG5lZWRlZCBmb3IgdGhlIGxpbmUgc3dlZXAgKioqL1xuXHRcdHRoaXMud2luZGluZ1J1bGUgPSBUZXNzMi5XSU5ESU5HX09ERDtcdC8qIHJ1bGUgZm9yIGRldGVybWluaW5nIHBvbHlnb24gaW50ZXJpb3IgKi9cblxuXHRcdHRoaXMuZGljdCA9IG51bGw7XHRcdC8qIGVkZ2UgZGljdGlvbmFyeSBmb3Igc3dlZXAgbGluZSAqL1xuXHRcdHRoaXMucHEgPSBudWxsO1x0XHQvKiBwcmlvcml0eSBxdWV1ZSBvZiB2ZXJ0ZXggZXZlbnRzICovXG5cdFx0dGhpcy5ldmVudCA9IG51bGw7XHRcdC8qIGN1cnJlbnQgc3dlZXAgZXZlbnQgYmVpbmcgcHJvY2Vzc2VkICovXG5cblx0XHR0aGlzLnZlcnRleEluZGV4Q291bnRlciA9IDA7XG5cdFx0XG5cdFx0dGhpcy52ZXJ0aWNlcyA9IFtdO1xuXHRcdHRoaXMudmVydGV4SW5kaWNlcyA9IFtdO1xuXHRcdHRoaXMudmVydGV4Q291bnQgPSAwO1xuXHRcdHRoaXMuZWxlbWVudHMgPSBbXTtcblx0XHR0aGlzLmVsZW1lbnRDb3VudCA9IDA7XG5cdH07XG5cblx0VGVzc2VsYXRvci5wcm90b3R5cGUgPSB7XG5cblx0XHRkb3RfOiBmdW5jdGlvbih1LCB2KSB7XG5cdFx0XHRyZXR1cm4gKHVbMF0qdlswXSArIHVbMV0qdlsxXSArIHVbMl0qdlsyXSk7XG5cdFx0fSxcblxuXHRcdG5vcm1hbGl6ZV86IGZ1bmN0aW9uKCB2ICkge1xuXHRcdFx0dmFyIGxlbiA9IHZbMF0qdlswXSArIHZbMV0qdlsxXSArIHZbMl0qdlsyXTtcblx0XHRcdGFzc2VydCggbGVuID4gMC4wICk7XG5cdFx0XHRsZW4gPSBNYXRoLnNxcnQoIGxlbiApO1xuXHRcdFx0dlswXSAvPSBsZW47XG5cdFx0XHR2WzFdIC89IGxlbjtcblx0XHRcdHZbMl0gLz0gbGVuO1xuXHRcdH0sXG5cblx0XHRsb25nQXhpc186IGZ1bmN0aW9uKCB2ICkge1xuXHRcdFx0dmFyIGkgPSAwO1xuXHRcdFx0aWYoIE1hdGguYWJzKHZbMV0pID4gTWF0aC5hYnModlswXSkgKSB7IGkgPSAxOyB9XG5cdFx0XHRpZiggTWF0aC5hYnModlsyXSkgPiBNYXRoLmFicyh2W2ldKSApIHsgaSA9IDI7IH1cblx0XHRcdHJldHVybiBpO1xuXHRcdH0sXG5cblx0XHRjb21wdXRlTm9ybWFsXzogZnVuY3Rpb24oIG5vcm0gKVxuXHRcdHtcblx0XHRcdHZhciB2LCB2MSwgdjI7XG5cdFx0XHR2YXIgYywgdExlbjIsIG1heExlbjI7XG5cdFx0XHR2YXIgbWF4VmFsID0gWzAsMCwwXSwgbWluVmFsID0gWzAsMCwwXSwgZDEgPSBbMCwwLDBdLCBkMiA9IFswLDAsMF0sIHROb3JtID0gWzAsMCwwXTtcblx0XHRcdHZhciBtYXhWZXJ0ID0gW251bGwsbnVsbCxudWxsXSwgbWluVmVydCA9IFtudWxsLG51bGwsbnVsbF07XG5cdFx0XHR2YXIgdkhlYWQgPSB0aGlzLm1lc2gudkhlYWQ7XG5cdFx0XHR2YXIgaTtcblxuXHRcdFx0diA9IHZIZWFkLm5leHQ7XG5cdFx0XHRmb3IoIGkgPSAwOyBpIDwgMzsgKytpICkge1xuXHRcdFx0XHRjID0gdi5jb29yZHNbaV07XG5cdFx0XHRcdG1pblZhbFtpXSA9IGM7XG5cdFx0XHRcdG1pblZlcnRbaV0gPSB2O1xuXHRcdFx0XHRtYXhWYWxbaV0gPSBjO1xuXHRcdFx0XHRtYXhWZXJ0W2ldID0gdjtcblx0XHRcdH1cblxuXHRcdFx0Zm9yKCB2ID0gdkhlYWQubmV4dDsgdiAhPT0gdkhlYWQ7IHYgPSB2Lm5leHQgKSB7XG5cdFx0XHRcdGZvciggaSA9IDA7IGkgPCAzOyArK2kgKSB7XG5cdFx0XHRcdFx0YyA9IHYuY29vcmRzW2ldO1xuXHRcdFx0XHRcdGlmKCBjIDwgbWluVmFsW2ldICkgeyBtaW5WYWxbaV0gPSBjOyBtaW5WZXJ0W2ldID0gdjsgfVxuXHRcdFx0XHRcdGlmKCBjID4gbWF4VmFsW2ldICkgeyBtYXhWYWxbaV0gPSBjOyBtYXhWZXJ0W2ldID0gdjsgfVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8qIEZpbmQgdHdvIHZlcnRpY2VzIHNlcGFyYXRlZCBieSBhdCBsZWFzdCAxL3NxcnQoMykgb2YgdGhlIG1heGltdW1cblx0XHRcdCogZGlzdGFuY2UgYmV0d2VlbiBhbnkgdHdvIHZlcnRpY2VzXG5cdFx0XHQqL1xuXHRcdFx0aSA9IDA7XG5cdFx0XHRpZiggbWF4VmFsWzFdIC0gbWluVmFsWzFdID4gbWF4VmFsWzBdIC0gbWluVmFsWzBdICkgeyBpID0gMTsgfVxuXHRcdFx0aWYoIG1heFZhbFsyXSAtIG1pblZhbFsyXSA+IG1heFZhbFtpXSAtIG1pblZhbFtpXSApIHsgaSA9IDI7IH1cblx0XHRcdGlmKCBtaW5WYWxbaV0gPj0gbWF4VmFsW2ldICkge1xuXHRcdFx0XHQvKiBBbGwgdmVydGljZXMgYXJlIHRoZSBzYW1lIC0tIG5vcm1hbCBkb2Vzbid0IG1hdHRlciAqL1xuXHRcdFx0XHRub3JtWzBdID0gMDsgbm9ybVsxXSA9IDA7IG5vcm1bMl0gPSAxO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8qIExvb2sgZm9yIGEgdGhpcmQgdmVydGV4IHdoaWNoIGZvcm1zIHRoZSB0cmlhbmdsZSB3aXRoIG1heGltdW0gYXJlYVxuXHRcdFx0KiAoTGVuZ3RoIG9mIG5vcm1hbCA9PSB0d2ljZSB0aGUgdHJpYW5nbGUgYXJlYSlcblx0XHRcdCovXG5cdFx0XHRtYXhMZW4yID0gMDtcblx0XHRcdHYxID0gbWluVmVydFtpXTtcblx0XHRcdHYyID0gbWF4VmVydFtpXTtcblx0XHRcdGQxWzBdID0gdjEuY29vcmRzWzBdIC0gdjIuY29vcmRzWzBdO1xuXHRcdFx0ZDFbMV0gPSB2MS5jb29yZHNbMV0gLSB2Mi5jb29yZHNbMV07XG5cdFx0XHRkMVsyXSA9IHYxLmNvb3Jkc1syXSAtIHYyLmNvb3Jkc1syXTtcblx0XHRcdGZvciggdiA9IHZIZWFkLm5leHQ7IHYgIT09IHZIZWFkOyB2ID0gdi5uZXh0ICkge1xuXHRcdFx0XHRkMlswXSA9IHYuY29vcmRzWzBdIC0gdjIuY29vcmRzWzBdO1xuXHRcdFx0XHRkMlsxXSA9IHYuY29vcmRzWzFdIC0gdjIuY29vcmRzWzFdO1xuXHRcdFx0XHRkMlsyXSA9IHYuY29vcmRzWzJdIC0gdjIuY29vcmRzWzJdO1xuXHRcdFx0XHR0Tm9ybVswXSA9IGQxWzFdKmQyWzJdIC0gZDFbMl0qZDJbMV07XG5cdFx0XHRcdHROb3JtWzFdID0gZDFbMl0qZDJbMF0gLSBkMVswXSpkMlsyXTtcblx0XHRcdFx0dE5vcm1bMl0gPSBkMVswXSpkMlsxXSAtIGQxWzFdKmQyWzBdO1xuXHRcdFx0XHR0TGVuMiA9IHROb3JtWzBdKnROb3JtWzBdICsgdE5vcm1bMV0qdE5vcm1bMV0gKyB0Tm9ybVsyXSp0Tm9ybVsyXTtcblx0XHRcdFx0aWYoIHRMZW4yID4gbWF4TGVuMiApIHtcblx0XHRcdFx0XHRtYXhMZW4yID0gdExlbjI7XG5cdFx0XHRcdFx0bm9ybVswXSA9IHROb3JtWzBdO1xuXHRcdFx0XHRcdG5vcm1bMV0gPSB0Tm9ybVsxXTtcblx0XHRcdFx0XHRub3JtWzJdID0gdE5vcm1bMl07XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYoIG1heExlbjIgPD0gMCApIHtcblx0XHRcdFx0LyogQWxsIHBvaW50cyBsaWUgb24gYSBzaW5nbGUgbGluZSAtLSBhbnkgZGVjZW50IG5vcm1hbCB3aWxsIGRvICovXG5cdFx0XHRcdG5vcm1bMF0gPSBub3JtWzFdID0gbm9ybVsyXSA9IDA7XG5cdFx0XHRcdG5vcm1bdGhpcy5sb25nQXhpc18oZDEpXSA9IDE7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGNoZWNrT3JpZW50YXRpb25fOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBhcmVhO1xuXHRcdFx0dmFyIGYsIGZIZWFkID0gdGhpcy5tZXNoLmZIZWFkO1xuXHRcdFx0dmFyIHYsIHZIZWFkID0gdGhpcy5tZXNoLnZIZWFkO1xuXHRcdFx0dmFyIGU7XG5cblx0XHRcdC8qIFdoZW4gd2UgY29tcHV0ZSB0aGUgbm9ybWFsIGF1dG9tYXRpY2FsbHksIHdlIGNob29zZSB0aGUgb3JpZW50YXRpb25cblx0XHRcdCogc28gdGhhdCB0aGUgdGhlIHN1bSBvZiB0aGUgc2lnbmVkIGFyZWFzIG9mIGFsbCBjb250b3VycyBpcyBub24tbmVnYXRpdmUuXG5cdFx0XHQqL1xuXHRcdFx0YXJlYSA9IDA7XG5cdFx0XHRmb3IoIGYgPSBmSGVhZC5uZXh0OyBmICE9PSBmSGVhZDsgZiA9IGYubmV4dCApIHtcblx0XHRcdFx0ZSA9IGYuYW5FZGdlO1xuXHRcdFx0XHRpZiggZS53aW5kaW5nIDw9IDAgKSBjb250aW51ZTtcblx0XHRcdFx0ZG8ge1xuXHRcdFx0XHRcdGFyZWEgKz0gKGUuT3JnLnMgLSBlLkRzdC5zKSAqIChlLk9yZy50ICsgZS5Ec3QudCk7XG5cdFx0XHRcdFx0ZSA9IGUuTG5leHQ7XG5cdFx0XHRcdH0gd2hpbGUoIGUgIT09IGYuYW5FZGdlICk7XG5cdFx0XHR9XG5cdFx0XHRpZiggYXJlYSA8IDAgKSB7XG5cdFx0XHRcdC8qIFJldmVyc2UgdGhlIG9yaWVudGF0aW9uIGJ5IGZsaXBwaW5nIGFsbCB0aGUgdC1jb29yZGluYXRlcyAqL1xuXHRcdFx0XHRmb3IoIHYgPSB2SGVhZC5uZXh0OyB2ICE9PSB2SGVhZDsgdiA9IHYubmV4dCApIHtcblx0XHRcdFx0XHR2LnQgPSAtIHYudDtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLnRVbml0WzBdID0gLSB0aGlzLnRVbml0WzBdO1xuXHRcdFx0XHR0aGlzLnRVbml0WzFdID0gLSB0aGlzLnRVbml0WzFdO1xuXHRcdFx0XHR0aGlzLnRVbml0WzJdID0gLSB0aGlzLnRVbml0WzJdO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0LypcdCNpZmRlZiBGT1JfVFJJVEVfVEVTVF9QUk9HUkFNXG5cdFx0I2luY2x1ZGUgPHN0ZGxpYi5oPlxuXHRcdGV4dGVybiBpbnQgUmFuZG9tU3dlZXA7XG5cdFx0I2RlZmluZSBTX1VOSVRfWFx0KFJhbmRvbVN3ZWVwID8gKDIqZHJhbmQ0OCgpLTEpIDogMS4wKVxuXHRcdCNkZWZpbmUgU19VTklUX1lcdChSYW5kb21Td2VlcCA/ICgyKmRyYW5kNDgoKS0xKSA6IDAuMClcblx0XHQjZWxzZVxuXHRcdCNpZiBkZWZpbmVkKFNMQU5URURfU1dFRVApICovXG5cdFx0LyogVGhlIFwiZmVhdHVyZSBtZXJnaW5nXCIgaXMgbm90IGludGVuZGVkIHRvIGJlIGNvbXBsZXRlLiAgVGhlcmUgYXJlXG5cdFx0KiBzcGVjaWFsIGNhc2VzIHdoZXJlIGVkZ2VzIGFyZSBuZWFybHkgcGFyYWxsZWwgdG8gdGhlIHN3ZWVwIGxpbmVcblx0XHQqIHdoaWNoIGFyZSBub3QgaW1wbGVtZW50ZWQuICBUaGUgYWxnb3JpdGhtIHNob3VsZCBzdGlsbCBiZWhhdmVcblx0XHQqIHJvYnVzdGx5IChpZS4gcHJvZHVjZSBhIHJlYXNvbmFibGUgdGVzc2VsYXRpb24pIGluIHRoZSBwcmVzZW5jZVxuXHRcdCogb2Ygc3VjaCBlZGdlcywgaG93ZXZlciBpdCBtYXkgbWlzcyBmZWF0dXJlcyB3aGljaCBjb3VsZCBoYXZlIGJlZW5cblx0XHQqIG1lcmdlZC4gIFdlIGNvdWxkIG1pbmltaXplIHRoaXMgZWZmZWN0IGJ5IGNob29zaW5nIHRoZSBzd2VlcCBsaW5lXG5cdFx0KiBkaXJlY3Rpb24gdG8gYmUgc29tZXRoaW5nIHVudXN1YWwgKGllLiBub3QgcGFyYWxsZWwgdG8gb25lIG9mIHRoZVxuXHRcdCogY29vcmRpbmF0ZSBheGVzKS5cblx0XHQqL1xuXHQvKlx0I2RlZmluZSBTX1VOSVRfWFx0KFRFU1NyZWFsKTAuNTA5NDE1Mzk1NjQ5NTUzODVcdC8vIFByZS1ub3JtYWxpemVkXG5cdFx0I2RlZmluZSBTX1VOSVRfWVx0KFRFU1NyZWFsKTAuODYwNTIwNzQ2MjIwMTA2MzNcblx0XHQjZWxzZVxuXHRcdCNkZWZpbmUgU19VTklUX1hcdChURVNTcmVhbCkxLjBcblx0XHQjZGVmaW5lIFNfVU5JVF9ZXHQoVEVTU3JlYWwpMC4wXG5cdFx0I2VuZGlmXG5cdFx0I2VuZGlmKi9cblxuXHRcdC8qIERldGVybWluZSB0aGUgcG9seWdvbiBub3JtYWwgYW5kIHByb2plY3QgdmVydGljZXMgb250byB0aGUgcGxhbmVcblx0XHQqIG9mIHRoZSBwb2x5Z29uLlxuXHRcdCovXG5cdFx0cHJvamVjdFBvbHlnb25fOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciB2LCB2SGVhZCA9IHRoaXMubWVzaC52SGVhZDtcblx0XHRcdHZhciBub3JtID0gWzAsMCwwXTtcblx0XHRcdHZhciBzVW5pdCwgdFVuaXQ7XG5cdFx0XHR2YXIgaSwgZmlyc3QsIGNvbXB1dGVkTm9ybWFsID0gZmFsc2U7XG5cblx0XHRcdG5vcm1bMF0gPSB0aGlzLm5vcm1hbFswXTtcblx0XHRcdG5vcm1bMV0gPSB0aGlzLm5vcm1hbFsxXTtcblx0XHRcdG5vcm1bMl0gPSB0aGlzLm5vcm1hbFsyXTtcblx0XHRcdGlmKCBub3JtWzBdID09PSAwLjAgJiYgbm9ybVsxXSA9PT0gMC4wICYmIG5vcm1bMl0gPT09IDAuMCApIHtcblx0XHRcdFx0dGhpcy5jb21wdXRlTm9ybWFsXyggbm9ybSApO1xuXHRcdFx0XHRjb21wdXRlZE5vcm1hbCA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHRzVW5pdCA9IHRoaXMuc1VuaXQ7XG5cdFx0XHR0VW5pdCA9IHRoaXMudFVuaXQ7XG5cdFx0XHRpID0gdGhpcy5sb25nQXhpc18oIG5vcm0gKTtcblxuXHQvKlx0I2lmIGRlZmluZWQoRk9SX1RSSVRFX1RFU1RfUFJPR1JBTSkgfHwgZGVmaW5lZChUUlVFX1BST0pFQ1QpXG5cdFx0XHQvLyBDaG9vc2UgdGhlIGluaXRpYWwgc1VuaXQgdmVjdG9yIHRvIGJlIGFwcHJveGltYXRlbHkgcGVycGVuZGljdWxhclxuXHRcdFx0Ly8gdG8gdGhlIG5vcm1hbC5cblx0XHRcdFxuXHRcdFx0Tm9ybWFsaXplKCBub3JtICk7XG5cblx0XHRcdHNVbml0W2ldID0gMDtcblx0XHRcdHNVbml0WyhpKzEpJTNdID0gU19VTklUX1g7XG5cdFx0XHRzVW5pdFsoaSsyKSUzXSA9IFNfVU5JVF9ZO1xuXG5cdFx0XHQvLyBOb3cgbWFrZSBpdCBleGFjdGx5IHBlcnBlbmRpY3VsYXIgXG5cdFx0XHR3ID0gRG90KCBzVW5pdCwgbm9ybSApO1xuXHRcdFx0c1VuaXRbMF0gLT0gdyAqIG5vcm1bMF07XG5cdFx0XHRzVW5pdFsxXSAtPSB3ICogbm9ybVsxXTtcblx0XHRcdHNVbml0WzJdIC09IHcgKiBub3JtWzJdO1xuXHRcdFx0Tm9ybWFsaXplKCBzVW5pdCApO1xuXG5cdFx0XHQvLyBDaG9vc2UgdFVuaXQgc28gdGhhdCAoc1VuaXQsdFVuaXQsbm9ybSkgZm9ybSBhIHJpZ2h0LWhhbmRlZCBmcmFtZSBcblx0XHRcdHRVbml0WzBdID0gbm9ybVsxXSpzVW5pdFsyXSAtIG5vcm1bMl0qc1VuaXRbMV07XG5cdFx0XHR0VW5pdFsxXSA9IG5vcm1bMl0qc1VuaXRbMF0gLSBub3JtWzBdKnNVbml0WzJdO1xuXHRcdFx0dFVuaXRbMl0gPSBub3JtWzBdKnNVbml0WzFdIC0gbm9ybVsxXSpzVW5pdFswXTtcblx0XHRcdE5vcm1hbGl6ZSggdFVuaXQgKTtcblx0XHQjZWxzZSovXG5cdFx0XHQvKiBQcm9qZWN0IHBlcnBlbmRpY3VsYXIgdG8gYSBjb29yZGluYXRlIGF4aXMgLS0gYmV0dGVyIG51bWVyaWNhbGx5ICovXG5cdFx0XHRzVW5pdFtpXSA9IDA7XG5cdFx0XHRzVW5pdFsoaSsxKSUzXSA9IDEuMDtcblx0XHRcdHNVbml0WyhpKzIpJTNdID0gMC4wO1xuXG5cdFx0XHR0VW5pdFtpXSA9IDA7XG5cdFx0XHR0VW5pdFsoaSsxKSUzXSA9IDAuMDtcblx0XHRcdHRVbml0WyhpKzIpJTNdID0gKG5vcm1baV0gPiAwKSA/IDEuMCA6IC0xLjA7XG5cdC8vXHQjZW5kaWZcblxuXHRcdFx0LyogUHJvamVjdCB0aGUgdmVydGljZXMgb250byB0aGUgc3dlZXAgcGxhbmUgKi9cblx0XHRcdGZvciggdiA9IHZIZWFkLm5leHQ7IHYgIT09IHZIZWFkOyB2ID0gdi5uZXh0ICkge1xuXHRcdFx0XHR2LnMgPSB0aGlzLmRvdF8oIHYuY29vcmRzLCBzVW5pdCApO1xuXHRcdFx0XHR2LnQgPSB0aGlzLmRvdF8oIHYuY29vcmRzLCB0VW5pdCApO1xuXHRcdFx0fVxuXHRcdFx0aWYoIGNvbXB1dGVkTm9ybWFsICkge1xuXHRcdFx0XHR0aGlzLmNoZWNrT3JpZW50YXRpb25fKCk7XG5cdFx0XHR9XG5cblx0XHRcdC8qIENvbXB1dGUgU1QgYm91bmRzLiAqL1xuXHRcdFx0Zmlyc3QgPSB0cnVlO1xuXHRcdFx0Zm9yKCB2ID0gdkhlYWQubmV4dDsgdiAhPT0gdkhlYWQ7IHYgPSB2Lm5leHQgKSB7XG5cdFx0XHRcdGlmIChmaXJzdCkge1xuXHRcdFx0XHRcdHRoaXMuYm1pblswXSA9IHRoaXMuYm1heFswXSA9IHYucztcblx0XHRcdFx0XHR0aGlzLmJtaW5bMV0gPSB0aGlzLmJtYXhbMV0gPSB2LnQ7XG5cdFx0XHRcdFx0Zmlyc3QgPSBmYWxzZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpZiAodi5zIDwgdGhpcy5ibWluWzBdKSB0aGlzLmJtaW5bMF0gPSB2LnM7XG5cdFx0XHRcdFx0aWYgKHYucyA+IHRoaXMuYm1heFswXSkgdGhpcy5ibWF4WzBdID0gdi5zO1xuXHRcdFx0XHRcdGlmICh2LnQgPCB0aGlzLmJtaW5bMV0pIHRoaXMuYm1pblsxXSA9IHYudDtcblx0XHRcdFx0XHRpZiAodi50ID4gdGhpcy5ibWF4WzFdKSB0aGlzLmJtYXhbMV0gPSB2LnQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0YWRkV2luZGluZ186IGZ1bmN0aW9uKGVEc3QsZVNyYykge1xuXHRcdFx0ZURzdC53aW5kaW5nICs9IGVTcmMud2luZGluZztcblx0XHRcdGVEc3QuU3ltLndpbmRpbmcgKz0gZVNyYy5TeW0ud2luZGluZztcblx0XHR9LFxuXHRcdFxuXHRcdC8qIHRlc3NNZXNoVGVzc2VsbGF0ZU1vbm9SZWdpb24oIGZhY2UgKSB0ZXNzZWxsYXRlcyBhIG1vbm90b25lIHJlZ2lvblxuXHRcdCogKHdoYXQgZWxzZSB3b3VsZCBpdCBkbz8/KSAgVGhlIHJlZ2lvbiBtdXN0IGNvbnNpc3Qgb2YgYSBzaW5nbGVcblx0XHQqIGxvb3Agb2YgaGFsZi1lZGdlcyAoc2VlIG1lc2guaCkgb3JpZW50ZWQgQ0NXLiAgXCJNb25vdG9uZVwiIGluIHRoaXNcblx0XHQqIGNhc2UgbWVhbnMgdGhhdCBhbnkgdmVydGljYWwgbGluZSBpbnRlcnNlY3RzIHRoZSBpbnRlcmlvciBvZiB0aGVcblx0XHQqIHJlZ2lvbiBpbiBhIHNpbmdsZSBpbnRlcnZhbC4gIFxuXHRcdCpcblx0XHQqIFRlc3NlbGxhdGlvbiBjb25zaXN0cyBvZiBhZGRpbmcgaW50ZXJpb3IgZWRnZXMgKGFjdHVhbGx5IHBhaXJzIG9mXG5cdFx0KiBoYWxmLWVkZ2VzKSwgdG8gc3BsaXQgdGhlIHJlZ2lvbiBpbnRvIG5vbi1vdmVybGFwcGluZyB0cmlhbmdsZXMuXG5cdFx0KlxuXHRcdCogVGhlIGJhc2ljIGlkZWEgaXMgZXhwbGFpbmVkIGluIFByZXBhcmF0YSBhbmQgU2hhbW9zICh3aGljaCBJIGRvbicndFxuXHRcdCogaGF2ZSBoYW5keSByaWdodCBub3cpLCBhbHRob3VnaCB0aGVpciBpbXBsZW1lbnRhdGlvbiBpcyBtb3JlXG5cdFx0KiBjb21wbGljYXRlZCB0aGFuIHRoaXMgb25lLiAgVGhlIGFyZSB0d28gZWRnZSBjaGFpbnMsIGFuIHVwcGVyIGNoYWluXG5cdFx0KiBhbmQgYSBsb3dlciBjaGFpbi4gIFdlIHByb2Nlc3MgYWxsIHZlcnRpY2VzIGZyb20gYm90aCBjaGFpbnMgaW4gb3JkZXIsXG5cdFx0KiBmcm9tIHJpZ2h0IHRvIGxlZnQuXG5cdFx0KlxuXHRcdCogVGhlIGFsZ29yaXRobSBlbnN1cmVzIHRoYXQgdGhlIGZvbGxvd2luZyBpbnZhcmlhbnQgaG9sZHMgYWZ0ZXIgZWFjaFxuXHRcdCogdmVydGV4IGlzIHByb2Nlc3NlZDogdGhlIHVudGVzc2VsbGF0ZWQgcmVnaW9uIGNvbnNpc3RzIG9mIHR3b1xuXHRcdCogY2hhaW5zLCB3aGVyZSBvbmUgY2hhaW4gKHNheSB0aGUgdXBwZXIpIGlzIGEgc2luZ2xlIGVkZ2UsIGFuZFxuXHRcdCogdGhlIG90aGVyIGNoYWluIGlzIGNvbmNhdmUuICBUaGUgbGVmdCB2ZXJ0ZXggb2YgdGhlIHNpbmdsZSBlZGdlXG5cdFx0KiBpcyBhbHdheXMgdG8gdGhlIGxlZnQgb2YgYWxsIHZlcnRpY2VzIGluIHRoZSBjb25jYXZlIGNoYWluLlxuXHRcdCpcblx0XHQqIEVhY2ggc3RlcCBjb25zaXN0cyBvZiBhZGRpbmcgdGhlIHJpZ2h0bW9zdCB1bnByb2Nlc3NlZCB2ZXJ0ZXggdG8gb25lXG5cdFx0KiBvZiB0aGUgdHdvIGNoYWlucywgYW5kIGZvcm1pbmcgYSBmYW4gb2YgdHJpYW5nbGVzIGZyb20gdGhlIHJpZ2h0bW9zdFxuXHRcdCogb2YgdHdvIGNoYWluIGVuZHBvaW50cy4gIERldGVybWluaW5nIHdoZXRoZXIgd2UgY2FuIGFkZCBlYWNoIHRyaWFuZ2xlXG5cdFx0KiB0byB0aGUgZmFuIGlzIGEgc2ltcGxlIG9yaWVudGF0aW9uIHRlc3QuICBCeSBtYWtpbmcgdGhlIGZhbiBhcyBsYXJnZVxuXHRcdCogYXMgcG9zc2libGUsIHdlIHJlc3RvcmUgdGhlIGludmFyaWFudCAoY2hlY2sgaXQgeW91cnNlbGYpLlxuXHRcdCovXG5cdC8vXHRpbnQgdGVzc01lc2hUZXNzZWxsYXRlTW9ub1JlZ2lvbiggVEVTU21lc2ggKm1lc2gsIFRFU1NmYWNlICpmYWNlIClcblx0XHR0ZXNzZWxsYXRlTW9ub1JlZ2lvbl86IGZ1bmN0aW9uKCBtZXNoLCBmYWNlICkge1xuXHRcdFx0dmFyIHVwLCBsbztcblxuXHRcdFx0LyogQWxsIGVkZ2VzIGFyZSBvcmllbnRlZCBDQ1cgYXJvdW5kIHRoZSBib3VuZGFyeSBvZiB0aGUgcmVnaW9uLlxuXHRcdFx0KiBGaXJzdCwgZmluZCB0aGUgaGFsZi1lZGdlIHdob3NlIG9yaWdpbiB2ZXJ0ZXggaXMgcmlnaHRtb3N0LlxuXHRcdFx0KiBTaW5jZSB0aGUgc3dlZXAgZ29lcyBmcm9tIGxlZnQgdG8gcmlnaHQsIGZhY2UtPmFuRWRnZSBzaG91bGRcblx0XHRcdCogYmUgY2xvc2UgdG8gdGhlIGVkZ2Ugd2Ugd2FudC5cblx0XHRcdCovXG5cdFx0XHR1cCA9IGZhY2UuYW5FZGdlO1xuXHRcdFx0YXNzZXJ0KCB1cC5MbmV4dCAhPT0gdXAgJiYgdXAuTG5leHQuTG5leHQgIT09IHVwICk7XG5cblx0XHRcdGZvciggOyBHZW9tLnZlcnRMZXEoIHVwLkRzdCwgdXAuT3JnICk7IHVwID0gdXAuTHByZXYgKVxuXHRcdFx0XHQ7XG5cdFx0XHRmb3IoIDsgR2VvbS52ZXJ0TGVxKCB1cC5PcmcsIHVwLkRzdCApOyB1cCA9IHVwLkxuZXh0IClcblx0XHRcdFx0O1xuXHRcdFx0bG8gPSB1cC5McHJldjtcblxuXHRcdFx0d2hpbGUoIHVwLkxuZXh0ICE9PSBsbyApIHtcblx0XHRcdFx0aWYoIEdlb20udmVydExlcSggdXAuRHN0LCBsby5PcmcgKSkge1xuXHRcdFx0XHRcdC8qIHVwLT5Ec3QgaXMgb24gdGhlIGxlZnQuICBJdCBpcyBzYWZlIHRvIGZvcm0gdHJpYW5nbGVzIGZyb20gbG8tPk9yZy5cblx0XHRcdFx0XHQqIFRoZSBFZGdlR29lc0xlZnQgdGVzdCBndWFyYW50ZWVzIHByb2dyZXNzIGV2ZW4gd2hlbiBzb21lIHRyaWFuZ2xlc1xuXHRcdFx0XHRcdCogYXJlIENXLCBnaXZlbiB0aGF0IHRoZSB1cHBlciBhbmQgbG93ZXIgY2hhaW5zIGFyZSB0cnVseSBtb25vdG9uZS5cblx0XHRcdFx0XHQqL1xuXHRcdFx0XHRcdHdoaWxlKCBsby5MbmV4dCAhPT0gdXAgJiYgKEdlb20uZWRnZUdvZXNMZWZ0KCBsby5MbmV4dCApXG5cdFx0XHRcdFx0XHR8fCBHZW9tLmVkZ2VTaWduKCBsby5PcmcsIGxvLkRzdCwgbG8uTG5leHQuRHN0ICkgPD0gMC4wICkpIHtcblx0XHRcdFx0XHRcdFx0dmFyIHRlbXBIYWxmRWRnZSA9IG1lc2guY29ubmVjdCggbG8uTG5leHQsIGxvICk7XG5cdFx0XHRcdFx0XHRcdC8vaWYgKHRlbXBIYWxmRWRnZSA9PSBOVUxMKSByZXR1cm4gMDtcblx0XHRcdFx0XHRcdFx0bG8gPSB0ZW1wSGFsZkVkZ2UuU3ltO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRsbyA9IGxvLkxwcmV2O1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8qIGxvLT5PcmcgaXMgb24gdGhlIGxlZnQuICBXZSBjYW4gbWFrZSBDQ1cgdHJpYW5nbGVzIGZyb20gdXAtPkRzdC4gKi9cblx0XHRcdFx0XHR3aGlsZSggbG8uTG5leHQgIT0gdXAgJiYgKEdlb20uZWRnZUdvZXNSaWdodCggdXAuTHByZXYgKVxuXHRcdFx0XHRcdFx0fHwgR2VvbS5lZGdlU2lnbiggdXAuRHN0LCB1cC5PcmcsIHVwLkxwcmV2Lk9yZyApID49IDAuMCApKSB7XG5cdFx0XHRcdFx0XHRcdHZhciB0ZW1wSGFsZkVkZ2UgPSBtZXNoLmNvbm5lY3QoIHVwLCB1cC5McHJldiApO1xuXHRcdFx0XHRcdFx0XHQvL2lmICh0ZW1wSGFsZkVkZ2UgPT0gTlVMTCkgcmV0dXJuIDA7XG5cdFx0XHRcdFx0XHRcdHVwID0gdGVtcEhhbGZFZGdlLlN5bTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dXAgPSB1cC5MbmV4dDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvKiBOb3cgbG8tPk9yZyA9PSB1cC0+RHN0ID09IHRoZSBsZWZ0bW9zdCB2ZXJ0ZXguICBUaGUgcmVtYWluaW5nIHJlZ2lvblxuXHRcdFx0KiBjYW4gYmUgdGVzc2VsbGF0ZWQgaW4gYSBmYW4gZnJvbSB0aGlzIGxlZnRtb3N0IHZlcnRleC5cblx0XHRcdCovXG5cdFx0XHRhc3NlcnQoIGxvLkxuZXh0ICE9PSB1cCApO1xuXHRcdFx0d2hpbGUoIGxvLkxuZXh0LkxuZXh0ICE9PSB1cCApIHtcblx0XHRcdFx0dmFyIHRlbXBIYWxmRWRnZSA9IG1lc2guY29ubmVjdCggbG8uTG5leHQsIGxvICk7XG5cdFx0XHRcdC8vaWYgKHRlbXBIYWxmRWRnZSA9PSBOVUxMKSByZXR1cm4gMDtcblx0XHRcdFx0bG8gPSB0ZW1wSGFsZkVkZ2UuU3ltO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9LFxuXG5cblx0XHQvKiB0ZXNzTWVzaFRlc3NlbGxhdGVJbnRlcmlvciggbWVzaCApIHRlc3NlbGxhdGVzIGVhY2ggcmVnaW9uIG9mXG5cdFx0KiB0aGUgbWVzaCB3aGljaCBpcyBtYXJrZWQgXCJpbnNpZGVcIiB0aGUgcG9seWdvbi4gIEVhY2ggc3VjaCByZWdpb25cblx0XHQqIG11c3QgYmUgbW9ub3RvbmUuXG5cdFx0Ki9cblx0XHQvL2ludCB0ZXNzTWVzaFRlc3NlbGxhdGVJbnRlcmlvciggVEVTU21lc2ggKm1lc2ggKVxuXHRcdHRlc3NlbGxhdGVJbnRlcmlvcl86IGZ1bmN0aW9uKCBtZXNoICkge1xuXHRcdFx0dmFyIGYsIG5leHQ7XG5cblx0XHRcdC8qTElOVEVEKi9cblx0XHRcdGZvciggZiA9IG1lc2guZkhlYWQubmV4dDsgZiAhPT0gbWVzaC5mSGVhZDsgZiA9IG5leHQgKSB7XG5cdFx0XHRcdC8qIE1ha2Ugc3VyZSB3ZSBkb24nJ3QgdHJ5IHRvIHRlc3NlbGxhdGUgdGhlIG5ldyB0cmlhbmdsZXMuICovXG5cdFx0XHRcdG5leHQgPSBmLm5leHQ7XG5cdFx0XHRcdGlmKCBmLmluc2lkZSApIHtcblx0XHRcdFx0XHRpZiAoICF0aGlzLnRlc3NlbGxhdGVNb25vUmVnaW9uXyggbWVzaCwgZiApICkgcmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0sXG5cblxuXHRcdC8qIHRlc3NNZXNoRGlzY2FyZEV4dGVyaW9yKCBtZXNoICkgemFwcyAoaWUuIHNldHMgdG8gTlVMTCkgYWxsIGZhY2VzXG5cdFx0KiB3aGljaCBhcmUgbm90IG1hcmtlZCBcImluc2lkZVwiIHRoZSBwb2x5Z29uLiAgU2luY2UgZnVydGhlciBtZXNoIG9wZXJhdGlvbnNcblx0XHQqIG9uIE5VTEwgZmFjZXMgYXJlIG5vdCBhbGxvd2VkLCB0aGUgbWFpbiBwdXJwb3NlIGlzIHRvIGNsZWFuIHVwIHRoZVxuXHRcdCogbWVzaCBzbyB0aGF0IGV4dGVyaW9yIGxvb3BzIGFyZSBub3QgcmVwcmVzZW50ZWQgaW4gdGhlIGRhdGEgc3RydWN0dXJlLlxuXHRcdCovXG5cdFx0Ly92b2lkIHRlc3NNZXNoRGlzY2FyZEV4dGVyaW9yKCBURVNTbWVzaCAqbWVzaCApXG5cdFx0ZGlzY2FyZEV4dGVyaW9yXzogZnVuY3Rpb24oIG1lc2ggKSB7XG5cdFx0XHR2YXIgZiwgbmV4dDtcblxuXHRcdFx0LypMSU5URUQqL1xuXHRcdFx0Zm9yKCBmID0gbWVzaC5mSGVhZC5uZXh0OyBmICE9PSBtZXNoLmZIZWFkOyBmID0gbmV4dCApIHtcblx0XHRcdFx0LyogU2luY2UgZiB3aWxsIGJlIGRlc3Ryb3llZCwgc2F2ZSBpdHMgbmV4dCBwb2ludGVyLiAqL1xuXHRcdFx0XHRuZXh0ID0gZi5uZXh0O1xuXHRcdFx0XHRpZiggISBmLmluc2lkZSApIHtcblx0XHRcdFx0XHRtZXNoLnphcEZhY2UoIGYgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKiB0ZXNzTWVzaFNldFdpbmRpbmdOdW1iZXIoIG1lc2gsIHZhbHVlLCBrZWVwT25seUJvdW5kYXJ5ICkgcmVzZXRzIHRoZVxuXHRcdCogd2luZGluZyBudW1iZXJzIG9uIGFsbCBlZGdlcyBzbyB0aGF0IHJlZ2lvbnMgbWFya2VkIFwiaW5zaWRlXCIgdGhlXG5cdFx0KiBwb2x5Z29uIGhhdmUgYSB3aW5kaW5nIG51bWJlciBvZiBcInZhbHVlXCIsIGFuZCByZWdpb25zIG91dHNpZGVcblx0XHQqIGhhdmUgYSB3aW5kaW5nIG51bWJlciBvZiAwLlxuXHRcdCpcblx0XHQqIElmIGtlZXBPbmx5Qm91bmRhcnkgaXMgVFJVRSwgaXQgYWxzbyBkZWxldGVzIGFsbCBlZGdlcyB3aGljaCBkbyBub3Rcblx0XHQqIHNlcGFyYXRlIGFuIGludGVyaW9yIHJlZ2lvbiBmcm9tIGFuIGV4dGVyaW9yIG9uZS5cblx0XHQqL1xuXHQvL1x0aW50IHRlc3NNZXNoU2V0V2luZGluZ051bWJlciggVEVTU21lc2ggKm1lc2gsIGludCB2YWx1ZSwgaW50IGtlZXBPbmx5Qm91bmRhcnkgKVxuXHRcdHNldFdpbmRpbmdOdW1iZXJfOiBmdW5jdGlvbiggbWVzaCwgdmFsdWUsIGtlZXBPbmx5Qm91bmRhcnkgKSB7XG5cdFx0XHR2YXIgZSwgZU5leHQ7XG5cblx0XHRcdGZvciggZSA9IG1lc2guZUhlYWQubmV4dDsgZSAhPT0gbWVzaC5lSGVhZDsgZSA9IGVOZXh0ICkge1xuXHRcdFx0XHRlTmV4dCA9IGUubmV4dDtcblx0XHRcdFx0aWYoIGUuUmZhY2UuaW5zaWRlICE9PSBlLkxmYWNlLmluc2lkZSApIHtcblxuXHRcdFx0XHRcdC8qIFRoaXMgaXMgYSBib3VuZGFyeSBlZGdlIChvbmUgc2lkZSBpcyBpbnRlcmlvciwgb25lIGlzIGV4dGVyaW9yKS4gKi9cblx0XHRcdFx0XHRlLndpbmRpbmcgPSAoZS5MZmFjZS5pbnNpZGUpID8gdmFsdWUgOiAtdmFsdWU7XG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHQvKiBCb3RoIHJlZ2lvbnMgYXJlIGludGVyaW9yLCBvciBib3RoIGFyZSBleHRlcmlvci4gKi9cblx0XHRcdFx0XHRpZiggISBrZWVwT25seUJvdW5kYXJ5ICkge1xuXHRcdFx0XHRcdFx0ZS53aW5kaW5nID0gMDtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0bWVzaC5kZWxldGUoIGUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Z2V0TmVpZ2hib3VyRmFjZV86IGZ1bmN0aW9uKGVkZ2UpXG5cdFx0e1xuXHRcdFx0aWYgKCFlZGdlLlJmYWNlKVxuXHRcdFx0XHRyZXR1cm4gLTE7XG5cdFx0XHRpZiAoIWVkZ2UuUmZhY2UuaW5zaWRlKVxuXHRcdFx0XHRyZXR1cm4gLTE7XG5cdFx0XHRyZXR1cm4gZWRnZS5SZmFjZS5uO1xuXHRcdH0sXG5cblx0XHRvdXRwdXRQb2x5bWVzaF86IGZ1bmN0aW9uKCBtZXNoLCBlbGVtZW50VHlwZSwgcG9seVNpemUsIHZlcnRleFNpemUgKSB7XG5cdFx0XHR2YXIgdjtcblx0XHRcdHZhciBmO1xuXHRcdFx0dmFyIGVkZ2U7XG5cdFx0XHR2YXIgbWF4RmFjZUNvdW50ID0gMDtcblx0XHRcdHZhciBtYXhWZXJ0ZXhDb3VudCA9IDA7XG5cdFx0XHR2YXIgZmFjZVZlcnRzLCBpO1xuXHRcdFx0dmFyIGVsZW1lbnRzID0gMDtcblx0XHRcdHZhciB2ZXJ0O1xuXG5cdFx0XHQvLyBBc3N1bWUgdGhhdCB0aGUgaW5wdXQgZGF0YSBpcyB0cmlhbmdsZXMgbm93LlxuXHRcdFx0Ly8gVHJ5IHRvIG1lcmdlIGFzIG1hbnkgcG9seWdvbnMgYXMgcG9zc2libGVcblx0XHRcdGlmIChwb2x5U2l6ZSA+IDMpXG5cdFx0XHR7XG5cdFx0XHRcdG1lc2gubWVyZ2VDb252ZXhGYWNlcyggcG9seVNpemUgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWFyayB1bnVzZWRcblx0XHRcdGZvciAoIHYgPSBtZXNoLnZIZWFkLm5leHQ7IHYgIT09IG1lc2gudkhlYWQ7IHYgPSB2Lm5leHQgKVxuXHRcdFx0XHR2Lm4gPSAtMTtcblxuXHRcdFx0Ly8gQ3JlYXRlIHVuaXF1ZSBJRHMgZm9yIGFsbCB2ZXJ0aWNlcyBhbmQgZmFjZXMuXG5cdFx0XHRmb3IgKCBmID0gbWVzaC5mSGVhZC5uZXh0OyBmICE9IG1lc2guZkhlYWQ7IGYgPSBmLm5leHQgKVxuXHRcdFx0e1xuXHRcdFx0XHRmLm4gPSAtMTtcblx0XHRcdFx0aWYoICFmLmluc2lkZSApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdGVkZ2UgPSBmLmFuRWRnZTtcblx0XHRcdFx0ZmFjZVZlcnRzID0gMDtcblx0XHRcdFx0ZG9cblx0XHRcdFx0e1xuXHRcdFx0XHRcdHYgPSBlZGdlLk9yZztcblx0XHRcdFx0XHRpZiAoIHYubiA9PT0gLTEgKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdHYubiA9IG1heFZlcnRleENvdW50O1xuXHRcdFx0XHRcdFx0bWF4VmVydGV4Q291bnQrKztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZmFjZVZlcnRzKys7XG5cdFx0XHRcdFx0ZWRnZSA9IGVkZ2UuTG5leHQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0d2hpbGUgKGVkZ2UgIT09IGYuYW5FZGdlKTtcblx0XHRcdFx0XG5cdFx0XHRcdGFzc2VydCggZmFjZVZlcnRzIDw9IHBvbHlTaXplICk7XG5cblx0XHRcdFx0Zi5uID0gbWF4RmFjZUNvdW50O1xuXHRcdFx0XHQrK21heEZhY2VDb3VudDtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5lbGVtZW50Q291bnQgPSBtYXhGYWNlQ291bnQ7XG5cdFx0XHRpZiAoZWxlbWVudFR5cGUgPT0gVGVzczIuQ09OTkVDVEVEX1BPTFlHT05TKVxuXHRcdFx0XHRtYXhGYWNlQ291bnQgKj0gMjtcblx0LypcdFx0dGVzcy5lbGVtZW50cyA9IChURVNTaW5kZXgqKXRlc3MtPmFsbG9jLm1lbWFsbG9jKCB0ZXNzLT5hbGxvYy51c2VyRGF0YSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdCAgc2l6ZW9mKFRFU1NpbmRleCkgKiBtYXhGYWNlQ291bnQgKiBwb2x5U2l6ZSApO1xuXHRcdFx0aWYgKCF0ZXNzLT5lbGVtZW50cylcblx0XHRcdHtcblx0XHRcdFx0dGVzcy0+b3V0T2ZNZW1vcnkgPSAxO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9Ki9cblx0XHRcdHRoaXMuZWxlbWVudHMgPSBbXTtcblx0XHRcdHRoaXMuZWxlbWVudHMubGVuZ3RoID0gbWF4RmFjZUNvdW50ICogcG9seVNpemU7XG5cdFx0XHRcblx0XHRcdHRoaXMudmVydGV4Q291bnQgPSBtYXhWZXJ0ZXhDb3VudDtcblx0LypcdFx0dGVzcy0+dmVydGljZXMgPSAoVEVTU3JlYWwqKXRlc3MtPmFsbG9jLm1lbWFsbG9jKCB0ZXNzLT5hbGxvYy51c2VyRGF0YSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdCBzaXplb2YoVEVTU3JlYWwpICogdGVzcy0+dmVydGV4Q291bnQgKiB2ZXJ0ZXhTaXplICk7XG5cdFx0XHRpZiAoIXRlc3MtPnZlcnRpY2VzKVxuXHRcdFx0e1xuXHRcdFx0XHR0ZXNzLT5vdXRPZk1lbW9yeSA9IDE7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH0qL1xuXHRcdFx0dGhpcy52ZXJ0aWNlcyA9IFtdO1xuXHRcdFx0dGhpcy52ZXJ0aWNlcy5sZW5ndGggPSBtYXhWZXJ0ZXhDb3VudCAqIHZlcnRleFNpemU7XG5cblx0LypcdFx0dGVzcy0+dmVydGV4SW5kaWNlcyA9IChURVNTaW5kZXgqKXRlc3MtPmFsbG9jLm1lbWFsbG9jKCB0ZXNzLT5hbGxvYy51c2VyRGF0YSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ICAgIHNpemVvZihURVNTaW5kZXgpICogdGVzcy0+dmVydGV4Q291bnQgKTtcblx0XHRcdGlmICghdGVzcy0+dmVydGV4SW5kaWNlcylcblx0XHRcdHtcblx0XHRcdFx0dGVzcy0+b3V0T2ZNZW1vcnkgPSAxO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9Ki9cblx0XHRcdHRoaXMudmVydGV4SW5kaWNlcyA9IFtdO1xuXHRcdFx0dGhpcy52ZXJ0ZXhJbmRpY2VzLmxlbmd0aCA9IG1heFZlcnRleENvdW50O1xuXG5cdFx0XHRcblx0XHRcdC8vIE91dHB1dCB2ZXJ0aWNlcy5cblx0XHRcdGZvciAoIHYgPSBtZXNoLnZIZWFkLm5leHQ7IHYgIT09IG1lc2gudkhlYWQ7IHYgPSB2Lm5leHQgKVxuXHRcdFx0e1xuXHRcdFx0XHRpZiAoIHYubiAhPSAtMSApXG5cdFx0XHRcdHtcblx0XHRcdFx0XHQvLyBTdG9yZSBjb29yZGluYXRlXG5cdFx0XHRcdFx0dmFyIGlkeCA9IHYubiAqIHZlcnRleFNpemU7XG5cdFx0XHRcdFx0dGhpcy52ZXJ0aWNlc1tpZHgrMF0gPSB2LmNvb3Jkc1swXTtcblx0XHRcdFx0XHR0aGlzLnZlcnRpY2VzW2lkeCsxXSA9IHYuY29vcmRzWzFdO1xuXHRcdFx0XHRcdGlmICggdmVydGV4U2l6ZSA+IDIgKVxuXHRcdFx0XHRcdFx0dGhpcy52ZXJ0aWNlc1tpZHgrMl0gPSB2LmNvb3Jkc1syXTtcblx0XHRcdFx0XHQvLyBTdG9yZSB2ZXJ0ZXggaW5kZXguXG5cdFx0XHRcdFx0dGhpcy52ZXJ0ZXhJbmRpY2VzW3Yubl0gPSB2LmlkeDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBPdXRwdXQgaW5kaWNlcy5cblx0XHRcdHZhciBuZWwgPSAwO1xuXHRcdFx0Zm9yICggZiA9IG1lc2guZkhlYWQubmV4dDsgZiAhPT0gbWVzaC5mSGVhZDsgZiA9IGYubmV4dCApXG5cdFx0XHR7XG5cdFx0XHRcdGlmICggIWYuaW5zaWRlICkgY29udGludWU7XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBTdG9yZSBwb2x5Z29uXG5cdFx0XHRcdGVkZ2UgPSBmLmFuRWRnZTtcblx0XHRcdFx0ZmFjZVZlcnRzID0gMDtcblx0XHRcdFx0ZG9cblx0XHRcdFx0e1xuXHRcdFx0XHRcdHYgPSBlZGdlLk9yZztcblx0XHRcdFx0XHR0aGlzLmVsZW1lbnRzW25lbCsrXSA9IHYubjtcblx0XHRcdFx0XHRmYWNlVmVydHMrKztcblx0XHRcdFx0XHRlZGdlID0gZWRnZS5MbmV4dDtcblx0XHRcdFx0fVxuXHRcdFx0XHR3aGlsZSAoZWRnZSAhPT0gZi5hbkVkZ2UpO1xuXHRcdFx0XHQvLyBGaWxsIHVudXNlZC5cblx0XHRcdFx0Zm9yIChpID0gZmFjZVZlcnRzOyBpIDwgcG9seVNpemU7ICsraSlcblx0XHRcdFx0XHR0aGlzLmVsZW1lbnRzW25lbCsrXSA9IC0xO1xuXG5cdFx0XHRcdC8vIFN0b3JlIHBvbHlnb24gY29ubmVjdGl2aXR5XG5cdFx0XHRcdGlmICggZWxlbWVudFR5cGUgPT0gVGVzczIuQ09OTkVDVEVEX1BPTFlHT05TIClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGVkZ2UgPSBmLmFuRWRnZTtcblx0XHRcdFx0XHRkb1xuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdHRoaXMuZWxlbWVudHNbbmVsKytdID0gdGhpcy5nZXROZWlnaGJvdXJGYWNlXyggZWRnZSApO1xuXHRcdFx0XHRcdFx0ZWRnZSA9IGVkZ2UuTG5leHQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHdoaWxlIChlZGdlICE9PSBmLmFuRWRnZSk7XG5cdFx0XHRcdFx0Ly8gRmlsbCB1bnVzZWQuXG5cdFx0XHRcdFx0Zm9yIChpID0gZmFjZVZlcnRzOyBpIDwgcG9seVNpemU7ICsraSlcblx0XHRcdFx0XHRcdHRoaXMuZWxlbWVudHNbbmVsKytdID0gLTE7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdC8vXHR2b2lkIE91dHB1dENvbnRvdXJzKCBURVNTdGVzc2VsYXRvciAqdGVzcywgVEVTU21lc2ggKm1lc2gsIGludCB2ZXJ0ZXhTaXplIClcblx0XHRvdXRwdXRDb250b3Vyc186IGZ1bmN0aW9uKCBtZXNoLCB2ZXJ0ZXhTaXplICkge1xuXHRcdFx0dmFyIGY7XG5cdFx0XHR2YXIgZWRnZTtcblx0XHRcdHZhciBzdGFydDtcblx0XHRcdHZhciB2ZXJ0cztcblx0XHRcdHZhciBlbGVtZW50cztcblx0XHRcdHZhciB2ZXJ0SW5kcztcblx0XHRcdHZhciBzdGFydFZlcnQgPSAwO1xuXHRcdFx0dmFyIHZlcnRDb3VudCA9IDA7XG5cblx0XHRcdHRoaXMudmVydGV4Q291bnQgPSAwO1xuXHRcdFx0dGhpcy5lbGVtZW50Q291bnQgPSAwO1xuXG5cdFx0XHRmb3IgKCBmID0gbWVzaC5mSGVhZC5uZXh0OyBmICE9PSBtZXNoLmZIZWFkOyBmID0gZi5uZXh0IClcblx0XHRcdHtcblx0XHRcdFx0aWYgKCAhZi5pbnNpZGUgKSBjb250aW51ZTtcblxuXHRcdFx0XHRzdGFydCA9IGVkZ2UgPSBmLmFuRWRnZTtcblx0XHRcdFx0ZG9cblx0XHRcdFx0e1xuXHRcdFx0XHRcdHRoaXMudmVydGV4Q291bnQrKztcblx0XHRcdFx0XHRlZGdlID0gZWRnZS5MbmV4dDtcblx0XHRcdFx0fVxuXHRcdFx0XHR3aGlsZSAoIGVkZ2UgIT09IHN0YXJ0ICk7XG5cblx0XHRcdFx0dGhpcy5lbGVtZW50Q291bnQrKztcblx0XHRcdH1cblxuXHQvKlx0XHR0ZXNzLT5lbGVtZW50cyA9IChURVNTaW5kZXgqKXRlc3MtPmFsbG9jLm1lbWFsbG9jKCB0ZXNzLT5hbGxvYy51c2VyRGF0YSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdCAgc2l6ZW9mKFRFU1NpbmRleCkgKiB0ZXNzLT5lbGVtZW50Q291bnQgKiAyICk7XG5cdFx0XHRpZiAoIXRlc3MtPmVsZW1lbnRzKVxuXHRcdFx0e1xuXHRcdFx0XHR0ZXNzLT5vdXRPZk1lbW9yeSA9IDE7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH0qL1xuXHRcdFx0dGhpcy5lbGVtZW50cyA9IFtdO1xuXHRcdFx0dGhpcy5lbGVtZW50cy5sZW5ndGggPSB0aGlzLmVsZW1lbnRDb3VudCAqIDI7XG5cdFx0XHRcblx0LypcdFx0dGVzcy0+dmVydGljZXMgPSAoVEVTU3JlYWwqKXRlc3MtPmFsbG9jLm1lbWFsbG9jKCB0ZXNzLT5hbGxvYy51c2VyRGF0YSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdCAgc2l6ZW9mKFRFU1NyZWFsKSAqIHRlc3MtPnZlcnRleENvdW50ICogdmVydGV4U2l6ZSApO1xuXHRcdFx0aWYgKCF0ZXNzLT52ZXJ0aWNlcylcblx0XHRcdHtcblx0XHRcdFx0dGVzcy0+b3V0T2ZNZW1vcnkgPSAxO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9Ki9cblx0XHRcdHRoaXMudmVydGljZXMgPSBbXTtcblx0XHRcdHRoaXMudmVydGljZXMubGVuZ3RoID0gdGhpcy52ZXJ0ZXhDb3VudCAqIHZlcnRleFNpemU7XG5cblx0LypcdFx0dGVzcy0+dmVydGV4SW5kaWNlcyA9IChURVNTaW5kZXgqKXRlc3MtPmFsbG9jLm1lbWFsbG9jKCB0ZXNzLT5hbGxvYy51c2VyRGF0YSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ICAgIHNpemVvZihURVNTaW5kZXgpICogdGVzcy0+dmVydGV4Q291bnQgKTtcblx0XHRcdGlmICghdGVzcy0+dmVydGV4SW5kaWNlcylcblx0XHRcdHtcblx0XHRcdFx0dGVzcy0+b3V0T2ZNZW1vcnkgPSAxO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9Ki9cblx0XHRcdHRoaXMudmVydGV4SW5kaWNlcyA9IFtdO1xuXHRcdFx0dGhpcy52ZXJ0ZXhJbmRpY2VzLmxlbmd0aCA9IHRoaXMudmVydGV4Q291bnQ7XG5cblx0XHRcdHZhciBudiA9IDA7XG5cdFx0XHR2YXIgbnZpID0gMDtcblx0XHRcdHZhciBuZWwgPSAwO1xuXHRcdFx0c3RhcnRWZXJ0ID0gMDtcblxuXHRcdFx0Zm9yICggZiA9IG1lc2guZkhlYWQubmV4dDsgZiAhPT0gbWVzaC5mSGVhZDsgZiA9IGYubmV4dCApXG5cdFx0XHR7XG5cdFx0XHRcdGlmICggIWYuaW5zaWRlICkgY29udGludWU7XG5cblx0XHRcdFx0dmVydENvdW50ID0gMDtcblx0XHRcdFx0c3RhcnQgPSBlZGdlID0gZi5hbkVkZ2U7XG5cdFx0XHRcdGRvXG5cdFx0XHRcdHtcblx0XHRcdFx0XHR0aGlzLnZlcnRpY2VzW252KytdID0gZWRnZS5PcmcuY29vcmRzWzBdO1xuXHRcdFx0XHRcdHRoaXMudmVydGljZXNbbnYrK10gPSBlZGdlLk9yZy5jb29yZHNbMV07XG5cdFx0XHRcdFx0aWYgKCB2ZXJ0ZXhTaXplID4gMiApXG5cdFx0XHRcdFx0XHR0aGlzLnZlcnRpY2VzW252KytdID0gZWRnZS5PcmcuY29vcmRzWzJdO1xuXHRcdFx0XHRcdHRoaXMudmVydGV4SW5kaWNlc1tudmkrK10gPSBlZGdlLk9yZy5pZHg7XG5cdFx0XHRcdFx0dmVydENvdW50Kys7XG5cdFx0XHRcdFx0ZWRnZSA9IGVkZ2UuTG5leHQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0d2hpbGUgKCBlZGdlICE9PSBzdGFydCApO1xuXG5cdFx0XHRcdHRoaXMuZWxlbWVudHNbbmVsKytdID0gc3RhcnRWZXJ0O1xuXHRcdFx0XHR0aGlzLmVsZW1lbnRzW25lbCsrXSA9IHZlcnRDb3VudDtcblxuXHRcdFx0XHRzdGFydFZlcnQgKz0gdmVydENvdW50O1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRhZGRDb250b3VyOiBmdW5jdGlvbiggc2l6ZSwgdmVydGljZXMgKVxuXHRcdHtcblx0XHRcdHZhciBlO1xuXHRcdFx0dmFyIGk7XG5cblx0XHRcdGlmICggdGhpcy5tZXNoID09PSBudWxsIClcblx0XHRcdCAgXHR0aGlzLm1lc2ggPSBuZXcgVEVTU21lc2goKTtcblx0LypcdCBcdGlmICggdGVzcy0+bWVzaCA9PSBOVUxMICkge1xuXHRcdFx0XHR0ZXNzLT5vdXRPZk1lbW9yeSA9IDE7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH0qL1xuXG5cdFx0XHRpZiAoIHNpemUgPCAyIClcblx0XHRcdFx0c2l6ZSA9IDI7XG5cdFx0XHRpZiAoIHNpemUgPiAzIClcblx0XHRcdFx0c2l6ZSA9IDM7XG5cblx0XHRcdGUgPSBudWxsO1xuXG5cdFx0XHRmb3IoIGkgPSAwOyBpIDwgdmVydGljZXMubGVuZ3RoOyBpICs9IHNpemUgKVxuXHRcdFx0e1xuXHRcdFx0XHRpZiggZSA9PSBudWxsICkge1xuXHRcdFx0XHRcdC8qIE1ha2UgYSBzZWxmLWxvb3AgKG9uZSB2ZXJ0ZXgsIG9uZSBlZGdlKS4gKi9cblx0XHRcdFx0XHRlID0gdGhpcy5tZXNoLm1ha2VFZGdlKCk7XG5cdC8qXHRcdFx0XHRpZiAoIGUgPT0gTlVMTCApIHtcblx0XHRcdFx0XHRcdHRlc3MtPm91dE9mTWVtb3J5ID0gMTtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9Ki9cblx0XHRcdFx0XHR0aGlzLm1lc2guc3BsaWNlKCBlLCBlLlN5bSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8qIENyZWF0ZSBhIG5ldyB2ZXJ0ZXggYW5kIGVkZ2Ugd2hpY2ggaW1tZWRpYXRlbHkgZm9sbG93IGVcblx0XHRcdFx0XHQqIGluIHRoZSBvcmRlcmluZyBhcm91bmQgdGhlIGxlZnQgZmFjZS5cblx0XHRcdFx0XHQqL1xuXHRcdFx0XHRcdHRoaXMubWVzaC5zcGxpdEVkZ2UoIGUgKTtcblx0XHRcdFx0XHRlID0gZS5MbmV4dDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8qIFRoZSBuZXcgdmVydGV4IGlzIG5vdyBlLT5PcmcuICovXG5cdFx0XHRcdGUuT3JnLmNvb3Jkc1swXSA9IHZlcnRpY2VzW2krMF07XG5cdFx0XHRcdGUuT3JnLmNvb3Jkc1sxXSA9IHZlcnRpY2VzW2krMV07XG5cdFx0XHRcdGlmICggc2l6ZSA+IDIgKVxuXHRcdFx0XHRcdGUuT3JnLmNvb3Jkc1syXSA9IHZlcnRpY2VzW2krMl07XG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRlLk9yZy5jb29yZHNbMl0gPSAwLjA7XG5cdFx0XHRcdC8qIFN0b3JlIHRoZSBpbnNlcnRpb24gbnVtYmVyIHNvIHRoYXQgdGhlIHZlcnRleCBjYW4gYmUgbGF0ZXIgcmVjb2duaXplZC4gKi9cblx0XHRcdFx0ZS5PcmcuaWR4ID0gdGhpcy52ZXJ0ZXhJbmRleENvdW50ZXIrKztcblxuXHRcdFx0XHQvKiBUaGUgd2luZGluZyBvZiBhbiBlZGdlIHNheXMgaG93IHRoZSB3aW5kaW5nIG51bWJlciBjaGFuZ2VzIGFzIHdlXG5cdFx0XHRcdCogY3Jvc3MgZnJvbSB0aGUgZWRnZScncyByaWdodCBmYWNlIHRvIGl0cyBsZWZ0IGZhY2UuICBXZSBhZGQgdGhlXG5cdFx0XHRcdCogdmVydGljZXMgaW4gc3VjaCBhbiBvcmRlciB0aGF0IGEgQ0NXIGNvbnRvdXIgd2lsbCBhZGQgKzEgdG9cblx0XHRcdFx0KiB0aGUgd2luZGluZyBudW1iZXIgb2YgdGhlIHJlZ2lvbiBpbnNpZGUgdGhlIGNvbnRvdXIuXG5cdFx0XHRcdCovXG5cdFx0XHRcdGUud2luZGluZyA9IDE7XG5cdFx0XHRcdGUuU3ltLndpbmRpbmcgPSAtMTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdC8vXHRpbnQgdGVzc1Rlc3NlbGF0ZSggVEVTU3Rlc3NlbGF0b3IgKnRlc3MsIGludCB3aW5kaW5nUnVsZSwgaW50IGVsZW1lbnRUeXBlLCBpbnQgcG9seVNpemUsIGludCB2ZXJ0ZXhTaXplLCBjb25zdCBURVNTcmVhbCogbm9ybWFsIClcblx0XHR0ZXNzZWxhdGU6IGZ1bmN0aW9uKCB3aW5kaW5nUnVsZSwgZWxlbWVudFR5cGUsIHBvbHlTaXplLCB2ZXJ0ZXhTaXplLCBub3JtYWwgKSB7XG5cdFx0XHR0aGlzLnZlcnRpY2VzID0gW107XG5cdFx0XHR0aGlzLmVsZW1lbnRzID0gW107XG5cdFx0XHR0aGlzLnZlcnRleEluZGljZXMgPSBbXTtcblxuXHRcdFx0dGhpcy52ZXJ0ZXhJbmRleENvdW50ZXIgPSAwO1xuXHRcdFx0XG5cdFx0XHRpZiAobm9ybWFsKVxuXHRcdFx0e1xuXHRcdFx0XHR0aGlzLm5vcm1hbFswXSA9IG5vcm1hbFswXTtcblx0XHRcdFx0dGhpcy5ub3JtYWxbMV0gPSBub3JtYWxbMV07XG5cdFx0XHRcdHRoaXMubm9ybWFsWzJdID0gbm9ybWFsWzJdO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLndpbmRpbmdSdWxlID0gd2luZGluZ1J1bGU7XG5cblx0XHRcdGlmICh2ZXJ0ZXhTaXplIDwgMilcblx0XHRcdFx0dmVydGV4U2l6ZSA9IDI7XG5cdFx0XHRpZiAodmVydGV4U2l6ZSA+IDMpXG5cdFx0XHRcdHZlcnRleFNpemUgPSAzO1xuXG5cdC8qXHRcdGlmIChzZXRqbXAodGVzcy0+ZW52KSAhPSAwKSB7IFxuXHRcdFx0XHQvLyBjb21lIGJhY2sgaGVyZSBpZiBvdXQgb2YgbWVtb3J5XG5cdFx0XHRcdHJldHVybiAwO1xuXHRcdFx0fSovXG5cblx0XHRcdGlmICghdGhpcy5tZXNoKVxuXHRcdFx0e1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdC8qIERldGVybWluZSB0aGUgcG9seWdvbiBub3JtYWwgYW5kIHByb2plY3QgdmVydGljZXMgb250byB0aGUgcGxhbmVcblx0XHRcdCogb2YgdGhlIHBvbHlnb24uXG5cdFx0XHQqL1xuXHRcdFx0dGhpcy5wcm9qZWN0UG9seWdvbl8oKTtcblxuXHRcdFx0LyogdGVzc0NvbXB1dGVJbnRlcmlvciggdGVzcyApIGNvbXB1dGVzIHRoZSBwbGFuYXIgYXJyYW5nZW1lbnQgc3BlY2lmaWVkXG5cdFx0XHQqIGJ5IHRoZSBnaXZlbiBjb250b3VycywgYW5kIGZ1cnRoZXIgc3ViZGl2aWRlcyB0aGlzIGFycmFuZ2VtZW50XG5cdFx0XHQqIGludG8gcmVnaW9ucy4gIEVhY2ggcmVnaW9uIGlzIG1hcmtlZCBcImluc2lkZVwiIGlmIGl0IGJlbG9uZ3Ncblx0XHRcdCogdG8gdGhlIHBvbHlnb24sIGFjY29yZGluZyB0byB0aGUgcnVsZSBnaXZlbiBieSB0ZXNzLT53aW5kaW5nUnVsZS5cblx0XHRcdCogRWFjaCBpbnRlcmlvciByZWdpb24gaXMgZ3VhcmFudGVlZCBiZSBtb25vdG9uZS5cblx0XHRcdCovXG5cdFx0XHRTd2VlcC5jb21wdXRlSW50ZXJpb3IoIHRoaXMgKTtcblxuXHRcdFx0dmFyIG1lc2ggPSB0aGlzLm1lc2g7XG5cblx0XHRcdC8qIElmIHRoZSB1c2VyIHdhbnRzIG9ubHkgdGhlIGJvdW5kYXJ5IGNvbnRvdXJzLCB3ZSB0aHJvdyBhd2F5IGFsbCBlZGdlc1xuXHRcdFx0KiBleGNlcHQgdGhvc2Ugd2hpY2ggc2VwYXJhdGUgdGhlIGludGVyaW9yIGZyb20gdGhlIGV4dGVyaW9yLlxuXHRcdFx0KiBPdGhlcndpc2Ugd2UgdGVzc2VsbGF0ZSBhbGwgdGhlIHJlZ2lvbnMgbWFya2VkIFwiaW5zaWRlXCIuXG5cdFx0XHQqL1xuXHRcdFx0aWYgKGVsZW1lbnRUeXBlID09IFRlc3MyLkJPVU5EQVJZX0NPTlRPVVJTKSB7XG5cdFx0XHRcdHRoaXMuc2V0V2luZGluZ051bWJlcl8oIG1lc2gsIDEsIHRydWUgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMudGVzc2VsbGF0ZUludGVyaW9yXyggbWVzaCApOyBcblx0XHRcdH1cblx0Ly9cdFx0aWYgKHJjID09IDApIGxvbmdqbXAodGVzcy0+ZW52LDEpOyAgLyogY291bGQndmUgdXNlZCBhIGxhYmVsICovXG5cblx0XHRcdG1lc2guY2hlY2soKTtcblxuXHRcdFx0aWYgKGVsZW1lbnRUeXBlID09IFRlc3MyLkJPVU5EQVJZX0NPTlRPVVJTKSB7XG5cdFx0XHRcdHRoaXMub3V0cHV0Q29udG91cnNfKCBtZXNoLCB2ZXJ0ZXhTaXplICk7ICAgICAvKiBvdXRwdXQgY29udG91cnMgKi9cblx0XHRcdH1cblx0XHRcdGVsc2Vcblx0XHRcdHtcblx0XHRcdFx0dGhpcy5vdXRwdXRQb2x5bWVzaF8oIG1lc2gsIGVsZW1lbnRUeXBlLCBwb2x5U2l6ZSwgdmVydGV4U2l6ZSApOyAgICAgLyogb3V0cHV0IHBvbHlnb25zICovXG5cdFx0XHR9XG5cbi8vXHRcdFx0dGVzcy5tZXNoID0gbnVsbDtcblxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHR9OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcmFuZ2UobWluLCBtYXgsIHZhbHVlKSB7XG4gIHJldHVybiAodmFsdWUgLSBtaW4pIC8gKG1heCAtIG1pbilcbn0iLCJtb2R1bGUuZXhwb3J0cz1yZXF1aXJlKFwiL3Byb2plY3RzL2JsYWNraWNlL25vZGVfbW9kdWxlcy90aHJlZS1zZGYtdGV4dC9ub2RlX21vZHVsZXMveHRlbmQvaW1tdXRhYmxlLmpzXCIpIl19
